Index: busybox_1_7_stable/docs/mdev.txt
===================================================================
--- busybox_1_7_stable/docs/mdev.txt	(revision 632)
+++ busybox_1_7_stable/docs/mdev.txt	(revision 633)
@@ -44,29 +44,48 @@
 660 permissions.
 
 The file has the format:
-	<device regex> <uid>:<gid> <octal permissions>
-For example:
+
+    For symlinks:
+	symlink -> target
+    For example:
+	core -> /proc/kcore
+	ram -> ram1
+	stderr -> /proc/self/fd/2
+	stdin -> /proc/self/fd/0
+	stdout -> /proc/self/fd/1
+	...
+  
+    For devices
+	<device regex> <uid>:<gid> <octal permissions> [ [<\>>\> </dev/device/path> <octal permissions>] ]
+    For example:
 	hd[a-z][0-9]* 0:3 660
+	fd0	0:11 0660
+	event[0-9] 0:0 0600 >> /dev/input 0755
+	pcmC[0-9]D[0-9]c 0:0 0666 >> /dev/snd/ 0755
 
-The config file parsing stops at the first matching line.  If no line is
-matched, then the default of 0:0 660 is used.  To set your own default, simply
-create your own total match like so:
-	.* 1:1 777
+    The device name can be restricted by using subexpressions in the regex. For example to create /dev/mtdblock/1 use:
+	mtdblock([0-9]) 0:0 0666 >> /dev/mtdblock/ 0755
 
-If you also enable support for executing your own commands, then the file has
-the format:
-	<device regex> <uid>:<gid> <octal permissions> [<@|$|*> <command>]
-The special characters have the meaning:
+    If you want to execute a special command, then the file has the format:
+	<device regex> <uid>:<gid> <octal permissions> [ [<\>>\> </dev/device/patht> <octal permissions>]] [<@|$|*> <command>] ]
+    The special characters have the meaning:
 	@ Run after creating the device.
 	$ Run before removing the device.
 	* Run both after creating and before removing the device.
 
-The command is executed via the system() function (which means you're giving a
-command to the shell), so make sure you have a shell installed at /bin/sh.
+    For example:
+	urandom 0:0 444 * echo "HI URANDOM !"
+	pcmC[0-9]D[0-9]c 0:0 0666 >> /dev/snd 0755 @echo "HELLO PCMC_D_C !"
 
-For your convenience, the shell env var $MDEV is set to the device name.  So if
-the device 'hdc' was matched, MDEV would be set to "hdc".
+    The command is executed via the system() function (which means you're giving a
+    command to the shell), so make sure you have a shell installed at /bin/sh.
 
+    For your convenience, the shell env var $MDEV is set to the device name.  So if
+    the device 'hdc' was matched, MDEV would be set to "hdc".
+
+    For example:
+	pcmC[0-9]D[0-9]c 0:0 0666 >> /dev/snd 0755 @echo "HELLO  $MDEV !"
+
 ----------
  FIRMWARE
 ----------
Index: busybox_1_7_stable/util-linux/mdev.c
===================================================================
--- busybox_1_7_stable/util-linux/mdev.c	(revision 632)
+++ busybox_1_7_stable/util-linux/mdev.c	(revision 633)
@@ -21,12 +21,20 @@
 
 #define MAX_SYSFS_DEPTH 3 /* prevent infinite loops in /sys symlinks */
 
+static void mdev_symlink(char *m_target, char *m_link)
+{
+	if (!m_target || !m_link) return;
+	if (symlink(m_target, m_link) && errno != EEXIST)
+		bb_perror_msg_and_die("symlink %s", m_link);
+}
+
 /* mknod in /dev based on a path like "/sys/block/hda/hda1" */
 static void make_device(char *path, int delete)
 {
-	const char *device_name;
-	int major, minor, type, len;
-	int mode = 0660;
+ 	const char *device_name;
+	char *device_path = NULL;
+ 	int major, minor, type, len, mk_dir=0;
+ 	mode_t mode = 0660, mode_path = 0660;
 	uid_t uid = 0;
 	gid_t gid = 0;
 	char *temp = path + strlen(path);
@@ -47,134 +55,171 @@
 	/* Determine device name, type, major and minor */
 
 	device_name = bb_basename(path);
-	type = path[5]=='c' ? S_IFCHR : S_IFBLK;
+	type = (path[5]=='b') ? S_IFBLK : S_IFCHR;
 
 	/* If we have a config file, look up permissions for this device */
 
 	if (ENABLE_FEATURE_MDEV_CONF) {
-		char *conf, *pos, *end;
-		int line, fd;
+		char *line, *tok_tmp, *tok_line=NULL, **tok = NULL;
+		FILE *file;
+		int i;
+  
+		file = fopen_or_warn("/etc/mdev.conf", "r");
+		if (file < 0)
+  			goto end_parse;
+  
+		while ((line = xmalloc_getline(file)) != NULL) {
+			char *regex = NULL;
+			regex_t match;
+			regmatch_t off[2];
+			int result, tok_len = 1;
+			char *tok_id[2], *tok_id_tmp;
+			char *s;
+  
+			tok_line = strdupa(line);
+			if (tok_line[0] == '#' || strlen(tok_line)==0) continue;
+  
+			for (i=0; i<strlen(tok_line); i++) {
+				if (isspace(tok_line[i]) && !isspace(tok_line[i+1]))
+					tok_len++;
+			}
+			tok = (char **) xrealloc(tok, tok_len * sizeof(char *));
+  
+			for (i=0; (tok_tmp=strtok(tok_line, " \t")); i++) {
+				tok[i] = tok_tmp;
+				tok_line = NULL;
+			}
+  
+			if (!strcmp(tok[1], "->")) {
+				mdev_symlink(tok[2], tok[0]);
+				continue;
+			}
+  
+			/* Regex to match this device */
+			regex = tok[0];
+			xregcomp(&match, regex, REG_EXTENDED);
+			result = regexec(&match, device_name, 2, off, 0);
+			regfree(&match);
+  
+			/* If not this device, skip rest of line */
+			if (result || off[0].rm_so || off[0].rm_eo != strlen(device_name)) {
+				continue;
+			}
 
-		/* mmap the config file */
-		fd = open("/etc/mdev.conf", O_RDONLY);
-		if (fd < 0)
-			goto end_parse;
-		len = xlseek(fd, 0, SEEK_END);
-		conf = mmap(NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);
-		close(fd);
-		if (!conf)
-			goto end_parse;
+			/* use substring for device name */
+			if (off[1].rm_so != -1) {
+				int sub_len = off[1].rm_eo - off[1].rm_so;
+				char *tmp = alloca(sub_len + 1);
+				strncpy(tmp, device_name + off[1].rm_so, sub_len);
+				tmp[sub_len] = '\0';
+				device_name = tmp;
+			}
+  
+			for (i=0; (tok_id_tmp=strtok(tok[1], ":")); i++) {
+				if (tok_id_tmp) tok_id[i] = tok_id_tmp;
+				tok[1] = NULL;
+			}
+  
+			/* uid:gid */
+			uid = strtoul(tok_id[0], &s, 10);
+			if (tok_id[0] == s) {
+				struct passwd *pass;
+				pass = getpwnam(tok_id[0]);
+				if (!pass) continue;
+				uid = pass->pw_uid;
+			}
+  
+			gid = strtoul(tok_id[1], &s, 10);
+			if (tok_id[1] == s) {
+				struct group *grp;
+				grp = getgrnam(tok_id[1]);
+				if (!grp) continue;
+				gid = grp->gr_gid;
+			}
 
-		line = 0;
-		/* Loop through lines in mmaped file*/
-		for (pos=conf; pos-conf<len;) {
-			int field;
-			char *end2;
+			/* mode */
+			mode = (mode_t)strtoul(tok[2], &s, 8);
 
-			line++;
-			/* find end of this line */
-			for (end=pos; end-conf<len && *end!='\n'; end++)
-				;
+			if (tok_len > 3) {
+#if ENABLE_FEATURE_MDEV_EXEC
+				const char *s2 = "@$*";
+				char *cmd_tmp;
+				unsigned int cmd = 0;
+#endif
+				/* mk_dir */
+				if (!strcmp(tok[3], ">>")) {
+					int path_len;
 
-			/* Three fields: regex, uid:gid, mode */
-			for (field=0; field < (3 + ENABLE_FEATURE_MDEV_EXEC);
-					field++)
-			{
-				/* Skip whitespace */
-				while (pos<end && isspace(*pos)) pos++;
-				if (pos==end || *pos=='#') break;
-				for (end2=pos;
-					end2<end && !isspace(*end2) && *end2!='#'; end2++)
-					;
+					mk_dir = 1;
+					device_path = strdupa(tok[4]);
+					path_len = strlen(device_path);
+					if (device_path[path_len-1] != '/')
+						strcat(device_path, "/");
 
-				if (field == 0) {
-					/* Regex to match this device */
+					mode_path = (mode_t)strtoul(tok[5], &s, 8);
+  				}
+#if ENABLE_FEATURE_MDEV_EXEC
+				else {
+					if ((cmd_tmp = strpbrk(tok[3], s2))!=NULL) {
+						int cmd_len = strlen(cmd_tmp) == 1 ? 1 : 0;
 
-					char *regex = xstrndup(pos, end2-pos);
-					regex_t match;
-					regmatch_t off;
-					int result;
+						cmd = *cmd_tmp;
 
-					/* Is this it? */
-					xregcomp(&match,regex, REG_EXTENDED);
-					result = regexec(&match, device_name, 1, &off, 0);
-					regfree(&match);
-					free(regex);
+						if (cmd_len == 1) {
+							command = strdupa(tok[4]);
+						} else {
+							command = strdupa(strrchr(tok[3], cmd_tmp[0])+1);
+						}
 
-					/* If not this device, skip rest of line */
-					if (result || off.rm_so
-							|| off.rm_eo != strlen(device_name))
-						break;
-				}
-				if (field == 1) {
-					/* uid:gid */
-
-					char *s, *s2;
-
-					/* Find : */
-					for (s=pos; s<end2 && *s!=':'; s++)
-						;
-					if (s == end2) break;
-
-					/* Parse UID */
-					uid = strtoul(pos, &s2, 10);
-					if (s != s2) {
-						struct passwd *pass;
-						char *_unam = xstrndup(pos, s-pos);
-						pass = getpwnam(_unam);
-						free(_unam);
-						if (!pass) break;
-						uid = pass->pw_uid;
+						for (i=4+cmd_len; i<tok_len; i++) {
+							strcat(strcat(command, " "), tok[i]);
+						}
+  					}
+					
+  				}
+  
+				if (tok_len > 6) {
+					if ((cmd_tmp = strpbrk(tok[6], s2))!=NULL) {
+						int cmd_len = strlen(cmd_tmp) == 1 ? 1 : 0;
+  
+						cmd = *cmd_tmp;
+  
+						if (cmd_len == 1) {
+							command = xstrdup(tok[7]);
+						} else {
+							command = xstrdup(strrchr(tok[6], cmd_tmp[0])+1);
+						}
+  
+						for (i=7+cmd_len; i<tok_len; i++) {
+							strcat(strcat(command, " "), tok[i]);
+						}
 					}
-					s++;
-					/* parse GID */
-					gid = strtoul(s, &s2, 10);
-					if (end2 != s2) {
-						struct group *grp;
-						char *_grnam = xstrndup(s, end2-s);
-						grp = getgrnam(_grnam);
-						free(_grnam);
-						if (!grp) break;
-						gid = grp->gr_gid;
-					}
 				}
-				if (field == 2) {
-					/* mode */
-
-					mode = strtoul(pos, &pos, 8);
-					if (pos != end2) break;
+				switch (cmd) {
+				case '@':
+					if (delete) command = NULL;
+					break;
+				case '$':
+					if (!delete) command = NULL;
+					break;
+				case '*':
+				default :
+					break;
 				}
-				if (ENABLE_FEATURE_MDEV_EXEC && field == 3) {
-					// Command to run
-					const char *s = "@$*";
-					const char *s2;
-					s2 = strchr(s, *pos++);
-					if (!s2) {
-						// Force error
-						field = 1;
-						break;
-					}
-					if ((s2-s+1) & (1<<delete))
-						command = xstrndup(pos, end-pos);
-				}
-
-				pos = end2;
+#endif
 			}
-
-			/* Did everything parse happily? */
-
-			if (field > 2) break;
-			if (field) bb_error_msg_and_die("bad line %d",line);
-
-			/* Next line */
-			pos = ++end;
-		}
-		munmap(conf, len);
+  		}
+		fclose(file);
  end_parse:	/* nothing */ ;
 	}
 
 	umask(0);
 	if (!delete) {
+		if (mk_dir) {
+			if (mkdir(device_path, mode_path) && errno != EEXIST)
+				bb_perror_msg_and_die("mkdir %s", device_path);
+			device_name = strcat(device_path, device_name);
+		}
 		if (sscanf(temp, "%d:%d", &major, &minor) != 2) return;
 		if (mknod(device_name, mode | type, makedev(major, minor)) && errno != EEXIST)
 			bb_perror_msg_and_die("mknod %s", device_name);
@@ -184,6 +229,7 @@
 
 		if (ENABLE_FEATURE_MDEV_CONF) chown(device_name, uid, gid);
 	}
+
 	if (command) {
 		/* setenv will leak memory, so use putenv */
 		char *s = xasprintf("MDEV=%s", device_name);
@@ -193,9 +239,24 @@
 		s[4] = '\0';
 		unsetenv(s);
 		free(s);
-		free(command);
 	}
-	if (delete) unlink(device_name);
+
+	if (delete) {
+		if (device_path) {
+			char *tmp_path;
+
+			tmp_path = strdupa(device_path);
+			device_name = strcat(tmp_path, device_name);
+		}
+
+		unlink(device_name);
+
+		if (device_path) {
+			if (rmdir(device_path) && errno != ENOTEMPTY)
+				bb_perror_msg_and_die("rmdir %s", device_path);
+		}
+	}
+
 }
 
 /* File callback for /sys/ traversal */
@@ -287,8 +348,8 @@
 	}
 }
 
-int mdev_main(int argc, char **argv);
-int mdev_main(int argc, char **argv)
+int mdev_main(int argc, char *argv[]);
+int mdev_main(int argc, char *argv[])
 {
 	char *action;
 	char *env_path;
