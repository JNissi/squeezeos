From 1a773fc43540a467c8652ef16d0f7e63e61c93f4 Mon Sep 17 00:00:00 2001
From: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
Date: Wed, 3 Dec 2008 16:08:46 +0200
Subject: [PATCH] UBIFS: remove prepare_write compat code

Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
---
 fs/ubifs/budget.c |    9 --
 fs/ubifs/compat.c |  251 -----------------------------------------------------
 fs/ubifs/compat.h |   13 ---
 fs/ubifs/debug.c  |    6 --
 fs/ubifs/file.c   |   15 ---
 fs/ubifs/ubifs.h  |    3 -
 6 files changed, 0 insertions(+), 297 deletions(-)

diff --git a/fs/ubifs/budget.c b/fs/ubifs/budget.c
index 3aa5384..1a4973e 100644
--- a/fs/ubifs/budget.c
+++ b/fs/ubifs/budget.c
@@ -75,8 +75,6 @@ struct retries_info {
 	unsigned int nospc_retries:1;
 };
 
-/* TODO: remove compatibility stuff as late as possible */
-#ifndef UBIFS_COMPAT_USE_OLD_PREPARE_WRITE
 /**
  * shrink_liability - write-back some dirty pages/inodes.
  * @c: UBIFS file-system description object
@@ -250,7 +248,6 @@ static int make_free_space(struct ubifs_info *c, struct retries_info *ri)
 	}
 	return -ENOSPC;
 }
-#endif /* UBIFS_COMPAT_USE_OLD_PREPARE_WRITE */
 
 /**
  * ubifs_calc_min_idx_lebs - calculate amount of eraseblocks for the index.
@@ -590,13 +587,7 @@ again:
 		return err;
 	}
 
-/* TODO: remove compatibility stuff as late as possible */
-#ifdef UBIFS_COMPAT_USE_OLD_PREPARE_WRITE
-	err = ubifs_make_free_space(c, &ri, req->locked_pg);
-#else
 	err = make_free_space(c, &ri);
-#endif
-
 	if (err == -EAGAIN) {
 		dbg_budg("try again");
 		cond_resched();
diff --git a/fs/ubifs/compat.c b/fs/ubifs/compat.c
index 127361a..061220d 100644
--- a/fs/ubifs/compat.c
+++ b/fs/ubifs/compat.c
@@ -57,254 +57,3 @@ void ubifs_hexdump(const void *ptr, int size)
 	}
 }
 #endif /* LINUX_VERSION_CODE < 2.6.23 */
-
-#ifdef UBIFS_COMPAT_USE_OLD_PREPARE_WRITE
-int ubifs_prepare_write(struct file *file, struct page *page, unsigned from,
-			unsigned to)
-{
-	struct inode *inode = page->mapping->host;
-	struct ubifs_info *c = inode->i_sb->s_fs_info;
-	loff_t pos = ((loff_t)page->index << PAGE_CACHE_SHIFT) + to;
-	struct ubifs_budget_req req;
-	int err;
-
-	ubifs_assert(!(inode->i_sb->s_flags & MS_RDONLY));
-
-	if (unlikely(c->ro_media))
-		return -EROFS;
-
-	if (!PageUptodate(page)) {
-		/*
-		 * The page is not loaded from the flash and has to be loaded
-		 * unless we are writing all of it.
-		 */
-		if (from == 0 && to == PAGE_CACHE_SIZE)
-			/*
-			 * Set the PG_checked flag to make the further code
-			 * allocate full budget, because we do not know whether
-			 * the page exists on the flash media or not.
-			 */
-			SetPageChecked(page);
-		else {
-			err = do_readpage(page);
-			if (err)
-				return err;
-		}
-
-		SetPageUptodate(page);
-		ClearPageError(page);
-	}
-
-	memset(&req, 0, sizeof(struct ubifs_budget_req));
-	if (!PagePrivate(page)) {
-		/*
-		 * If the PG_Checked flag is set, the page corresponds to a
-		 * hole or to a place beyond the inode. In this case we have to
-		 * budget for a new page, otherwise for a dirtied page.
-		 */
-		if (PageChecked(page))
-			req.new_page = 1;
-		else
-			req.dirtied_page = 1;
-	} else
-		req.locked_pg = 1;
-
-	if (pos > inode->i_size)
-		/*
-		 * We are writing beyond the file which means we are going to
-		 * change inode size and make the inode dirty. And in turn,
-		 * this means we have to budget for making the inode dirty.
-		 */
-		req.dirtied_ino = 1;
-
-	err = ubifs_budget_space(c, &req);
-	return err;
-}
-
-int ubifs_commit_write(struct file *file, struct page *page, unsigned from,
-		       unsigned to)
-{
-	struct inode *inode = page->mapping->host;
-	struct ubifs_inode *ui = ubifs_inode(inode);
-	struct ubifs_info *c = inode->i_sb->s_fs_info;
-	loff_t pos = ((loff_t)page->index << PAGE_CACHE_SHIFT) + to;
-
-	dbg_gen("ino %lu, pg %lu, offs %lld-%lld (in pg: %u-%u, %u bytes) "
-		"flags %#lx", inode->i_ino, page->index, pos - to + from,
-		pos, from, to, to - from, page->flags);
-	ubifs_assert(PageUptodate(page));
-	ubifs_assert(mutex_is_locked(&inode->i_mutex));
-
-	if (!PagePrivate(page)) {
-		SetPagePrivate(page);
-		atomic_long_inc(&c->dirty_pg_cnt);
-		__set_page_dirty_nobuffers(page);
-	}
-
-	if (pos > inode->i_size) {
-		int release;
-
-		mutex_lock(&ui->ui_mutex);
-		i_size_write(inode, pos);
-		ui->ui_size = pos;
-		release = ui->dirty;
-		/*
-		 * Note, we do not set @I_DIRTY_PAGES (which means that the
-		 * inode has dirty pages), this has been done in
-		 * '__set_page_dirty_nobuffers()'.
-		 */
-		__mark_inode_dirty(inode, I_DIRTY_DATASYNC);
-		mutex_unlock(&ui->ui_mutex);
-
-		/*
-		 * We've marked the inode as dirty and we have allocated budget
-		 * for this. However, the inode may had already be be dirty
-		 * before, in which case we have to free the budget.
-		 */
-		if (release)
-			ubifs_release_dirty_inode_budget(c, ui);
-	}
-
-	return 0;
-}
-
-#include <linux/writeback.h>
-
-#define MAX_SHRINK_RETRIES 8
-#define MAX_GC_RETRIES     4
-#define MAX_CMT_RETRIES    2
-#define MAX_NOSPC_RETRIES  1
-#define NR_TO_WRITE 16
-
-struct retries_info {
-	long long prev_liability;
-	unsigned int shrink_cnt;
-	unsigned int shrink_retries:5;
-	unsigned int try_gc:1;
-	unsigned int gc_retries:4;
-	unsigned int cmt_retries:3;
-	unsigned int nospc_retries:1;
-};
-
-static int shrink_liability(struct ubifs_info *c, int nr_to_write,
-			    int locked_pg)
-{
-	struct writeback_control wbc = {
-		.sync_mode   = WB_SYNC_NONE,
-		.range_end   = LLONG_MAX,
-		.nr_to_write = nr_to_write,
-		.skip_locked_pages = locked_pg,
-	};
-
-	writeback_inodes_sb(c->vfs_sb, &wbc);
-	dbg_budg("%ld pages were written back", nr_to_write - wbc.nr_to_write);
-	return nr_to_write - wbc.nr_to_write;
-}
-
-static int run_gc(struct ubifs_info *c)
-{
-	int err, lnum;
-
-	/* Make some free space by garbage-collecting dirty space */
-	down_read(&c->commit_sem);
-	lnum = ubifs_garbage_collect(c, 1);
-	up_read(&c->commit_sem);
-	if (lnum < 0)
-		return lnum;
-
-	/* GC freed one LEB, return it to lprops */
-	dbg_budg("GC freed LEB %d", lnum);
-	err = ubifs_return_leb(c, lnum);
-	if (err)
-		return err;
-
-	return 0;
-}
-
-int ubifs_make_free_space(struct ubifs_info *c, struct retries_info *ri,
-			  int locked_pg)
-{
-	int err;
-
-	/*
-	 * If we have some dirty pages and inodes (liability), try to write
-	 * them back unless this was tried too many times without effect
-	 * already.
-	 */
-	if (ri->shrink_retries < MAX_SHRINK_RETRIES && !ri->try_gc) {
-		long long liability;
-
-		spin_lock(&c->space_lock);
-		liability = c->budg_idx_growth + c->budg_data_growth +
-			    c->budg_dd_growth;
-		spin_unlock(&c->space_lock);
-
-		if (ri->prev_liability >= liability) {
-			/* Liability does not shrink, next time try GC then */
-			ri->shrink_retries += 1;
-			if (ri->gc_retries < MAX_GC_RETRIES)
-				ri->try_gc = 1;
-			dbg_budg("liability did not shrink: retries %d of %d",
-				 ri->shrink_retries, MAX_SHRINK_RETRIES);
-		}
-
-		dbg_budg("force write-back (count %d)", ri->shrink_cnt);
-		shrink_liability(c, NR_TO_WRITE + ri->shrink_cnt, locked_pg);
-
-		ri->prev_liability = liability;
-		ri->shrink_cnt += 1;
-		return -EAGAIN;
-	}
-
-	/*
-	 * Try to run garbage collector unless it was already tried too many
-	 * times.
-	 */
-	if (ri->gc_retries < MAX_GC_RETRIES) {
-		ri->gc_retries += 1;
-		dbg_budg("run GC, retries %d of %d",
-			 ri->gc_retries, MAX_GC_RETRIES);
-
-		ri->try_gc = 0;
-		err = run_gc(c);
-		if (!err)
-			return -EAGAIN;
-
-		if (err == -EAGAIN) {
-			dbg_budg("GC asked to commit");
-			err = ubifs_run_commit(c);
-			if (err)
-				return err;
-			return -EAGAIN;
-		}
-
-		if (err != -ENOSPC)
-			return err;
-
-		/*
-		 * GC could not make any progress. If this is the first time,
-		 * then it makes sense to try to commit, because it might make
-		 * some dirty space.
-		 */
-		dbg_budg("GC returned -ENOSPC, retries %d",
-			 ri->nospc_retries);
-		if (ri->nospc_retries >= MAX_NOSPC_RETRIES)
-			return err;
-		ri->nospc_retries += 1;
-	}
-
-	/* Neither GC nor write-back helped, try to commit */
-	if (ri->cmt_retries < MAX_CMT_RETRIES) {
-		ri->cmt_retries += 1;
-		dbg_budg("run commit, retries %d of %d",
-			 ri->cmt_retries, MAX_CMT_RETRIES);
-		err = ubifs_run_commit(c);
-		if (err)
-			return err;
-		return -EAGAIN;
-	}
-
-	return -ENOSPC;
-}
-
-#endif /* UBIFS_COMPAT_USE_OLD_PREPARE_WRITE */
diff --git a/fs/ubifs/compat.h b/fs/ubifs/compat.h
index 6b80375..8f2c93e 100644
--- a/fs/ubifs/compat.h
+++ b/fs/ubifs/compat.h
@@ -32,19 +32,6 @@ struct ubifs_info;
 struct retries_info;
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
-/*
- * We have write_begin() write_end() instead of prepare_write(), commit_write()
- * since 2.6.24.
- */
-#define UBIFS_COMPAT_USE_OLD_PREPARE_WRITE
-#define do_readpage(page) ubifs_do_readpage(page)
-int ubifs_do_readpage(struct page *page);
-int ubifs_prepare_write(struct file *file, struct page *page, unsigned from,
-			unsigned to);
-int ubifs_commit_write(struct file *file, struct page *page, unsigned from,
-		       unsigned to);
-int ubifs_make_free_space(struct ubifs_info *c, struct retries_info *ri,
-			  int locked_pg);
 #define bdi_init(x) 0
 #define bdi_destroy(x)
 #endif
diff --git a/fs/ubifs/debug.c b/fs/ubifs/debug.c
index 56fcd44..1d84617 100644
--- a/fs/ubifs/debug.c
+++ b/fs/ubifs/debug.c
@@ -571,13 +571,7 @@ void dbg_dump_budget_req(const struct ubifs_budget_req *req)
 	       req->new_page, req->dirtied_page);
 	printk(KERN_DEBUG "\tnew_dent    %d, mod_dent     %d\n",
 	       req->new_dent, req->mod_dent);
-/* TODO: remove compatibility stuff as late as possible */
-#ifdef UBIFS_COMPAT_USE_OLD_PREPARE_WRITE
-	printk(KERN_DEBUG "\tlocked_pg   %d idx_growth    %d\n",
-	       req->locked_pg, req->idx_growth);
-#else
 	printk(KERN_DEBUG "\tidx_growth  %d\n", req->idx_growth);
-#endif
 	printk(KERN_DEBUG "\tdata_growth %d dd_growth     %d\n",
 	       req->data_growth, req->dd_growth);
 	spin_unlock(&dbg_lock);
diff --git a/fs/ubifs/file.c b/fs/ubifs/file.c
index 84db32b..d38efeb 100644
--- a/fs/ubifs/file.c
+++ b/fs/ubifs/file.c
@@ -101,12 +101,7 @@ dump:
 	return -EINVAL;
 }
 
-/* TODO: remove compatibility stuff as late as possible */
-#ifdef UBIFS_COMPAT_USE_OLD_PREPARE_WRITE
-int ubifs_do_readpage(struct page *page)
-#else
 static int do_readpage(struct page *page)
-#endif
 {
 	void *addr;
 	int err = 0, i;
@@ -222,9 +217,6 @@ static void release_existing_page_budget(struct ubifs_info *c)
 	ubifs_release_budget(c, &req);
 }
 
-/* TODO: remove compatibility stuff as late as possible */
-#ifndef UBIFS_COMPAT_USE_OLD_PREPARE_WRITE
-
 static int write_begin_slow(struct address_space *mapping,
 			    loff_t pos, unsigned len, struct page **pagep)
 {
@@ -590,8 +582,6 @@ out:
 	return copied;
 }
 
-#endif /* UBIFS_COMPAT_USE_OLD_PREPARE_WRITE */
-
 /**
  * populate_page - copy data nodes into a page for bulk-read.
  * @c: UBIFS file-system description object
@@ -1557,13 +1547,8 @@ static int ubifs_file_mmap(struct file *file, struct vm_area_struct *vma)
 struct address_space_operations ubifs_file_address_operations = {
 	.readpage       = ubifs_readpage,
 	.writepage      = ubifs_writepage,
-#ifdef UBIFS_COMPAT_USE_OLD_PREPARE_WRITE
-	.prepare_write  = ubifs_prepare_write,
-	.commit_write   = ubifs_commit_write,
-#else
 	.write_begin    = ubifs_write_begin,
 	.write_end      = ubifs_write_end,
-#endif
 	.invalidatepage = ubifs_invalidatepage,
 	.set_page_dirty = ubifs_set_page_dirty,
 	.releasepage    = ubifs_releasepage,
diff --git a/fs/ubifs/ubifs.h b/fs/ubifs/ubifs.h
index e9aabcc..896c6f6 100644
--- a/fs/ubifs/ubifs.h
+++ b/fs/ubifs/ubifs.h
@@ -844,9 +844,6 @@ struct ubifs_compressor {
  * @dirtied_ino_d fields are aligned.
  */
 struct ubifs_budget_req {
-#ifdef UBIFS_COMPAT_USE_OLD_PREPARE_WRITE
-	unsigned int locked_pg:1;
-#endif
 	unsigned int fast:1;
 	unsigned int recalculate:1;
 #ifndef UBIFS_DEBUG
-- 
1.5.6.3

