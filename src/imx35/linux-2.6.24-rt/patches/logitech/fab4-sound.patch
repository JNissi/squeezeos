---
 sound/arm/mxc-alsa-spdif.c  |  118 ++++--
 sound/soc/codecs/Kconfig    |    8 
 sound/soc/codecs/Makefile   |    4 
 sound/soc/codecs/ak4420.c   |  154 ++++++++
 sound/soc/codecs/wm8974.c   |  819 ++++++++++++++++++++++++++++++++++++++++++++
 sound/soc/codecs/wm8974.h   |   96 +++++
 sound/soc/imx/Kconfig       |   17 
 sound/soc/imx/Makefile      |    4 
 sound/soc/imx/fab4-ak4420.c |  342 ++++++++++++++++++
 sound/soc/imx/fab4-wm8974.c |  370 +++++++++++++++++++
 sound/soc/imx/imx-ssi.c     |    3 
 11 files changed, 1891 insertions(+), 44 deletions(-)

Index: linux-2.6.24/sound/arm/mxc-alsa-spdif.c
===================================================================
--- linux-2.6.24.orig/sound/arm/mxc-alsa-spdif.c	2009-01-26 18:51:42.000000000 +0100
+++ linux-2.6.24/sound/arm/mxc-alsa-spdif.c	2009-01-26 19:08:10.000000000 +0100
@@ -41,6 +41,7 @@
 #ifdef CONFIG_PM
 #include <linux/pm.h>
 #endif
+#include <linux/bitrev.h>
 
 #include <asm/arch/dma.h>
 #include <asm/mach-types.h>
@@ -291,6 +292,11 @@ struct mxc_spdif_device {
 	int spdif_txclk_48000;
 
 	/*!
+	 * function to set spdif clock
+	 */
+	void (*spdif_set_clk) (int sample_rate);
+
+	/*!
 	 * ALSA SPDIF sound card handle
 	 */
 	struct snd_card *card;
@@ -315,6 +321,8 @@ static struct spdif_mixer_control mxc_sp
 
 static unsigned long spdif_base_addr;
 
+static int spdif_set_channel_status(void);
+
 /* define each spdif interrupt handlers */
 typedef void (*spdif_irq_func_t) (unsigned int bit, void *desc);
 
@@ -394,13 +402,11 @@ static void spdif_intr_enable(unsigned l
  */
 static int spdif_set_clk_accuracy(enum spdif_clk_accuracy level)
 {
-	unsigned long value;
 
-	value = __raw_readl(SPDIF_REG_STCSCL + spdif_base_addr) & 0xffffcf;
-	value |= (level << 4);
-	__raw_writel(value, SPDIF_REG_STCSCL + spdif_base_addr);
+	mxc_spdif_control.ch_status[3] &= 0xcf;
+	mxc_spdif_control.ch_status[3] |= (level << 4);
 
-	return 0;
+	return spdif_set_channel_status();
 }
 
 /*!
@@ -452,36 +458,52 @@ static int spdif_get_rxclk_rate(struct c
  *
  * This function is called to set the audio sample rate to be transfered.
  */
-static int spdif_set_sample_rate(int src_44100, int src_48000, int sample_rate)
+static int spdif_set_sample_rate(struct mxc_spdif_device *chip, int sample_rate)
 {
-	unsigned long cstatus, stc;
+	unsigned long stc;
+
+	mxc_spdif_control.ch_status[3] &= 0xF0;
 
-	cstatus = __raw_readl(SPDIF_REG_STCSCL + spdif_base_addr) & 0xfffff0;
 	stc = __raw_readl(SPDIF_REG_STC + spdif_base_addr) & ~0x7FF;
 
 	switch (sample_rate) {
-	case 44100:
-		__raw_writel(cstatus, SPDIF_REG_STCSCL + spdif_base_addr);
-		stc |= (src_44100 << 8) | 0x07;
+	case 96000:
+		mxc_spdif_control.ch_status[3] |= 0x0A;
+		stc |= (chip->spdif_txclk_48000 << 8) | 0x03;
 		__raw_writel(stc, SPDIF_REG_STC + spdif_base_addr);
-		pr_debug("set sample rate to 44100\n");
+		pr_debug("set sample rate to 96000\n");
+		break;
+	case 88200:
+		mxc_spdif_control.ch_status[3]  |= 0x08;
+		stc |= (chip->spdif_txclk_44100 << 8) | 0x03;
+		__raw_writel(stc, SPDIF_REG_STC + spdif_base_addr);
+		pr_debug("set sample rate to 88200\n");
 		break;
 	case 48000:
-		cstatus |= 0x04;
-		__raw_writel(cstatus, SPDIF_REG_STCSCL + spdif_base_addr);
-		stc |= (src_48000 << 8) | 0x07;
+		mxc_spdif_control.ch_status[3]  |= 0x02;
+		stc |= (chip->spdif_txclk_48000 << 8) | 0x07;
 		__raw_writel(stc, SPDIF_REG_STC + spdif_base_addr);
 		pr_debug("set sample rate to 48000\n");
 		break;
+	case 44100:
+		stc |= (chip->spdif_txclk_44100 << 8) | 0x07;
+		__raw_writel(stc, SPDIF_REG_STC + spdif_base_addr);
+		pr_debug("set sample rate to 44100\n");
+		break;
 	case 32000:
-		cstatus |= 0x0c;
-		__raw_writel(cstatus, SPDIF_REG_STCSCL + spdif_base_addr);
-		stc |= (src_48000 << 8) | 0x0b;
+		mxc_spdif_control.ch_status[3]  |= 0x03;
+		stc |= (chip->spdif_txclk_48000 << 8) | 0x0b;
 		__raw_writel(stc, SPDIF_REG_STC + spdif_base_addr);
 		pr_debug("set sample rate to 32000\n");
 		break;
 	}
 
+	spdif_set_channel_status();
+
+	if (chip->spdif_set_clk) {
+		(chip->spdif_set_clk)(sample_rate);
+	}
+
 	return 0;
 }
 
@@ -490,9 +512,22 @@ static int spdif_set_sample_rate(int src
  *
  * This function is called to set the channel status
  */
-static int spdif_set_channel_status(int value, unsigned long reg)
+static int spdif_set_channel_status(void)
 {
-	__raw_writel(value & 0xffffff, reg + spdif_base_addr);
+	unsigned int stcscl, stcsch;
+
+	stcsch =
+		(mxc_spdif_control.ch_status[2] << 24) |
+		(mxc_spdif_control.ch_status[1] << 16) |
+		(mxc_spdif_control.ch_status[0] << 8);
+
+	stcscl = mxc_spdif_control.ch_status[3] << 8;
+
+	stcsch = bitrev32(stcsch);
+	stcscl = bitrev32(stcscl);
+
+	__raw_writel(stcsch, SPDIF_REG_STCSCH + spdif_base_addr);
+	__raw_writel(stcscl, SPDIF_REG_STCSCL + spdif_base_addr);
 
 	return 0;
 }
@@ -730,7 +765,7 @@ static void spdif_tx_init(void)
 	regval = __raw_readl(spdif_base_addr + SPDIF_REG_SCR);
 
 	regval &= 0xfc32e3;
-	regval |= SCR_TXFIFO_AUTOSYNC | SCR_TXFIFO_NORMAL |
+	regval |= SCR_VAL_CLEAR | SCR_TXFIFO_AUTOSYNC | SCR_TXFIFO_NORMAL |
 	    SCR_TXSEL_NORMAL | SCR_USRC_SEL_CHIP | (2 << SCR_TXFIFO_ESEL_BIT);
 	__raw_writel(regval, SPDIF_REG_SCR + spdif_base_addr);
 
@@ -756,7 +791,7 @@ static void spdif_tx_uninit(void)
 
 }
 
-static unsigned int spdif_playback_rates[] = { 32000, 44100, 48000 };
+static unsigned int spdif_playback_rates[] = { 32000, 44100, 48000, 88200, 96000 };
 static unsigned int spdif_capture_rates[] = {
 	16000, 32000, 44100, 48000, 64000, 96000
 };
@@ -790,9 +825,10 @@ static struct snd_pcm_hardware snd_spdif
 	.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |
 	    SNDRV_PCM_FMTBIT_S24_LE,
 	.rates =
-	    SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+	    SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
+	    SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000,
 	.rate_min = 32000,
-	.rate_max = 48000,
+	.rate_max = 96000,
 	.channels_min = 2,
 	.channels_max = 2,
 	.buffer_bytes_max = SPDIF_MAX_BUF_SIZE,
@@ -1147,23 +1183,15 @@ static int snd_mxc_spdif_playback_prepar
 	struct mxc_spdif_device *chip;
 	struct snd_pcm_runtime *runtime;
 	int err;
-	unsigned int ch_status;
 
 	chip = snd_pcm_substream_chip(substream);
 	runtime = substream->runtime;
 
 	spdif_tx_init();
 
-	ch_status =
-	    ((mxc_spdif_control.ch_status[2] << 16) | (mxc_spdif_control.
-						       ch_status[1] << 8) |
-	     mxc_spdif_control.ch_status[0]);
-	spdif_set_channel_status(ch_status, SPDIF_REG_STCSCH);
-	ch_status = mxc_spdif_control.ch_status[3];
-	spdif_set_channel_status(ch_status, SPDIF_REG_STCSCL);
+	spdif_set_channel_status();
 	spdif_intr_enable(INT_TXFIFO_RESYNC, 1);
-	spdif_set_sample_rate(chip->spdif_txclk_44100, chip->spdif_txclk_48000,
-			      runtime->rate);
+	spdif_set_sample_rate(chip, runtime->rate);
 	spdif_set_clk_accuracy(SPDIF_CLK_ACCURACY_LEV2);
 	/* setup DMA controller for spdif tx */
 	err = spdif_configure_dma_channel(&chip->
@@ -1206,8 +1234,12 @@ static int snd_card_mxc_spdif_playback_o
 	struct mxc_spdif_platform_data *spdif_data;
 
 	chip = snd_pcm_substream_chip(substream);
-
 	spdif_data = chip->card->dev->platform_data;
+
+	if (spdif_data->spdif_enable) {
+		(spdif_data->spdif_enable)(1);
+	}
+
 	/* enable tx clock */
 	clk_enable(spdif_data->spdif_clk);
 
@@ -1256,6 +1288,10 @@ static int snd_card_mxc_spdif_playback_c
 	mxc_dma_free(chip->s[SNDRV_PCM_STREAM_PLAYBACK].dma_wchannel);
 	chip->s[SNDRV_PCM_STREAM_PLAYBACK].dma_wchannel = 0;
 
+	if (spdif_data->spdif_enable) {
+		(spdif_data->spdif_enable)(0);
+	}
+
 	return 0;
 }
 
@@ -1755,18 +1791,13 @@ static int mxc_pb_spdif_get(struct snd_k
 static int mxc_pb_spdif_put(struct snd_kcontrol *kcontrol,
 			    struct snd_ctl_elem_value *uvalue)
 {
-	unsigned int ch_status;
 	mxc_spdif_control.ch_status[0] = uvalue->value.iec958.status[0];
 	mxc_spdif_control.ch_status[1] = uvalue->value.iec958.status[1];
 	mxc_spdif_control.ch_status[2] = uvalue->value.iec958.status[2];
 	mxc_spdif_control.ch_status[3] = uvalue->value.iec958.status[3];
-	ch_status =
-	    ((mxc_spdif_control.ch_status[2] << 16) | (mxc_spdif_control.
-						       ch_status[1] << 8) |
-	     mxc_spdif_control.ch_status[0]);
-	spdif_set_channel_status(ch_status, SPDIF_REG_STCSCH);
-	ch_status = mxc_spdif_control.ch_status[3];
-	spdif_set_channel_status(ch_status, SPDIF_REG_STCSCL);
+
+	spdif_set_channel_status();
+
 	return 0;
 }
 
@@ -2119,6 +2150,7 @@ static int mxc_alsa_spdif_probe(struct p
 	chip->mxc_spdif_rx = plat_data->spdif_rx;
 	chip->spdif_txclk_44100 = plat_data->spdif_clk_44100;
 	chip->spdif_txclk_48000 = plat_data->spdif_clk_48000;
+	chip->spdif_set_clk = plat_data->spdif_set_clk;
 	atomic_set(&chip->dpll_locked, 0);
 
 	err = snd_card_mxc_spdif_pcm(chip);
Index: linux-2.6.24/sound/soc/codecs/ak4420.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24/sound/soc/codecs/ak4420.c	2009-01-26 19:08:10.000000000 +0100
@@ -0,0 +1,154 @@
+/*
+ * ak4420.c
+ *
+ * Copyright 2008 Logitech
+ *	Richard Titmuss <richard_titmuss@logitech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/tlv.h>
+#include <sound/initval.h>
+#include <asm/div64.h>
+
+#define AUDIO_NAME "AK4420"
+#define AK4420_VERSION "0.1"
+
+#define AK4420_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | \
+		      SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+static const struct snd_soc_pcm_stream ak4420_dai_playback = {
+	.stream_name = "Playback",
+	.channels_min = 2,
+	.channels_max = 2,
+	.rates = AK4420_RATES,
+	.formats = SNDRV_PCM_FMTBIT_S24_LE,
+};
+
+/* dai ops, called by machine drivers */
+static const struct snd_soc_dai_ops ak4420_dai_ops = {
+};
+
+/* audio ops, called by alsa */
+static const struct snd_soc_ops ak4420_dai_audio_ops = {
+};
+
+static const struct snd_soc_codec_ops ak4420_codec_ops = {
+};
+
+static int ak4420_codec_probe(struct device *dev)
+{
+	struct snd_soc_codec *codec = to_snd_soc_codec(dev);
+
+	printk(KERN_INFO "AK4420 Audio Codec %s", AK4420_VERSION);
+
+	codec->owner = THIS_MODULE;
+	codec->ops = &ak4420_codec_ops;
+
+	snd_soc_register_codec(codec);
+
+	return 0;
+
+}
+
+static int ak4420_codec_remove(struct device *dev)
+{
+	struct snd_soc_codec *codec = to_snd_soc_codec(dev);
+	kfree(codec->private_data);
+	return 0;
+}
+
+static int ak4420_dai_probe(struct device *dev)
+{
+	struct snd_soc_dai *dai = to_snd_soc_dai(dev);
+
+	dai->playback = &ak4420_dai_playback;
+	snd_soc_register_codec_dai(dai);
+	return 0;
+}
+
+const char ak4420_codec[SND_SOC_CODEC_NAME_SIZE] = "ak4420-codec";
+EXPORT_SYMBOL_GPL(ak4420_codec);
+
+static struct snd_soc_device_driver ak4420_codec_driver = {
+	.type = SND_SOC_BUS_TYPE_CODEC,
+	.driver = {
+		   .name = ak4420_codec,
+		   .owner = THIS_MODULE,
+		   .bus = &asoc_bus_type,
+		   .probe = ak4420_codec_probe,
+		   .remove = __devexit_p(ak4420_codec_remove),
+		   },
+};
+
+const char ak4420_dai[SND_SOC_CODEC_NAME_SIZE] = "ak4420-dai";
+EXPORT_SYMBOL_GPL(ak4420_dai);
+
+static struct snd_soc_device_driver ak4420_dai_driver = {
+	.type = SND_SOC_BUS_TYPE_DAI,
+	.driver = {
+		   .name = ak4420_dai,
+		   .owner = THIS_MODULE,
+		   .bus = &asoc_bus_type,
+		   .probe = ak4420_dai_probe,
+		   },
+};
+
+static __init int ak4420_init(void)
+{
+	int ret = 0;
+
+	ret = driver_register(&ak4420_codec_driver.driver);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = driver_register(&ak4420_dai_driver.driver);
+	if (ret < 0) {
+		driver_unregister(&ak4420_codec_driver.driver);
+		return ret;
+	}
+
+	return ret;
+}
+
+static __exit void ak4420_exit(void)
+{
+	driver_unregister(&ak4420_dai_driver.driver);
+	driver_unregister(&ak4420_codec_driver.driver);
+}
+
+module_init(ak4420_init);
+module_exit(ak4420_exit);
+
+MODULE_DESCRIPTION("ASoC AK4420 driver");
+MODULE_AUTHOR("Richard Titmuss");
+MODULE_LICENSE("GPL");
Index: linux-2.6.24/sound/soc/codecs/Kconfig
===================================================================
--- linux-2.6.24.orig/sound/soc/codecs/Kconfig	2009-01-26 18:51:42.000000000 +0100
+++ linux-2.6.24/sound/soc/codecs/Kconfig	2009-01-26 19:08:10.000000000 +0100
@@ -48,3 +48,11 @@ config SND_SOC_AK4647
 config SND_SOC_WM8580
         tristate
         depends on SND_SOC
+
+config SND_SOC_AK4420
+	tristate
+	depends on SND_SOC
+
+config SND_SOC_WM8974
+	tristate
+	depends on SND_SOC
Index: linux-2.6.24/sound/soc/codecs/Makefile
===================================================================
--- linux-2.6.24.orig/sound/soc/codecs/Makefile	2009-01-26 18:51:42.000000000 +0100
+++ linux-2.6.24/sound/soc/codecs/Makefile	2009-01-26 19:08:10.000000000 +0100
@@ -7,6 +7,8 @@ snd-soc-wm9712-objs := wm9712.o
 snd-soc-cs4270-objs := cs4270.o
 snd-soc-ak4647-objs := ak4647.o
 snd-soc-wm8580-objs := wm8580.o
+snd-soc-ak4420-objs := ak4420.o
+snd-soc-wm8974-objs := wm8974.o
 
 obj-$(CONFIG_SND_SOC_AC97_CODEC)	+= snd-soc-ac97.o
 obj-$(CONFIG_SND_SOC_WM8350)	+= snd-soc-wm8350.o
@@ -17,3 +19,5 @@ obj-$(CONFIG_SND_SOC_WM9712)	+= snd-soc-
 obj-$(CONFIG_SND_SOC_CS4270)	+= snd-soc-cs4270.o
 obj-$(CONFIG_SND_SOC_AK4647)	+= snd-soc-ak4647.o
 obj-$(CONFIG_SND_SOC_WM8580)    += snd-soc-wm8580.o
+obj-$(CONFIG_SND_SOC_AK4420)	+= snd-soc-ak4420.o
+obj-$(CONFIG_SND_SOC_WM8974)	+= snd-soc-wm8974.o
Index: linux-2.6.24/sound/soc/codecs/wm8974.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24/sound/soc/codecs/wm8974.c	2009-01-26 19:08:14.000000000 +0100
@@ -0,0 +1,819 @@
+/*
+ * wm8974.c -- WM8974 ALSA SoC audio driver
+ *
+ * Copyright 2008 Logitech
+ *	Richard Titmuss <richard_titmuss@logitech.com>
+ *
+ * Based on wm8350.c and main line wm8974.c:
+ *
+ * Copyright (C) 2007 Wolfson Microelectronics PLC.
+ *
+ * Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include "wm8974.h"
+
+#define AUDIO_NAME "WM8974"
+#define WM8974_VERSION "0.1"
+
+
+/*
+ * wm8974 register cache
+ * We can't read the WM8974 register space  so we cache
+ * them instead.
+ */
+static const u16 wm8974_reg[WM8974_CACHEREGNUM] = {
+	0x0000, 0x0000, 0x0000, 0x0000,
+	0x0050, 0x0000, 0x0140, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x00ff,
+	0x0000, 0x0000, 0x0100, 0x00ff,
+	0x0000, 0x0000, 0x012c, 0x002c,
+	0x002c, 0x002c, 0x002c, 0x0000,
+	0x0032, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000,
+	0x0038, 0x000b, 0x0032, 0x0000,
+	0x0008, 0x000c, 0x0093, 0x00e9,
+	0x0000, 0x0000, 0x0000, 0x0000,
+	0x0003, 0x0010, 0x0000, 0x0000,
+	0x0000, 0x0002, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0039, 0x0000,
+	0x0000,
+};
+
+
+/*
+ * read wm8974 register cache
+ */
+static inline unsigned int wm8974_read_reg_cache(struct snd_soc_codec * codec,
+						 unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+
+	if (reg == WM8974_RESET)
+		return 0;
+	if (reg >= WM8974_CACHEREGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write wm8974 register cache
+ */
+static inline void wm8974_write_reg_cache(struct snd_soc_codec *codec,
+					  u16 reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+
+	if (reg >= WM8974_CACHEREGNUM)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the WM8974 register space
+ */
+static int wm8974_write_reg(struct snd_soc_codec *codec, unsigned int reg,
+			unsigned int value)
+{
+	u8 data[2];
+
+        /* data is
+	 *   D15..D9 WM8974 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	// XXXX msleep(1000);
+
+	wm8974_write_reg_cache (codec, reg, value);
+        if (codec->mach_write(codec->control_data, (long)data, 2) == 2)
+                return 0;
+	else
+                return -EIO;
+}
+
+
+static const char *wm8974_companding[] = {"Off", "NC", "u-law", "A-law" };
+static const char *wm8974_deemp[] = {"None", "32kHz", "44.1kHz", "48kHz" };
+static const char *wm8974_eqmode[] = {"Capture", "Playback" };
+static const char *wm8974_bw[] = {"Narrow", "Wide" };
+static const char *wm8974_eq1[] = {"80Hz", "105Hz", "135Hz", "175Hz" };
+static const char *wm8974_eq2[] = {"230Hz", "300Hz", "385Hz", "500Hz" };
+static const char *wm8974_eq3[] = {"650Hz", "850Hz", "1.1kHz", "1.4kHz" };
+static const char *wm8974_eq4[] = {"1.8kHz", "2.4kHz", "3.2kHz", "4.1kHz" };
+static const char *wm8974_eq5[] = {"5.3kHz", "6.9kHz", "9kHz", "11.7kHz" };
+static const char *wm8974_alc[] = {"ALC", "Limiter" };
+
+static const struct soc_enum wm8974_enum[] = {
+	SOC_ENUM_SINGLE(WM8974_COMP, 1, 4, wm8974_companding), /* adc */
+	SOC_ENUM_SINGLE(WM8974_COMP, 3, 4, wm8974_companding), /* dac */
+	SOC_ENUM_SINGLE(WM8974_DAC,  4, 4, wm8974_deemp),
+	SOC_ENUM_SINGLE(WM8974_EQ1,  8, 2, wm8974_eqmode),
+
+	SOC_ENUM_SINGLE(WM8974_EQ1,  5, 4, wm8974_eq1),
+	SOC_ENUM_SINGLE(WM8974_EQ2,  8, 2, wm8974_bw),
+	SOC_ENUM_SINGLE(WM8974_EQ2,  5, 4, wm8974_eq2),
+	SOC_ENUM_SINGLE(WM8974_EQ3,  8, 2, wm8974_bw),
+
+	SOC_ENUM_SINGLE(WM8974_EQ3,  5, 4, wm8974_eq3),
+	SOC_ENUM_SINGLE(WM8974_EQ4,  8, 2, wm8974_bw),
+	SOC_ENUM_SINGLE(WM8974_EQ4,  5, 4, wm8974_eq4),
+	SOC_ENUM_SINGLE(WM8974_EQ5,  8, 2, wm8974_bw),
+
+	SOC_ENUM_SINGLE(WM8974_EQ5,  5, 4, wm8974_eq5),
+	SOC_ENUM_SINGLE(WM8974_ALC3,  8, 2, wm8974_alc),
+};
+
+static const struct snd_kcontrol_new wm8974_snd_controls[] = {
+	SOC_SINGLE("Digital Loopback Switch", WM8974_COMP, 0, 1, 0),
+
+	SOC_ENUM("DAC Companding", wm8974_enum[1]),
+	SOC_ENUM("ADC Companding", wm8974_enum[0]),
+
+	SOC_ENUM("Playback De-emphasis", wm8974_enum[2]),
+	SOC_SINGLE("DAC Inversion Switch", WM8974_DAC, 0, 1, 0),
+
+	SOC_SINGLE("PCM Volume", WM8974_DACVOL, 0, 127, 0),
+
+	SOC_SINGLE("High Pass Filter Switch", WM8974_ADC, 8, 1, 0),
+	SOC_SINGLE("High Pass Cut Off", WM8974_ADC, 4, 7, 0),
+	SOC_SINGLE("ADC Inversion Switch", WM8974_COMP, 0, 1, 0),
+
+	SOC_SINGLE("Capture Volume", WM8974_ADCVOL,  0, 127, 0),
+
+	SOC_ENUM("Equaliser Function", wm8974_enum[3]),
+	SOC_ENUM("EQ1 Cut Off", wm8974_enum[4]),
+	SOC_SINGLE("EQ1 Volume", WM8974_EQ1,  0, 31, 1),
+
+	SOC_ENUM("Equaliser EQ2 Bandwith", wm8974_enum[5]),
+	SOC_ENUM("EQ2 Cut Off", wm8974_enum[6]),
+	SOC_SINGLE("EQ2 Volume", WM8974_EQ2,  0, 31, 1),
+
+	SOC_ENUM("Equaliser EQ3 Bandwith", wm8974_enum[7]),
+	SOC_ENUM("EQ3 Cut Off", wm8974_enum[8]),
+	SOC_SINGLE("EQ3 Volume", WM8974_EQ3,  0, 31, 1),
+
+	SOC_ENUM("Equaliser EQ4 Bandwith", wm8974_enum[9]),
+	SOC_ENUM("EQ4 Cut Off", wm8974_enum[10]),
+	SOC_SINGLE("EQ4 Volume", WM8974_EQ4,  0, 31, 1),
+
+	SOC_ENUM("Equaliser EQ5 Bandwith", wm8974_enum[11]),
+	SOC_ENUM("EQ5 Cut Off", wm8974_enum[12]),
+	SOC_SINGLE("EQ5 Volume", WM8974_EQ5,  0, 31, 1),
+
+	SOC_SINGLE("DAC Playback Limiter Switch", WM8974_DACLIM1,  8, 1, 0),
+	SOC_SINGLE("DAC Playback Limiter Decay", WM8974_DACLIM1,  4, 15, 0),
+	SOC_SINGLE("DAC Playback Limiter Attack", WM8974_DACLIM1,  0, 15, 0),
+
+	SOC_SINGLE("DAC Playback Limiter Threshold", WM8974_DACLIM2,  4, 7, 0),
+	SOC_SINGLE("DAC Playback Limiter Boost", WM8974_DACLIM2,  0, 15, 0),
+
+	SOC_SINGLE("ALC Enable Switch", WM8974_ALC1,  8, 1, 0),
+	SOC_SINGLE("ALC Capture Max Gain", WM8974_ALC1,  3, 7, 0),
+	SOC_SINGLE("ALC Capture Min Gain", WM8974_ALC1,  0, 7, 0),
+
+	SOC_SINGLE("ALC Capture ZC Switch", WM8974_ALC2,  8, 1, 0),
+	SOC_SINGLE("ALC Capture Hold", WM8974_ALC2,  4, 7, 0),
+	SOC_SINGLE("ALC Capture Target", WM8974_ALC2,  0, 15, 0),
+
+	SOC_ENUM("ALC Capture Mode", wm8974_enum[13]),
+	SOC_SINGLE("ALC Capture Decay", WM8974_ALC3,  4, 15, 0),
+	SOC_SINGLE("ALC Capture Attack", WM8974_ALC3,  0, 15, 0),
+
+	SOC_SINGLE("ALC Capture Noise Gate Switch", WM8974_NGATE,  3, 1, 0),
+	SOC_SINGLE("ALC Capture Noise Gate Threshold", WM8974_NGATE,  0, 7, 0),
+
+	SOC_SINGLE("Capture PGA ZC Switch", WM8974_INPPGA,  7, 1, 0),
+	SOC_SINGLE("Capture PGA Volume", WM8974_INPPGA,  0, 63, 0),
+
+	SOC_SINGLE("Speaker Playback ZC Switch", WM8974_SPKVOL,  7, 1, 0),
+	SOC_SINGLE("Speaker Playback Switch", WM8974_SPKVOL,  6, 1, 1),
+	SOC_SINGLE("Speaker Playback Volume", WM8974_SPKVOL,  0, 63, 0),
+
+	SOC_SINGLE("Capture Boost(+20dB)", WM8974_ADCBOOST,  8, 1, 0),
+	SOC_SINGLE("Mono Playback Switch", WM8974_MONOMIX, 6, 1, 0),
+};
+
+/* add non dapm controls */
+static int wm8974_add_controls(struct snd_soc_codec *codec,
+	struct snd_card *card)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8974_snd_controls); i++) {
+		err = snd_ctl_add(card,
+				snd_soc_cnew(&wm8974_snd_controls[i],
+					codec, NULL));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+/*
+ * DAPM Controls
+ */
+
+/* Speaker Output Mixer */
+static const struct snd_kcontrol_new wm8974_speaker_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Line Bypass Switch", WM8974_SPKMIX, 1, 1, 0),
+	SOC_DAPM_SINGLE("Aux Playback Switch", WM8974_SPKMIX, 5, 1, 0),
+	SOC_DAPM_SINGLE("PCM Playback Switch", WM8974_SPKMIX, 0, 1, 0),
+};
+
+/* Mono Output Mixer */
+static const struct snd_kcontrol_new wm8974_mono_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Line Bypass Switch", WM8974_MONOMIX, 1, 1, 0),
+	SOC_DAPM_SINGLE("Aux Playback Switch", WM8974_MONOMIX, 2, 1, 0),
+	SOC_DAPM_SINGLE("PCM Playback Switch", WM8974_MONOMIX, 0, 1, 0),
+};
+
+/* AUX Input boost vol */
+static const struct snd_kcontrol_new wm8974_aux_boost_controls =
+	SOC_DAPM_SINGLE("Aux Volume", WM8974_ADCBOOST, 0, 7, 0);
+
+/* Mic Input boost vol */
+static const struct snd_kcontrol_new wm8974_mic_boost_controls =
+	SOC_DAPM_SINGLE("Mic Volume", WM8974_ADCBOOST, 4, 7, 0);
+
+/* Capture boost switch */
+static const struct snd_kcontrol_new wm8974_capture_boost_controls =
+	SOC_DAPM_SINGLE("Capture Boost Switch", WM8974_INPPGA,  6, 1, 0);
+
+/* Aux In to PGA */
+static const struct snd_kcontrol_new wm8974_aux_capture_boost_controls =
+	SOC_DAPM_SINGLE("Aux Capture Boost Switch", WM8974_INPPGA,  2, 1, 0);
+
+/* Mic P In to PGA */
+static const struct snd_kcontrol_new wm8974_micp_capture_boost_controls =
+	SOC_DAPM_SINGLE("Mic P Capture Boost Switch", WM8974_INPPGA,  0, 1, 0);
+
+/* Mic N In to PGA */
+static const struct snd_kcontrol_new wm8974_micn_capture_boost_controls =
+	SOC_DAPM_SINGLE("Mic N Capture Boost Switch", WM8974_INPPGA,  1, 1, 0);
+
+static const struct snd_soc_dapm_widget wm8974_dapm_widgets[] = {
+	SND_SOC_DAPM_MIXER("Speaker Mixer", WM8974_POWER3, 3, 0,
+			   &wm8974_speaker_mixer_controls[0],
+			   ARRAY_SIZE(wm8974_speaker_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Mono Mixer", WM8974_POWER3, 3, 0,
+			   &wm8974_mono_mixer_controls[0],
+			   ARRAY_SIZE(wm8974_mono_mixer_controls)),
+	SND_SOC_DAPM_DAC("DAC", "Playback", WM8974_POWER3, 0, 0),
+	SND_SOC_DAPM_ADC("ADC", "Capture", WM8974_POWER2, 0, 0),
+	SND_SOC_DAPM_PGA("Aux Input", WM8974_POWER1, 6, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("SpkN Out", WM8974_POWER3, 5, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("SpkP Out", WM8974_POWER3, 6, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Mono Out", WM8974_POWER3, 7, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Mic PGA", WM8974_POWER2, 2, 0, NULL, 0),
+
+	SND_SOC_DAPM_PGA("Aux Boost", SND_SOC_NOPM, 0, 0,
+			 &wm8974_aux_boost_controls, 1),
+	SND_SOC_DAPM_PGA("Mic Boost", SND_SOC_NOPM, 0, 0,
+			 &wm8974_mic_boost_controls, 1),
+	SND_SOC_DAPM_SWITCH("Capture Boost", SND_SOC_NOPM, 0, 0,
+			    &wm8974_capture_boost_controls),
+
+	SND_SOC_DAPM_MIXER("Boost Mixer", WM8974_POWER2, 4, 0, NULL, 0),
+
+	SND_SOC_DAPM_MICBIAS("Mic Bias", WM8974_POWER1, 4, 0),
+
+	SND_SOC_DAPM_INPUT("MICN"),
+	SND_SOC_DAPM_INPUT("MICP"),
+	SND_SOC_DAPM_INPUT("AUX"),
+	SND_SOC_DAPM_OUTPUT("MONOOUT"),
+	SND_SOC_DAPM_OUTPUT("SPKOUTP"),
+	SND_SOC_DAPM_OUTPUT("SPKOUTN"),
+};
+
+static const char *audio_map[][3] = {
+	/* Mono output mixer */
+	{"Mono Mixer", "PCM Playback Switch", "DAC"},
+	{"Mono Mixer", "Aux Playback Switch", "Aux Input"},
+	{"Mono Mixer", "Line Bypass Switch", "Boost Mixer"},
+
+	/* Speaker output mixer */
+	{"Speaker Mixer", "PCM Playback Switch", "DAC"},
+	{"Speaker Mixer", "Aux Playback Switch", "Aux Input"},
+	{"Speaker Mixer", "Line Bypass Switch", "Boost Mixer"},
+
+	/* Outputs */
+	{"Mono Out", NULL, "Mono Mixer"},
+	{"MONOOUT", NULL, "Mono Out"},
+	{"SpkN Out", NULL, "Speaker Mixer"},
+	{"SpkP Out", NULL, "Speaker Mixer"},
+	{"SPKOUTN", NULL, "SpkN Out"},
+	{"SPKOUTP", NULL, "SpkP Out"},
+
+	/* Boost Mixer */
+	{"ADC", NULL, "Boost Mixer"},
+	//{"Capture Boost Switch", "Aux Capture Boost Switch", "AUX"},
+	//{"Boost Mixer", "Aux Volume", "Aux Boost"},
+	// FIXME
+	{"Capture Boost", NULL /*"Capture Switch"*/, "Boost Mixer"},
+	{"Boost Mixer", NULL /*"Mic Volume"*/, "Mic Boost"},
+	{"Boost Mixer", NULL /*"Mic Volume"*/, "Mic PGA"},
+
+	/* Inputs */
+	{"Mic Boost", NULL, "MICP"},
+	{"Mic PGA", NULL, "MICN"},
+	{"Capture Boost", NULL, "Mic PGA"},
+	{"Aux Input", NULL, "AUX"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int wm8974_add_widgets(struct snd_soc_codec *codec,
+	struct snd_soc_machine *machine)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm8974_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(machine, codec,
+			&wm8974_dapm_widgets[i]);
+	}
+
+	/* set up audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(machine, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(machine);
+	return 0;
+}
+
+static int wm8974_set_clkdiv(struct snd_soc_dai *codec_dai,
+	int div_id, int div)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+        u16 reg;
+
+	switch (div_id) {
+	case WM8974_OPCLKDIV:
+		reg = wm8974_read_reg_cache(codec, WM8974_GPIO) & 0x1cf;
+		wm8974_write_reg(codec, WM8974_GPIO, reg | div);
+		break;
+	case WM8974_MCLKDIV:
+		reg = wm8974_read_reg_cache(codec, WM8974_CLOCK) & 0x1f;
+		wm8974_write_reg(codec, WM8974_CLOCK, reg | div);
+		break;
+	case WM8974_ADCCLK:
+		reg = wm8974_read_reg_cache(codec, WM8974_ADC) & 0x1f7;
+		wm8974_write_reg(codec, WM8974_ADC, reg | div);
+		break;
+	case WM8974_DACCLK:
+		reg = wm8974_read_reg_cache(codec, WM8974_DAC) & 0x1f7;
+		wm8974_write_reg(codec, WM8974_DAC, reg | div);
+		break;
+	case WM8974_BCLKDIV:
+		reg = wm8974_read_reg_cache(codec, WM8974_CLOCK) & 0x1e3;
+		wm8974_write_reg(codec, WM8974_CLOCK, reg | div);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int wm8974_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u16 iface = 0;
+	u16 clk = wm8974_read_reg_cache(codec, WM8974_CLOCK) & 0x1fe;
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		clk |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch(fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0010;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0008;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x0018;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+#if 1
+	// FIXME no sound without this clock inversion
+	iface |= 0x0080;
+#else
+	/* clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0180;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0100;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0080;
+		break;
+	default:
+		return -EINVAL;
+	}
+#endif
+
+	wm8974_write_reg(codec, WM8974_IFACE, iface);
+	wm8974_write_reg(codec, WM8974_CLOCK, clk);
+
+	return 0;
+}
+
+static int wm8974_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_link *pcm_link = substream->private_data;
+	struct snd_soc_codec *codec = pcm_link->codec;
+	u16 iface = wm8974_read_reg_cache(codec, WM8974_IFACE) & 0x19f;
+	u16 adn = wm8974_read_reg_cache(codec, WM8974_ADD) & 0x1f1;
+
+	/* bit size */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		iface |= 0x0020;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		iface |= 0x0040;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		iface |= 0x0060;
+		break;
+	}
+
+	/* filter coefficient */
+	switch (params_rate(params)) {
+	case SNDRV_PCM_RATE_8000:
+		adn |= 0x5 << 1;
+		break;
+	case SNDRV_PCM_RATE_11025:
+		adn |= 0x4 << 1;
+		break;
+	case SNDRV_PCM_RATE_16000:
+		adn |= 0x3 << 1;
+		break;
+	case SNDRV_PCM_RATE_22050:
+		adn |= 0x2 << 1;
+		break;
+	case SNDRV_PCM_RATE_32000:
+		adn |= 0x1 << 1;
+		break;
+	case SNDRV_PCM_RATE_44100:
+	case SNDRV_PCM_RATE_48000:
+	case SNDRV_PCM_RATE_88200:
+	case SNDRV_PCM_RATE_96000:
+		break;
+	}
+
+	wm8974_write_reg(codec, WM8974_IFACE, iface);
+	wm8974_write_reg(codec, WM8974_ADD, adn);
+
+	return 0;
+}
+
+static int wm8974_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u16 mute_reg = wm8974_read_reg_cache(codec, WM8974_DAC) & 0xffbf;
+	u16 spk_reg = wm8974_read_reg_cache(codec, WM8974_SPKVOL) & 0xffbf;
+
+	if(mute) {
+		wm8974_write_reg(codec, WM8974_SPKVOL, spk_reg | 0x20);
+		wm8974_write_reg(codec, WM8974_DAC, mute_reg | 0x20);
+	}
+	else {
+		wm8974_write_reg(codec, WM8974_DAC, mute_reg);
+		wm8974_write_reg(codec, WM8974_SPKVOL, spk_reg);
+	}
+        return 0;
+}
+
+#define WM8974_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | \
+		      SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | \
+		      SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+		      SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | \
+		      SNDRV_PCM_RATE_96000)
+
+#define WM8974_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE)
+
+static const struct snd_soc_pcm_stream wm8974_hifi_dai_playback = {
+	.stream_name	= "Playback",
+	.channels_min	= 1,
+	.channels_max	= 1,
+	.rates		= WM8974_RATES,
+	.formats	= WM8974_FORMATS,
+};
+
+static const struct snd_soc_pcm_stream wm8974_hifi_dai_capture = {
+	.stream_name	= "Capture",
+	.channels_min	= 1,
+	.channels_max	= 1,
+	.rates		= WM8974_RATES,
+	.formats	= WM8974_FORMATS,
+};
+
+/* dai ops, called by machine drivers */
+static const struct snd_soc_dai_ops wm8974_hifi_dai_ops = {
+	.digital_mute = wm8974_mute,
+	.set_fmt = wm8974_set_dai_fmt,
+	.set_clkdiv = wm8974_set_clkdiv,
+};
+
+/* audio ops, called by alsa */
+static const struct snd_soc_ops wm8974_hifi_dai_audio_ops = {
+	.hw_params = wm8974_pcm_hw_params,
+};
+
+static int wm8974_suspend(struct device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+static int wm8974_resume(struct device *dev)
+{
+	return 0;
+}
+
+static int wm8974_codec_io_probe(struct snd_soc_codec *codec,
+	struct snd_soc_machine *machine)
+{
+	struct wm8974* wm8974 = codec->control_data;
+	u16 reg;
+
+	snd_assert(wm8974 != NULL, return -EINVAL);
+
+	/* reset codec */
+	wm8974_write_reg(codec, WM8974_RESET, 0xFFFF);
+
+	wm8974_write_reg(codec, WM8974_POWER1,
+			 ( 1 << 4) | /* MICBEN */
+			 ( 1 << 3) | /* BIASEN */
+			 ( 1 << 2) | /* BUFIOEN */
+			 ( 3 << 0)   /* VMIDSEL = 11 */
+			 );
+
+	wm8974_write_reg(codec, WM8974_POWER2,
+			 ( 1 << 4) |  /* BOOSTEN */
+			 ( 1 << 2) |  /* INPPGAEN */
+			 ( 1 << 0)    /* ADCEN */
+			 );
+
+	wm8974_write_reg(codec, WM8974_POWER3,
+			 ( 1 << 0) | /* DACEN */
+			 ( 1 << 5) | /* SPKPEN */
+			 ( 1 << 6) | /* SPKNEN */
+			 ( 1 << 2)   /* SPKMIXEN */
+			 );
+
+	wm8974_write_reg(codec, WM8974_DAC,
+			 ( 1 << 6) | /* DACMU */
+			 ( 1 << 3)   /* DACOSR128 */
+			 );
+
+	wm8974_write_reg(codec, WM8974_ADC,
+			 ( 1 << 8) |  /* HPFEN */
+			 ( 1 << 7) |  /* HPFAPP */
+			 ( 2 << 4) |  /* HPFCUT = 010 */
+			 ( 1 << 3)    /* ADCOSR */
+			 );
+
+	wm8974_write_reg(codec, WM8974_ADCBOOST,
+			 ( 1 << 8)    /* PGAPOOST */
+			 );
+
+	wm8974_write_reg(codec, WM8974_SPKMIX,
+			 ( 1 << 0)   /* DAC2SPK */
+			 );
+
+	wm8974_write_reg(codec, WM8974_SPKVOL,
+			 ( 1 << 6) | /* SPKMUTE */
+			 ( 1 << 7)   /* SPKZC */
+			 );
+
+#if 1
+	/* default volumes */
+	reg = wm8974_read_reg_cache(codec, WM8974_INPPGA) & 0x1C0;
+	wm8974_write_reg(codec, WM8974_INPPGA, reg |
+			 ( 47 << 0 )  /* INPPGAVOL */
+			 );
+
+	reg = wm8974_read_reg_cache(codec, WM8974_SPKVOL) & 0x1C0;
+	wm8974_write_reg(codec, WM8974_SPKVOL, reg |
+			 ( 63 << 0)   /* SPKVOL */
+			 );
+#endif
+
+	wm8974_add_controls(codec, machine->card);
+	wm8974_add_widgets(codec, machine);
+
+	return 0;
+}
+
+static int wm8974_codec_io_remove(struct snd_soc_codec *codec,
+	struct snd_soc_machine *machine)
+{
+	return 0;
+}
+
+static const struct snd_soc_codec_ops wm8974_codec_ops = {
+	.read		= wm8974_read_reg_cache,
+	.write		= wm8974_write_reg,
+	.io_probe	= wm8974_codec_io_probe,
+	.io_remove	= wm8974_codec_io_remove,
+};
+
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+static struct i2c_client *wm8974_i2c_client;
+
+static int wm8974_i2c_probe(struct i2c_client *client)
+{
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&client->dev, "No SMBUS byte data capability\n");
+		return -EEXIST;
+	}
+
+	wm8974_i2c_client = client;
+
+	return 0;
+}
+
+static int wm8974_i2c_remove(struct i2c_client *client)
+{
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+	kfree(codec->reg_cache);
+	return 0;
+}
+
+static struct i2c_driver wm8974_i2c_driver = {
+	.driver = {
+		.name = "wm8974-i2c",
+		.owner = THIS_MODULE,
+	},
+	.probe	= wm8974_i2c_probe,
+	.remove	= wm8974_i2c_remove,
+};
+#endif
+
+
+static int wm8974_codec_probe(struct device *dev)
+{
+	struct snd_soc_codec *codec = to_snd_soc_codec(dev);
+
+	printk(KERN_INFO "WM8974 Audio Codec %s\n", WM8974_VERSION);
+
+	codec->owner = THIS_MODULE;
+	codec->ops = &wm8974_codec_ops;
+	codec->reg_cache_size = ARRAY_SIZE(wm8974_reg);
+	codec->reg_cache = kmemdup(wm8974_reg, sizeof(wm8974_reg), GFP_KERNEL);
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	codec->control_data = wm8974_i2c_client;
+	codec->mach_write = i2c_master_send;
+#endif
+
+ 	snd_soc_register_codec(codec);
+
+	return 0;
+}
+
+static int wm8974_codec_remove(struct device *dev)
+{
+	struct snd_soc_codec *codec = to_snd_soc_codec(dev);
+	kfree(codec->private_data);
+	return 0;
+}
+
+static int wm8974_hifi_dai_probe(struct device *dev)
+{
+	struct snd_soc_dai *dai = to_snd_soc_dai(dev);
+
+	dai->ops = &wm8974_hifi_dai_ops;
+	dai->audio_ops = &wm8974_hifi_dai_audio_ops;
+	dai->capture = &wm8974_hifi_dai_capture;
+	dai->playback = &wm8974_hifi_dai_playback;
+	snd_soc_register_codec_dai(dai);
+	return 0;
+}
+
+const char wm8974_codec[SND_SOC_CODEC_NAME_SIZE] = "wm8974-codec";
+EXPORT_SYMBOL_GPL(wm8974_codec);
+
+static struct snd_soc_device_driver wm8974_codec_driver = {
+	.type	= SND_SOC_BUS_TYPE_CODEC,
+	.driver	= {
+		.name 		= wm8974_codec,
+		.owner		= THIS_MODULE,
+		.bus 		= &asoc_bus_type,
+		.probe		= wm8974_codec_probe,
+		.remove		= __devexit_p(wm8974_codec_remove),
+		.suspend	= wm8974_suspend,
+		.resume		= wm8974_resume,
+	},
+};
+
+const char wm8974_hifi_dai[SND_SOC_CODEC_NAME_SIZE] = "wm8974-hifi-dai";
+EXPORT_SYMBOL_GPL(wm8974_hifi_dai);
+
+static struct snd_soc_device_driver wm8974_hifi_dai_driver = {
+	.type	= SND_SOC_BUS_TYPE_DAI,
+	.driver	= {
+		.name 		= wm8974_hifi_dai,
+		.owner		= THIS_MODULE,
+		.bus 		= &asoc_bus_type,
+		.probe		= wm8974_hifi_dai_probe,
+	},
+};
+
+static __init int wm8974_init(void)
+{
+	int ret = 0;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	ret = i2c_add_driver(&wm8974_i2c_driver);
+	if (ret != 0)
+		goto error0;
+#endif
+
+	ret = driver_register(&wm8974_codec_driver.driver);
+	if (ret < 0)
+		goto error1;
+
+	ret = driver_register(&wm8974_hifi_dai_driver.driver);
+	if (ret < 0)
+		goto error2;
+
+	return ret;
+
+ error2:
+	driver_unregister(&wm8974_codec_driver.driver);
+ error1:
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8974_i2c_driver);
+#endif
+ error0:
+	return ret;
+}
+
+static __exit void wm8974_exit(void)
+{
+	driver_unregister(&wm8974_hifi_dai_driver.driver);
+	driver_unregister(&wm8974_codec_driver.driver);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8974_i2c_driver);
+#endif
+}
+
+module_init(wm8974_init);
+module_exit(wm8974_exit);
+
+MODULE_DESCRIPTION("ASoC WM8974 driver");
+MODULE_AUTHOR("Richard Titmuss");
+MODULE_LICENSE("GPL");
Index: linux-2.6.24/sound/soc/codecs/wm8974.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24/sound/soc/codecs/wm8974.h	2009-01-26 19:08:10.000000000 +0100
@@ -0,0 +1,96 @@
+/*
+ * wm8974.h  --  WM8974 Soc Audio driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _WM8974_H
+#define _WM8974_H
+
+/* WM8974 register space */
+
+#define WM8974_RESET		0x0
+#define WM8974_POWER1		0x1
+#define WM8974_POWER2		0x2
+#define WM8974_POWER3		0x3
+#define WM8974_IFACE		0x4
+#define WM8974_COMP			0x5
+#define WM8974_CLOCK		0x6
+#define WM8974_ADD			0x7
+#define WM8974_GPIO			0x8
+#define WM8974_DAC			0xa
+#define WM8974_DACVOL		0xb
+#define WM8974_ADC			0xe
+#define WM8974_ADCVOL		0xf
+#define WM8974_EQ1			0x12
+#define WM8974_EQ2			0x13
+#define WM8974_EQ3			0x14
+#define WM8974_EQ4			0x15
+#define WM8974_EQ5			0x16
+#define WM8974_DACLIM1		0x18
+#define WM8974_DACLIM2		0x19
+#define WM8974_NOTCH1		0x1b
+#define WM8974_NOTCH2		0x1c
+#define WM8974_NOTCH3		0x1d
+#define WM8974_NOTCH4		0x1e
+#define WM8974_ALC1			0x20
+#define WM8974_ALC2			0x21
+#define WM8974_ALC3			0x22
+#define WM8974_NGATE		0x23
+#define WM8974_PLLN			0x24
+#define WM8974_PLLK1		0x25
+#define WM8974_PLLK2		0x26
+#define WM8974_PLLK3		0x27
+#define WM8974_ATTEN		0x28
+#define WM8974_INPUT		0x2c
+#define WM8974_INPPGA		0x2d
+#define WM8974_ADCBOOST		0x2f
+#define WM8974_OUTPUT		0x31
+#define WM8974_SPKMIX		0x32
+#define WM8974_SPKVOL		0x36
+#define WM8974_MONOMIX		0x38
+
+#define WM8974_CACHEREGNUM 	57
+
+/* Clock divider Id's */
+#define WM8974_OPCLKDIV		0
+#define WM8974_MCLKDIV		1
+#define WM8974_ADCCLK		2
+#define WM8974_DACCLK		3
+#define WM8974_BCLKDIV		4
+
+/* DAC clock dividers */
+#define WM8974_DACCLK_F2	(1 << 3)
+#define WM8974_DACCLK_F4	(0 << 3)
+
+/* ADC clock dividers */
+#define WM8974_ADCCLK_F2	(1 << 3)
+#define WM8974_ADCCLK_F4	(0 << 3)
+
+/* PLL Out dividers */
+#define WM8974_OPCLKDIV_1	(0 << 4)
+#define WM8974_OPCLKDIV_2	(1 << 4)
+#define WM8974_OPCLKDIV_3	(2 << 4)
+#define WM8974_OPCLKDIV_4	(3 << 4)
+
+/* BCLK clock dividers */
+#define WM8974_BCLKDIV_1	(0 << 2)
+#define WM8974_BCLKDIV_2	(1 << 2)
+#define WM8974_BCLKDIV_4	(2 << 2)
+#define WM8974_BCLKDIV_8	(3 << 2)
+#define WM8974_BCLKDIV_16	(4 << 2)
+#define WM8974_BCLKDIV_32	(5 << 2)
+
+/* MCLK clock dividers */
+#define WM8974_MCLKDIV_1	(0 << 5)
+#define WM8974_MCLKDIV_1_5	(1 << 5)
+#define WM8974_MCLKDIV_2	(2 << 5)
+#define WM8974_MCLKDIV_3	(3 << 5)
+#define WM8974_MCLKDIV_4	(4 << 5)
+#define WM8974_MCLKDIV_6	(5 << 5)
+#define WM8974_MCLKDIV_8	(6 << 5)
+#define WM8974_MCLKDIV_12	(7 << 5)
+
+#endif
Index: linux-2.6.24/sound/soc/imx/fab4-ak4420.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24/sound/soc/imx/fab4-ak4420.c	2009-01-26 19:08:10.000000000 +0100
@@ -0,0 +1,342 @@
+/*
+ * fab4-ak4420.c
+ *
+ * Copyright 2008 Logitech
+ *	Richard Titmuss <richard_titmuss@logitech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mxc.h>
+
+#include "imx-pcm.h"
+#include "imx-ssi.h"
+
+
+extern void gpio_activate_audio_ports(int ssi_port);
+extern const char ak4420_codec[SND_SOC_CODEC_NAME_SIZE];
+extern const char ak4420_dai[SND_SOC_CODEC_NAME_SIZE];
+
+static void headphone_detect_handler(struct work_struct *work);
+static DECLARE_WORK(hp_event, headphone_detect_handler);
+static struct snd_soc_machine *fab4_mach;
+
+static void fab4_init_dam(int ssi_port, int dai_port)
+{
+	/* AK4420 uses SSI1 or SSI2 via AUDMUX port dai_port for audio */
+
+	/* reset port ssi_port & dai_port */
+	DAM_PTCR(ssi_port) = 0;
+	DAM_PDCR(ssi_port) = 0;
+	DAM_PTCR(dai_port) = 0;
+	DAM_PDCR(dai_port) = 0;
+
+	/* set to synchronous */
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_SYN;
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_SYN;
+
+	/* set Rx sources ssi_port <--> dai_port */
+	DAM_PDCR(ssi_port) |= AUDMUX_PDCR_RXDSEL(dai_port);
+	DAM_PDCR(dai_port) |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+	/* set Tx frame direction and source  ssi_port --> dai_port output */
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TFSDIR;
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, ssi_port);
+
+	/* set Tx Clock direction and source ssi_port--> dai_port output */
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TCLKDIR;
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, ssi_port);
+}
+
+static int fab4_hifi_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_link *pcm_link = substream->private_data;
+	struct mxc_audio_platform_data *dev_data = pcm_link->private_data;
+	struct snd_soc_dai *cpu_dai = pcm_link->cpu_dai;
+	unsigned int channels = params_channels(params);
+	unsigned int rate = params_rate(params);
+	u32 dai_format;
+
+	fab4_init_dam(dev_data->src_port, dev_data->ext_port);
+
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_IF |
+	    SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_SYNC;
+
+	if (channels == 2)
+		dai_format |= SND_SOC_DAIFMT_TDM;
+
+	/* set cpu DAI configuration */
+	cpu_dai->ops->set_fmt(cpu_dai, dai_format);
+
+	/* set i.MX active slot mask */
+	cpu_dai->ops->set_tdm_slot(cpu_dai,
+				   channels == 1 ? 0xfffffffe : 0xfffffffc,
+				   channels);
+
+	/* set the SSI system clock as input (unused) */
+	cpu_dai->ops->set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0, SND_SOC_CLOCK_IN);
+
+	/* set BCLK division for sample rate */
+	switch (rate) {
+	case 96000:
+	case 88200:
+		cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 0);
+		break;
+	default:
+		cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 1);
+		break;
+	}
+
+	if (dev_data->audio_set_clk) {
+		(dev_data->audio_set_clk)(rate);
+	}
+
+	return 0;
+}
+
+/*
+ * fab4 ak4420 HiFi DAI opserations.
+ */
+static struct snd_soc_ops fab4_hifi_ops = {
+	.hw_params = fab4_hifi_hw_params,
+};
+
+static int hifi_pcm_new(struct snd_soc_pcm_link *pcm_link)
+{
+	int ret;
+	pcm_link->audio_ops = &fab4_hifi_ops;
+	ret = snd_soc_pcm_new(pcm_link, 1, 0);
+	if (ret < 0) {
+		pr_err("%s: Failed to create hifi pcm\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+struct snd_soc_pcm_link_ops hifi_pcm = {
+	.new = hifi_pcm_new,
+};
+
+static void headphone_detect_handler(struct work_struct *work)
+{
+	sysfs_notify(&fab4_mach->pdev->dev.driver->kobj, NULL,
+		     "headphone");
+
+}
+
+static irqreturn_t imx_headphone_detect_handler(int irq, void *dev_id)
+{
+	schedule_work(&hp_event);
+	return IRQ_HANDLED;
+
+}
+
+static int fab4_mach_probe(struct snd_soc_machine
+				 *machine)
+{
+	struct snd_soc_codec *codec;
+	struct snd_soc_pcm_link *pcm_link;
+	int ret;
+
+	pcm_link = list_first_entry(&machine->active_list,
+				    struct snd_soc_pcm_link, active_list);
+	codec = pcm_link->codec;
+
+	snd_soc_dapm_set_policy(machine, SND_SOC_DAPM_POLICY_STREAM);
+
+	/* register card with ALSA upper layers */
+	ret = snd_soc_register_card(machine);
+	if (ret < 0) {
+		pr_err("%s: failed to register sound card\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+struct snd_soc_machine_ops fab4_mach_ops = {
+	.mach_probe = fab4_mach_probe,
+};
+
+static ssize_t show_headphone(struct device_driver *dev, char *buf)
+{
+#if 0
+	unsigned int value;
+
+	if (value == 0)
+		strcpy(buf, "speaker\n");
+	else
+		strcpy(buf, "headphone\n");
+#endif
+	strcpy(buf, "fixme\n");
+
+	return strlen(buf);
+}
+
+DRIVER_ATTR(headphone, S_IRUGO | S_IWUSR, show_headphone, NULL);
+
+/*
+ * This function will register the snd_soc_pcm_link drivers.
+ * It also registers devices for platform DMA, I2S, SSP and registers an
+ * I2C driver to probe the codec.
+ */
+static int __init fab4_ak4420_probe(struct platform_device *pdev)
+{
+	struct snd_soc_machine *machine;
+	struct mxc_audio_platform_data *dev_data = pdev->dev.platform_data;
+	struct snd_soc_pcm_link *hifi;
+	const char *ssi_port;
+	int ret;
+
+	machine = kzalloc(sizeof(struct snd_soc_machine), GFP_KERNEL);
+	if (machine == NULL)
+		return -ENOMEM;
+
+	machine->owner = THIS_MODULE;
+	machine->pdev = pdev;
+	machine->name = "fab4";
+	machine->longname = "ak4420";
+	machine->ops = &fab4_mach_ops;
+	pdev->dev.driver_data = machine;
+
+	/* register card */
+	fab4_mach = machine;
+	ret = snd_soc_new_card(machine, 1, SNDRV_DEFAULT_IDX1,
+			       SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		pr_err("%s: failed to create stereo sound card\n", __func__);
+		goto err;
+	}
+
+	/* fab4 ak4420 hifi interface */
+	if (dev_data->src_port == 1)
+		ssi_port = imx_ssi_1;
+	else
+		ssi_port = imx_ssi_3;
+	hifi = snd_soc_pcm_link_new(machine,
+				    "fab4-ak4420", &hifi_pcm,
+				    imx_pcm, ak4420_codec,
+				    ak4420_dai, ssi_port);
+	if (hifi == NULL) {
+		pr_err("Failed to create HiFi PCM link\n");
+		goto err;
+	}
+
+	ret = snd_soc_pcm_link_attach(hifi);
+	hifi->private_data = dev_data;
+	if (ret < 0)
+		goto link_err;
+
+	/* Configure audio port 3 */
+	gpio_activate_audio_ports(dev_data->src_port);
+
+#if 0
+	// XXXX
+	if (request_irq
+	    (dev_data->intr_id_hp, imx_headphone_detect_handler, 0,
+	     "headphone", machine))
+		goto link_err;
+#endif
+
+	ret = driver_create_file(pdev->dev.driver, &driver_attr_headphone);
+	if (ret < 0)
+		goto sysfs_err;
+
+	return ret;
+
+      sysfs_err:
+	driver_remove_file(pdev->dev.driver, &driver_attr_headphone);
+      link_err:
+	snd_soc_machine_free(machine);
+      err:
+	kfree(machine);
+	return ret;
+}
+
+static int __devexit fab4_ak4420_remove(struct platform_device *pdev)
+{
+	struct snd_soc_machine *machine = pdev->dev.driver_data;
+
+	fab4_mach = NULL;
+	driver_remove_file(pdev->dev.driver, &driver_attr_headphone);
+	kfree(machine);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int fab4_ak4420_suspend(struct platform_device
+				     *pdev, pm_message_t state)
+{
+	struct snd_soc_machine *machine = pdev->dev.driver_data;
+	return snd_soc_suspend(machine, state);
+}
+
+static int fab4_ak4420_resume(struct platform_device
+				    *pdev)
+{
+	struct snd_soc_machine *machine = pdev->dev.driver_data;
+	return snd_soc_resume(machine);
+}
+
+#else
+#define fab4_ak4420_suspend NULL
+#define fab4_ak4420_resume  NULL
+#endif
+
+static struct platform_driver fab4_ak4420_driver = {
+	.probe = fab4_ak4420_probe,
+	.remove = __devexit_p(fab4_ak4420_remove),
+	.suspend = fab4_ak4420_suspend,
+	.resume = fab4_ak4420_resume,
+	.driver = {
+		   .name = "fab4-ak4420",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init fab4_asoc_init(void)
+{
+	return platform_driver_register(&fab4_ak4420_driver);
+}
+
+static void __exit fab4_asoc_exit(void)
+{
+	platform_driver_unregister(&fab4_ak4420_driver);
+}
+
+module_init(fab4_asoc_init);
+module_exit(fab4_asoc_exit);
+
+/* Module information */
+MODULE_DESCRIPTION("ALSA SoC ak4420 fab4");
+MODULE_AUTHOR("Richard Titmuss");
+MODULE_LICENSE("GPL");
Index: linux-2.6.24/sound/soc/imx/fab4-wm8974.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24/sound/soc/imx/fab4-wm8974.c	2009-01-26 19:08:14.000000000 +0100
@@ -0,0 +1,370 @@
+/*
+ * fab4-wm8974.c
+ *
+ * Copyright 2008 Logitech
+ *	Richard Titmuss <richard_titmuss@logitech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include <asm/arch/dma.h>
+#include <asm/arch/spba.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mxc.h>
+
+#include "imx-ssi.h"
+#include "imx-pcm.h"
+
+#include "../codecs/wm8974.h"
+
+void gpio_activate_audio_ports(int ssi_port);
+extern const char wm8974_codec[SND_SOC_CODEC_NAME_SIZE];
+extern const char wm8974_hifi_dai[SND_SOC_CODEC_NAME_SIZE];
+
+
+static void fab4_init_dam(int ssi_port, int dai_port)
+{
+	/* WM8974 uses SSI1 or SSI2 via AUDMUX port dai_port for audio */
+
+	/* reset port ssi_port & dai_port */
+	DAM_PTCR(ssi_port) = 0;
+	DAM_PDCR(ssi_port) = 0;
+	DAM_PTCR(dai_port) = 0;
+	DAM_PDCR(dai_port) = 0;
+
+	/* set to synchronous */
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_SYN;
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_SYN;
+
+	/* set Rx sources ssi_port <--> dai_port */
+	DAM_PDCR(ssi_port) |= AUDMUX_PDCR_RXDSEL(dai_port);
+	DAM_PDCR(dai_port) |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+	/* set Tx frame direction and source  dai_port--> ssi_port output */
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TFSDIR;
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, dai_port);
+
+	/* set Tx Clock direction and source dai_port--> ssi_port output */
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TCLKDIR;
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, dai_port);
+}
+
+static int fab4_startup(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static int fab4_hifi_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_link *pcm_link = substream->private_data;
+	struct mxc_audio_platform_data *dev_data = pcm_link->private_data;
+	struct snd_soc_dai *cpu_dai = pcm_link->cpu_dai;
+	struct snd_soc_dai *codec_dai = pcm_link->codec_dai;
+	unsigned int rate = params_rate(params);
+	unsigned int channels = params_channels(params);
+	unsigned int mclkdiv;
+	u32 dai_format;
+
+	fab4_init_dam(dev_data->src_port, dev_data->ext_port);
+
+	switch (rate) {
+	case 8000:
+		mclkdiv = WM8974_MCLKDIV_12;
+		break;
+	case 11025:
+		mclkdiv = WM8974_MCLKDIV_8;
+		break;
+	case 16000:
+		mclkdiv = WM8974_MCLKDIV_6;
+		break;
+	case 22050:
+		mclkdiv = WM8974_MCLKDIV_4;
+		break;
+	case 32000:
+		mclkdiv = WM8974_MCLKDIV_3;
+		break;
+	case 44100:
+		mclkdiv = WM8974_MCLKDIV_2;
+		break;
+	case 48000:
+		mclkdiv = WM8974_MCLKDIV_2;
+		break;
+	case 88200:
+		mclkdiv = WM8974_MCLKDIV_1;
+		break;
+	case 96000:
+		mclkdiv = WM8974_MCLKDIV_1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	    SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_SYNC;
+	if (channels == 2)
+		dai_format |= SND_SOC_DAIFMT_TDM;
+
+	/* set codec DAI configuration */
+	codec_dai->ops->set_fmt(codec_dai, dai_format);
+
+	/* set cpu DAI configuration */
+	cpu_dai->ops->set_fmt(cpu_dai, dai_format);
+
+	/* set i.MX active slot mask */
+	cpu_dai->ops->set_tdm_slot(cpu_dai, 0xfffffffe, 2);
+
+	/* set the SSI system clock as input (unused) */
+	cpu_dai->ops->set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0, SND_SOC_CLOCK_IN);
+
+	/* set codec MCLK and BCLK division for sample rate */
+	if (dev_data->audio_set_clk) {
+		(dev_data->audio_set_clk)(rate);
+	}
+	codec_dai->ops->set_clkdiv(codec_dai, WM8974_BCLKDIV, WM8974_BCLKDIV_4);
+	codec_dai->ops->set_clkdiv(codec_dai, WM8974_MCLKDIV, mclkdiv);
+
+	return 0;
+}
+
+static void fab4_shutdown(struct snd_pcm_substream *substream)
+{
+}
+
+/*
+ * fab4 WM8974 DAI operations.
+ */
+static struct snd_soc_ops fab4_hifi_ops = {
+	.startup = fab4_startup,
+	.shutdown = fab4_shutdown,
+	.hw_params = fab4_hifi_hw_params,
+};
+
+static int fab4_pcm_new(struct snd_soc_pcm_link *pcm_link)
+{
+	int ret;
+
+	pcm_link->audio_ops = &fab4_hifi_ops;
+
+	ret = snd_soc_pcm_new(pcm_link, 1, 1);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: failed to create hifi pcm\n", __func__);
+		return ret;
+	}
+
+	printk(KERN_INFO "fab4 WM8974 Audio Driver\n");
+
+	return 0;
+}
+
+static int fab4_pcm_free(struct snd_soc_pcm_link *pcm_link)
+{
+	return 0;
+}
+
+static const struct snd_soc_pcm_link_ops fab4_pcm_ops = {
+	.new = fab4_pcm_new,
+	.free = fab4_pcm_free,
+};
+
+/* fab4 machine dapm widgets */
+static const struct snd_soc_dapm_widget fab4_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("Mic", NULL),
+	SND_SOC_DAPM_SPK("Speaker", NULL),
+};
+
+/* fab4 machine audio map */
+static const char *audio_map[][3] = {
+	/* speaker connected to codec pins SPKOUTP, SPKOUTN */
+	{"Speaker", NULL, "SPKOUTP" },
+	{"Speaker", NULL, "SPKOUTN" },
+
+	/* mic connected to codec pins MICP, MICN */
+	{"Mic", NULL, "MICP" },
+	{"Mic", NULL, "MICN" },
+
+	{ NULL, NULL, NULL },
+};
+
+static int mach_probe(struct snd_soc_machine *machine)
+{
+	struct snd_soc_codec *codec;
+	struct snd_soc_pcm_link *pcm_link;
+
+	int i, ret;
+
+	pcm_link = list_first_entry(&machine->active_list,
+				    struct snd_soc_pcm_link, active_list);
+
+	codec = pcm_link->codec;
+
+	codec->ops->io_probe(codec, machine);
+
+	/* add fab4 specific widgets */
+	for (i = 0; i < ARRAY_SIZE(fab4_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(machine, codec,
+					 &fab4_dapm_widgets[i]);
+	}
+
+	/* set up fab4 specific audio path audio map */
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(machine, audio_map[i][0],
+					   audio_map[i][1], audio_map[i][2]);
+	}
+
+	/* disable unused WM8974 codec pins */
+	snd_soc_dapm_set_endpoint(machine, "AUX", 0);
+	snd_soc_dapm_set_endpoint(machine, "MONOOUT", 0);
+
+	/* connect and enable all speaker and mic */
+	snd_soc_dapm_set_endpoint(machine, "Speaker", 1);
+	snd_soc_dapm_set_endpoint(machine, "Mic", 1);
+
+	snd_soc_dapm_set_policy(machine, SND_SOC_DAPM_POLICY_PATH);
+	snd_soc_dapm_sync_endpoints(machine);
+
+	/* register card with ALSA upper layers */
+	ret = snd_soc_register_card(machine);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: failed to register sound card\n",
+		       __FUNCTION__);
+		snd_soc_machine_free(machine);
+		return ret;
+	}
+	return 0;
+
+}
+
+struct snd_soc_machine_ops machine_ops = {
+	.mach_probe = mach_probe,
+};
+
+static int __devinit fab4_wm8974_audio_probe(struct platform_device *pdev)
+{
+	struct snd_soc_machine *machine;
+	struct mxc_audio_platform_data *dev_data = pdev->dev.platform_data;
+	struct snd_soc_pcm_link *hifi;
+	const char *ssi_port;
+	int ret;
+
+	machine = kzalloc(sizeof(struct snd_soc_machine), GFP_KERNEL);
+	if (machine == NULL)
+		return -ENOMEM;
+
+	machine->owner = THIS_MODULE;
+	machine->pdev = pdev;
+	machine->name = "fab4";
+	machine->longname = "wm8974";
+	machine->ops = &machine_ops;
+	pdev->dev.driver_data = machine;
+
+	/* register card */
+	ret =
+	    snd_soc_new_card(machine, 1, SNDRV_DEFAULT_IDX1,
+			     SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: failed to create pcms\n", __func__);
+		return ret;
+	}
+
+	/* WM8974 hifi interface */
+	ret = -ENODEV;
+
+	if (dev_data->src_port == 1)
+		ssi_port = imx_ssi_1;
+	else
+		ssi_port = imx_ssi_3;
+
+	hifi = snd_soc_pcm_link_new(machine, "fab4-wm8974",
+				    &fab4_pcm_ops, imx_pcm,
+				    wm8974_codec, wm8974_hifi_dai,
+				    ssi_port);
+	if (hifi == NULL) {
+		printk(KERN_ERR "failed to create PCM link\n");
+		snd_soc_machine_free(machine);
+		return ret;
+	}
+
+	ret = snd_soc_pcm_link_attach(hifi);
+	hifi->private_data = dev_data;
+	if (ret < 0) {
+		printk(KERN_ERR "%s: failed to attach hifi pcm\n", __func__);
+		snd_soc_machine_free(machine);
+		return ret;
+	}
+
+	gpio_activate_audio_ports(dev_data->src_port);
+
+	return ret;
+}
+
+static int __devexit fab4_wm8974_audio_remove(struct platform_device *pdev)
+{
+	struct snd_soc_machine *machine = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec;
+	struct snd_soc_pcm_link *pcm_link;
+
+	pcm_link = list_first_entry(&machine->active_list,
+				    struct snd_soc_pcm_link, active_list);
+
+	codec = pcm_link->codec;
+	codec->ops->io_remove(codec, machine);
+
+	snd_soc_machine_free(machine);
+	return 0;
+}
+
+static struct platform_driver fab4_wm8974_audio_driver = {
+	.probe = fab4_wm8974_audio_probe,
+	.remove = __devexit_p(fab4_wm8974_audio_remove),
+	.driver = {
+		   .name = "fab4-wm8974",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init fab4_wm8974_audio_init(void)
+{
+	return platform_driver_register(&fab4_wm8974_audio_driver);
+}
+
+static void __exit fab4_wm8974_audio_exit(void)
+{
+	platform_driver_unregister(&fab4_wm8974_audio_driver);
+}
+
+module_init(fab4_wm8974_audio_init);
+module_exit(fab4_wm8974_audio_exit);
+
+MODULE_DESCRIPTION("ALSA SoC wm8974 fab4");
+MODULE_AUTHOR("Richard Titmuss");
+MODULE_LICENSE("GPL");
Index: linux-2.6.24/sound/soc/imx/imx-ssi.c
===================================================================
--- linux-2.6.24.orig/sound/soc/imx/imx-ssi.c	2009-01-26 18:51:42.000000000 +0100
+++ linux-2.6.24/sound/soc/imx/imx-ssi.c	2009-01-26 19:08:11.000000000 +0100
@@ -275,7 +275,8 @@ static int imx_ssi_set_dai_fmt(struct sn
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBS_CFS:
 		stcr |= SSI_STCR_TFDIR | SSI_STCR_TXDIR;
-		srcr |= SSI_SRCR_RFDIR | SSI_SRCR_RXDIR;
+		/* Don't enable the rx clock for I2S master */
+		/* srcr |= SSI_SRCR_RFDIR | SSI_SRCR_RXDIR; */
 		if (((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_I2S)
 		    && (fmt & SND_SOC_DAIFMT_TDM)) {
 			scr &= ~SSI_SCR_I2S_MODE_MASK;
Index: linux-2.6.24/sound/soc/imx/Kconfig
===================================================================
--- linux-2.6.24.orig/sound/soc/imx/Kconfig	2009-01-26 18:51:42.000000000 +0100
+++ linux-2.6.24/sound/soc/imx/Kconfig	2009-01-26 19:08:11.000000000 +0100
@@ -42,3 +42,20 @@ config SND_SOC_IMX_3STACK_WM8580
  help
    Say Y if you want to add support for Soc audio on IMX 3STACK
    with the WM8580
+
+config SND_SOC_FAB4_AK4420
+ tristate "SoC Audio support for Logitech Fab4 - AK4420"
+ select SND_MXC_SOC_SSI
+ select SND_SOC_AK4420
+ help
+   Say Y if you want to add support for SoC audio on Logitech Fab4
+   with the AK4420.
+
+config SND_SOC_FAB4_WM8974
+ tristate "SoC Audio support for Logitech Fab4 - WM8974"
+ select SND_MXC_SOC_SSI
+ select SND_SOC_WM8974
+ help
+   Say Y if you want to add support for SoC audio on Logitech Fab4
+   with the WM8974.
+
Index: linux-2.6.24/sound/soc/imx/Makefile
===================================================================
--- linux-2.6.24.orig/sound/soc/imx/Makefile	2009-01-26 18:51:42.000000000 +0100
+++ linux-2.6.24/sound/soc/imx/Makefile	2009-01-26 19:08:11.000000000 +0100
@@ -14,3 +14,7 @@ snd-soc-imx-3stack-ak4647-objs := imx-3s
 obj-$(CONFIG_SND_SOC_IMX_3STACK_AK4647) += snd-soc-imx-3stack-ak4647.o
 snd-soc-imx-3stack-wm8580-objs := imx-3stack-wm8580.o
 obj-$(CONFIG_SND_SOC_IMX_3STACK_WM8580) += snd-soc-imx-3stack-wm8580.o
+snd-soc-fab4-ak4420-objs := fab4-ak4420.o
+obj-$(CONFIG_SND_SOC_FAB4_AK4420) += snd-soc-fab4-ak4420.o
+snd-soc-fab4-wm8974-objs := fab4-wm8974.o
+obj-$(CONFIG_SND_SOC_FAB4_WM8974) += snd-soc-fab4-wm8974.o
