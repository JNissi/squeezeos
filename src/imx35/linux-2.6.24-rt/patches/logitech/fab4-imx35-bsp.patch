---
 arch/arm/configs/imx35_3stack_defconfig  |   35 +
 arch/arm/kernel/setup.c                  |   23 
 arch/arm/mach-mx3/time.c                 |  152 +++++
 arch/arm/mach-mx35/Kconfig               |    8 
 arch/arm/mach-mx35/Makefile              |    1 
 arch/arm/mach-mx35/board-mx35_fab4.h     |  107 +++
 arch/arm/mach-mx35/clock.c               |  381 ++++++++-----
 arch/arm/mach-mx35/cpu.c                 |    5 
 arch/arm/mach-mx35/crm_regs.h            |   33 -
 arch/arm/mach-mx35/devices.c             |  226 ++++++-
 arch/arm/mach-mx35/mx35_3stack.c         |   99 +++
 arch/arm/mach-mx35/mx35_3stack_gpio.c    |   54 +
 arch/arm/mach-mx35/mx35_3stack_irq.c     |    1 
 arch/arm/mach-mx35/mx35_fab4.c           |  742 +++++++++++++++++++++++++
 arch/arm/mach-mx35/mx35_fab4_gpio.c      |  908 +++++++++++++++++++++++++++++++
 arch/arm/mach-mx35/sdma_script_code_v2.h |  234 +++++++
 arch/arm/mach-mx35/serial.c              |    1 
 arch/arm/tools/mach-types                |    1 
 18 files changed, 2815 insertions(+), 196 deletions(-)

Index: linux-2.6.24/arch/arm/configs/imx35_3stack_defconfig
===================================================================
--- linux-2.6.24.orig/arch/arm/configs/imx35_3stack_defconfig	2009-01-26 18:52:00.000000000 +0100
+++ linux-2.6.24/arch/arm/configs/imx35_3stack_defconfig	2009-01-26 19:07:59.000000000 +0100
@@ -346,7 +346,39 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_LAPB is not set
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_RR is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_INGRESS is not set
+
+#
+# Classification
+#
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+# CONFIG_NET_CLS_POLICE is not set
+CONFIG_NET_SCH_FIFO=y
 
 #
 # Network testing
@@ -1194,6 +1226,7 @@ CONFIG_MMC=y
 CONFIG_MMC_BLOCK=y
 CONFIG_MMC_BLOCK_BOUNCE=y
 # CONFIG_SDIO_UART is not set
+CONFIG_SDIO_UNIFI_FS=m
 
 #
 # MMC/SD Host Controller Drivers
Index: linux-2.6.24/arch/arm/kernel/setup.c
===================================================================
--- linux-2.6.24.orig/arch/arm/kernel/setup.c	2009-01-26 18:51:42.000000000 +0100
+++ linux-2.6.24/arch/arm/kernel/setup.c	2009-01-26 19:07:59.000000000 +0100
@@ -76,6 +76,9 @@ EXPORT_SYMBOL(system_serial_low);
 unsigned int system_serial_high;
 EXPORT_SYMBOL(system_serial_high);
 
+u8 system_uuid[16];
+EXPORT_SYMBOL(system_uuid);
+
 unsigned int elf_hwcap;
 EXPORT_SYMBOL(elf_hwcap);
 
@@ -708,6 +711,18 @@ static int __init parse_tag_serialnr(con
 
 __tagtable(ATAG_SERIAL, parse_tag_serialnr);
 
+static int __init parse_tag_uuid(const struct tag *tag)
+{
+	int i;
+
+	for (i=0; i<16; i++) {
+		system_uuid[i] = tag->u.uuid.value[i];
+	}
+	return 0;
+}
+
+__tagtable(ATAG_UUID, parse_tag_uuid);
+
 static int __init parse_tag_revision(const struct tag *tag)
 {
 	system_rev = tag->u.revision.rev;
@@ -1009,6 +1024,14 @@ static int c_show(struct seq_file *m, vo
 	seq_printf(m, "Revision\t: %04x\n", system_rev);
 	seq_printf(m, "Serial\t\t: %08x%08x\n",
 		   system_serial_high, system_serial_low);
+	seq_printf(m, "UUID\t\t: ");
+	for (i=0; i<16; i++) {
+		seq_printf(m, "%02x", system_uuid[i]);
+		if (i == 3 || i == 5 || i == 7 || i == 9) {
+			seq_printf(m, "-");
+		}
+	}
+	seq_printf(m, "\n");
 
 	return 0;
 }
Index: linux-2.6.24/arch/arm/mach-mx3/time.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24/arch/arm/mach-mx3/time.c	2009-01-26 19:07:59.000000000 +0100
@@ -0,0 +1,152 @@
+/*
+ * System Timer Interrupt reconfigured to run in free-run mode.
+ * Author: Vitaly Wool
+ * Copyright 2004 MontaVista Software Inc.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*!
+ * @file time.c
+ * @brief This file contains OS tick and wdog timer implementations.
+ *
+ * This file contains OS tick and wdog timer implementations.
+ *
+ * @ingroup Timers
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/hardware.h>
+#include <asm/mach/time.h>
+#include <asm/io.h>
+#include <asm/arch/common.h>
+
+/*!
+ * This is the timer interrupt service routine to do required tasks.
+ * It also services the WDOG timer at the frequency of twice per WDOG
+ * timeout value. For example, if the WDOG's timeout value is 4 (2
+ * seconds since the WDOG runs at 0.5Hz), it will be serviced once
+ * every 2/2=1 second.
+ *
+ * @param  irq          GPT interrupt source number (not used)
+ * @param  dev_id       this parameter is not used
+ * @return always returns \b IRQ_HANDLED as defined in
+ *         include/linux/interrupt.h.
+ */
+static irqreturn_t mxc_timer_interrupt(int irq, void *dev_id)
+{
+	unsigned int next_match;
+
+	write_seqlock(&xtime_lock);
+
+	if (__raw_readl(MXC_GPT_GPTSR) & GPTSR_OF1) {
+		do {
+			timer_tick();
+			next_match = __raw_readl(MXC_GPT_GPTOCR1) + LATCH;
+			__raw_writel(GPTSR_OF1, MXC_GPT_GPTSR);
+			__raw_writel(next_match, MXC_GPT_GPTOCR1);
+		} while ((signed long)(next_match -
+				       __raw_readl(MXC_GPT_GPTCNT)) <= 0);
+	}
+
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is used to obtain the number of microseconds since the last
+ * timer interrupt. Note that interrupts is disabled by do_gettimeofday().
+ *
+ * @return the number of microseconds since the last timer interrupt.
+ */
+static unsigned long mxc_gettimeoffset(void)
+{
+	unsigned long ticks_to_match, elapsed, usec, tick_usec, i;
+
+	/* Get ticks before next timer match */
+	ticks_to_match =
+	    __raw_readl(MXC_GPT_GPTOCR1) - __raw_readl(MXC_GPT_GPTCNT);
+
+	/* We need elapsed ticks since last match */
+	elapsed = LATCH - ticks_to_match;
+
+	/* Now convert them to usec */
+	/* Insure no overflow when calculating the usec below */
+	for (i = 1, tick_usec = tick_nsec / 1000;; i *= 2) {
+		tick_usec /= i;
+		if ((0xFFFFFFFF / tick_usec) > elapsed)
+			break;
+	}
+	usec = (unsigned long)(elapsed * tick_usec) / (LATCH / i);
+
+	return usec;
+}
+
+/*!
+ * The OS tick timer interrupt structure.
+ */
+static struct irqaction timer_irq = {
+	.name = "MXC Timer Tick",
+	.flags = IRQF_DISABLED | IRQF_TIMER,
+	.handler = mxc_timer_interrupt
+};
+
+/*!
+ * This function is used to initialize the GPT to produce an interrupt
+ * based on HZ.  It is called by start_kernel() during system startup.
+ */
+void __init mxc_init_time(void)
+{
+	u32 reg, v;
+	reg = __raw_readl(MXC_GPT_GPTCR);
+	reg &= ~GPTCR_ENABLE;
+	__raw_writel(reg, MXC_GPT_GPTCR);
+	reg |= GPTCR_SWR;
+	__raw_writel(reg, MXC_GPT_GPTCR);
+
+	while ((__raw_readl(MXC_GPT_GPTCR) & GPTCR_SWR) != 0)
+		cpu_relax();
+
+	reg = GPTCR_FRR | GPTCR_CLKSRC_HIGHFREQ;
+	__raw_writel(reg, MXC_GPT_GPTCR);
+
+	/* TODO: get timer rate from clk driver */
+	v = 66500000;
+
+	__raw_writel((v / CLOCK_TICK_RATE) - 1, MXC_GPT_GPTPR);
+
+	if ((v % CLOCK_TICK_RATE) != 0) {
+		pr_info("\nWARNING: Can't generate CLOCK_TICK_RATE at %d Hz\n",
+			CLOCK_TICK_RATE);
+	}
+	pr_info("Actual CLOCK_TICK_RATE is %d Hz\n",
+		v / ((__raw_readl(MXC_GPT_GPTPR) & 0xFFF) + 1));
+
+	reg = __raw_readl(MXC_GPT_GPTCNT);
+	reg += LATCH;
+	__raw_writel(reg, MXC_GPT_GPTOCR1);
+
+	setup_irq(MXC_INT_GPT, &timer_irq);
+
+	reg = __raw_readl(MXC_GPT_GPTCR);
+	reg =
+	    GPTCR_FRR | GPTCR_CLKSRC_HIGHFREQ | GPTCR_STOPEN | GPTCR_DOZEN |
+	    GPTCR_WAITEN | GPTCR_ENMOD | GPTCR_ENABLE;
+	__raw_writel(reg, MXC_GPT_GPTCR);
+
+	__raw_writel(GPTIR_OF1IE, MXC_GPT_GPTIR);
+}
+
+struct sys_timer mxc_timer = {
+	.init = mxc_init_time,
+	.offset = mxc_gettimeoffset,
+};
Index: linux-2.6.24/arch/arm/mach-mx35/board-mx35_fab4.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24/arch/arm/mach-mx35/board-mx35_fab4.h	2009-01-26 19:07:59.000000000 +0100
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX35_FAB4_H__
+#define __ASM_ARCH_MXC_BOARD_MX35_FAB4_H__
+
+#ifdef CONFIG_MACH_FAB4
+
+/*!
+ * @defgroup BRDCFG_MX35 Board Configuration Options
+ * @ingroup MSL_MX35
+ */
+
+/*!
+ * @file mach-mx35/board-mx35_fab4.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for Logitech MX35 Fab4 Platform.
+ *
+ * @ingroup BRDCFG_MX35
+ */
+
+/*
+ * Include Files
+ */
+#include <asm/arch/mxc_uart.h>
+
+/*!
+ * @name MXC UART EVB board level configurations
+ */
+/*! @{ */
+/*!
+ * Specifies if the Irda transmit path is inverting
+ */
+#define MXC_IRDA_TX_INV         0
+/*!
+ * Specifies if the Irda receive path is inverting
+ */
+#define MXC_IRDA_RX_INV         0
+
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE              MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR                NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED           1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE              MODE_DCE
+#define UART2_IR                NO_IRDA
+#define UART2_ENABLED           1
+
+/* UART 3 configuration */
+#define UART3_MODE              MODE_DTE
+#define UART3_IR                NO_IRDA
+#define UART3_ENABLED           0
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+#define MXC_PSEUDO_PARENT	MXC_INT_RESV0
+
+
+#define AHB_FREQ                133000000
+#define IPG_FREQ                66500000
+
+
+extern void mxc_map_io(void);
+extern void mxc_init_irq(void);
+extern void mxc_cpu_init(void) __init;
+extern void mx35_fab4_gpio_init(void) __init;
+extern struct sys_timer mxc_timer;
+extern void mxc_cpu_common_init(void);
+extern int mxc_clocks_init(void);
+extern void __init early_console_setup(char *);
+extern void gpio_tsc_active(void);
+extern void gpio_tsc_inactive(void);
+extern unsigned int sdhc_get_card_det_status(struct device *dev);
+extern unsigned int sdhc_get_card_wp_status(void);
+
+#endif				/* CONFIG_MACH_FAB4 */
+#endif				/* __ASM_ARCH_MXC_BOARD_MX35_FAB4_H__ */
Index: linux-2.6.24/arch/arm/mach-mx35/clock.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx35/clock.c	2009-01-26 18:52:00.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx35/clock.c	2009-01-26 19:07:59.000000000 +0100
@@ -135,9 +135,11 @@ static unsigned long _clk_round_rate(str
 	if (clk->parent->rate % rate)
 		div++;
 
-	__calc_two_dividers(div, &pre, &post);
-
-	return clk->parent->rate / (pre * post);
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+		__calc_two_dividers(div, &pre, &post);
+		return clk->parent->rate / (pre * post);
+	} else
+		return clk->parent->rate / div;
 }
 
 static int __switch_cpu_wp(struct clk *clk, unsigned long rate)
@@ -211,11 +213,13 @@ static int __switch_cpu_rate(struct clk 
 static int __get_arm_div(unsigned long pdr0, int *fi, int *fd)
 {
 	int *pclk_mux;
-	if (pdr0 & MXC_CCM_PDR0_AUTO_CON) {
-		pclk_mux = g_clk_mux_consumer +
+	if ((pdr0 & MXC_CCM_PDR0_AUTO_CON)
+	    || (cpu_is_mx35_rev(CHIP_REV_2_0) >= 1))
+		pclk_mux =
+		    g_clk_mux_consumer +
 		    ((pdr0 & MXC_CCM_PDR0_CON_MUX_DIV_MASK) >>
 		     MXC_CCM_PDR0_CON_MUX_DIV_OFFSET);
-	} else {
+	else {
 		pclk_mux = g_clk_mux_auto +
 		    ((pdr0 & MXC_CCM_PDR0_AUTO_MUX_DIV_MASK) >>
 		     MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET);
@@ -231,7 +235,8 @@ static int __get_arm_div(unsigned long p
 			*fi = *fd = 1;
 			return CLK_CODE_ARM(*pclk_mux);
 		}
-		if (pdr0 & MXC_CCM_PDR0_AUTO_CON) {
+		if ((pdr0 & MXC_CCM_PDR0_AUTO_CON)
+		    || (cpu_is_mx35_rev(CHIP_REV_2_0) >= 1)) {
 			*fi = 3;
 			*fd = 4;
 		} else {
@@ -245,8 +250,10 @@ static int __get_arm_div(unsigned long p
 static int __get_ahb_div(unsigned long pdr0)
 {
 	int *pclk_mux;
-	if (pdr0 & MXC_CCM_PDR0_AUTO_CON) {
-		pclk_mux = g_clk_mux_consumer +
+	if ((pdr0 & MXC_CCM_PDR0_AUTO_CON)
+	    || (cpu_is_mx35_rev(CHIP_REV_2_0) >= 1)) {
+		pclk_mux =
+		    g_clk_mux_consumer +
 		    ((pdr0 & MXC_CCM_PDR0_CON_MUX_DIV_MASK) >>
 		     MXC_CCM_PDR0_CON_MUX_DIV_OFFSET);
 	} else {
@@ -267,7 +274,8 @@ static void sync_cpu_wb(void)
 	int i;
 	struct cpu_wp *p;
 	unsigned long reg = __raw_readl(MXC_CCM_PDR0);
-	if (reg & MXC_CCM_PDR0_AUTO_CON) {
+	if ((reg & MXC_CCM_PDR0_AUTO_CON)
+	    && (cpu_is_mx35_rev(CHIP_REV_2_0) >= 1)) {
 		reg &= MXC_CCM_PDR0_CON_MUX_DIV_MASK;
 	} else {
 		reg &= MXC_CCM_PDR0_AUTO_MUX_DIV_MASK;
@@ -505,7 +513,9 @@ static void _clk_hsp_recalc(struct clk *
 	int hsp_pdf;
 	unsigned long reg;
 	reg = __raw_readl(MXC_CCM_PDR0);
-	if (reg & MXC_CCM_PDR0_AUTO_CON) {
+
+	if ((reg & MXC_CCM_PDR0_AUTO_CON)
+	    || (cpu_is_mx35_rev(CHIP_REV_2_0) >= 1)) {
 		hsp_pdf =
 		    (reg & MXC_CCM_PDR0_HSP_PODF_MASK) >>
 		    MXC_CCM_PDR0_HSP_PODF_OFFSET;
@@ -529,72 +539,93 @@ static void _clk_mlb_recalc(struct clk *
 
 static void _clk_usb_recalc(struct clk *clk)
 {
-	unsigned long usb_pdf, usb_prepdf;
-
-	usb_pdf = PDR4(MXC_CCM_PDR4_USB_PODF_MASK,
-		       MXC_CCM_PDR4_USB_PODF_OFFSET);
-	usb_prepdf = PDR4(MXC_CCM_PDR4_USB_PRDF_MASK,
-			  MXC_CCM_PDR4_USB_PRDF_OFFSET);
-	clk->rate = clk->parent->rate / ((usb_prepdf + 1) * (usb_pdf + 1));
+	unsigned long usb_podf, usb_prdf;
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+		usb_podf = PDR4(MXC_CCM_PDR4_USB_PODF_MASK,
+				MXC_CCM_PDR4_USB_PODF_OFFSET);
+		usb_prdf = PDR4(MXC_CCM_PDR4_USB_PRDF_MASK,
+				MXC_CCM_PDR4_USB_PRDF_OFFSET);
+		clk->rate =
+		    clk->parent->rate / ((usb_prdf + 1) * (usb_podf + 1));
+	} else {
+		usb_podf = PDR4(MXC_CCM_PDR4_USB_PODF_MASK_V2,
+				MXC_CCM_PDR4_USB_PODF_OFFSET);
+		clk->rate = clk->parent->rate / (usb_podf + 1);
+	}
 }
 
 static int _clk_usb_set_rate(struct clk *clk, unsigned long rate)
 {
 	u32 reg;
 	u32 div;
-	u32 pre, post;
+	u32 podf, prdf;
 
 	div = clk->parent->rate / rate;
 
 	if ((clk->parent->rate / div) != rate)
 		return -EINVAL;
 
-	__calc_two_dividers(div, &pre, &post);
-
-	/* Set CSI clock divider */
-	reg = __raw_readl(MXC_CCM_PDR4) &
-	    ~(MXC_CCM_PDR4_USB_PODF_MASK | MXC_CCM_PDR4_USB_PRDF_MASK);
-	reg |= (post - 1) << MXC_CCM_PDR4_USB_PODF_OFFSET;
-	reg |= (pre - 1) << MXC_CCM_PDR4_USB_PRDF_OFFSET;
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+		__calc_two_dividers(div, &prdf, &podf);
+		reg = __raw_readl(MXC_CCM_PDR4) &
+		    ~(MXC_CCM_PDR4_USB_PODF_MASK | MXC_CCM_PDR4_USB_PRDF_MASK);
+		reg |= (podf - 1) << MXC_CCM_PDR4_USB_PODF_OFFSET;
+		reg |= (prdf - 1) << MXC_CCM_PDR4_USB_PRDF_OFFSET;
+	} else {
+		podf = div - 1;
+		reg =
+		    __raw_readl(MXC_CCM_PDR4) & ~MXC_CCM_PDR4_USB_PODF_MASK_V2;
+		reg |= (podf - 1) << MXC_CCM_PDR4_USB_PODF_OFFSET;
+	}
 	__raw_writel(reg, MXC_CCM_PDR4);
-
 	clk->rate = rate;
 	return 0;
 }
 
 static void _clk_csi_recalc(struct clk *clk)
 {
-	u32 reg;
-	u32 pre, post;
+	u32 podf, prdf;
 
-	reg = __raw_readl(MXC_CCM_PDR2);
-	pre = (reg & MXC_CCM_PDR2_CSI_PRDF_MASK) >>
-	    MXC_CCM_PDR2_CSI_PRDF_OFFSET;
-	post = (reg & MXC_CCM_PDR2_CSI_PODF_MASK) >>
-	    MXC_CCM_PDR2_CSI_PODF_OFFSET;
-	clk->rate = clk->parent->rate / ((pre + 1) * (post + 1));
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+		prdf = PDR2(MXC_CCM_PDR2_CSI_PRDF_MASK,
+			    MXC_CCM_PDR2_CSI_PRDF_OFFSET);
+		podf =
+		    PDR2(MXC_CCM_PDR2_CSI_PODF_MASK,
+			 MXC_CCM_PDR2_CSI_PODF_OFFSET);
+		clk->rate = clk->parent->rate / ((prdf + 1) * (podf + 1));
+	} else {
+		podf =
+		    PDR2(MXC_CCM_PDR2_CSI_PODF_MASK_V2,
+			 MXC_CCM_PDR2_CSI_PODF_OFFSET);
+		clk->rate = clk->parent->rate / (podf + 1);
+	}
 }
 
 static int _clk_csi_set_rate(struct clk *clk, unsigned long rate)
 {
 	u32 reg;
 	u32 div;
-	u32 pre, post;
+	u32 prdf, podf;
 
 	div = clk->parent->rate / rate;
 
 	if ((clk->parent->rate / div) != rate)
 		return -EINVAL;
 
-	__calc_two_dividers(div, &pre, &post);
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+		__calc_two_dividers(div, &prdf, &podf);
+		reg = __raw_readl(MXC_CCM_PDR2) &
+		    ~(MXC_CCM_PDR2_CSI_PRDF_MASK | MXC_CCM_PDR2_CSI_PODF_MASK);
+		reg |= (podf - 1) << MXC_CCM_PDR2_CSI_PODF_OFFSET;
+		reg |= (prdf - 1) << MXC_CCM_PDR2_CSI_PRDF_OFFSET;
+	} else {
+		reg =
+		    __raw_readl(MXC_CCM_PDR2) & ~MXC_CCM_PDR2_CSI_PODF_MASK_V2;
+		reg |= (div - 1) << MXC_CCM_PDR2_CSI_PODF_OFFSET;
+	}
 
 	/* Set CSI clock divider */
-	reg = __raw_readl(MXC_CCM_PDR2) &
-	    ~(MXC_CCM_PDR2_CSI_PRDF_MASK | MXC_CCM_PDR2_CSI_PODF_MASK);
-	reg |= (post - 1) << MXC_CCM_PDR2_CSI_PODF_OFFSET;
-	reg |= (pre - 1) << MXC_CCM_PDR2_CSI_PRDF_OFFSET;
 	__raw_writel(reg, MXC_CCM_PDR2);
-
 	clk->rate = rate;
 	return 0;
 }
@@ -614,29 +645,46 @@ static int _clk_csi_set_parent(struct cl
 
 static void _clk_per_recalc(struct clk *clk)
 {
-	unsigned long per_prdf = 0, per_podf;
+	u32 podf = 0, prdf = 0;
 
-	if (clk->parent == &cpu_clk) {
-		per_prdf = PDR4(MXC_CCM_PDR4_PER0_PRDF_MASK,
-				MXC_CCM_PDR4_PER0_PRDF_OFFSET);
-		per_podf = PDR4(MXC_CCM_PDR4_PER0_PODF_MASK,
-				MXC_CCM_PDR4_PER0_PODF_OFFSET);
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+		if (clk->parent == &cpu_clk) {
+			prdf = PDR4(MXC_CCM_PDR4_PER0_PRDF_MASK,
+				    MXC_CCM_PDR4_PER0_PRDF_OFFSET);
+			podf = PDR4(MXC_CCM_PDR4_PER0_PODF_MASK,
+				    MXC_CCM_PDR4_PER0_PODF_OFFSET);
+		} else {
+			podf = PDR0(MXC_CCM_PDR0_PER_PODF_MASK,
+				    MXC_CCM_PDR0_PER_PODF_OFFSET);
+		}
+		clk->rate = clk->parent->rate / ((podf + 1) * (prdf + 1));
 	} else {
-		per_podf = PDR0(MXC_CCM_PDR0_PER_PODF_MASK,
-				MXC_CCM_PDR0_PER_PODF_OFFSET);
+		if (clk->parent == &ahb_clk)
+			podf = PDR0(MXC_CCM_PDR0_PER_PODF_MASK,
+				    MXC_CCM_PDR0_PER_PODF_OFFSET);
+		else if (clk->parent == &cpu_clk) {
+			podf = PDR4(MXC_CCM_PDR4_PER0_PODF_MASK_V2,
+				    MXC_CCM_PDR4_PER0_PODF_OFFSET);
+		}
+		clk->rate = clk->parent->rate / (podf + 1);
 	}
-	per_podf = (per_podf + 1) * (per_prdf + 1);
-	clk->rate = clk->parent->rate / per_podf;
 }
 
 static void _clk_uart_per_recalc(struct clk *clk)
 {
-	unsigned long pre_pdf, pro_pdf;
-	pre_pdf = PDR4(MXC_CCM_PDR4_UART_PRDF_MASK,
-		       MXC_CCM_PDR4_UART_PRDF_OFFSET);
-	pro_pdf = PDR4(MXC_CCM_PDR4_UART_PODF_MASK,
-		       MXC_CCM_PDR4_UART_PODF_OFFSET);
-	clk->rate = clk->parent->rate / ((pre_pdf + 1) * (pro_pdf + 1));
+	unsigned long podf, prdf;
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+		prdf = PDR4(MXC_CCM_PDR4_UART_PRDF_MASK,
+			    MXC_CCM_PDR4_UART_PRDF_OFFSET);
+		podf = PDR4(MXC_CCM_PDR4_UART_PODF_MASK,
+			    MXC_CCM_PDR4_UART_PODF_OFFSET);
+		clk->rate = clk->parent->rate / ((prdf + 1) * (podf + 1));
+	} else {
+		podf =
+		    PDR4(MXC_CCM_PDR4_UART_PODF_MASK_V2,
+			 MXC_CCM_PDR4_UART_PODF_OFFSET);
+		clk->rate = clk->parent->rate / (podf + 1);
+	}
 
 }
 
@@ -644,22 +692,27 @@ static int _clk_uart_set_rate(struct clk
 {
 	u32 reg;
 	u32 div;
-	u32 pre, post;
+	u32 prdf, podf;
 
 	div = clk->parent->rate / rate;
 
 	if ((clk->parent->rate / div) != rate)
 		return -EINVAL;
 
-	__calc_two_dividers(div, &pre, &post);
-
-	/* Set CSI clock divider */
-	reg = __raw_readl(MXC_CCM_PDR4) &
-	    ~(MXC_CCM_PDR4_UART_PRDF_MASK | MXC_CCM_PDR4_UART_PODF_MASK);
-	reg |= (post - 1) << MXC_CCM_PDR4_UART_PODF_OFFSET;
-	reg |= (pre - 1) << MXC_CCM_PDR4_UART_PRDF_OFFSET;
+	/* Set UART clock divider */
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+		__calc_two_dividers(div, &prdf, &podf);
+		reg = __raw_readl(MXC_CCM_PDR4) &
+		    ~(MXC_CCM_PDR4_UART_PRDF_MASK |
+		      MXC_CCM_PDR4_UART_PODF_MASK);
+		reg |= (podf - 1) << MXC_CCM_PDR4_UART_PODF_OFFSET;
+		reg |= (prdf - 1) << MXC_CCM_PDR4_UART_PRDF_OFFSET;
+	} else {
+		reg =
+		    __raw_readl(MXC_CCM_PDR4) & ~MXC_CCM_PDR4_UART_PODF_MASK_V2;
+		reg |= (div - 1) << MXC_CCM_PDR4_UART_PODF_OFFSET;
+	}
 	__raw_writel(reg, MXC_CCM_PDR4);
-
 	clk->rate = rate;
 	return 0;
 }
@@ -812,16 +865,6 @@ static void _clk_asrc_recalc(struct clk 
 	clk->rate = clk->parent->rate / (div + 1);
 }
 
-static unsigned long _clk_asrc_round_rate(struct clk *clk, unsigned long rate)
-{
-	unsigned long div;
-	div = clk->parent->rate / rate;
-	if ((clk->parent->rate % rate))
-		div++;
-
-	return clk->parent->rate / div;
-}
-
 static int _clk_asrc_set_rate(struct clk *clk, unsigned long rate)
 {
 	int div;
@@ -839,66 +882,98 @@ static int _clk_asrc_set_rate(struct clk
 
 static void _clk_sdhc_recalc(struct clk *clk)
 {
-	unsigned long prdf, podf;
+	u32 podf = 0, prdf = 0;
+
 	switch (clk->id) {
 	case 0:
-		prdf = PDR3(MXC_CCM_PDR3_ESDHC1_PRDF_MASK,
-			    MXC_CCM_PDR3_ESDHC1_PRDF_OFFSET);
-		podf = PDR3(MXC_CCM_PDR3_ESDHC1_PODF_MASK,
-			    MXC_CCM_PDR3_ESDHC1_PODF_OFFSET);
+		if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+			prdf = PDR3(MXC_CCM_PDR3_ESDHC1_PRDF_MASK,
+				    MXC_CCM_PDR3_ESDHC1_PRDF_OFFSET);
+			podf = PDR3(MXC_CCM_PDR3_ESDHC1_PODF_MASK,
+				    MXC_CCM_PDR3_ESDHC1_PODF_OFFSET);
+		} else
+			podf = PDR3(MXC_CCM_PDR3_ESDHC1_PODF_MASK_V2,
+				    MXC_CCM_PDR3_ESDHC1_PODF_OFFSET);
 		break;
 	case 1:
-		prdf = PDR3(MXC_CCM_PDR3_ESDHC2_PRDF_MASK,
-			    MXC_CCM_PDR3_ESDHC2_PRDF_OFFSET);
-		podf = PDR3(MXC_CCM_PDR3_ESDHC2_PODF_MASK,
-			    MXC_CCM_PDR3_ESDHC2_PODF_OFFSET);
+		if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+			prdf = PDR3(MXC_CCM_PDR3_ESDHC2_PRDF_MASK,
+				    MXC_CCM_PDR3_ESDHC2_PRDF_OFFSET);
+			podf = PDR3(MXC_CCM_PDR3_ESDHC2_PODF_MASK,
+				    MXC_CCM_PDR3_ESDHC2_PODF_OFFSET);
+		} else
+			podf = PDR3(MXC_CCM_PDR3_ESDHC2_PODF_MASK_V2,
+				    MXC_CCM_PDR3_ESDHC2_PODF_OFFSET);
 		break;
 	case 2:
-		prdf = PDR3(MXC_CCM_PDR3_ESDHC3_PRDF_MASK,
-			    MXC_CCM_PDR3_ESDHC3_PRDF_OFFSET);
-		podf = PDR3(MXC_CCM_PDR3_ESDHC3_PODF_MASK,
-			    MXC_CCM_PDR3_ESDHC3_PODF_OFFSET);
+		if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+			prdf = PDR3(MXC_CCM_PDR3_ESDHC3_PRDF_MASK,
+				    MXC_CCM_PDR3_ESDHC3_PRDF_OFFSET);
+			podf = PDR3(MXC_CCM_PDR3_ESDHC3_PODF_MASK,
+				    MXC_CCM_PDR3_ESDHC3_PODF_OFFSET);
+		} else
+			podf = PDR3(MXC_CCM_PDR3_ESDHC3_PODF_MASK_V2,
+				    MXC_CCM_PDR3_ESDHC3_PODF_OFFSET);
 		break;
 	default:
 		return;
 	}
-	clk->rate = clk->parent->rate / ((prdf + 1) * (podf + 1));
+	clk->rate = clk->parent->rate / ((podf + 1) * (prdf + 1));
 }
 
 static int _clk_sdhc_set_rate(struct clk *clk, unsigned long rate)
 {
 	u32 reg;
 	u32 div;
-	u32 pre, post;
+	u32 prdf, podf;
 
 	div = clk->parent->rate / rate;
 
 	if ((clk->parent->rate / div) != rate)
 		return -EINVAL;
 
-	__calc_pre_post_dividers(div, &pre, &post);
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1)
+		__calc_pre_post_dividers(div, &prdf, &podf);
 
 	switch (clk->id) {
 	case 0:
-		reg = __raw_readl(MXC_CCM_PDR3) &
-		    ~(MXC_CCM_PDR3_ESDHC1_PRDF_MASK |
-		      MXC_CCM_PDR3_ESDHC1_PODF_MASK);
-		reg |= (post - 1) << MXC_CCM_PDR3_ESDHC1_PODF_OFFSET;
-		reg |= (pre - 1) << MXC_CCM_PDR3_ESDHC1_PRDF_OFFSET;
+		if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+			reg = __raw_readl(MXC_CCM_PDR3) &
+			    ~(MXC_CCM_PDR3_ESDHC1_PRDF_MASK |
+			      MXC_CCM_PDR3_ESDHC1_PODF_MASK);
+			reg |= (podf - 1) << MXC_CCM_PDR3_ESDHC1_PODF_OFFSET;
+			reg |= (prdf - 1) << MXC_CCM_PDR3_ESDHC1_PRDF_OFFSET;
+		} else {
+			reg = __raw_readl(MXC_CCM_PDR3) &
+			    ~MXC_CCM_PDR3_ESDHC1_PODF_MASK_V2;
+			reg |= (div - 1) << MXC_CCM_PDR3_ESDHC1_PODF_OFFSET;
+		}
 		break;
 	case 1:
-		reg = __raw_readl(MXC_CCM_PDR3) &
-		    ~(MXC_CCM_PDR3_ESDHC2_PRDF_MASK |
-		      MXC_CCM_PDR3_ESDHC2_PODF_MASK);
-		reg |= (post - 1) << MXC_CCM_PDR3_ESDHC2_PODF_OFFSET;
-		reg |= (pre - 1) << MXC_CCM_PDR3_ESDHC2_PRDF_OFFSET;
+		if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+			reg = __raw_readl(MXC_CCM_PDR3) &
+			    ~(MXC_CCM_PDR3_ESDHC2_PRDF_MASK |
+			      MXC_CCM_PDR3_ESDHC2_PODF_MASK);
+			reg |= (podf - 1) << MXC_CCM_PDR3_ESDHC2_PODF_OFFSET;
+			reg |= (prdf - 1) << MXC_CCM_PDR3_ESDHC2_PRDF_OFFSET;
+		} else {
+			reg = __raw_readl(MXC_CCM_PDR3) &
+			    ~MXC_CCM_PDR3_ESDHC2_PODF_MASK_V2;
+			reg |= (div - 1) << MXC_CCM_PDR3_ESDHC2_PODF_OFFSET;
+		}
 		break;
 	case 2:
-		reg = __raw_readl(MXC_CCM_PDR3) &
-		    ~(MXC_CCM_PDR3_ESDHC3_PRDF_MASK |
-		      MXC_CCM_PDR3_ESDHC3_PODF_MASK);
-		reg |= (post - 1) << MXC_CCM_PDR3_ESDHC3_PODF_OFFSET;
-		reg |= (pre - 1) << MXC_CCM_PDR3_ESDHC3_PRDF_OFFSET;
+		if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+			reg = __raw_readl(MXC_CCM_PDR3) &
+			    ~(MXC_CCM_PDR3_ESDHC3_PRDF_MASK |
+			      MXC_CCM_PDR3_ESDHC3_PODF_MASK);
+			reg |= (podf - 1) << MXC_CCM_PDR3_ESDHC3_PODF_OFFSET;
+			reg |= (prdf - 1) << MXC_CCM_PDR3_ESDHC3_PRDF_OFFSET;
+		} else {
+			reg = __raw_readl(MXC_CCM_PDR3) &
+			    ~MXC_CCM_PDR3_ESDHC3_PODF_MASK_V2;
+			reg |= (div - 1) << MXC_CCM_PDR3_ESDHC3_PODF_OFFSET;
+		}
 		break;
 	default:
 		return -EINVAL;
@@ -994,7 +1069,7 @@ static struct clk asrc_clk[] = {
 	 .name = "asrc_audio_clk",
 	 .parent = &ckie_clk,
 	 .recalc = _clk_asrc_recalc,
-	 .round_rate = _clk_asrc_round_rate,
+	 .round_rate = _clk_round_rate,
 	 .set_rate = _clk_asrc_set_rate,
 	 .enable = _clk_asrc_enable,
 	 .disable = _clk_asrc_disable,},
@@ -1391,7 +1466,7 @@ static struct clk wdog_clk = {
 
 static struct clk csi_clk = {
 	.name = "csi_clk",
-	.parent = &cpu_clk,
+	.parent = &peri_pll_clk,
 	.recalc = _clk_csi_recalc,
 	.round_rate = _clk_round_rate,
 	.set_rate = _clk_csi_set_rate,
@@ -1419,47 +1494,53 @@ static struct clk nfc_clk = {
 
 static unsigned long _clk_cko1_round_rate(struct clk *clk, unsigned long rate)
 {
-	u32 div;
+	u32 div = 0, div1 = 1;
 
 	div = clk->parent->rate / rate;
 	if (clk->parent->rate % rate)
 		div++;
 
-	if (div > 64)
-		div = (div + 1) & (~1);
+	if (div > 64) {
+		div = (div + 1) >> 1;
+		div1++;
+	}
 
 	if (div > 128)
-		return -EINVAL;
-
-	return clk->parent->rate / div;
+		div = 64;
+	return clk->parent->rate / (div * div1);
 }
 
 static int _clk_cko1_set_rate(struct clk *clk, unsigned long rate)
 {
 	u32 reg;
-	u32 div, div2;
-	u32 pre, post;
+	u32 div, div1 = 0;
+	u32 prdf, podf;
 
 	div = clk->parent->rate / rate;
-
 	if ((clk->parent->rate / div) != rate)
 		return -EINVAL;
 	if (div > 64) {
-		if (div % 1)
-			return -EINVAL;
-		div2 = MXC_CCM_COSR_CLKOUTDIV_1;
+		div1 = MXC_CCM_COSR_CLKOUTDIV_1;
 		div >>= 1;
 	} else {
-		div2 = 0;
+		div1 = 0;
 	}
 
-	__calc_two_dividers(div, &pre, &post);
-
-	reg = __raw_readl(MXC_CCM_COSR) &
-	    ~(MXC_CCM_COSR_CLKOUT_PREDIV_MASK |
-	      MXC_CCM_COSR_CLKOUT_PRODIV_MASK | MXC_CCM_COSR_CLKOUTDIV_1);
-	reg |= ((pre - 1) << MXC_CCM_COSR_CLKOUT_PREDIV_OFFSET) |
-	    ((post - 1) << MXC_CCM_COSR_CLKOUT_PRODIV_OFFSET) | div2;
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+		__calc_two_dividers(div, &prdf, &podf);
+		reg = __raw_readl(MXC_CCM_COSR) &
+		    ~(MXC_CCM_COSR_CLKOUT_PREDIV_MASK |
+		      MXC_CCM_COSR_CLKOUT_PRODIV_MASK |
+		      MXC_CCM_COSR_CLKOUTDIV_1);
+		reg |= ((prdf - 1) << MXC_CCM_COSR_CLKOUT_PREDIV_OFFSET)
+		    | ((podf - 1) << MXC_CCM_COSR_CLKOUT_PRODIV_OFFSET)
+		    | div1;
+	} else {
+		reg = __raw_readl(MXC_CCM_COSR) &
+		    ~(MXC_CCM_COSR_CLKOUT_PRODIV_MASK_V2 |
+		      MXC_CCM_COSR_CLKOUTDIV_1);
+		reg |= ((div - 1) << MXC_CCM_COSR_CLKOUT_PRODIV_OFFSET) | div1;
+	}
 	__raw_writel(reg, MXC_CCM_COSR);
 
 	return 0;
@@ -1467,17 +1548,21 @@ static int _clk_cko1_set_rate(struct clk
 
 static void _clk_cko1_recalc(struct clk *clk)
 {
-	u32 pre, post, factor;
+	u32 prdf = 1;
+	u32 podf, div1;
 	u32 reg = __raw_readl(MXC_CCM_COSR);
 
-	pre = (reg & MXC_CCM_COSR_CLKOUT_PREDIV_MASK) >>
-	    MXC_CCM_COSR_CLKOUT_PREDIV_OFFSET;
-
-	post = (reg & MXC_CCM_COSR_CLKOUT_PRODIV_MASK) >>
-	    MXC_CCM_COSR_CLKOUT_PRODIV_OFFSET;
+	div1 = 1 << ((reg & MXC_CCM_COSR_CLKOUTDIV_1) != 0);
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+		prdf = (reg & MXC_CCM_COSR_CLKOUT_PREDIV_MASK) >>
+		    MXC_CCM_COSR_CLKOUT_PREDIV_OFFSET;
+		podf = (reg & MXC_CCM_COSR_CLKOUT_PRODIV_MASK) >>
+		    MXC_CCM_COSR_CLKOUT_PRODIV_OFFSET;
+	} else
+		podf = (reg & MXC_CCM_COSR_CLKOUT_PRODIV_MASK_V2) >>
+		    MXC_CCM_COSR_CLKOUT_PRODIV_OFFSET;
 
-	factor = 1 << ((reg & MXC_CCM_COSR_CLKOUTDIV_1) != 0);
-	clk->rate = clk->parent->rate / (factor * (pre + 1) * (post + 1));
+	clk->rate = clk->parent->rate / (div1 * (podf + 1) * (prdf + 1));
 }
 
 static int _clk_cko1_set_parent(struct clk *clk, struct clk *parent)
@@ -1485,11 +1570,12 @@ static int _clk_cko1_set_parent(struct c
 	u32 reg;
 	reg = __raw_readl(MXC_CCM_COSR) & ~MXC_CCM_COSR_CLKOSEL_MASK;
 
-	if (parent == &ckil_clk)
+	if (parent == &ckil_clk) {
+		reg &= ~MXC_CCM_COSR_CKIL_CKIH_MASK;
 		reg |= 0 << MXC_CCM_COSR_CLKOSEL_OFFSET;
-	else if (parent == &ckih_clk)
+	} else if (parent == &ckih_clk) {
 		reg |= 1 << MXC_CCM_COSR_CLKOSEL_OFFSET;
-	else if (parent == &ckie_clk)
+	} else if (parent == &ckie_clk)
 		reg |= 2 << MXC_CCM_COSR_CLKOSEL_OFFSET;
 	else if (parent == &peri_pll_clk)
 		reg |= 6 << MXC_CCM_COSR_CLKOSEL_OFFSET;
@@ -1515,6 +1601,10 @@ static int _clk_cko1_set_parent(struct c
 		reg |= 0x13 << MXC_CCM_COSR_CLKOSEL_OFFSET;
 	else if (parent == &asrc_clk[1])
 		reg |= 0x14 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if ((parent == &nfc_clk) && (cpu_is_mx35_rev(CHIP_REV_2_0) >= 1))
+		reg |= 0x17 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if ((parent == &ipu_clk) && (cpu_is_mx35_rev(CHIP_REV_2_0) >= 1))
+		reg |= 0x18 << MXC_CCM_COSR_CLKOSEL_OFFSET;
 	else
 		return -EINVAL;
 
@@ -1663,6 +1753,12 @@ static void mxc_clockout_scan(void)
 	case 0x14:
 		cko1_clk.parent = &asrc_clk[1];
 		break;
+	case 0x17:
+		cko1_clk.parent = &nfc_clk;
+		break;
+	case 0x18:
+		cko1_clk.parent = &ipu_clk;
+		break;
 	}
 }
 
@@ -1670,7 +1766,8 @@ static void mxc_update_clocks(void)
 {
 	unsigned long reg;
 	reg = __raw_readl(MXC_CCM_PDR0);
-	if (!(reg & MXC_CCM_PDR0_AUTO_CON))
+	if ((!(reg & MXC_CCM_PDR0_AUTO_CON))
+	    && (cpu_is_mx35_rev(CHIP_REV_2_0) < 1))
 		ipu_clk.parent = &ahb_clk;
 
 	if (reg & MXC_CCM_PDR0_PER_SEL)
Index: linux-2.6.24/arch/arm/mach-mx35/cpu.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx35/cpu.c	2009-01-26 18:52:00.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx35/cpu.c	2009-01-26 19:07:59.000000000 +0100
@@ -31,10 +31,15 @@
  */
 void __init mxc_cpu_init(void)
 {
+
 	/* Setup Peripheral Port Remap register for AVIC */
 	asm("ldr r0, =0xC0000015				\n\
 	 mcr p15, 0, r0, c15, c2, 4");
 	/*TODO:Add code to check chip version */
+
+	if (!system_rev)
+		mxc_set_system_rev(0x35, CHIP_REV_1_0);
+
 }
 
 /*!
Index: linux-2.6.24/arch/arm/mach-mx35/crm_regs.h
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx35/crm_regs.h	2009-01-26 18:52:00.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx35/crm_regs.h	2009-01-26 19:07:59.000000000 +0100
@@ -100,6 +100,9 @@
 #define MXC_CCM_PDR2_SSI1_PODF_OFFSET           0
 #define MXC_CCM_PDR2_SSI1_PODF_MASK             (0x3F)
 
+/* Extra definitions for Chip Version 2*/
+#define MXC_CCM_PDR2_CSI_PODF_MASK_V2              (0x3F << 16)
+
 #define MXC_CCM_PDR3_SPDIF_PRDF_OFFSET          29
 #define MXC_CCM_PDR3_SPDIF_PRDF_MASK            (0x7 << 29)
 #define MXC_CCM_PDR3_SPDIF_PODF_OFFSET          23
@@ -120,6 +123,11 @@
 #define MXC_CCM_PDR3_ESDHC1_PODF_OFFSET         0
 #define MXC_CCM_PDR3_ESDHC1_PODF_MASK           (0x7)
 
+/* Extra definitions for Chip Version 2 */
+#define MXC_CCM_PDR3_ESDHC3_PODF_MASK_V2	(0x3F << 16)
+#define MXC_CCM_PDR3_ESDHC2_PODF_MASK_V2        (0x3F << 8)
+#define MXC_CCM_PDR3_ESDHC1_PODF_MASK_V2        0x3F
+
 #define MXC_CCM_PDR4_NFC_PODF_OFFSET           	28
 #define MXC_CCM_PDR4_NFC_PODF_MASK            	(0xF << 28)
 #define MXC_CCM_PDR4_USB_PRDF_OFFSET          	25
@@ -136,6 +144,11 @@
 #define MXC_CCM_PDR4_UART_PODF_MASK            	(0x7 << 10)
 #define MXC_CCM_PDR4_USB_M_U			(1 << 9)
 
+/* Extra definitions for Chip Version 2 */
+#define MXC_CCM_PDR4_USB_PODF_MASK_V2		(0x3F << 22)
+#define MXC_CCM_PDR4_PER0_PODF_MASK_V2		(0x3F << 16)
+#define MXC_CCM_PDR4_UART_PODF_MASK_V2          (0x3F << 10)
+
 /* Bit definitions for RCSR */
 #define MXC_CCM_RCSR_BUS_WIDTH			(1 << 29)
 #define MXC_CCM_RCSR_BUS_16BIT			(1 << 29)
@@ -170,6 +183,13 @@
 #define MXC_CCM_ACMR_SSI2_CLK_SEL_OFFSET	0
 #define MXC_CCM_ACMR_SSI2_CLK_SEL_MASK		(0xF << 0)
 
+/* Extra definitions for Version 2 */
+#define MXC_CCM_ACMR_CKILH_PODF0_OFFSET		16
+#define MXC_CCM_ACMR_CKILH_PODF1_OFFSET		19
+#define MXC_CCM_ACMR_CKILH_PODF2_OFFSET		22
+#define MXC_CCM_ACMR_CKILH_PODF3_OFFSET         25
+#define MXC_CCM_ACMR_CKILH_PODF_MASK		0x7
+
 /* Bit definitions for Clock gating Register*/
 #define MXC_CCM_CGR0_ASRC_OFFSET             	0
 #define MXC_CCM_CGR0_ASRC_MASK               	(0x3 << 0)
@@ -372,10 +392,10 @@
 #define MXC_CCM_COSR_CLKOSEL_OFFSET             0
 #define MXC_CCM_COSR_CLKOEN                     (1 << 5)
 #define MXC_CCM_COSR_CLKOUTDIV_1             	(1 << 6)
-#define MXC_CCM_COSR_CLKOUT_PREDIV_MASK         (0x7 << 10)
-#define MXC_CCM_COSR_CLKOUT_PREDIV_OFFSET       10
-#define MXC_CCM_COSR_CLKOUT_PRODIV_MASK         (0x7 << 13)
-#define MXC_CCM_COSR_CLKOUT_PRODIV_OFFSET       13
+#define MXC_CCM_COSR_CLKOUT_PREDIV_MASK         (0x7 << 13)
+#define MXC_CCM_COSR_CLKOUT_PREDIV_OFFSET       13
+#define MXC_CCM_COSR_CLKOUT_PRODIV_MASK         (0x7 << 10)
+#define MXC_CCM_COSR_CLKOUT_PRODIV_OFFSET       10
 #define MXC_CCM_COSR_SSI1_RX_SRC_SEL_MASK       (0x3 << 16)
 #define MXC_CCM_COSR_SSI1_RX_SRC_SEL_OFFSET     16
 #define MXC_CCM_COSR_SSI1_TX_SRC_SEL_MASK       (0x3 << 18)
@@ -388,6 +408,11 @@
 #define MXC_CCM_COSR_ASRC_AUDIO_PODF_MASK       (0x3F << 26)
 #define MXC_CCM_COSR_ASRC_AUDIO_PODF_OFFSET     26
 
+/* extra definitions for Version 2 */
+#define MXC_CCM_COSR_CKIL_CKIH_MASK		(1 << 7)
+#define MXC_CCM_COSR_CKIL_CKIH_OFFSET		7
+#define MXC_CCM_COSR_CLKOUT_PRODIV_MASK_V2	(0x3F << 10)
+
 /*
  * PMCR0 register offsets
  */
Index: linux-2.6.24/arch/arm/mach-mx35/devices.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx35/devices.c	2009-01-26 18:52:00.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx35/devices.c	2009-01-26 19:07:59.000000000 +0100
@@ -24,54 +24,122 @@
 
 #include "iomux.h"
 #include "sdma_script_code.h"
+#include "sdma_script_code_v2.h"
 #include "board-mx35_3stack.h"
+#include "board-mx35_fab4.h"
 
 extern void gpio_spdif_active(void);
+extern void gpio_spdif_inactive(void);
 
 void mxc_sdma_get_script_info(sdma_script_start_addrs * sdma_script_addr)
 {
-	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
-	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
-	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
-	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
-	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
-
-	sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
-	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
-	sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
-	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
-
-	sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_per_ADDR;
-	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
-	sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR;
-	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
-
-	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = uartsh_2_per_ADDR;
-	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR;
-	sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR;
-	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
-
-	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
-	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
-
-	sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR;
-	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
-	sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR;
-	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
-
-	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
-	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
-
-	sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = spdif_2_mcu_ADDR;
-	sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = mcu_2_spdif_ADDR;
-
-	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
-	sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr = ext_mem__ipu_ram_ADDR;
-	sdma_script_addr->mxc_sdma_descrambler_addr = descrambler_ADDR;
-
-	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code;
-	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
-	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR;
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+		sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
+		sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+		sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+		sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+		sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
+		sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
+
+		sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_per_ADDR;
+		sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
+
+		//sdma_script_addr->mxc_sdma_per_2_per_addr = p_2_p_ADDR;
+
+		sdma_script_addr->mxc_sdma_uartsh_2_per_addr =
+		    uartsh_2_per_ADDR;
+		sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr =
+		    uartsh_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
+
+		sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
+
+		sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR;
+		sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR;
+		sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
+
+		sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+
+		sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = spdif_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = mcu_2_spdif_ADDR;
+
+		//sdma_script_addr->mxc_sdma_asrc_2_mcu_addr = asrc__mcu_ADDR;
+
+		sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+		sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr =
+		    ext_mem__ipu_ram_ADDR;
+		sdma_script_addr->mxc_sdma_descrambler_addr = -1;
+
+		sdma_script_addr->mxc_sdma_start_addr =
+		    (unsigned short *)sdma_code;
+		sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
+		sdma_script_addr->mxc_sdma_ram_code_start_addr =
+		    RAM_CODE_START_ADDR;
+	} else {
+		sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR_V2;
+		sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+		sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+		sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+		sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
+		sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
+
+		sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_per_ADDR_V2;
+		sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR_V2;
+		sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR_V2;
+		sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR_V2;
+
+		//sdma_script_addr->mxc_sdma_per_2_per_addr = p_2_p_ADDR_V2;
+
+		sdma_script_addr->mxc_sdma_uartsh_2_per_addr =
+		    uartsh_2_per_ADDR_V2;
+		sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr =
+		    uartsh_2_mcu_ADDR_V2;
+		sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR_V2;
+		sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR_V2;
+
+		sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR_V2;
+		sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR_V2;
+
+		sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR_V2;
+		sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR_V2;
+		sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR_V2;
+		sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR_V2;
+
+		sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+
+		sdma_script_addr->mxc_sdma_spdif_2_mcu_addr =
+		    spdif_2_mcu_ADDR_V2;
+		sdma_script_addr->mxc_sdma_mcu_2_spdif_addr =
+		    mcu_2_spdif_ADDR_V2;
+
+		//sdma_script_addr->mxc_sdma_asrc_2_mcu_addr = asrc__mcu_ADDR_V2;
+
+		sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+		sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr =
+		    ext_mem__ipu_ram_ADDR_V2;
+		sdma_script_addr->mxc_sdma_descrambler_addr = -1;
+
+		sdma_script_addr->mxc_sdma_start_addr =
+		    (unsigned short *)sdma_code_v2;
+		sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
+		sdma_script_addr->mxc_sdma_ram_code_start_addr =
+		    RAM_CODE_START_ADDR_V2;
+	}
 }
 
 static void mxc_nop_release(struct device *dev)
@@ -328,6 +396,7 @@ static struct mxc_i2c_platform_data mxci
 };
 #endif
 
+#ifdef CONFIG_I2C_MXC_SELECT2
 /*!
  * Resource definition for the I2C2
  */
@@ -348,6 +417,7 @@ static struct resource mxci2c2_resources
 static struct mxc_i2c_platform_data mxci2c2_data = {
 	.i2c_clk = 100000,
 };
+#endif
 
 #ifdef CONFIG_I2C_MXC_SELECT3
 /*!
@@ -385,6 +455,7 @@ static struct platform_device mxci2c_dev
 	 .num_resources = ARRAY_SIZE(mxci2c1_resources),
 	 .resource = mxci2c1_resources,},
 #endif
+#ifdef CONFIG_I2C_MXC_SELECT2
 	{
 	 .name = "mxc_i2c_slave",
 	 .id = 1,
@@ -394,6 +465,7 @@ static struct platform_device mxci2c_dev
 		 },
 	 .num_resources = ARRAY_SIZE(mxci2c2_resources),
 	 .resource = mxci2c2_resources,},
+#endif
 #ifdef CONFIG_I2C_MXC_SELECT3
 	{
 	 .name = "mxc_i2c",
@@ -457,6 +529,7 @@ static inline void mxc_init_dma(void)
 	(void)platform_device_register(&mxc_dma_device);
 }
 
+#ifdef CONFIG_SND_MXC_SPDIF
 static struct resource spdif_resources[] = {
 	{
 	 .start = SPDIF_BASE_ADDR,
@@ -465,6 +538,44 @@ static struct resource spdif_resources[]
 	 },
 };
 
+#ifdef CONFIG_MACH_FAB4
+static void fab4_spdif_set_clk(int sample_rate)
+{
+	switch (sample_rate) {
+	case 96000:
+	case 48000:
+	case 32000:
+		mxc_set_gpio_dataout(MX35_PIN_TX4_RX1, 1);
+		break;
+
+	default:
+		mxc_set_gpio_dataout(MX35_PIN_TX4_RX1, 0);
+		break;
+	}
+}
+
+static void fab4_spdif_enable(int enable)
+{
+	if (enable) {
+		gpio_spdif_active();
+	}
+	else {
+		gpio_spdif_inactive();
+	}
+}
+
+static struct mxc_spdif_platform_data mxc_spdif_data = {
+	.spdif_tx = 1,
+	.spdif_rx = 0,          /* disable spdif rx */
+	.spdif_clk_44100 = 0,	/* audio osc source */
+	.spdif_clk_48000 = 0,	/* audio osc source */
+	.spdif_clkid = 0,
+	.spdif_clk = NULL,	/* spdif bus clk */
+	.spdif_core_clk = NULL,	/* spdif core bus clk */
+	.spdif_set_clk = &fab4_spdif_set_clk , /* OSC_SEL1 */
+	.spdif_enable = &fab4_spdif_enable,
+};
+#else
 static struct mxc_spdif_platform_data mxc_spdif_data = {
 	.spdif_tx = 1,
 	.spdif_rx = 1,
@@ -473,6 +584,7 @@ static struct mxc_spdif_platform_data mx
 	.spdif_clkid = 0,
 	.spdif_clk = NULL,	/* spdif bus clk */
 };
+#endif
 
 static struct platform_device mxc_alsa_spdif_device = {
 	.name = "mxc_alsa_spdif",
@@ -491,10 +603,15 @@ static inline void mxc_init_spdif(void)
 	clk_put(mxc_spdif_data.spdif_clk);
 	mxc_spdif_data.spdif_core_clk = clk_get(NULL, "spdif_clk");
 	clk_put(mxc_spdif_data.spdif_core_clk);
-	gpio_spdif_active();
 	platform_device_register(&mxc_alsa_spdif_device);
 }
+#else
+static inline void mxc_init_spdif(void)
+{
+}
+#endif
 
+#ifdef CONFIG_SND_SOC_IMX_3STACK_AK4647
 static struct mxc_audio_platform_data mxc_audio_data;
 
 static struct platform_device mxc_alsa_device = {
@@ -512,10 +629,20 @@ static void mxc_init_audio(void)
 	mxc_audio_data.ssi_num = 1;
 	mxc_audio_data.src_port = 1;
 	mxc_audio_data.ext_port = 4;
+#if CONFIG_MACH_FAB4
+	mxc_audio_data.intr_id_hp = 0; // FIXME if required
+#else
 	mxc_audio_data.intr_id_hp = MXC_PSEUDO_IRQ_HEADPHONE;
+#endif
 	platform_device_register(&mxc_alsa_device);
 }
+#else
+static void mxc_init_audio(void)
+{
+}
+#endif
 
+#ifdef CONFIG_SND_SOC_IMX_3STACK_WM8580
 static struct platform_device mxc_alsa_surround_device = {
 	.name = "imx-3stack-wm8580",
 	.id = 0,
@@ -528,7 +655,13 @@ static void mxc_init_surround_audio(void
 {
 	platform_device_register(&mxc_alsa_surround_device);
 }
+#else
+static void mxc_init_surround_audio(void)
+{
+}
+#endif
 
+#ifdef CONFIG_MXC_ASRC
 static struct resource asrc_resources[] = {
 	{
 	 .start = ASRC_BASE_ADDR,
@@ -557,8 +690,15 @@ static inline void mxc_init_asrc(void)
 	mxc_asrc_data.asrc_audio_clk = clk_get(NULL, "asrc_audio_clk");
 	clk_set_rate(mxc_asrc_data.asrc_audio_clk, 768000);
 	clk_put(mxc_asrc_data.asrc_audio_clk);
+	gpio_spdif_inactive();
 	platform_device_register(&mxc_asrc_device);
 }
+#else
+static inline void mxc_init_asrc(void)
+{
+}
+#endif
+
 
 #if defined(CONFIG_CAN_FLEXCAN) || defined(CONFIG_CAN_FLEXCAN_MODULE)
 
Index: linux-2.6.24/arch/arm/mach-mx35/Kconfig
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx35/Kconfig	2009-01-26 18:52:00.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx35/Kconfig	2009-01-26 19:08:05.000000000 +0100
@@ -16,6 +16,14 @@ config MACH_MX35EVB
 	  Include support for MX35EVB platform. This includes specific
 	  configurations for the board and its peripherals.
 
+config MACH_FAB4
+	bool "Support Logitech Fab4 platforms"
+	default n
+	select MXC_PSEUDO_IRQS if MXC_PMIC
+	help
+	  Include support for Logitech Fab4 platform. This includes specific
+	  configurations for the board and its peripherals.
+
 config MX35_DOZE_DURING_IDLE
 	bool "Enter Doze mode during idle"
 	help
Index: linux-2.6.24/arch/arm/mach-mx35/Makefile
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx35/Makefile	2009-01-26 18:52:00.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx35/Makefile	2009-01-26 19:07:59.000000000 +0100
@@ -8,6 +8,7 @@ obj-y		:= system.o iomux.o cpu.o mm.o cl
 obj-$(CONFIG_MXC_SDMA_API) 	+= dma.o
 obj-$(CONFIG_MACH_MX35_3DS)	+= mx35_3stack.o mx35_3stack_gpio.o mx35_3stack_cpld.o dvfs.o
 obj-$(CONFIG_MACH_MX35EVB)	+= mx35evb.o mx35evb_cpld.o mx35evb_gpio.o
+obj-$(CONFIG_MACH_FAB4)		+= mx35_fab4.o mx35_fab4_gpio.o
 
 obj-$(CONFIG_MXC_PSEUDO_IRQS)	+= mx35_3stack_irq.o
 obj-$(CONFIG_PM) 		+= pm.o
Index: linux-2.6.24/arch/arm/mach-mx35/mx35_3stack.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx35/mx35_3stack.c	2009-01-26 18:52:00.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx35/mx35_3stack.c	2009-01-26 19:07:59.000000000 +0100
@@ -299,6 +299,45 @@ static inline void mxc_init_mlb(void)
 }
 #endif
 
+#if defined(CONFIG_SDIO_UNIFI_FS) || defined(CONFIG_SDIO_UNIFI_FS_MODULE)
+static void mxc_unifi_hardreset(void)
+{
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_RESET_1, 1, 0);
+	msleep(100);
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_RESET_1, 1, 1);
+}
+
+static void mxc_unifi_enable(int en)
+{
+	if (en) {
+		pmic_gpio_set_bit_val(MCU_GPIO_REG_GPIO_CONTROL_1, 5, 1);
+		msleep(10);
+	} else
+		pmic_gpio_set_bit_val(MCU_GPIO_REG_GPIO_CONTROL_1, 5, 0);
+}
+
+static struct mxc_unifi_platform_data unifi_data = {
+	.hardreset = mxc_unifi_hardreset,
+	.enable = mxc_unifi_enable,
+	.reg_1v5_ana_bb = "SW4",
+	.reg_vdd_vpa = "SW1",
+	.reg_1v5_dd = "SW4",
+	.host_id = 1,
+};
+
+struct mxc_unifi_platform_data *get_unifi_plat_data(void)
+{
+	return &unifi_data;
+}
+#else
+struct mxc_unifi_platform_data *get_unifi_plat_data(void)
+{
+	return NULL;
+}
+#endif
+
+EXPORT_SYMBOL(get_unifi_plat_data);
+
 static struct mxc_tsc_platform_data tsc2007_data = {
 	.vdd_reg = "SW1",
 	.penup_threshold = 30,
@@ -435,7 +474,7 @@ EXPORT_SYMBOL(expio_intr_fec);
 #endif
 
 #if defined(CONFIG_MMC_IMX_ESDHCI) || defined(CONFIG_MMC_IMX_ESDHCI_MODULE)
-static struct mxc_mmc_platform_data mmc_data = {
+static struct mxc_mmc_platform_data mmc0_data = {
 	.ocr_mask = MMC_VDD_32_33,
 	.min_clk = 400000,
 	.max_clk = 52000000,
@@ -472,15 +511,60 @@ static struct platform_device mxcsdhc1_d
 	.id = 0,
 	.dev = {
 		.release = mxc_nop_release,
-		.platform_data = &mmc_data,
+		.platform_data = &mmc0_data,
 		},
 	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
 	.resource = mxcsdhc1_resources,
 };
 
+#if defined(CONFIG_SDIO_UNIFI_FS) || defined(CONFIG_SDIO_UNIFI_FS_MODULE)
+static struct mxc_mmc_platform_data mmc1_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30 |
+		    MMC_VDD_31_32,
+	.min_clk = 150000,
+	.max_clk = 25000000,
+	.card_inserted_state = 1,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "sdhc_clk",
+};
+
+static struct resource mxcsdhc2_resources[] = {
+	[0] = {
+	       .start = MMC_SDHC2_BASE_ADDR,
+	       .end = MMC_SDHC2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_MMC_SDHC2,
+	       .end = MXC_INT_MMC_SDHC2,
+	       .flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxcsdhc2_device = {
+	.name = "mxsdhci",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
+	.resource = mxcsdhc2_resources,
+};
+#endif
+
 static inline void mxc_init_mmc(void)
 {
 	(void)platform_device_register(&mxcsdhc1_device);
+#if defined(CONFIG_SDIO_UNIFI_FS) || defined(CONFIG_SDIO_UNIFI_FS_MODULE)
+	(void)platform_device_register(&mxcsdhc2_device);
+#endif
 }
 #else
 static inline void mxc_init_mmc(void)
@@ -852,12 +936,17 @@ static struct cpu_wp cpu_wp_con[] = {
 
 struct cpu_wp *get_cpu_wp(int *wp)
 {
-	if (__raw_readl(MXC_CCM_PDR0) & MXC_CCM_PDR0_AUTO_CON) {
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) >= 1) {
 		*wp = 9;
 		return cpu_wp_con;
 	} else {
-		*wp = 6;
-		return cpu_wp_auto;
+		if (__raw_readl(MXC_CCM_PDR0) & MXC_CCM_PDR0_AUTO_CON) {
+			*wp = 9;
+			return cpu_wp_con;
+		} else {
+			*wp = 6;
+			return cpu_wp_auto;
+		}
 	}
 }
 
Index: linux-2.6.24/arch/arm/mach-mx35/mx35_3stack_gpio.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx35/mx35_3stack_gpio.c	2009-01-26 18:52:00.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx35/mx35_3stack_gpio.c	2009-01-26 19:07:59.000000000 +0100
@@ -550,6 +550,34 @@ void gpio_sdhc_active(int module)
 		mxc_iomux_set_pad(MX35_PIN_SD1_DATA3, pad_val);
 		break;
 	case 1:
+		mxc_request_iomux(MX35_PIN_SD2_CLK,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_SD2_CMD,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_SD2_DATA0,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_SD2_DATA1,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_SD2_DATA2,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_SD2_DATA3,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+
+		pad_val = PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE |
+			PAD_CTL_HYS_SCHMITZ | PAD_CTL_DRV_MAX |
+			PAD_CTL_47K_PU | PAD_CTL_SRE_FAST;
+
+		mxc_iomux_set_pad(MX35_PIN_SD2_CLK, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD2_CMD, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA0, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA1, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA2, pad_val);
+
+		pad_val = PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE |
+			PAD_CTL_HYS_SCHMITZ | PAD_CTL_DRV_MAX |
+			PAD_CTL_100K_PU | PAD_CTL_SRE_FAST;
+
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA3, pad_val);
 		break;
 	default:
 		break;
@@ -590,7 +618,31 @@ void gpio_sdhc_inactive(int module)
 				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
 		break;
 	case 1:
-		/* TODO:what are the pins for SDHC2? */
+		mxc_free_iomux(MX35_PIN_SD2_CLK,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD2_CMD,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD2_DATA0,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD2_DATA1,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD2_DATA2,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD2_DATA3,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+
+		mxc_iomux_set_pad(MX35_PIN_SD2_CLK,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD2_CMD,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA0,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA1,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA2,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA3,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
 		break;
 	default:
 		break;
Index: linux-2.6.24/arch/arm/mach-mx35/mx35_3stack_irq.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx35/mx35_3stack_irq.c	2009-01-26 18:52:00.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx35/mx35_3stack_irq.c	2009-01-26 19:07:59.000000000 +0100
@@ -30,6 +30,7 @@
 #include <asm/arch/pmic_external.h>
 
 #include "board-mx35_3stack.h"
+#include "board-mx35_fab4.h"
 #include "iomux.h"
 
 /*!
Index: linux-2.6.24/arch/arm/mach-mx35/mx35_fab4.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24/arch/arm/mach-mx35/mx35_fab4.c	2009-01-26 19:07:59.000000000 +0100
@@ -0,0 +1,742 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/flash.h>
+#endif
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/memory.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/mx35_fab4.h>
+
+#include "board-mx35_fab4.h"
+#include "crm_regs.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx35/mx35_fab4.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX35
+ */
+
+unsigned int mx35_fab4_board_io;
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+/* MTD NAND flash */
+
+#if defined(CONFIG_MTD_NAND_MXC) || defined(CONFIG_MTD_NAND_MXC_MODULE)	\
+|| defined(CONFIG_MTD_NAND_MXC_V2) || defined(CONFIG_MTD_NAND_MXC_V2_MODULE)
+
+static struct mtd_partition mxc_nand_partitions_pa2[] = {
+	{
+	 .name = "redboot",
+	 .offset = 0,
+	 .size = 2 * 64 * 2048
+	},
+	{
+	 .name = "ubi",
+	 .offset = 2 * 64 * 2048,
+	 .size = 1016 * 64 * 2048
+	},
+};
+
+static struct mtd_partition mxc_nand_partitions_pa3[] = {
+	{
+	 .name = "redboot",
+	 .offset = 0,
+	 .size = 4 * 64 * 2048
+	},
+	{
+	 .name = "ubi",
+	 .offset = 4 * 64 * 2048,
+	 .size = 1014 * 64 * 2048
+	},
+};
+
+static struct flash_platform_data mxc_nand_data = {
+	.parts = mxc_nand_partitions_pa3,
+	.nr_parts = ARRAY_SIZE(mxc_nand_partitions_pa3),
+	.width = 1,
+};
+
+static struct platform_device mxc_nand_mtd_device = {
+	.name = "mxc_nandv2_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_nand_data,
+		},
+};
+
+static void mxc_init_nand_mtd(void)
+{
+	if (__raw_readl(MXC_CCM_RCSR) & MXC_CCM_RCSR_NF16B)
+		mxc_nand_data.width = 2;
+
+	if (system_rev <= 2) {
+		mxc_nand_data.parts = mxc_nand_partitions_pa2;
+		mxc_nand_data.nr_parts = ARRAY_SIZE(mxc_nand_partitions_pa2);
+	}
+
+	platform_device_register(&mxc_nand_mtd_device);
+}
+#else
+static inline void mxc_init_nand_mtd(void)
+{
+}
+#endif
+
+static struct mxc_lcd_platform_data lcd_data = {
+	.io_reg = "LCD"
+};
+
+static struct platform_device lcd_dev = {
+	.name = "lcd_claa",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = (void *)&lcd_data,
+		},
+};
+
+static void mxc_init_lcd(void)
+{
+	platform_device_register(&lcd_dev);
+}
+
+#if defined(CONFIG_FB_MXC_SYNC_PANEL) || defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
+static const char fb_default_mode[] = "Wintek-480x272";
+
+/* mxc lcd driver */
+static struct platform_device mxc_fb_device = {
+	.name = "mxc_sdc_fb",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &fb_default_mode,
+		.coherent_dma_mask = 0xFFFFFFFF,
+		},
+};
+
+static void mxc_init_fb(void)
+{
+	(void)platform_device_register(&mxc_fb_device);
+}
+#else
+static inline void mxc_init_fb(void)
+{
+}
+#endif
+
+#if defined(CONFIG_BACKLIGHT_MXC)
+static struct platform_device mxcbl_devices[] = {
+#if defined(CONFIG_BACKLIGHT_MXC_IPU) || defined(CONFIG_BACKLIGHT_MXC_IPU_MODULE)
+	{
+	 .name = "mxc_ipu_bl",
+	 .id = 0,
+	 .dev = {
+		 .platform_data = (void *)3,	/* DISP # for this backlight */
+		 },
+	 }
+#endif
+};
+
+static inline void mxc_init_bl(void)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(mxcbl_devices); i++) {
+		platform_device_register(&mxcbl_devices[i]);
+	}
+}
+#else
+static inline void mxc_init_bl(void)
+{
+}
+#endif
+
+static struct resource ir_resources[] = {
+	[0] = {
+	       .start = MX35_PIN_ATA_DA2,
+	       .end = MX35_PIN_ATA_DA2,
+	       .flags = IORESOURCE_MEM,
+	       .name = "xres",
+	       },
+	[1] = {
+	       .start = MX35_PIN_ATA_DA1,
+	       .end = MX35_PIN_ATA_DA1,
+	       .flags = IORESOURCE_MEM,
+	       .name = "sdata",
+	       },
+	[2] = {
+	       .start = MX35_PIN_ATA_DA0,
+	       .end = MX35_PIN_ATA_DA0,
+	       .flags = IORESOURCE_MEM,
+	       .name = "sclk",
+	       },
+};
+
+static struct i2c_board_info mxc_i2c_board_info[] __initdata = {
+	{
+	 .driver_name = "clearpad",
+	 .addr = 0x20,
+	 .irq = IOMUX_TO_IRQ(MX35_PIN_I2C2_CLK),
+	 },
+	{
+	  /* really a tmp100 */
+	 .driver_name = "lm75",
+	 .addr = 0x48,
+	 },
+	{
+	 .driver_name = "tsl2569",
+	 .addr = 0x39,
+	 },
+	{
+	 .driver_name = "fab4-ir",
+	 .addr = 0x47,
+	 .platform_data = ir_resources,
+	 .irq = IOMUX_TO_IRQ(MX35_PIN_I2C2_DAT),
+	 },
+	{
+	 .driver_name = "wm8974-i2c",
+	 .addr = 0x1A,
+	 },
+};
+
+#if defined(CONFIG_FEC) || defined(CONFIG_FEC_MODULE)
+unsigned int expio_intr_fec;
+
+EXPORT_SYMBOL(expio_intr_fec);
+#endif
+
+#if defined(CONFIG_MMC_IMX_ESDHCI) || defined(CONFIG_MMC_IMX_ESDHCI_MODULE)
+static struct mxc_mmc_platform_data mmc_data1 = {
+	.ocr_mask = MMC_VDD_32_33,
+	.min_clk = 400000,
+	.max_clk = 52000000,
+	.card_inserted_state = 1,
+	.status = sdhc_get_card_det_status,
+	.clock_mmc = "sdhc_clk",
+};
+
+/*!
+ * Resource definition for the SDHC1
+ */
+static struct resource mxcsdhc1_resources[] = {
+	[0] = {
+	       .start = MMC_SDHC1_BASE_ADDR,
+	       .end = MMC_SDHC1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_MMC_SDHC1,
+	       .end = MXC_INT_MMC_SDHC1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+		/* No card detect irq */
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for MXC SDHC1 */
+static struct platform_device mxcsdhc1_device = {
+	.name = "mxsdhci",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc_data1,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
+	.resource = mxcsdhc1_resources,
+};
+
+static struct mxc_mmc_platform_data mmc_data2 = {
+	.ocr_mask = MMC_VDD_32_33,
+	.min_clk = 400000,
+	.max_clk = 52000000,
+	.card_inserted_state = 1,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_get_card_wp_status,
+	.clock_mmc = "sdhc_clk",
+};
+
+/*!
+ * Resource definition for the SDHC2
+ */
+static struct resource mxcsdhc2_resources[] = {
+	[0] = {
+	       .start = MMC_SDHC2_BASE_ADDR,
+	       .end = MMC_SDHC2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_MMC_SDHC2,
+	       .end = MXC_INT_MMC_SDHC2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = IOMUX_TO_IRQ(MX35_PIN_ATA_CS0),
+	       .end = IOMUX_TO_IRQ(MX35_PIN_ATA_CS0),
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for MXC SDHC2 */
+static struct platform_device mxcsdhc2_device = {
+	.name = "mxsdhci",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc_data2,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
+	.resource = mxcsdhc2_resources,
+};
+
+static inline void mxc_init_mmc(void)
+{
+	/* WLAN */
+	(void)platform_device_register(&mxcsdhc1_device);
+
+	/* SD Card */
+	(void)platform_device_register(&mxcsdhc2_device);
+}
+#else
+static inline void mxc_init_mmc(void)
+{
+}
+#endif
+
+
+#ifdef CONFIG_SND_SOC_FAB4_AK4420
+static void fab4_ak4420_set_clk(int sample_rate)
+{
+	switch (sample_rate) {
+	case 96000:
+	case 48000:
+	case 32000:
+	case 16000:
+	case 8000:
+		mxc_set_gpio_dataout(MX35_PIN_TX4_RX1, 1);
+		break;
+
+	default:
+		mxc_set_gpio_dataout(MX35_PIN_TX4_RX1, 0);
+		break;
+	}
+}
+
+static struct mxc_audio_platform_data mxc_audio_data = {
+	.ssi_num = 1,
+	.src_port = 1,
+	.ext_port = 4,
+	.intr_id_hp = 0, // FIXME
+	.audio_set_clk = &fab4_ak4420_set_clk , /* OSC_SEL1 */
+};
+
+static struct platform_device mxc_alsa_ak4420_device = {
+	.name = "fab4-ak4420",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_audio_data,
+		},
+
+};
+
+static void mxc_init_ak4420_audio(void)
+{
+	platform_device_register(&mxc_alsa_ak4420_device);
+}
+#else
+static void mxc_init_ak4420_audio(void)
+{
+}
+#endif
+
+
+#ifdef CONFIG_SND_SOC_FAB4_WM8974
+static void fab4_wm8974_set_clk(int sample_rate)
+{
+	switch (sample_rate) {
+	case 96000:
+	case 48000:
+	case 32000:
+	case 16000:
+	case 8000:
+		mxc_set_gpio_dataout(MX35_PIN_TX5_RX0, 1);
+		break;
+
+	default:
+		mxc_set_gpio_dataout(MX35_PIN_TX5_RX0, 0);
+		break;
+	}
+}
+
+static struct mxc_audio_platform_data mxc_wm8974_data = {
+	.ssi_num = 2,
+	.src_port = 2,
+	.ext_port = 5,
+	.intr_id_hp = 0,
+	.audio_set_clk = &fab4_wm8974_set_clk , /* OSC_SEL2 */
+};
+
+static struct platform_device mxc_alsa_wm8974_device = {
+	.name = "fab4-wm8974",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_wm8974_data,
+		},
+
+};
+
+static void mxc_init_wm8974_audio(void)
+{
+	platform_device_register(&mxc_alsa_wm8974_device);
+}
+#else
+static void mxc_init_wm8974_audio(void)
+{
+}
+#endif
+
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	mxc_cpu_init();
+
+#ifdef CONFIG_DISCONTIGMEM
+	do {
+		int nid;
+		mi->nr_banks = MXC_NUMNODES;
+		for (nid = 0; nid < mi->nr_banks; nid++)
+			SET_NODE(mi, nid);
+	} while (0);
+#endif
+}
+
+
+/* PLATFORM DEVICES REVIEWED BELOW THIS POINT */
+
+
+
+#ifdef CONFIG_MXC_FAB4_DEBUG_GPIO
+
+/* GPIO debug  initialization. */
+static struct mxc_fab4_gpio_pins fab4_gpio_pins[] = {
+	{
+		.name = "FAIL_SAFE#",
+		.gpio = MX35_PIN_FST,
+	},
+	{
+		.name = "SD_CD#",
+		.gpio = MX35_PIN_ATA_CS0,
+	},
+	{
+		.name = "SD_WP#",
+		.gpio = MX35_PIN_ATA_DMARQ,
+	},
+	{
+		.name = "I2C_ATTN1#",
+		.gpio = MX35_PIN_I2C2_CLK,
+	},
+	{
+		.name = "I2C_ATTN2#",
+		.gpio = MX35_PIN_I2C2_DAT,
+	},
+	{
+		.name = "IR_SENSOR#",
+		.gpio = MX35_PIN_CAPTURE,
+	},
+	{
+		.name = "IR_LED",
+		.gpio = MX35_PIN_GPIO1_1,
+	},
+	{
+		.name = "OSC_SEL2",
+		.gpio = MX35_PIN_TX5_RX0,
+	},
+	{
+		.name = "OSC_SEL1",
+		.gpio = MX35_PIN_TX4_RX1,
+	},
+	{
+		.name = "HDP_EN",
+		.gpio = MX35_PIN_ATA_RESET_B,
+	},
+	{
+		.name = "LCD_DISP",
+		.gpio = MX35_PIN_D3_SPL,
+	},
+	{
+		.name = "HDP_DET",
+		.gpio = MX35_PIN_ATA_DIOW,
+	},
+	{
+		.name = "WIFI_PD#",
+		.gpio = MX35_PIN_ATA_DIOR,
+	},
+	{
+		.name = "WIFI_RESET#",
+		.gpio = MX35_PIN_ATA_CS1,
+	},
+	{
+		.name = "DAC1_SMUTE",
+		.gpio = MX35_PIN_ATA_INTRQ,
+	},
+};
+
+static struct mxc_fab4_gpio_platform_data fab4_gpio_data = {
+	.pins = fab4_gpio_pins,
+	.nr_pins = ARRAY_SIZE(fab4_gpio_pins),
+};
+
+static struct platform_device fab4_gpio_device = {
+	.name = "fab4_gpio",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &fab4_gpio_data,
+		},
+};
+
+static inline void fab4_gpio_debug_init(void)
+{
+	platform_device_register(&fab4_gpio_device);
+}
+#else
+static inline void fab4_gpio_debug_init(void)
+{
+}
+#endif
+
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	const char *rest;
+
+	mxc_cpu_common_init();
+
+	mxc_clocks_init();
+	early_console_setup(saved_command_line);
+	mxc_gpio_init();
+	mx35_fab4_gpio_init();
+	mxc_init_nand_mtd();
+
+	mxc_init_lcd();
+	mxc_init_fb();
+	mxc_init_bl();
+
+	i2c_register_board_info(0, mxc_i2c_board_info,
+				ARRAY_SIZE(mxc_i2c_board_info));
+
+	mxc_init_mmc();
+
+	mxc_init_ak4420_audio();
+
+	if (system_rev >= 3) {
+		/* Changed to use i2c from PA3/PB1 build */
+		mxc_init_wm8974_audio();
+	}
+
+	fab4_gpio_debug_init();
+
+	switch (__raw_readl(MXC_CCM_RCSR) & 0xF) {
+	case 0x0:
+		rest = "Power On";
+		break;
+	case 0x4:
+		rest = "External";
+		break;
+	case 0x8:
+		rest = "Watchdog timeout";
+		break;
+	case 0x2:
+		rest = "JTAG";
+		break;
+	default:
+		rest = "unknown";
+		break;
+	}
+	printk(KERN_INFO "Reset status: %s\n", rest);
+}
+
+#define PLL_PCTL_REG(brmo, pd, mfd, mfi, mfn)		\
+		(((brmo) << 31) + (((pd) - 1) << 26) + (((mfd) - 1) << 16) + \
+		((mfi)  << 10) + mfn)
+
+/* For 24MHz input clock */
+#define PLL_665MHZ		PLL_PCTL_REG(1, 1, 48, 13, 41)
+#define PLL_532MHZ		PLL_PCTL_REG(1, 1, 12, 11, 1)
+#define PLL_399MHZ		PLL_PCTL_REG(0, 1, 16, 8, 5)
+
+/* working point(wp): 0,1 - 133MHz; 2,3 - 266MHz; 4,5 - 399MHz;*/
+/* auto input clock table */
+static struct cpu_wp cpu_wp_auto[] = {
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 133000000,
+	 .pdr0_reg = (0x2 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 133000000,
+	 .pdr0_reg = (0x6 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 266000000,
+	 .pdr0_reg = (0x1 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 266000000,
+	 .pdr0_reg = (0x5 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 399000000,
+	 .pdr0_reg = (0x0 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 399000000,
+	 .pdr0_reg = (0x6 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+};
+
+/* consumer input clock table */
+static struct cpu_wp cpu_wp_con[] = {
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 133000000,
+	 .pdr0_reg = (0x6 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 133000000,
+	 .pdr0_reg = (0xE << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 266000000,
+	 .pdr0_reg = (0x2 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 266000000,
+	 .pdr0_reg = (0xA << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 399000000,
+	 .pdr0_reg = (0x1 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 399000000,
+	 .pdr0_reg = (0x9 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 532000000,
+	 .pdr0_reg = (0x0 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 532000000,
+	 .pdr0_reg = (0x8 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_665MHZ,
+	 .pll_rate = 665000000,
+	 .cpu_rate = 665000000,
+	 .pdr0_reg = (0x7 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+};
+
+struct cpu_wp *get_cpu_wp(int *wp)
+{
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) >= 1) {
+                *wp = 9;
+                return cpu_wp_con;
+        } else {
+		if (__raw_readl(MXC_CCM_PDR0) & MXC_CCM_PDR0_AUTO_CON) {
+			*wp = 9;
+			return cpu_wp_con;
+		} else {
+			*wp = 6;
+			return cpu_wp_auto;
+		}
+	}
+}
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_FAB4 data structure.
+ */
+/* *INDENT-OFF* */
+MACHINE_START(FAB4, "Logitech Fab4 Board")
+	/* Maintainer: Logitech */
+	.phys_io = AIPS1_BASE_ADDR,
+	.io_pg_offst = ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params = PHYS_OFFSET + 0x100,
+	.fixup = fixup_mxc_board,
+	.map_io = mxc_map_io,
+	.init_irq = mxc_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
Index: linux-2.6.24/arch/arm/mach-mx35/mx35_fab4_gpio.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24/arch/arm/mach-mx35/mx35_fab4_gpio.c	2009-01-26 19:07:59.000000000 +0100
@@ -0,0 +1,908 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/gpio.h>
+#include "board-mx35_fab4.h"
+#include "crm_regs.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx35/mx35_fab4_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO_MX35
+ */
+
+/*!
+ * This system-wise GPIO function initializes the pins during system startup.
+ * All the statically linked device drivers should put the proper GPIO
+ * initialization code inside this function. It is called by \b fixup_mx31ads()
+ * during system startup. This function is board specific.
+ */
+void mx35_fab4_gpio_init(void)
+{
+	/* I2C_ATTN1# */
+	mxc_request_iomux(MX35_PIN_I2C2_CLK, MUX_CONFIG_ALT5);
+	mxc_iomux_set_input(MUX_IN_GPIO2_IN_26, INPUT_CTL_PATH0);
+	mxc_iomux_set_pad(MX35_PIN_I2C2_CLK, 0);
+	mxc_set_gpio_direction(MX35_PIN_I2C2_CLK, 1);
+
+	/* I2C_ATTN2# */
+	mxc_request_iomux(MX35_PIN_I2C2_DAT, MUX_CONFIG_ALT5);
+	mxc_iomux_set_input(MUX_IN_GPIO2_IN_27, INPUT_CTL_PATH0);
+	mxc_iomux_set_pad(MX35_PIN_I2C2_DAT, 0);
+	mxc_set_gpio_direction(MX35_PIN_I2C2_DAT, 1);
+
+	/* OSC_SEL1 */
+	/* output, TX4_RX1/GPIO1_11 */
+	mxc_request_iomux(MX35_PIN_TX4_RX1, MUX_CONFIG_ALT5);
+	mxc_iomux_set_pad(MX35_PIN_TX4_RX1, 0);
+	mxc_set_gpio_dataout(MX35_PIN_TX4_RX1, 0);
+	mxc_set_gpio_direction(MX35_PIN_TX4_RX1, 0);
+
+	/* OSC_SEL2 */
+	// output, TX5_RX0/GPIO1_10
+	// not tested
+	mxc_request_iomux(MX35_PIN_TX5_RX0, MUX_CONFIG_ALT5);
+	mxc_iomux_set_pad(MX35_PIN_TX5_RX0, 0);
+	mxc_set_gpio_dataout(MX35_PIN_TX5_RX0, 0);
+	mxc_set_gpio_direction(MX35_PIN_TX5_RX0, 0);
+
+	/* HDP_EN */
+	// FIXME we may not want this enabled (high)
+	// output, ATA_RESET#/GPIO2_11
+	// not tested
+	mxc_request_iomux(MX35_PIN_ATA_RESET_B, MUX_CONFIG_ALT5);
+	mxc_iomux_set_pad(MX35_PIN_ATA_RESET_B, 0);
+	mxc_set_gpio_dataout(MX35_PIN_ATA_RESET_B, 1);
+	mxc_set_gpio_direction(MX35_PIN_ATA_RESET_B, 0);
+
+	/* HDP_DET */
+	/* input, ATA_DIOW/GPIO2_9 */
+	mxc_request_iomux(MX35_PIN_ATA_DIOW, MUX_CONFIG_ALT5);
+	mxc_iomux_set_input(MUX_IN_GPIO2_IN_9, INPUT_CTL_PATH1);
+	if (system_rev <= 2) {
+		/* pull-up missing on PA2 */
+		mxc_iomux_set_pad(MX35_PIN_ATA_DIOW, PAD_CTL_100K_PU);
+	}
+	else {
+		mxc_iomux_set_pad(MX35_PIN_ATA_DIOW, 0);
+	}
+	mxc_set_gpio_direction(MX35_PIN_ATA_DIOW, 1);
+
+	/* DAC1_SMUTE */
+	// FIXME we may not want this enabled (low)
+	// output, ATA_INTRQ/GPIO2_29
+	// not tested
+	mxc_request_iomux(MX35_PIN_ATA_INTRQ, MUX_CONFIG_ALT5);
+	mxc_iomux_set_pad(MX35_PIN_ATA_INTRQ, 0);
+	mxc_set_gpio_dataout(MX35_PIN_ATA_INTRQ, 0);
+	mxc_set_gpio_direction(MX35_PIN_ATA_INTRQ, 0);
+
+	/* WIFI_PD# */
+	/* output, ATA_DIOR/GPIO2_8 */
+	mxc_request_iomux(MX35_PIN_ATA_DIOR, MUX_CONFIG_ALT5);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DIOR, 0);
+	mxc_set_gpio_dataout(MX35_PIN_ATA_DIOR, 0);
+	mxc_set_gpio_direction(MX35_PIN_ATA_DIOR, 0);
+
+	/* WIFI_RESET# */
+	/* output, ATA_CS1/GPIO2_7 */
+	mxc_request_iomux(MX35_PIN_ATA_CS1, MUX_CONFIG_ALT5);
+	mxc_iomux_set_pad(MX35_PIN_ATA_CS1, 0);
+	mxc_set_gpio_dataout(MX35_PIN_ATA_CS1, 0);
+	mxc_set_gpio_direction(MX35_PIN_ATA_CS1, 0);
+
+	/* FAIL_SAFE# */
+	/* input, FST/GPIO1_8 */
+	mxc_request_iomux(MX35_PIN_FST, MUX_CONFIG_ALT5);
+	mxc_iomux_set_input(MUX_IN_GPIO1_IN_8, INPUT_CTL_PATH1);
+	mxc_iomux_set_pad(MX35_PIN_FST, 0);
+	mxc_set_gpio_direction(MX35_PIN_FST, 1);
+
+	/* LCDP_DISP */
+	// FIXME we may not want this enabled (high)
+	// output, D3_SPL/GPIO1_5
+	mxc_request_iomux(MX35_PIN_D3_SPL, MUX_CONFIG_ALT5);
+	mxc_iomux_set_pad(MX35_PIN_D3_SPL, 0);
+	mxc_set_gpio_dataout(MX35_PIN_D3_SPL, 1);
+	mxc_set_gpio_direction(MX35_PIN_D3_SPL, 0);
+
+
+	/* Power up WLAN */
+	/* FIXME move this to wlan sdi driver */
+	mxc_set_gpio_dataout(MX35_PIN_ATA_CS1, 0); /* reset is active */
+	mxc_set_gpio_dataout(MX35_PIN_ATA_DIOR, 1); /* power-down is inactive */
+	msleep(50); /* wait 50 ms */
+	mxc_set_gpio_dataout(MX35_PIN_ATA_CS1, 1); /* reset is inactive */
+	msleep(1000); /* wait 1000 ms, to allow the wifi to boot */
+}
+
+/*!
+ * Setup GPIO for a UART port to be active
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_active(int port, int no_irda)
+{
+	/*
+	 * Configure the IOMUX control registers for the UART signals
+	 */
+	switch (port) {
+		/* UART 1 IOMUX Configs */
+	case 0:
+		mxc_request_iomux(MX35_PIN_RXD1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_TXD1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_RTS1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_CTS1, MUX_CONFIG_FUNC);
+
+		mxc_iomux_set_pad(MX35_PIN_RXD1,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX35_PIN_TXD1,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		mxc_iomux_set_pad(MX35_PIN_RTS1,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX35_PIN_CTS1,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+
+		break;
+		/* UART 2 IOMUX Configs */
+	case 1:
+		mxc_request_iomux(MX35_PIN_TXD2, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_RXD2, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_RTS2, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_CTS2, MUX_CONFIG_FUNC);
+		mxc_iomux_set_pad(MX35_PIN_RXD2,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX35_PIN_TXD2,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		mxc_iomux_set_pad(MX35_PIN_RTS2,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX35_PIN_CTS2,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		break;
+		/* UART 3 IOMUX Configs */
+	case 2:
+		mxc_request_iomux(MX35_PIN_FEC_TX_CLK, MUX_CONFIG_ALT2);
+		mxc_request_iomux(MX35_PIN_FEC_RX_CLK, MUX_CONFIG_ALT2);
+		mxc_request_iomux(MX35_PIN_FEC_COL, MUX_CONFIG_ALT2);
+		mxc_request_iomux(MX35_PIN_FEC_RX_DV, MUX_CONFIG_ALT2);
+
+		mxc_iomux_set_input(MUX_IN_UART3_UART_RTS_B, INPUT_CTL_PATH2);
+		mxc_iomux_set_input(MUX_IN_UART3_UART_RXD_MUX, INPUT_CTL_PATH3);
+		break;
+	default:
+		break;
+	}
+
+}
+
+EXPORT_SYMBOL(gpio_uart_active);
+
+/*!
+ * Setup GPIO for a UART port to be inactive
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_inactive(int port, int no_irda)
+{
+	switch (port) {
+	case 0:
+		mxc_request_gpio(MX35_PIN_RXD1);
+		mxc_request_gpio(MX35_PIN_TXD1);
+		mxc_request_gpio(MX35_PIN_RTS1);
+		mxc_request_gpio(MX35_PIN_CTS1);
+
+		mxc_free_iomux(MX35_PIN_RXD1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_TXD1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_RTS1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_CTS1, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		mxc_request_gpio(MX35_PIN_RXD2);
+		mxc_request_gpio(MX35_PIN_TXD2);
+		mxc_request_gpio(MX35_PIN_RTS2);
+		mxc_request_gpio(MX35_PIN_CTS2);
+
+		mxc_free_iomux(MX35_PIN_RXD2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_TXD2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_RTS2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_CTS2, MUX_CONFIG_GPIO);
+		break;
+	case 2:
+		mxc_request_gpio(MX35_PIN_FEC_TX_CLK);
+		mxc_request_gpio(MX35_PIN_FEC_RX_CLK);
+		mxc_request_gpio(MX35_PIN_FEC_COL);
+		mxc_request_gpio(MX35_PIN_FEC_RX_DV);
+
+		mxc_free_iomux(MX35_PIN_FEC_TX_CLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_FEC_RX_CLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_FEC_COL, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_FEC_RX_DV, MUX_CONFIG_GPIO);
+
+		mxc_iomux_set_input(MUX_IN_UART3_UART_RTS_B, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_UART3_UART_RXD_MUX, INPUT_CTL_PATH0);
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_uart_inactive);
+
+/*!
+ * Configure the IOMUX GPR register to receive shared SDMA UART events
+ *
+ * @param  port         a UART port
+ */
+void config_uartdma_event(int port)
+{
+}
+
+EXPORT_SYMBOL(config_uartdma_event);
+
+void gpio_fec_active(void)
+{
+	mxc_request_iomux(MX35_PIN_FEC_TX_CLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RX_CLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RX_DV, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_COL, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RDATA0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_TDATA0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_TX_EN, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_MDC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_MDIO, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_TX_ERR, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RX_ERR, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_CRS, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RDATA1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_TDATA1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RDATA2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_TDATA2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RDATA3, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_TDATA3, MUX_CONFIG_FUNC);
+
+#define FEC_PAD_CTL_COMMON (PAD_CTL_DRV_3_3V|PAD_CTL_PUE_PUD| \
+			PAD_CTL_ODE_CMOS|PAD_CTL_DRV_NORMAL|PAD_CTL_SRE_SLOW)
+	mxc_iomux_set_pad(MX35_PIN_FEC_TX_CLK, FEC_PAD_CTL_COMMON |
+			  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+			  PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RX_CLK,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_SCHMITZ |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RX_DV,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_SCHMITZ |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_COL,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_SCHMITZ |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RDATA0,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_SCHMITZ |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_TDATA0,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_CMOS |
+			  PAD_CTL_PKE_NONE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_TX_EN,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_CMOS |
+			  PAD_CTL_PKE_NONE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_MDC,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_CMOS |
+			  PAD_CTL_PKE_NONE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_MDIO,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_SCHMITZ |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_22K_PU);
+	mxc_iomux_set_pad(MX35_PIN_FEC_TX_ERR,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_CMOS |
+			  PAD_CTL_PKE_NONE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RX_ERR,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_SCHMITZ |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_CRS,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_SCHMITZ |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RDATA1,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_SCHMITZ |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_TDATA1,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_CMOS |
+			  PAD_CTL_PKE_NONE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RDATA2,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_SCHMITZ |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_TDATA2,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_CMOS |
+			  PAD_CTL_PKE_NONE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RDATA3,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_SCHMITZ |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_TDATA3,
+			  FEC_PAD_CTL_COMMON | PAD_CTL_HYS_CMOS |
+			  PAD_CTL_PKE_NONE | PAD_CTL_100K_PD);
+#undef FEC_PAD_CTL_COMMON
+}
+
+EXPORT_SYMBOL(gpio_fec_active);
+
+void gpio_fec_inactive(void)
+{
+	mxc_request_gpio(MX35_PIN_FEC_TX_CLK);
+	mxc_request_gpio(MX35_PIN_FEC_RX_CLK);
+	mxc_request_gpio(MX35_PIN_FEC_RX_DV);
+	mxc_request_gpio(MX35_PIN_FEC_COL);
+	mxc_request_gpio(MX35_PIN_FEC_RDATA0);
+	mxc_request_gpio(MX35_PIN_FEC_TDATA0);
+	mxc_request_gpio(MX35_PIN_FEC_TX_EN);
+	mxc_request_gpio(MX35_PIN_FEC_MDC);
+	mxc_request_gpio(MX35_PIN_FEC_MDIO);
+	mxc_request_gpio(MX35_PIN_FEC_TX_ERR);
+	mxc_request_gpio(MX35_PIN_FEC_RX_ERR);
+	mxc_request_gpio(MX35_PIN_FEC_CRS);
+	mxc_request_gpio(MX35_PIN_FEC_RDATA1);
+	mxc_request_gpio(MX35_PIN_FEC_TDATA1);
+	mxc_request_gpio(MX35_PIN_FEC_RDATA2);
+	mxc_request_gpio(MX35_PIN_FEC_TDATA2);
+	mxc_request_gpio(MX35_PIN_FEC_RDATA3);
+	mxc_request_gpio(MX35_PIN_FEC_TDATA3);
+
+	mxc_free_iomux(MX35_PIN_FEC_TX_CLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RX_CLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RX_DV, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_COL, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RDATA0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_TDATA0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_TX_EN, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_MDC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_MDIO, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_TX_ERR, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RX_ERR, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_CRS, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RDATA1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_TDATA1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RDATA2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_TDATA2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RDATA3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_TDATA3, MUX_CONFIG_GPIO);
+}
+
+EXPORT_SYMBOL(gpio_fec_inactive);
+
+/*!
+ * Setup GPIO for an I2C device to be active
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_active(int i2c_num)
+{
+
+#define PAD_CONFIG (PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | PAD_CTL_ODE_OpenDrain)
+
+	switch (i2c_num) {
+	case 0:
+		mxc_request_iomux(MX35_PIN_I2C1_CLK, MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_I2C1_DAT, MUX_CONFIG_SION);
+
+		mxc_iomux_set_pad(MX35_PIN_I2C1_CLK, PAD_CONFIG);
+		mxc_iomux_set_pad(MX35_PIN_I2C1_DAT, PAD_CONFIG);
+		break;
+	case 1:
+		mxc_request_iomux(MX35_PIN_I2C2_CLK, MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_I2C2_DAT, MUX_CONFIG_SION);
+
+		mxc_iomux_set_pad(MX35_PIN_I2C2_CLK, PAD_CONFIG);
+		mxc_iomux_set_pad(MX35_PIN_I2C2_DAT, PAD_CONFIG);
+
+		break;
+	case 2:
+		mxc_request_iomux(MX35_PIN_TX3_RX2, MUX_CONFIG_ALT1);
+		mxc_request_iomux(MX35_PIN_TX2_RX3, MUX_CONFIG_ALT1);
+		mxc_iomux_set_pad(MX35_PIN_TX3_RX2, PAD_CONFIG);
+		mxc_iomux_set_pad(MX35_PIN_TX2_RX3, PAD_CONFIG);
+		break;
+	default:
+		break;
+	}
+
+#undef PAD_CONFIG
+
+}
+
+EXPORT_SYMBOL(gpio_i2c_active);
+
+/*!
+ * Setup GPIO for an I2C device to be inactive
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_inactive(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		break;
+	case 1:
+		break;
+	case 2:
+		mxc_request_iomux(MX35_PIN_TX3_RX2, MUX_CONFIG_GPIO);
+		mxc_request_iomux(MX35_PIN_TX2_RX3, MUX_CONFIG_GPIO);
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_i2c_inactive);
+
+/*!
+ * Setup GPIO for a CSPI device to be active
+ *
+ * @param  cspi_mod         an CSPI device
+ */
+void gpio_spi_active(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		mxc_request_iomux(MX35_PIN_CSPI1_MOSI, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_CSPI1_MISO, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_CSPI1_SS0, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_CSPI1_SS1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_CSPI1_SCLK, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_CSPI1_SPI_RDY, MUX_CONFIG_FUNC);
+
+		mxc_iomux_set_pad(MX35_PIN_CSPI1_MOSI,
+				  PAD_CTL_DRV_3_3V | PAD_CTL_HYS_SCHMITZ |
+				  PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD |
+				  PAD_CTL_100K_PD | PAD_CTL_DRV_NORMAL);
+		mxc_iomux_set_pad(MX35_PIN_CSPI1_MISO,
+				  PAD_CTL_DRV_3_3V | PAD_CTL_HYS_SCHMITZ |
+				  PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD |
+				  PAD_CTL_100K_PD | PAD_CTL_DRV_NORMAL);
+		mxc_iomux_set_pad(MX35_PIN_CSPI1_SS0,
+				  PAD_CTL_DRV_3_3V | PAD_CTL_HYS_SCHMITZ |
+				  PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD |
+				  PAD_CTL_100K_PU | PAD_CTL_ODE_CMOS |
+				  PAD_CTL_DRV_NORMAL);
+		mxc_iomux_set_pad(MX35_PIN_CSPI1_SS1,
+				  PAD_CTL_DRV_3_3V | PAD_CTL_HYS_SCHMITZ |
+				  PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD |
+				  PAD_CTL_100K_PU | PAD_CTL_ODE_CMOS |
+				  PAD_CTL_DRV_NORMAL);
+		mxc_iomux_set_pad(MX35_PIN_CSPI1_SCLK,
+				  PAD_CTL_DRV_3_3V | PAD_CTL_HYS_SCHMITZ |
+				  PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD |
+				  PAD_CTL_100K_PD | PAD_CTL_DRV_NORMAL);
+		mxc_iomux_set_pad(MX35_PIN_CSPI1_SPI_RDY,
+				  PAD_CTL_DRV_3_3V | PAD_CTL_HYS_SCHMITZ |
+				  PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD |
+				  PAD_CTL_100K_PU | PAD_CTL_DRV_NORMAL);
+		break;
+	case 1:
+		/* SPI2 */
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_spi_active);
+
+/*!
+ * Setup GPIO for a CSPI device to be inactive
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_inactive(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		mxc_request_gpio(MX35_PIN_CSPI1_MOSI);
+		mxc_request_gpio(MX35_PIN_CSPI1_MISO);
+		mxc_request_gpio(MX35_PIN_CSPI1_SS0);
+		mxc_request_gpio(MX35_PIN_CSPI1_SS1);
+		mxc_request_gpio(MX35_PIN_CSPI1_SCLK);
+		mxc_request_gpio(MX35_PIN_CSPI1_SPI_RDY);
+
+		mxc_free_iomux(MX35_PIN_CSPI1_MOSI, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_CSPI1_MISO, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_CSPI1_SS0, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_CSPI1_SS1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_CSPI1_SCLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_CSPI1_SPI_RDY, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		/* SPI2 */
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_spi_inactive);
+
+/*!
+ * Setup GPIO for LCD to be active
+ */
+void gpio_lcd_active(void)
+{
+	mxc_request_iomux(MX35_PIN_LD0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD3, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD4, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD5, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD6, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD7, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD8, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD9, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD10, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD11, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD12, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD13, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD14, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD15, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD16, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD17, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD18, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD19, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD20, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD21, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD22, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD23, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_D3_VSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_D3_HSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_D3_FPSHIFT, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_D3_DRDY, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_CONTRAST, MUX_CONFIG_FUNC);
+}
+
+EXPORT_SYMBOL(gpio_lcd_active);
+
+/*!
+ * Setup GPIO for LCD to be inactive
+ */
+void gpio_lcd_inactive(void)
+{
+}
+
+EXPORT_SYMBOL(gpio_lcd_inactive);
+
+/*!
+ * Setup GPIO for SDHC to be active
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_active(int module)
+{
+	unsigned int pad_val;
+
+	switch (module) {
+	case 0:
+		/* WLAN Module */
+		mxc_request_iomux(MX35_PIN_SD1_CLK,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_SD1_CMD,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_SD1_DATA0,
+				  MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_SD1_DATA1,
+				  MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_SD1_DATA2,
+				  MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_SD1_DATA3,
+				  MUX_CONFIG_FUNC);
+
+		pad_val = PAD_CTL_DRV_3_3V | PAD_CTL_HYS_CMOS |
+			PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE |
+			PAD_CTL_47K_PU | PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST;
+
+		mxc_iomux_set_pad(MX35_PIN_SD1_CLK, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD1_CMD, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD1_DATA0, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD1_DATA1, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD1_DATA2, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD1_DATA3, pad_val);
+		break;
+	case 1:
+		/* SD Card */
+		mxc_request_iomux(MX35_PIN_SD2_CLK,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_SD2_CMD,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_SD2_DATA0, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_SD2_DATA1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_SD2_DATA2, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_SD2_DATA3, MUX_CONFIG_FUNC);
+
+		pad_val = PAD_CTL_DRV_MAX | PAD_CTL_PUE_PUD |
+			PAD_CTL_PKE_ENABLE | PAD_CTL_22K_PU |
+			PAD_CTL_SRE_FAST;
+
+		mxc_iomux_set_pad(MX35_PIN_SD2_CLK, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD2_CMD, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA0, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA1, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA2, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA3, pad_val);
+
+		/* Chip select and write protect */
+		mxc_request_iomux(MX35_PIN_ATA_CS0, MUX_CONFIG_ALT5);
+		mxc_iomux_set_input(MUX_IN_GPIO2_IN_6, INPUT_CTL_PATH1);
+		mxc_iomux_set_pad(MX35_PIN_ATA_CS0, 0);
+		mxc_set_gpio_direction(MX35_PIN_ATA_CS0, 1);
+
+		mxc_request_iomux(MX35_PIN_ATA_DMARQ, MUX_CONFIG_ALT5);
+		mxc_iomux_set_input(MUX_IN_GPIO2_IN_31, INPUT_CTL_PATH1);
+		mxc_iomux_set_pad(MX35_PIN_ATA_DMARQ, 0);
+		mxc_set_gpio_direction(MX35_PIN_ATA_DMARQ, 1);
+
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+/*!
+ * Setup GPIO for SDHC1 to be inactive
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_inactive(int module)
+{
+	switch (module) {
+	case 0:
+		/* WLAN Module */
+		mxc_free_iomux(MX35_PIN_SD1_CLK,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD1_CMD,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD1_DATA0,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD1_DATA1,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD1_DATA2,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD1_DATA3,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+
+		mxc_iomux_set_pad(MX35_PIN_SD1_CLK,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD1_CMD,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD1_DATA0,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD1_DATA1,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD1_DATA2,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD1_DATA3,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		break;
+	case 1:
+		/* SD Card */
+		mxc_free_iomux(MX35_PIN_SD2_CLK,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD2_CMD,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD2_DATA0,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD2_DATA1,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD2_DATA2,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_free_iomux(MX35_PIN_SD2_DATA3,
+			       MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+
+		mxc_iomux_set_pad(MX35_PIN_SD2_CLK,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD2_CMD,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA0,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA1,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA2,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA3,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+
+		/* Chip select and write protect */
+		mxc_free_iomux(MX35_PIN_ATA_CS0, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX35_PIN_ATA_DMARQ, MUX_CONFIG_FUNC);
+
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+/*
+ * Probe for the card. If present the GPIO data would be set.
+ */
+unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	if (to_platform_device(dev)->id == 0) {
+		/* WLAN Module - always available */
+		return 0;
+	}
+	else if (to_platform_device(dev)->id == 1) {
+		/* SD Card */
+		return mxc_get_gpio_datain(MX35_PIN_ATA_CS0);
+	} else {
+		return 0;
+	}
+}
+
+EXPORT_SYMBOL(sdhc_get_card_det_status);
+
+/*
+ * Write protect for the card. If present the GPIO data would be set.
+ */
+unsigned int sdhc_get_card_wp_status(void)
+{
+	unsigned int ret;
+
+	/* SD Card */
+	ret = mxc_get_gpio_datain(MX35_PIN_ATA_DMARQ);
+	return ret;
+}
+
+EXPORT_SYMBOL(sdhc_get_card_wp_status);
+
+/*
+ *  USB Host2
+ */
+int gpio_usbh2_active(void)
+{
+	mxc_request_iomux(MX35_PIN_I2C2_CLK, MUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX35_PIN_I2C2_CLK, 0x0040);
+
+	mxc_request_iomux(MX35_PIN_I2C2_DAT, MUX_CONFIG_ALT2);
+	mxc_iomux_set_input(MUX_IN_USB_UH2_USB_OC, INPUT_CTL_PATH1);
+	mxc_iomux_set_pad(MX35_PIN_I2C2_DAT, 0x01c0);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(gpio_usbh2_active);
+
+void gpio_usbh2_inactive(void)
+{
+	mxc_request_gpio(MX35_PIN_I2C2_DAT);
+	mxc_free_iomux(MX35_PIN_I2C2_DAT, MUX_CONFIG_GPIO);
+	mxc_request_gpio(MX35_PIN_I2C2_CLK);
+	mxc_free_iomux(MX35_PIN_I2C2_CLK, MUX_CONFIG_GPIO);
+}
+
+EXPORT_SYMBOL(gpio_usbh2_inactive);
+
+/*
+ *  USB OTG UTMI
+ */
+int gpio_usbotg_utmi_active(void)
+{
+	mxc_request_iomux(MX35_PIN_USBOTG_PWR, MUX_CONFIG_FUNC);
+	mxc_iomux_set_pad(MX35_PIN_USBOTG_PWR, 0x0040);
+	mxc_request_iomux(MX35_PIN_USBOTG_OC, MUX_CONFIG_FUNC);
+	mxc_iomux_set_pad(MX35_PIN_USBOTG_OC, 0x01c0);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(gpio_usbotg_utmi_active);
+
+void gpio_usbotg_utmi_inactive(void)
+{
+	mxc_request_gpio(MX35_PIN_USBOTG_PWR);
+	mxc_free_iomux(MX35_PIN_USBOTG_PWR, MUX_CONFIG_GPIO);
+	mxc_request_gpio(MX35_PIN_USBOTG_OC);
+	mxc_free_iomux(MX35_PIN_USBOTG_OC, MUX_CONFIG_GPIO);
+}
+
+EXPORT_SYMBOL(gpio_usbotg_utmi_inactive);
+
+/*!
+ * Setup GPIO for spdif tx/rx to be active
+ */
+void gpio_spdif_active(void)
+{
+	/* SPDIF OUT */
+	mxc_free_iomux(MX35_PIN_CTS2, MUX_CONFIG_GPIO);
+
+	mxc_request_iomux(MX35_PIN_CTS2, MUX_CONFIG_ALT1);
+	mxc_iomux_set_pad(MX35_PIN_CTS2, PAD_CTL_PKE_NONE | PAD_CTL_PUE_PUD);
+}
+
+EXPORT_SYMBOL(gpio_spdif_active);
+
+/*!
+ * Setup GPIO for spdif tx/rx to be inactive
+ */
+void gpio_spdif_inactive(void)
+{
+	/* SPDIF OUT */
+	mxc_free_iomux(MX35_PIN_CTS2, MUX_CONFIG_ALT1);
+
+	/* turn off led */
+	mxc_request_iomux(MX35_PIN_CTS2, MUX_CONFIG_ALT5);
+	if (system_rev <= 2) {
+		mxc_set_gpio_dataout(MX35_PIN_CTS2, 1);
+	}
+	else {
+		mxc_set_gpio_dataout(MX35_PIN_CTS2, 0);
+	}
+	mxc_set_gpio_direction(MX35_PIN_CTS2, 0);
+}
+
+EXPORT_SYMBOL(gpio_spdif_inactive);
+
+/*!
+ * This function activates DAM ports 3 to enable
+ * audio I/O.
+ */
+void gpio_activate_audio_ports(int ssi_port)
+{
+	unsigned int pad_val;
+	u32 reg;
+
+	if (ssi_port == 1) {
+		/* Select osc_audio for SSI1 audio clock */
+		reg = __raw_readl(MXC_CCM_ACMR);
+		reg &= ~MXC_CCM_ACMR_SSI1_CLK_SEL_MASK;
+		reg |= (0x01 << MXC_CCM_ACMR_SSI1_CLK_SEL_OFFSET);
+		__raw_writel(reg, MXC_CCM_ACMR);
+
+		mxc_request_iomux(MX35_PIN_STXD4, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_SRXD4, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_SCK4, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_STXFS4, MUX_CONFIG_FUNC);
+
+		pad_val = PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PU |
+			PAD_CTL_PUE_PUD;
+		mxc_iomux_set_pad(MX35_PIN_STXD4, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SRXD4, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SCK4, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_STXFS4, pad_val);
+	}
+	else {
+		mxc_request_iomux(MX35_PIN_STXD5, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_SRXD5, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_SCK5, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_STXFS5, MUX_CONFIG_FUNC);
+
+		pad_val = PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PU |
+			PAD_CTL_PUE_PUD;
+		mxc_iomux_set_pad(MX35_PIN_STXD5, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SRXD5, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SCK5, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_STXFS5, pad_val);
+	}
+}
+
+EXPORT_SYMBOL(gpio_activate_audio_ports);
Index: linux-2.6.24/arch/arm/mach-mx35/sdma_script_code_v2.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24/arch/arm/mach-mx35/sdma_script_code_v2.h	2009-01-26 19:07:59.000000000 +0100
@@ -0,0 +1,234 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.  */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/*******************************************************************************
+
+			SDMA RELEASE LABEL: 	"SDMA_RINGO.03.00.00"
+
+*******************************************************************************/
+
+#ifndef SDMA_SCRIPT_CODE_V2_H
+#define SDMA_SCRIPT_CODE_V2_H
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define start_ADDR_V2	0
+#define start_SIZE_V2	24
+
+#define core_ADDR_V2	80
+#define core_SIZE_V2	233
+
+#define common_ADDR_V2	313
+#define common_SIZE_V2	416
+
+#define ap_2_ap_ADDR_V2	729
+#define ap_2_ap_SIZE_V2	41
+
+#define app_2_mcu_ADDR_V2	770
+#define app_2_mcu_SIZE_V2	64
+
+#define mcu_2_app_ADDR_V2	834
+#define mcu_2_app_SIZE_V2	70
+
+#define uart_2_mcu_ADDR_V2	904
+#define uart_2_mcu_SIZE_V2	75
+
+#define shp_2_mcu_ADDR_V2	979
+#define shp_2_mcu_SIZE_V2	69
+
+#define mcu_2_shp_ADDR_V2	1048
+#define mcu_2_shp_SIZE_V2	72
+
+#define per_2_shp_ADDR_V2	1120
+#define per_2_shp_SIZE_V2	78
+
+#define shp_2_per_ADDR_V2	1198
+#define shp_2_per_SIZE_V2	72
+
+#define uartsh_2_mcu_ADDR_V2	1270
+#define uartsh_2_mcu_SIZE_V2	69
+
+#define mcu_2_ata_ADDR_V2	1339
+#define mcu_2_ata_SIZE_V2	90
+
+#define ata_2_mcu_ADDR_V2	1429
+#define ata_2_mcu_SIZE_V2	102
+
+#define app_2_per_ADDR_V2	1531
+#define app_2_per_SIZE_V2	66
+
+#define per_2_app_ADDR_V2	1597
+#define per_2_app_SIZE_V2	74
+
+#define loop_DMAs_routines_ADDR_V2	1671
+#define loop_DMAs_routines_SIZE_V2	240
+
+#define test_ADDR_V2	1911
+#define test_SIZE_V2	63
+
+#define signature_ADDR_V2	1022
+#define signature_SIZE_V2	1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define asrc__mcu_ADDR_V2	6144
+#define asrc__mcu_SIZE_V2	116
+
+#define ext_mem__ipu_ram_ADDR_V2	6260
+#define ext_mem__ipu_ram_SIZE_V2	123
+
+#define mcu_2_spdif_ADDR_V2	6383
+#define mcu_2_spdif_SIZE_V2	103
+
+#define p_2_p_ADDR_V2	6486
+#define p_2_p_SIZE_V2	260
+
+#define spdif_2_mcu_ADDR_V2	6746
+#define spdif_2_mcu_SIZE_V2	47
+
+#define uart_2_per_ADDR_V2	6793
+#define uart_2_per_SIZE_V2	73
+
+#define uartsh_2_per_ADDR_V2	6866
+#define uartsh_2_per_SIZE_V2	67
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define RAM_CODE_START_ADDR_V2		6144
+#define RAM_CODE_SIZE_V2		789
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+
+static const short sdma_code_v2[] = {
+	0xc230, 0xc23a, 0x56f3, 0x57db, 0x047a, 0x7d07, 0x072f, 0x076e,
+	0x7d02, 0x6ec7, 0x9813, 0x6ed7, 0x9813, 0x074f, 0x076e, 0x7d02,
+	0x6e01, 0x9813, 0x6e05, 0x5ce3, 0x048f, 0x0410, 0x3c0f, 0x5c93,
+	0x0e03, 0x0611, 0x1eff, 0x06bf, 0x06d5, 0x7d01, 0x068d, 0x05a6,
+	0x5deb, 0x55fb, 0x008e, 0x076a, 0x7d02, 0x076b, 0x7c04, 0x06d4,
+	0x7d01, 0x008c, 0x04a0, 0x06a0, 0x076f, 0x7d0c, 0x076e, 0x7d05,
+	0x7802, 0x62c8, 0x5a05, 0x7c2b, 0x9847, 0x7802, 0x5205, 0x6ac8,
+	0x7c26, 0x9847, 0x076e, 0x7d05, 0x7802, 0x620b, 0x5a05, 0x7c21,
+	0x9847, 0x7802, 0x5205, 0x6a0b, 0x7c1c, 0x6a28, 0x7f1a, 0x076a,
+	0x7d02, 0x076b, 0x7c0a, 0x4c00, 0x7c08, 0x076a, 0x7d03, 0x5a05,
+	0x7f11, 0x9854, 0x5205, 0x7e0e, 0x5493, 0x4e00, 0x7ccb, 0x0000,
+	0x54e3, 0x55eb, 0x4d00, 0x7d0a, 0xc251, 0x57db, 0x9814, 0x68cc,
+	0x9862, 0x680c, 0x009e, 0x0007, 0x54e3, 0xd868, 0xc261, 0x9802,
+	0x55eb, 0x009d, 0x058c, 0x0aff, 0x0211, 0x1aff, 0x05ba, 0x05a0,
+	0x04b2, 0x04ad, 0x0454, 0x0006, 0x0e70, 0x0611, 0x5616, 0xc18a,
+	0x7d2a, 0x5ade, 0x008e, 0xc19c, 0x7c26, 0x5be0, 0x5ef0, 0x5ce8,
+	0x0688, 0x08ff, 0x0011, 0x28ff, 0x00bc, 0x53f6, 0x05df, 0x7d0b,
+	0x6dc5, 0x03df, 0x7d03, 0x6bd5, 0xd8c3, 0x989f, 0x6b05, 0xc6e7,
+	0x7e27, 0x7f29, 0x989f, 0x6d01, 0x03df, 0x7d05, 0x6bd5, 0xc711,
+	0x7e18, 0x7f1a, 0x989f, 0x6b05, 0xc687, 0x7e07, 0x7f06, 0x52de,
+	0x53e6, 0xc1a8, 0x7dd7, 0x0200, 0x9877, 0x0007, 0x6004, 0x680c,
+	0x53f6, 0x028e, 0x00a3, 0xc2ad, 0x048b, 0x0498, 0x0454, 0x068a,
+	0x989f, 0x0207, 0x680c, 0x6ddf, 0x0107, 0x68ff, 0x60d0, 0x98a8,
+	0x0207, 0x68ff, 0x6d28, 0x0107, 0x6004, 0x680c, 0x98a8, 0x0007,
+	0x68ff, 0x60d0, 0x98a8, 0x0288, 0x03a5, 0x3b03, 0x3d03, 0x4d00,
+	0x7d0a, 0x0804, 0x00a5, 0x00da, 0x7d1a, 0x02a0, 0x7b01, 0x65d8,
+	0x7eee, 0x65ff, 0x7eec, 0x0804, 0x02d0, 0x7d11, 0x4b00, 0x7c0f,
+	0x008a, 0x3003, 0x6dcf, 0x6bdf, 0x0015, 0x0015, 0x7b02, 0x65d8,
+	0x0000, 0x7edd, 0x63ff, 0x7edb, 0x3a03, 0x6dcd, 0x6bdd, 0x008a,
+	0x7b02, 0x65d8, 0x0000, 0x7ed3, 0x65ff, 0x7ed1, 0x0006, 0xc230,
+	0xc23a, 0x57db, 0x52f3, 0x047a, 0x7d06, 0x0479, 0x7c02, 0x6ac6,
+	0x98fc, 0x6ac7, 0x98fc, 0x6a01, 0x008f, 0x00d5, 0x7d01, 0x008d,
+	0x05a0, 0x5deb, 0x56fb, 0x0478, 0x7d4e, 0x0479, 0x7c1f, 0x0015,
+	0x0388, 0x047a, 0x7d03, 0x62c8, 0x7e39, 0x9910, 0x620a, 0x7e38,
+	0x0808, 0x7801, 0x0217, 0x5a06, 0x7f34, 0x2301, 0x047a, 0x7d03,
+	0x62c8, 0x7e2c, 0x991d, 0x620a, 0x7e2b, 0x0808, 0x7801, 0x0217,
+	0x5a26, 0x7f27, 0x2301, 0x4b00, 0x7ce4, 0x993c, 0x0015, 0x0015,
+	0x0015, 0x047a, 0x7d09, 0x7806, 0x0b00, 0x62c8, 0x5a06, 0x0b01,
+	0x62c8, 0x5a26, 0x7c13, 0x993c, 0x7806, 0x0b00, 0x620b, 0x5a06,
+	0x0b01, 0x620b, 0x5a26, 0x7c0c, 0x0b70, 0x0311, 0x5313, 0x0000,
+	0x55eb, 0x4d00, 0x7d11, 0xc251, 0x57db, 0x98fc, 0x68cc, 0x9949,
+	0x680c, 0x0007, 0x0479, 0x7c02, 0x008b, 0x9950, 0x0017, 0x00a3,
+	0x0b70, 0x0311, 0x5313, 0xc26a, 0xc261, 0x98f1, 0x0b70, 0x0311,
+	0x5313, 0x076c, 0x7c01, 0xc230, 0x5efb, 0x068a, 0x076b, 0x7c01,
+	0xc230, 0x5ef3, 0x59db, 0x58d3, 0x018f, 0x0110, 0x390f, 0x008b,
+	0xc18a, 0x7d2b, 0x5ac0, 0x5bc8, 0xc19c, 0x7c27, 0x0388, 0x0689,
+	0x5ce3, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x073e, 0x4d00, 0x7d18,
+	0x0870, 0x0011, 0x077e, 0x7d09, 0x077d, 0x7d02, 0x5228, 0x9981,
+	0x52f8, 0x54db, 0x02bc, 0x02cc, 0x7c09, 0x077c, 0x7d02, 0x5228,
+	0x998a, 0x52f8, 0x54d3, 0x02bc, 0x02cc, 0x7d09, 0x0400, 0x9978,
+	0x008b, 0x52c0, 0x53c8, 0xc1a8, 0x7dd6, 0x0200, 0x9968, 0x08ff,
+	0x00bf, 0x077f, 0x7d1b, 0x0488, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+	0x5deb, 0x028f, 0x32ff, 0x0210, 0x32ff, 0x0210, 0x0212, 0x0217,
+	0x0217, 0x32ff, 0x0212, 0x05da, 0x7c02, 0x073e, 0x99b9, 0x02a4,
+	0x02dd, 0x7d02, 0x073e, 0x99b9, 0x075e, 0x99b9, 0x55eb, 0x0598,
+	0x5deb, 0x52f3, 0x54fb, 0x076a, 0x7d26, 0x076c, 0x7d01, 0x99f6,
+	0x076b, 0x7c57, 0x0769, 0x7d04, 0x0768, 0x7d02, 0x0e01, 0x99d0,
+	0x5893, 0x00d6, 0x7d01, 0x008e, 0x5593, 0x05a0, 0x5d93, 0x06a0,
+	0x7802, 0x5502, 0x5d04, 0x7c1d, 0x4e00, 0x7c08, 0x0769, 0x7d03,
+	0x5502, 0x7e17, 0x99dd, 0x5d04, 0x7f14, 0x0689, 0x5093, 0x4800,
+	0x7d01, 0x99c8, 0x9a41, 0x0015, 0x7806, 0x5502, 0x5d04, 0x074d,
+	0x5502, 0x5d24, 0x072d, 0x7c01, 0x9a41, 0x0017, 0x076d, 0x7c01,
+	0x2001, 0x5593, 0x009d, 0x0007, 0xda48, 0x9990, 0x6cd3, 0x0769,
+	0x7d04, 0x0768, 0x7d02, 0x0e01, 0x9a05, 0x5893, 0x00d6, 0x7d01,
+	0x008e, 0x5593, 0x05a0, 0x5d93, 0x06a0, 0x7802, 0x5502, 0x6dc8,
+	0x7c0f, 0x4e00, 0x7c08, 0x0769, 0x7d03, 0x5502, 0x7e09, 0x9a12,
+	0x6dc8, 0x7f06, 0x0689, 0x5093, 0x4800, 0x7d01, 0x99fd, 0x9a41,
+	0x9a3b, 0x6ac3, 0x0769, 0x7d04, 0x0768, 0x7d02, 0x0e01, 0x9a28,
+	0x5893, 0x00d6, 0x7d01, 0x008e, 0x5593, 0x05a0, 0x5d93, 0x06a0,
+	0x7802, 0x65c8, 0x5d04, 0x7c0f, 0x4e00, 0x7c08, 0x0769, 0x7d03,
+	0x65c8, 0x7e09, 0x9a35, 0x5d04, 0x7f06, 0x0689, 0x5093, 0x4800,
+	0x7d01, 0x9a20, 0x9a41, 0x5593, 0x009d, 0x0007, 0x6cff, 0xda48,
+	0x9990, 0x0000, 0x54e3, 0x55eb, 0x4d00, 0x7c01, 0x9990, 0x9978,
+	0x54e3, 0x55eb, 0x0aff, 0x0211, 0x1aff, 0x077f, 0x7c02, 0x05a0,
+	0x9a55, 0x009d, 0x058c, 0x05ba, 0x05a0, 0x0210, 0x04ba, 0x04ad,
+	0x0454, 0x0006, 0xc230, 0xc23a, 0x57db, 0x52f3, 0x047a, 0x7d02,
+	0x6ad7, 0x9a63, 0x6a05, 0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+	0x56fb, 0x0015, 0x0015, 0x0015, 0x047a, 0x7d07, 0x7804, 0x5206,
+	0x6ac8, 0x5226, 0x6ac8, 0x7c0f, 0x9a7d, 0x7804, 0x5206, 0x6a0b,
+	0x5226, 0x6a0b, 0x7c0a, 0x6a28, 0x7f08, 0x0000, 0x4d00, 0x7d07,
+	0xc251, 0x57db, 0x9a63, 0xc2ca, 0x9a86, 0xc2ce, 0x0454, 0xc261,
+	0x9a5c, 0xc23a, 0x57db, 0x52f3, 0x6ad5, 0x56fb, 0x028e, 0x1a94,
+	0x6ac3, 0x62c8, 0x0269, 0x7d1e, 0x1e94, 0x6ee3, 0x62d0, 0x5aeb,
+	0x62c8, 0x0248, 0x6ed3, 0x6ac8, 0x2694, 0x52eb, 0x6ad5, 0x6ee3,
+	0x62c8, 0x026e, 0x7d27, 0x6ac8, 0x7f23, 0x2501, 0x4d00, 0x7d26,
+	0x028e, 0x1a98, 0x6ac3, 0x62c8, 0x6ec3, 0x0260, 0x7df1, 0x62d0,
+	0xc2d1, 0x9ace, 0x6ee3, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d,
+	0x05a0, 0x62c8, 0x026e, 0x7d0e, 0x6ac8, 0x7f0a, 0x2001, 0x7cf9,
+	0x6add, 0x7f06, 0x0000, 0x4d00, 0x7d09, 0xc251, 0x57db, 0x9a8d,
+	0x0007, 0x6aff, 0x62d0, 0xc2d1, 0x0458, 0x0454, 0x6add, 0x7ff8,
+	0xc261, 0x9a8a, 0xc230, 0xc23a, 0x57db, 0x52f3, 0x6ad5, 0x56fb,
+	0x028e, 0x1a94, 0x5202, 0x0269, 0x7d17, 0x1e94, 0x5206, 0x0248,
+	0x5a06, 0x2694, 0x5206, 0x026e, 0x7d26, 0x6ac8, 0x7f22, 0x2501,
+	0x4d00, 0x7d27, 0x028e, 0x1a98, 0x5202, 0x0260, 0x7df3, 0x6add,
+	0x7f18, 0x62d0, 0xc2d1, 0x9b11, 0x008f, 0x2001, 0x00d5, 0x7d01,
+	0x008d, 0x05a0, 0x5206, 0x026e, 0x7d0e, 0x6ac8, 0x7f0a, 0x2001,
+	0x7cf9, 0x6add, 0x7f06, 0x0000, 0x4d00, 0x7d0b, 0xc251, 0x57db,
+	0x9ad7, 0x0007, 0x6aff, 0x6add, 0x7ffc, 0x62d0, 0xc2d1, 0x0458,
+	0x0454, 0x6add, 0x7ff6, 0xc261, 0x9ad4
+};
+#endif
Index: linux-2.6.24/arch/arm/mach-mx35/serial.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx35/serial.c	2009-01-26 18:52:00.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx35/serial.c	2009-01-26 19:07:59.000000000 +0100
@@ -26,6 +26,7 @@
 #include "serial.h"
 #include "board-mx35evb.h"
 #include "board-mx35_3stack.h"
+#include "board-mx35_fab4.h"
 
 #if defined(CONFIG_SERIAL_MXC) || defined(CONFIG_SERIAL_MXC_MODULE)
 
Index: linux-2.6.24/arch/arm/tools/mach-types
===================================================================
--- linux-2.6.24.orig/arch/arm/tools/mach-types	2009-01-26 18:52:02.000000000 +0100
+++ linux-2.6.24/arch/arm/tools/mach-types	2009-01-26 19:07:59.000000000 +0100
@@ -1642,3 +1642,4 @@ mx35evb			MACH_MX35EVB		MX35EVB			1643
 aml_m8050		MACH_AML_M8050		AML_M8050		1644
 mx35_3ds		MACH_MX35_3DS		MX35_3DS		1645
 mx51_3ds		MACH_MX51_3DS		MX51_3DS		1696
+fab4			MACH_FAB4		FAB4			1804
