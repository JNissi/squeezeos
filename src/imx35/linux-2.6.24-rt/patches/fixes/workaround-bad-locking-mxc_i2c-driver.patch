The mcx_i2c driver uses a spinlock to force an interrupt lock
in the mxc_i2c_stop() routine, but an interrupt is really really
dirty here, because it waits maximal 16 times 3 us (=48us) while
keeping the interrupts locked. On preempt-RT this can only be
achieved by using the raw-spinlock. But in fact the locking
scheme need to be reworked in this driver.

*** Besides this , the implementation is wrong by design, because
*** the spinlock is created on stack and never initialised.

Signed-off-by: Remy Bohmer <linux@bohmer.net>
---
 drivers/i2c/busses/mxc_i2c.c |   17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)

Index: linux-2.6.24/drivers/i2c/busses/mxc_i2c.c
===================================================================
--- linux-2.6.24.orig/drivers/i2c/busses/mxc_i2c.c	2009-01-25 13:16:41.000000000 +0100
+++ linux-2.6.24/drivers/i2c/busses/mxc_i2c.c	2009-01-25 13:48:26.000000000 +0100
@@ -35,6 +35,15 @@
 #include <asm/io.h>
 #include "mxc_i2c_reg.h"
 
+/*
+ * For the mxc_i2c_stop() we apparantly need a interrupt lock, but
+ * an interrupt is really really dirty here, because it waits maximal
+ * 16 times 3 us (=48us) while keeping the interrupts locked. On preempt-RT
+ * this can only be achieved by using the raw-spinlock. But in fact
+ * the locking scheme need to be reworked in this driver.
+ */
+static DEFINE_RAW_SPINLOCK(dirty_lock);
+
 /*!
  * In case the MXC device has multiple I2C modules, this structure is used to
  * store information specific to each I2C module.
@@ -124,9 +133,8 @@ static void mxc_i2c_stop(mxc_i2c_device 
 {
 	unsigned int cr, sr;
 	int retry = 16;
-	spinlock_t lock;
 
-	spin_lock(&lock);
+	spin_lock(&dirty_lock);
 	cr = readw(dev->membase + MXC_I2CR);
 	cr &= ~(MXC_I2CR_MSTA | MXC_I2CR_MTX);
 	writew(cr, dev->membase + MXC_I2CR);
@@ -137,7 +145,7 @@ static void mxc_i2c_stop(mxc_i2c_device 
 		udelay(3);
 		sr = readw(dev->membase + MXC_I2SR);
 	}
-	spin_unlock(&lock);
+	spin_unlock(&dirty_lock);
 	if (retry <= 0)
 		printk(KERN_DEBUG "Could not set I2C Bus Busy bit to zero.\n");
 
@@ -415,6 +423,7 @@ static int mxc_i2c_xfer(struct i2c_adapt
 	mxc_i2c_device *dev = (mxc_i2c_device *) (i2c_get_adapdata(adap));
 	int i, ret = 0, addr_comp = 0;
 	volatile unsigned int sr;
+	int retry;
 
 	if (dev->low_power) {
 		printk(KERN_ERR "I2C Device in low power mode\n");
@@ -431,7 +440,7 @@ static int mxc_i2c_xfer(struct i2c_adapt
 	 * Check bus state
 	 */
 
-	int retry = 5;
+	retry = 5;
 	if (sr & MXC_I2SR_IBB && retry--) {
 		udelay(5);
 		sr = readw(dev->membase + MXC_I2SR);
