---
 drivers/i2c/chips/tsl2569.c |  437 +++++++++++++++++++++++++++++++++++++++++++-
 drivers/net/fec.c           |   16 +
 2 files changed, 442 insertions(+), 11 deletions(-)

Index: linux-2.6.24/drivers/net/fec.c
===================================================================
--- linux-2.6.24.orig/drivers/net/fec.c	2009-01-31 16:16:11.000000000 +0100
+++ linux-2.6.24/drivers/net/fec.c	2009-01-31 16:16:26.000000000 +0100
@@ -268,7 +268,6 @@ static void set_multicast_list(struct ne
 static void fec_restart(struct net_device *dev, int duplex);
 static void fec_stop(struct net_device *dev);
 static void fec_set_mac_address(struct net_device *dev);
-static void mii_link_timer_callback(unsigned long data);
 
 static void __inline__ fec_dcache_inv_range(void * start, void * end);
 static void __inline__ fec_dcache_flush_range(void * start, void * end);
@@ -2163,8 +2162,6 @@ static void __inline__ fec_request_intrs
 	}
 	else {
 		fep->phy_timer_list.expires = jiffies + HZ / 2;	/* every 500ms */
-		fep->phy_timer_list.data = (unsigned long)dev;
-		fep->phy_timer_list.function = mii_link_timer_callback;
 		add_timer(&fep->phy_timer_list);
 	}
 	disable_irq(expio_intr_fec);
@@ -2187,9 +2184,14 @@ static void __inline__ fec_set_mii(struc
 	clk_put(clk);
 
 	fep->phy_speed =
-		((((rate / 2 + 4999999) / 2500000) / 2) & 0x3F) << 1;
+		(((((rate / 2) + (4999999 / 2)) / 2500000)) & 0x3F) << 1;
 	fecp->fec_mii_speed = fep->phy_speed;
-	fec_restart(dev, 0);
+
+	/* fec_restart will be called from the phy timer when the link
+	 * is detected. calling it early here causes ksoftirqd to spin
+	 * when then link is down.
+	 */
+	//fec_restart(dev, 0);
 }
 
 #define FEC_IIM_BASE    IO_ADDRESS(IIM_BASE_ADDR)
@@ -3091,6 +3093,8 @@ int __init fec_enet_init(struct net_devi
 	fecp->fec_x_des_start = __pa((uint)(fep->cbd_mem_base + RX_RING_SIZE*sizeof(cbd_t)));
 
 	init_timer(&fep->phy_timer_list);
+	fep->phy_timer_list.data = (unsigned long)dev;
+	fep->phy_timer_list.function = mii_link_timer_callback;
 
 	/* Install our interrupt handlers. This varies depending on
 	 * the architecture.
@@ -3118,6 +3122,8 @@ int __init fec_enet_init(struct net_devi
 	dev->set_multicast_list = set_multicast_list;
 	SET_ETHTOOL_OPS(dev, &fec_ethtool_ops);
 
+	netif_carrier_off(dev);  /* will be enabled in relink */
+
 	for (i=0; i<NMII-1; i++)
 		mii_cmds[i].mii_next = &mii_cmds[i+1];
 	mii_free = mii_cmds;
Index: linux-2.6.24/drivers/i2c/chips/tsl2569.c
===================================================================
--- linux-2.6.24.orig/drivers/i2c/chips/tsl2569.c	2009-01-31 16:15:52.000000000 +0100
+++ linux-2.6.24/drivers/i2c/chips/tsl2569.c	2009-01-31 16:16:29.000000000 +0100
@@ -48,7 +48,6 @@
 #define TSL2569_POWER_DOWN		0x00
 #define TSL2569_POWER_UP		0x03
 
-
 /*
  * Structs
  */
@@ -58,6 +57,9 @@ struct tsl2569_data {
 	struct mutex update_lock;
 
 	unsigned int power_state : 1;
+	unsigned int gain : 1;  // 0: 1X , 1: 16X
+	unsigned int integration : 2; // 0:13.7mS, 1:100mS, 2:402mS, 3:Manual
+	unsigned int manual_cycle_state : 1; // 0: manual cycle stopped, 1: manual cycle started
 };
 
 /*
@@ -69,9 +71,9 @@ static int tsl2569_set_power_state(struc
 	struct tsl2569_data *data = i2c_get_clientdata(client);
 	int ret;
 
-	if (state == 0)
+	if (state == 0) {
 		ret = i2c_smbus_write_byte_data(client, TSL2569_REG_CONTROL, TSL2569_POWER_UP);
-	else {
+	} else {
 		ret = i2c_smbus_write_byte_data(client, TSL2569_REG_CONTROL, TSL2569_POWER_DOWN);
 	}
 
@@ -93,9 +95,48 @@ static int tsl2569_get_adc_value(struct 
 	return ret;
 }
 
+static int tsl2569_set_timing(struct i2c_client *client)
+{
+	struct tsl2569_data *data = i2c_get_clientdata(client);
+	int ret;
+
+	u8 value;
+	value = ((data->gain & 0x01) << 4)
+		| (data->integration & 0x03);
+
+	printk("tsl2569: set timing: (%d,%d): %X\n", data->gain, data->integration, value);
+
+	ret = i2c_smbus_write_byte_data(client, TSL2569_REG_TIMING, value);
+	return ret;
+}
+
+static int tsl2569_integ_cycle(struct i2c_client *client, u8 cmd)
+{
+	struct tsl2569_data *data = i2c_get_clientdata(client);
+	int ret;
+
+	u8 value;
+	value = ((data->gain & 0x01) << 4)
+		| ((cmd & 0x01) << 3)
+		| (data->integration & 0x03);
+	printk("tsl2569: integration cycle: (%d,%d,%d): %X\n", data->gain, data->integration, cmd, value);
+
+	ret = i2c_smbus_write_byte_data(client, TSL2569_REG_TIMING, value);
+	return ret;
+}
+
+/*
+ * sysfs access functions
+ */
+
+// rjuchli: Forward Declaration for TAOS Inc. Code
+unsigned int CalculateLux(unsigned int iGain, unsigned int tInt, unsigned int ch0, unsigned int ch1, int iType);
+
 static int tsl2569_get_lux_value(struct i2c_client *client, u8 cmd)
 {
-	int lux, ch0, ch1;
+	struct tsl2569_data *data = i2c_get_clientdata(client);
+	int ch0, ch1;
+	unsigned int lux;
 
 	ch0 = tsl2569_get_adc_value(client, TSL2569_REG_ADC0);
 	if (ch0 < 0)
@@ -105,8 +146,11 @@ static int tsl2569_get_lux_value(struct 
 	if (ch1 < 0)
 		return ch1;
 
-	// FIXME calculate lux
-	lux = 0;
+	/*
+	 * Calculating the Lux Value using the current parameters
+	 * from the data structure
+	 */
+	lux = CalculateLux(data->gain, data->integration, ch0, ch1, 0);
 
 	return lux;
 }
@@ -211,10 +255,160 @@ static ssize_t tsl2569_show_lux(struct d
 static DEVICE_ATTR(lux, S_IRUGO,
 		   tsl2569_show_lux, NULL);
 
+static ssize_t tsl2569_show_gain(struct device  *dev,
+			struct device_attribute *attr, char* buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct tsl2569_data *data = i2c_get_clientdata(client);
+	int ret;
+
+	mutex_lock(&data->update_lock);
+
+	ret = sprintf(buf, "%d\n", data->gain);
+
+	mutex_unlock(&data->update_lock);
+	return ret;
+}
+
+static ssize_t tsl2569_store_gain(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct tsl2569_data *data = i2c_get_clientdata(client);
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+	int ret;
+
+	if (val < 0 || val > 1)
+		return -EINVAL;
+
+	data->gain = val;
+
+	mutex_lock(&data->update_lock);
+
+	// Update the Timing Register
+	ret = tsl2569_set_timing(client);
+	if(ret < 0)
+		return ret;
+
+	printk("Store Gain: %d\n", data->gain);
+
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+
+static DEVICE_ATTR(gain, S_IWUSR | S_IRUGO,
+		tsl2569_show_gain, tsl2569_store_gain);
+
+
+static ssize_t tsl2569_show_integration(struct device  *dev,
+			struct device_attribute *attr, char* buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct tsl2569_data *data = i2c_get_clientdata(client);
+	int ret;
+
+	mutex_lock(&data->update_lock);
+
+	ret = sprintf(buf, "%d\n", data->integration);
+
+	mutex_unlock(&data->update_lock);
+	return ret;
+}
+
+static ssize_t tsl2569_store_integration(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct tsl2569_data *data = i2c_get_clientdata(client);
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+	int ret;
+
+	if (val < 0 || val > 3)
+		return -EINVAL;
+
+	data->integration = val;
+
+	mutex_lock(&data->update_lock);
+
+	// Update the Timing Register
+	ret = tsl2569_set_timing(client);
+	if(ret < 0)
+		return ret;
+
+	printk("Store Integration: %d\n", data->integration);
+
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(integration, S_IWUSR | S_IRUGO,
+		tsl2569_show_integration, tsl2569_store_integration);
+
+static ssize_t tsl2569_show_integ_cycle(struct device  *dev,
+			struct device_attribute *attr, char* buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct tsl2569_data *data = i2c_get_clientdata(client);
+	int ret;
+
+	mutex_lock(&data->update_lock);
+
+	ret = sprintf(buf, "%d\n", data->manual_cycle_state);
+
+	mutex_unlock(&data->update_lock);
+	return ret;
+}
+
+static ssize_t tsl2569_store_integ_cycle(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct tsl2569_data *data = i2c_get_clientdata(client);
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+	int ret;
+
+	if (val < 0 || val > 1)
+		return -EINVAL;
+
+	mutex_lock(&data->update_lock);
+
+	if ( data->integration != 3 ) {
+		// Integration not set to manual
+		return -EINVAL;
+	}
+
+	// does this change the state?
+	if(val != data->manual_cycle_state) {
+
+		data->manual_cycle_state = val;
+
+		// Update the Timing Register
+		ret = tsl2569_integ_cycle(client, val);
+		if(ret < 0)
+			return ret;
+
+		printk("Manual Cycle: %d\n", data->manual_cycle_state);
+	}
+
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(manual_cycle_state, S_IWUSR | S_IRUGO,
+		tsl2569_show_integ_cycle, tsl2569_store_integ_cycle);
+
+
 static struct attribute *tsl2569_attributes[] = {
 	&dev_attr_power_state.attr,
 	&dev_attr_adc.attr,
 	&dev_attr_lux.attr,
+	&dev_attr_gain.attr,
+	&dev_attr_integration.attr,
+	&dev_attr_manual_cycle_state.attr,
 	NULL
 };
 
@@ -246,6 +440,10 @@ static int tsl2569_init_client(struct i2
 
 	data->power_state = 1;
 
+	/* Initialize Gain / Integration time with default values */
+	data->gain = 0; // 1X gain is default
+	data->integration = 2; // 402ms is default
+
 	return 0;
 }
 
@@ -333,3 +531,230 @@ MODULE_VERSION(DRIVER_VERSION);
 
 module_init(tsl2569_init);
 module_exit(tsl2569_exit);
+
+// ======================================================================
+// Lux Calculation Code follows taken directly out of the
+// specifications by TAOS, Inc.
+// - rjuchli
+// ======================================================================
+
+//****************************************************************************
+//
+// Copyright 2004-2008 TAOS, Inc.
+//
+// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
+// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
+// PURPOSE.
+//
+// Module Name:
+// lux.cpp
+//
+//****************************************************************************
+
+#define LUX_SCALE 16 // scale by 2^16
+#define RATIO_SCALE 9 // scale ratio by 2^9
+
+//---------------------------------------------------
+// Integration time scaling factors
+//---------------------------------------------------
+
+#define CH_SCALE 10 // scale channel values by 2^10
+#define CHSCALE_TINT0 0x7517 // 322/11 * 2^CH_SCALE
+#define CHSCALE_TINT1 0x0fe7 // 322/81 * 2^CH_SCALE
+
+//---------------------------------------------------
+// T Package coefficients
+//---------------------------------------------------
+// For Ch1/Ch0=0.00 to 0.35:
+// Lux=0.00763*Ch0-0.01031*Ch1
+//
+// For Ch1/Ch0=0.35 to 0.50:
+// Lux=0.00817*Ch0-0.01188*Ch1
+//
+// For Ch1/Ch0=0.50 to 0.60:
+// Lux=0.00723*Ch0-0.01000*Ch1
+//
+// For Ch1/Ch0=0.60 to 0.72:
+// Lux=0.00573*Ch0-0.00750*Ch1
+//
+// For Ch1/Ch0=0.72 to 0.85:
+// Lux=0.00216*Ch0-0.00254*Ch1
+//
+// For Ch1/Ch0>0.85:
+// Lux/Ch0=0
+//
+//--------------------------------------------------
+
+#define K1T 0x00b3 // 0.35 * 2^RATIO_SCALE
+#define B1T 0x01f4 // 0.00763 * 2^LUX_SCALE
+#define M1T 0x02a4 // 0.01031 * 2^LUX_SCALE
+
+#define K2T 0x0100 // 0.50 * 2^RATIO_SCALE
+#define B2T 0x0217 // 0.00817 * 2^LUX_SCALE
+#define M2T 0x030a // 0.01188 * 2^LUX_SCALE
+
+#define K3T 0x0133 // 0.60 * 2^RATIO_SCALE
+#define B3T 0x01da // 0.00723 * 2^LUX_SCALE
+#define M3T 0x028f // 0.01000 * 2^LUX_SCALE
+
+#define K4T 0x0171 // 0.72 * 2^RATIO_SCALE
+#define B4T 0x0177 // 0.00573 * 2^LUX_SCALE
+#define M4T 0x01ec // 0.00750 * 2^LUX_SCALE
+
+#define K5T 0x01b3 // 0.85 * 2^RATIO_SCALE
+#define B5T 0x008d // 0.00216 * 2^LUX_SCALE
+#define M5T 0x00a6 // 0.00254 * 2^LUX_SCALE
+
+#define K6T 0x01b3 // 0.85 * 2^RATIO_SCALE
+#define B6T 0x0000 // 0.00000 * 2^LUX_SCALE
+#define M6T 0x0000 // 0.00000 * 2^LUX_SCALE
+
+
+//---------------------------------------------------
+// CS Package coefficients
+//---------------------------------------------------
+// For Ch1/Ch0=0.00 to 0.35:
+// Lux=0.00713*Ch0-0.00975*Ch1
+//
+// For Ch1/Ch0=0.35 to 0.45:
+// Lux=0.00813*Ch0-0.01250*Ch1
+//
+// For Ch1/Ch0=0.45 to 0.52:
+// Lux=0.00935*Ch0-0.01521*Ch1
+//
+// For Ch1/Ch0=0.52 to 0.67:
+// Lux=0.00394*Ch0-0.00482*Ch1
+//
+// For Ch1/Ch0=0.67 to 0.85:
+// Lux=0.00337*Ch0-0.00396*Ch1
+//
+// For Ch1/Ch0>0.85:
+// Lux/Ch0=0
+//
+//-------------------------------------------------
+#define K1C 0x00b3 // 0.35 * 2^RATIO_SCALE
+#define B1C 0x01d3 // 0.00713 * 2^LUX_SCALE
+#define M1C 0x027f // 0.00975 * 2^LUX_SCALE
+
+#define K2C 0x00e6 // 0.45 * 2^RATIO_SCALE
+#define B2C 0x0214 // 0.00813 * 2^LUX_SCALE
+#define M2C 0x0333 // 0.01250 * 2^LUX_SCALE
+
+#define K3C 0x010a // 0.52 * 2^RATIO_SCALE
+#define B3C 0x0265 // 0.00935 * 2^LUX_SCALE
+#define M3C 0x03e5 // 0.01521 * 2^LUX_SCALE
+
+#define K4C 0x0157 // 0.67 * 2^RATIO_SCALE
+#define B4C 0x0102 // 0.00394 * 2^LUX_SCALE
+#define M4C 0x013c // 0.00482 * 2^LUX_SCALE
+
+#define K5C 0x01b3 // 0.85 * 2^RATIO_SCALE
+#define B5C 0x00dd // 0.00337 * 2^LUX_SCALE
+#define M5C 0x0104 // 0.00396 * 2^LUX_SCALE
+
+#define K6C 0x01b3 // 0.85 * 2^RATIO_SCALE
+#define B6C 0x0000 // 0.00000 * 2^LUX_SCALE
+#define M6C 0x0000 // 0.00000 * 2^LUX_SCALE
+
+
+// lux equation approximation without floating point calculations
+//////////////////////////////////////////////////////////////////////////////
+// Routine: unsigned int CalculateLux(unsigned int ch0, unsigned int ch0, int iType)
+//
+// Description: Calculate the approximate illuminance (lux) given the raw
+// channel values of the TSL2568. The equation if implemented
+// as a piece-wise linear approximation.
+//
+// Arguments: unsigned int iGain - gain, where 0:1X, 1:16X
+// unsigned int tInt - integration time, where 0:13.7mS, 1:100mS, 2:402mS,
+// 3:Manual
+// unsigned int ch0 - raw channel value from channel 0 of TSL2568
+// unsigned int ch1 - raw channel value from channel 1 of TSL2568
+// unsigned int iType - package type (0:T, 1:CS)
+//
+// Return: unsigned int - the approximate illuminance (lux)
+//
+//////////////////////////////////////////////////////////////////////////////
+unsigned int CalculateLux(unsigned int iGain, unsigned int tInt, unsigned int ch0, unsigned int ch1, int iType)
+{
+	//------------------------------------------------------------------------
+	// first, scale the channel values depending on the gain and integration time
+	// 16X, 402mS is nominal.
+	// scale if integration time is NOT 402 msec
+	unsigned long chScale;
+	unsigned long channel1;
+	unsigned long channel0;
+	switch (tInt)
+	{
+		case 0: // 13.7 msec
+			chScale = CHSCALE_TINT0;
+			break;
+		case 1: // 101 msec
+			chScale = CHSCALE_TINT1;
+			break;
+		default: // assume no scaling
+			chScale = (1 << CH_SCALE);
+			break;
+	}
+	// scale if gain is NOT 16X
+	if (!iGain) chScale = chScale << 4; // scale 1X to 16X
+
+	// scale the channel values
+	channel0 = (ch0 * chScale) >> CH_SCALE;
+	channel1 = (ch1 * chScale) >> CH_SCALE;
+	//-----------------------------------------------------------------
+
+	// find the ratio of the channel values (Channel1/Channel0)
+	// protect against divide by zero
+	unsigned long ratio1 = 0;
+	if (channel0 != 0) ratio1 = (channel1 << (RATIO_SCALE+1)) / channel0;
+	// round the ratio value
+	unsigned long ratio = (ratio1 + 1) >> 1;
+
+	// is ratio <= eachBreak ?
+	unsigned int b, m;
+	switch (iType)
+	{
+		case 0: // T package
+			if ((ratio >= 0) && (ratio <= K1T))
+				{b=B1T; m=M1T;}
+			else if (ratio <= K2T)
+				{b=B2T; m=M2T;}
+			else if (ratio <= K3T)
+				{b=B3T; m=M3T;}
+			else if (ratio <= K4T)
+				{b=B4T; m=M4T;}
+			else if (ratio <= K5T)
+				{b=B5T; m=M5T;}
+			else if (ratio > K6T)
+				{b=B6T; m=M6T;}
+			break;
+		case 1: // CS package
+			if ((ratio >= 0) && (ratio <= K1C))
+				{b=B1C; m=M1C;}
+			else if (ratio <= K2C)
+				{b=B2C; m=M2C;}
+			else if (ratio <= K3C)
+				{b=B3C; m=M3C;}
+			else if (ratio <= K4C)
+				{b=B4C; m=M4C;}
+			else if (ratio <= K5C)
+				{b=B5C; m=M5C;}
+			else if (ratio > K6C)
+				{b=B6C; m=M6C;}
+			break;
+	}
+
+	unsigned long temp;
+	unsigned long lux;
+	temp = ((channel0 * b) - (channel1 * m));
+
+	// scale CS or T package
+	// round lsb (2^(LUX_SCALE-1))
+	temp += (1 << (LUX_SCALE-1));
+	// strip off fractional portion
+	lux = temp >> LUX_SCALE;
+	return(lux);
+}
+
