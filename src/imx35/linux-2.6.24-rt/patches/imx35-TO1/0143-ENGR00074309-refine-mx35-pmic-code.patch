From 4fb28e94db95748ba8c7f5104772ecdfc747f1b3 Mon Sep 17 00:00:00 2001
From: Jingyu Zhou <b02241@freescale.com>
Date: Fri, 25 Apr 2008 16:28:18 +0800
Subject: [PATCH] ENGR00074309 refine mx35 pmic code

Refine mx35 pmic code

Signed-off-by: Zhou Jingyu <Jingyu.Zhou@freescale.com>
---
 drivers/mxc/pmic/core/max8660.c            |   17 -
 drivers/mxc/pmic/core/mc9sdz60.c           |   14 -
 drivers/mxc/pmic/core/mcu_pmic_core.c      |   96 ------
 drivers/mxc/pmic/mc9sdz60/Makefile         |    2 -
 drivers/mxc/pmic/mc9sdz60/mcu_pmic_power.c |  465 ----------------------------
 drivers/mxc/pmic/mc9sdz60/mcu_pmic_rtc.c   |   35 +--
 drivers/regulator/max8660/reg-max8660.c    |   19 --
 7 files changed, 4 insertions(+), 644 deletions(-)

diff --git a/drivers/mxc/pmic/core/max8660.c b/drivers/mxc/pmic/core/max8660.c
index 5214739..6f5cf3b 100644
--- a/drivers/mxc/pmic/core/max8660.c
+++ b/drivers/mxc/pmic/core/max8660.c
@@ -34,13 +34,6 @@
 #define I2C1_BUS	0
 #define MAX8660_I2C_ADDR				0x68
 
-#define DEBUG_MAX8660 1
-#if DEBUG_MAX8660
-#define DPRINTK(format, args...) printk(KERN_ERR "max8660"format"\n", ##args)
-#else
-#define DPRINTK(format, args...)
-#endif
-
 static struct i2c_client *max8660_i2c_client;
 
     /* reg names for max8660
@@ -67,7 +60,6 @@ int max8660_get_buffered_reg_val(int reg_name, u8 *value)
 	/* outof range */
 	if (reg_name < REG_MAX8660_OUTPUT_ENABLE_1
 	    || reg_name > REG_MAX8660_FORCE_PWM) {
-		DPRINTK("reg_name=%d outof range", reg_name);
 		return -1;
 	}
 	*value =
@@ -80,7 +72,6 @@ int max8660_save_buffered_reg_val(int reg_name, u8 value)
 	/* outof range */
 	if (reg_name < REG_MAX8660_OUTPUT_ENABLE_1
 	    || reg_name > REG_MAX8660_FORCE_PWM) {
-		DPRINTK("reg_name=%d outof range", reg_name);
 		return -1;
 	}
 	max8660_reg_value_table[reg_name - REG_MAX8660_OUTPUT_ENABLE_1] = value;
@@ -89,10 +80,7 @@ int max8660_save_buffered_reg_val(int reg_name, u8 value)
 
 int max8660_write_reg(u8 reg, u8 value)
 {
-	DPRINTK("max8660_i2c_client = %p", max8660_i2c_client);
 	if (i2c_smbus_write_byte_data(max8660_i2c_client, reg, value) < 0) {
-		printk(KERN_ERR "%s:write reg errorr:reg=%x,val=%x\n",
-		       __func__, reg, value);
 		return -1;
 	}
 	return 0;
@@ -107,7 +95,6 @@ int max8660_write_reg(u8 reg, u8 value)
 static int max8660_probe(struct i2c_client *client)
 {
 	max8660_i2c_client = client;
-	DPRINTK("max8660_i2c_client = %p", max8660_i2c_client);
 	return 0;
 }
 
@@ -133,14 +120,10 @@ static struct i2c_driver max8660_i2c_driver = {
 int max8660_init(void)
 {
 	int err;
-	DPRINTK("Freescale max8660 driver loaded\n");
 	err = i2c_add_driver(&max8660_i2c_driver);
 	if (err) {
-		printk(KERN_ERR
-		       "max8660: driver registration failed err = %d\n", err);
 		return err;
 	}
-	DPRINTK("max8660 inited\n");
 	return 0;
 }
 void max8660_exit(void)
diff --git a/drivers/mxc/pmic/core/mc9sdz60.c b/drivers/mxc/pmic/core/mc9sdz60.c
index e367cb5..ee8c3e9 100644
--- a/drivers/mxc/pmic/core/mc9sdz60.c
+++ b/drivers/mxc/pmic/core/mc9sdz60.c
@@ -35,13 +35,6 @@
 #define MC9SDZ60_I2C_ADDR	0xD2	/* 7bits I2C address */
 static struct i2c_client *mc9sdz60_i2c_client;
 
-#define DEBUG_MC9SDZ60 1
-#if DEBUG_MC9SDZ60
-#define DPRINTK(format, args...) printk(KERN_ERR "mc9sdz60: "format"\n", ##args)
-#else
-#define DPRINTK(format, args...)
-#endif
-
 int mc9sdz60_read_reg(u8 reg, u8 *value)
 {
 	*value = (u8) i2c_smbus_read_byte_data(mc9sdz60_i2c_client, reg);
@@ -51,8 +44,6 @@ int mc9sdz60_read_reg(u8 reg, u8 *value)
 int mc9sdz60_write_reg(u8 reg, u8 value)
 {
 	if (i2c_smbus_write_byte_data(mc9sdz60_i2c_client, reg, value) < 0) {
-		printk(KERN_ERR "%s:write reg errorr:reg=%x,val=%x\n",
-		       __func__, reg, value);
 		return -1;
 	}
 	return 0;
@@ -67,7 +58,6 @@ int mc9sdz60_write_reg(u8 reg, u8 value)
 static int mc9sdz60_probe(struct i2c_client *client)
 {
 	mc9sdz60_i2c_client = client;
-	DPRINTK("mc9sdz60_i2c_client = %p", mc9sdz60_i2c_client);
 	return 0;
 }
 
@@ -95,14 +85,10 @@ static struct i2c_driver mc9sdz60_i2c_driver = {
 int mc9sdz60_init(void)
 {
 	int err;
-	DPRINTK("Freescale mc9sdz60 driver,\
-	     (c) 2008 Freescale Semiconductor, Inc.\n");
 	err = i2c_add_driver(&mc9sdz60_i2c_driver);
 	if (err) {
-		printk(KERN_ERR "mc9sdz60: driver registration failed\n");
 		return err;
 	}
-	DPRINTK("mc9sdz60 inited\n");
 	return 0;
 }
 void mc9sdz60_exit(void)
diff --git a/drivers/mxc/pmic/core/mcu_pmic_core.c b/drivers/mxc/pmic/core/mcu_pmic_core.c
index 7c7d698..228d8db 100644
--- a/drivers/mxc/pmic/core/mcu_pmic_core.c
+++ b/drivers/mxc/pmic/core/mcu_pmic_core.c
@@ -32,8 +32,6 @@
 #include <asm/uaccess.h>
 #include <asm/arch/gpio.h>
 
-#include <../arch/arm/mach-mx3/iomux.h>
-
 #include <asm/arch/pmic_status.h>
 #include <asm/arch/pmic_external.h>
 #include "pmic.h"
@@ -116,8 +114,6 @@ const static u8 mcu_pmic_reg_addr_table[] = {
 	MAX8660_FORCE_PWM
 };
 
-#define DPRINTK(format, args...) printk(KERN_ERR "pmic-core "format"\n", ##args)
-
 int pmic_read(int reg_num, unsigned int *reg_val)
 {
 	int ret;
@@ -137,7 +133,6 @@ int pmic_read(int reg_num, unsigned int *reg_val)
 			goto error1;
 		*reg_val = value;
 	} else {
-		DPRINTK("reg_num=%d out of range", reg_num);
 		goto error1;
 	}
 
@@ -168,62 +163,16 @@ int pmic_write(int reg_num, const unsigned int reg_val)
 
 		ret = max8660_save_buffered_reg_val(reg_num, value);
 	} else {
-		DPRINTK("reg_num=%d out of range", reg_num);
 		goto error1;
 	}
 
 	return 0;
 
       error1:
-	DPRINTK(" reg_num = %d, write failed", reg_num);
 	return -1;
 
 }
 
-/* for debug*/
-void dump_pmic_reg(void)
-{
-#define REG_DUMP(reg) do {\
-		pmic_read_reg(reg, &reg_val, 0xff);\
-		DPRINTK("%s = %x", #reg, reg_val); } while (0)
-	unsigned int reg_val;
-
-	REG_DUMP(REG_MCU_VERSION);
-	REG_DUMP(REG_MCU_SECS);
-	REG_DUMP(REG_MCU_MINS);
-	REG_DUMP(REG_MCU_HRS);
-	REG_DUMP(REG_MCU_DAY);
-	REG_DUMP(REG_MCU_DATE);
-	REG_DUMP(REG_MCU_MONTH);
-	REG_DUMP(REG_MCU_YEAR);
-	REG_DUMP(REG_MCU_ALARM_SECS);
-	REG_DUMP(REG_MCU_ALARM_MINS);
-	REG_DUMP(REG_MCU_ALARM_HRS);
-	REG_DUMP(REG_MCU_TS_CONTROL);
-	REG_DUMP(REG_MCU_X_LOW);
-	REG_DUMP(REG_MCU_Y_LOW);
-	REG_DUMP(REG_MCU_XY_HIGH);
-	REG_DUMP(REG_MCU_X_LEFT_LOW);
-	REG_DUMP(REG_MCU_X_LEFT_HIGH);
-	REG_DUMP(REG_MCU_X_RIGHT);
-	REG_DUMP(REG_MCU_Y_TOP_LOW);
-	REG_DUMP(REG_MCU_Y_TOP_HIGH);
-	REG_DUMP(REG_MCU_Y_BOTTOM);
-	REG_DUMP(REG_MCU_RESET_1);
-	REG_DUMP(REG_MCU_RESET_2);
-	REG_DUMP(REG_MCU_POWER_CTL);
-	REG_DUMP(REG_MCU_DELAY_CONFIG);
-	REG_DUMP(REG_MCU_GPIO_1);
-	REG_DUMP(REG_MCU_GPIO_2);
-	REG_DUMP(REG_MCU_KPD_1);
-	REG_DUMP(REG_MCU_KPD_2);
-	REG_DUMP(REG_MCU_KPD_CONTROL);
-	REG_DUMP(REG_MCU_INT_ENABLE_1);
-	REG_DUMP(REG_MCU_INT_ENABLE_2);
-	REG_DUMP(REG_MCU_INT_FLAG_1);
-	REG_DUMP(REG_MCU_INT_FLAG_2);
-}
-
 /*!
  * This function unsets a bit in mask register of pmic to unmask an event IT.
  *
@@ -389,7 +338,6 @@ unsigned int pmic_get_active_events(unsigned int *active_events)
 	pmic_read(REG_MCU_INT_FLAG_2, &flag2);
 	pmic_write(REG_MCU_INT_FLAG_1, 0);
 	pmic_write(REG_MCU_INT_FLAG_2, 0);
-	DPRINTK("pmic interrupt flag1=%x, flag2=%x", flag1, flag2);
 
 	flag1 &= events_enabled1;
 	flag2 &= events_enabled2;
@@ -410,8 +358,6 @@ unsigned int pmic_get_active_events(unsigned int *active_events)
 	return count;
 }
 
-void pmic_bh_handler(struct work_struct *work);
-
 /*
  * External functions
  */
@@ -420,11 +366,6 @@ extern void pmic_event_callback(type_event event);
 extern void gpio_pmic_active(void);
 
 /*!
- * Bottom half handler of PMIC event handling.
- */
-DECLARE_WORK(pmic_ws, pmic_bh_handler);
-
-/*!
  * This function registers platform device structures for
  * PMIC client drivers.
  */
@@ -445,39 +386,6 @@ static void pmic_pdev_unregister(void)
 }
 
 /*!
- * This function is called when pmic interrupt occurs on the processor.
- * It is the interrupt handler for the pmic module.
- *
- * @param        irq        the irq number
- * @param        dev_id     the pointer on the device
- *
- * @return       The function returns IRQ_HANDLED when handled.
- */
-static irqreturn_t pmic_irq_handler(int irq, void *dev_id)
-{
-	/* prepare a task */
-	schedule_work(&pmic_ws);
-
-	return IRQ_HANDLED;
-}
-
-/*!
- * This function is the bottom half handler of the PMIC interrupt.
- * It checks for active events and launches callback for the
- * active events.
- */
-void pmic_bh_handler(struct work_struct *work)
-{
-	unsigned int loop;
-	unsigned int count = 0;
-
-	count = pmic_get_active_events(active_events);
-
-	for (loop = 0; loop < count; loop++)
-		pmic_event_callback(active_events[loop]);
-}
-
-/*!
  * This function is used to determine the PMIC type and its revision.
  *
  * @return      Returns the PMIC type and its revision.
@@ -502,10 +410,6 @@ static int __init mcu_pmic_init(void)
 	if (err)
 		goto fail1;
 
-	/* Initialize the PMIC event handling */
-	pmic_event_list_init();
-
-	/* Set and install PMIC IRQ handler */
 	pmic_pdev_register();
 
 	return 0;
diff --git a/drivers/mxc/pmic/mc9sdz60/Makefile b/drivers/mxc/pmic/mc9sdz60/Makefile
index ab25226..1b5c5b9 100644
--- a/drivers/mxc/pmic/mc9sdz60/Makefile
+++ b/drivers/mxc/pmic/mc9sdz60/Makefile
@@ -5,8 +5,6 @@
 obj-y += mcu_pmic_gpio.o
 obj-$(CONFIG_MXC_MC9SDZ60_ADC) += pmic_adc-mod.o
 obj-$(CONFIG_MXC_MC9SDZ60_RTC) += pmic_rtc-mod.o
-#obj-$(CONFIG_MXC_MC9SDZ60_POWER) += pmic_power-mod.o
 pmic_adc-mod-objs := mcu_pmic_adc.o
 pmic_rtc-mod-objs := mcu_pmic_rtc.o
-#pmic_power-mod-objs := mcu_pmic_power.o
 
diff --git a/drivers/mxc/pmic/mc9sdz60/mcu_pmic_power.c b/drivers/mxc/pmic/mc9sdz60/mcu_pmic_power.c
deleted file mode 100644
index 6072eb9..0000000
--- a/drivers/mxc/pmic/mc9sdz60/mcu_pmic_power.c
+++ /dev/null
@@ -1,465 +0,0 @@
-/*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-/*!
- * @file mc9sdz60/mcu_pmic_power.c
- * @brief This is the main file of mc9sdz60 Power Control driver.
- * @This driver is deprecated, replaced by Wolfson regulator architecture
- * @ingroup PMIC_POWER
- */
-
-/*
- * Includes
- */
-#include <linux/platform_device.h>
-#include <asm/ioctl.h>
-#include <asm/arch/pmic_status.h>
-#include <asm/arch/pmic_external.h>
-#include <asm/arch/pmic_power.h>
-#include "../core/pmic_config.h"
-
-/*
- * PMIC Power Control API
- */
-
-
-/*!
- * This is the suspend of power management for Power Control
- * API module.
- *
- * @param   pdev  the device structure used to give information on which power
- *                device (0 through 3 channels) to suspend
- * @param   state the power state the device is entering
- *
- * @return  The function always returns 0.
- */
-static int pmic_power_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	return 0;
-};
-
-/*!
- * This is the resume of power management API.
- * It suports RESTORE state.
- *
- * @param   pdev  the device structure used to give information on which power
- *                device (0 through 3 channels) to suspend
- *
- * @return  The function always returns 0.
- */
-static int pmic_power_resume(struct platform_device *pdev)
-{
-	return 0;
-};
-
-/*!
- * This function sets user power off in power control register and thus powers
- * off the phone.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_power_off(void)
-{
-#define POWER_OFF_DELAY_MS 200
-	u8 mask = 0;
-	CHECK_ERROR(pmic_write_reg
-		    (REG_MCU_DELAY_CONFIG, POWER_OFF_DELAY_MS, 0xff));
-	SET_BIT_IN_BYTE(mask, 4);
-	CHECK_ERROR(pmic_write_reg(REG_MCU_POWER_CTL, mask, mask));
-
-	return PMIC_SUCCESS;
-}
-EXPORT_SYMBOL(pmic_power_off);
-
-/*!
- * This function turns on a regulator.
- *
- * @param        regulator    The regulator to be truned on.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_power_regulator_on(t_pmic_regulator regulator)
-{
-	u8 reg_mask = 0;
-	int reg_num;
-
-	if (regulator > MCU_LDO7 || regulator < MCU_SW1)
-		return PMIC_NOT_SUPPORTED;
-
-	switch (regulator) {
-	case MCU_SW1:
-		SET_BIT_IN_BYTE(reg_mask, 0);
-		reg_num = REG_MCU_POWER_CTL;
-		break;
-	case MCU_SW2:
-		SET_BIT_IN_BYTE(reg_mask, 1);
-		reg_num = REG_MCU_POWER_CTL;
-		break;
-	case MCU_SW3:
-		SET_BIT_IN_BYTE(reg_mask, 0);
-		reg_num = REG_MAX8660_OUTPUT_ENABLE_1;
-		break;
-	case MCU_SW4:
-		SET_BIT_IN_BYTE(reg_mask, 2);
-		reg_num = REG_MAX8660_OUTPUT_ENABLE_1;
-		break;
-	case MCU_LDO5:
-		SET_BIT_IN_BYTE(reg_mask, 3);
-		reg_num = REG_MCU_POWER_CTL;
-		break;
-	case MCU_LDO6:
-		SET_BIT_IN_BYTE(reg_mask, 1);
-		reg_num = REG_MAX8660_OUTPUT_ENABLE_2;
-		break;
-	case MCU_LDO7:
-		SET_BIT_IN_BYTE(reg_mask, 2);
-		reg_num = REG_MAX8660_OUTPUT_ENABLE_2;
-		break;
-
-	default:
-		return PMIC_PARAMETER_ERROR;
-	}
-
-	CHECK_ERROR(pmic_write_reg(reg_num, reg_mask, reg_mask));
-
-	return PMIC_SUCCESS;
-}
-EXPORT_SYMBOL(pmic_power_regulator_on);
-
-/*!
- * This function turns off a regulator.
- *
- * @param        regulator    The regulator to be truned off.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_power_regulator_off(t_pmic_regulator regulator)
-{
-	u8 reg_mask = 0;
-	unsigned int reg_read = 0;
-	int reg_num;
-
-	if (regulator > MCU_LDO7 || regulator < MCU_SW1)
-		return PMIC_NOT_SUPPORTED;
-
-	switch (regulator) {
-	case MCU_SW1:
-		SET_BIT_IN_BYTE(reg_mask, 0);
-		reg_num = REG_MCU_POWER_CTL;
-		break;
-	case MCU_SW2:
-		SET_BIT_IN_BYTE(reg_mask, 1);
-		reg_num = REG_MCU_POWER_CTL;
-		break;
-	case MCU_SW3:
-		SET_BIT_IN_BYTE(reg_mask, 0);
-		reg_num = REG_MAX8660_OUTPUT_ENABLE_1;
-		break;
-	case MCU_SW4:
-		SET_BIT_IN_BYTE(reg_mask, 2);
-		reg_num = REG_MAX8660_OUTPUT_ENABLE_1;
-		break;
-	case MCU_LDO5:
-		SET_BIT_IN_BYTE(reg_mask, 3);
-		reg_num = REG_MCU_POWER_CTL;
-		break;
-	case MCU_LDO6:
-		SET_BIT_IN_BYTE(reg_mask, 1);
-		reg_num = REG_MAX8660_OUTPUT_ENABLE_2;
-		break;
-	case MCU_LDO7:
-		SET_BIT_IN_BYTE(reg_mask, 2);
-		reg_num = REG_MAX8660_OUTPUT_ENABLE_2;
-		break;
-
-	default:
-		return PMIC_PARAMETER_ERROR;
-	}
-
-	CHECK_ERROR(pmic_write_reg(reg_num, 0, reg_mask));
-
-	/* handle sw3,4 */
-	switch (regulator) {
-	case MCU_SW3:
-		reg_mask = 0;
-		SET_BIT_IN_BYTE(reg_mask, 2);
-		CHECK_ERROR(pmic_read_reg
-			    (REG_MCU_POWER_CTL, &reg_read, reg_mask));
-
-		/* check if hw pin enable sw34 */
-		if (0 != reg_read) {
-
-			/* keep sw4 on */
-			reg_mask = 0;
-			SET_BIT_IN_BYTE(reg_mask, 2);
-			CHECK_ERROR(pmic_write_reg
-				    (REG_MAX8660_OUTPUT_ENABLE_1, reg_mask,
-				     reg_mask));
-
-			/* disable hw pin to actually turn off sw3 */
-			reg_mask = 0;
-			SET_BIT_IN_BYTE(reg_mask, 2);
-			CHECK_ERROR(pmic_write_reg
-				    (REG_MCU_POWER_CTL, 0, reg_mask));
-		}
-		break;
-	case MCU_SW4:
-		reg_mask = 0;
-		SET_BIT_IN_BYTE(reg_mask, 2);
-		CHECK_ERROR(pmic_read_reg
-			    (REG_MCU_POWER_CTL, &reg_read, reg_mask));
-
-		/* check if hw pin enable sw34 */
-		if (0 != reg_read) {
-
-			/* keep sw3 on */
-			reg_mask = 0;
-			SET_BIT_IN_BYTE(reg_mask, 0);
-			CHECK_ERROR(pmic_write_reg
-				    (REG_MAX8660_OUTPUT_ENABLE_1, reg_mask,
-				     reg_mask));
-
-			/* disable hw pin to actually turn off sw4 */
-			reg_mask = 0;
-			SET_BIT_IN_BYTE(reg_mask, 2);
-			CHECK_ERROR(pmic_write_reg
-				    (REG_MCU_POWER_CTL, 0, reg_mask));
-		}
-		break;
-	default:
-		break;
-	}
-	return PMIC_SUCCESS;
-}
-EXPORT_SYMBOL(pmic_power_regulator_off);
-
-/*!
- * This function sets the regulator output voltage.
- *
- * @param        regulator    The regulator to be truned off.
- * @param        voltage      The regulator output voltage.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_power_regulator_set_voltage(t_pmic_regulator regulator,
-					     t_regulator_voltage voltage)
-{
-	u8 reg_mask = 0;
-
-	if (regulator > MCU_LDO7 || regulator < MCU_SW3)
-		return PMIC_NOT_SUPPORTED;
-
-	switch (regulator) {
-	case MCU_SW3:
-		if ((voltage.mcu_sw34 < MCU_SW34_0_725V)
-		    || voltage.mcu_sw34 > MCU_SW34_1_8V)
-			return PMIC_PARAMETER_ERROR;
-
-		/* hold on */
-		SET_BIT_IN_BYTE(reg_mask, 0);
-		CHECK_ERROR(pmic_write_reg
-			    (REG_MAX8660_VOLT_CHANGE_CONTROL_1, 0, reg_mask));
-
-		/* set volt */
-		CHECK_ERROR(pmic_write_reg
-			    (REG_MAX8660_V3_TARGET_VOLT_1, voltage.mcu_sw34,
-			     0xff));
-
-		/* start ramp */
-		SET_BIT_IN_BYTE(reg_mask, 0);
-		CHECK_ERROR(pmic_write_reg
-			    (REG_MAX8660_VOLT_CHANGE_CONTROL_1, reg_mask,
-			     reg_mask));
-		break;
-	case MCU_SW4:
-		if ((voltage.mcu_sw34 < MCU_SW34_0_725V)
-		    || voltage.mcu_sw34 > MCU_SW34_1_8V)
-			return PMIC_PARAMETER_ERROR;
-
-		/* hold on */
-		SET_BIT_IN_BYTE(reg_mask, 4);
-		CHECK_ERROR(pmic_write_reg
-			    (REG_MAX8660_VOLT_CHANGE_CONTROL_1, 0, reg_mask));
-
-		/* set volt */
-		CHECK_ERROR(pmic_write_reg
-			    (REG_MAX8660_V4_TARGET_VOLT_1, voltage.mcu_sw34,
-			     0xff));
-
-		/* start ramp */
-		SET_BIT_IN_BYTE(reg_mask, 4);
-		CHECK_ERROR(pmic_write_reg
-			    (REG_MAX8660_VOLT_CHANGE_CONTROL_1, reg_mask,
-			     reg_mask));
-		break;
-	case MCU_LDO5:
-		if (voltage.mcu_ldo5 < MCU_LDO5_1_725V
-		    || voltage.mcu_ldo5 > MCU_LDO5_2_0V)
-			return PMIC_PARAMETER_ERROR;
-
-		/* hold on */
-		SET_BIT_IN_BYTE(reg_mask, 6);
-		CHECK_ERROR(pmic_write_reg
-			    (REG_MAX8660_VOLT_CHANGE_CONTROL_1, 0, reg_mask));
-
-		/* set volt */
-		CHECK_ERROR(pmic_write_reg
-			    (REG_MAX8660_V5_TARGET_VOLT_1, voltage.mcu_ldo5,
-			     0xff));
-
-		/* start ramp */
-		SET_BIT_IN_BYTE(reg_mask, 6);
-		CHECK_ERROR(pmic_write_reg
-			    (REG_MAX8660_VOLT_CHANGE_CONTROL_1, reg_mask,
-			     reg_mask));
-		break;
-
-		break;
-	case MCU_LDO6:
-		if (voltage.mcu_ldo67 < MCU_LDO67_1_8V
-		    || voltage.mcu_ldo67 > MCU_LDO67_3_3V)
-			return PMIC_PARAMETER_ERROR;
-
-		/* set volt */
-		CHECK_ERROR(pmic_write_reg
-			    (REG_MAX8660_V6V7_TARGET_VOLT, voltage.mcu_ldo67,
-			     0x0f));
-
-		break;
-	case MCU_LDO7:
-		if (voltage.mcu_ldo67 < MCU_LDO67_1_8V
-		    || voltage.mcu_ldo67 > MCU_LDO67_3_3V)
-			return PMIC_PARAMETER_ERROR;
-		break;
-
-		/* set volt */
-		CHECK_ERROR(pmic_write_reg
-			    (REG_MAX8660_V6V7_TARGET_VOLT,
-			     (voltage.mcu_ldo67 << 4), 0xf0));
-
-	default:
-		return PMIC_PARAMETER_ERROR;
-	}
-
-	return PMIC_SUCCESS;
-}
-EXPORT_SYMBOL(pmic_power_regulator_set_voltage);
-
-/*!
- * This function retrives the regulator output voltage.
- *
- * @param        regulator    The regulator to be truned off.
- * @param        voltage      Pointer to regulator output voltage.
- *
- * @return       This function returns PMIC_SUCCESS if successful.
- */
-PMIC_STATUS pmic_power_regulator_get_voltage(t_pmic_regulator regulator,
-					     t_regulator_voltage *voltage)
-{
-	unsigned int reg_val = 0;
-
-	if (regulator > MCU_LDO7 || regulator < MCU_SW3)
-		return PMIC_NOT_SUPPORTED;
-
-	switch (regulator) {
-	case MCU_SW3:
-		CHECK_ERROR(pmic_read_reg
-			    (REG_MAX8660_V3_TARGET_VOLT_1, &reg_val, 0xff));
-		voltage->mcu_sw34 = reg_val;
-		break;
-	case MCU_SW4:
-		CHECK_ERROR(pmic_read_reg
-			    (REG_MAX8660_V4_TARGET_VOLT_1, &reg_val, 0xff));
-		voltage->mcu_sw34 = reg_val;
-		break;
-	case MCU_LDO5:
-		CHECK_ERROR(pmic_read_reg
-			    (REG_MAX8660_V5_TARGET_VOLT_1, &reg_val, 0xff));
-		voltage->mcu_ldo5 = reg_val;
-		break;
-	case MCU_LDO6:
-		CHECK_ERROR(pmic_read_reg
-			    (REG_MAX8660_V6V7_TARGET_VOLT, &reg_val, 0x0f));
-		voltage->mcu_ldo67 = reg_val;
-		break;
-	case MCU_LDO7:
-		CHECK_ERROR(pmic_read_reg
-			    (REG_MAX8660_V6V7_TARGET_VOLT, &reg_val, 0xf0));
-		voltage->mcu_ldo67 = (reg_val >> 4) & 0xf;
-		break;
-	default:
-		return PMIC_PARAMETER_ERROR;
-	}
-	return PMIC_SUCCESS;
-}
-EXPORT_SYMBOL(pmic_power_regulator_get_voltage);
-
-/*
- * Initialization and Exit
- */
-
-PMIC_STATUS pmic_power_regulator_init()
-{
-	t_regulator_voltage volt;
-	volt.mcu_sw34 = MCU_SW34_1_2V;
-	CHECK_ERROR(pmic_power_regulator_set_voltage(MCU_SW3, volt));
-	volt.mcu_sw34 = MCU_SW34_1_5V;
-	CHECK_ERROR(pmic_power_regulator_set_voltage(MCU_SW4, volt));
-	volt.mcu_ldo5 = MCU_LDO5_1_8V;
-	CHECK_ERROR(pmic_power_regulator_set_voltage(MCU_LDO5, volt));
-	volt.mcu_ldo67 = MCU_LDO67_2_5V;
-	CHECK_ERROR(pmic_power_regulator_set_voltage(MCU_LDO6, volt));
-	volt.mcu_ldo67 = MCU_LDO67_2_8V;
-	CHECK_ERROR(pmic_power_regulator_set_voltage(MCU_LDO7, volt));
-
-	return PMIC_SUCCESS;
-}
-
-static int pmic_power_probe(struct platform_device *pdev)
-{
-	printk(KERN_INFO "PMIC Power successfully probed\n");
-	pmic_power_regulator_init();
-	return 0;
-}
-
-static struct platform_driver pmic_power_driver_ldm = {
-	.driver = {
-		   .name = "pmic_power",
-		   },
-	.suspend = pmic_power_suspend,
-	.resume = pmic_power_resume,
-	.probe = pmic_power_probe,
-	.remove = NULL,
-};
-
-static int __init pmic_power_init(void)
-{
-	pr_debug("PMIC Power driver loading..\n");
-	return platform_driver_register(&pmic_power_driver_ldm);
-}
-static void __exit pmic_power_exit(void)
-{
-	platform_driver_unregister(&pmic_power_driver_ldm);
-	pr_debug("PMIC Power driver successfully unloaded\n");
-}
-
-/*
- * Module entry points
- */
-
-subsys_initcall(pmic_power_init);
-module_exit(pmic_power_exit);
-
-MODULE_DESCRIPTION("PMIC Power Control device driver");
-MODULE_AUTHOR("Freescale Semiconductor, Inc.");
-MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/mc9sdz60/mcu_pmic_rtc.c b/drivers/mxc/pmic/mc9sdz60/mcu_pmic_rtc.c
index a83d13d..2f61e64 100644
--- a/drivers/mxc/pmic/mc9sdz60/mcu_pmic_rtc.c
+++ b/drivers/mxc/pmic/mc9sdz60/mcu_pmic_rtc.c
@@ -49,13 +49,6 @@ static struct class *pmic_rtc_class;
 struct rtc_time alarm_greg_time;
 static DECLARE_MUTEX(mutex);
 
-#define DEBUG_PMIC_RTC 1
-#if DEBUG_PMIC_RTC
-#define DPRINTK(format, args...) printk(KERN_ERR "pmic_rtc"format"\n", ##args)
-#else
-#define DPRINTK(format, args...)
-#endif
-
 /*
  * Real Time Clock Pmic API
  */
@@ -74,9 +67,9 @@ static void callback_alarm_asynchronous(void *unused)
  */
 static void callback_test_sub(void)
 {
-	printk(KERN_INFO "*****************************************\n");
-	printk(KERN_INFO "***** PMIC RTC 'Alarm IT CallBack' ******\n");
-	printk(KERN_INFO "*****************************************\n");
+	pr_info(KERN_INFO "*****************************************\n");
+	pr_info(KERN_INFO "***** PMIC RTC 'Alarm IT CallBack' ******\n");
+	pr_info(KERN_INFO "*****************************************\n");
 }
 
 /*!
@@ -85,7 +78,7 @@ static void callback_test_sub(void)
  */
 static void callback_alarm_synchronous(void *unused)
 {
-	printk(KERN_INFO "*** Alarm IT Pmic ***\n");
+	pr_info(KERN_INFO "*** Alarm IT Pmic ***\n");
 	wake_up(&queue_alarm);
 }
 
@@ -149,9 +142,6 @@ PMIC_STATUS pmic_rtc_set_time(struct timeval *pmic_time)
 	reg_val |= ((greg_time.tm_year / 10) << 4);
 	CHECK_ERROR(pmic_write_reg(REG_MCU_YEAR, reg_val, 0xff));
 
-	DPRINTK("set time = %d y, %d m, %d d, %d h, %d m, %d s",
-		greg_time.tm_year, greg_time.tm_mon, greg_time.tm_mday,
-		greg_time.tm_hour, greg_time.tm_min, greg_time.tm_sec);
 	return PMIC_SUCCESS;
 }
 EXPORT_SYMBOL(pmic_rtc_set_time);
@@ -190,10 +180,6 @@ PMIC_STATUS pmic_rtc_get_time(struct timeval *pmic_time)
 	CHECK_ERROR(pmic_read_reg(REG_MCU_YEAR, &reg_val, 0xff));
 	greg_time.tm_year = BCD2BIN(reg_val);
 
-	DPRINTK("get time = %d y, %d m, %d d, %d h, %d m, %d s",
-		greg_time.tm_year, greg_time.tm_mon, greg_time.tm_mday,
-		greg_time.tm_hour, greg_time.tm_min, greg_time.tm_sec);
-
 	rtc_tm_to_time(&greg_time, &time);
 	pmic_time->tv_sec = time;
 
@@ -232,9 +218,6 @@ PMIC_STATUS pmic_rtc_set_time_alarm(struct timeval *pmic_time)
 
 	/* enable alarm */
 	CHECK_ERROR(pmic_write_reg(REG_MCU_ALARM_SECS, 0x80, 0x80));
-	DPRINTK("set alarm time = %dh, %dm, %ds\n",
-		greg_time.tm_hour, greg_time.tm_min, greg_time.tm_sec);
-
 	up(&mutex);
 
 	return PMIC_SUCCESS;
@@ -268,9 +251,6 @@ PMIC_STATUS pmic_rtc_get_time_alarm(struct timeval *pmic_time)
 
 	rtc_tm_to_time(&greg_time, &time);
 	pmic_time->tv_sec = time;
-	DPRINTK("get alarm time = %dh, %dm, %ds\n",
-		greg_time.tm_hour, greg_time.tm_min, greg_time.tm_sec);
-
 	return PMIC_SUCCESS;
 }
 EXPORT_SYMBOL(pmic_rtc_get_time_alarm);
@@ -408,22 +388,18 @@ static int pmic_rtc_ioctl(struct inode *inode, struct file *file,
 		CHECK_ERROR(pmic_rtc_get_time_alarm(pmic_time));
 		break;
 	case PMIC_RTC_WAIT_ALARM:
-		printk(KERN_INFO "WAIT ALARM...\n");
 		CHECK_ERROR(pmic_rtc_event_sub(RTC_IT_ALARM,
 					       callback_test_sub));
 		CHECK_ERROR(pmic_rtc_wait_alarm());
-		printk(KERN_INFO "ALARM DONE\n");
 		CHECK_ERROR(pmic_rtc_event_unsub(RTC_IT_ALARM,
 						 callback_test_sub));
 		break;
 	case PMIC_RTC_ALARM_REGISTER:
-		printk(KERN_INFO "PMIC RTC ALARM REGISTER\n");
 		alarm_callback.func = callback_alarm_asynchronous;
 		alarm_callback.param = NULL;
 		CHECK_ERROR(pmic_event_subscribe(EVENT_RTC, alarm_callback));
 		break;
 	case PMIC_RTC_ALARM_UNREGISTER:
-		printk(KERN_INFO "PMIC RTC ALARM UNREGISTER\n");
 		alarm_callback.func = callback_alarm_asynchronous;
 		alarm_callback.param = NULL;
 		CHECK_ERROR(pmic_event_unsubscribe(EVENT_RTC, alarm_callback));
@@ -532,13 +508,11 @@ static int pmic_rtc_probe(struct platform_device *pdev)
 
 	pmic_rtc_major = register_chrdev(0, MCU_PMIC_RTC_NAME, &pmic_rtc_fops);
 	if (pmic_rtc_major < 0) {
-		printk(KERN_ERR "Unable to get a major for pmic_rtc\n");
 		return pmic_rtc_major;
 	}
 
 	pmic_rtc_class = class_create(THIS_MODULE, MCU_PMIC_RTC_NAME);
 	if (IS_ERR(pmic_rtc_class)) {
-		printk(KERN_ERR "Error creating pmic rtc class.\n");
 		ret = PTR_ERR(pmic_rtc_class);
 		goto err_out1;
 	}
@@ -547,7 +521,6 @@ static int pmic_rtc_probe(struct platform_device *pdev)
 					 MKDEV(pmic_rtc_major, 0),
 					 NULL, MCU_PMIC_RTC_NAME);
 	if (IS_ERR(temp_class)) {
-		printk(KERN_ERR "Error creating pmic rtc class device.\n");
 		ret = PTR_ERR(temp_class);
 		goto err_out2;
 	}
diff --git a/drivers/regulator/max8660/reg-max8660.c b/drivers/regulator/max8660/reg-max8660.c
index ce7094e..63ed2eb 100644
--- a/drivers/regulator/max8660/reg-max8660.c
+++ b/drivers/regulator/max8660/reg-max8660.c
@@ -137,14 +137,6 @@ enum {
 #define SET_BIT_IN_BYTE(byte, pos) (byte |= (0x01 << pos))
 #define CLEAR_BIT_IN_BYTE(byte, pos) (byte &= ~(0x01 << pos))
 
-#define DEBUG_REG_MAX8660 0
-#if DEBUG_REG_MAX8660
-#define DPRINTK(format, args...) printk(KERN_ERR \
-	"reg-max8660: "format"\n", ##args)
-#else
-#define DPRINTK(format, args...)
-#endif
-
 static int max8660_regulator_on(int regulator)
 {
 	u8 reg_mask = 0;
@@ -851,16 +843,12 @@ int reg_max8660_probe(void)
 						   reg_max8660[i].regulator.
 						   constraints);
 		if (ret11 < 0) {
-			DPRINTK("%s: failed to register %s err %d\n",
-				__func__, reg_max8660[i].regulator.name, ret11);
 			i--;
 			for (; i >= 0; i--)
 				regulator_unregister(&reg_max8660[i].regulator);
 
 			return ret11;
 		}
-		DPRINTK("%s: success register %s err %d\n",
-			__func__, reg_max8660[i].regulator.name, ret11);
 
 	}
 
@@ -871,9 +859,6 @@ int reg_max8660_probe(void)
 					      regulator,
 					      reg_max8660[i].regulator.parent);
 		if (ret11 < 0) {
-			DPRINTK("%s: failed to register %s err %d\n",
-				__func__,
-				reg_max8660_children[i].regulator.name, ret11);
 			i--;
 			for (; i >= 0; i--)
 				regulator_unregister(&reg_max8660_children[i].
@@ -881,12 +866,8 @@ int reg_max8660_probe(void)
 
 			return ret11;
 		}
-		DPRINTK("%s: success register %s err %d\n",
-			__func__, reg_max8660_children[i].regulator.name,
-			ret11);
 
 	}
-	DPRINTK("max8660 regulator successfully probed\n");
 
 	return 0;
 }
-- 
1.5.4.4

