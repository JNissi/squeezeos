From fe1eb7caa1e488c0b3327158c7b3e21913c1072b Mon Sep 17 00:00:00 2001
From: Richard Zhu <r65037@freescale.com>
Date: Wed, 14 May 2008 14:52:05 +0800
Subject: [PATCH] ENGR00075946 Enable the SDMA mode on eSDHC driver

Enable the Smart DMA feature on eSDHC linux driver, and
export the PIO mode option to the config-menu.

Signed-off-by: Richard Zhu <r65037@freescale.com>
---
 arch/arm/mach-mx37/dma.c    |    4 +-
 drivers/mmc/host/Kconfig    |   12 +++
 drivers/mmc/host/mx_sdhci.c |  222 +++++++++++++++++++++++++-----------------
 drivers/mmc/host/mx_sdhci.h |    1 +
 4 files changed, 147 insertions(+), 92 deletions(-)

diff --git a/arch/arm/mach-mx37/dma.c b/arch/arm/mach-mx37/dma.c
index c68a540..e847e34 100644
--- a/arch/arm/mach-mx37/dma.c
+++ b/arch/arm/mach-mx37/dma.c
@@ -18,8 +18,8 @@
 #include "serial.h"
 
 #define MXC_MMC_BUFFER_ACCESS     0x20
-#define MXC_SDHC_MMC_WML          64
-#define MXC_SDHC_SD_WML           256
+#define MXC_SDHC_MMC_WML          512
+#define MXC_SDHC_SD_WML           512
 #define MXC_SSI_TX0_REG           0x0
 #define MXC_SSI_TX1_REG           0x4
 #define MXC_SSI_RX0_REG           0x8
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 0346738..8127aa5 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -149,3 +149,15 @@ config MMC_IMX_ESDHCI
 	  say Y or M here.
 
 	  If unsure, say N.
+
+config MMC_IMX_ESDHCI_PIO_MODE
+	bool "Freescale i.MX Secure Digital Host Controller Interface PIO mode"
+	depends on MMC_IMX_ESDHC != n
+	default n
+	help
+	  This set the Freescale i.MX Multimedia card Interface to PIO mode.
+	  If you have a i.MX platform with a Multimedia Card slot,
+	  and want test it with PIO mode.
+	  say Y here.
+
+	  If unsure, say N.
diff --git a/drivers/mmc/host/mx_sdhci.c b/drivers/mmc/host/mx_sdhci.c
index 78baeef..234e3ad 100644
--- a/drivers/mmc/host/mx_sdhci.c
+++ b/drivers/mmc/host/mx_sdhci.c
@@ -87,7 +87,12 @@
  * defines the mxc flags refer to the special hw pre-conditons and behavior
  */
 static unsigned int mxc_quirks;
+#ifdef CONFIG_MMC_IMX_ESDHCI_PIO_MODE
+static unsigned int debug_quirks = SDHCI_QUIRK_ONLY_PIO;
+#else
 static unsigned int debug_quirks;
+#endif
+static unsigned int mxc_wml_value = 512;
 
 static void sdhci_prepare_data(struct sdhci_host *, struct mmc_data *);
 static void sdhci_finish_data(struct sdhci_host *);
@@ -181,7 +186,10 @@ static void sdhci_reset(struct sdhci_host *host, u8 mask)
 
 	if (host->flags & SDHCI_USE_DMA)
 		mask_u32 &= ~(SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL);
-	writel(SDHCI_WML_128_WORDS, host->ioaddr + SDHCI_WML);
+	if (mxc_wml_value == 512)
+		writel(SDHCI_WML_128_WORDS, host->ioaddr + SDHCI_WML);
+	else
+		writel(SDHCI_WML_16_WORDS, host->ioaddr + SDHCI_WML);
 	writel(mask_u32, host->ioaddr + SDHCI_INT_ENABLE);
 	writel(mask_u32, host->ioaddr + SDHCI_SIGNAL_ENABLE);
 }
@@ -202,7 +210,10 @@ static void sdhci_init(struct sdhci_host *host)
 	if (host->flags & SDHCI_USE_DMA)
 		intmask &= ~(SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL);
 	/* Configure the WML rege */
-	writel(SDHCI_WML_128_WORDS, host->ioaddr + SDHCI_WML);
+	if (mxc_wml_value == 512)
+		writel(SDHCI_WML_128_WORDS, host->ioaddr + SDHCI_WML);
+	else
+		writel(SDHCI_WML_16_WORDS, host->ioaddr + SDHCI_WML);
 	writel(intmask, host->ioaddr + SDHCI_INT_ENABLE);
 	writel(intmask, host->ioaddr + SDHCI_SIGNAL_ENABLE);
 }
@@ -441,42 +452,14 @@ static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_data *data)
 
 	if (count >= 0xF)
 		count = 0xE;
+	/* Set the max time-out value to level up the compatibility */
+	count = 0xE;
 
 	count =
 	    (count << 16) | (readl(host->ioaddr + SDHCI_CLOCK_CONTROL) &
 			     0xFFF0FFFF);
 	writel(count, host->ioaddr + SDHCI_CLOCK_CONTROL);
 
-	if (host->chip->quirks & SDHCI_QUIRK_EXTERNAL_DMA_MODE) {
-		host->dma_size = data->blocks * data->blksz;
-		DBG("%s:Request bytes to transfer:%d\n", DRIVER_NAME,
-		    host->dma_size);
-		if (host->dma_size <= (64 << host->mmc->ios.bus_width))
-			goto NO_EX_DMA;
-
-		if (data->blksz & 0x3) {
-			printk(KERN_ERR
-			       "mxc_mci: block size not multiple of 4 bytes\n");
-		}
-
-		if (data->flags & MMC_DATA_READ)
-			host->dma_dir = DMA_FROM_DEVICE;
-		else
-			host->dma_dir = DMA_TO_DEVICE;
-
-		host->dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg,
-					   data->sg_len, host->dma_dir);
-
-		if (data->flags & MMC_DATA_READ) {
-			mxc_dma_sg_config(host->dma, data->sg, data->sg_len,
-					  host->dma_size, MXC_DMA_MODE_READ);
-		} else {
-			mxc_dma_sg_config(host->dma, data->sg, data->sg_len,
-					  host->dma_size, MXC_DMA_MODE_WRITE);
-		}
-	}
-NO_EX_DMA:
-
 	if (host->flags & SDHCI_USE_DMA)
 		host->flags |= SDHCI_REQ_USE_DMA;
 
@@ -514,6 +497,33 @@ NO_EX_DMA:
 
 		writel(sg_dma_address(data->sg),
 		       host->ioaddr + SDHCI_DMA_ADDRESS);
+	} else if ((host->flags & SDHCI_USE_EXTERNAL_DMA) &&
+		   (data->blocks * data->blksz >= mxc_wml_value)) {
+		host->dma_size = data->blocks * data->blksz;
+		DBG("Configure the External DMA, %s, len is 0x%x\n",
+		    (data->flags & MMC_DATA_READ)
+		    ? "DMA_FROM_DEIVCE" : "DMA_TO_DEVICE", host->dma_size);
+
+		if (data->blksz & 0x3) {
+			printk(KERN_ERR
+			       "mxc_mci: block size not multiple of 4 bytes\n");
+		}
+
+		if (data->flags & MMC_DATA_READ)
+			host->dma_dir = DMA_FROM_DEVICE;
+		else
+			host->dma_dir = DMA_TO_DEVICE;
+
+		host->dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg,
+					   data->sg_len, host->dma_dir);
+
+		if (data->flags & MMC_DATA_READ) {
+			mxc_dma_sg_config(host->dma, data->sg, data->sg_len,
+					  host->dma_size, MXC_DMA_MODE_READ);
+		} else {
+			mxc_dma_sg_config(host->dma, data->sg, data->sg_len,
+					  host->dma_size, MXC_DMA_MODE_WRITE);
+		}
 	} else {
 		host->cur_sg = data->sg;
 		host->num_sg = data->sg_len;
@@ -543,11 +553,11 @@ static void sdhci_finish_data(struct sdhci_host *host)
 			      flags & MMC_DATA_READ) ? DMA_FROM_DEVICE :
 			     DMA_TO_DEVICE);
 	}
-	if (host->chip->quirks & SDHCI_QUIRK_EXTERNAL_DMA_MODE) {
-		if (host->dma_size > (64 << host->mmc->ios.bus_width)) {
-			dma_unmap_sg(mmc_dev(host->mmc), data->sg,
-				     host->dma_len, host->dma_dir);
-		}
+	if ((host->flags & SDHCI_USE_EXTERNAL_DMA) &&
+	    (host->dma_size >= mxc_wml_value)) {
+		dma_unmap_sg(mmc_dev(host->mmc), data->sg,
+			     host->dma_len, host->dma_dir);
+		host->dma_size = 0;
 	}
 
 	/*
@@ -635,8 +645,9 @@ static void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 			mode &= ~SDHCI_TRNS_READ;
 		if (host->flags & SDHCI_USE_DMA)
 			mode |= SDHCI_TRNS_DMA;
-		DBG("Prepare data completely in %s transfer mode.\n",
-		    (host->flags & SDHCI_USE_DMA) ? "INTERNAL DMA" : "PIO");
+		if (host->flags & SDHCI_USE_EXTERNAL_DMA)
+			DBG("Prepare data completely in %s transfer mode.\n",
+			    "EXTTERNAL DMA");
 	}
 
 	if ((cmd->flags & MMC_RSP_136) && (cmd->flags & MMC_RSP_BUSY)) {
@@ -664,9 +675,8 @@ static void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 		flags |= SDHCI_CMD_DATA;
 
 	mode |= SDHCI_MAKE_CMD(cmd->opcode, flags);
+	DBG("Complete sending cmd, transfer mode would be 0x%x.\n", mode);
 	writel(mode, host->ioaddr + SDHCI_TRANSFER_MODE);
-	DBG("Complete sending cmd, tansfer mode is 0x%x.\n",
-	    readl(host->ioaddr + SDHCI_TRANSFER_MODE));
 }
 
 static void sdhci_finish_command(struct sdhci_host *host)
@@ -812,6 +822,7 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 
 	sdhci_activate_led(host);
 
+	spin_unlock_irqrestore(&host->lock, flags);
 	host->mrq = mrq;
 	if (!(host->flags & SDHCI_CD_PRESENT)) {
 		host->mrq->cmd->error = -ENOMEDIUM;
@@ -820,7 +831,6 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 		sdhci_send_command(host, mrq->cmd);
 
 	mmiowb();
-	spin_unlock_irqrestore(&host->lock, flags);
 }
 
 static void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
@@ -835,17 +845,7 @@ static void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 	host = mmc_priv(mmc);
 
-	spin_lock_irqsave(&host->lock, flags);
-
-	/*
-	 * Reset the chip on each power off.
-	 * Should clear out any weird states.
-	 */
-	if (ios->power_mode == MMC_POWER_OFF) {
-		writel(0, host->ioaddr + SDHCI_SIGNAL_ENABLE);
-		sdhci_init(host);
-	}
-
+	/* Configure the External DMA mode */
 	if (host->chip->quirks & SDHCI_QUIRK_EXTERNAL_DMA_MODE) {
 		host->dma_dir = DMA_NONE;
 		if (mmc->ios.bus_width != host->mode) {
@@ -855,31 +855,40 @@ static void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 					dev_id = MXC_DMA_MMC1_WIDTH_4;
 				else
 					dev_id = MXC_DMA_MMC2_WIDTH_4;
-
-				/* Configure the WML rege */
-				writel(SDHCI_WML_64_WORDS,
-				       host->ioaddr + SDHCI_WML);
 			} else {
 				if (host->id == 0)
 					dev_id = MXC_DMA_MMC1_WIDTH_1;
 				else
 					dev_id = MXC_DMA_MMC2_WIDTH_1;
-
-				/* Configure the WML rege */
-				writel(SDHCI_WML_16_WORDS,
-				       host->ioaddr + SDHCI_WML);
 			}
-			DBG("%d dma chan request\n", dev_id);
 			host->dma = mxc_dma_request(dev_id, "MXC MMC");
 			if (host->dma < 0)
 				DBG("Cannot allocate MMC DMA channel\n");
 			mxc_dma_callback_set(host->dma, sdhci_dma_irq,
 					     (void *)host);
+			/* Configure the WML rege */
+			if (mxc_wml_value == 512)
+				writel(SDHCI_WML_128_WORDS,
+				       host->ioaddr + SDHCI_WML);
+			else
+				writel(SDHCI_WML_16_WORDS,
+				       host->ioaddr + SDHCI_WML);
 		}
 	}
 
 	host->mode = mmc->ios.bus_width;
 
+	spin_lock_irqsave(&host->lock, flags);
+
+	/*
+	 * Reset the chip on each power off.
+	 * Should clear out any weird states.
+	 */
+	if (ios->power_mode == MMC_POWER_OFF) {
+		writel(0, host->ioaddr + SDHCI_SIGNAL_ENABLE);
+		sdhci_init(host);
+	}
+
 	sdhci_set_clock(host, ios->clock);
 
 	if (ios->power_mode == MMC_POWER_OFF)
@@ -1126,6 +1135,8 @@ static void sdhci_cmd_irq(struct sdhci_host *host, u32 intmask)
 
 static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
 {
+	u32 intsave = 0;
+
 	BUG_ON(intmask == 0);
 
 	if (!host->data) {
@@ -1145,6 +1156,11 @@ static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
 		return;
 	}
 
+	/* Mask the INT */
+	intsave = readl(host->ioaddr + SDHCI_INT_ENABLE);
+	writel(intsave & (~(intmask & SDHCI_INT_DATA_RE_MASK)),
+	       host->ioaddr + SDHCI_INT_ENABLE);
+
 	if (intmask & SDHCI_INT_DATA_TIMEOUT)
 		host->data->error = -ETIMEDOUT;
 	else if (intmask & (SDHCI_INT_DATA_CRC | SDHCI_INT_DATA_END_BIT))
@@ -1153,20 +1169,16 @@ static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
 	if (host->data->error)
 		sdhci_finish_data(host);
 	else {
-		if (host->chip->quirks & SDHCI_QUIRK_EXTERNAL_DMA_MODE) {
+		if ((host->flags & SDHCI_USE_EXTERNAL_DMA) &&
+		    (host->dma_size >= mxc_wml_value)) {
 			/* Use DMA if transfer size is greater than fifo size */
 			if (intmask & (SDHCI_INT_DATA_AVAIL |
 				       SDHCI_INT_SPACE_AVAIL)) {
-				if (host->dma_size > (64 <<
-						      host->
-						      mmc->ios.bus_width)) {
-					if (mxc_dma_enable(host->dma) < 0)
-						printk(KERN_ERR
-						       "ENABLE SDMA ERR.\n");
-				} else {
-					sdhci_transfer_pio(host);
+				intsave &= ~SDHCI_INT_DATA_RE_MASK;
+				if (mxc_dma_enable(host->dma) < 0) {
+					printk(KERN_ERR "ENABLE SDMA ERR.\n");
+					intsave |= SDHCI_INT_DATA_RE_MASK;
 				}
-
 			}
 		} else {
 			if (intmask & (SDHCI_INT_DATA_AVAIL |
@@ -1204,11 +1216,14 @@ static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
 				intmask = readl(host->ioaddr +
 						SDHCI_PRESENT_STATE);
 				if (intmask & SDHCI_DATA_ACTIVE)
-					return;
+					goto data_irq_out;
 				sdhci_finish_data(host);
 			}
 		}
 	}
+data_irq_out:
+	/* Enable the INT */
+	writel(intsave, host->ioaddr + SDHCI_INT_ENABLE);
 }
 
 /*!
@@ -1221,20 +1236,27 @@ static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
 */
 static void sdhci_dma_irq(void *devid, int error, unsigned int cnt)
 {
+	u32 intsave = 0;
+	int ret;
 	struct sdhci_host *host = devid;
 
-	if (host->chip->quirks & SDHCI_QUIRK_EXTERNAL_DMA_MODE) {
+	DBG("%s: error: %d Transferred bytes:%d\n", DRIVER_NAME, error, cnt);
+	if (host->flags & SDHCI_USE_EXTERNAL_DMA) {
 		/*
 		 * Stop the DMA transfer here, the data_irq would be called
 		 * to process the others
 		 */
-		mxc_dma_disable(host->dma);
+		ret = mxc_dma_disable(host->dma);
+		if (ret < 0)
+			printk(KERN_ERR "Disable dma channel err %d\n", ret);
 
 		if (error) {
 			DBG("Error in DMA transfer\n");
 			return;
 		}
-		DBG("%s: Transfered bytes:%d\n", DRIVER_NAME, cnt);
+		intsave = readl(host->ioaddr + SDHCI_INT_ENABLE);
+		intsave |= SDHCI_INT_DATA_RE_MASK;
+		writel(intsave, host->ioaddr + SDHCI_INT_ENABLE);
 	}
 }
 
@@ -1308,7 +1330,7 @@ static irqreturn_t sdhci_irq(int irq, void *dev_id)
 {
 	irqreturn_t result;
 	struct sdhci_host *host = dev_id;
-	u32 intmask, intsave = 0;
+	u32 intmask;
 	int cardint = 0;
 
 	spin_lock(&host->lock);
@@ -1322,11 +1344,6 @@ static irqreturn_t sdhci_irq(int irq, void *dev_id)
 
 	DBG("*** %s got interrupt: 0x%08x\n", host->slot_descr, intmask);
 
-	/* Mask the INT */
-	intsave = readl(host->ioaddr + SDHCI_INT_ENABLE);
-	writel(intsave & (~(intmask & SDHCI_INT_DATA_RE_MASK)),
-	       host->ioaddr + SDHCI_INT_ENABLE);
-
 	if (intmask & (SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE)) {
 		writel(intmask &
 		       (SDHCI_INT_CARD_INSERT |
@@ -1388,8 +1405,6 @@ out:
 	if (cardint)
 		mmc_signal_sdio_irq(host->mmc);
 
-	/* Enable the INT */
-	writel(intsave, host->ioaddr + SDHCI_INT_ENABLE);
 	return result;
 }
 
@@ -1496,6 +1511,7 @@ static int __devinit sdhci_probe_slot(struct platform_device
 	struct sdhci_chip *chip;
 	struct mmc_host *mmc;
 	struct sdhci_host *host;
+	mxc_dma_device_t dev_id = 0;
 
 	if (!mmc_plat)
 		return -EINVAL;
@@ -1599,6 +1615,8 @@ static int __devinit sdhci_probe_slot(struct platform_device
 		 quirks & (SDHCI_QUIRK_INTERNAL_ADVANCED_DMA |
 			   SDHCI_QUIRK_INTERNAL_SIMPLE_DMA))
 		host->flags |= SDHCI_USE_DMA;
+	else if (chip->quirks & (SDHCI_QUIRK_EXTERNAL_DMA_MODE))
+		host->flags |= SDHCI_USE_EXTERNAL_DMA;
 	else
 		host->flags &= ~SDHCI_USE_DMA;
 
@@ -1652,7 +1670,10 @@ static int __devinit sdhci_probe_slot(struct platform_device
 	 * Maximum number of sectors in one transfer. Limited by DMA boundary
 	 * size (512KiB).
 	 */
-	mmc->max_req_size = 524288;
+	if (host->flags & SDHCI_USE_EXTERNAL_DMA)
+		mmc->max_req_size = 32 * 1024;
+	else
+		mmc->max_req_size = 524288;
 
 	/*
 	 * Maximum segment size. Could be one segment with the maximum number
@@ -1701,6 +1722,20 @@ static int __devinit sdhci_probe_slot(struct platform_device
 
 	sdhci_init(host);
 
+	if (host->flags & SDHCI_USE_EXTERNAL_DMA) {
+		/* Apply the 1-bit SDMA channel. */
+		if (host->id == 0)
+			dev_id = MXC_DMA_MMC1_WIDTH_1;
+		else
+			dev_id = MXC_DMA_MMC2_WIDTH_1;
+		host->dma = mxc_dma_request(dev_id, "MXC MMC");
+		if (host->dma < 0) {
+			DBG("Cannot allocate MMC DMA channel\n");
+			goto out6;
+		}
+		mxc_dma_callback_set(host->dma, sdhci_dma_irq, (void *)host);
+	}
+
 #ifdef CONFIG_MMC_DEBUG
 	sdhci_dumpregs(host);
 #endif
@@ -1709,9 +1744,14 @@ static int __devinit sdhci_probe_slot(struct platform_device
 
 	if (mmc_add_host(mmc) < 0)
 		goto out6;
-	printk(KERN_INFO "%s: SDHCI detect irq %d irq %d %s\n",
-	       mmc_hostname(mmc), host->detect_irq, host->irq,
-	       (host->flags & SDHCI_USE_DMA) ? "INTERNAL DMA" : "PIO");
+	if (host->flags & SDHCI_USE_EXTERNAL_DMA)
+		printk(KERN_INFO "%s: SDHCI detect irq %d irq %d %s\n",
+		       mmc_hostname(mmc), host->detect_irq, host->irq,
+		       "EXTERNAL DMA");
+	else
+		printk(KERN_INFO "%s: SDHCI detect irq %d irq %d %s\n",
+		       mmc_hostname(mmc), host->detect_irq, host->irq,
+		       (host->flags & SDHCI_USE_DMA) ? "INTERNAL DMA" : "PIO");
 
 	return 0;
 
@@ -1755,8 +1795,10 @@ static void sdhci_remove_slot(struct platform_device *pdev, int slot)
 	if (host->detect_irq)
 		free_irq(host->detect_irq, host);
 	free_irq(host->irq, host);
-	if (chip->quirks & SDHCI_QUIRK_EXTERNAL_DMA_MODE)
+	if (chip->quirks & SDHCI_QUIRK_EXTERNAL_DMA_MODE) {
+		host->flags &= ~SDHCI_USE_EXTERNAL_DMA;
 		mxc_dma_free(host->dma);
+	}
 
 	del_timer_sync(&host->timer);
 
@@ -1788,7 +1830,7 @@ static int sdhci_probe(struct platform_device *pdev)
 
 	/* Distinguish different platform */
 	if (machine_is_mx37_3ds()) {
-		mxc_quirks = SDHCI_QUIRK_ONLY_PIO;
+		mxc_quirks = SDHCI_QUIRK_EXTERNAL_DMA_MODE;
 	} else {
 		mxc_quirks = SDHCI_QUIRK_INTERNAL_ADVANCED_DMA |
 		    SDHCI_QUIRK_INTERNAL_SIMPLE_DMA;
diff --git a/drivers/mmc/host/mx_sdhci.h b/drivers/mmc/host/mx_sdhci.h
index d66d0ce..6d4077a 100644
--- a/drivers/mmc/host/mx_sdhci.h
+++ b/drivers/mmc/host/mx_sdhci.h
@@ -178,6 +178,7 @@ struct sdhci_host {
 	int flags;		/* Host attributes */
 #define SDHCI_USE_DMA		(1<<0)	/* Host is DMA capable */
 #define SDHCI_REQ_USE_DMA	(1<<1)	/* Use DMA for this req. */
+#define SDHCI_USE_EXTERNAL_DMA	(1<<2)	/* Use DMA for this req. */
 #define SDHCI_CD_PRESENT 	(1<<8)	/* Use DMA for this req. */
 #define SDHCI_WP_ENABLED	(1<<9)	/* Use DMA for this req. */
 
-- 
1.5.4.4

