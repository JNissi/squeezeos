From 777ada9a6bab284ab2e6260f1445826c180c8b80 Mon Sep 17 00:00:00 2001
From: Fred Fan <r01011@freescale.com>
Date: Thu, 7 Aug 2008 10:22:03 +0800
Subject: [PATCH] ENGR00086874 FlexCAN fails to send right data when len is not round of 4bytes

The cause is the data buffer of can frame is not byte order. In a word, the
master byte will be transmit first. The solution is swab the order when receive
or transmit frame with data.

Signed-off-by: Fred Fan <r01011@freescale.com>
---
 drivers/net/can/flexcan/mbm.c |   23 +++++++++++++++++++----
 1 files changed, 19 insertions(+), 4 deletions(-)

diff --git a/drivers/net/can/flexcan/mbm.c b/drivers/net/can/flexcan/mbm.c
index 1a3eeb3..6c06470 100644
--- a/drivers/net/can/flexcan/mbm.c
+++ b/drivers/net/can/flexcan/mbm.c
@@ -30,6 +30,20 @@
 #include <asm/irq.h>
 #include "flexcan.h"
 
+#define flexcan_swab32(x)	\
+	(((x) << 24) | ((x) >> 24) |\
+		(((x) & (__u32)0x0000ff00UL) << 8) |\
+		(((x) & (__u32)0x00ff0000UL) >> 8))
+
+static inline void flexcan_memcpy(void *dst, void *src, int len)
+{
+	int i;
+	unsigned int *d = (unsigned int *)dst, *s = (unsigned int *)src;
+	len = (len + 3) >> 2;
+	for (i = 0; i < len; i++, s++, d++)
+		*d = flexcan_swab32(*s);
+}
+
 static void flexcan_mb_bottom(struct net_device *dev, int index)
 {
 	struct flexcan_device *flexcan = netdev_priv(dev);
@@ -66,7 +80,8 @@ static void flexcan_mb_bottom(struct net_device *dev, int index)
 		frame->can_dlc = hwmb->mb_cs.cs.length;
 
 		if (frame->can_dlc && frame->can_dlc)
-			memcpy(frame->data, hwmb->mb_data, frame->can_dlc);
+			flexcan_memcpy(frame->data, hwmb->mb_data,
+				       frame->can_dlc);
 
 		if (flexcan->fifo
 		    || (index >= (flexcan->maxmb - flexcan->xmit_maxmb))) {
@@ -129,8 +144,8 @@ static void flexcan_fifo_isr(struct net_device *dev, unsigned int iflag1)
 			frame->can_dlc = hwmb->mb_cs.cs.length;
 
 			if (frame->can_dlc && (frame->can_dlc <= 8))
-				memcpy(frame->data, hwmb->mb_data,
-				       frame->can_dlc);
+				flexcan_memcpy(frame->data, hwmb->mb_data,
+					       frame->can_dlc);
 			tmp = __raw_readl(flexcan->io_base + CAN_HW_REG_TIMER);
 
 			dev->last_rx = jiffies;
@@ -272,7 +287,7 @@ int flexcan_mbm_xmit(struct flexcan_device *flexcan, struct can_frame *frame)
 	}
 
 	hwmb[i].mb_cs.cs.length = frame->can_dlc;
-	memcpy(hwmb[i].mb_data, frame->data, frame->can_dlc);
+	flexcan_memcpy(hwmb[i].mb_data, frame->data, frame->can_dlc);
 	hwmb[i].mb_cs.cs.code = CAN_MB_TX_ONCE;
 	return 0;
 }
-- 
1.5.4.4

