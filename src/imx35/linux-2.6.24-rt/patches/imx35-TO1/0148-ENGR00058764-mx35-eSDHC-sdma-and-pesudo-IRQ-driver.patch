From edc0dba6936b8bd049abe7b0468276f797a82cc6 Mon Sep 17 00:00:00 2001
From: Richard Zhu <r65037@freescale.com>
Date: Mon, 28 Apr 2008 13:07:08 +0800
Subject: [PATCH] ENGR00058764 mx35 eSDHC sdma and pesudo IRQ driver

Enalbe the internal DMA(simple dma) on mx35.
For card detect, since mx35 has to be out of IRQ context,
to do the card detect irq handler in work queue.

Signed-off-by: Richard Zhu <r65037@freescale.com>
---
 arch/arm/mach-mx35/board-mx35_3stack.h |    1 +
 arch/arm/mach-mx35/mx35_3stack.c       |    5 +-
 arch/arm/mach-mx35/mx35_3stack_gpio.c  |   19 +++
 drivers/mmc/host/mx_sdhci.c            |  278 ++++++++++++--------------------
 drivers/mmc/host/mx_sdhci.h            |    8 +-
 5 files changed, 136 insertions(+), 175 deletions(-)

diff --git a/arch/arm/mach-mx35/board-mx35_3stack.h b/arch/arm/mach-mx35/board-mx35_3stack.h
index b2b5285..a99be90 100644
--- a/arch/arm/mach-mx35/board-mx35_3stack.h
+++ b/arch/arm/mach-mx35/board-mx35_3stack.h
@@ -195,6 +195,7 @@ extern int mxc_clocks_init(void);
 extern void __init early_console_setup(char *);
 extern void gpio_tsc_active(void);
 extern void gpio_tsc_inactive(void);
+extern unsigned int sdhc_get_card_det_status(struct device *dev);
 
 #endif				/* CONFIG_MACH_MX35_3DS */
 #endif				/* __ASM_ARCH_MXC_BOARD_MX35_3STACK_H__ */
diff --git a/arch/arm/mach-mx35/mx35_3stack.c b/arch/arm/mach-mx35/mx35_3stack.c
index ced2261..7722e68 100644
--- a/arch/arm/mach-mx35/mx35_3stack.c
+++ b/arch/arm/mach-mx35/mx35_3stack.c
@@ -323,6 +323,7 @@ static struct mxc_mmc_platform_data mmc_data = {
 	.min_clk = 400000,
 	.max_clk = 52000000,
 	.card_inserted_state = 1,
+	.status = sdhc_get_card_det_status,
 	.clock_mmc = "sdhc_clk",
 };
 
@@ -341,8 +342,8 @@ static struct resource mxcsdhc1_resources[] = {
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[2] = {
-	       .start = 0,
-	       .end = 0,
+	       .start = MXC_PSEUDO_IRQ_SD1_CD,
+	       .end = MXC_PSEUDO_IRQ_SD1_CD,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
diff --git a/arch/arm/mach-mx35/mx35_3stack_gpio.c b/arch/arm/mach-mx35/mx35_3stack_gpio.c
index f4f9db7..75d498e 100644
--- a/arch/arm/mach-mx35/mx35_3stack_gpio.c
+++ b/arch/arm/mach-mx35/mx35_3stack_gpio.c
@@ -580,6 +580,25 @@ void gpio_sdhc_inactive(int module)
 EXPORT_SYMBOL(gpio_sdhc_inactive);
 
 /*
+ * Probe for the card. If present the GPIO data would be set.
+ */
+unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	unsigned int ret;
+
+	if (to_platform_device(dev)->id == 0) {
+		if (0 != pmic_gpio_get_designation_bit_val(2, &ret))
+			printk(KERN_ERR "Get cd status error.");
+		return ret;
+	} else {		/* config the det pin for SDHC2 */
+		return 0;
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL(sdhc_get_card_det_status);
+
+/*
  *  USB Host2
  */
 int gpio_usbh2_active(void)
diff --git a/drivers/mmc/host/mx_sdhci.c b/drivers/mmc/host/mx_sdhci.c
index 6e4dfd1..05b16bb 100644
--- a/drivers/mmc/host/mx_sdhci.c
+++ b/drivers/mmc/host/mx_sdhci.c
@@ -43,9 +43,6 @@
 #include <asm/mach/irq.h>
 #include <asm/mach-types.h>
 #include <asm/arch/mmc.h>
-#ifdef CONFIG_MACH_MX35_3DS
-#include <asm/arch/pmic_external.h>
-#endif
 
 #include "mx_sdhci.h"
 
@@ -90,7 +87,7 @@
  * defines the mxc flags refer to the special hw pre-conditons and behavior
  */
 static unsigned int mxc_quirks;
-static unsigned int debug_quirks = SDHCI_QUIRK_ONLY_PIO;
+static unsigned int debug_quirks;
 
 static void sdhci_prepare_data(struct sdhci_host *, struct mmc_data *);
 static void sdhci_finish_data(struct sdhci_host *);
@@ -103,10 +100,6 @@ extern void gpio_sdhc_active(int module);
 extern void gpio_sdhc_inactive(int module);
 static void sdhci_dma_irq(void *devid, int error, unsigned int cnt);
 
-#ifdef CONFIG_MACH_MX35_3DS
-static pmic_event_callback_t sdhci_pmic_cd_callback;
-static pmic_event_callback_t sdhci_pmic_wp_callback;
-#endif
 static void sdhci_dumpregs(struct sdhci_host *host)
 {
 	printk(KERN_DEBUG DRIVER_NAME
@@ -188,6 +181,7 @@ static void sdhci_reset(struct sdhci_host *host, u8 mask)
 
 	if (host->flags & SDHCI_USE_DMA)
 		mask_u32 &= ~(SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL);
+	writel(SDHCI_WML_128_WORDS, host->ioaddr + SDHCI_WML);
 	writel(mask_u32, host->ioaddr + SDHCI_INT_ENABLE);
 	writel(mask_u32, host->ioaddr + SDHCI_SIGNAL_ENABLE);
 }
@@ -208,7 +202,7 @@ static void sdhci_init(struct sdhci_host *host)
 	if (host->flags & SDHCI_USE_DMA)
 		intmask &= ~(SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL);
 	/* Configure the WML rege */
-	writel(SDHCI_WML_4_WORDS, host->ioaddr + SDHCI_WML);
+	writel(SDHCI_WML_128_WORDS, host->ioaddr + SDHCI_WML);
 	writel(intmask, host->ioaddr + SDHCI_INT_ENABLE);
 	writel(intmask, host->ioaddr + SDHCI_SIGNAL_ENABLE);
 }
@@ -269,7 +263,6 @@ static void sdhci_read_block_pio(struct sdhci_host *host)
 	int size;
 
 	DBG("PIO reading\n");
-	udelay(100);		/* 100 us delay is needed */
 
 	blksize = host->data->blksz;
 	chunk_remain = 0;
@@ -380,6 +373,31 @@ static void sdhci_transfer_pio(struct sdhci_host *host)
 	DBG("PIO transfer complete.\n");
 }
 
+static void sdhci_prepare_dma(struct sdhci_host *host, struct mmc_data *data)
+{
+	/*
+	 * Skip to next SG entry.
+	 */
+	host->cur_sg++;
+	host->num_sg--;
+
+	/*
+	 * Any entries left?
+	 */
+	if (host->num_sg > 0) {
+		DBG("Another entry configure the sg DMA, %s\n",
+		    (data->flags & MMC_DATA_READ)
+		    ? "DMA_FROM_DEIVCE" : "DMA_TO_DEVICE");
+		host->offset = 0;
+		host->remain = host->cur_sg->length;
+
+		/* COnfig the DMA address */
+		writel(sg_dma_address(host->cur_sg),
+		       host->ioaddr + SDHCI_DMA_ADDRESS);
+	}
+
+}
+
 static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_data *data)
 {
 	u32 count;
@@ -487,8 +505,11 @@ NO_EX_DMA:
 	if (host->flags & SDHCI_REQ_USE_DMA) {
 		int count;
 
+		DBG("Configure the sg DMA, %s, len is 0x%x\n",
+		    (data->flags & MMC_DATA_READ)
+		    ? "DMA_FROM_DEIVCE" : "DMA_TO_DEVICE", data->sg_len);
 		count =
-		    dma_map_sg(&(host->chip->pdev)->dev, data->sg, data->sg_len,
+		    dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
 			       (data->
 				flags & MMC_DATA_READ) ? DMA_FROM_DEVICE :
 			       DMA_TO_DEVICE);
@@ -496,8 +517,6 @@ NO_EX_DMA:
 
 		writel(sg_dma_address(data->sg),
 		       host->ioaddr + SDHCI_DMA_ADDRESS);
-		DBG("configure the sg DMA, %s\n", (data->flags & MMC_DATA_READ)
-		    ? "DMA_FROM_DEIVCE" : "DMA_TO_DEVICE");
 	} else {
 		host->cur_sg = data->sg;
 		host->num_sg = data->sg_len;
@@ -545,8 +564,8 @@ static void sdhci_finish_data(struct sdhci_host *host)
 
 	if (!data->error && blocks) {
 		printk(KERN_ERR "%s: Controller signalled completion even "
-		       "though there were blocks left.\n",
-		       mmc_hostname(host->mmc));
+		       "though there were 0x%x blocks left.\n",
+		       mmc_hostname(host->mmc), blocks);
 		data->error = -EIO;
 	}
 
@@ -572,6 +591,7 @@ static void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 	u32 mode = 0;
 	unsigned long timeout;
 
+	DBG("sdhci_send_command is starting...\n");
 	WARN_ON(host->cmd);
 
 	/* Wait max 10 ms */
@@ -705,16 +725,12 @@ static void sdhci_set_clock(struct sdhci_host *host, unsigned int clock)
 
 	if (clock == 0)
 		goto out;
-	/*
-	 * when prescaler = 16, CLK_20M = CLK_DIV / 2
-	 */
 	if (clock == host->min_clk)
 		prescaler = 16;
 	else
 		prescaler = 0;
-	/* div=1, CLK_DIV = ipg_perclk/2 */
 	while (prescaler <= 0x80) {
-		for (div = 1; div <= 0xF; div++) {
+		for (div = 0; div <= 0xF; div++) {
 			int x;
 			if (prescaler != 0)
 				x = (clk_rate / (div + 1)) / (prescaler * 2);
@@ -755,7 +771,7 @@ static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
 {
 	int voltage = 0;
 
-	/* There is no PWR CTL REG*/
+	/* There is no PWR CTL REG */
 	if (host->power == power)
 		return;
 
@@ -790,7 +806,6 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 {
 	struct sdhci_host *host;
 	unsigned long flags;
-	int card_gpio_status;
 
 	host = mmc_priv(mmc);
 
@@ -801,13 +816,7 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	sdhci_activate_led(host);
 
 	host->mrq = mrq;
-#ifdef CONFIG_MACH_MX35_3DS
-	if (!(host->flags & SDHCI_CD_PRESENT))
-#else
-	card_gpio_status = host->plat_data->status(host->mmc->parent);
-	if (card_gpio_status)
-#endif
-	{
+	if (!(host->flags & SDHCI_CD_PRESENT)) {
 		host->mrq->cmd->error = -ENOMEDIUM;
 		tasklet_schedule(&host->finish_tasklet);
 	} else
@@ -968,9 +977,18 @@ static void sdhci_tasklet_card(unsigned long param)
 {
 	struct sdhci_host *host;
 	unsigned long flags;
+	unsigned int cd_status = 0;
 
 	host = (struct sdhci_host *)param;
 
+	if (host->flags & SDHCI_CD_PRESENT)
+		host->flags &= ~SDHCI_CD_PRESENT;
+	else
+		host->flags |= SDHCI_CD_PRESENT;
+	/* Detect there is a card in slot or not */
+	DBG("cd_status=%d %s\n", cd_status,
+	    (host->flags & SDHCI_CD_PRESENT) ? "inserted" : "removed");
+
 	spin_lock_irqsave(&host->lock, flags);
 
 	if (!(host->flags & SDHCI_CD_PRESENT)) {
@@ -1164,11 +1182,14 @@ static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
 		 * boundaries, but as we can't disable the feature
 		 * we need to at least restart the transfer.
 		 */
-		if (intmask & SDHCI_INT_DMA_END)
-			writel(readl
-			       (host->ioaddr +
-				SDHCI_DMA_ADDRESS),
-			       host->ioaddr + SDHCI_DMA_ADDRESS);
+		if ((intmask & SDHCI_INT_DMA_END) &&
+		    (!(intmask & SDHCI_INT_DATA_END))) {
+			/*
+			 * A scatterlist segment completed,
+			 * prepare the next one.
+			 */
+			sdhci_prepare_dma(host, host->data);
+		}
 
 		if (intmask & SDHCI_INT_DATA_END) {
 			if (host->cmd) {
@@ -1179,16 +1200,14 @@ static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
 				 */
 				host->data_early = 1;
 			} else {
-			/*
-			 * There are the DATA END INT when writing is
-			 * not complete. Double check on it.
-			 */
-			intmask = readl(host->ioaddr + SDHCI_PRESENT_STATE);
-			if (intmask & SDHCI_DATA_ACTIVE) {
-				printk(KERN_ERR
-					"ERR DATA END INT in writing.\n");
-				return;
-			}
+				/* ????
+				 * There are the DATA END INT when writing is
+				 * not complete. Double check on it.
+				 */
+				intmask = readl(host->ioaddr +
+						SDHCI_PRESENT_STATE);
+				if (intmask & SDHCI_DATA_ACTIVE)
+					return;
 				sdhci_finish_data(host);
 			}
 		}
@@ -1222,43 +1241,25 @@ static void sdhci_dma_irq(void *devid, int error, unsigned int cnt)
 	}
 }
 
-#ifdef CONFIG_MACH_MX35_3DS
-/*!
-* Card detection interrupt callback routine registered to handle the
-* SDHC interrupts. This interrupt callback handles card insertion
-* and card removal interrupts. when the PMIC events mechanis is used.
-*
-* @param   irq    the interrupt number
-* @param   devid  driver private data
-*
-* @return  The function returns \b IRQ_RETVAL(1)
-*/
-static void sdhci_pmic_cd_func(void *devid)
+/* woke queue handler func */
+static void esdhc_cd_callback(struct work_struct *work)
 {
-	int cd_status = 0;
 	unsigned long flags;
-	struct sdhci_host *host = devid;
+	unsigned int cd_status = 0;
+	struct sdhci_host *host = container_of(work, struct sdhci_host, cd_wq);
 
-	if (host->flags & SDHCI_CD_PRESENT)
+	cd_status = host->plat_data->status(host->mmc->parent);
+	if (cd_status)
 		host->flags &= ~SDHCI_CD_PRESENT;
 	else
 		host->flags |= SDHCI_CD_PRESENT;
-
 	/* Detect there is a card in slot or not */
-	DBG("%s: %s cd_status=%d %s\n", DRIVER_NAME,
-	    host->slot_descr, (host->flags & SDHCI_CD_PRESENT),
-	    (host->flags & SDHCI_CD_PRESENT)
-	    ? "inserted" : "removed");
+	DBG("cd_status=%d %s\n", cd_status,
+	    (host->flags & SDHCI_CD_PRESENT) ? "inserted" : "removed");
 
-	if (0 == cd_status) {
-#if 0
-		host->flags |= SDHCI_CD_PRESENT;
-#endif
-		mmc_detect_change(host->mmc, msecs_to_jiffies(500));
-	} else {
-#if 0
-		host->flags &= ~SDHCI_CD_PRESENT;
-#endif
+	spin_lock_irqsave(&host->lock, flags);
+
+	if (!(host->flags & SDHCI_CD_PRESENT)) {
 		if (host->mrq) {
 			printk(KERN_ERR
 			       "%s: Card removed during transfer!\n",
@@ -1267,40 +1268,27 @@ static void sdhci_pmic_cd_func(void *devid)
 			       "%s: Resetting controller.\n",
 			       mmc_hostname(host->mmc));
 
-			spin_lock_irqsave(&host->lock, flags);
 			sdhci_reset(host, SDHCI_RESET_CMD);
 			sdhci_reset(host, SDHCI_RESET_DATA);
 
 			host->mrq->cmd->error = -ENOMEDIUM;
 			tasklet_schedule(&host->finish_tasklet);
-			spin_unlock_irqrestore(&host->lock, flags);
 		}
-		mmc_detect_change(host->mmc, msecs_to_jiffies(100));
 	}
-}
 
-/*!
-* Write protect interrupt callback routine registered to check the SDHC write
-* protected or not. when the PMIC events mechanis is used.
-*
-* @param
-* @param
-*
-* @return
-*/
-static void sdhci_pmic_wp_func(void *devid)
-{
-	int wp_status = 0;
-	struct sdhci_host *host = devid;
+	spin_unlock_irqrestore(&host->lock, flags);
 
-	/* Detect the card in slot is write protected or not */
-	if (0 == wp_status)
-		host->flags |= SDHCI_WP_ENABLED;
-	else
-		host->flags &= ~SDHCI_WP_ENABLED;
-	host->flags |= SDHCI_WP_ENABLED;
+	mmc_detect_change(host->mmc, msecs_to_jiffies(500));
+
+	do {
+		cd_status = host->plat_data->status(host->mmc->parent);
+		if (cd_status)
+			set_irq_type(host->detect_irq, IRQT_FALLING);
+		else
+			set_irq_type(host->detect_irq, IRQT_RISING);
+	} while (cd_status != host->plat_data->status(host->mmc->parent));
 }
-#else
+
 /*!
 * Card detection interrupt service routine registered to handle
 * the SDHC interrupts. This interrupt routine handles card
@@ -1311,58 +1299,19 @@ static void sdhci_pmic_wp_func(void *devid)
 *
 * @return  The function returns \b IRQ_RETVAL(1)
 */
-static irqreturn_t sdhci_cd_irq(int irq, void *devid)
+static irqreturn_t sdhci_cd_irq(int irq, void *dev_id)
 {
-	struct sdhci_host *host = devid;
-	int card_gpio_status = host->plat_data->status(host->mmc->parent);
-	unsigned long flags;
-
-	DBG("%s: %s status=%d %s\n", DRIVER_NAME,
-	    host->slot_descr, card_gpio_status,
-	    card_gpio_status ? "removed" : "inserted");
-
-	if (card_gpio_status == host->plat_data->card_inserted_state) {
-		host->flags &= ~SDHCI_CD_PRESENT;
-		if (host->mrq) {
-			printk(KERN_ERR
-			       "%s: Card removed during transfer!\n",
-			       mmc_hostname(host->mmc));
-			printk(KERN_ERR
-			       "%s: Resetting controller.\n",
-			       mmc_hostname(host->mmc));
-
-			spin_lock_irqsave(&host->lock, flags);
-			sdhci_reset(host, SDHCI_RESET_CMD);
-			sdhci_reset(host, SDHCI_RESET_DATA);
-
-			host->mrq->cmd->error = -ENOMEDIUM;
-			tasklet_schedule(&host->finish_tasklet);
-			spin_unlock_irqrestore(&host->lock, flags);
-		}
-		mmc_detect_change(host->mmc, msecs_to_jiffies(100));
-	} else {
-		host->flags |= SDHCI_CD_PRESENT;
-		mmc_detect_change(host->mmc, msecs_to_jiffies(500));
-	}
-
-	do {
-		card_gpio_status = host->plat_data->status(host->mmc->parent);
-		if (card_gpio_status)
-			set_irq_type(host->detect_irq, IRQT_FALLING);
-		else
-			set_irq_type(host->detect_irq, IRQT_RISING);
-	} while (card_gpio_status !=
-		 host->plat_data->status(host->mmc->parent));
+	struct sdhci_host *host = dev_id;
 
+	schedule_work(&host->cd_wq);
 	return IRQ_HANDLED;
 }
-#endif
 
 static irqreturn_t sdhci_irq(int irq, void *dev_id)
 {
 	irqreturn_t result;
 	struct sdhci_host *host = dev_id;
-	u32 intmask;
+	u32 intmask, intsave = 0;
 	int cardint = 0;
 
 	spin_lock(&host->lock);
@@ -1376,6 +1325,11 @@ static irqreturn_t sdhci_irq(int irq, void *dev_id)
 
 	DBG("*** %s got interrupt: 0x%08x\n", host->slot_descr, intmask);
 
+	/* Mask the INT */
+	intsave = readl(host->ioaddr + SDHCI_INT_ENABLE);
+	writel(intsave & (~(intmask & SDHCI_INT_DATA_RE_MASK)),
+	       host->ioaddr + SDHCI_INT_ENABLE);
+
 	if (intmask & (SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE)) {
 		writel(intmask &
 		       (SDHCI_INT_CARD_INSERT |
@@ -1437,6 +1391,8 @@ out:
 	if (cardint)
 		mmc_signal_sdio_irq(host->mmc);
 
+	/* Enable the INT */
+	writel(intsave, host->ioaddr + SDHCI_INT_ENABLE);
 	return result;
 }
 
@@ -1589,18 +1545,6 @@ static int __devinit sdhci_probe_slot(struct platform_device
 		ret = -ENOMEM;
 		goto out1;
 	}
-#ifdef CONFIG_MACH_MX35_3DS
-	/* Subcribe the PMIC event */
-	sdhci_pmic_cd_callback.func = sdhci_pmic_cd_func;
-	sdhci_pmic_cd_callback.param = host;
-	CHECK_ERROR(pmic_event_subscribe
-		    (EVENT_SD1_DET, sdhci_pmic_cd_callback));
-
-	sdhci_pmic_wp_callback.func = sdhci_pmic_wp_func;
-	sdhci_pmic_wp_callback.param = host;
-	CHECK_ERROR(pmic_event_subscribe
-		    (EVENT_SD1_WP, sdhci_pmic_wp_callback));
-#else
 	host->detect_irq = platform_get_irq(pdev, 1);
 	if (!host->detect_irq) {
 		ret = -ENOMEM;
@@ -1614,7 +1558,12 @@ static int __devinit sdhci_probe_slot(struct platform_device
 		else
 			set_irq_type(host->detect_irq, IRQT_RISING);
 	} while (ret != host->plat_data->status(host->mmc->parent));
-#endif
+
+	ret = host->plat_data->status(host->mmc->parent);
+	if (ret)
+		host->flags &= ~SDHCI_CD_PRESENT;
+	else
+		host->flags |= SDHCI_CD_PRESENT;
 
 	DBG("slot %d at 0x%x, irq %d\n", slot, host->res->start, host->irq);
 
@@ -1626,7 +1575,7 @@ static int __devinit sdhci_probe_slot(struct platform_device
 		goto out1;
 	}
 	host->ioaddr = (void *)ioremap(host->res->start, host->res->end -
-					host->res->start + 1);
+				       host->res->start + 1);
 	if (!host->ioaddr) {
 		ret = -ENOMEM;
 		goto out3;
@@ -1662,7 +1611,7 @@ static int __devinit sdhci_probe_slot(struct platform_device
 	 */
 	host->min_clk = mmc_plat->min_clk;
 	host->max_clk = mmc_plat->max_clk;
-	host->timeout_clk = 32 * 1000;	/* Just set the value temply. */
+	host->timeout_clk = 1024 * 1000;	/* Just set the value temply. */
 
 	/*
 	 * Set host parameters.
@@ -1740,15 +1689,14 @@ static int __devinit sdhci_probe_slot(struct platform_device
 		     sdhci_tasklet_card, (unsigned long)host);
 	tasklet_init(&host->finish_tasklet,
 		     sdhci_tasklet_finish, (unsigned long)host);
+	/* initialize the work queue */
+	INIT_WORK(&host->cd_wq, esdhc_cd_callback);
 
 	setup_timer(&host->timer, sdhci_timeout_timer, (unsigned long)host);
 
-#ifdef CONFIG_MACH_MX35_3DS
-#else
 	ret = request_irq(host->detect_irq, sdhci_cd_irq, 0, pdev->name, host);
 	if (ret)
 		goto out4;
-#endif
 
 	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED, pdev->name, host);
 	if (ret)
@@ -1773,16 +1721,9 @@ static int __devinit sdhci_probe_slot(struct platform_device
 out6:
 	free_irq(host->irq, host);
 out5:
-#ifdef CONFIG_MACH_MX35_3DS
-	CHECK_ERROR(pmic_event_unsubscribe
-		    (EVENT_SD1_DET, sdhci_pmic_cd_callback));
-	CHECK_ERROR(pmic_event_unsubscribe
-		    (EVENT_SD1_WP, sdhci_pmic_wp_callback));
-#else
 	if (host->detect_irq)
 		free_irq(host->detect_irq, host);
 out4:
-#endif
 	del_timer_sync(&host->timer);
 	tasklet_kill(&host->card_tasklet);
 	tasklet_kill(&host->finish_tasklet);
@@ -1814,13 +1755,8 @@ static void sdhci_remove_slot(struct platform_device *pdev, int slot)
 
 	sdhci_reset(host, SDHCI_RESET_ALL);
 
-#ifdef CONFIG_MACH_MX35_3DS
-	pmic_event_unsubscribe(EVENT_SD1_DET, sdhci_pmic_cd_callback);
-	pmic_event_unsubscribe(EVENT_SD1_WP, sdhci_pmic_wp_callback);
-#else
 	if (host->detect_irq)
 		free_irq(host->detect_irq, host);
-#endif
 	free_irq(host->irq, host);
 	if (chip->quirks & SDHCI_QUIRK_EXTERNAL_DMA_MODE)
 		mxc_dma_free(host->dma);
@@ -1855,7 +1791,7 @@ static int sdhci_probe(struct platform_device *pdev)
 
 	/* Distinguish different platform */
 	if (machine_is_mx37_3ds()) {
-		mxc_quirks = SDHCI_QUIRK_EXTERNAL_DMA_MODE;
+		mxc_quirks = SDHCI_QUIRK_ONLY_PIO;
 	} else {
 		mxc_quirks = SDHCI_QUIRK_INTERNAL_ADVANCED_DMA |
 		    SDHCI_QUIRK_INTERNAL_SIMPLE_DMA;
diff --git a/drivers/mmc/host/mx_sdhci.h b/drivers/mmc/host/mx_sdhci.h
index 8d60765..d66d0ce 100644
--- a/drivers/mmc/host/mx_sdhci.h
+++ b/drivers/mmc/host/mx_sdhci.h
@@ -67,6 +67,7 @@
 #define  SDHCI_CTRL_4BITBUS	0x00000002
 #define  SDHCI_CTRL_HISPD	0x00000004
 #define  SDHCI_CTRL_D3CD 	0x00000008
+#define  SDHCI_CTRL_ADMA 	0x00000100
 /* wake up control */
 #define  SDHCI_CTRL_WECINS 	0x04000000
 
@@ -126,6 +127,8 @@
 		SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL | \
 		SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_DATA_CRC | \
 		SDHCI_INT_DATA_END_BIT | SDHCI_INT_DMAERR)
+#define  SDHCI_INT_DATA_RE_MASK	(SDHCI_INT_DMA_END | \
+		SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL)
 
 #define SDHCI_ACMD12_ERR	0x3C
 
@@ -147,7 +150,7 @@
 
 /* 44-47 reserved for more caps */
 #define SDHCI_WML 		0x44
-#define  SDHCI_WML_4_WORDS 	0x00010001
+#define  SDHCI_WML_4_WORDS 	0x00040004
 #define  SDHCI_WML_16_WORDS 	0x00100010
 #define  SDHCI_WML_64_WORDS 	0x00400040
 #define  SDHCI_WML_128_WORDS 	0x00800080
@@ -184,7 +187,7 @@ struct sdhci_host {
 
 	unsigned int clock;	/* Current clock (MHz) */
 	unsigned short power;	/* Current voltage */
-	struct regulator *regulator_mmc; 	/*! Regulator */
+	struct regulator *regulator_mmc;	/*! Regulator */
 
 	struct mmc_request *mrq;	/* Current request */
 	struct mmc_command *cmd;	/* Current command */
@@ -213,6 +216,7 @@ struct sdhci_host {
 
 	struct tasklet_struct card_tasklet;	/* Tasklet structures */
 	struct tasklet_struct finish_tasklet;
+	struct work_struct cd_wq;
 
 	struct timer_list timer;	/* Timer for timeouts */
 	/* Platform specific data */
-- 
1.5.4.4

