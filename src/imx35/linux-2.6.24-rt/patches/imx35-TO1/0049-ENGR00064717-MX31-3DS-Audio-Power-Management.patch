From 6e24d1c1c67420caa8edcfc73005c48408b7713f Mon Sep 17 00:00:00 2001
From: Wallace Wang <r59996@freescale.com>
Date: Wed, 5 Mar 2008 13:39:33 +0800
Subject: [PATCH] ENGR00064717 MX31 3DS Audio Power Management

MX31 3DS audio power management support

Signed-off-by: Wallace Wang <r59996@freescale.com>
---
 arch/arm/mach-mx3/devices.c           |   21 ++++++++---
 arch/arm/mach-mx3/mx31ads.c           |   15 --------
 arch/arm/mach-mx3/mx3_3stack.c        |   13 -------
 arch/arm/plat-mxc/clock.c             |   10 +++---
 drivers/mxc/pmic/mc13783/pmic_audio.c |   64 ++++++++++++++++++++++++++++++++-
 include/asm-arm/arch-mxc/mxc.h        |    1 +
 include/asm-arm/arch-mxc/pmic_audio.h |   15 +++++++-
 sound/arm/mxc-alsa-pmic.c             |   26 +++++++++++++-
 8 files changed, 124 insertions(+), 41 deletions(-)

diff --git a/arch/arm/mach-mx3/devices.c b/arch/arm/mach-mx3/devices.c
index 550928e..e983bd5 100644
--- a/arch/arm/mach-mx3/devices.c
+++ b/arch/arm/mach-mx3/devices.c
@@ -9,7 +9,7 @@
  * licensed "as is" without any warranty of any kind, whether express
  * or implied.
  *
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -20,6 +20,7 @@
 #include <linux/spi/spi.h>
 
 #include <asm/hardware.h>
+#include <asm/mach-types.h>
 #include <asm/arch/pmic_external.h>
 #include <asm/arch/pmic_power.h>
 #include <asm/arch/mmc.h>
@@ -249,10 +250,7 @@ static inline void mxc_init_ipu(void)
 #endif
 
 #if  defined(CONFIG_SND_MXC_PMIC) || defined(CONFIG_SND_MXC_PMIC_MODULE)
-static struct mxc_audio_platform_data mxc_audio_data = {
-	.ssi_num = 2,
-	.src_port = 0,
-};
+static struct mxc_audio_platform_data mxc_audio_data;
 
 static struct platform_device mxc_alsa_device = {
 	.name = "mxc_alsa",
@@ -266,6 +264,19 @@ static struct platform_device mxc_alsa_device = {
 
 static void mxc_init_audio(void)
 {
+	struct clk *pll_clk;
+	pll_clk = clk_get(NULL, "usb_pll");
+	mxc_audio_data.ssi_clk[0] = clk_get(NULL, "ssi_clk.0");
+	clk_set_parent(mxc_audio_data.ssi_clk[0], pll_clk);
+	if (machine_is_mx31_3ds()) {
+		mxc_audio_data.ssi_num = 1;
+	} else {
+		mxc_audio_data.ssi_num = 2;
+		mxc_audio_data.ssi_clk[1] = clk_get(NULL, "ssi_clk.1");
+		clk_set_parent(mxc_audio_data.ssi_clk[1], pll_clk);
+	}
+	clk_put(pll_clk);
+	mxc_audio_data.src_port = 0;
 	platform_device_register(&mxc_alsa_device);
 }
 #else
diff --git a/arch/arm/mach-mx3/mx31ads.c b/arch/arm/mach-mx3/mx31ads.c
index 7a8cd61..8c61c7d 100644
--- a/arch/arm/mach-mx3/mx31ads.c
+++ b/arch/arm/mach-mx3/mx31ads.c
@@ -619,8 +619,6 @@ extern void gpio_activate_audio_ports(void);
 
 static void __init mxc_init_pmic_audio(void)
 {
-	struct clk *pll_clk;
-	struct clk *ssi_clk;
 	struct clk *ckih_clk;
 	struct clk *cko_clk;
 
@@ -637,19 +635,6 @@ static void __init mxc_init_pmic_audio(void)
 	clk_put(ckih_clk);
 	clk_put(cko_clk);
 
-	/* Assign USBPLL to be used by SSI1/2 */
-	pll_clk = clk_get(NULL, "usb_pll");
-	ssi_clk = clk_get(NULL, "ssi_clk.0");
-	clk_set_parent(ssi_clk, pll_clk);
-	clk_enable(ssi_clk);
-	clk_put(ssi_clk);
-
-	ssi_clk = clk_get(NULL, "ssi_clk.1");
-	clk_set_parent(ssi_clk, pll_clk);
-	clk_enable(ssi_clk);
-	clk_put(ssi_clk);
-	clk_put(pll_clk);
-
 	gpio_activate_audio_ports();
 }
 #else
diff --git a/arch/arm/mach-mx3/mx3_3stack.c b/arch/arm/mach-mx3/mx3_3stack.c
index b85bb41..410473a 100644
--- a/arch/arm/mach-mx3/mx3_3stack.c
+++ b/arch/arm/mach-mx3/mx3_3stack.c
@@ -474,8 +474,6 @@ static int __init mxc_expio_init(void)
 #if defined(CONFIG_MXC_PMIC_MC13783) && defined(CONFIG_SND_MXC_PMIC)
 static void __init mxc_init_pmic_audio(void)
 {
-	struct clk *pll_clk;
-	struct clk *ssi_clk;
 	struct clk *ckih_clk;
 	struct clk *cko_clk;
 
@@ -492,17 +490,6 @@ static void __init mxc_init_pmic_audio(void)
 	clk_put(ckih_clk);
 	clk_put(cko_clk);
 
-	/* Assign USBPLL to be used by SSI1/2 */
-	pll_clk = clk_get(NULL, "usb_pll");
-	ssi_clk = clk_get(NULL, "ssi_clk.0");
-	clk_set_parent(ssi_clk, pll_clk);
-	clk_put(ssi_clk);
-
-	ssi_clk = clk_get(NULL, "ssi_clk.1");
-	clk_set_parent(ssi_clk, pll_clk);
-	clk_put(ssi_clk);
-	clk_put(pll_clk);
-
 	/* config Audio ports (4 & 5) */
 	mxc_request_iomux(MX31_PIN_SCK4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
 	mxc_request_iomux(MX31_PIN_SRXD4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
diff --git a/arch/arm/plat-mxc/clock.c b/arch/arm/plat-mxc/clock.c
index 0b22809..a4da645 100644
--- a/arch/arm/plat-mxc/clock.c
+++ b/arch/arm/plat-mxc/clock.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2007-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -70,7 +70,7 @@ static DEFINE_SPINLOCK(clockfw_lock);
 struct clk *clk_get(struct device *dev, const char *id)
 {
 	struct clk *p, *clk = ERR_PTR(-ENOENT);
-	int idno;
+	int idno, len;
 	char *str;
 
 	if (id == NULL)
@@ -93,12 +93,12 @@ struct clk *clk_get(struct device *dev, const char *id)
 
 	str = strrchr(id, '.');
 	if (str) {
-		str[0] = '\0';
+		len = str - id;
 		str++;
 		idno = simple_strtol(str, NULL, 10);
 		list_for_each_entry(p, &clocks, node) {
-			if (p->id == idno &&
-			    strcmp(id, p->name) == 0 &&
+			if (p->id == idno && (strlen(p->name) == len) &&
+			    strncmp(id, p->name, len) == 0 &&
 			    try_module_get(p->owner)) {
 				clk = p;
 				goto found;
diff --git a/drivers/mxc/pmic/mc13783/pmic_audio.c b/drivers/mxc/pmic/mc13783/pmic_audio.c
index 0a434c7..9f53d2f 100644
--- a/drivers/mxc/pmic/mc13783/pmic_audio.c
+++ b/drivers/mxc/pmic/mc13783/pmic_audio.c
@@ -131,7 +131,7 @@ EXPORT_SYMBOL(pmic_audio_output_get_config);
 EXPORT_SYMBOL(pmic_audio_output_enable_phantom_ground);
 EXPORT_SYMBOL(pmic_audio_output_disable_phantom_ground);
 EXPORT_SYMBOL(pmic_audio_set_autodetect);
-
+EXPORT_SYMBOL(pmic_audio_fm_output_enable);
 #ifdef DEBUG_AUDIO
 EXPORT_SYMBOL(pmic_audio_dump_registers);
 #endif				/* DEBUG_AUDIO */
@@ -1304,12 +1304,25 @@ PMIC_STATUS pmic_audio_enable(const PMIC_AUDIO_HANDLE handle)
 	const unsigned int STDAC_ENABLE = SET_BITS(regST_DAC, STDCEN, 1);
 	const unsigned int VCODEC_ENABLE = SET_BITS(regAUD_CODEC, CDCEN, 1);
 	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	unsigned int reg_write = 0;
+	unsigned int reg_mask = 0;
 
 	/* Use a critical section to ensure a consistent hardware state. */
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
 	if ((handle == stDAC.handle) && (stDAC.handleState == HANDLE_IN_USE)) {
+		pmic_write_reg(REG_AUDIO_RX_0, AUDIO_BIAS_ENABLE,
+			       AUDIO_BIAS_ENABLE);
+		reg_mask =
+		    SET_BITS(regAUDIO_RX_0, HSDETEN,
+			     1) | SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+		reg_write =
+		    SET_BITS(regAUDIO_RX_0, HSDETEN,
+			     1) | SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+		rc = pmic_write_reg(REG_AUDIO_RX_0, reg_write, reg_mask);
+		if (rc == PMIC_SUCCESS)
+			pr_debug("pmic_audio_enable\n");
 		/* We can enable the Stereo DAC. */
 		rc = pmic_write_reg(REG_AUDIO_STEREO_DAC,
 				    STDAC_ENABLE, STDAC_ENABLE);
@@ -1323,6 +1336,12 @@ PMIC_STATUS pmic_audio_enable(const PMIC_AUDIO_HANDLE handle)
 		/* Must first set the audio bias bit to power up the audio circuits. */
 		pmic_write_reg(REG_AUDIO_RX_0, AUDIO_BIAS_ENABLE,
 			       AUDIO_BIAS_ENABLE);
+		reg_mask = SET_BITS(regAUDIO_RX_0, HSDETEN, 1) |
+		    SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+		reg_write = SET_BITS(regAUDIO_RX_0, HSDETEN, 1) |
+		    SET_BITS(regAUDIO_RX_0, HSDETAUTOB, 1);
+		rc = pmic_write_reg(REG_AUDIO_RX_0, reg_write, reg_mask);
+
 		/* Then we can enable the Voice CODEC. */
 		rc = pmic_write_reg(REG_AUDIO_CODEC, VCODEC_ENABLE,
 				    VCODEC_ENABLE);
@@ -5738,6 +5757,49 @@ static PMIC_STATUS pmic_audio_deregister(void *callback,
 	return rc;
 }
 
+/*!
+ * @brief enable/disable fm output.
+ *
+ * @param[in]   enable            true to enable false to disable
+ */
+PMIC_STATUS pmic_audio_fm_output_enable(bool enable)
+{
+	unsigned int reg_mask = 0;
+	unsigned int reg_write = 0;
+	PMIC_STATUS rc = PMIC_PARAMETER_ERROR;
+	if (enable) {
+		pmic_audio_antipop_enable(ANTI_POP_RAMP_FAST);
+		reg_mask |= SET_BITS(regAUDIO_RX_0, AHSLEN, 1);
+		reg_write |= SET_BITS(regAUDIO_RX_0, AHSLEN, 1);
+		reg_mask |= SET_BITS(regAUDIO_RX_0, AHSREN, 1);
+		reg_write |= SET_BITS(regAUDIO_RX_0, AHSREN, 1);
+
+		reg_mask |= SET_BITS(regAUDIO_RX_0, AHSSEL, 1);
+		reg_write |= SET_BITS(regAUDIO_RX_0, AHSSEL, 1);
+
+		reg_mask |= SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+		reg_write |= SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+
+		reg_mask |= SET_BITS(regAUDIO_RX_0, HSPGDIS, 1);
+		reg_write |= SET_BITS(regAUDIO_RX_0, HSPGDIS, 0);
+	} else {
+		reg_mask |= SET_BITS(regAUDIO_RX_0, ADDRXIN, 1);
+		reg_write |= SET_BITS(regAUDIO_RX_0, ADDRXIN, 0);
+	}
+	rc = pmic_write_reg(REG_AUDIO_RX_0, reg_write, reg_mask);
+	if (rc != PMIC_SUCCESS)
+		return rc;
+	if (enable) {
+		reg_mask = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+		reg_write = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+	} else {
+		reg_mask = SET_BITS(regAUDIO_RX_1, ARXINEN, 1);
+		reg_write = SET_BITS(regAUDIO_RX_1, ARXINEN, 0);
+	}
+	rc = pmic_write_reg(REG_AUDIO_RX_1, reg_write, reg_mask);
+	return rc;
+}
+
 /*@}*/
 
 /**************************************************************************
diff --git a/include/asm-arm/arch-mxc/mxc.h b/include/asm-arm/arch-mxc/mxc.h
index 8600ef5..de544aa 100644
--- a/include/asm-arm/arch-mxc/mxc.h
+++ b/include/asm-arm/arch-mxc/mxc.h
@@ -82,6 +82,7 @@ struct mxc_audio_platform_data {
 	int ssi_num;
 	int src_port;
 	int ext_port;
+	struct clk *ssi_clk[2];
 	char *regulator1;
 	char *regulator2;
 };
diff --git a/include/asm-arm/arch-mxc/pmic_audio.h b/include/asm-arm/arch-mxc/pmic_audio.h
index b601573..2e0e2d1 100644
--- a/include/asm-arm/arch-mxc/pmic_audio.h
+++ b/include/asm-arm/arch-mxc/pmic_audio.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -2295,6 +2295,19 @@ PMIC_STATUS pmic_audio_output_enable_phantom_ground(void);
  */
 PMIC_STATUS pmic_audio_output_disable_phantom_ground(void);
 
+/*!
+ * @brief Enable/Disable fm output
+ *
+ * This function enables/disables the fm output.
+ *
+ * @param[in]   enable		     True to enable and false to disable
+ *
+ * @retval      PMIC_SUCCESS         If the fm output  was
+ *                                   successfully enable or disabled
+ * @retval      PMIC_ERROR           If the operation fails
+ */
+PMIC_STATUS pmic_audio_fm_output_enable(bool enable);
+
 /*@}*/
 
 #endif				/* __KERNEL__ */
diff --git a/sound/arm/mxc-alsa-pmic.c b/sound/arm/mxc-alsa-pmic.c
index 1f745f3..6392c59 100644
--- a/sound/arm/mxc-alsa-pmic.c
+++ b/sound/arm/mxc-alsa-pmic.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -66,6 +66,8 @@
 #include "mxc-alsa-pmic.h"
 #include "mxc-alsa-common.h"
 #include <linux/fs.h>
+#include <linux/clk.h>
+
 /*
  * PMIC driver buffer policy.
  * Customize here if the sound is not correct
@@ -2784,6 +2786,7 @@ static int snd_card_mxc_audio_playback_open(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime;
 	int stream_id = -1;
 	int err;
+	audio_stream_t *s;
 	PMIC_AUDIO_HANDLE temp_handle;
 	int device = -1;
 
@@ -2799,6 +2802,7 @@ static int snd_card_mxc_audio_playback_open(struct snd_pcm_substream *substream)
 		stream_id = 3;
 	}
 
+	s = &chip->s[stream_id];
 	err = -1;
 
 	if (stream_id == 0) {
@@ -2893,6 +2897,10 @@ static int snd_card_mxc_audio_playback_open(struct snd_pcm_substream *substream)
 				     audio_playback_dma_callback,
 				     stream_id)) < 0)
 		goto exit_err;
+
+	/* enable ssi clock */
+	clk_enable(audio_data->ssi_clk[s->ssi]);
+
 	return 0;
       exit_err:
 #ifdef CONFIG_SND_MXC_PMIC_IRAM
@@ -2968,6 +2976,8 @@ static int snd_card_mxc_audio_playback_close(struct snd_pcm_substream
 	if (stream_id == 0)
 		mxc_snd_pcm_iram_put();
 #endif				/*CONFIG_SND_MXC_PMIC_IRAM */
+	/* disable ssi clock */
+	clk_disable(audio_data->ssi_clk[ssi]);
 
 	return 0;
 }
@@ -3007,6 +3017,9 @@ static int snd_card_mxc_audio_capture_close(struct snd_pcm_substream *substream)
 
 	chip->s[substream->pstr->stream].stream = NULL;
 
+	/* disable ssi clock */
+	clk_disable(audio_data->ssi_clk[ssi]);
+
 	return 0;
 }
 
@@ -3156,10 +3169,12 @@ static int snd_card_mxc_audio_capture_open(struct snd_pcm_substream *substream)
 	int stream_id;
 	int err;
 	PMIC_AUDIO_HANDLE temp_handle;
+	audio_stream_t *s;
 
 	chip = snd_pcm_substream_chip(substream);
 	runtime = substream->runtime;
 	stream_id = substream->pstr->stream;
+	s = &chip->s[stream_id];
 	err = -1;
 
 	if ((audio_data->ssi_num == 1)
@@ -3207,6 +3222,9 @@ static int snd_card_mxc_audio_capture_open(struct snd_pcm_substream *substream)
 		return err;
 	}
 
+	/* enable ssi clock */
+	clk_enable(audio_data->ssi_clk[s->ssi]);
+
 	msleep(50);
 
 	return 0;
@@ -3824,6 +3842,12 @@ static int __init mxc_alsa_audio_probe(struct platform_device *pdev)
 
 static int mxc_alsa_audio_remove(struct platform_device *dev)
 {
+	if (audio_data->ssi_num == 1) {
+		clk_put(audio_data->ssi_clk[SSI1]);
+	} else {
+		clk_put(audio_data->ssi_clk[SSI1]);
+		clk_put(audio_data->ssi_clk[SSI2]);
+	}
 	snd_card_free(mxc_audio->card);
 	kfree(mxc_audio);
 	platform_set_drvdata(dev, NULL);
-- 
1.5.4.4

