From 03eb90cc35535852cb4a1c93e76d7f0f6b3ddfdf Mon Sep 17 00:00:00 2001
From: Bruce Schmid <duck@freescale.com>
Date: Fri, 6 Jun 2008 15:13:14 -0600
Subject: [PATCH] ENGR00083330-3 Integrate Devtech's USB code patch 3/12

USB: mxc gadget support

Signed-off-by: Bruce Schmid <duck@freescale.com>
---
 drivers/usb/gadget/Kconfig        |   72 +-
 drivers/usb/gadget/arcotg_udc.c   | 3195 ++++++++++++++++---------------------
 drivers/usb/gadget/arcotg_udc.h   |  108 +-
 drivers/usb/gadget/gadget_chips.h |    2 +-
 4 files changed, 1501 insertions(+), 1876 deletions(-)

diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 4f2ccf6..fdccd0c 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -275,14 +275,12 @@ config USB_OMAP
 	select USB_GADGET_SELECTED
 
 config USB_GADGET_ARC
-	boolean "ARC USB Device Controller"
+	boolean "Freescale USB Device Controller"
 	depends on ARCH_MXC
-	select USB_GADGET_DUALSPEED
-	select USB_GADGET_ARC_OTGHS if USB_EHCI_ARC_OTGHS
-	select USB_GADGET_ARC_OTGFS if USB_EHCI_ARC_OTGFS
+	select USB_GADGET_DUALSPEED if USB_GADGET_FSL_1504 || USB_GADGET_FSL_UTMI
 	help
-	   Some Freescale processors have an ARC High Speed
-	   USBOTG controller, which supports device mode.
+	   Some Freescale processors have a USBOTG controller,
+	   which supports device mode.
 
 	   Say "y" to link the driver statically, or "m" to build a
 	   dynamically linked module called "arc_udc" and force all
@@ -370,7 +368,8 @@ endchoice
 config USB_OTG
 	boolean "OTG Support"
 	depends on (USB_GADGET_OMAP && ARCH_OMAP_OTG && USB_OHCI_HCD) || \
-		   (USB_GADGET_ARC && (ARCH_MX3 || ARCH_MX27 || ARCH_MXC91221) && USB_EHCI_HCD)
+		   (USB_GADGET_ARC && (ARCH_MX3 || ARCH_MX27 || ARCH_MXC91221) && \
+		   USB_EHCI_HCD)
 	help
 	   The most notable feature of USB OTG is support for a
 	   "Dual-Role" device, which can act as either a device
@@ -388,35 +387,54 @@ config USB_GADGET_DUALSPEED
 	  and code to handle dual-speed controllers.
 
 config USB_GADGET_ARC_OTG
-	bool "Support for OTG prepheral port on ARC controller"
+	bool "Support for DR peripheral port on Freescale controller"
 	depends on USB_GADGET_ARC
 	default y
-	---help---
-	  Enable support for the USB OTG port in HS/FS prepheral mode.
+	help
+	  Enable support for the Freescale Dual Role port in peripheral mode.
 
 choice
-	prompt "Select transceiver"
+	prompt "Select transceiver for DR port"
 	depends on USB_GADGET_ARC_OTG
-
-config USB_GADGET_ARC_OTGFS
-	bool "Full Speed"
-	depends on !USB_EHCI_ARC_OTGHS
 	help
-	  The ARC OTG controller can be connected to either a FS or
-	  a HS transceiver.
+	  Choose the transceiver to use with the Freescale DR port.
 
-	  Enable this configuration option if you want to use the FS
-	  transceiver.
+config USB_GADGET_FSL_MC13783
+	bool "Freescale MC13783"
+	depends on !USB_EHCI_FSL_1301 && !USB_EHCI_FSL_1504 && !USB_EHCI_FSL_UTMI
+	---help---
+	  Enable support for the Full Speed Freescale MC13783 transceiver.
 
-config USB_GADGET_ARC_OTGHS
-	bool "High Speed"
-	depends on !USB_EHCI_ARC_OTGFS
-	help
-	  The ARC OTG controller can be connected to either a FS or
-	  a HS transceiver.
+	  The mx27ads, mx31ads and mx32ads boards require modifications
+	  to support this transceiver.
+
+config USB_GADGET_FSL_1301
+	bool "Philips ISP1301"
+	depends on !USB_EHCI_FSL_MC13783 && !USB_EHCI_FSL_1504 && !USB_EHCI_FSL_UTMI
+	---help---
+	  Enable support for the Full Speed Philips ISP1301 transceiver.
+
+	  This is the factory default for the mx27ads board.
+	  The mx31ads and mx32ads boards require modifications
+	  to support this transceiver.
+
+config USB_GADGET_FSL_1504
+	bool "Philips ISP1504"
+	depends on !USB_EHCI_FSL_MC13783 && !USB_EHCI_FSL_1301 && !USB_EHCI_FSL_UTMI
+	---help---
+	  Enable support for the High Speed Philips ISP1504 transceiver.
+
+	  This is the factory default for the mx31ads and mx32ads boards.
+	  The mx27ads board requires modifications to support this transceiver.
+
+config USB_GADGET_FSL_UTMI
+	bool "On-chip UTMI"
+	depends on !USB_EHCI_FSL_MC13783 && !USB_EHCI_FSL_1301 && !USB_EHCI_FSL_1504
+	---help---
+	  Enable support for the High Speed Philips ISP1504 transceiver.
+
+	  This is the factory default for the mx35 board.
 
-	  Enable this configuration option if you want to use the HS
-	  transceiver.
 endchoice
 
 #
diff --git a/drivers/usb/gadget/arcotg_udc.c b/drivers/usb/gadget/arcotg_udc.c
index 6511177..c22d789 100644
--- a/drivers/usb/gadget/arcotg_udc.c
+++ b/drivers/usb/gadget/arcotg_udc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -11,21 +11,8 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
-/*!
- * @file arcotg_udc.c
- * @brief arc otg device controller driver
- * @ingroup USB
- */
-
-/*!
- * Include files
- */
-
-#if 0
-#define	DEBUG
-#define VERBOSE
-#define DUMP_QUEUES
-#endif
+#undef DEBUG
+#undef VERBOSE
 
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -41,96 +28,90 @@
 #include <linux/interrupt.h>
 #include <linux/proc_fs.h>
 #include <linux/mm.h>
-#include <linux/platform_device.h>
-#include <linux/dma-mapping.h>
-#include <linux/dmapool.h>
-#include <linux/fsl_devices.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
-#include <linux/usb/fsl_xcvr.h>
 #include <linux/usb/otg.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/dmapool.h>
 
 #include <asm/byteorder.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/system.h>
+#include <asm/unaligned.h>
 #include <asm/dma.h>
+#include <asm/cacheflush.h>
 
 #include "arcotg_udc.h"
 #include <asm/arch/arc_otg.h>
 
-extern void gpio_usbotg_hs_active(void);
-extern void gpio_usbotg_fs_active(void);
-
-static void Ep0Stall(struct arcotg_udc *);
-static int ep0_prime_status(struct arcotg_udc *, int);
-
-static int timeout;
-
-#undef	USB_TRACE
-
 #define	DRIVER_DESC	"ARC USBOTG Device Controller driver"
 #define	DRIVER_AUTHOR	"Freescale Semiconductor"
 #define	DRIVER_VERSION	"1 August 2005"
 
-#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
+#ifdef CONFIG_PPC_MPC512x
+#define BIG_ENDIAN_DESC
+#endif
 
-/*#define DEBUG_FORCE_FS 1 */
+#ifdef BIG_ENDIAN_DESC
+#define cpu_to_hc32(x)	(x)
+#define hc32_to_cpu(x)	(x)
+#else
+#define cpu_to_hc32(x)	cpu_to_le32((x))
+#define hc32_to_cpu(x)	le32_to_cpu((x))
+#endif
+
+#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
 
-static const char driver_name[] = "arc_udc";
+static const char driver_name[] = "fsl-usb2-udc";
 static const char driver_desc[] = DRIVER_DESC;
 
-volatile static struct usb_dr_device *usb_slave_regs;
+volatile static struct usb_dr_device *dr_regs;
+volatile static struct usb_sys_interface *usb_sys_regs;
 
 /* it is initialized in probe()  */
-static struct arcotg_udc *udc_controller;
-
-/* workqueue function for using msleep to allow the USB HW to go into a
-  * test mode */
-static struct delayed_work usbhset_work;
-
-/*ep name is important in gadget, it should obey the convention of ep_match()*/
-/* even numbered EPs are OUT or setup, odd are IN/INTERRUPT */
-static const char *const ep_name[] = {
-	"ep0-control", NULL,	/* everyone has ep0 */
-	/* 7 configurable endpoints */
-	"ep1out",
-	"ep1in",
-	"ep2out",
-	"ep2in",
-	"ep3out",
-	"ep3in",
-	"ep4out",
-	"ep4in",
-	"ep5out",
-	"ep5in",
-	"ep6out",
-	"ep6in",
-	"ep7out",
-	"ep7in"
+static struct fsl_udc *udc_controller;
+
+static const struct usb_endpoint_descriptor
+fsl_ep0_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	0,
+	.bmAttributes =		USB_ENDPOINT_XFER_CONTROL,
+	.wMaxPacketSize =	USB_MAX_CTRL_PAYLOAD,
 };
-static const struct usb_endpoint_descriptor arcotg_ep0_desc = {
-	.bLength = USB_DT_ENDPOINT_SIZE,
-	.bDescriptorType = USB_DT_ENDPOINT,
 
-	.bEndpointAddress = 0,
-	.bmAttributes = USB_ENDPOINT_XFER_CONTROL,
-	.wMaxPacketSize = USB_MAX_CTRL_PAYLOAD,
-};
+static int udc_suspend(struct fsl_udc *udc);
+static int fsl_udc_suspend(struct device *dev, pm_message_t state);
+static int fsl_udc_resume(struct device *dev);
+static void fsl_ep_fifo_flush(struct usb_ep *_ep);
+
+#ifdef CONFIG_USB_OTG
+/* Get platform resource from OTG driver */
+extern struct resource *otg_get_resources(void);
+#endif
 
-static int udc_suspend(struct arcotg_udc *udc);
-static int arcotg_udc_suspend(struct device *dev, pm_message_t state);
-static int arcotg_udc_resume(struct device *dev);
+#ifdef CONFIG_PPC32
+#define fsl_readl(addr)		in_le32((addr))
+#define fsl_writel(addr, val32) out_le32((val32), (addr))
+#else
+#define fsl_readl(addr)		readl((addr))
+#define fsl_writel(addr, val32) writel((addr), (val32))
+#endif
 
 /********************************************************************
- * 	Internal Used Function
+ *	Internal Used Function
 ********************************************************************/
 
 #ifdef DUMP_QUEUES
-static void dump_ep_queue(struct arcotg_ep *ep)
+static void dump_ep_queue(struct fsl_ep *ep)
 {
 	int ep_index;
-	struct arcotg_req *req;
+	struct fsl_req *req;
 	struct ep_td_struct *dtd;
 
 	if (list_empty(&ep->queue)) {
@@ -157,36 +138,25 @@ static void dump_ep_queue(struct arcotg_ep *ep)
 	}
 }
 #else
-static inline void dump_ep_queue(struct arcotg_ep *ep)
+static inline void dump_ep_queue(struct fsl_ep *ep)
 {
 }
 #endif
 
-/*!
+/*-----------------------------------------------------------------
  * done() - retire a request; caller blocked irqs
- * @param ep      endpoint pointer
- * @param req     require pointer
- * @param status  when req->req.status is -EINPROGRESSS, it is input para
- *	     else it will be a output parameter
- * req->req.status : in ep_queue() it will be set as -EINPROGRESS
- */
-static void done(struct arcotg_ep *ep, struct arcotg_req *req, int status)
+ * @status : request status to be set, only works when
+ *	request is still in progress.
+ *--------------------------------------------------------------*/
+static void done(struct fsl_ep *ep, struct fsl_req *req, int status)
 {
-	struct arcotg_udc *udc = NULL;
+	struct fsl_udc *udc = NULL;
 	unsigned char stopped = ep->stopped;
+	struct ep_td_struct *curr_td, *next_td;
+	int j;
 
-	udc = (struct arcotg_udc *)ep->udc;
-
-	pr_debug("udc: req=0x%p\n", req);
-	if (req->head) {
-		pr_debug("udc: freeing head=0x%p\n", req->head);
-		dma_pool_free(udc->dtd_pool, req->head, req->head->td_dma);
-	}
-
-	/* the req->queue pointer is used by ep_queue() func, in which
-	 * the request will be added into a udc_ep->queue 'd tail
-	 * so here the req will be dropped from the ep->queue
-	 */
+	udc = (struct fsl_udc *)ep->udc;
+	/* Removed the req from fsl_ep->queue */
 	list_del_init(&req->queue);
 
 	/* req.status should be set as -EINPROGRESS in ep_queue() */
@@ -195,78 +165,64 @@ static void done(struct arcotg_ep *ep, struct arcotg_req *req, int status)
 	else
 		status = req->req.status;
 
-	pr_debug("udc: req=0x%p  mapped=%x\n", req, req->mapped);
+	/* Free dtd for the request */
+	next_td = req->head;
+	for (j = 0; j < req->dtd_count; j++) {
+		curr_td = next_td;
+		if (j != req->dtd_count - 1)
+			next_td = curr_td->next_td_virt;
 
-	if (req->mapped) {
-		pr_debug("udc: calling dma_unmap_single(buf,%s)  req=0x%p  "
-			 "a=0x%x  len=%d\n",
-			 ep_is_in(ep) ? "to_dvc" : "from_dvc",
-			 req, req->req.dma, req->req.length);
+		dma_pool_free(udc->td_pool, curr_td, curr_td->td_dma);
+	}
 
+	if (req->mapped) {
 		dma_unmap_single(ep->udc->gadget.dev.parent,
-				 req->req.dma, req->req.length,
-				 ep_is_in(ep) ? DMA_TO_DEVICE :
-				 DMA_FROM_DEVICE);
-
+			req->req.dma, req->req.length,
+			ep_is_in(ep)
+				? DMA_TO_DEVICE
+				: DMA_FROM_DEVICE);
 		req->req.dma = DMA_ADDR_INVALID;
 		req->mapped = 0;
-		pr_debug("udc: req=0x%p set req.dma=0x%x\n", req, req->req.dma);
-	} else {
-		if ((req->req.length != 0)
-		    && (req->req.dma != DMA_ADDR_INVALID)) {
-			pr_debug("udc: calling dma_sync_single_for_cpu(buf,%s) "
-				 "req=0x%p  dma=0x%x  len=%d\n",
-				 ep_is_in(ep) ? "to_dvc" : "from_dvc", req,
-				 req->req.dma, req->req.length);
-
-			dma_sync_single_for_cpu(ep->udc->gadget.dev.parent,
-						req->req.dma, req->req.length,
-						ep_is_in(ep) ? DMA_TO_DEVICE :
-						DMA_FROM_DEVICE);
-		}
-	}
+	} else
+		dma_sync_single_for_cpu(ep->udc->gadget.dev.parent,
+			req->req.dma, req->req.length,
+			ep_is_in(ep)
+				? DMA_TO_DEVICE
+				: DMA_FROM_DEVICE);
 
-	if (status && (status != -ESHUTDOWN)) {
-		pr_debug("udc: complete %s req 0c%p stat %d len %u/%u\n",
-			 ep->ep.name, &req->req, status,
-			 req->req.actual, req->req.length);
-	}
+	if (status && (status != -ESHUTDOWN))
+		VDBG("complete %s req %p stat %d len %u/%u",
+			ep->ep.name, &req->req, status,
+			req->req.actual, req->req.length);
 
-	/* don't modify queue heads during completion callback */
 	ep->stopped = 1;
 
 	spin_unlock(&ep->udc->lock);
-
-	/* this complete() should a func implemented by gadget layer,
+	/* complete() is from gadget layer,
 	 * eg fsg->bulk_in_complete() */
-	if (req->req.complete) {
-		pr_debug("udc: calling gadget's complete()  req=0x%p\n", req);
+	if (req->req.complete)
 		req->req.complete(&ep->ep, &req->req);
-		pr_debug("udc: back from gadget's complete()\n");
-	}
 
 	spin_lock(&ep->udc->lock);
 	ep->stopped = stopped;
 }
 
-/*!
+/*-----------------------------------------------------------------
  * nuke(): delete all requests related to this ep
- * called by ep_disable() within spinlock held
- * add status paramter?
- * @param ep endpoint pointer
- * @param status current status
- */
-static void nuke(struct arcotg_ep *ep, int status)
+ * called with spinlock held
+ *--------------------------------------------------------------*/
+static void nuke(struct fsl_ep *ep, int status)
 {
-	pr_debug("udc: ep=0x%p\n", ep);
 	ep->stopped = 1;
 
+	/* Flush fifo */
+	fsl_ep_fifo_flush(&ep->ep);
+
 	/* Whether this eq has request linked */
 	while (!list_empty(&ep->queue)) {
-		struct arcotg_req *req = NULL;
-
-		req = list_entry(ep->queue.next, struct arcotg_req, queue);
+		struct fsl_req *req = NULL;
 
+		req = list_entry(ep->queue.next, struct fsl_req, queue);
 		done(ep, req, status);
 	}
 	dump_ep_queue(ep);
@@ -275,197 +231,203 @@ static void nuke(struct arcotg_ep *ep, int status)
 /*------------------------------------------------------------------
 	Internal Hardware related function
  ------------------------------------------------------------------*/
-extern void fsl_platform_set_vbus_power(struct fsl_usb2_platform_data *pdata,
-					int on);
 
-/*
- * init device controller
- * @param  qh_addr the aligned virt addr of ep QH addr
- * @param  dev     device controller pointer
- */
-static int dr_controller_setup(struct arcotg_udc *udc)
+static int dr_controller_setup(struct fsl_udc *udc)
 {
 	unsigned int tmp = 0, portctrl = 0;
-	void *qh_addr = udc->ep_qh;
-	struct device *dev __attribute((unused)) = udc->gadget.dev.parent;
+	unsigned int __attribute((unused)) ctrl = 0;
+	unsigned long timeout;
 	struct fsl_usb2_platform_data *pdata;
 
-	pdata = udc->pdata;
-
-	pr_debug("udc: dev=0x%p\n", dev);
+#define FSL_UDC_RESET_TIMEOUT 1000
 
-	/* before here, make sure usb_slave_regs has been initialized */
-	if (!qh_addr)
+	/* before here, make sure dr_regs has been initialized */
+	if (!udc)
 		return -EINVAL;
+	pdata = udc->pdata;
 
 	/* Stop and reset the usb controller */
-	tmp = le32_to_cpu(usb_slave_regs->usbcmd);
+	tmp = fsl_readl(&dr_regs->usbcmd);
 	tmp &= ~USB_CMD_RUN_STOP;
-	usb_slave_regs->usbcmd = cpu_to_le32(tmp);
+	fsl_writel(tmp, &dr_regs->usbcmd);
 
-	tmp = le32_to_cpu(usb_slave_regs->usbcmd);
+	tmp = fsl_readl(&dr_regs->usbcmd);
 	tmp |= USB_CMD_CTRL_RESET;
-	usb_slave_regs->usbcmd = cpu_to_le32(tmp);
+	fsl_writel(tmp, &dr_regs->usbcmd);
 
 	/* Wait for reset to complete */
-	timeout = 10000000;
-	while ((le32_to_cpu(usb_slave_regs->usbcmd) & USB_CMD_CTRL_RESET) &&
-	       --timeout) {
-		continue;
-	}
-	if (timeout == 0) {
-		printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-		return -ETIMEDOUT;
+	timeout = jiffies + FSL_UDC_RESET_TIMEOUT;
+	while (fsl_readl(&dr_regs->usbcmd) & USB_CMD_CTRL_RESET) {
+		if (time_after(jiffies, timeout)) {
+			ERR("udc reset timeout! \n");
+			return -ETIMEDOUT;
+		}
+		cpu_relax();
 	}
 
 	/* Set the controller as device mode */
-	tmp = le32_to_cpu(usb_slave_regs->usbmode);
+	tmp = fsl_readl(&dr_regs->usbmode);
+	tmp &= ~USB_MODE_CTRL_MODE_MASK;	/* clear mode bits */
 	tmp |= USB_MODE_CTRL_MODE_DEVICE;
 	/* Disable Setup Lockout */
 	tmp |= USB_MODE_SETUP_LOCK_OFF;
-	usb_slave_regs->usbmode = cpu_to_le32(tmp);
+	if (pdata->es)
+		tmp |= USB_MODE_ES;
+	fsl_writel(tmp, &dr_regs->usbmode);
 
-	if (pdata->xcvr_ops && pdata->xcvr_ops->set_device)
-		pdata->xcvr_ops->set_device();
+	fsl_platform_set_device_mode(pdata);
 
 	/* Clear the setup status */
-	usb_slave_regs->usbsts = 0;
+	fsl_writel(0, &dr_regs->usbsts);
 
 	tmp = udc->ep_qh_dma;
 	tmp &= USB_EP_LIST_ADDRESS_MASK;
-	usb_slave_regs->endpointlistaddr = cpu_to_le32(tmp);
-
-	pr_debug("udc: vir[qh_base]=0x%p phy[qh_base]=0x%8x epla_reg=0x%8x\n",
-		 qh_addr, (int)tmp,
-		 le32_to_cpu(usb_slave_regs->endpointlistaddr));
-
-	portctrl = le32_to_cpu(usb_slave_regs->portsc1);
-	portctrl &= ~PORTSCX_PHY_TYPE_SEL;
+	fsl_writel(tmp, &dr_regs->endpointlistaddr);
+
+	VDBG("vir[qh_base] is %p phy[qh_base] is 0x%8x reg is 0x%8x",
+		(int)udc->ep_qh, (int)tmp,
+		fsl_readl(&dr_regs->endpointlistaddr));
+
+	/* Config PHY interface */
+	portctrl = fsl_readl(&dr_regs->portsc1);
+	portctrl &= ~(PORTSCX_PHY_TYPE_SEL | PORTSCX_PORT_WIDTH);
+	switch (udc->phy_mode) {
+	case FSL_USB2_PHY_ULPI:
+		portctrl |= PORTSCX_PTS_ULPI;
+		break;
+	case FSL_USB2_PHY_UTMI_WIDE:
+		portctrl |= PORTSCX_PTW_16BIT;
+		/* fall through */
+	case FSL_USB2_PHY_UTMI:
+		portctrl |= PORTSCX_PTS_UTMI;
+		break;
+	case FSL_USB2_PHY_SERIAL:
+		portctrl |= PORTSCX_PTS_FSLS;
+		break;
+	default:
+		return -EINVAL;
+	}
+	fsl_writel(portctrl, &dr_regs->portsc1);
 
-	portctrl |= udc->xcvr_type;
+	if (cpu_is_mx35()) {
+		/* AHB burst INCR mode if imx35 */
+		tmp = fsl_readl(&dr_regs->sbuscfg);
+		tmp &= ~0x07;
+		fsl_writel(tmp, &dr_regs->sbuscfg);
+	}
 
-#ifdef DEBUG_FORCE_FS
-	portctrl |= 0x1000000;
-#endif
+	if (pdata->have_sysif_regs) {
+		/* Config control enable i/o output, cpu endian register */
+		ctrl = __raw_readl(&usb_sys_regs->control);
+		ctrl |= USB_CTRL_IOENB;
+		__raw_writel(ctrl, &usb_sys_regs->control);
+	}
 
-	usb_slave_regs->portsc1 = cpu_to_le32(portctrl);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+	/* Turn on cache snooping hardware, since some PowerPC platforms
+	 * wholly rely on hardware to deal with cache coherent. */
 
-	/* AHB burst INCR mode if imx35 */
-	if (cpu_is_mx35()) {
-		usb_slave_regs->sbuscfg = (usb_slave_regs->sbuscfg & (~0x07));
+	if (pdata->have_sysif_regs) {
+		/* Setup Snooping for all the 4GB space */
+		tmp = SNOOP_SIZE_2GB;	/* starts from 0x0, size 2G */
+		__raw_writel(tmp, &usb_sys_regs->snoop1);
+		tmp |= 0x80000000;	/* starts from 0x8000000, size 2G */
+		__raw_writel(tmp, &usb_sys_regs->snoop2);
 	}
-
-	fsl_platform_set_vbus_power(pdata, 0);
+#endif
 
 	return 0;
 }
 
-/*!
- * just Enable DR irq reg and Set Dr controller Run
- * @param  udc  device controller pointer
- */
-
-static void dr_controller_run(struct arcotg_udc *udc)
+/* Enable DR irq and set controller to run state */
+static void dr_controller_run(struct fsl_udc *udc)
 {
-	u32 tmp;
+	u32 temp;
 
-	pr_debug("%s\n", __FUNCTION__);
+	fsl_platform_pullup_enable(udc->pdata);
 
-	/*Enable DR irq reg */
-	tmp = USB_INTR_INT_EN | USB_INTR_ERR_INT_EN |
-	    USB_INTR_PTC_DETECT_EN | USB_INTR_RESET_EN |
-	    USB_INTR_DEVICE_SUSPEND | USB_INTR_SYS_ERR_EN;
+	/* Enable DR irq reg */
+	temp = USB_INTR_INT_EN | USB_INTR_ERR_INT_EN
+		| USB_INTR_PTC_DETECT_EN | USB_INTR_RESET_EN
+		| USB_INTR_DEVICE_SUSPEND | USB_INTR_SYS_ERR_EN;
 
-	usb_slave_regs->usbintr = le32_to_cpu(tmp);
+	fsl_writel(temp, &dr_regs->usbintr);
 
 	/* Clear stopped bit */
 	udc->stopped = 0;
 
-	/* Set the controller as device mode */
-	tmp = le32_to_cpu(usb_slave_regs->usbmode);
-	tmp |= USB_MODE_CTRL_MODE_DEVICE;
-	usb_slave_regs->usbmode = cpu_to_le32(tmp);
-
 	/* Set controller to Run */
-	tmp = le32_to_cpu(usb_slave_regs->usbcmd);
-	tmp |= USB_CMD_RUN_STOP;
-	usb_slave_regs->usbcmd = le32_to_cpu(tmp);
+	temp = fsl_readl(&dr_regs->usbcmd);
+	temp |= USB_CMD_RUN_STOP;
+	fsl_writel(temp, &dr_regs->usbcmd);
 
 	return;
 }
 
-/*
- * just Disable DR irq reg and Set Dr controller Stop
- * @param  udc  device controller pointer
- */
-static void dr_controller_stop(struct arcotg_udc *udc)
+static void dr_controller_stop(struct fsl_udc *udc)
 {
 	unsigned int tmp;
 
-	pr_debug("%s\n", __FUNCTION__);
+	pr_debug("%s\n", __func__);
 
 	/* if we're in OTG mode, and the Host is currently using the port,
 	 * stop now and don't rip the controller out from under the
 	 * ehci driver
 	 */
 	if (udc->gadget.is_otg) {
-		if (!(usb_slave_regs->otgsc & OTGSC_STS_USB_ID)) {
+		if (!(fsl_readl(&dr_regs->otgsc) & OTGSC_STS_USB_ID)) {
 			pr_debug("udc: Leaving early\n");
 			return;
 		}
 	}
 
 	/* disable all INTR */
-	usb_slave_regs->usbintr = 0;
+	fsl_writel(0, &dr_regs->usbintr);
 
 	/* Set stopped bit for isr */
 	udc->stopped = 1;
 
+	/* disable IO output */
+/*	usb_sys_regs->control = 0; */
+
+	fsl_platform_pullup_disable(udc->pdata);
+
 	/* set controller to Stop */
-	tmp = le32_to_cpu(usb_slave_regs->usbcmd);
+	tmp = fsl_readl(&dr_regs->usbcmd);
 	tmp &= ~USB_CMD_RUN_STOP;
-	usb_slave_regs->usbcmd = le32_to_cpu(tmp);
+	fsl_writel(tmp, &dr_regs->usbcmd);
+
+	return;
 }
 
 void dr_ep_setup(unsigned char ep_num, unsigned char dir, unsigned char ep_type)
 {
 	unsigned int tmp_epctrl = 0;
 
-	tmp_epctrl = le32_to_cpu(usb_slave_regs->endptctrl[ep_num]);
+	tmp_epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
 	if (dir) {
 		if (ep_num)
 			tmp_epctrl |= EPCTRL_TX_DATA_TOGGLE_RST;
 		tmp_epctrl |= EPCTRL_TX_ENABLE;
-		tmp_epctrl |=
-		    ((unsigned int)(ep_type) << EPCTRL_TX_EP_TYPE_SHIFT);
+		tmp_epctrl |= ((unsigned int)(ep_type)
+				<< EPCTRL_TX_EP_TYPE_SHIFT);
 	} else {
 		if (ep_num)
 			tmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;
 		tmp_epctrl |= EPCTRL_RX_ENABLE;
-		tmp_epctrl |=
-		    ((unsigned int)(ep_type) << EPCTRL_RX_EP_TYPE_SHIFT);
+		tmp_epctrl |= ((unsigned int)(ep_type)
+				<< EPCTRL_RX_EP_TYPE_SHIFT);
 	}
 
-	usb_slave_regs->endptctrl[ep_num] = cpu_to_le32(tmp_epctrl);
-
-	/* wait for the write reg to finish */
-	timeout = 10000000;
-	while ((!(le32_to_cpu(usb_slave_regs->endptctrl[ep_num]) &
-		  (tmp_epctrl & (EPCTRL_TX_ENABLE | EPCTRL_RX_ENABLE))))
-	       && --timeout) {
-		continue;
-	}
-	if (timeout == 0) {
-		printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-	}
+	fsl_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);
 }
 
-static void dr_ep_change_stall(unsigned char ep_num, unsigned char dir,
-			       int value)
+static void
+dr_ep_change_stall(unsigned char ep_num, unsigned char dir, int value)
 {
-	unsigned int tmp_epctrl = 0;
+	u32 tmp_epctrl = 0;
 
-	tmp_epctrl = le32_to_cpu(usb_slave_regs->endptctrl[ep_num]);
+	tmp_epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
 
 	if (value) {
 		/* set the stall bit */
@@ -482,80 +444,75 @@ static void dr_ep_change_stall(unsigned char ep_num, unsigned char dir,
 			tmp_epctrl &= ~EPCTRL_RX_EP_STALL;
 			tmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;
 		}
-
 	}
-	usb_slave_regs->endptctrl[ep_num] = cpu_to_le32(tmp_epctrl);
+	fsl_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);
+}
+
+/* Get stall status of a specific ep
+   Return: 0: not stalled; 1:stalled */
+static int dr_ep_get_stall(unsigned char ep_num, unsigned char dir)
+{
+	u32 epctrl;
+
+	epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (dir)
+		return (epctrl & EPCTRL_TX_EP_STALL) ? 1 : 0;
+	else
+		return (epctrl & EPCTRL_RX_EP_STALL) ? 1 : 0;
 }
 
 /********************************************************************
 	Internal Structure Build up functions
 ********************************************************************/
 
-/*!
- * set the Endpoint Capabilites field of QH
- * @param handle  udc handler
- * @param ep_num  endpoint number
- * @param dir     in or out
- * @param ep_type USB_ENDPOINT_XFER_CONTROL or other
- * @param max_pkt_len  max packet length of this endpoint
- * @param zlt   Zero Length Termination Select
- * @param mult  Mult field
- */
-static void struct_ep_qh_setup(void *handle, unsigned char ep_num,
-			       unsigned char dir, unsigned char ep_type,
-			       unsigned int max_pkt_len,
-			       unsigned int zlt, unsigned char mult)
+/*------------------------------------------------------------------
+* struct_ep_qh_setup(): set the Endpoint Capabilites field of QH
+ * @zlt: Zero Length Termination Select (1: disable; 0: enable)
+ * @mult: Mult field
+ ------------------------------------------------------------------*/
+static void struct_ep_qh_setup(struct fsl_udc *udc, unsigned char ep_num,
+		unsigned char dir, unsigned char ep_type,
+		unsigned int max_pkt_len,
+		unsigned int zlt, unsigned char mult)
 {
-	struct arcotg_udc *udc = NULL;
-	struct ep_queue_head *p_QH = NULL;
+	struct ep_queue_head *p_QH = &udc->ep_qh[2 * ep_num + dir];
 	unsigned int tmp = 0;
 
-	udc = (struct arcotg_udc *)handle;
-
-	p_QH = &udc->ep_qh[2 * ep_num + dir];
-
-	/* set the Endpoint Capabilites Reg of QH */
+	/* set the Endpoint Capabilites in QH */
 	switch (ep_type) {
 	case USB_ENDPOINT_XFER_CONTROL:
 		/* Interrupt On Setup (IOS). for control ep  */
-		tmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS) |
-		    EP_QUEUE_HEAD_IOS;
+		tmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)
+			| EP_QUEUE_HEAD_IOS;
 		break;
 	case USB_ENDPOINT_XFER_ISOC:
-		tmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS) |
-		    (mult << EP_QUEUE_HEAD_MULT_POS);
+		tmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)
+			| (mult << EP_QUEUE_HEAD_MULT_POS);
 		break;
 	case USB_ENDPOINT_XFER_BULK:
 	case USB_ENDPOINT_XFER_INT:
 		tmp = max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS;
-		if (zlt)
-			tmp |= EP_QUEUE_HEAD_ZLT_SEL;
 		break;
 	default:
-		pr_debug("udc: error ep type is %d\n", ep_type);
+		VDBG("error ep type is %d", ep_type);
 		return;
 	}
-	p_QH->max_pkt_length = le32_to_cpu(tmp);
+	if (zlt)
+		tmp |= EP_QUEUE_HEAD_ZLT_SEL;
+	p_QH->max_pkt_length = cpu_to_hc32(tmp);
 
 	return;
 }
 
-/*!
- * This function only to make code looks good
- * it is a collection of struct_ep_qh_setup and dr_ep_setup for ep0
- * ep0 should set OK before the bind() of gadget layer
- * @param udc  device controller pointer
- */
-static void ep0_dr_and_qh_setup(struct arcotg_udc *udc)
+/* Setup qh structure and ep register for ep0. */
+static void ep0_setup(struct fsl_udc *udc)
 {
 	/* the intialization of an ep includes: fields in QH, Regs,
-	 * arcotg_ep struct */
-	struct_ep_qh_setup(udc, 0, USB_RECV,
-			   USB_ENDPOINT_XFER_CONTROL, USB_MAX_CTRL_PAYLOAD,
-			   0, 0);
-	struct_ep_qh_setup(udc, 0, USB_SEND,
-			   USB_ENDPOINT_XFER_CONTROL, USB_MAX_CTRL_PAYLOAD,
-			   0, 0);
+	 * fsl_ep struct */
+	struct_ep_qh_setup(udc, 0, USB_RECV, USB_ENDPOINT_XFER_CONTROL,
+			USB_MAX_CTRL_PAYLOAD, 0, 0);
+	struct_ep_qh_setup(udc, 0, USB_SEND, USB_ENDPOINT_XFER_CONTROL,
+			USB_MAX_CTRL_PAYLOAD, 0, 0);
 	dr_ep_setup(0, USB_RECV, USB_ENDPOINT_XFER_CONTROL);
 	dr_ep_setup(0, USB_SEND, USB_ENDPOINT_XFER_CONTROL);
 
@@ -567,33 +524,28 @@ static void ep0_dr_and_qh_setup(struct arcotg_udc *udc)
 		Endpoint Management Functions
 ***********************************************************************/
 
-/*!
+/*-------------------------------------------------------------------------
  * when configurations are set, or when interface settings change
  * for example the do_set_interface() in gadget layer,
  * the driver will enable or disable the relevant endpoints
- * ep0 will not use this func it is enable in probe()
- * @param _ep   endpoint pointer
- * @param desc  endpoint descriptor pointer
- * @return The function returns 0 on success or -1 if failed
- */
-static int arcotg_ep_enable(struct usb_ep *_ep,
-			    const struct usb_endpoint_descriptor *desc)
+ * ep0 doesn't use this routine. It is always enabled.
+-------------------------------------------------------------------------*/
+static int fsl_ep_enable(struct usb_ep *_ep,
+		const struct usb_endpoint_descriptor *desc)
 {
-	struct arcotg_udc *udc = NULL;
-	struct arcotg_ep *ep = NULL;
+	struct fsl_udc *udc = NULL;
+	struct fsl_ep *ep = NULL;
 	unsigned short max = 0;
-	unsigned char mult = 0, zlt = 0;
-	int retval = 0;
+	unsigned char mult = 0, zlt;
+	int retval = -EINVAL;
 	unsigned long flags = 0;
-	char *val = NULL;	/* for debug */
 
-	ep = container_of(_ep, struct arcotg_ep, ep);
+	ep = container_of(_ep, struct fsl_ep, ep);
 
-	pr_debug("udc: %s ep.name=%s\n", __FUNCTION__, ep->ep.name);
+	pr_debug("udc: %s ep.name=%s\n", __func__, ep->ep.name);
 	/* catch various bogus parameters */
-	if (!_ep || !desc || ep->desc || _ep->name == ep_name[0] ||
-	    (desc->bDescriptorType != USB_DT_ENDPOINT))
-		/* FIXME: add judge for ep->bEndpointAddress */
+	if (!_ep || !desc || ep->desc
+			|| (desc->bDescriptorType != USB_DT_ENDPOINT))
 		return -EINVAL;
 
 	udc = ep->udc;
@@ -602,214 +554,123 @@ static int arcotg_ep_enable(struct usb_ep *_ep,
 		return -ESHUTDOWN;
 
 	max = le16_to_cpu(desc->wMaxPacketSize);
-	retval = -EINVAL;
 
-	/* check the max package size validate for this endpoint */
-	/* Refer to USB2.0 spec table 9-13,
-	 */
+	/* Disable automatic zlp generation.  Driver is reponsible to indicate
+	 * explicitly through req->req.zero.  This is needed to enable multi-td
+	 * request. */
+	zlt = 1;
+
+	/* Assume the max packet size from gadget is always correct */
 	switch (desc->bmAttributes & 0x03) {
+	case USB_ENDPOINT_XFER_CONTROL:
 	case USB_ENDPOINT_XFER_BULK:
-		if (strstr(ep->ep.name, "-iso")
-		    || strstr(ep->ep.name, "-int"))
-			goto en_done;
-		mult = 0;
-		zlt = 1;
-		switch (udc->gadget.speed) {
-		case USB_SPEED_HIGH:
-			if ((max == 128) || (max == 256) || (max == 512))
-				break;
-		default:
-			switch (max) {
-			case 4:
-			case 8:
-			case 16:
-			case 32:
-			case 64:
-				break;
-			default:
-			case USB_SPEED_LOW:
-				goto en_done;
-			}
-		}
-		break;
 	case USB_ENDPOINT_XFER_INT:
-		if (strstr(ep->ep.name, "-iso"))	/* bulk is ok */
-			goto en_done;
+		/* mult = 0.  Execute N Transactions as demonstrated by
+		 * the USB variable length packet protocol where N is
+		 * computed using the Maximum Packet Length (dQH) and
+		 * the Total Bytes field (dTD) */
 		mult = 0;
-		zlt = 1;
-		switch (udc->gadget.speed) {
-		case USB_SPEED_HIGH:
-			if (max <= 1024)
-				break;
-		case USB_SPEED_FULL:
-			if (max <= 64)
-				break;
-		default:
-			if (max <= 8)
-				break;
-			goto en_done;
-		}
 		break;
 	case USB_ENDPOINT_XFER_ISOC:
-		if (strstr(ep->ep.name, "-bulk") || strstr(ep->ep.name, "-int"))
-			goto en_done;
-		mult = (unsigned char)
-		    (1 + ((le16_to_cpu(desc->wMaxPacketSize) >> 11) & 0x03));
-		zlt = 0;
-		switch (udc->gadget.speed) {
-		case USB_SPEED_HIGH:
-			if (max <= 1024)
-				break;
-		case USB_SPEED_FULL:
-			if (max <= 1023)
-				break;
-		default:
+		/* Calculate transactions needed for high bandwidth iso */
+		mult = (unsigned char)(1 + ((max >> 11) & 0x03));
+		max = max & 0x8ff;	/* bit 0~10 */
+		/* 3 transactions at most */
+		if (mult > 3)
 			goto en_done;
-		}
 		break;
-	case USB_ENDPOINT_XFER_CONTROL:
-		if (strstr(ep->ep.name, "-iso") || strstr(ep->ep.name, "-int"))
-			goto en_done;
-		mult = 0;
-		zlt = 1;
-		switch (udc->gadget.speed) {
-		case USB_SPEED_HIGH:
-		case USB_SPEED_FULL:
-			switch (max) {
-			case 1:
-			case 2:
-			case 4:
-			case 8:
-			case 16:
-			case 32:
-			case 64:
-				break;
-			default:
-				goto en_done;
-			}
-		case USB_SPEED_LOW:
-			switch (max) {
-			case 1:
-			case 2:
-			case 4:
-			case 8:
-				break;
-			default:
-				goto en_done;
-			}
-		default:
-			goto en_done;
-		}
-		break;
-
 	default:
 		goto en_done;
 	}
 
-	/* here initialize variable of ep */
 	spin_lock_irqsave(&udc->lock, flags);
 	ep->ep.maxpacket = max;
 	ep->desc = desc;
 	ep->stopped = 0;
 
-	/* hardware special operation */
-
+	/* Controller related setup */
 	/* Init EPx Queue Head (Ep Capabilites field in QH
 	 * according to max, zlt, mult) */
-	struct_ep_qh_setup((void *)udc, (unsigned char)ep_index(ep),
-			   (unsigned char)
-			   ((desc->bEndpointAddress & USB_DIR_IN) ?
-			    USB_SEND : USB_RECV), (unsigned char)
-			   (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK),
-			   max, zlt, mult);
-
-	/* Init endpoint x at here */
-	/* 83xx RM chapter 16.3.2.24, here init the endpoint ctrl reg */
-	dr_ep_setup((unsigned char)ep_index(ep),
-		    (unsigned char)((desc->bEndpointAddress & USB_DIR_IN)
-				    ? USB_SEND : USB_RECV),
-		    (unsigned char)(desc->bmAttributes &
-				    USB_ENDPOINT_XFERTYPE_MASK));
-
-	/* Now HW will be NAKing transfers to that EP,
-	 * until a buffer is queued to it. */
-
-	/* should have stop the lock */
+	struct_ep_qh_setup(udc, (unsigned char) ep_index(ep),
+			(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)
+					?  USB_SEND : USB_RECV),
+			(unsigned char) (desc->bmAttributes
+					& USB_ENDPOINT_XFERTYPE_MASK),
+			max, zlt, mult);
+
+	/* Init endpoint ctrl register */
+	dr_ep_setup((unsigned char) ep_index(ep),
+			(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)
+					? USB_SEND : USB_RECV),
+			(unsigned char) (desc->bmAttributes
+					& USB_ENDPOINT_XFERTYPE_MASK));
+
 	spin_unlock_irqrestore(&udc->lock, flags);
 	retval = 0;
-	switch (desc->bmAttributes & 0x03) {
-	case USB_ENDPOINT_XFER_BULK:
-		val = "bulk";
-		break;
-	case USB_ENDPOINT_XFER_ISOC:
-		val = "iso";
-		break;
-	case USB_ENDPOINT_XFER_INT:
-		val = "intr";
-		break;
-	default:
-		val = "ctrl";
-		break;
-	}
 
-	pr_debug("udc: enabled %s (ep%d%s-%s) maxpacket %d\n", ep->ep.name,
-		 ep->desc->bEndpointAddress & 0x0f,
-		 (desc->bEndpointAddress & USB_DIR_IN) ? "in" : "out",
-		 val, max);
-      en_done:
+	VDBG("enabled %s (ep%d%s) maxpacket %d", ep->ep.name,
+			ep->desc->bEndpointAddress & 0x0f,
+			(desc->bEndpointAddress & USB_DIR_IN)
+				? "in" : "out", max);
+en_done:
 	return retval;
 }
 
-/*!
- * disable endpoint
+/*---------------------------------------------------------------------
+ * @ep : the ep being unconfigured. May not be ep0
  * Any pending and uncomplete req will complete with status (-ESHUTDOWN)
- * @param _ep  the ep being unconfigured. May not be ep0
- * @return The function returns 0 on success or -1 if failed
- */
-static int arcotg_ep_disable(struct usb_ep *_ep)
+*---------------------------------------------------------------------*/
+static int fsl_ep_disable(struct usb_ep *_ep)
 {
-	struct arcotg_udc *udc = NULL;
-	struct arcotg_ep *ep = NULL;
+	struct fsl_udc *udc = NULL;
+	struct fsl_ep *ep = NULL;
 	unsigned long flags = 0;
+	u32 epctrl;
+	int ep_num;
 
-	ep = container_of(_ep, struct arcotg_ep, ep);
+	ep = container_of(_ep, struct fsl_ep, ep);
 	if (!_ep || !ep->desc) {
-		pr_debug("udc: %s not enabled\n", _ep ? ep->ep.name : NULL);
+		VDBG("%s not enabled", _ep ? ep->ep.name : NULL);
 		return -EINVAL;
 	}
 
-	udc = (struct arcotg_udc *)ep->udc;
+	/* disable ep on controller */
+	ep_num = ep_index(ep);
+	epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (ep_is_in(ep))
+		epctrl &= ~EPCTRL_TX_ENABLE;
+	else
+		epctrl &= ~EPCTRL_RX_ENABLE;
+	fsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);
 
+	udc = (struct fsl_udc *)ep->udc;
 	spin_lock_irqsave(&udc->lock, flags);
 
-	/* Nuke all pending requests (does flush) */
+	/* nuke all pending requests (does flush) */
 	nuke(ep, -ESHUTDOWN);
 
 	ep->desc = 0;
 	ep->stopped = 1;
 	spin_unlock_irqrestore(&udc->lock, flags);
 
-	pr_debug("udc: disabled %s OK\n", _ep->name);
+	VDBG("disabled %s OK", _ep->name);
 	return 0;
 }
 
-/*!
+/*---------------------------------------------------------------------
  * allocate a request object used by this endpoint
  * the main operation is to insert the req->queue to the eq->queue
- * @param _ep       the ep being unconfigured. May not be ep0
- * @param gfp_flags mem flags
- * @return Returns the request, or null if one could not be allocated
- */
-static struct usb_request *arcotg_alloc_request(struct usb_ep *_ep,
-						gfp_t gfp_flags)
+ * Returns the request, or null if one could not be allocated
+*---------------------------------------------------------------------*/
+static struct usb_request *
+fsl_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)
 {
-	struct arcotg_req *req = NULL;
+	struct fsl_req *req = NULL;
 
-	req = kmalloc(sizeof *req, gfp_flags);
+	req = kzalloc(sizeof *req, gfp_flags);
 	if (!req)
 		return NULL;
 
-	memset(req, 0, sizeof *req);
 	req->req.dma = DMA_ADDR_INVALID;
 	pr_debug("udc: req=0x%p   set req.dma=0x%x\n", req, req->req.dma);
 	INIT_LIST_HEAD(&req->queue);
@@ -817,239 +678,193 @@ static struct usb_request *arcotg_alloc_request(struct usb_ep *_ep,
 	return &req->req;
 }
 
-/*!
- * free request memory
- * @param _ep       the ep being unconfigured. May not be ep0
- * @param  _req     usb request pointer
- */
-static void arcotg_free_request(struct usb_ep *_ep, struct usb_request *_req)
+static void fsl_free_request(struct usb_ep *_ep, struct usb_request *_req)
 {
-	struct arcotg_req *req;
+	struct fsl_req *req = NULL;
 
-	req = container_of(_req, struct arcotg_req, req);
-	pr_debug("udc: req=0x%p\n", req);
+	req = container_of(_req, struct fsl_req, req);
 
 	if (_req)
 		kfree(req);
 }
 
 /*-------------------------------------------------------------------------*/
-
-/*!
- * link req's dTD queue to the end of ep's QH's dTD queue.
- * @param ep    endpoint pointer
- * @param req   request pointer
- * @return The function returns 0 on success or -1 if failed
- */
-static int arcotg_queue_td(struct arcotg_ep *ep, struct arcotg_req *req)
+static int fsl_queue_td(struct fsl_ep *ep, struct fsl_req *req)
 {
 	int i = ep_index(ep) * 2 + ep_is_in(ep);
 	u32 temp, bitmask, tmp_stat;
 	struct ep_queue_head *dQH = &ep->udc->ep_qh[i];
 
-	pr_debug("udc: queue req=0x%p to ep index %d\n", req, i);
-	bitmask = (ep_is_in(ep)) ? (1 << (ep_index(ep) + 16)) :
-	    (1 << (ep_index(ep)));
+	/* VDBG("QH addr Register 0x%8x", dr_regs->endpointlistaddr);
+	VDBG("ep_qh[%d] addr is 0x%8x", i, (u32)&(ep->udc->ep_qh[i])); */
+
+	bitmask = ep_is_in(ep)
+		? (1 << (ep_index(ep) + 16))
+		: (1 << (ep_index(ep)));
 
 	/* check if the pipe is empty */
 	if (!(list_empty(&ep->queue))) {
 		/* Add td to the end */
-		struct arcotg_req *lastreq;
-		lastreq = list_entry(ep->queue.prev, struct arcotg_req, queue);
-
-		WARN_ON(req->head->td_dma & 31);
-		lastreq->tail->next_td_ptr = req->head->td_dma;
-		lastreq->tail->next_td_virt = req->head;
-
-		pr_debug("udc: ep's queue not empty.  lastreq=0x%p\n", lastreq);
-
+		struct fsl_req *lastreq;
+		lastreq = list_entry(ep->queue.prev, struct fsl_req, queue);
+		lastreq->tail->next_td_ptr =
+			cpu_to_hc32(req->head->td_dma & DTD_ADDR_MASK);
 		/* Read prime bit, if 1 goto done */
-		if (usb_slave_regs->endpointprime & cpu_to_le32(bitmask)) {
-			pr_debug("udc: ep's already primed\n");
+		if (fsl_readl(&dr_regs->endpointprime) & bitmask)
 			goto out;
-		}
 
-		timeout = 10000000;
 		do {
 			/* Set ATDTW bit in USBCMD */
-			usb_slave_regs->usbcmd |= cpu_to_le32(USB_CMD_ATDTW);
+			temp = fsl_readl(&dr_regs->usbcmd);
+			fsl_writel(temp | USB_CMD_ATDTW, &dr_regs->usbcmd);
 
 			/* Read correct status bit */
-			tmp_stat = le32_to_cpu(usb_slave_regs->endptstatus) &
-			    bitmask;
+			tmp_stat = fsl_readl(&dr_regs->endptstatus) & bitmask;
 
-		} while ((!(usb_slave_regs->usbcmd &
-			    cpu_to_le32(USB_CMD_ATDTW)))
-			 && --timeout);
-
-		if (timeout == 0) {
-			printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-		}
+		} while (!(fsl_readl(&dr_regs->usbcmd) & USB_CMD_ATDTW));
 
 		/* Write ATDTW bit to 0 */
-		usb_slave_regs->usbcmd &= cpu_to_le32(~USB_CMD_ATDTW);
+		temp = fsl_readl(&dr_regs->usbcmd);
+		fsl_writel(temp & ~USB_CMD_ATDTW, &dr_regs->usbcmd);
 
 		if (tmp_stat)
 			goto out;
-
-		/* fall through to Case 1: List is empty */
 	}
 
 	/* Write dQH next pointer and terminate bit to 0 */
-	WARN_ON(req->head->td_dma & 31);
-	dQH->next_dtd_ptr = cpu_to_le32(req->head->td_dma);
+	temp = req->head->td_dma & EP_QUEUE_HEAD_NEXT_POINTER_MASK;
+	dQH->next_dtd_ptr = cpu_to_hc32(temp);
 
 	/* Clear active and halt bit */
-	temp = cpu_to_le32(~(EP_QUEUE_HEAD_STATUS_ACTIVE |
-			     EP_QUEUE_HEAD_STATUS_HALT));
+	temp = cpu_to_hc32(~(EP_QUEUE_HEAD_STATUS_ACTIVE
+			| EP_QUEUE_HEAD_STATUS_HALT));
 	dQH->size_ioc_int_sts &= temp;
 
 	/* Prime endpoint by writing 1 to ENDPTPRIME */
-	temp = (ep_is_in(ep)) ? (1 << (ep_index(ep) + 16)) :
-	    (1 << (ep_index(ep)));
-
-	pr_debug("udc: setting endpointprime. temp=0x%x (bitmask=0x%x)\n",
-		 temp, bitmask);
-	usb_slave_regs->endpointprime |= cpu_to_le32(temp);
-
-      out:
+	temp = ep_is_in(ep)
+		? (1 << (ep_index(ep) + 16))
+		: (1 << (ep_index(ep)));
+	fsl_writel(temp, &dr_regs->endpointprime);
+out:
 	return 0;
 }
 
-static int arcotg_build_dtd(struct arcotg_req *req, unsigned max,
-			    struct ep_td_struct **address,
-			    struct arcotg_udc *udc)
+/* Fill in the dTD structure
+ * @req: request that the transfer belongs to
+ * @length: return actually data length of the dTD
+ * @dma: return dma address of the dTD
+ * @is_last: return flag if it is the last dTD of the request
+ * return: pointer to the built dTD */
+static struct ep_td_struct *fsl_build_dtd(struct fsl_req *req, unsigned *length,
+		dma_addr_t *dma, int *is_last)
 {
-	unsigned length;
 	u32 swap_temp;
 	struct ep_td_struct *dtd;
-	dma_addr_t handle;
-
-	/* how big will this packet be? */
-	length = min(req->req.length - req->req.actual, max);
-
-	dtd = dma_pool_alloc(udc->dtd_pool, GFP_KERNEL, &handle);
-	pr_debug("udc: dma_pool_alloc() ep(0x%p)=%s  virt=0x%p  dma=0x%x\n",
-		 req->ep, req->ep->name, dtd, handle);
-
-	/* check alignment - must be 32 byte aligned (bits 4:0 == 0) */
-	BUG_ON((u32) dtd & 31);
 
-	memset(dtd, 0, sizeof(struct ep_td_struct));
-	dtd->td_dma = handle;
+	/* how big will this transfer be? */
+	*length = min(req->req.length - req->req.actual,
+			(unsigned)EP_MAX_LENGTH_TRANSFER);
 
-	/* Fill in the transfer size; set interrupt on every dtd;
-	   set active bit */
-	swap_temp = ((length << DTD_LENGTH_BIT_POS) | DTD_IOC
-		     | DTD_STATUS_ACTIVE);
-
-	dtd->size_ioc_sts = cpu_to_le32(swap_temp);
+	dtd = dma_pool_alloc(udc_controller->td_pool, GFP_KERNEL, dma);
+	if (dtd == NULL)
+		return dtd;
 
+	dtd->td_dma = *dma;
 	/* Clear reserved field */
-	swap_temp = cpu_to_le32(dtd->size_ioc_sts);
+	swap_temp = hc32_to_cpu(dtd->size_ioc_sts);
 	swap_temp &= ~DTD_RESERVED_FIELDS;
-	dtd->size_ioc_sts = cpu_to_le32(swap_temp);
-
-	pr_debug("udc: req=0x%p  dtd=0x%p  req.dma=0x%x  req.length=%d  "
-		 "length=%d  size_ioc_sts=0x%x\n",
-		 req, dtd, req->req.dma, req->req.length,
-		 length, dtd->size_ioc_sts);
+	dtd->size_ioc_sts = cpu_to_hc32(swap_temp);
 
 	/* Init all of buffer page pointers */
 	swap_temp = (u32) (req->req.dma + req->req.actual);
-	dtd->buff_ptr0 = cpu_to_le32(swap_temp);
-	dtd->buff_ptr1 = cpu_to_le32(swap_temp + 0x1000);
-	dtd->buff_ptr2 = cpu_to_le32(swap_temp + 0x2000);
-	dtd->buff_ptr3 = cpu_to_le32(swap_temp + 0x3000);
-	dtd->buff_ptr4 = cpu_to_le32(swap_temp + 0x4000);
+	dtd->buff_ptr0 = cpu_to_hc32(swap_temp);
+	dtd->buff_ptr1 = cpu_to_hc32(swap_temp + 0x1000);
+	dtd->buff_ptr2 = cpu_to_hc32(swap_temp + 0x2000);
+	dtd->buff_ptr3 = cpu_to_hc32(swap_temp + 0x3000);
+	dtd->buff_ptr4 = cpu_to_hc32(swap_temp + 0x4000);
+
+	req->req.actual += *length;
+
+	/* zlp is needed if req->req.zero is set */
+	if (req->req.zero) {
+		if (*length == 0 || (*length % req->ep->ep.maxpacket) != 0)
+			*is_last = 1;
+		else
+			*is_last = 0;
+	} else if (req->req.length == req->req.actual)
+		*is_last = 1;
+	else
+		*is_last = 0;
 
-	req->req.actual += length;
-	*address = dtd;
+	if ((*is_last) == 0)
+		VDBG("multi-dtd request!\n");
+	/* Fill in the transfer size; set active bit */
+	swap_temp = ((*length << DTD_LENGTH_BIT_POS) | DTD_STATUS_ACTIVE);
 
-	return length;
+	/* Enable interrupt for the last dtd of a request */
+	if (*is_last && !req->req.no_interrupt)
+		swap_temp |= DTD_IOC;
+
+	dtd->size_ioc_sts = cpu_to_hc32(swap_temp);
+
+	mb();
+
+	VDBG("length = %d address= 0x%x", *length, (int)*dma);
+
+	return dtd;
 }
 
-/*!
- * add USB request to dtd queue
- * @param req  USB request
- * @param dev  device pointer
- * @return Returns zero on success , or a negative error code
- */
-static int arcotg_req_to_dtd(struct arcotg_req *req, struct arcotg_udc *udc)
+/* Generate dtd chain for a request */
+static int fsl_req_to_dtd(struct fsl_req *req)
 {
-	unsigned max;
-	unsigned count;
-	int is_last;
-	int is_first = 1;
-	struct ep_td_struct *last_addr = NULL, *addr;
+	unsigned	count;
+	int		is_last;
+	int		is_first = 1;
+	struct ep_td_struct	*last_dtd = NULL, *dtd;
+	dma_addr_t dma;
 
-	pr_debug("udc: req=0x%p\n", req);
-
-	max = EP_MAX_LENGTH_TRANSFER;
 	do {
-		count = arcotg_build_dtd(req, max, &addr, udc);
+		dtd = fsl_build_dtd(req, &count, &dma, &is_last);
+		if (dtd == NULL)
+			return -ENOMEM;
 
 		if (is_first) {
 			is_first = 0;
-			req->head = addr;
+			req->head = dtd;
 		} else {
-			if (!last_addr) {
-				/* FIXME last_addr not set.  iso only
-				 * case, which we don't do yet
-				 */
-				pr_debug("udc: wiping out something at 0!!\n");
-			}
-
-			last_addr->next_td_ptr = cpu_to_le32(addr->td_dma);
-			last_addr->next_td_virt = addr;
-			last_addr = addr;
+			last_dtd->next_td_ptr = cpu_to_hc32(dma);
+			last_dtd->next_td_virt = dtd;
 		}
-
-		/* last packet is usually short (or a zlp) */
-		if (unlikely(count != max))
-			is_last = 1;
-		else if (likely(req->req.length != req->req.actual) ||
-			 req->req.zero)
-			is_last = 0;
-		else
-			is_last = 1;
+		last_dtd = dtd;
 
 		req->dtd_count++;
 	} while (!is_last);
 
-	addr->next_td_ptr = cpu_to_le32(DTD_NEXT_TERMINATE);
-	addr->next_td_virt = NULL;
-	req->tail = addr;
+	dtd->next_td_ptr = cpu_to_hc32(DTD_NEXT_TERMINATE);
+
+	req->tail = dtd;
 
 	return 0;
 }
 
-/*!
- * add transfer request to queue
- * @param  _ep endpoint pointer
- * @param _req request pointer
- * @param gfp_flags GFP_* flags to use
- * @return  Returns zero on success , or a negative error code
- */
-static int arcotg_ep_queue(struct usb_ep *_ep, struct usb_request *_req,
-			   gfp_t gfp_flags)
+/* queues (submits) an I/O request to an endpoint */
+static int
+fsl_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 {
-	struct arcotg_ep *ep = container_of(_ep, struct arcotg_ep, ep);
-	struct arcotg_req *req = container_of(_req, struct arcotg_req, req);
-	struct arcotg_udc *udc;
+	struct fsl_ep *ep = container_of(_ep, struct fsl_ep, ep);
+	struct fsl_req *req = container_of(_req, struct fsl_req, req);
+	struct fsl_udc *udc;
 	unsigned long flags;
 	int is_iso = 0;
 
-	pr_debug("udc: _req=0x%p  len=%d\n", _req, _req->length);
-
 	/* catch various bogus parameters */
 	if (!_req || !req->req.complete || !req->req.buf
-	    || !list_empty(&req->queue)) {
-		pr_debug("udc: %s, bad params\n", __FUNCTION__);
+			|| !list_empty(&req->queue)) {
+		VDBG("%s, bad params\n", __func__);
 		return -EINVAL;
 	}
 	if (!_ep || (!ep->desc && ep_index(ep))) {
-		pr_debug("udc: %s, bad ep\n", __FUNCTION__);
+		VDBG("%s, bad ep\n", __func__);
 		return -EINVAL;
 	}
 	if (ep->desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {
@@ -1064,42 +879,21 @@ static int arcotg_ep_queue(struct usb_ep *_ep, struct usb_request *_req,
 
 	req->ep = ep;
 
-	/* if data phase is absent send the status phase */
-	if ((ep_index(ep) == 0)) {
-		if (udc->ep0_state != DATA_STATE_XMIT &&
-		    udc->ep0_state != DATA_STATE_RECV &&
-		    (udc->local_setup_buff).wLength == 0) {
-			if (ep0_prime_status(udc, EP_DIR_IN))
-				Ep0Stall(udc);
-			else
-				return 0;
-		}
-	}
-
 	/* map virtual address to hardware */
 	if (req->req.dma == DMA_ADDR_INVALID) {
 		req->req.dma = dma_map_single(ep->udc->gadget.dev.parent,
-					      req->req.buf,
-					      req->req.length, ep_is_in(ep)
-					      ? DMA_TO_DEVICE :
-					      DMA_FROM_DEVICE);
+					req->req.buf,
+					req->req.length, ep_is_in(ep)
+						? DMA_TO_DEVICE
+						: DMA_FROM_DEVICE);
 		req->mapped = 1;
-		pr_debug("udc: called dma_map_single(buffer,%s)  req=0x%p  "
-			 "buf=0x%p  dma=0x%x  len=%d\n",
-			 ep_is_in(ep) ? "to_dvc" : "from_dvc",
-			 req, req->req.buf, req->req.dma, req->req.length);
-		pr_debug("udc: req=0x%p set req.dma=0x%x\n", req, req->req.dma);
 	} else {
 		dma_sync_single_for_device(ep->udc->gadget.dev.parent,
-					   req->req.dma, req->req.length,
-					   ep_is_in(ep) ? DMA_TO_DEVICE :
-					   DMA_FROM_DEVICE);
-
+					req->req.dma, req->req.length,
+					ep_is_in(ep)
+						? DMA_TO_DEVICE
+						: DMA_FROM_DEVICE);
 		req->mapped = 0;
-		pr_debug("udc: called dma_sync_single_for_device(buffer,%s)  "
-			 "req=0x%p  buf=0x%p  dma=0x%x  len=%d\n",
-			 ep_is_in(ep) ? "to_dvc" : "from_dvc",
-			 req, req->req.buf, req->req.dma, req->req.length);
 	}
 
 	req->req.status = -EINPROGRESS;
@@ -1108,46 +902,50 @@ static int arcotg_ep_queue(struct usb_ep *_ep, struct usb_request *_req,
 
 	spin_lock_irqsave(&udc->lock, flags);
 
-	/* push the dtds to device queue */
-	if (!arcotg_req_to_dtd(req, udc))
-		arcotg_queue_td(ep, req);
-	else
+	/* build dtds and push them to device queue */
+	if (!fsl_req_to_dtd(req)) {
+		fsl_queue_td(ep, req);
+	} else {
+		spin_unlock_irqrestore(&udc->lock, flags);
 		return -ENOMEM;
+	}
 
-	/* EP0 */
-	if ((ep_index(ep) == 0)) {
+	/* Update ep0 state */
+	if ((ep_index(ep) == 0))
 		udc->ep0_state = DATA_STATE_XMIT;
-		pr_debug("udc: ep0_state now DATA_STATE_XMIT\n");
-	}
 
-	/* put this req at the end of the ep's queue */
 	/* irq handler advances the queue */
 	if (req != NULL)
 		list_add_tail(&req->queue, &ep->queue);
-
-	dump_ep_queue(ep);
 	spin_unlock_irqrestore(&udc->lock, flags);
 
 	return 0;
 }
 
-/*!
- * remove the endpoint buffer
- * @param _ep endpoint pointer
- * @param _req usb request pointer
- * @return Returns zero on success , or a negative error code
- */
-static int arcotg_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+/* dequeues (cancels, unlinks) an I/O request from an endpoint */
+static int fsl_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
 {
-	struct arcotg_ep *ep = container_of(_ep, struct arcotg_ep, ep);
-	struct arcotg_req *req;
+	struct fsl_ep *ep = container_of(_ep, struct fsl_ep, ep);
+	struct fsl_req *req;
 	unsigned long flags;
+	int ep_num, stopped, ret = 0;
+	u32 epctrl;
 
-	pr_debug("%s\n", __FUNCTION__);
 	if (!_ep || !_req)
 		return -EINVAL;
 
 	spin_lock_irqsave(&ep->udc->lock, flags);
+	stopped = ep->stopped;
+
+	/* Stop the ep before we deal with the queue */
+	ep->stopped = 1;
+	ep_num = ep_index(ep);
+	epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (ep_is_in(ep))
+		epctrl &= ~EPCTRL_TX_ENABLE;
+	else
+		epctrl &= ~EPCTRL_RX_ENABLE;
+	fsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);
 
 	/* make sure it's actually queued on this endpoint */
 	list_for_each_entry(req, &ep->queue, queue) {
@@ -1155,36 +953,70 @@ static int arcotg_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
 			break;
 	}
 	if (&req->req != _req) {
-		spin_unlock_irqrestore(&ep->udc->lock, flags);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* The request is in progress, or completed but not dequeued */
+	if (ep->queue.next == &req->queue) {
+		_req->status = -ECONNRESET;
+		fsl_ep_fifo_flush(_ep);	/* flush current transfer */
+
+		/* The request isn't the last request in this ep queue */
+		if (req->queue.next != &ep->queue) {
+			struct ep_queue_head *qh;
+			struct fsl_req *next_req;
+
+			qh = ep->qh;
+			next_req = list_entry(req->queue.next, struct fsl_req,
+					queue);
+
+			/* Point the QH to the first TD of next request */
+			fsl_writel((u32) next_req->head, &qh->curr_dtd_ptr);
+		}
+
+		/* The request hasn't been processed, patch up the TD chain */
+	} else {
+		struct fsl_req *prev_req;
+
+		prev_req = list_entry(req->queue.prev, struct fsl_req, queue);
+		fsl_writel(fsl_readl(&req->tail->next_td_ptr),
+				&prev_req->tail->next_td_ptr);
+
 	}
-	pr_debug("udc: req=0x%p\n", req);
 
 	done(ep, req, -ECONNRESET);
 
-	spin_unlock_irqrestore(&ep->udc->lock, flags);
-	return 0;
+	/* Enable EP */
+out:	epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (ep_is_in(ep))
+		epctrl |= EPCTRL_TX_ENABLE;
+	else
+		epctrl |= EPCTRL_RX_ENABLE;
+	fsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);
+	ep->stopped = stopped;
 
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+	return ret;
 }
 
 /*-------------------------------------------------------------------------*/
 
-/*!
+/*-----------------------------------------------------------------
  * modify the endpoint halt feature
- * @param  _ep  the non-isochronous endpoint being stalled
- * @param value 1--set halt  0--clear halt
- * @return Returns zero, or a negative error code
- */
-static int _arcotg_ep_set_halt(struct usb_ep *_ep, int value)
+ * @ep: the non-isochronous endpoint being stalled
+ * @value: 1--set halt  0--clear halt
+ * Returns zero, or a negative error code.
+*----------------------------------------------------------------*/
+static int fsl_ep_set_halt(struct usb_ep *_ep, int value)
 {
-
-	struct arcotg_ep *ep = NULL;
+	struct fsl_ep *ep = NULL;
 	unsigned long flags = 0;
 	int status = -EOPNOTSUPP;	/* operation not supported */
 	unsigned char ep_dir = 0, ep_num = 0;
-	struct arcotg_udc *udc = NULL;
+	struct fsl_udc *udc = NULL;
 
-	ep = container_of(_ep, struct arcotg_ep, ep);
+	ep = container_of(_ep, struct fsl_ep, ep);
 	udc = ep->udc;
 	if (!_ep || !ep->desc) {
 		status = -EINVAL;
@@ -1196,8 +1028,8 @@ static int _arcotg_ep_set_halt(struct usb_ep *_ep, int value)
 		goto out;
 	}
 
-	/* Attemp to halt IN ep will fail if any transfer requests
-	   are still queue */
+	/* Attempt to halt IN ep will fail if any transfer requests
+	 * are still queue */
 	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
 		status = -EAGAIN;
 		goto out;
@@ -1212,34 +1044,28 @@ static int _arcotg_ep_set_halt(struct usb_ep *_ep, int value)
 
 	if (ep_index(ep) == 0) {
 		udc->ep0_state = WAIT_FOR_SETUP;
-		pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
 		udc->ep0_dir = 0;
 	}
-      out:
-	pr_debug("udc:  %s %s halt rc=%d\n",
-		 ep->ep.name, value ? "set" : "clear", status);
+out:
+	VDBG(" %s %s halt stat %d", ep->ep.name,
+			value ?  "set" : "clear", status);
 
 	return status;
 }
 
-static int arcotg_ep_set_halt(struct usb_ep *_ep, int value)
-{
-	return (_arcotg_ep_set_halt(_ep, value));
-}
-
 static int arcotg_fifo_status(struct usb_ep *_ep)
 {
-	struct arcotg_ep *ep;
-	struct arcotg_udc *udc;
+	struct fsl_ep *ep;
+	struct fsl_udc *udc;
 	int size = 0;
 	u32 bitmask;
 	struct ep_queue_head *d_qh;
 
-	ep = container_of(_ep, struct arcotg_ep, ep);
+	ep = container_of(_ep, struct fsl_ep, ep);
 	if (!_ep || (!ep->desc && ep_index(ep) != 0))
 		return -ENODEV;
 
-	udc = (struct arcotg_udc *)ep->udc;
+	udc = (struct fsl_udc *)ep->udc;
 
 	if (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)
 		return -ESHUTDOWN;
@@ -1249,232 +1075,197 @@ static int arcotg_fifo_status(struct usb_ep *_ep)
 	bitmask = (ep_is_in(ep)) ? (1 << (ep_index(ep) + 16)) :
 	    (1 << (ep_index(ep)));
 
-	if (le32_to_cpu(usb_slave_regs->endptstatus) & bitmask)
+	if (fsl_readl(&dr_regs->endptstatus) & bitmask)
 		size = (d_qh->size_ioc_int_sts & DTD_PACKET_SIZE)
 		    >> DTD_LENGTH_BIT_POS;
 
-	pr_debug("%s %u\n", __FUNCTION__, size);
+	pr_debug("%s %u\n", __func__, size);
 	return size;
 }
 
-static void arcotg_fifo_flush(struct usb_ep *_ep)
+static void fsl_ep_fifo_flush(struct usb_ep *_ep)
 {
-	struct arcotg_ep *ep;
-	struct arcotg_udc *udc;
-	u32 bitmask;
-	int loops = 0;
-
-	ep = container_of(_ep, struct arcotg_ep, ep);
-	if (!_ep || (!ep->desc && ep_index(ep) != 0))
-		return;
-
-	udc = (struct arcotg_udc *)ep->udc;
+	struct fsl_ep *ep;
+	int ep_num, ep_dir;
+	u32 bits;
+	unsigned long timeout;
+#define FSL_UDC_FLUSH_TIMEOUT 1000
 
-	if (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)
+	if (!_ep) {
 		return;
+	} else {
+		ep = container_of(_ep, struct fsl_ep, ep);
+		if (!ep->desc)
+			return;
+	}
+	ep_num = ep_index(ep);
+	ep_dir = ep_is_in(ep) ? USB_SEND : USB_RECV;
 
-	bitmask = (ep_is_in(ep)) ? (1 << (ep_index(ep) + 16)) :
-	    (1 << (ep_index(ep)));
+	if (ep_num == 0)
+		bits = (1 << 16) | 1;
+	else if (ep_dir == USB_SEND)
+		bits = 1 << (16 + ep_num);
+	else
+		bits = 1 << ep_num;
 
+	timeout = jiffies + FSL_UDC_FLUSH_TIMEOUT;
 	do {
-		/* set the flush bit, and wait for it to clear */
-		usb_slave_regs->endptflush = cpu_to_le32(bitmask);
-		while (usb_slave_regs->endptflush)
-			continue;
+		fsl_writel(bits, &dr_regs->endptflush);
 
-		/* if ENDPTSTAT bit is set, the flush failed. Retry. */
-		if (!(cpu_to_le32(usb_slave_regs->endptstatus) && bitmask))
-			break;
-	} while (++loops > 3);
+		/* Wait until flush complete */
+		while (fsl_readl(&dr_regs->endptflush)) {
+			if (time_after(jiffies, timeout)) {
+				ERR("ep flush timeout\n");
+				return;
+			}
+			cpu_relax();
+		}
+		/* See if we need to flush again */
+	} while (fsl_readl(&dr_regs->endptstatus) & bits);
 }
 
-/*!
- * endpoint callback functions
- */
-static const struct usb_ep_ops arcotg_ep_ops = {
-	.enable = arcotg_ep_enable,
-	.disable = arcotg_ep_disable,
-
-	.alloc_request = arcotg_alloc_request,
-	.free_request = arcotg_free_request,
+static struct usb_ep_ops fsl_ep_ops = {
+	.enable = fsl_ep_enable,
+	.disable = fsl_ep_disable,
 
-	.queue = arcotg_ep_queue,
-	.dequeue = arcotg_ep_dequeue,
+	.alloc_request = fsl_alloc_request,
+	.free_request = fsl_free_request,
 
-	.set_halt = arcotg_ep_set_halt,
+	.queue = fsl_ep_queue,
+	.dequeue = fsl_ep_dequeue,
 
+	.set_halt = fsl_ep_set_halt,
 	.fifo_status = arcotg_fifo_status,
-	.fifo_flush = arcotg_fifo_flush,
+	.fifo_flush = fsl_ep_fifo_flush,	/* flush fifo */
 };
 
 /*-------------------------------------------------------------------------
 		Gadget Driver Layer Operations
 -------------------------------------------------------------------------*/
 
-/*************************************************************************
-		Gadget Driver Layer Operations
-*************************************************************************/
-
-/*!
+/*----------------------------------------------------------------------
  * Get the current frame number (from DR frame_index Reg )
- * @param gadget  gadget pointer
- * @return return frame count
- */
-static int arcotg_get_frame(struct usb_gadget *gadget)
+ *----------------------------------------------------------------------*/
+static int fsl_get_frame(struct usb_gadget *gadget)
 {
-	return (int)(le32_to_cpu(usb_slave_regs->frindex) & USB_FRINDEX_MASKS);
+	return (int)(fsl_readl(&dr_regs->frindex) & USB_FRINDEX_MASKS);
 }
 
 /*-----------------------------------------------------------------------
  * Tries to wake up the host connected to this gadget
- *
- * Return : 0-success
- * Negative-this feature not enabled by host or not supported by device hw
- * FIXME: RM 16.6.2.2.1 DR support this wake-up feature?
  -----------------------------------------------------------------------*/
-static int arcotg_wakeup(struct usb_gadget *gadget)
+static int fsl_wakeup(struct usb_gadget *gadget)
 {
-	pr_debug("%s\n", __FUNCTION__);
-	return -ENOTSUPP;
-}
+	struct fsl_udc *udc = container_of(gadget, struct fsl_udc, gadget);
+	u32 portsc;
 
-/*!
- * sets the device selfpowered feature
- * this affects the device status reported by the hw driver
- * to reflect that it now has a local power supply
- * usually device hw has register for this feature
- * @param gadget  gadget pointer
- * @param is_selfpowered self powered?
- * @return if selfpowered
- */
-static int arcotg_set_selfpowered(struct usb_gadget *gadget, int is_selfpowered)
-{
-	pr_debug("%s\n", __FUNCTION__);
-	return -ENOTSUPP;
+	/* Remote wakeup feature not enabled by host */
+	if (!udc->remote_wakeup)
+		return -ENOTSUPP;
+
+	portsc = fsl_readl(&dr_regs->portsc1);
+	/* not suspended? */
+	if (!(portsc & PORTSCX_PORT_SUSPEND))
+		return 0;
+	/* trigger force resume */
+	portsc |= PORTSCX_PORT_FORCE_RESUME;
+	fsl_writel(portsc, &dr_regs->portsc1);
+	return 0;
 }
 
-static int can_pullup(struct arcotg_udc *udc)
+static int can_pullup(struct fsl_udc *udc)
 {
 	return udc->driver && udc->softconnect && udc->vbus_active;
 }
 
-/*!
- * Notify controller that VBUS is powered, Called by whatever
- * detects VBUS sessions
- * @param gadger    gadger pointer
- * @param is_active is active?
- * @return Returns zero on success , or a negative error code
- */
-static int arcotg_vbus_session(struct usb_gadget *gadget, int is_active)
+/* Notify controller that VBUS is powered, Called by whatever
+   detects VBUS sessions */
+static int fsl_vbus_session(struct usb_gadget *gadget, int is_active)
 {
-	struct arcotg_udc *udc;
-	unsigned long flags;
+	struct fsl_udc	*udc;
+	unsigned long	flags;
 
-	pr_debug("%s\n", __FUNCTION__);
-
-	udc = container_of(gadget, struct arcotg_udc, gadget);
+	udc = container_of(gadget, struct fsl_udc, gadget);
 	spin_lock_irqsave(&udc->lock, flags);
-
-	pr_debug("udc: VBUS %s\n", is_active ? "on" : "off");
+	VDBG("VBUS %s\n", is_active ? "on" : "off");
 	udc->vbus_active = (is_active != 0);
-
-#if 0				/* FIXME manipulate pullups?? check other platforms. */
 	if (can_pullup(udc))
-		usb_slave_regs->usbcmd |= USB_CMD_RUN_STOP;
+		fsl_writel((fsl_readl(&dr_regs->usbcmd) | USB_CMD_RUN_STOP),
+				&dr_regs->usbcmd);
 	else
-		usb_slave_regs->usbcmd &= ~USB_CMD_RUN_STOP;
-#endif
-
+		fsl_writel((fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP),
+				&dr_regs->usbcmd);
 	spin_unlock_irqrestore(&udc->lock, flags);
 	return 0;
 }
 
-/*!
- * constrain controller's VBUS power usage
+/* constrain controller's VBUS power usage
  * This call is used by gadget drivers during SET_CONFIGURATION calls,
  * reporting how much power the device may consume.  For example, this
  * could affect how quickly batteries are recharged.
+ *
  * Returns zero on success, else negative errno.
- * @param gadget    gadger pointer
- * @param mA	    power
- * @return Returns zero on success , or a negative error code
  */
-static int arcotg_vbus_draw(struct usb_gadget *gadget, unsigned mA)
+static int fsl_vbus_draw(struct usb_gadget *gadget, unsigned mA)
 {
-	struct arcotg_udc *udc;
-
-	pr_debug("%s\n", __FUNCTION__);
-
-	udc = container_of(gadget, struct arcotg_udc, gadget);
+	struct fsl_udc *udc;
 
+	udc = container_of(gadget, struct fsl_udc, gadget);
 	if (udc->transceiver)
 		return otg_set_power(udc->transceiver, mA);
-
 	return -ENOTSUPP;
 }
 
-/*!
- * Change Data+ pullup status
+/* Change Data+ pullup status
  * this func is used by usb_gadget_connect/disconnet
- * @param gadget    gadger pointer
- * @param is_on     on or off
- * @return Returns zero on success , or a negative error code
  */
-static int arcotg_pullup(struct usb_gadget *gadget, int is_on)
+static int fsl_pullup(struct usb_gadget *gadget, int is_on)
 {
-	struct arcotg_udc *udc;
+	struct fsl_udc *udc;
 
-	pr_debug("%s\n", __FUNCTION__);
-
-	udc = container_of(gadget, struct arcotg_udc, gadget);
+	udc = container_of(gadget, struct fsl_udc, gadget);
 	udc->softconnect = (is_on != 0);
 	if (can_pullup(udc))
-		usb_slave_regs->usbcmd |= USB_CMD_RUN_STOP;
+		fsl_writel((fsl_readl(&dr_regs->usbcmd) | USB_CMD_RUN_STOP),
+				&dr_regs->usbcmd);
 	else
-		usb_slave_regs->usbcmd &= ~USB_CMD_RUN_STOP;
+		fsl_writel((fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP),
+				&dr_regs->usbcmd);
 
 	return 0;
 }
 
-static const struct usb_gadget_ops arcotg_gadget_ops = {
-	.get_frame = arcotg_get_frame,
-	.wakeup = arcotg_wakeup,
-	.set_selfpowered = arcotg_set_selfpowered,
-	.vbus_session = arcotg_vbus_session,
-	.vbus_draw = arcotg_vbus_draw,
-	.pullup = arcotg_pullup,
+/* defined in gadget.h */
+static struct usb_gadget_ops fsl_gadget_ops = {
+	.get_frame = fsl_get_frame,
+	.wakeup = fsl_wakeup,
+/*	.set_selfpowered = fsl_set_selfpowered,	*/ /* Always selfpowered */
+	.vbus_session = fsl_vbus_session,
+	.vbus_draw = fsl_vbus_draw,
+	.pullup = fsl_pullup,
 };
 
-static void Ep0Stall(struct arcotg_udc *udc)
+/* Set protocol stall on ep0, protocol stall will automatically be cleared
+   on new transaction */
+static void ep0stall(struct fsl_udc *udc)
 {
 	u32 tmp;
 
-	pr_debug("%s\n", __FUNCTION__);
-	/* a protocol stall */
-	tmp = le32_to_cpu(usb_slave_regs->endptctrl[0]);
+	/* must set tx and rx to stall at the same time */
+	tmp = fsl_readl(&dr_regs->endptctrl[0]);
 	tmp |= EPCTRL_TX_EP_STALL | EPCTRL_RX_EP_STALL;
-	usb_slave_regs->endptctrl[0] = cpu_to_le32(tmp);
+	fsl_writel(tmp, &dr_regs->endptctrl[0]);
 	udc->ep0_state = WAIT_FOR_SETUP;
-	pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
 	udc->ep0_dir = 0;
 }
 
-/*!
- * if direction is EP_IN, the status is Device->Host
- * if direction is EP_OUT, the status transaction is Device<-Host
- * @param udc device controller pointer
- * @param direction in or out
- * @return Returns zero on success , or a negative error code
- */
-static int ep0_prime_status(struct arcotg_udc *udc, int direction)
+/* Prime a status phase for ep0 */
+static int ep0_prime_status(struct fsl_udc *udc, int direction)
 {
-
-	struct arcotg_req *req = udc->status_req;
-	struct arcotg_ep *ep;
+	struct fsl_req *req = udc->status_req;
+	struct fsl_ep *ep;
 	int status = 0;
-	unsigned long flags;
 
-	pr_debug("%s\n", __FUNCTION__);
 	if (direction == EP_DIR_IN)
 		udc->ep0_dir = USB_DIR_IN;
 	else
@@ -1482,7 +1273,6 @@ static int ep0_prime_status(struct arcotg_udc *udc, int direction)
 
 	ep = &udc->eps[0];
 	udc->ep0_state = WAIT_FOR_OUT_STATUS;
-	pr_debug("udc: ep0_state now WAIT_FOR_OUT_STATUS\n");
 
 	req->ep = ep;
 	req->req.length = 0;
@@ -1491,479 +1281,353 @@ static int ep0_prime_status(struct arcotg_udc *udc, int direction)
 	req->req.complete = NULL;
 	req->dtd_count = 0;
 
-	spin_lock_irqsave(&udc->lock, flags);
-
-	if ((arcotg_req_to_dtd(req, udc) == 0))
-		status = arcotg_queue_td(ep, req);
+	if (fsl_req_to_dtd(req) == 0)
+		status = fsl_queue_td(ep, req);
 	else
 		return -ENOMEM;
 
 	if (status)
-		printk(KERN_ERR "Can't get control status request \n");
-
+		ERR("Can't queue ep0 status request \n");
 	list_add_tail(&req->queue, &ep->queue);
-	dump_ep_queue(ep);
-
-	spin_unlock_irqrestore(&udc->lock, flags);
 
 	return status;
 }
 
-static int udc_reset_ep_queue(struct arcotg_udc *udc, u8 pipe)
+static inline int udc_reset_ep_queue(struct fsl_udc *udc, u8 pipe)
 {
-	struct arcotg_ep *ep = get_ep_by_pipe(udc, pipe);
+	struct fsl_ep *ep = get_ep_by_pipe(udc, pipe);
 
-	pr_debug("%s\n", __FUNCTION__);
-	/* FIXME: collect completed requests? */
 	if (!ep->name)
 		return 0;
 
-	nuke(ep, -ECONNRESET);
+	nuke(ep, -ESHUTDOWN);
 
 	return 0;
 }
-static void ch9SetAddress(struct arcotg_udc *udc, u16 value, u16 index,
-			  u16 length)
-{
-	pr_debug("udc: new address=%d\n", value);
 
+/*
+ * ch9 Set address
+ */
+static void ch9setaddress(struct fsl_udc *udc, u16 value, u16 index, u16 length)
+{
 	/* Save the new address to device struct */
 	udc->device_address = (u8) value;
-
 	/* Update usb state */
 	udc->usb_state = USB_STATE_ADDRESS;
-
 	/* Status phase */
 	if (ep0_prime_status(udc, EP_DIR_IN))
-		Ep0Stall(udc);
+		ep0stall(udc);
 }
 
-static void ch9GetStatus(struct arcotg_udc *udc, u16 value, u16 index,
-			 u16 length)
+/*
+ * ch9 Get status
+ */
+static void ch9getstatus(struct fsl_udc *udc, u8 request_type, u16 value,
+		u16 index, u16 length)
 {
-	u16 usb_status = 0;	/* fix me to give correct status */
+	u16 tmp = 0;		/* Status, cpu endian */
 
-	struct arcotg_req *req;
-	struct arcotg_ep *ep;
+	struct fsl_req *req;
+	struct fsl_ep *ep;
 	int status = 0;
-	unsigned long flags;
 
-	pr_debug("%s\n", __FUNCTION__);
 	ep = &udc->eps[0];
 
-	req = container_of(arcotg_alloc_request(&ep->ep, GFP_KERNEL),
-			   struct arcotg_req, req);
+	if ((request_type & USB_RECIP_MASK) == USB_RECIP_DEVICE) {
+		/* Get device status */
+		tmp = 1 << USB_DEVICE_SELF_POWERED;
+		tmp |= udc->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP;
+	} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_INTERFACE) {
+		/* Get interface status */
+		/* We don't have interface information in udc driver */
+		tmp = 0;
+	} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_ENDPOINT) {
+		/* Get endpoint status */
+		struct fsl_ep *target_ep;
+
+		target_ep = get_ep_by_pipe(udc, get_pipe_by_windex(index));
+
+		/* stall if endpoint doesn't exist */
+		if (!target_ep->desc)
+			goto stall;
+		tmp = dr_ep_get_stall(ep_index(target_ep), ep_is_in(target_ep))
+				<< USB_ENDPOINT_HALT;
+	}
+
+	udc->ep0_dir = USB_DIR_IN;
+	/* Borrow the per device status_req */
+	req = udc->status_req;
+	/* Fill in the reqest structure */
+	*((u16 *) req->req.buf) = cpu_to_le16(tmp);
+	req->ep = ep;
 	req->req.length = 2;
-	req->req.buf = &usb_status;
 	req->req.status = -EINPROGRESS;
 	req->req.actual = 0;
+	req->req.complete = NULL;
+	req->dtd_count = 0;
 
-	spin_lock_irqsave(&udc->lock, flags);
-
-	/* data phase */
-	if ((arcotg_req_to_dtd(req, udc) == 0))
-		status = arcotg_queue_td(ep, req);
+	/* prime the data phase */
+	if ((fsl_req_to_dtd(req) == 0))
+		status = fsl_queue_td(ep, req);
 	else			/* no mem */
 		goto stall;
 
 	if (status) {
-		printk(KERN_ERR "Can't respond to getstatus request \n");
-		Ep0Stall(udc);
-	} else {
-		udc->ep0_state = DATA_STATE_XMIT;
-		pr_debug("udc: ep0_state now DATA_STATE_XMIT\n");
+		ERR("Can't respond to getstatus request \n");
+		goto stall;
 	}
-
 	list_add_tail(&req->queue, &ep->queue);
-	dump_ep_queue(ep);
-
-	spin_unlock_irqrestore(&udc->lock, flags);
+	udc->ep0_state = DATA_STATE_XMIT;
 	return;
-
-      stall:
-	Ep0Stall(udc);
-}
-
-static void ch9SetConfig(struct arcotg_udc *udc, u16 value, u16 index,
-			 u16 length)
-{
-	pr_debug("udc: 1 calling gadget driver->setup\n");
-	udc->ep0_dir = USB_DIR_IN;
-	if (udc->driver->setup(&udc->gadget, &udc->local_setup_buff) >= 0) {
-		/* gadget layer deal with the status phase */
-		udc->usb_state = USB_STATE_CONFIGURED;
-		udc->ep0_state = WAIT_FOR_OUT_STATUS;
-		pr_debug("udc: ep0_state now WAIT_FOR_OUT_STATUS\n");
-	}
+stall:
+	ep0stall(udc);
 }
 
-static void setup_received_irq(struct arcotg_udc *udc,
-			       struct usb_ctrlrequest *setup)
+static void setup_received_irq(struct fsl_udc *udc,
+		struct usb_ctrlrequest *setup)
 {
-	u16 ptc = 0;		/* port test control */
-	int handled = 1;	/* set to zero if we do not handle the message, */
-	/* and should pass it to the gadget driver */
-
-	pr_debug("udc: request=0x%x\n", setup->bRequest);
-	/* Fix Endian (udc->local_setup_buff is cpu Endian now) */
-	setup->wValue = le16_to_cpu(setup->wValue);
-	setup->wIndex = le16_to_cpu(setup->wIndex);
-	setup->wLength = le16_to_cpu(setup->wLength);
+	u16 wValue = le16_to_cpu(setup->wValue);
+	u16 wIndex = le16_to_cpu(setup->wIndex);
+	u16 wLength = le16_to_cpu(setup->wLength);
 
 	udc_reset_ep_queue(udc, 0);
 
-	/* We asume setup only occurs on EP0 */
-	if (setup->bRequestType & USB_DIR_IN) {
-		if (ep0_prime_status(udc, EP_DIR_OUT))
-			Ep0Stall(udc);
-		udc->ep0_dir = USB_DIR_IN;
-	} else
-		udc->ep0_dir = USB_DIR_OUT;
-
-	if ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS) {
-		/* handle class requests */
-		switch (setup->bRequest) {
-
-		case USB_BULK_RESET_REQUEST:
-			udc->ep0_dir = USB_DIR_IN;
-			if (udc->driver->setup(&udc->gadget,
-					       &udc->local_setup_buff) >= 0) {
-				udc->ep0_state = WAIT_FOR_SETUP;
-				pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
-			}
+	/* We process some stardard setup requests here */
+	switch (setup->bRequest) {
+	case USB_REQ_GET_STATUS:
+		/* Data+Status phase from udc */
+		if ((setup->bRequestType & (USB_DIR_IN | USB_TYPE_MASK))
+					!= (USB_DIR_IN | USB_TYPE_STANDARD))
 			break;
+		ch9getstatus(udc, setup->bRequestType, wValue, wIndex, wLength);
+		return;
 
-		default:
-			handled = 0;
-			break;
-		}
-	} else if ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
-		/* handle standard requests */
-		switch (setup->bRequest) {
-
-		case USB_REQ_GET_STATUS:
-			if ((setup->
-			     bRequestType & (USB_DIR_IN | USB_TYPE_STANDARD))
-			    != (USB_DIR_IN | USB_TYPE_STANDARD))
-				break;
-			ch9GetStatus(udc, setup->wValue, setup->wIndex,
-				     setup->wLength);
+	case USB_REQ_SET_ADDRESS:
+		/* Status phase from udc */
+		if (setup->bRequestType != (USB_DIR_OUT | USB_TYPE_STANDARD
+						| USB_RECIP_DEVICE))
 			break;
+		ch9setaddress(udc, wValue, wIndex, wLength);
+		return;
 
-		case USB_REQ_SET_ADDRESS:
-			if (setup->bRequestType !=
-			    (USB_DIR_OUT | USB_TYPE_STANDARD |
-			     USB_RECIP_DEVICE))
-				break;
-			ch9SetAddress(udc, setup->wValue, setup->wIndex,
-				      setup->wLength);
-			break;
+	case USB_REQ_CLEAR_FEATURE:
+	case USB_REQ_SET_FEATURE:
+		/* Status phase from udc */
+	{
+		int rc = -EOPNOTSUPP;
 
-		case USB_REQ_SET_CONFIGURATION:
-			if (setup->bRequestType !=
-			    (USB_DIR_OUT | USB_TYPE_STANDARD |
-			     USB_RECIP_DEVICE))
-				break;
-			/* gadget layer take over the status phase */
-			ch9SetConfig(udc, setup->wValue, setup->wIndex,
-				     setup->wLength);
-			break;
-		case USB_REQ_SET_INTERFACE:
-			if (setup->bRequestType !=
-			    (USB_DIR_OUT | USB_TYPE_STANDARD |
-			     USB_RECIP_INTERFACE))
+		if ((setup->bRequestType & (USB_RECIP_MASK | USB_TYPE_MASK))
+				== (USB_RECIP_ENDPOINT | USB_TYPE_STANDARD)) {
+			int pipe = get_pipe_by_windex(wIndex);
+			struct fsl_ep *ep;
+
+			if (wValue != 0 || wLength != 0 || pipe > udc->max_ep)
 				break;
-			udc->ep0_dir = USB_DIR_IN;
-			if (udc->driver->setup(&udc->gadget,
-					       &udc->local_setup_buff) >= 0)
-				/* gadget layer take over the status phase */
+			ep = get_ep_by_pipe(udc, pipe);
+
+			spin_unlock(&udc->lock);
+			rc = fsl_ep_set_halt(&ep->ep,
+					(setup->bRequest == USB_REQ_SET_FEATURE)
+						? 1 : 0);
+			spin_lock(&udc->lock);
+
+		} else if ((setup->bRequestType & (USB_RECIP_MASK
+				| USB_TYPE_MASK)) == (USB_RECIP_DEVICE
+				| USB_TYPE_STANDARD)) {
+			/* Note: The driver has not include OTG support yet.
+			 * This will be set when OTG support is added */
+			if (!gadget_is_otg(&udc->gadget))
 				break;
-			/* Requests with no data phase */
-		case USB_REQ_CLEAR_FEATURE:
-		case USB_REQ_SET_FEATURE:
-			{	/* status transaction */
-				int rc = -EOPNOTSUPP;
-
-				if ((setup->bRequestType & USB_TYPE_MASK) !=
-				    USB_TYPE_STANDARD)
-					break;
-
-				/* we only support set/clear feature for endpoint */
-				if (setup->bRequestType == USB_RECIP_ENDPOINT) {
-					int dir = (setup->wIndex & 0x0080) ?
-					    EP_DIR_IN : EP_DIR_OUT;
-					int num = (setup->wIndex & 0x000f);
-					struct arcotg_ep *ep;
-
-					if (setup->wValue != 0
-					    || setup->wLength != 0
-					    || (num * 2 + dir) > USB_MAX_PIPES)
-						break;
-					ep = &udc->eps[num * 2 + dir];
-
-					if (setup->bRequest ==
-					    USB_REQ_SET_FEATURE) {
-						pr_debug("udc: udc: SET_FEATURE"
-							 " doing set_halt\n");
-						rc = _arcotg_ep_set_halt(&ep->
-									 ep, 1);
-					} else {
-						pr_debug("udc: CLEAR_FEATURE"
-							 " doing clear_halt\n");
-						rc = _arcotg_ep_set_halt(&ep->
-									 ep, 0);
-					}
-
-				} else if (setup->bRequestType ==
-					   USB_RECIP_DEVICE) {
-					if (setup->bRequest ==
-					    USB_REQ_SET_FEATURE) {
-						ptc = setup->wIndex >> 8;
-						rc = 0;
-					}
-					if (!udc->gadget.is_otg)
-						break;
-					else if (setup->bRequest ==
-						 USB_DEVICE_B_HNP_ENABLE)
-						udc->gadget.b_hnp_enable = 1;
-					else if (setup->bRequest ==
-						 USB_DEVICE_A_HNP_SUPPORT)
-						udc->gadget.a_hnp_support = 1;
-					else if (setup->bRequest ==
-						 USB_DEVICE_A_ALT_HNP_SUPPORT)
-						udc->gadget.a_alt_hnp_support =
-						    1;
-					rc = 0;
-				}
-				if (rc == 0) {
-					/* send status only if _arcotg_ep_set_halt success */
-					if (ep0_prime_status(udc, EP_DIR_IN))
-						Ep0Stall(udc);
-				}
+			else if (setup->bRequest == USB_DEVICE_B_HNP_ENABLE)
+				udc->gadget.b_hnp_enable = 1;
+			else if (setup->bRequest == USB_DEVICE_A_HNP_SUPPORT)
+				udc->gadget.a_hnp_support = 1;
+			else if (setup->bRequest ==
+					USB_DEVICE_A_ALT_HNP_SUPPORT)
+				udc->gadget.a_alt_hnp_support = 1;
+			else
 				break;
-			}
-		default:
-			handled = 0;
+			rc = 0;
+		} else
 			break;
-		}
-	} else {
-		/* vendor requests */
-		handled = 0;
-	}
-
-	if (!handled) {
-		/*!
-		 *  0x66 - Device_Reset_Request of Still Image Capture Device,
-		 *  0x22 - SET_CONTROL_LINE_STATE of Communication Device
-		 */
-		if (setup->bRequest == 0x66 || setup->bRequest == 0x22) {
-			udc->ep0_dir = USB_DIR_IN;
-			udc->driver->setup(&udc->gadget,
-					   &udc->local_setup_buff);
-			udc->ep0_state = WAIT_FOR_OUT_STATUS;
-			return;
-		}
-		/* 0x65 - Get_Extended_Event_Data of Still Image Capture Device */
-		if (setup->bRequest == 0x65)
-			return;
 
-		if (udc->driver->setup(&udc->gadget, &udc->local_setup_buff)
-		    != 0) {
-			Ep0Stall(udc);
-		} else if (setup->bRequestType & USB_DIR_IN) {
-			udc->ep0_state = DATA_STATE_XMIT;
-			pr_debug("udc: ep0_state now DATA_STATE_XMIT\n");
-		} else {
-			if (setup->wLength != 0) {
-				udc->ep0_state = DATA_STATE_RECV;
-				pr_debug
-				    ("udc: ep0_state now DATA_STATE_RECV\n");
-			}
+		if (rc == 0) {
+			if (ep0_prime_status(udc, EP_DIR_IN))
+				ep0stall(udc);
 		}
+		return;
 	}
 
-	if (ptc) {
-		if (ep0_prime_status(udc, EP_DIR_IN))
-			Ep0Stall(udc);
-
-		usb_slave_regs->portsc1 |= ptc << 16;
-		pr_debug("udc: switch to test mode.\n");
-		/* schedule a msleep wait for the USB HW to go into test mode */
-		schedule_delayed_work(&usbhset_work, 0);
+	default:
+		break;
 	}
-}
 
-/* use a global workqueue to use msleep, and not mdelay */
-static void usbhset_workqueue_handler(struct work_struct *work)
-{
-	msleep(10);
+	/* Requests handled by gadget */
+	if (wLength) {
+		/* Data phase from gadget, status phase from udc */
+		udc->ep0_dir = (setup->bRequestType & USB_DIR_IN)
+				?  USB_DIR_IN : USB_DIR_OUT;
+		spin_unlock(&udc->lock);
+		if (udc->driver->setup(&udc->gadget,
+				&udc->local_setup_buff) < 0)
+			ep0stall(udc);
+		spin_lock(&udc->lock);
+		udc->ep0_state = (setup->bRequestType & USB_DIR_IN)
+				?  DATA_STATE_XMIT : DATA_STATE_RECV;
+	} else {
+		/* No data phase, IN status from gadget */
+		udc->ep0_dir = USB_DIR_IN;
+		spin_unlock(&udc->lock);
+		if (udc->driver->setup(&udc->gadget,
+				&udc->local_setup_buff) < 0)
+			ep0stall(udc);
+		spin_lock(&udc->lock);
+		udc->ep0_state = WAIT_FOR_OUT_STATUS;
+	}
 }
 
-static void ep0_req_complete(struct arcotg_udc *udc, struct arcotg_ep *ep0,
-			     struct arcotg_req *req)
+/* Process request for Data or Status phase of ep0
+ * prime status phase if needed */
+static void ep0_req_complete(struct fsl_udc *udc, struct fsl_ep *ep0,
+		struct fsl_req *req)
 {
-	pr_debug("udc: req=0x%p  ep0_state=0x%x\n", req, udc->ep0_state);
 	if (udc->usb_state == USB_STATE_ADDRESS) {
 		/* Set the new address */
 		u32 new_address = (u32) udc->device_address;
-		usb_slave_regs->deviceaddr = cpu_to_le32(new_address <<
-							 USB_DEVICE_ADDRESS_BIT_POS);
-		pr_debug("udc: set deviceaddr to %d\n",
-			 usb_slave_regs->
-			 deviceaddr >> USB_DEVICE_ADDRESS_BIT_POS);
+		fsl_writel(new_address << USB_DEVICE_ADDRESS_BIT_POS,
+				&dr_regs->deviceaddr);
 	}
 
+	done(ep0, req, 0);
+
 	switch (udc->ep0_state) {
 	case DATA_STATE_XMIT:
-
-		done(ep0, req, 0);
 		/* receive status phase */
 		if (ep0_prime_status(udc, EP_DIR_OUT))
-			Ep0Stall(udc);
+			ep0stall(udc);
 		break;
-
 	case DATA_STATE_RECV:
-
-		done(ep0, req, 0);
 		/* send status phase */
 		if (ep0_prime_status(udc, EP_DIR_IN))
-			Ep0Stall(udc);
+			ep0stall(udc);
 		break;
-
 	case WAIT_FOR_OUT_STATUS:
-		done(ep0, req, 0);
 		udc->ep0_state = WAIT_FOR_SETUP;
-		pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
 		break;
-
 	case WAIT_FOR_SETUP:
-		pr_debug("udc: Unexpected interrupt\n");
+		ERR("Unexpect ep0 packets \n");
 		break;
-
 	default:
-		Ep0Stall(udc);
+		ep0stall(udc);
 		break;
 	}
 }
 
-static void tripwire_handler(struct arcotg_udc *udc, u8 ep_num, u8 * buffer_ptr)
+/* Tripwire mechanism to ensure a setup packet payload is extracted without
+ * being corrupted by another incoming setup packet */
+static void tripwire_handler(struct fsl_udc *udc, u8 ep_num, u8 *buffer_ptr)
 {
 	u32 temp;
 	struct ep_queue_head *qh;
+	struct fsl_usb2_platform_data *pdata = udc->pdata;
 
 	qh = &udc->ep_qh[ep_num * 2 + EP_DIR_OUT];
 
 	/* Clear bit in ENDPTSETUPSTAT */
-	temp = cpu_to_le32(1 << ep_num);
-	usb_slave_regs->endptsetupstat |= temp;
+	temp = fsl_readl(&dr_regs->endptsetupstat);
+	fsl_writel(temp | (1 << ep_num), &dr_regs->endptsetupstat);
 
 	/* while a hazard exists when setup package arrives */
 	do {
 		/* Set Setup Tripwire */
-		temp = cpu_to_le32(USB_CMD_SUTW);
-		usb_slave_regs->usbcmd |= temp;
+		temp = fsl_readl(&dr_regs->usbcmd);
+		fsl_writel(temp | USB_CMD_SUTW, &dr_regs->usbcmd);
 
 		/* Copy the setup packet to local buffer */
-		pr_debug("udc: qh=0x%p  copy setup buffer from 0x%p to 0x%p\n",
-			 qh, qh->setup_buffer, buffer_ptr);
-		memcpy(buffer_ptr, (u8 *) qh->setup_buffer, 8);
-	} while (!(le32_to_cpu(usb_slave_regs->usbcmd) & USB_CMD_SUTW));
+		if (pdata->le_setup_buf) {
+			u32 *p = (u32 *)buffer_ptr;
+			u32 *s = (u32 *)qh->setup_buffer;
 
-	/* Clear Setup Tripwire */
-	temp = le32_to_cpu(usb_slave_regs->usbcmd);
-	temp &= ~USB_CMD_SUTW;
-	usb_slave_regs->usbcmd = le32_to_cpu(temp);
+			/* Convert little endian setup buffer to CPU endian */
+			*p++ = le32_to_cpu(*s++);
+			*p = le32_to_cpu(*s);
+		} else {
+			memcpy(buffer_ptr, (u8 *) qh->setup_buffer, 8);
+		}
+	} while (!(fsl_readl(&dr_regs->usbcmd) & USB_CMD_SUTW));
 
-	timeout = 10000000;
-	while ((usb_slave_regs->endptsetupstat & 1) && --timeout) {
-		continue;
-	}
-	if (timeout == 0) {
-		printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-	}
+	/* Clear Setup Tripwire */
+	temp = fsl_readl(&dr_regs->usbcmd);
+	fsl_writel(temp & ~USB_CMD_SUTW, &dr_regs->usbcmd);
 }
 
-/*!
- * process_ep_req(): free the completed Tds for this req
- * FIXME: ERROR handling for multi-dtd requests
- * @param udc  device controller pointer
- * @param pipe endpoint pipe
- * @param req  request pointer
- * @return Returns zero on success , or a negative error code
- */
-static int process_ep_req(struct arcotg_udc *udc, int pipe,
-			  struct arcotg_req *curr_req)
+/* process-ep_req(): free the completed Tds for this req */
+static int process_ep_req(struct fsl_udc *udc, int pipe,
+		struct fsl_req *curr_req)
 {
-	struct ep_td_struct *curr_td, *tmp_td;
-	int td_complete, actual, remaining_length, j, tmp;
-	int status = 0;
-	int errors = 0;
-	struct ep_queue_head *curr_qh = &udc->ep_qh[pipe];
+	struct ep_td_struct *curr_td;
+	int	td_complete, actual, remaining_length, j, tmp;
+	int	status = 0;
+	int	errors = 0;
+	struct  ep_queue_head *curr_qh = &udc->ep_qh[pipe];
 	int direction = pipe % 2;
 
 	curr_td = curr_req->head;
 	td_complete = 0;
 	actual = curr_req->req.length;
 
-	pr_debug
-	    ("udc: curr_req=0x%p  curr_td=0x%p  actual=%d  size_ioc_sts=0x%x\n",
-	     curr_req, curr_td, actual, curr_td->size_ioc_sts);
-
 	for (j = 0; j < curr_req->dtd_count; j++) {
-		remaining_length = ((le32_to_cpu(curr_td->size_ioc_sts)
-				     & DTD_PACKET_SIZE) >> DTD_LENGTH_BIT_POS);
+		remaining_length = (hc32_to_cpu(curr_td->size_ioc_sts)
+					& DTD_PACKET_SIZE)
+				>> DTD_LENGTH_BIT_POS;
 		actual -= remaining_length;
 
-		if ((errors = le32_to_cpu(curr_td->size_ioc_sts) &
-		     DTD_ERROR_MASK)) {
+		errors = hc32_to_cpu(curr_td->size_ioc_sts) & DTD_ERROR_MASK;
+		if (errors) {
 			if (errors & DTD_STATUS_HALTED) {
-				printk(KERN_ERR "dTD error %08x \n", errors);
+				ERR("dTD error %08x QH=%d\n", errors, pipe);
 				/* Clear the errors and Halt condition */
-				tmp = le32_to_cpu(curr_qh->size_ioc_int_sts);
+				tmp = hc32_to_cpu(curr_qh->size_ioc_int_sts);
 				tmp &= ~errors;
-				curr_qh->size_ioc_int_sts = cpu_to_le32(tmp);
+				curr_qh->size_ioc_int_sts = cpu_to_hc32(tmp);
 				status = -EPIPE;
-				/*FIXME clearing active bit, update
-				 * nextTD pointer re-prime ep */
+				/* FIXME: continue with next queued TD? */
 
 				break;
 			}
 			if (errors & DTD_STATUS_DATA_BUFF_ERR) {
-				pr_debug("udc: Transfer overflow\n");
+				VDBG("Transfer overflow");
 				status = -EPROTO;
 				break;
 			} else if (errors & DTD_STATUS_TRANSACTION_ERR) {
-				pr_debug("udc: ISO error\n");
+				VDBG("ISO error");
 				status = -EILSEQ;
 				break;
 			} else
-				printk(KERN_ERR
-				       "Unknown error has occured (0x%x)!\r\n",
-				       errors);
-
-		} else if (le32_to_cpu(curr_td->size_ioc_sts) &
-			   DTD_STATUS_ACTIVE) {
-			pr_debug("udc: Request not wholly complete dtd=0x%p\n",
-				 curr_td);
+				ERR("Unknown error has occured (0x%x)!\r\n",
+					errors);
+
+		} else if (hc32_to_cpu(curr_td->size_ioc_sts)
+				& DTD_STATUS_ACTIVE) {
+			VDBG("Request not complete");
 			status = REQ_UNCOMPLETE;
 			return status;
-		} else if (remaining_length)
+		} else if (remaining_length) {
 			if (direction) {
-				pr_debug
-				    ("udc: Transmit dTD remaining length not zero "
-				     "(rl=%d)\n", remaining_length);
+				VDBG("Transmit dTD remaining length not zero");
 				status = -EPROTO;
 				break;
 			} else {
-				td_complete += 1;
+				td_complete++;
 				break;
+			}
 		} else {
-			td_complete += 1;
-			pr_debug("udc: dTD transmitted successful\n");
+			td_complete++;
+			VDBG("dTD transmitted successful ");
 		}
 
 		if (j != curr_req->dtd_count - 1)
-			curr_td = curr_td->next_td_virt;
+			curr_td = (struct ep_td_struct *)curr_td->next_td_virt;
 	}
 
 	if (status)
@@ -1971,42 +1635,25 @@ static int process_ep_req(struct arcotg_udc *udc, int pipe,
 
 	curr_req->req.actual = actual;
 
-	/* Free dtd for completed/error request */
-	curr_td = curr_req->head;
-	for (j = 0; j < curr_req->dtd_count; j++) {
-		tmp_td = curr_td;
-		if (j != curr_req->dtd_count - 1)
-			curr_td = curr_td->next_td_virt;
-		pr_debug("udc: freeing dtd 0x%p  curr_req=0x%p\n", tmp_td,
-			 curr_req);
-		dma_pool_free(udc->dtd_pool, tmp_td, tmp_td->td_dma);
-	}
-
-	return status;
+	return 0;
 }
 
-static void dtd_complete_irq(struct arcotg_udc *udc)
+/* Process a DTD completion interrupt */
+static void dtd_complete_irq(struct fsl_udc *udc)
 {
 	u32 bit_pos;
 	int i, ep_num, direction, bit_mask, status;
-	struct arcotg_ep *curr_ep;
-	struct arcotg_req *curr_req, *temp_req;
+	struct fsl_ep *curr_ep;
+	struct fsl_req *curr_req, *temp_req;
 
-	pr_debug("%s\n", __FUNCTION__);
 	/* Clear the bits in the register */
-	bit_pos = usb_slave_regs->endptcomplete;
-	usb_slave_regs->endptcomplete = bit_pos;
-
-	/* Clear the buffer if the ACK was missing from the IN ep */
-	if ((usb_slave_regs->endptstatus & 0x10000)
-	    && !(usb_slave_regs->endptstatus & 1))
-		usb_slave_regs->endptflush |= 0x10000;
+	bit_pos = fsl_readl(&dr_regs->endptcomplete);
+	fsl_writel(bit_pos, &dr_regs->endptcomplete);
 
-	bit_pos = le32_to_cpu(bit_pos);
 	if (!bit_pos)
 		return;
 
-	for (i = 0; i < USB_MAX_ENDPOINTS * 2; i++) {
+	for (i = 0; i < udc->max_ep * 2; i++) {
 		ep_num = i >> 1;
 		direction = i % 2;
 
@@ -2019,46 +1666,46 @@ static void dtd_complete_irq(struct arcotg_udc *udc)
 
 		/* If the ep is configured */
 		if (curr_ep->name == NULL) {
-			printk(KERN_WARNING "Invalid EP?\n");
+			WARN("Invalid EP?");
 			continue;
 		}
 
-		dump_ep_queue(curr_ep);
-
-		/* search all arcotg_reqs of ep */
+		/* process the req queue until an uncomplete request */
 		list_for_each_entry_safe(curr_req, temp_req, &curr_ep->queue,
-					 queue) {
+				queue) {
 			status = process_ep_req(udc, i, curr_req);
-			if (status == REQ_UNCOMPLETE) {
-				pr_debug
-				    ("udc: Not all tds are completed in the req\n");
+
+			VDBG("status of process_ep_req= %d, ep = %d",
+					status, ep_num);
+			if (status == REQ_UNCOMPLETE)
 				break;
-			}
+			/* write back status to req */
+			curr_req->req.status = status;
 
 			if (ep_num == 0) {
 				ep0_req_complete(udc, curr_ep, curr_req);
 				break;
 			} else
 				done(curr_ep, curr_req, status);
-
 		}
 
 		dump_ep_queue(curr_ep);
 	}
 }
 
-static void port_change_irq(struct arcotg_udc *udc)
+/* Process a port change interrupt */
+static void port_change_irq(struct fsl_udc *udc)
 {
 	u32 speed;
 
 	if (udc->bus_reset)
-		udc->bus_reset = FALSE;
+		udc->bus_reset = 0;
 
 	/* Bus resetting is finished */
-	if (!(le32_to_cpu(usb_slave_regs->portsc1) & PORTSCX_PORT_RESET)) {
+	if (!(fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET)) {
 		/* Get the speed */
-		speed = (le32_to_cpu(usb_slave_regs->portsc1) &
-			 PORTSCX_PORT_SPEED_MASK);
+		speed = (fsl_readl(&dr_regs->portsc1)
+				& PORTSCX_PORT_SPEED_MASK);
 		switch (speed) {
 		case PORTSCX_PORT_SPEED_HIGH:
 			udc->gadget.speed = USB_SPEED_HIGH;
@@ -2074,43 +1721,40 @@ static void port_change_irq(struct arcotg_udc *udc)
 			break;
 		}
 	}
-	pr_debug("udc: speed now %d\n", udc->gadget.speed);
 
 	/* Update USB state */
 	if (!udc->resume_state)
 		udc->usb_state = USB_STATE_DEFAULT;
 }
 
-static void suspend_irq(struct arcotg_udc *udc)
+/* Process suspend interrupt */
+static void suspend_irq(struct fsl_udc *udc)
 {
-	pr_debug("%s\n", __FUNCTION__);
+	pr_debug("%s\n", __func__);
 
 	udc->resume_state = udc->usb_state;
 	udc->usb_state = USB_STATE_SUSPENDED;
 
-	/* report suspend to the driver ,serial.c not support this */
+	/* report suspend to the driver, serial.c does not support this */
 	if (udc->driver->suspend)
 		udc->driver->suspend(&udc->gadget);
 }
 
-static void resume_irq(struct arcotg_udc *udc)
+static void bus_resume(struct fsl_udc *udc)
 {
-	pr_debug("%s\n", __FUNCTION__);
-
 	udc->usb_state = udc->resume_state;
 	udc->resume_state = 0;
 
-	/* report resume to the driver , serial.c not support this */
+	/* report resume to the driver, serial.c does not support this */
 	if (udc->driver->resume)
 		udc->driver->resume(&udc->gadget);
-
 }
 
-static int reset_queues(struct arcotg_udc *udc)
+/* Clear up all ep queues */
+static int reset_queues(struct fsl_udc *udc)
 {
 	u8 pipe;
 
-	pr_debug("udc: disconnect\n");
 	for (pipe = 0; pipe < udc->max_pipes; pipe++)
 		udc_reset_ep_queue(udc, pipe);
 
@@ -2120,105 +1764,111 @@ static int reset_queues(struct arcotg_udc *udc)
 	return 0;
 }
 
-static void reset_irq(struct arcotg_udc *udc)
+/* Process reset interrupt */
+static void reset_irq(struct fsl_udc *udc)
 {
 	u32 temp;
+	unsigned long timeout;
 
 	/* Clear the device address */
-	temp = le32_to_cpu(usb_slave_regs->deviceaddr);
-	temp &= ~USB_DEVICE_ADDRESS_MASK;
-	usb_slave_regs->deviceaddr = cpu_to_le32(temp);
-	pr_debug("udc: set deviceaddr to %d\n",
-		 usb_slave_regs->deviceaddr >> USB_DEVICE_ADDRESS_BIT_POS);
+	temp = fsl_readl(&dr_regs->deviceaddr);
+	fsl_writel(temp & ~USB_DEVICE_ADDRESS_MASK, &dr_regs->deviceaddr);
+
 	udc->device_address = 0;
 
 	/* Clear usb state */
-	udc->usb_state = USB_STATE_DEFAULT;
+	udc->resume_state = 0;
+	udc->ep0_dir = 0;
+	udc->ep0_state = WAIT_FOR_SETUP;
+	udc->remote_wakeup = 0;	/* default to 0 on reset */
+	udc->gadget.b_hnp_enable = 0;
+	udc->gadget.a_hnp_support = 0;
+	udc->gadget.a_alt_hnp_support = 0;
 
 	/* Clear all the setup token semaphores */
-	temp = le32_to_cpu(usb_slave_regs->endptsetupstat);
-	usb_slave_regs->endptsetupstat = cpu_to_le32(temp);
+	temp = fsl_readl(&dr_regs->endptsetupstat);
+	fsl_writel(temp, &dr_regs->endptsetupstat);
 
 	/* Clear all the endpoint complete status bits */
-	temp = le32_to_cpu(usb_slave_regs->endptcomplete);
-	usb_slave_regs->endptcomplete = cpu_to_le32(temp);
-
-	timeout = 10000000;
-	/* Wait until all endptprime bits cleared */
-	while ((usb_slave_regs->endpointprime) && --timeout) {
-		continue;
-	}
-	if (timeout == 0) {
-		printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
+	temp = fsl_readl(&dr_regs->endptcomplete);
+	fsl_writel(temp, &dr_regs->endptcomplete);
+
+	timeout = jiffies + 100;
+	while (fsl_readl(&dr_regs->endpointprime)) {
+		/* Wait until all endptprime bits cleared */
+		if (time_after(jiffies, timeout)) {
+			ERR("Timeout for reset\n");
+			break;
+		}
+		cpu_relax();
 	}
 
-	/* Write 1s to the Flush register */
-	usb_slave_regs->endptflush = 0xFFFFFFFF;
+	/* Write 1s to the flush register */
+	fsl_writel(0xffffffff, &dr_regs->endptflush);
 
-	if (le32_to_cpu(usb_slave_regs->portsc1) & PORTSCX_PORT_RESET) {
-		pr_debug("udc: Bus RESET\n");
+	if (fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET) {
+		VDBG("Bus reset");
 		/* Bus is reseting */
-		udc->bus_reset = TRUE;
-		udc->ep0_state = WAIT_FOR_SETUP;
-		pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
-		udc->ep0_dir = 0;
+		udc->bus_reset = 1;
 		/* Reset all the queues, include XD, dTD, EP queue
 		 * head and TR Queue */
 		reset_queues(udc);
+		udc->usb_state = USB_STATE_DEFAULT;
 	} else {
-		pr_debug("udc: Controller reset\n");
+		VDBG("Controller reset");
 		/* initialize usb hw reg except for regs for EP, not
 		 * touch usbintr reg */
 		dr_controller_setup(udc);
 
-		/* FIXME: Reset all internal used Queues */
+		/* Reset all internal used Queues */
 		reset_queues(udc);
 
-		ep0_dr_and_qh_setup(udc);
+		ep0_setup(udc);
 
 		/* Enable DR IRQ reg, Set Run bit, change udc state */
 		dr_controller_run(udc);
 		udc->usb_state = USB_STATE_ATTACHED;
-		udc->ep0_state = WAIT_FOR_SETUP;
-		pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
-		udc->ep0_dir = 0;
 	}
 }
 
-static irqreturn_t arcotg_udc_irq(int irq, void *_udc)
+/*
+ * USB device controller interrupt handler
+ */
+static irqreturn_t fsl_udc_irq(int irq, void *_udc)
 {
-	struct arcotg_udc *udc = _udc;
+	struct fsl_udc *udc = _udc;
 	u32 irq_src;
 	irqreturn_t status = IRQ_NONE;
 	unsigned long flags;
 
+	/* Disable ISR for OTG host mode */
 	if (udc->stopped)
-		return IRQ_NONE;	/* ignore irq if we're not running */
-
+		return IRQ_NONE;
 	spin_lock_irqsave(&udc->lock, flags);
-	irq_src = usb_slave_regs->usbsts & usb_slave_regs->usbintr;
+	irq_src = fsl_readl(&dr_regs->usbsts) & fsl_readl(&dr_regs->usbintr);
 	/* Clear notification bits */
-	usb_slave_regs->usbsts &= irq_src;
+	fsl_writel(irq_src, &dr_regs->usbsts);
 
-	irq_src = le32_to_cpu(irq_src);
-	pr_debug("udc: irq_src [0x%08x]\n", irq_src);
+	/* VDBG("irq_src [0x%8x]", irq_src); */
+
+	/* Need to resume? */
+	if (udc->usb_state == USB_STATE_SUSPENDED)
+		if ((fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_SUSPEND) == 0)
+			bus_resume(udc);
 
 	/* USB Interrupt */
 	if (irq_src & USB_STS_INT) {
-		/* Setup packet, we only support ep0 as control ep */
-		pr_debug("udc: endptsetupstat=0x%x  endptcomplete=0x%x\n",
-			 usb_slave_regs->endptsetupstat,
-			 usb_slave_regs->endptcomplete);
-		if (usb_slave_regs->
-		    endptsetupstat & cpu_to_le32(EP_SETUP_STATUS_EP0)) {
+		VDBG("Packet int");
+		/* Setup package, we only support ep0 as control ep */
+		if (fsl_readl(&dr_regs->endptsetupstat) & EP_SETUP_STATUS_EP0) {
 			tripwire_handler(udc, 0,
-					 (u8 *) (&udc->local_setup_buff));
+					(u8 *) (&udc->local_setup_buff));
 			setup_received_irq(udc, &udc->local_setup_buff);
 			status = IRQ_HANDLED;
 		}
 
 		/* completion of dtd */
-		if (usb_slave_regs->endptcomplete) {
+		if (fsl_readl(&dr_regs->endptcomplete)) {
 			dtd_complete_irq(udc);
 			status = IRQ_HANDLED;
 		}
@@ -2237,6 +1887,7 @@ static irqreturn_t arcotg_udc_irq(int irq, void *_udc)
 
 	/* Reset Received */
 	if (irq_src & USB_STS_RESET) {
+		VDBG("reset int");
 		reset_irq(udc);
 		status = IRQ_HANDLED;
 	}
@@ -2245,164 +1896,134 @@ static irqreturn_t arcotg_udc_irq(int irq, void *_udc)
 	if (irq_src & USB_STS_SUSPEND) {
 		suspend_irq(udc);
 		status = IRQ_HANDLED;
-	} else if (udc->resume_state) {
-		resume_irq(udc);
-		status = IRQ_HANDLED;
 	}
 
 	if (irq_src & (USB_STS_ERR | USB_STS_SYS_ERR)) {
-		pr_debug("udc: Error IRQ %x\n", irq_src);
-		status = IRQ_HANDLED;
+		VDBG("Error IRQ %x ", irq_src);
 	}
 
-	if (status != IRQ_HANDLED) {
-		pr_debug("udc: not handled  irq_src=0x%x\n", irq_src);
-	}
-
-	pr_debug("udc: irq_src [0x%08x] done.  regs now=0x%08x\n", irq_src,
-		 usb_slave_regs->usbsts & usb_slave_regs->usbintr);
-	pr_debug("-\n");
-	pr_debug("-\n");
 	spin_unlock_irqrestore(&udc->lock, flags);
-
 	return status;
 }
 
-/*!
- * tell the controller driver about gadget layer driver
- * The driver's bind function will be called to bind it to a gadget.
- * @param driver  for example fsg_driver from file_storage.c
- * @return Returns zero on success , or a negative error code
- */
+/*----------------------------------------------------------------*
+ * Hook to gadget drivers
+ * Called by initialization code of gadget drivers
+*----------------------------------------------------------------*/
 int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 {
 	int retval = -ENODEV;
 	unsigned long flags = 0;
-	struct arcotg_udc *udc = udc_controller;
 
-	pr_debug("udc: udc=0x%p\n", udc);
-
-	/* standard operations */
-	if (!udc)
+	if (!udc_controller)
 		return -ENODEV;
 
 	if (!driver || (driver->speed != USB_SPEED_FULL
-			&& driver->speed != USB_SPEED_HIGH)
-	    || !driver->bind || !driver->unbind ||
-	    !driver->disconnect || !driver->setup)
+				&& driver->speed != USB_SPEED_HIGH)
+			|| !driver->bind || !driver->disconnect
+			|| !driver->setup)
 		return -EINVAL;
 
-	if (udc->driver)
+	if (udc_controller->driver)
 		return -EBUSY;
 
 	/* lock is needed but whether should use this lock or another */
-	spin_lock_irqsave(&udc->lock, flags);
+	spin_lock_irqsave(&udc_controller->lock, flags);
 
 	driver->driver.bus = 0;
 	/* hook up the driver */
-	udc->driver = driver;
-	udc->gadget.dev.driver = &driver->driver;
-	spin_unlock_irqrestore(&udc->lock, flags);
+	udc_controller->driver = driver;
+	udc_controller->gadget.dev.driver = &driver->driver;
+	spin_unlock_irqrestore(&udc_controller->lock, flags);
 
-	retval = driver->bind(&udc->gadget);
+	/* bind udc driver to gadget driver */
+	retval = driver->bind(&udc_controller->gadget);
 	if (retval) {
-		pr_debug("bind to %s --> %d\n", driver->driver.name, retval);
-		udc->gadget.dev.driver = 0;
-		udc->driver = 0;
+		VDBG("bind to %s --> %d", driver->driver.name, retval);
+		udc_controller->gadget.dev.driver = 0;
+		udc_controller->driver = 0;
 		goto out;
 	}
 
-	if (udc->transceiver) {
-		/* Suspend the controller until OTG enables it */
-		udc_suspend(udc);
-		pr_debug("udc: suspend udc for OTG auto detect \n");
+	if (udc_controller->transceiver) {
+		/* Suspend the controller until OTG enable it */
+		udc_suspend(udc_controller);
+		printk(KERN_INFO "Suspend udc for OTG auto detect\n");
 
 		/* export udc suspend/resume call to OTG */
-		udc->gadget.dev.parent->driver->suspend = arcotg_udc_suspend;
-		udc->gadget.dev.parent->driver->resume = arcotg_udc_resume;
+		udc_controller->gadget.dev.driver->suspend = fsl_udc_suspend;
+		udc_controller->gadget.dev.driver->resume = fsl_udc_resume;
 
 		/* connect to bus through transceiver */
-		retval = otg_set_peripheral(udc->transceiver, &udc->gadget);
-		if (retval < 0) {
-			pr_debug("udc: can't bind to transceiver\n");
-			driver->unbind(&udc->gadget);
-			udc->gadget.dev.driver = 0;
-			udc->driver = 0;
-			return retval;
+		if (udc_controller->transceiver) {
+			retval = otg_set_peripheral(udc_controller->transceiver,
+						    &udc_controller->gadget);
+			if (retval < 0) {
+				ERR("can't bind to transceiver\n");
+				driver->unbind(&udc_controller->gadget);
+				udc_controller->gadget.dev.driver = 0;
+				udc_controller->driver = 0;
+				return retval;
+			}
 		}
 	} else {
 		/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
-		dr_controller_run(udc);
-		udc->usb_state = USB_STATE_ATTACHED;
-		udc->ep0_state = WAIT_FOR_SETUP;
-		pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
-		udc->ep0_dir = 0;
+		dr_controller_run(udc_controller);
+		udc_controller->usb_state = USB_STATE_ATTACHED;
+		udc_controller->ep0_state = WAIT_FOR_SETUP;
+		udc_controller->ep0_dir = 0;
 	}
+	printk(KERN_INFO "%s: bind to driver %s \n",
+			udc_controller->gadget.name, driver->driver.name);
 
-	printk(KERN_INFO "arcotg_udc: gadget %s bound to driver %s\n",
-	       udc->gadget.name, driver->driver.name);
-
-      out:
+out:
+	if (retval)
+		printk(KERN_DEBUG "retval %d \n", retval);
 	return retval;
 }
-
 EXPORT_SYMBOL(usb_gadget_register_driver);
 
+/* Disconnect from gadget driver */
 int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 {
-	struct arcotg_ep *loop_ep;
+	struct fsl_ep *loop_ep;
 	unsigned long flags;
-	struct arcotg_udc *udc = udc_controller;
 
-	pr_debug("usb_gadget_unregister_driver: udc=0x%p\n", udc);
-	if (!udc)
+	if (!udc_controller)
 		return -ENODEV;
 
-	if (!driver || driver != udc->driver)
+	if (!driver || driver != udc_controller->driver || !driver->unbind)
 		return -EINVAL;
 
-	if (udc->transceiver) {
-		(void)otg_set_peripheral(udc->transceiver, 0);
-		pr_debug("udc: set peripheral=NULL\n");
-	} else {
-		/* FIXME
-		   pullup_disable(udc);
-		 */
-	}
+	if (udc_controller->transceiver)
+		(void)otg_set_peripheral(udc_controller->transceiver, 0);
 
 	/* stop DR, disable intr */
-	dr_controller_stop(udc);
+	dr_controller_stop(udc_controller);
 
 	/* in fact, no needed */
-	udc->usb_state = USB_STATE_ATTACHED;
-	udc->ep0_state = WAIT_FOR_SETUP;
-	pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
-	udc->ep0_dir = 0;
+	udc_controller->usb_state = USB_STATE_ATTACHED;
+	udc_controller->ep0_state = WAIT_FOR_SETUP;
+	udc_controller->ep0_dir = 0;
 
 	/* stand operation */
-	spin_lock_irqsave(&udc->lock, flags);
-	udc->gadget.speed = USB_SPEED_UNKNOWN;
-	nuke(&udc->eps[0], -ESHUTDOWN);
-	list_for_each_entry(loop_ep, &udc->gadget.ep_list, ep.ep_list)
-	    nuke(loop_ep, -ESHUTDOWN);
-
-	/* report disconnect to free up endpoints */
-	pr_debug("udc: disconnect\n");
-	driver->disconnect(&udc->gadget);
-
-	spin_unlock_irqrestore(&udc->lock, flags);
+	spin_lock_irqsave(&udc_controller->lock, flags);
+	udc_controller->gadget.speed = USB_SPEED_UNKNOWN;
+	nuke(&udc_controller->eps[0], -ESHUTDOWN);
+	list_for_each_entry(loop_ep, &udc_controller->gadget.ep_list,
+			ep.ep_list)
+		nuke(loop_ep, -ESHUTDOWN);
+	spin_unlock_irqrestore(&udc_controller->lock, flags);
 
 	/* unbind gadget and unhook driver. */
-	pr_debug("udc: unbind\n");
-	driver->unbind(&udc->gadget);
-	udc->gadget.dev.driver = 0;
-	udc->driver = 0;
+	driver->unbind(&udc_controller->gadget);
+	udc_controller->gadget.dev.driver = 0;
+	udc_controller->driver = 0;
 
 	printk(KERN_INFO "unregistered gadget driver '%s'\r\n",
 	       driver->driver.name);
 	return 0;
 }
-
 EXPORT_SYMBOL(usb_gadget_unregister_driver);
 
 /*-------------------------------------------------------------------------
@@ -2412,10 +2033,10 @@ EXPORT_SYMBOL(usb_gadget_unregister_driver);
 
 #include <linux/seq_file.h>
 
-static const char proc_filename[] = "driver/arcotg_udc";
+static const char proc_filename[] = "driver/fsl_usb2_udc";
 
-static int arcotg_proc_read(char *page, char **start, off_t off, int count,
-			    int *eof, void *_dev)
+static int fsl_proc_read(char *page, char **start, off_t off, int count,
+		int *eof, void *_dev)
 {
 	char *buf = page;
 	char *next = buf;
@@ -2423,10 +2044,12 @@ static int arcotg_proc_read(char *page, char **start, off_t off, int count,
 	unsigned long flags;
 	int t, i;
 	u32 tmp_reg;
-	struct arcotg_ep *ep = NULL;
-	struct arcotg_req *req;
+	struct fsl_ep *ep = NULL;
+	struct fsl_req *req;
+	struct fsl_usb2_platform_data *pdata;
 
-	struct arcotg_udc *udc = udc_controller;
+	struct fsl_udc *udc = udc_controller;
+	pdata = udc->pdata;
 	if (off != 0)
 		return 0;
 
@@ -2434,162 +2057,182 @@ static int arcotg_proc_read(char *page, char **start, off_t off, int count,
 
 	/* ------basic driver infomation ---- */
 	t = scnprintf(next, size,
-		      DRIVER_DESC "\n" "%s version: %s\n"
-		      "Gadget driver: %s\n\n", driver_name, DRIVER_VERSION,
-		      udc->driver ? udc->driver->driver.name : "(none)");
+			DRIVER_DESC "\n"
+			"%s version: %s\n"
+			"Gadget driver: %s\n\n",
+			driver_name, DRIVER_VERSION,
+			udc->driver ? udc->driver->driver.name : "(none)");
 	size -= t;
 	next += t;
 
 	/* ------ DR Registers ----- */
-	tmp_reg = le32_to_cpu(usb_slave_regs->usbcmd);
+	tmp_reg = fsl_readl(&dr_regs->usbcmd);
 	t = scnprintf(next, size,
-		      "USBCMD reg:\n" "SetupTW: %d\n" "Run/Stop: %s\n\n",
-		      (tmp_reg & USB_CMD_SUTW) ? 1 : 0,
-		      (tmp_reg & USB_CMD_RUN_STOP) ? "Run" : "Stop");
+			"USBCMD reg:\n"
+			"SetupTW: %d\n"
+			"Run/Stop: %s\n\n",
+			(tmp_reg & USB_CMD_SUTW) ? 1 : 0,
+			(tmp_reg & USB_CMD_RUN_STOP) ? "Run" : "Stop");
 	size -= t;
 	next += t;
 
-	tmp_reg = le32_to_cpu(usb_slave_regs->usbsts);
+	tmp_reg = fsl_readl(&dr_regs->usbsts);
 	t = scnprintf(next, size,
-		      "USB Status Reg:\n" "Dr Suspend: %d"
-		      "Reset Received: %d" "System Error: %s"
-		      "USB Error Interrupt: %s\n\n",
-		      (tmp_reg & USB_STS_SUSPEND) ? 1 : 0,
-		      (tmp_reg & USB_STS_RESET) ? 1 : 0,
-		      (tmp_reg & USB_STS_SYS_ERR) ? "Err" : "Normal",
-		      (tmp_reg & USB_STS_ERR) ? "Err detected" : "No err");
+			"USB Status Reg:\n"
+			"Dr Suspend: %d" "Reset Received: %d" "System Error: %s"
+			"USB Error Interrupt: %s\n\n",
+			(tmp_reg & USB_STS_SUSPEND) ? 1 : 0,
+			(tmp_reg & USB_STS_RESET) ? 1 : 0,
+			(tmp_reg & USB_STS_SYS_ERR) ? "Err" : "Normal",
+			(tmp_reg & USB_STS_ERR) ? "Err detected" : "No err");
 	size -= t;
 	next += t;
 
-	tmp_reg = le32_to_cpu(usb_slave_regs->usbintr);
+	tmp_reg = fsl_readl(&dr_regs->usbintr);
 	t = scnprintf(next, size,
-		      "USB Intrrupt Enable Reg:\n"
-		      "Sleep Enable: %d" "SOF Received Enable: %d"
-		      "Reset Enable: %d\n" "System Error Enable: %d"
-		      "Port Change Dectected Enable: %d\n"
-		      "USB Error Intr Enable: %d"
-		      "USB Intr Enable: %d\n\n",
-		      (tmp_reg & USB_INTR_DEVICE_SUSPEND) ? 1 : 0,
-		      (tmp_reg & USB_INTR_SOF_EN) ? 1 : 0,
-		      (tmp_reg & USB_INTR_RESET_EN) ? 1 : 0,
-		      (tmp_reg & USB_INTR_SYS_ERR_EN) ? 1 : 0,
-		      (tmp_reg & USB_INTR_PTC_DETECT_EN) ? 1 : 0,
-		      (tmp_reg & USB_INTR_ERR_INT_EN) ? 1 : 0,
-		      (tmp_reg & USB_INTR_INT_EN) ? 1 : 0);
+			"USB Intrrupt Enable Reg:\n"
+			"Sleep Enable: %d" "SOF Received Enable: %d"
+			"Reset Enable: %d\n"
+			"System Error Enable: %d"
+			"Port Change Dectected Enable: %d\n"
+			"USB Error Intr Enable: %d" "USB Intr Enable: %d\n\n",
+			(tmp_reg & USB_INTR_DEVICE_SUSPEND) ? 1 : 0,
+			(tmp_reg & USB_INTR_SOF_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_RESET_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_SYS_ERR_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_PTC_DETECT_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_ERR_INT_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_INT_EN) ? 1 : 0);
 	size -= t;
 	next += t;
 
-	tmp_reg = le32_to_cpu(usb_slave_regs->frindex);
+	tmp_reg = fsl_readl(&dr_regs->frindex);
 	t = scnprintf(next, size,
-		      "USB Frame Index Reg:" "Frame Number is 0x%x\n\n",
-		      (tmp_reg & USB_FRINDEX_MASKS));
+			"USB Frame Index Reg:" "Frame Number is 0x%x\n\n",
+			(tmp_reg & USB_FRINDEX_MASKS));
 	size -= t;
 	next += t;
 
-	tmp_reg = le32_to_cpu(usb_slave_regs->deviceaddr);
+	tmp_reg = fsl_readl(&dr_regs->deviceaddr);
 	t = scnprintf(next, size,
-		      "USB Device Address Reg:" "Device Addr is 0x%x\n\n",
-		      (tmp_reg & USB_DEVICE_ADDRESS_MASK));
+			"USB Device Address Reg:" "Device Addr is 0x%x\n\n",
+			(tmp_reg & USB_DEVICE_ADDRESS_MASK));
 	size -= t;
 	next += t;
 
-	tmp_reg = le32_to_cpu(usb_slave_regs->endpointlistaddr);
+	tmp_reg = fsl_readl(&dr_regs->endpointlistaddr);
 	t = scnprintf(next, size,
-		      "USB Endpoint List Address Reg:"
-		      "Device Addr is 0x%x\n\n",
-		      (tmp_reg & USB_EP_LIST_ADDRESS_MASK));
+			"USB Endpoint List Address Reg:"
+			"Device Addr is 0x%x\n\n",
+			(tmp_reg & USB_EP_LIST_ADDRESS_MASK));
 	size -= t;
 	next += t;
 
-	tmp_reg = le32_to_cpu(usb_slave_regs->portsc1);
+	tmp_reg = fsl_readl(&dr_regs->portsc1);
 	t = scnprintf(next, size,
-		      "USB Port Status&Control Reg:\n"
-		      "Port Transceiver Type : %s" "Port Speed: %s \n"
-		      "PHY Low Power Suspend: %s" "Port Reset: %s"
-		      "Port Suspend Mode: %s \n" "Over-current Change: %s"
-		      "Port Enable/Disable Change: %s\n"
-		      "Port Enabled/Disabled: %s"
-		      "Current Connect Status: %s\n\n", ( {
-							 char *s;
-							 switch (tmp_reg &
-								 PORTSCX_PTS_FSLS)
-							 {
-case PORTSCX_PTS_UTMI:
-s = "UTMI"; break; case PORTSCX_PTS_ULPI:
-s = "ULPI "; break; case PORTSCX_PTS_FSLS:
-s = "FS/LS Serial"; break; default:
-							 s = "None"; break;}
-							 s;}
-		      ), ( {
-			  char *s; switch (tmp_reg & PORTSCX_PORT_SPEED_UNDEF) {
-case PORTSCX_PORT_SPEED_FULL:
-s = "Full Speed"; break; case PORTSCX_PORT_SPEED_LOW:
-s = "Low Speed"; break; case PORTSCX_PORT_SPEED_HIGH:
-s = "High Speed"; break; default:
-			  s = "Undefined"; break;}
-			  s;}
-		      ),
-		      (tmp_reg & PORTSCX_PHY_LOW_POWER_SPD) ?
-		      "Normal PHY mode" : "Low power mode",
-		      (tmp_reg & PORTSCX_PORT_RESET) ? "In Reset" :
-		      "Not in Reset",
-		      (tmp_reg & PORTSCX_PORT_SUSPEND) ? "In " : "Not in",
-		      (tmp_reg & PORTSCX_OVER_CURRENT_CHG) ? "Dected" :
-		      "No",
-		      (tmp_reg & PORTSCX_PORT_EN_DIS_CHANGE) ? "Disable" :
-		      "Not change",
-		      (tmp_reg & PORTSCX_PORT_ENABLE) ? "Enable" :
-		      "Not correct",
-		      (tmp_reg & PORTSCX_CURRENT_CONNECT_STATUS) ?
-		      "Attached" : "Not-Att") ;
+		"USB Port Status&Control Reg:\n"
+		"Port Transceiver Type : %s" "Port Speed: %s \n"
+		"PHY Low Power Suspend: %s" "Port Reset: %s"
+		"Port Suspend Mode: %s \n" "Over-current Change: %s"
+		"Port Enable/Disable Change: %s\n"
+		"Port Enabled/Disabled: %s"
+		"Current Connect Status: %s\n\n", ({
+			char *s;
+			switch (tmp_reg & PORTSCX_PTS_FSLS) {
+			case PORTSCX_PTS_UTMI:
+				s = "UTMI"; break;
+			case PORTSCX_PTS_ULPI:
+				s = "ULPI "; break;
+			case PORTSCX_PTS_FSLS:
+				s = "FS/LS Serial"; break;
+			default:
+				s = "None"; break;
+			}
+			s; }), ({
+			char *s;
+			switch (tmp_reg & PORTSCX_PORT_SPEED_UNDEF) {
+			case PORTSCX_PORT_SPEED_FULL:
+				s = "Full Speed"; break;
+			case PORTSCX_PORT_SPEED_LOW:
+				s = "Low Speed"; break;
+			case PORTSCX_PORT_SPEED_HIGH:
+				s = "High Speed"; break;
+			default:
+				s = "Undefined"; break;
+			}
+			s;
+		}),
+		(tmp_reg & PORTSCX_PHY_LOW_POWER_SPD) ?
+		"Normal PHY mode" : "Low power mode",
+		(tmp_reg & PORTSCX_PORT_RESET) ? "In Reset" :
+		"Not in Reset",
+		(tmp_reg & PORTSCX_PORT_SUSPEND) ? "In " : "Not in",
+		(tmp_reg & PORTSCX_OVER_CURRENT_CHG) ? "Dected" :
+		"No",
+		(tmp_reg & PORTSCX_PORT_EN_DIS_CHANGE) ? "Disable" :
+		"Not change",
+		(tmp_reg & PORTSCX_PORT_ENABLE) ? "Enable" :
+		"Not correct",
+		(tmp_reg & PORTSCX_CURRENT_CONNECT_STATUS) ?
+		"Attached" : "Not-Att");
 	size -= t;
 	next += t;
 
-	tmp_reg = le32_to_cpu(usb_slave_regs->usbmode);
-	t = scnprintf(next, size, "USB Mode Reg:" "Controller Mode is : %s\n\n", ( {
-										  char
-										  *s;
-										  switch
-										  (tmp_reg
-										   &
-										   USB_MODE_CTRL_MODE_HOST)
-										  {
-case USB_MODE_CTRL_MODE_IDLE:
-s = "Idle"; break; case USB_MODE_CTRL_MODE_DEVICE:
-s = "Device Controller"; break; case USB_MODE_CTRL_MODE_HOST:
-s = "Host Controller"; break; default:
-										  s
-										  =
-										  "None";
-										  break;}
-										  s;}
-		      )) ;
+	tmp_reg = fsl_readl(&dr_regs->usbmode);
+	t = scnprintf(next, size,
+			"USB Mode Reg:" "Controller Mode is : %s\n\n", ({
+				char *s;
+				switch (tmp_reg & USB_MODE_CTRL_MODE_HOST) {
+				case USB_MODE_CTRL_MODE_IDLE:
+					s = "Idle"; break;
+				case USB_MODE_CTRL_MODE_DEVICE:
+					s = "Device Controller"; break;
+				case USB_MODE_CTRL_MODE_HOST:
+					s = "Host Controller"; break;
+				default:
+					s = "None"; break;
+				}
+				s;
+			}));
 	size -= t;
 	next += t;
 
-	tmp_reg = le32_to_cpu(usb_slave_regs->endptsetupstat);
+	tmp_reg = fsl_readl(&dr_regs->endptsetupstat);
 	t = scnprintf(next, size,
-		      "Endpoint Setup Status Reg:" "SETUP on ep 0x%x\n\n",
-		      (tmp_reg & EP_SETUP_STATUS_MASK));
+			"Endpoint Setup Status Reg:" "SETUP on ep 0x%x\n\n",
+			(tmp_reg & EP_SETUP_STATUS_MASK));
 	size -= t;
 	next += t;
 
-	for (i = 0; i < USB_MAX_ENDPOINTS; i++) {
-		tmp_reg = le32_to_cpu(usb_slave_regs->endptctrl[i]);
+	for (i = 0; i < udc->max_ep / 2; i++) {
+		tmp_reg = fsl_readl(&dr_regs->endptctrl[i]);
 		t = scnprintf(next, size, "EP Ctrl Reg [0x%x]: = [0x%x]\n",
-			      i, tmp_reg);
+				i, tmp_reg);
 		size -= t;
 		next += t;
 	}
-	tmp_reg = le32_to_cpu(usb_slave_regs->endpointprime);
+	tmp_reg = fsl_readl(&dr_regs->endpointprime);
 	t = scnprintf(next, size, "EP Prime Reg = [0x%x]\n", tmp_reg);
 	size -= t;
 	next += t;
 
-	/* ------arcotg_udc, arcotg_ep, arcotg_request structure information ----- */
+	if (pdata->have_sysif_regs) {
+		tmp_reg = usb_sys_regs->snoop1;
+		t = scnprintf(next, size, "\nSnoop1 Reg = [0x%x]\n\n", tmp_reg);
+		size -= t;
+		next += t;
+
+		tmp_reg = usb_sys_regs->control;
+		t = scnprintf(next, size, "General Control Reg = [0x%x]\n\n",
+				tmp_reg);
+		size -= t;
+		next += t;
+	}
+
+	/* ------fsl_udc, fsl_ep, fsl_request structure information ----- */
 	ep = &udc->eps[0];
 	t = scnprintf(next, size, "For %s Maxpkt is 0x%x index is 0x%x\n",
-		      ep->ep.name, ep_maxpacket(ep), ep_index(ep));
+			ep->ep.name, ep_maxpacket(ep), ep_index(ep));
 	size -= t;
 	next += t;
 
@@ -2600,9 +2243,9 @@ s = "Host Controller"; break; default:
 	} else {
 		list_for_each_entry(req, &ep->queue, queue) {
 			t = scnprintf(next, size,
-				      "req %p actual 0x%x length 0x%x  buf %p\n",
-				      &req->req, req->req.actual,
-				      req->req.length, req->req.buf);
+				"req %p actual 0x%x length 0x%x  buf %p\n",
+				&req->req, req->req.actual,
+				req->req.length, req->req.buf);
 			size -= t;
 			next += t;
 		}
@@ -2611,40 +2254,31 @@ s = "Host Controller"; break; default:
 	list_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {
 		if (ep->desc) {
 			t = scnprintf(next, size,
-				      "\nFor %s Maxpkt is 0x%x index is 0x%x\n",
-				      ep->ep.name,
-				      ep_maxpacket(ep), ep_index(ep));
+					"\nFor %s Maxpkt is 0x%x "
+					"index is 0x%x\n",
+					ep->ep.name, ep_maxpacket(ep),
+					ep_index(ep));
 			size -= t;
 			next += t;
 
 			if (list_empty(&ep->queue)) {
 				t = scnprintf(next, size,
-					      "its req queue is empty\n\n");
+						"its req queue is empty\n\n");
 				size -= t;
 				next += t;
 			} else {
 				list_for_each_entry(req, &ep->queue, queue) {
 					t = scnprintf(next, size,
-						      "req %p actual 0x%x length"
-						      "0x%x  buf %p\n",
-						      &req->req,
-						      req->req.actual,
-						      req->req.length,
-						      req->req.buf);
+						"req %p actual 0x%x length"
+						"0x%x  buf %p\n",
+						&req->req, req->req.actual,
+						req->req.length, req->req.buf);
 					size -= t;
 					next += t;
-				}
-			}
-		}
-#if 0				/* DDD debug */
-		else {
-			t = scnprintf(next, size, "\nno desc for %s\n",
-				      ep->ep.name);
-			size -= t;
-			next += t;
-		}
-#endif
-	}
+					} /* end for each_entry of ep req */
+				}	/* end for else */
+			}	/* end for if(ep->queue) */
+		}		/* end (ep->desc) */
 
 	spin_unlock_irqrestore(&udc->lock, flags);
 
@@ -2653,7 +2287,7 @@ s = "Host Controller"; break; default:
 }
 
 #define create_proc_file()	create_proc_read_entry(proc_filename, \
-				0, NULL, arcotg_proc_read, NULL)
+				0, NULL, fsl_proc_read, NULL)
 
 #define remove_proc_file()	remove_proc_entry(proc_filename, NULL)
 
@@ -2662,374 +2296,322 @@ s = "Host Controller"; break; default:
 #define create_proc_file()	do {} while (0)
 #define remove_proc_file()	do {} while (0)
 
-#endif				/*CONFIG_USB_GADGET_DEBUG_FILES */
+#endif				/* CONFIG_USB_GADGET_DEBUG_FILES */
 
 /*-------------------------------------------------------------------------*/
 
-/*!
- * Release the ARC OTG specific udc structure
- * it is not stand gadget function
- * it is called when the last reference to the device is removed;
- * it is called from the embedded kobject's release method.
- * All device structures registered with the core must have a
- * release method, or the kernel prints out scary complaints
- * @param dev device controller pointer
- */
-static void arcotg_gadget_release(struct device *dev)
+/* Release udc structures */
+static void fsl_udc_release(struct device *dev)
 {
-	struct device *udc_dev = dev->parent;
-
-	struct arcotg_udc *udc = (struct arcotg_udc *)dev_get_drvdata(udc_dev);
-
-	complete(udc->done);
-	dma_free_coherent(dev, udc->ep_qh_size, udc->ep_qh, udc->ep_qh_dma);
-	kfree(udc);
+	complete(udc_controller->done);
+	dma_free_coherent(dev, udc_controller->ep_qh_size,
+			udc_controller->ep_qh, udc_controller->ep_qh_dma);
+	kfree(udc_controller);
 }
 
 /******************************************************************
-	Internal Structure Build up functions -2
+	Internal structure setup functions
 *******************************************************************/
-/*!
- * this func will init resource for globle controller
- * Return the udc handle on success or Null on failing
- * @param pdev device controller pointer
- */
-static void *struct_udc_setup(struct platform_device *pdev)
+/*------------------------------------------------------------------
+ * init resource for globle controller
+ * Return the udc handle on success or NULL on failure
+ ------------------------------------------------------------------*/
+static int __init struct_udc_setup(struct fsl_udc *udc,
+		struct platform_device *pdev)
 {
-	struct arcotg_udc *udc = NULL;
-
-	udc = (struct arcotg_udc *)
-	    kmalloc(sizeof(struct arcotg_udc), GFP_KERNEL);
-	pr_debug("udc: kmalloc(ucd)=0x%p\n", udc);
-	if (udc == NULL) {
-		printk(KERN_ERR "malloc udc failed\n");
-		goto cleanup;
-	}
+	struct fsl_usb2_platform_data *pdata;
+	size_t size;
 
-	/* Zero out the internal USB state structure */
-	memset(udc, 0, sizeof(struct arcotg_udc));
+	pdata = pdev->dev.platform_data;
+	udc->phy_mode = pdata->phy_mode;
 
-	/* initialized QHs, take care the 2K align */
-	udc->ep_qh_size = USB_MAX_PIPES * sizeof(struct ep_queue_head);
+	udc->eps = kzalloc(sizeof(struct fsl_ep) * udc->max_ep, GFP_KERNEL);
+	if (!udc->eps) {
+		ERR("malloc fsl_ep failed\n");
+		return -1;
+	}
 
-	/* Arc OTG IP-core requires 2K alignment of queuehead
-	 * this if fullfilled by per page allocation
-	 * by dma_alloc_coherent(...)
-	 */
-	udc->ep_qh = (struct ep_queue_head *)
-	    dma_alloc_coherent(&pdev->dev, udc->ep_qh_size,
-			       &udc->ep_qh_dma, GFP_KERNEL);
+	/* initialized QHs, take care of alignment */
+	size = udc->max_ep * sizeof(struct ep_queue_head);
+	if (size < QH_ALIGNMENT)
+		size = QH_ALIGNMENT;
+	else if ((size % QH_ALIGNMENT) != 0) {
+		size += QH_ALIGNMENT + 1;
+		size &= ~(QH_ALIGNMENT - 1);
+	}
+	udc->ep_qh = dma_alloc_coherent(&pdev->dev, size,
+					&udc->ep_qh_dma, GFP_KERNEL);
 	if (!udc->ep_qh) {
-		printk(KERN_ERR "malloc QHs for udc failed\n");
-		goto cleanup;
+		ERR("malloc QHs for udc failed\n");
+		kfree(udc->eps);
+		return -1;
 	}
-	pr_debug("udc: udc->ep_qh=0x%p\n", udc->ep_qh);
-
-	memset(udc->ep_qh, 0, udc->ep_qh_size);
 
-	/* need 32 byte alignment, don't cross 4K boundary */
-	udc->dtd_pool = dma_pool_create("arcotg_dtd", &pdev->dev,
-					sizeof(struct ep_td_struct), 32, 4096);
-	if (!udc->dtd_pool) {
-		printk(KERN_ERR "dtd_pool alloc failed\n");
-		goto cleanup;
-	}
+	udc->ep_qh_size = size;
 
 	/* Initialize ep0 status request structure */
-	/* FIXME: arcotg_alloc_request() ignores ep argument */
-	udc->status_req =
-	    container_of(arcotg_alloc_request(NULL, GFP_KERNEL),
-			 struct arcotg_req, req);
-
+	/* FIXME: fsl_alloc_request() ignores ep argument */
+	udc->status_req = container_of(fsl_alloc_request(NULL, GFP_KERNEL),
+			struct fsl_req, req);
 	/* allocate a small amount of memory to get valid address */
 	udc->status_req->req.buf = kmalloc(8, GFP_KERNEL);
 	udc->status_req->req.dma = virt_to_phys(udc->status_req->req.buf);
 
-	pr_debug("udc: status_req=0x%p  status_req->req.buf=0x%p  "
-		 "status_req->req.dma=0x%x",
-		 udc->status_req, udc->status_req->req.buf,
-		 udc->status_req->req.dma);
-
 	udc->resume_state = USB_STATE_NOTATTACHED;
 	udc->usb_state = USB_STATE_POWERED;
 	udc->ep0_dir = 0;
-	/* initliaze the arcotg_udc lock */
+	udc->remote_wakeup = 0;	/* default to 0 on reset */
 	spin_lock_init(&udc->lock);
 
-	return udc;
-
-      cleanup:
-	kfree(udc);
-	return NULL;
+	return 0;
 }
 
-/*!
- * set up the arcotg_ep struct for eps
- * ep0out isnot used so do nothing here
+/*----------------------------------------------------------------
+ * Setup the fsl_ep struct for eps
+ * Link fsl_ep->ep to gadget->ep_list
+ * ep0out is not used so do nothing here
  * ep0in should be taken care
- * It also link this arcotg_ep->ep to gadget->ep_list
- * @param udc   device controller pointer
- * @param pipe_num pipe number
- * @return Returns zero on success , or a negative error code
- */
-static int struct_ep_setup(struct arcotg_udc *udc, unsigned char pipe_num)
+ *--------------------------------------------------------------*/
+static int __init struct_ep_setup(struct fsl_udc *udc, unsigned char index,
+		char *name, int link)
 {
-	struct arcotg_ep *ep = get_ep_by_pipe(udc, pipe_num);
+	struct fsl_ep *ep = &udc->eps[index];
 
-	/*
-	   VDBG("pipe_num=%d  name[%d]=%s",
-	   pipe_num, pipe_num, ep_name[pipe_num]);
-	 */
 	ep->udc = udc;
-	strcpy(ep->name, ep_name[pipe_num]);
-	ep->ep.name = ep_name[pipe_num];
-	ep->ep.ops = &arcotg_ep_ops;
+	strcpy(ep->name, name);
+	ep->ep.name = ep->name;
+
+	ep->ep.ops = &fsl_ep_ops;
 	ep->stopped = 0;
 
-	/* for ep0: the desc defined here;
-	 * for other eps, gadget layer called ep_enable with defined desc
-	 */
 	/* for ep0: maxP defined in desc
 	 * for other eps, maxP is set by epautoconfig() called by gadget layer
 	 */
-	if (pipe_num == 0) {
-		ep->desc = &arcotg_ep0_desc;
-		ep->ep.maxpacket = USB_MAX_CTRL_PAYLOAD;
-	} else {
-		ep->ep.maxpacket = (unsigned short)~0;
-		ep->desc = NULL;
-	}
+	ep->ep.maxpacket = (unsigned short) ~0;
 
 	/* the queue lists any req for this ep */
 	INIT_LIST_HEAD(&ep->queue);
 
-	/* arcotg_ep->ep.ep_list: gadget ep_list hold all of its eps
-	 * so only the first should init--it is ep0' */
-
 	/* gagdet.ep_list used for ep_autoconfig so no ep0 */
-	if (pipe_num != 0)
+	if (link)
 		list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
-
 	ep->gadget = &udc->gadget;
+	ep->qh = &udc->ep_qh[index];
 
 	return 0;
 }
 
-static int board_init(struct platform_device *pdev)
-{
-	struct fsl_usb2_platform_data *pdata;
-	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
-
-	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev, pdata);
-
-	/*
-	 * do platform specific init: check the clock, grab/config pins, etc.
-	 */
-	if (pdata->platform_init && pdata->platform_init(pdev) != 0)
-		return -EINVAL;
-
-	return 0;
-}
-
-/* Driver probe functions */
-
- /*!
-  * all intialize operations implemented here except Enable usb_intr reg
-  * @param dev device controller pointer
-  * @return Returns zero on success , or a negative error code
-  */
-static int __devinit arcotg_udc_probe(struct platform_device *pdev)
+/* Driver probe function
+ * all intialization operations implemented here except enabling usb_intr reg
+ * board setup should have been done in the platform code
+ */
+static int __init fsl_udc_probe(struct platform_device *pdev)
 {
+	struct resource *res;
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
-	struct arcotg_udc *udc;
-
-	unsigned int tmp_status = -ENODEV;
+	int ret = -ENODEV;
 	unsigned int i;
-	u32 id;
-	u64 rsrc_start, rsrc_len;
+	u32 dccparams;
 
-	if (strcmp(pdev->name, "arc_udc")) {
-		pr_debug("udc: Wrong device\n");
+	if (strcmp(pdev->name, driver_name)) {
+		VDBG("Wrong device\n");
 		return -ENODEV;
 	}
 
-	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev, pdata);
-
-	if (board_init(pdev) != 0)
-		return -EINVAL;
-
-	/* Initialize the udc structure including QH member and other member */
-	udc = (struct arcotg_udc *)struct_udc_setup(pdev);
-	udc_controller = udc;
-
-	if (!udc) {
-		pr_debug("udc: udc is NULL\n");
+	udc_controller = kzalloc(sizeof(struct fsl_udc), GFP_KERNEL);
+	if (udc_controller == NULL) {
+		ERR("malloc udc failed\n");
 		return -ENOMEM;
 	}
-
-	dev_set_drvdata(&pdev->dev, udc);
-
-	udc->pdata = pdata;
-	udc->xcvr_type = pdata->xcvr_type;
+	udc_controller->pdata = pdata;
 
 #ifdef CONFIG_USB_OTG
-	udc->transceiver = otg_get_transceiver();
-	pr_debug("udc: otg_get_transceiver returns 0x%p", udc->transceiver);
-#endif
-
-	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
+	/* Memory and interrupt resources will be passed from OTG */
+	udc_controller->transceiver = otg_get_transceiver();
+	if (!udc_controller->transceiver) {
+		printk(KERN_ERR "Can't find OTG driver!\n");
 		return -ENODEV;
 	}
 
-	rsrc_start = pdev->resource[0].start;
-	rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
-
-	pr_debug("start=0x%x   end=0x%x\n",
-		 pdev->resource[0].start, pdev->resource[0].end);
-	pr_debug("rsrc_start=0x%llx  rsrc_len=0x%llx\n", rsrc_start, rsrc_len);
+	res = otg_get_resources();
+	if (!res) {
+		DBG("resource not registered!\n");
+		return -ENODEV;
+	}
+#else
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		kfree(udc_controller);
+		return -ENXIO;
+	}
 
-#if 0				/* DDD */
-	pr_debug("doing request_mem_region(start=0x%llx, len=0x%llx)\n",
-		 rsrc_start, rsrc_len);
-	if (!request_mem_region(rsrc_start, rsrc_len, driver_name)) {
-		printk(KERN_ERR "request_mem_region failed\n");
+	if (!request_mem_region(res->start, res->end - res->start + 1,
+				driver_name)) {
+		ERR("request mem region for %s failed \n", pdev->name);
+		kfree(udc_controller);
 		return -EBUSY;
 	}
 #endif
-	usb_slave_regs = (struct usb_dr_device *)(int)IO_ADDRESS(rsrc_start);
-
-	pr_debug("udc: usb_slave_regs = 0x%p\n", usb_slave_regs);
-	pr_debug("udc: hci_version=0x%x\n", usb_slave_regs->hciversion);
-	pr_debug("udc: otgsc at 0x%p\n", &usb_slave_regs->otgsc);
-
-	id = usb_slave_regs->id;
-	printk(KERN_INFO "ARC USBOTG h/w ID=0x%x  revision=0x%x\n",
-	       id & 0x3f, id >> 16);
-
-	/* request irq and disable DR  */
-	tmp_status = request_irq(pdev->resource[1].start, arcotg_udc_irq,
-				 IRQF_SHARED, driver_name, udc);
-	if (tmp_status != 0) {
-		printk(KERN_ERR "cannot request irq %d err %d \n",
-		       (int)pdev->resource[1].start, tmp_status);
-		/* DDD free mem_region here */
-		return tmp_status;
-	}
-
-	if (!udc->transceiver) {
-		/* initialize usb hw reg except for regs for EP,
-		 * leave usbintr reg untouched*/
-		dr_controller_setup(udc);
+	dr_regs = ioremap(res->start, res->end - res->start + 1);
+	if (!dr_regs) {
+		ret = -ENOMEM;
+		goto err1;
 	}
-
-	/* here comes the stand operations for probe
-	 * set the arcotg_udc->gadget.xxx
+	pdata->regs = (void *)dr_regs;
+	/*
+	 * do platform specific init: check the clock, grab/config pins, etc.
 	 */
-	udc->gadget.ops = &arcotg_gadget_ops;
-	udc->gadget.is_dualspeed = 1;
+	if (pdata->platform_init && pdata->platform_init(pdev))
+		return -ENODEV;
 
-	/* gadget.ep0 is a pointer */
-	udc->gadget.ep0 = &udc->eps[0].ep;
+	if (pdata->have_sysif_regs)
+		usb_sys_regs = (struct usb_sys_interface *)
+				((u32)dr_regs + USB_DR_SYS_OFFSET);
 
-	INIT_LIST_HEAD(&udc->gadget.ep_list);
+	/* Read Device Controller Capability Parameters register */
+	dccparams = fsl_readl(&dr_regs->dccparams);
+	if (!(dccparams & DCCPARAMS_DC)) {
+		ERR("This SOC doesn't support device role\n");
+		ret = -ENODEV;
+		goto err2;
+	}
+	/* Get max device endpoints */
+	/* DEN is bidirectional ep number, max_ep doubles the number */
+	udc_controller->max_ep = (dccparams & DCCPARAMS_DEN_MASK) * 2;
 
-	udc->gadget.speed = USB_SPEED_UNKNOWN;
+#ifdef CONFIG_USB_OTG
+	res++;
+	udc_controller->irq = res->start;
+#else
+	udc_controller->irq = platform_get_irq(pdev, 0);
+#endif
+	if (!udc_controller->irq) {
+		ret = -ENODEV;
+		goto err2;
+	}
 
-	/* name: Identifies the controller hardware type. */
-	udc->gadget.name = driver_name;
+	ret = request_irq(udc_controller->irq, fsl_udc_irq, IRQF_SHARED,
+			driver_name, udc_controller);
+	if (ret != 0) {
+		ERR("cannot request irq %d err %d \n",
+				udc_controller->irq, ret);
+		goto err2;
+	}
 
-	device_initialize(&udc->gadget.dev);
+	/* Initialize the udc structure including QH member and other member */
+	if (struct_udc_setup(udc_controller, pdev)) {
+		ERR("Can't initialize udc data structure\n");
+		ret = -ENOMEM;
+		goto err3;
+	}
 
-	strcpy(udc->gadget.dev.bus_id, "gadget");
+	if (!udc_controller->transceiver) {
+		/* initialize usb hw reg except for regs for EP,
+		 * leave usbintr reg untouched */
+		dr_controller_setup(udc_controller);
+	}
+
+	/* Setup gadget structure */
+	udc_controller->gadget.ops = &fsl_gadget_ops;
+	udc_controller->gadget.is_dualspeed = 1;
+	udc_controller->gadget.ep0 = &udc_controller->eps[0].ep;
+	INIT_LIST_HEAD(&udc_controller->gadget.ep_list);
+	udc_controller->gadget.speed = USB_SPEED_UNKNOWN;
+	udc_controller->gadget.name = driver_name;
+
+	/* Setup gadget.dev and register with kernel */
+	strcpy(udc_controller->gadget.dev.bus_id, "gadget");
+	udc_controller->gadget.dev.release = fsl_udc_release;
+	udc_controller->gadget.dev.parent = &pdev->dev;
+	ret = device_register(&udc_controller->gadget.dev);
+	if (ret < 0)
+		goto err3;
+
+	if (udc_controller->transceiver)
+		udc_controller->gadget.is_otg = 1;
+
+	/* setup QH and epctrl for ep0 */
+	ep0_setup(udc_controller);
+
+	/* setup udc->eps[] for ep0 */
+	struct_ep_setup(udc_controller, 0, "ep0", 0);
+	/* for ep0: the desc defined here;
+	 * for other eps, gadget layer called ep_enable with defined desc
+	 */
+	udc_controller->eps[0].desc = &fsl_ep0_desc;
+	udc_controller->eps[0].ep.maxpacket = USB_MAX_CTRL_PAYLOAD;
 
-	udc->gadget.dev.release = arcotg_gadget_release;
-	udc->gadget.dev.parent = &pdev->dev;
+	/* setup the udc->eps[] for non-control endpoints and link
+	 * to gadget.ep_list */
+	for (i = 1; i < (int)(udc_controller->max_ep / 2); i++) {
+		char name[14];
 
-	if (udc->transceiver) {
-		udc->gadget.is_otg = 1;
+		sprintf(name, "ep%dout", i);
+		struct_ep_setup(udc_controller, i * 2, name, 1);
+		sprintf(name, "ep%din", i);
+		struct_ep_setup(udc_controller, i * 2 + 1, name, 1);
 	}
 
-	/* for an EP, the intialization includes: fields in QH, Regs,
-	 * arcotg_ep struct */
-	ep0_dr_and_qh_setup(udc);
-	for (i = 0; i < USB_MAX_PIPES; i++) {
-		/* because the ep type is not decide here so
-		 * struct_ep_qh_setup() and dr_ep_setup()
-		 * should be called in ep_enable()
-		 */
-		if (ep_name[i] != NULL)
-			/* setup the arcotg_ep struct and link ep.ep.list
-			 * into gadget.ep_list */
-			struct_ep_setup(udc, i);
+	/* use dma_pool for TD management */
+	udc_controller->td_pool = dma_pool_create("udc_td", &pdev->dev,
+			sizeof(struct ep_td_struct),
+			DTD_ALIGNMENT, UDC_DMA_BOUNDARY);
+	if (udc_controller->td_pool == NULL) {
+		ret = -ENOMEM;
+		goto err4;
 	}
-
 	create_proc_file();
-	tmp_status = device_add(&udc->gadget.dev);
-	pr_debug("udc: back from device_add ");
+	return 0;
 
-	return tmp_status;
+err4:
+	device_unregister(&udc_controller->gadget.dev);
+err3:
+	free_irq(udc_controller->irq, udc_controller);
+err2:
+	iounmap(dr_regs);
+err1:
+	release_mem_region(res->start, res->end - res->start + 1);
+	kfree(udc_controller);
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdata);
+	return ret;
 }
 
-/*!
- * Driver removal functions
- * Free resources
- * Finish pending transaction
- * @param dev device controller pointer
- * @return Returns zero on success , or a negative error code
+/* Driver removal function
+ * Free resources and finish pending transactions
  */
-static int __devexit arcotg_udc_remove(struct platform_device *pdev)
+static int __exit fsl_udc_remove(struct platform_device *pdev)
 {
-	struct arcotg_udc *udc =
-	    (struct arcotg_udc *)platform_get_drvdata(pdev);
+	struct resource *res;
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 
 	DECLARE_COMPLETION(done);
 
-	if (!udc)
+	if (!udc_controller)
 		return -ENODEV;
-
-	udc->done = &done;
-
-	if (udc->transceiver) {
-		put_device(udc->transceiver->dev);
-		udc->transceiver = 0;
-	}
+	udc_controller->done = &done;
 
 	/* DR has been stopped in usb_gadget_unregister_driver() */
-
-	/* remove proc */
 	remove_proc_file();
 
-	/* free irq */
-	free_irq(pdev->resource[1].start, udc);
-
-	/* deinitialize all ep: strcut */
-	/* deinitialize ep0: reg and QH */
-
 	/* Free allocated memory */
-	pr_debug("status_req->head = 0x%p\n", udc->status_req->head);
-	if (udc->status_req->head) {
-		pr_debug("freeing head=0x%p\n", udc->status_req->head);
-		dma_pool_free(udc->dtd_pool,
-			      udc->status_req->head,
-			      udc->status_req->head->td_dma);
-	}
+	kfree(udc_controller->status_req->req.buf);
+	kfree(udc_controller->status_req);
+	kfree(udc_controller->eps);
 
-	kfree(udc->status_req->req.buf);
-	kfree(udc->status_req);
+	dma_pool_destroy(udc_controller->td_pool);
+	free_irq(udc_controller->irq, udc_controller);
+	iounmap(dr_regs);
 
-	if (udc->dtd_pool)
-		dma_pool_destroy(udc->dtd_pool);
+#ifndef CONFIG_USB_OTG
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+#endif
 
-	device_unregister(&udc->gadget.dev);
+	device_unregister(&udc_controller->gadget.dev);
 	/* free udc --wait for the release() finished */
 	wait_for_completion(&done);
 
-#if 0				/* DDD */
-	release_mem_region(pdev->resource[0].start,
-			   pdev->resource[0].end - pdev->resource[0].start + 1);
-#endif
-
 	/*
 	 * do platform specific un-initialization:
 	 * release iomux pins, etc.
@@ -3040,74 +2622,58 @@ static int __devexit arcotg_udc_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static int udc_suspend(struct arcotg_udc *udc)
+static int udc_suspend(struct fsl_udc *udc)
 {
 	udc->stopped = 1;
 	return 0;
 }
 
-/*!
+/*-----------------------------------------------------------------
  * Modify Power management attributes
- * Here we stop the DR controller and disable the irq
- * @param dev device controller pointer
- * @param state current state
- * @return The function returns 0 on success or -1 if failed
- */
-static int arcotg_udc_suspend(struct device *dev, pm_message_t state)
+ * Used by OTG statemachine to disable gadget temporarily
+ -----------------------------------------------------------------*/
+static int fsl_udc_suspend(struct device *dev, pm_message_t state)
 {
-	struct arcotg_udc *udc = (struct arcotg_udc *)dev_get_drvdata(dev);
-	pr_debug("udc: Suspend. state=%d\n", state.event);
-	return udc_suspend(udc);
+	return udc_suspend(udc_controller);
 }
 
-static int udc_resume(struct arcotg_udc *udc)
+/*-----------------------------------------------------------------
+ * Invoked on USB resume. May be called in_interrupt.
+ * Here we start the DR controller and enable the irq
+ *-----------------------------------------------------------------*/
+static int fsl_udc_resume(struct device *dev)
 {
-	/*Enable DR irq reg and set controller Run */
-	if (udc->stopped) {
-		dr_controller_setup(udc);
-		dr_controller_run(udc);
+	/* Enable DR irq reg and set controller Run */
+	if (udc_controller->stopped) {
+		dr_controller_setup(udc_controller);
+		dr_controller_run(udc_controller);
 	}
-	udc->usb_state = USB_STATE_ATTACHED;
-	udc->ep0_state = WAIT_FOR_SETUP;
-	udc->ep0_dir = 0;
+	udc_controller->usb_state = USB_STATE_ATTACHED;
+	udc_controller->ep0_state = WAIT_FOR_SETUP;
+	udc_controller->ep0_dir = 0;
 	return 0;
 }
 
-/*!
- * Invoked on USB resume. May be called in_interrupt.
- * Here we start the DR controller and enable the irq
- * @param dev device controller pointer
- * @return The function returns 0 on success or -1 if failed
- */
-static int arcotg_udc_resume(struct device *dev)
-{
-	struct arcotg_udc *udc = (struct arcotg_udc *)dev_get_drvdata(dev);
-	pr_debug("udc: Resume dev=0x%p udc=0x%p\n", dev, udc);
-
-	return udc_resume(udc);
-}
+/*-------------------------------------------------------------------------
+	Register entry point for the peripheral controller driver
+--------------------------------------------------------------------------*/
 
-/*!
- * Register entry point for the peripheral controller driver
- */
 static struct platform_driver udc_driver = {
-	.probe = arcotg_udc_probe,
-	.remove = __exit_p(arcotg_udc_remove),
-	.driver = {
-		   .name = driver_name,
-		   },
+	.remove  = __exit_p(fsl_udc_remove),
+	/* these suspend and resume are not usb suspend and resume */
+	.suspend = fsl_udc_suspend,
+	.resume  = fsl_udc_resume,
+	.probe = fsl_udc_probe,
+	.driver  = {
+		.name = driver_name,
+		.owner = THIS_MODULE,
+	},
 };
 
 static int __init udc_init(void)
 {
-	int rc;
-
-	INIT_DELAYED_WORK(&usbhset_work, usbhset_workqueue_handler);
-
-	printk(KERN_INFO "%s version %s init \n", driver_desc, DRIVER_VERSION);
-	rc = platform_driver_register(&udc_driver);
-	pr_debug("udc: %s() driver_register returns %d\n", __FUNCTION__, rc);
-	return rc;
+	printk(KERN_INFO "%s (%s)\n", driver_desc, DRIVER_VERSION);
+	return platform_driver_register(&udc_driver);
 }
 
 module_init(udc_init);
@@ -3115,6 +2681,7 @@ module_init(udc_init);
 static void __exit udc_exit(void)
 {
 	platform_driver_unregister(&udc_driver);
+	printk(KERN_INFO "%s unregistered \n", driver_desc);
 }
 
 module_exit(udc_exit);
diff --git a/drivers/usb/gadget/arcotg_udc.h b/drivers/usb/gadget/arcotg_udc.h
index 3479816..641171c 100644
--- a/drivers/usb/gadget/arcotg_udc.h
+++ b/drivers/usb/gadget/arcotg_udc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -69,7 +69,18 @@ struct usb_dr_device {
 	u32 endptstatus;	/* Endpoint Status Register */
 	u32 endptcomplete;	/* Endpoint Complete Register */
 	u32 endptctrl[8 * 2];	/* Endpoint Control Registers */
-} __attribute__ ((packed));
+};
+
+ /* non-EHCI USB system interface registers (Big Endian) */
+struct usb_sys_interface {
+	u32 snoop1;
+	u32 snoop2;
+	u32 age_cnt_thresh;	/* Age Count Threshold Register */
+	u32 pri_ctrl;		/* Priority Control Register */
+	u32 si_ctrl;		/* System Interface Control Register */
+	u8 res[236];
+	u32 control;		/* General Purpose Control Register */
+};
 
 /* ep0 transfer state */
 #define WAIT_FOR_SETUP          0
@@ -78,6 +89,10 @@ struct usb_dr_device {
 #define WAIT_FOR_OUT_STATUS     3
 #define DATA_STATE_RECV         4
 
+/* Device Controller Capability Parameter register */
+#define DCCPARAMS_DC				0x00000080
+#define DCCPARAMS_DEN_MASK			0x0000001f
+
 /* Frame Index Register Bit Masks */
 #define	USB_FRINDEX_MASKS			(0x3fff)
 /* USB CMD  Register Bit Masks */
@@ -221,7 +236,9 @@ struct usb_dr_device {
 #define  USB_MODE_CTRL_MODE_IDLE              (0x00000000)
 #define  USB_MODE_CTRL_MODE_DEVICE            (0x00000002)
 #define  USB_MODE_CTRL_MODE_HOST              (0x00000003)
+#define  USB_MODE_CTRL_MODE_MASK              0x00000003
 #define  USB_MODE_CTRL_MODE_RSV               (0x00000001)
+#define  USB_MODE_ES                          0x00000004 /* (big) Endian Sel */
 #define  USB_MODE_SETUP_LOCK_OFF              (0x00000008)
 #define  USB_MODE_STREAM_DISABLE              (0x00000010)
 /* Endpoint Flush Register */
@@ -371,6 +388,7 @@ struct ep_queue_head {
 #define  EP_QUEUE_HEAD_STATUS_HALT	      (0x00000040)
 #define  EP_QUEUE_HEAD_STATUS_ACTIVE          (0x00000080)
 #define  EP_QUEUE_CURRENT_OFFSET_MASK         (0x00000FFF)
+#define  EP_QUEUE_HEAD_NEXT_POINTER_MASK      0xFFFFFFE0
 #define  EP_QUEUE_FRINDEX_MASK                (0x000007FF)
 #define  EP_MAX_LENGTH_TRANSFER               (0x4000)
 
@@ -441,11 +459,18 @@ struct ep_td_struct {
 #define  DTD_STATUS_DATA_BUFF_ERR             (0x00000020)
 #define  DTD_STATUS_TRANSACTION_ERR           (0x00000008)
 #define  DTD_RESERVED_FIELDS                  (0x80007300)
+#define  DTD_ADDR_MASK                        0xFFFFFFE0
 #define  DTD_PACKET_SIZE                      (0x7FFF0000)
 #define  DTD_LENGTH_BIT_POS                   (16)
 #define  DTD_ERROR_MASK                       (DTD_STATUS_HALTED | \
                                                DTD_STATUS_DATA_BUFF_ERR | \
                                                DTD_STATUS_TRANSACTION_ERR)
+/* Alignment requirements; must be a power of two */
+#define DTD_ALIGNMENT				0x20
+#define QH_ALIGNMENT				2048
+
+/* Controller dma boundary */
+#define UDC_DMA_BOUNDARY			0x1000
 
 /* -----------------------------------------------------------------------*/
 /* ##### enum data
@@ -459,12 +484,12 @@ typedef enum {
 
 /*-------------------------------------------------------------------------*/
 
-struct arcotg_req {
+struct fsl_req {
 	struct usb_request req;
 	struct list_head queue;
 	/* ep_queue() func will add
 	   a request->queue into a udc_ep->queue 'd tail */
-	struct arcotg_ep *ep;
+	struct fsl_ep *ep;
 	unsigned mapped;
 
 	struct ep_td_struct *head, *tail;	/* For dTD List
@@ -474,55 +499,45 @@ struct arcotg_req {
 
 #define REQ_UNCOMPLETE		(1)
 
-struct arcotg_ep {
+struct fsl_ep {
 	struct usb_ep ep;
 	struct list_head queue;
-	struct arcotg_udc *udc;
+	struct fsl_udc *udc;
+	struct ep_queue_head *qh;
 	const struct usb_endpoint_descriptor *desc;
 	struct usb_gadget *gadget;
 
-	u8 already_seen;
-	u8 setup_stage;
-	u32 last_io;		/* timestamp */
-
 	char name[14];
-#if 0
-	u16 maxpacket;
-	u8 bEndpointAddress;
-	u8 bmAttributes;
-#endif
-	unsigned double_buf:1;
 	unsigned stopped:1;
-	unsigned fnf:1;
-	unsigned has_dma:1;
-	u8 ackwait;
-	u8 dma_channel;
-	u16 dma_counter;
-	int lch;
-
-	struct timer_list timer;
-
 };
 
 #define EP_DIR_IN	1
 #define EP_DIR_OUT	0
 
-struct arcotg_udc {
+struct fsl_udc {
 	struct usb_gadget gadget;
 	struct usb_gadget_driver *driver;
-	struct arcotg_ep eps[USB_MAX_ENDPOINTS * 2];
+	struct fsl_usb2_platform_data *pdata;
+	struct fsl_ep *eps;
+	unsigned int max_ep;
+	unsigned int irq;
+
 	struct usb_ctrlrequest local_setup_buff;
 	spinlock_t lock;
-	struct fsl_usb2_platform_data *pdata;
 	u32 xcvr_type;
 	struct otg_transceiver *transceiver;
 	unsigned softconnect:1;
 	unsigned vbus_active:1;
 	unsigned stopped:1;
+	unsigned remote_wakeup:1;
 
 	struct ep_queue_head *ep_qh;	/* Endpoints Queue-Head */
-	int ep_qh_size;		/* Endpoints Queue-Head */
-	struct arcotg_req *status_req;	/* ep0 status request */
+	struct fsl_req *status_req;	/* ep0 status request */
+	struct dma_pool *td_pool;	/* dma pool for DTD */
+	enum fsl_usb2_phy_modes phy_mode;
+
+	size_t ep_qh_size;		/* size after alignment adjustment*/
+	dma_addr_t ep_qh_dma;		/* dma address of QH */
 
 	u32 max_pipes;		/* Device max pipes */
 	u32 max_use_endpts;	/* Max endpointes to be used */
@@ -530,18 +545,25 @@ struct arcotg_udc {
 	u32 resume_state;	/* USB state to resume */
 	u32 usb_state;		/* USB current state */
 	u32 usb_next_state;	/* USB next state */
-	u32 ep0_state;		/* Enpoint zero state */
-	u32 ep0_dir;		/* Enpoint zero direction: can be
+	u32 ep0_state;		/* Endpoint zero state */
+	u32 ep0_dir;		/* Endpoint zero direction: can be
 				   USB_DIR_IN or USB_DIR_OUT */
 	u32 usb_sof_count;	/* SOF count */
 	u32 errors;		/* USB ERRORs count */
-	dma_addr_t ep_qh_dma;	/* DMA address of ep_qh */
-	struct dma_pool *dtd_pool;
 	u8 device_address;	/* Device USB address */
 
 	struct completion *done;	/* to make sure release() is done */
 };
 
+/*-------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+#define DBG(fmt, args...) 	printk(KERN_DEBUG "[%s]  " fmt "\n", \
+				__func__, ## args)
+#else
+#define DBG(fmt, args...)	do {} while (0)
+#endif
+
 #if 0
 static void dump_msg(const char *label, const u8 * buf, unsigned int length)
 {
@@ -570,6 +592,16 @@ static void dump_msg(const char *label, const u8 * buf, unsigned int length)
 }
 #endif
 
+#ifdef VERBOSE
+#define VDBG		DBG
+#else
+#define VDBG(stuff...)	do {} while (0)
+#endif
+
+#define ERR(stuff...)		printk(KERN_ERR "udc: " stuff)
+#define WARN(stuff...)		printk(KERN_WARNING "udc: " stuff)
+#define INFO(stuff...)		printk(KERN_INFO "udc: " stuff)
+
 /*-------------------------------------------------------------------------*/
 
 /* ### Add board specific defines here
@@ -593,8 +625,16 @@ static void dump_msg(const char *label, const u8 * buf, unsigned int length)
 
 #define get_ep_by_pipe(udc, pipe)	((pipe == 1)? &udc->eps[0]: \
 					&udc->eps[pipe])
+#define get_pipe_by_windex(windex)	((windex & USB_ENDPOINT_NUMBER_MASK) \
+					* 2 + ((windex & USB_DIR_IN) ? 1 : 0))
 
 /* Bulk only class request */
 #define USB_BULK_RESET_REQUEST          0xff
 
+#ifdef CONFIG_ARCH_MXC
+#include <asm/arch/fsl_usb_gadget.h>
+#elif CONFIG_PPC32
+#include <asm/fsl_usb_gadget.h>
+#endif
+
 #endif				/* __ARCOTG_UDC_H */
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index 579cd6e..cb363d8 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -89,7 +89,7 @@
 #endif
 
 #ifdef CONFIG_USB_GADGET_ARC
-#define	gadget_is_arcotg(g)	!strcmp("arc_udc", (g)->name)
+#define	gadget_is_arcotg(g)	!strcmp("fsl-usb2-udc", (g)->name)
 #else
 #define	gadget_is_arcotg(g)	0
 #endif
-- 
1.5.4.4

