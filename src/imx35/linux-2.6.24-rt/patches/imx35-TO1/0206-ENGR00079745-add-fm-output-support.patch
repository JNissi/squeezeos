From 1d10455a7169954d89dc53a1e44bb0e3fdbfddaa Mon Sep 17 00:00:00 2001
From: Jingyu Zhou <b02241@freescale.com>
Date: Wed, 11 Jun 2008 13:59:11 +0800
Subject: [PATCH] ENGR00079745 add fm output support

add fm output support

Signed-off-by: Zhou Jingyu <Jingyu.Zhou@freescale.com>
---
 sound/soc/codecs/ak4647.c |  123 +++++++++++++++++++++++++++++++++++++++++----
 1 files changed, 112 insertions(+), 11 deletions(-)

diff --git a/sound/soc/codecs/ak4647.c b/sound/soc/codecs/ak4647.c
index 459a34b..172c03c 100644
--- a/sound/soc/codecs/ak4647.c
+++ b/sound/soc/codecs/ak4647.c
@@ -266,8 +266,6 @@ static int ak4647_add_widgets(struct snd_soc_codec *codec,
 		ret = snd_soc_dapm_connect_input(machine, audio_map[i][0],
 						 audio_map[i][1],
 						 audio_map[i][2]);
-		pr_info("ret = %d; sink: %s; control: %s; source: %s", ret,
-			audio_map[i][0], audio_map[i][1], audio_map[i][2]);
 	}
 
 	snd_soc_dapm_new_widgets(machine);
@@ -450,10 +448,15 @@ static int ak4647_mute(struct snd_soc_dai *dai, int mute)
 	else
 		CLEAR_BIT_IN_BYTE(value, 5);
 	ak4647_write_reg(AK4647_MODE3, value);
-	msleep(100);
 	return 0;
 }
 
+struct ak4647_state_data {
+	u8 left_capture_vol;
+	u8 right_capture_vol;
+};
+static struct ak4647_state_data ak4647_state;
+
 /* dai ops, called by machine drivers */
 static const struct snd_soc_dai_ops ak4647_hifi_dai_ops = {
 	.digital_mute = ak4647_mute,
@@ -465,9 +468,17 @@ static const struct snd_soc_dai_ops ak4647_hifi_dai_ops = {
 static int ak4647_pcm_startup(struct snd_pcm_substream *substream)
 {
 	u8 value;
-	/* when PMADL=PMADR=0 set IVL &IVR to be 0x91 (0db) */
-	ak4647_write_reg(AK4647_LEFT_INPUT_VOLUME, 0x91);
-	ak4647_write_reg(AK4647_RIGHT_INPUT_VOLUME, 0x91);
+	/* for playback, save down capture volume */
+	if (SNDRV_PCM_STREAM_PLAYBACK == substream->stream) {
+		ak4647_read_reg(AK4647_LEFT_INPUT_VOLUME, &value);
+		ak4647_state.left_capture_vol = value;
+		ak4647_read_reg(AK4647_RIGHT_INPUT_VOLUME, &value);
+		ak4647_state.right_capture_vol = value;
+
+		/* when PMADL=PMADR=0 set IVL &IVR to be 0x91 (0db) */
+		ak4647_write_reg(AK4647_LEFT_INPUT_VOLUME, 0x91);
+		ak4647_write_reg(AK4647_RIGHT_INPUT_VOLUME, 0x91);
+	}
 
 	/* output digital volume independent */
 	ak4647_read_reg(AK4647_MODE3, &value);
@@ -483,6 +494,14 @@ static void ak4647_pcm_shutdown(struct snd_pcm_substream *substream)
 	/* mute */
 	CLEAR_BIT_IN_BYTE(value, 6);
 	ak4647_write_reg(AK4647_PM2, value);
+
+	/* after playback, restore capture volume */
+	if (SNDRV_PCM_STREAM_PLAYBACK == substream->stream) {
+		ak4647_write_reg(AK4647_LEFT_INPUT_VOLUME,
+				 ak4647_state.left_capture_vol);
+		ak4647_write_reg(AK4647_RIGHT_INPUT_VOLUME,
+				 ak4647_state.right_capture_vol);
+	}
 }
 
 static int ak4647_pcm_prepare(struct snd_pcm_substream *substream)
@@ -497,17 +516,13 @@ static int ak4647_pcm_prepare(struct snd_pcm_substream *substream)
 	/* PLL enabled */
 	SET_BIT_IN_BYTE(value, 0);
 
+	ak4647_write_reg(AK4647_PM2, value);
 	/* wait for PLL locked */
 	msleep(40);
 
 	/* don't mute */
 	SET_BIT_IN_BYTE(value, 6);
 	ak4647_write_reg(AK4647_PM2, value);
-
-	/* when PMADL=PMADR=0 set IVL &IVR to be 0x91 (0db) */
-	ak4647_write_reg(AK4647_LEFT_INPUT_VOLUME, 0x91);
-	ak4647_write_reg(AK4647_RIGHT_INPUT_VOLUME, 0x91);
-
 	return 0;
 }
 
@@ -538,6 +553,9 @@ static int ak4647_codec_io_probe(struct snd_soc_codec *codec,
 	/* ALC disabled */
 	ak4647_write_reg(AK4647_ALC1, 0x0);
 
+	ak4647_state.left_capture_vol = 0x91;
+	ak4647_state.right_capture_vol = 0x91;
+
 	return 0;
 }
 
@@ -655,6 +673,89 @@ static __exit void ak4647_exit(void)
 	i2c_del_driver(&ak4647_i2c_driver);
 }
 
+int pmic_audio_fm_output_enable(bool enable)
+{
+	u8 val;
+	if (enable) {
+		ak4647_set_dai_fmt(NULL,
+				   SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+				   SND_SOC_DAIFMT_CBM_CFM |
+				   SND_SOC_DAIFMT_SYNC);
+		ak4647_set_dai_sysclk(NULL, 0, 44100, 0);
+		ak4647_set_clkdiv(NULL, 0, 0);
+		/* VCOM power on */
+		ak4647_write_reg(AK4647_PM1, 0x44);
+		msleep(30);
+
+		ak4647_read_reg(AK4647_PM2, &val);
+		/* PLL enabled */
+		SET_BIT_IN_BYTE(val, 0);
+
+		ak4647_write_reg(AK4647_PM2, val);
+		/* wait for PLL locked */
+		msleep(40);
+
+		/* don't mute */
+		SET_BIT_IN_BYTE(val, 6);
+		ak4647_write_reg(AK4647_PM2, val);
+
+		/* loopback STDO to DAC */
+		ak4647_read_reg(AK4647_MODE3, &val);
+		SET_BIT_IN_BYTE(val, 6);
+		ak4647_write_reg(AK4647_MODE3, val);
+
+		/* switch to R/L 1 */
+		ak4647_read_reg(AK4647_PM3, &val);
+		CLEAR_BIT_IN_BYTE(val, 1);
+		CLEAR_BIT_IN_BYTE(val, 2);
+		ak4647_write_reg(AK4647_PM3, val);
+
+		/* power up ADC */
+		ak4647_read_reg(AK4647_PM1, &val);
+		SET_BIT_IN_BYTE(val, 0);
+		ak4647_write_reg(AK4647_PM1, val);
+		ak4647_read_reg(AK4647_PM3, &val);
+		SET_BIT_IN_BYTE(val, 0);
+		ak4647_write_reg(AK4647_PM3, val);
+
+		/* power up DAC */
+		ak4647_read_reg(AK4647_PM1, &val);
+		SET_BIT_IN_BYTE(val, 2);
+		ak4647_write_reg(AK4647_PM1, val);
+
+		msleep(30);
+
+		/* headphone output switch on */
+		ak4647_read_reg(AK4647_MODE4, &val);
+		SET_BIT_IN_BYTE(val, 0);
+		ak4647_write_reg(AK4647_MODE4, val);
+
+		/* power on headphone amp */
+		ak4647_read_reg(AK4647_PM2, &val);
+		SET_BIT_IN_BYTE(val, 4);
+		SET_BIT_IN_BYTE(val, 5);
+		ak4647_write_reg(AK4647_PM2, val);
+
+		ak4647_mute(NULL, 0);
+	} else {
+		ak4647_mute(NULL, 1);
+
+		/* disbale loopback */
+		ak4647_read_reg(AK4647_MODE3, &val);
+		CLEAR_BIT_IN_BYTE(val, 6);
+		SET_BIT_IN_BYTE(val, 5);
+		ak4647_write_reg(AK4647_MODE3, val);
+
+		/* switch to R/L 2 */
+		ak4647_read_reg(AK4647_PM3, &val);
+		SET_BIT_IN_BYTE(val, 1);
+		SET_BIT_IN_BYTE(val, 2);
+		ak4647_write_reg(AK4647_PM3, val);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(pmic_audio_fm_output_enable);
+
 subsys_initcall(ak4647_init);
 module_exit(ak4647_exit);
 
-- 
1.5.4.4

