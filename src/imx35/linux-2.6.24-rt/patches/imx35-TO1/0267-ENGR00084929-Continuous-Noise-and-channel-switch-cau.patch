From 043fe56962cf3c55128aaf50048598e7e6db971c Mon Sep 17 00:00:00 2001
From: Wallace Wang <r59996@freescale.com>
Date: Wed, 23 Jul 2008 14:37:40 +0800
Subject: [PATCH] ENGR00084929 Continuous Noise and channel switch caused by System underrun

1. After system underrun, there is continuous noise
2. After system underrun, the channel maybe switch in 5.1 channel
3. The DMA buffer is too small for 6 audio

Signed-off-by: Wallace Wang <r59996@freescale.com>
---
 sound/soc/imx/imx-esai.c |   38 ++++++++++++--------
 sound/soc/imx/imx-pcm.c  |   85 ++++++++++++++++++++-------------------------
 2 files changed, 61 insertions(+), 62 deletions(-)

diff --git a/sound/soc/imx/imx-esai.c b/sound/soc/imx/imx-esai.c
index 7111445..762a94f 100644
--- a/sound/soc/imx/imx-esai.c
+++ b/sound/soc/imx/imx-esai.c
@@ -653,7 +653,6 @@ static int imx_esai_hw_tx_params(struct snd_pcm_substream
 	channels = params_channels(params);
 	tfcr &= ESAI_TFCR_TE_MASK;
 	tfcr |= ESAI_TFCR_TE(channels);
-	tfcr |= ESAI_TFCR_TFEN;
 
 	tfcr |= ESAI_TFCR_TFWM(64);
 
@@ -734,43 +733,52 @@ static int imx_esai_hw_params(struct snd_pcm_substream
 
 static int imx_esai_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	u32 reg;
+	u32 reg, tfcr;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		tfcr = __raw_readl(ESAI_TFCR);
 		reg = __raw_readl(ESAI_TCR);
-		reg &= ~ESAI_TCR_TPR;
-		__raw_writel(reg, ESAI_TCR);
 	} else {
 		reg = __raw_readl(ESAI_RCR);
-		reg &= ~ESAI_RCR_RPR;
-		__raw_writel(reg, ESAI_RCR);
 	}
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			tfcr |= ESAI_TFCR_TFEN;
+			__raw_writel(tfcr, ESAI_TFCR);
+			reg &= ~ESAI_TCR_TPR;
 			reg |= ESAI_TCR_TE(substream->runtime->channels);
-		else
+			__raw_writel(reg, ESAI_TCR);
+		} else {
+			reg &= ~ESAI_RCR_RPR;
 			reg |= ESAI_RCR_RE(substream->runtime->channels);
+			__raw_writel(reg, ESAI_RCR);
+		}
 		break;
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 			reg &= ~ESAI_TCR_TE(substream->runtime->channels);
-		else
+			__raw_writel(reg, ESAI_TCR);
+			reg |= ESAI_TCR_TPR;
+			__raw_writel(reg, ESAI_TCR);
+			tfcr |= ESAI_TFCR_TFR;
+			tfcr &= ~ESAI_TFCR_TFEN;
+			__raw_writel(tfcr, ESAI_TFCR);
+			tfcr &= ~ESAI_TFCR_TFR;
+			__raw_writel(tfcr, ESAI_TFCR);
+		} else {
 			reg &= ~ESAI_RCR_RE(substream->runtime->channels);
+			__raw_writel(reg, ESAI_RCR);
+		}
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		__raw_writel(reg, ESAI_TCR);
-	else
-		__raw_writel(reg, ESAI_RCR);
-
 	ESAI_DUMP();
 	return 0;
 }
diff --git a/sound/soc/imx/imx-pcm.c b/sound/soc/imx/imx-pcm.c
index 7c3f89d..ee32247 100644
--- a/sound/soc/imx/imx-pcm.c
+++ b/sound/soc/imx/imx-pcm.c
@@ -60,8 +60,8 @@ static const struct snd_pcm_hardware imx_pcm_hardware = {
 	.buffer_bytes_max = SND_RAM_SIZE,
 	.period_bytes_max = SND_RAM_SIZE / 4,
 #else
-	.buffer_bytes_max = 32 * 1024,
-	.period_bytes_max = 8 * 1024,
+	.buffer_bytes_max = 64 * 1024,
+	.period_bytes_max = 16 * 1024,
 #endif
 	.period_bytes_min = 64,
 	.periods_min = 2,
@@ -314,6 +314,37 @@ static int imx_pcm_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct mxc_runtime_data *prtd = runtime->private_data;
+	int ret = 0, channel = 0;
+
+	if (prtd->dma_alloc) {
+		mxc_dma_free(prtd->dma_wchannel);
+		prtd->dma_alloc = 0;
+	}
+
+	/* only allocate the DMA chn once */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+
+		channel = mxc_dma_request(prtd->dma_ch, "ALSA TX SDMA");
+		if (channel < 0) {
+			pr_err("imx-pcm: error requesting
+					a write dma channel\n");
+			return channel;
+		}
+		ret = mxc_dma_callback_set(channel, (mxc_dma_callback_t)
+					   audio_dma_irq, (void *)substream);
+
+	} else {
+		channel = mxc_dma_request(prtd->dma_ch, "ALSA RX SDMA");
+		if (channel < 0) {
+			pr_err("imx-pcm: error requesting
+				a read dma channel\n");
+			return channel;
+		}
+		ret = mxc_dma_callback_set(channel, (mxc_dma_callback_t)
+					   audio_dma_irq, (void *)substream);
+	}
+	prtd->dma_wchannel = channel;
+	prtd->dma_alloc = 1;
 
 	prtd->period = 0;
 	prtd->periods = 0;
@@ -326,59 +357,19 @@ static int imx_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct mxc_runtime_data *prtd = runtime->private_data;
 	struct snd_soc_pcm_link *pcm_link = substream->private_data;
-	int ret = 0, channel = 0;
-	int transfer = 0;
 
-	transfer = imx_get_sdma_transfer(params_format(params),
-					 pcm_link->cpu_dai->id,
-					 substream->stream);
+	prtd->dma_ch = imx_get_sdma_transfer(params_format(params),
+					     pcm_link->cpu_dai->id,
+					     substream->stream);
 
-	if (transfer < 0) {
+	if (prtd->dma_ch < 0) {
 		printk(KERN_ERR "imx-pcm: invaild sdma transfer type");
 		return -1;
 	}
 
-	/* only allocate the DMA chn once */
-	if (!prtd->dma_alloc) {
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-
-			channel = mxc_dma_request(transfer, "ALSA TX SDMA");
-			if (channel < 0) {
-				printk(KERN_ERR
-				       "imx-pcm: error requesting a write dma channel\n");
-				return channel;
-			}
-			ret = mxc_dma_callback_set(channel, (mxc_dma_callback_t)
-						   audio_dma_irq,
-						   (void *)substream);
-
-		} else {
-			channel = mxc_dma_request(transfer, "ALSA RX SDMA");
-			if (channel < 0) {
-				printk(KERN_ERR
-				       "imx-pcm: error requesting a read dma channel\n");
-				return channel;
-			}
-			ret = mxc_dma_callback_set(channel, (mxc_dma_callback_t)
-						   audio_dma_irq,
-						   (void *)substream);
-		}
-		prtd->dma_wchannel = channel;
-		prtd->dma_alloc = 1;
-
-		/* set up chn with params */
-		//      dma->params.callback = audio_dma_irq;
-
-	}
-
 	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
 
-	dbg("-imx_pcm_hw_params:"
-	    "UseIram=%d buf->addr=%x buf->area=%p buf->bytes=%d\n",
-	    UseIram, (unsigned int)runtime->dma_addr,
-	    runtime->dma_area, runtime->dma_bytes);
-
-	return ret;
+	return 0;
 }
 
 static int imx_pcm_hw_free(struct snd_pcm_substream *substream)
-- 
1.5.4.4

