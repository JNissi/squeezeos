From 7c4cc9485215bbfdd7ad24e9b12ef64fc420b0cc Mon Sep 17 00:00:00 2001
From: Fred Fan <r01011@freescale.com>
Date: Wed, 26 Mar 2008 10:32:51 +0800
Subject: [PATCH] ENGR00058715 Add i.MX35 machine specific layer

Add supporting i.MX35 EVB and 3STACK board. The common modules such as
clock, iomux, platform device, cpu and etc has implemented. And support
machine specific layer code for EVB and 3STACK board. Just on 3STACK board,
the virtual interrupts which is generated by CPLD has implemented.

Signed-off-by:Fred Fan <r01011@freescale.com>
---
 arch/arm/Makefile                       |    1 +
 arch/arm/configs/imx35_3stack_defconfig | 1025 +++++++++++++++++++++
 arch/arm/configs/imx35evb_defconfig     |  967 ++++++++++++++++++++
 arch/arm/mach-mx35/Kconfig              |   57 ++
 arch/arm/mach-mx35/Makefile             |   10 +
 arch/arm/mach-mx35/Makefile.boot        |    9 +
 arch/arm/mach-mx35/board-mx35_3stack.h  |  172 ++++
 arch/arm/mach-mx35/board-mx35evb.h      |  151 +++
 arch/arm/mach-mx35/clock.c              | 1513 +++++++++++++++++++++++++++++++
 arch/arm/mach-mx35/cpu.c                |   77 ++
 arch/arm/mach-mx35/crm_regs.h           |  419 +++++++++
 arch/arm/mach-mx35/devices.c            |  353 +++++++
 arch/arm/mach-mx35/dma.c                |  163 ++++
 arch/arm/mach-mx35/iomux.c              |  216 +++++
 arch/arm/mach-mx35/iomux.h              |  290 ++++++
 arch/arm/mach-mx35/mm.c                 |   82 ++
 arch/arm/mach-mx35/mx35_3stack.c        |  405 +++++++++
 arch/arm/mach-mx35/mx35_3stack_cpld.c   |  159 ++++
 arch/arm/mach-mx35/mx35_3stack_gpio.c   |  228 +++++
 arch/arm/mach-mx35/mx35evb.c            |  396 ++++++++
 arch/arm/mach-mx35/mx35evb_cpld.c       |   82 ++
 arch/arm/mach-mx35/mx35evb_gpio.c       |  188 ++++
 arch/arm/mach-mx35/sdma_script_code.h   |  212 +++++
 arch/arm/mach-mx35/serial.c             |  180 ++++
 arch/arm/mach-mx35/serial.h             |  132 +++
 arch/arm/mach-mx35/system.c             |   59 ++
 arch/arm/plat-mxc/Kconfig               |   11 +
 arch/arm/plat-mxc/sdma/sdma.c           |   13 +-
 arch/arm/tools/mach-types               |  128 +++-
 drivers/net/Kconfig                     |    2 +-
 drivers/net/fec.c                       |   11 +-
 include/asm-arm/arch-mxc/hardware.h     |   12 +-
 include/asm-arm/arch-mxc/memory.h       |    2 +-
 include/asm-arm/arch-mxc/mx35.h         |  429 +++++++++
 include/asm-arm/arch-mxc/mx35_pins.h    |  347 +++++++
 include/asm-arm/arch-mxc/sdma.h         |   15 +-
 36 files changed, 8487 insertions(+), 29 deletions(-)

diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index b8f1b14..83988bb 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -139,6 +139,7 @@ endif
  machine-$(CONFIG_ARCH_KS8695)     := ks8695
   incdir-$(CONFIG_ARCH_MXC)	   := mxc
  machine-$(CONFIG_ARCH_MX3)	   := mx3
+ machine-$(CONFIG_ARCH_MX35)	   := mx35
  machine-$(CONFIG_ARCH_MX37)	   := mx37
  machine-$(CONFIG_ARCH_MX27)	   := mx27
  machine-$(CONFIG_ARCH_MX21)	   := mx21
diff --git a/arch/arm/configs/imx35_3stack_defconfig b/arch/arm/configs/imx35_3stack_defconfig
new file mode 100644
index 0000000..b700ff8
--- /dev/null
+++ b/arch/arm/configs/imx35_3stack_defconfig
@@ -0,0 +1,1025 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.24
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_FAIR_USER_SCHED=y
+# CONFIG_FAIR_CGROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# Freescale MXC Implementations
+#
+# CONFIG_ARCH_MXC91321 is not set
+# CONFIG_ARCH_MX37 is not set
+CONFIG_ARCH_MX35=y
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_ARCH_MX27 is not set
+# CONFIG_ARCH_MX21 is not set
+CONFIG_I2C_MXC_SELECT1=y
+# CONFIG_I2C_MXC_SELECT2 is not set
+CONFIG_MXC_SDMA_API=y
+# CONFIG_I2C_MXC_SELECT3 is not set
+
+#
+# MX35 Options
+#
+CONFIG_MACH_MX35_3DS=y
+# CONFIG_MACH_MX35EVB is not set
+# CONFIG_MX35_DOZE_DURING_IDLE is not set
+
+#
+# Device options
+#
+CONFIG_ARCH_HAS_EVTMON=y
+CONFIG_DMA_ZONE_SIZE=24
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+# CONFIG_CPU_ARM926T is not set
+CONFIG_CPU_V6=y
+# CONFIG_CPU_32v6K is not set
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_CACHE_L2X0=y
+
+#
+# Bus support
+#
+CONFIG_ISA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_PCCARD=m
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+# CONFIG_PCMCIA_IOCTL is not set
+
+#
+# PC-card bridges
+#
+# CONFIG_I82365 is not set
+# CONFIG_TCIC is not set
+CONFIG_PCMCIA_PROBE=y
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw rootfstype=jffs2 ip=off"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_SUSPEND_UP_POSSIBLE=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+# CONFIG_IEEE80211_CRYPT_WEP is not set
+# CONFIG_IEEE80211_CRYPT_CCMP is not set
+# CONFIG_IEEE80211_CRYPT_TKIP is not set
+# CONFIG_IEEE80211_SOFTMAC is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+# CONFIG_MTD is not set
+
+#
+# Voltage and Current regulators
+#
+CONFIG_REGULATOR_API=y
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_WM8350 is not set
+# CONFIG_PARPORT is not set
+# CONFIG_PNP is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_SMC911X is not set
+CONFIG_SMSC911X=y
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+CONFIG_NET_PCI=y
+# CONFIG_AC3200 is not set
+# CONFIG_APRICOT is not set
+# CONFIG_B44 is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_FEC is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+CONFIG_PCMCIA_PCNET=m
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=m
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MXC_MU is not set
+# CONFIG_MXC_SUPER_GEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXC=y
+CONFIG_SERIAL_MXC_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_NVRAM is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ELEKTOR is not set
+CONFIG_I2C_MXC=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_MXC_WATCHDOG=y
+
+#
+# ISA-based Watchdog Cards
+#
+# CONFIG_PCWATCHDOG is not set
+# CONFIG_MIXCOMWD is not set
+# CONFIG_WDT is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+# CONFIG_HID is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# On-The-Go and USB Peripheral Support
+#
+# CONFIG_OTG is not set
+
+#
+#
+#
+
+#
+#
+#
+# CONFIG_MMC is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_MXC=y
+# CONFIG_RTC_DRV_MXC_V2 is not set
+
+#
+# MXC support drivers
+#
+# CONFIG_MXC_IPU is not set
+
+#
+# MXC SSI support
+#
+# CONFIG_MXC_SSI is not set
+
+#
+# MXC Digital Audio Multiplexer support
+#
+# CONFIG_MXC_DAM is not set
+
+#
+# MXC PMIC support
+#
+# CONFIG_MXC_PMIC is not set
+
+#
+# Advanced Power Management devices
+#
+
+#
+# MXC Security Drivers
+#
+# CONFIG_MXC_SECURITY_SCC is not set
+# CONFIG_MXC_SECURITY_RNG is not set
+# CONFIG_MXC_SECURITY_RTIC is not set
+
+#
+# MXC MPEG4 Encoder Kernel module support
+#
+# CONFIG_MXC_HMP4E is not set
+
+#
+# MXC HARDWARE EVENT
+#
+CONFIG_MXC_HWEVENT=y
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_BIND34 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+# CONFIG_DLM is not set
+CONFIG_INSTRUMENTATION=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_OPROFILE_ARMV6=y
+CONFIG_OPROFILE_ARM11_CORE=y
+CONFIG_OPROFILE_ARM11_EVTMON=y
+# CONFIG_MARKERS is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_SAMPLES is not set
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/imx35evb_defconfig b/arch/arm/configs/imx35evb_defconfig
new file mode 100644
index 0000000..5f27aeb
--- /dev/null
+++ b/arch/arm/configs/imx35evb_defconfig
@@ -0,0 +1,967 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.24
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_FAIR_USER_SCHED=y
+# CONFIG_FAIR_CGROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# Freescale MXC Implementations
+#
+# CONFIG_ARCH_MXC91321 is not set
+# CONFIG_ARCH_MX37 is not set
+CONFIG_ARCH_MX35=y
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_ARCH_MX27 is not set
+# CONFIG_ARCH_MX21 is not set
+CONFIG_MXC_SDMA_API=y
+
+#
+# MX35 Options
+#
+# CONFIG_MACH_MX35_3DS is not set
+CONFIG_MACH_MX35EVB=y
+# CONFIG_MX35_DOZE_DURING_IDLE is not set
+
+#
+# Device options
+#
+CONFIG_ARCH_HAS_EVTMON=y
+CONFIG_DMA_ZONE_SIZE=24
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+# CONFIG_CPU_ARM926T is not set
+CONFIG_CPU_V6=y
+# CONFIG_CPU_32v6K is not set
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_CACHE_L2X0=y
+
+#
+# Bus support
+#
+CONFIG_ISA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_PCCARD=m
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+# CONFIG_PCMCIA_IOCTL is not set
+
+#
+# PC-card bridges
+#
+# CONFIG_I82365 is not set
+# CONFIG_TCIC is not set
+CONFIG_PCMCIA_PROBE=y
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw rootfstype=jffs2 ip=off"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_SUSPEND_UP_POSSIBLE=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+# CONFIG_IEEE80211_CRYPT_WEP is not set
+# CONFIG_IEEE80211_CRYPT_CCMP is not set
+# CONFIG_IEEE80211_CRYPT_TKIP is not set
+# CONFIG_IEEE80211_SOFTMAC is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+# CONFIG_MTD is not set
+
+#
+# Voltage and Current regulators
+#
+# CONFIG_REGULATOR is not set
+# CONFIG_PARPORT is not set
+# CONFIG_PNP is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+CONFIG_NET_PCI=y
+# CONFIG_AC3200 is not set
+# CONFIG_APRICOT is not set
+# CONFIG_B44 is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_FEC is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+CONFIG_PCMCIA_PCNET=m
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=m
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MXC_MU is not set
+# CONFIG_MXC_SUPER_GEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXC=y
+CONFIG_SERIAL_MXC_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_NVRAM is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_MXC_WATCHDOG=y
+
+#
+# ISA-based Watchdog Cards
+#
+# CONFIG_PCWATCHDOG is not set
+# CONFIG_MIXCOMWD is not set
+# CONFIG_WDT is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+# CONFIG_HID is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# On-The-Go and USB Peripheral Support
+#
+# CONFIG_OTG is not set
+
+#
+#
+#
+
+#
+#
+#
+# CONFIG_MMC is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_MXC=y
+# CONFIG_RTC_DRV_MXC_V2 is not set
+
+#
+# MXC support drivers
+#
+# CONFIG_MXC_IPU is not set
+
+#
+# MXC SSI support
+#
+# CONFIG_MXC_SSI is not set
+
+#
+# MXC Digital Audio Multiplexer support
+#
+# CONFIG_MXC_DAM is not set
+
+#
+# MXC PMIC support
+#
+# CONFIG_MXC_PMIC is not set
+
+#
+# Advanced Power Management devices
+#
+
+#
+# MXC Security Drivers
+#
+# CONFIG_MXC_SECURITY_SCC is not set
+# CONFIG_MXC_SECURITY_RNG is not set
+# CONFIG_MXC_SECURITY_RTIC is not set
+
+#
+# MXC MPEG4 Encoder Kernel module support
+#
+# CONFIG_MXC_HMP4E is not set
+
+#
+# MXC HARDWARE EVENT
+#
+CONFIG_MXC_HWEVENT=y
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_BIND34 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+# CONFIG_DLM is not set
+CONFIG_INSTRUMENTATION=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_OPROFILE_ARMV6=y
+CONFIG_OPROFILE_ARM11_CORE=y
+CONFIG_OPROFILE_ARM11_EVTMON=y
+# CONFIG_MARKERS is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_SAMPLES is not set
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/mach-mx35/Kconfig b/arch/arm/mach-mx35/Kconfig
new file mode 100644
index 0000000..c8e574e
--- /dev/null
+++ b/arch/arm/mach-mx35/Kconfig
@@ -0,0 +1,57 @@
+menu "MX35 Options"
+	depends on ARCH_MX35
+
+config MACH_MX35_3DS
+	bool "Support MX35 3STACK platforms"
+	default y
+	help
+	  Include support for MX35 3STACK platform. This includes specific
+	  configurations for the board and its peripherals.
+
+config MACH_MX35EVB
+	bool "Support MX35EVB platforms"
+	default n
+	help
+	  Include support for MX35EVB platform. This includes specific
+	  configurations for the board and its peripherals.
+
+config MX35_DOZE_DURING_IDLE
+	bool "Enter Doze mode during idle"
+	help
+	  Turning on this option will put the CPU into Doze mode during idle.
+	  The default is to enter Wait mode during idle. Doze mode during
+	  idle will save additional power over Wait mode.
+
+config MXC_SDMA_API
+        bool "Use SDMA API"
+        default y
+        help
+           This selects the Freescale MXC SDMA API.
+           If unsure, say N.
+
+menu "Device options"
+
+config I2C_MXC_SELECT1
+	bool "Enable I2C1 module"
+	default y
+	depends on I2C_MXC
+	help
+	  Enable MX35 I2C1 module.
+
+config I2C_MXC_SELECT2
+	bool "Enable I2C2 module"
+	default n
+	depends on I2C_MXC
+	help
+	  Enable MX35 I2C2 module.
+
+config I2C_MXC_SELECT3
+	bool "Enable I2C3 module"
+	default n
+	depends on I2C_MXC
+	help
+	  Enable MX35 I2C3 module.
+
+endmenu
+
+endmenu
diff --git a/arch/arm/mach-mx35/Makefile b/arch/arm/mach-mx35/Makefile
new file mode 100644
index 0000000..060ab4d
--- /dev/null
+++ b/arch/arm/mach-mx35/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		:= system.o iomux.o cpu.o mm.o clock.o devices.o serial.o
+obj-$(CONFIG_MXC_SDMA_API) 	+= dma.o
+obj-$(CONFIG_MACH_MX35_3DS)	+= mx35_3stack.o mx35_3stack_gpio.o mx35_3stack_cpld.o
+obj-$(CONFIG_MACH_MX35EVB)	+= mx35evb.o mx35evb_cpld.o mx35evb_gpio.o
diff --git a/arch/arm/mach-mx35/Makefile.boot b/arch/arm/mach-mx35/Makefile.boot
new file mode 100644
index 0000000..198d92d
--- /dev/null
+++ b/arch/arm/mach-mx35/Makefile.boot
@@ -0,0 +1,9 @@
+ifeq ($(CONFIG_MACH_MX35EVB), y)
+   zreladdr-y	:= 0x90008000
+params_phys-y	:= 0x90000100
+initrd_phys-y	:= 0x90800000
+else
+   zreladdr-y	:= 0x80008000
+params_phys-y	:= 0x80000100
+initrd_phys-y	:= 0x80800000
+endif
diff --git a/arch/arm/mach-mx35/board-mx35_3stack.h b/arch/arm/mach-mx35/board-mx35_3stack.h
new file mode 100644
index 0000000..a402fed
--- /dev/null
+++ b/arch/arm/mach-mx35/board-mx35_3stack.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX35_3STACK_H__
+#define __ASM_ARCH_MXC_BOARD_MX35_3STACK_H__
+
+#ifdef CONFIG_MACH_MX35_3DS
+
+/*!
+ * @defgroup BRDCFG_MX35 Board Configuration Options
+ * @ingroup MSL_MX35
+ */
+
+/*!
+ * @file mach-mx35/board-mx35_3stack.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX35 3STACK Platform.
+ *
+ * @ingroup BRDCFG_MX35
+ */
+
+/*
+ * Include Files
+ */
+#include <asm/arch/mxc_uart.h>
+
+/*!
+ * @name MXC UART EVB board level configurations
+ */
+/*! @{ */
+/*!
+ * Specifies if the Irda transmit path is inverting
+ */
+#define MXC_IRDA_TX_INV         0
+/*!
+ * Specifies if the Irda receive path is inverting
+ */
+#define MXC_IRDA_RX_INV         0
+
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE              MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR                NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED           1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE              MODE_DCE
+#define UART2_IR                NO_IRDA
+#define UART2_ENABLED           1
+
+/* UART 3 configuration */
+#define UART3_MODE              MODE_DTE
+#define UART3_IR                NO_IRDA
+#define UART3_ENABLED           1
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+/*!
+ * @name debug board parameters
+ */
+/*! @{ */
+/*!
+ * Base address of debug board
+ */
+#define DEBUG_BASE_ADDRESS      CS5_BASE_ADDR
+
+/* External ethernet LAN9217 base address */
+#define LAN9217_BASE_ADDR       DEBUG_BASE_ADDRESS
+
+/* External UART */
+#define UARTA_BASE_ADDR     	(DEBUG_BASE_ADDRESS + 0x08000)
+#define UARTB_BASE_ADDR     	(DEBUG_BASE_ADDRESS + 0x10000)
+
+#define BOARD_IO_ADDR		(DEBUG_BASE_ADDRESS + 0x20000)
+
+/* LED switchs */
+#define LED_SWITCH_REG        	0x00
+/* buttons */
+#define SWITCH_BUTTON_REG     	0x08
+/* status, interrupt */
+#define INTR_STATUS_REG       	0x10
+#define INTR_RESET_REG        	0x20
+/*CPLD configuration*/
+#define CONFIG1_REG           	0x28
+#define CONFIG2_REG           	0x30
+/*interrupt mask */
+#define INTR_MASK_REG        	0x38
+
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER1_REG     	0x40
+#define	MAGIC_NUMBER2_REG     	0x48
+/* CPLD code version */
+#define CPLD_CODE_VER_REG       0x50
+/* magic word for debug CPLD */
+#define MAGIC3_NUMBER3_REG     	0x58
+/* module reset register*/
+#define CONTROL_REG      	0x60
+/* CPU ID and Personality ID*/
+#define IDENT_REG         	0x68
+
+/* For interrupts like xuart, enet etc */
+#define EXPIO_PARENT_INT        MX35_PIN_GPIO1_1
+
+#define EXPIO_INT_ENET_INT          (MXC_EXP_IO_BASE + 0)
+#define EXPIO_INT_XUARTA_INT        (MXC_EXP_IO_BASE + 1)
+#define EXPIO_INT_XUARTB_INT        (MXC_EXP_IO_BASE + 2)
+#define EXPIO_INT_BUTTONA_INT       (MXC_EXP_IO_BASE + 3)
+#define EXPIO_INT_BUTTONB_INT       (MXC_EXP_IO_BASE + 4)
+
+/*! This is System IRQ used by LAN9217 for interrupt generation taken
+ * from platform.h
+ */
+#define LAN9217_IRQ              EXPIO_INT_ENET_INT
+
+/*! This is base virtual address of debug board*/
+extern unsigned int mx35_3stack_board_io;
+
+#define MXC_BD_LED1             (1)
+#define MXC_BD_LED2             (1 << 1)
+#define MXC_BD_LED3             (1 << 2)
+#define MXC_BD_LED4             (1 << 3)
+#define MXC_BD_LED5             (1 << 4)
+#define MXC_BD_LED6             (1 << 5)
+#define MXC_BD_LED7             (1 << 6)
+#define MXC_BD_LED8             (1 << 7)
+#define MXC_BD_LED_ON(led)
+#define MXC_BD_LED_OFF(led)
+
+/*! @} */
+
+#define AHB_FREQ                133000000
+#define IPG_FREQ                66500000
+
+extern void mxc_map_io(void);
+extern void mxc_init_irq(void);
+extern void mxc_cpu_init(void) __init;
+extern void mx35_3stack_gpio_init(void) __init;
+extern struct sys_timer mxc_timer;
+extern void mxc_cpu_common_init(void);
+extern int mxc_clocks_init(void);
+extern void __init early_console_setup(char *);
+
+#endif				/* CONFIG_MACH_MX35_3DS */
+#endif				/* __ASM_ARCH_MXC_BOARD_MX35_3STACK_H__ */
diff --git a/arch/arm/mach-mx35/board-mx35evb.h b/arch/arm/mach-mx35/board-mx35evb.h
new file mode 100644
index 0000000..6e69e72
--- /dev/null
+++ b/arch/arm/mach-mx35/board-mx35evb.h
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX35EVB_H__
+#define __ASM_ARCH_MXC_BOARD_MX35EVB_H__
+
+#ifdef CONFIG_MACH_MX35EVB
+/*!
+ * @defgroup BRDCFG_MX35 Board Configuration Options
+ * @ingroup MSL_MX35
+ */
+
+/*!
+ * @file mach-mx35/board-mx35evb.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX35 EVB Platform.
+ *
+ * @ingroup BRDCFG_MX35
+ */
+
+/*
+ * Include Files
+ */
+#include <asm/arch/mxc_uart.h>
+
+/*!
+ * @name MXC UART EVB board level configurations
+ */
+/*! @{ */
+/*!
+ * Specifies if the Irda transmit path is inverting
+ */
+#define MXC_IRDA_TX_INV         0
+/*!
+ * Specifies if the Irda receive path is inverting
+ */
+#define MXC_IRDA_RX_INV         0
+
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE              MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR                NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED           1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE              MODE_DCE
+#define UART2_IR                NO_IRDA
+#define UART2_ENABLED           1
+
+/* UART 3 configuration */
+#define UART3_MODE              MODE_DTE
+#define UART3_IR                NO_IRDA
+#define UART3_ENABLED           1
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+/*!
+ * @name PBC Controller parameters
+ */
+/*!
+ * Base address of PBC controller
+ */
+/*! @{ */
+#define PBC_BASE_ADDRESS 	CS4_BASE_ADDR
+
+#define PBC_VERSION		0x0000
+#define PBC_BCTRL1_SET		0x0008
+#define PBC_BCTRL1_CLR		0x000C
+#define PBC_BCTRL2_SET		0x0010
+#define PBC_BCTRL2_CLR		0x0014
+#define PBC_IMR1_SET		0x0018
+#define PBC_IMR1_CLR		0x001C
+#define PBC_IMR2_SET		0x0020
+#define PBC_IMR2_CLR		0x0024
+#define PBC_BSTAT1		0x0028
+#define PBC_ISR			0x002C
+
+#define ENET_BASE_ADDRESS    	(PBC_BASE_ADDRESS + 0x20000)
+
+/*! Definitions in Board Control Register 1 */
+#define PBC_BCTRL1_ENET_RESET_B	(1)
+#define PBC_BCTRL1_FEC_RESET_B	(1<<2)
+
+/*! @} */
+
+#define EXPIO_PARENT_INT_0	IOMUX_TO_IRQ(MX35_PIN_GPIO1_0)
+#define EXPIO_PARENT_INT_1	IOMUX_TO_IRQ(MX35_PIN_GPIO1_1)
+
+#define EXPIO_PARENT_INT	EXPIO_PARENT_INT_1
+#define EXPIO_PARENT_INT_PIN	MX35_PIN_GPIO1_1
+
+#define EXPIO_INT_FEC		(EXPIO_PARENT_INT + 0)
+#define EXPIO_INT_ENET		(EXPIO_PARENT_INT + 1)
+
+extern unsigned int mx35evb_board_io;
+
+#define MXC_BD_LED1             (1)
+#define MXC_BD_LED2             (1 << 1)
+#define MXC_BD_LED3             (1 << 2)
+#define MXC_BD_LED4             (1 << 3)
+#define MXC_BD_LED_ON(led)	\
+	__raw_writew(led, mx35evb_bard_io + PBC_BCTRL2_SET)
+#define MXC_BD_LED_OFF(led)	\
+	__raw_writew(led, mx35evb_bard_io + PBC_BCTRL2_CLR)
+
+#define AHB_FREQ                133000000
+#define IPG_FREQ                66500000
+/*!
+ * Specifies if the MXC Write Protectect function is suppport or not.
+ */
+#define MXC_MMC_WRITE_PROTECT   1
+
+extern void mxc_map_io(void);
+extern void mxc_init_irq(void);
+extern void mxc_cpu_init(void) __init;
+extern void mx35evb_gpio_init(void) __init;
+extern struct sys_timer mxc_timer;
+extern void mxc_cpu_common_init(void);
+extern int mxc_clocks_init(void);
+extern void __init early_console_setup(char *);
+
+#endif				/* CONFIG_MACH_MX35EVB */
+#endif				/* __ASM_ARCH_MXC_BOARD_MX35EVB_H__ */
diff --git a/arch/arm/mach-mx35/clock.c b/arch/arm/mach-mx35/clock.c
new file mode 100644
index 0000000..1c2c0c7
--- /dev/null
+++ b/arch/arm/mach-mx35/clock.c
@@ -0,0 +1,1513 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/div64.h>
+
+#include "crm_regs.h"
+
+#define PRE_DIV_MIN_FREQ    10000000	/* Minimum Frequency after Predivider */
+#define PROPAGATE_RATE_DIS  2
+
+struct timer_list dptcen_timer;
+static int cpu_curr_wp;
+static struct cpu_wp *cpu_wp_tbl;
+static int cpu_wp_nr;
+static int cpu_wp_offset;
+
+static struct clk mcu_pll_clk;
+static struct clk peri_pll_clk;
+static struct clk ipg_clk;
+static struct clk ckih_clk;
+static struct clk ckie_clk;
+static struct clk ahb_clk;
+static struct clk cpu_clk;
+
+#define CLK_CODE(arm, ahb, sel) (((arm) << 16) + ((ahb) << 8) + (sel))
+#define CLK_CODE_ARM(c)		(((c) >> 16) & 0xFF)
+#define CLK_CODE_AHB(c) 	(((c) >>  8) & 0xFF)
+#define CLK_CODE_PATH(c) 	((c) & 0xFF)
+
+static int __get_arm_div(unsigned long pdr0, int *fi, int *fd);
+
+static int g_clk_mux_auto[8] = {
+	CLK_CODE(1, 3, 0), CLK_CODE(1, 2, 1), CLK_CODE(2, 1, 1), -1,
+	CLK_CODE(1, 6, 0), CLK_CODE(1, 4, 1), CLK_CODE(2, 2, 1), -1,
+};
+
+static int g_clk_mux_consumer[16] = {
+	CLK_CODE(1, 4, 0), CLK_CODE(1, 3, 1), CLK_CODE(1, 3, 1), -1,
+	-1, -1, CLK_CODE(4, 1, 0), CLK_CODE(1, 5, 0),
+	CLK_CODE(1, 8, 1), CLK_CODE(1, 6, 1), CLK_CODE(2, 4, 0), -1,
+	-1, -1, CLK_CODE(4, 2, 0), -1,
+};
+
+static int g_hsp_div_table[3][16] = {
+	{4, 3, 2, -1, -1, -1, 1, 5, 4, 3, 2, -1, -1, -1, 1, -1},
+	{-1, -1, -1, -1, -1, -1, -1, -1, 8, 6, 4, -1, -1, -1, 2, -1},
+	{3, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1},
+};
+
+static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
+{
+	u32 min_pre, temp_pre, old_err, err;
+
+	if (div >= 512) {
+		*pre = 8;
+		*post = 64;
+	} else if (div >= 64) {
+		min_pre = (div - 1) / 64 + 1;
+		old_err = 8;
+		for (temp_pre = 8; temp_pre >= min_pre; temp_pre--) {
+			err = div % temp_pre;
+			if (err == 0) {
+				*pre = temp_pre;
+				break;
+			}
+			err = temp_pre - err;
+			if (err < old_err) {
+				old_err = err;
+				*pre = temp_pre;
+			}
+		}
+		*post = (div + *pre - 1) / *pre;
+	} else if (div <= 8) {
+		*pre = div;
+		*post = 1;
+	} else {
+		*pre = 1;
+		*post = div;
+	}
+}
+
+static int __switch_cpu_wp(unsigned long rate)
+{
+	int i;
+	if (cpu_wp_tbl[cpu_curr_wp].cpu_rate > rate) {
+		for (i = cpu_curr_wp + 2; i < cpu_wp_nr; i += 2) {
+			if (rate == cpu_wp_tbl[i].cpu_rate)
+				goto found;
+		}
+		return -EINVAL;
+	} else {
+		for (i = cpu_curr_wp - 2; i >= 0; i -= 2) {
+			if (rate == cpu_wp_tbl[cpu_curr_wp].cpu_rate)
+				goto found;
+		}
+		return -EINVAL;
+	}
+      found:
+	__raw_writel(cpu_wp_tbl[i].pdr0_reg, MXC_CCM_PDR0);
+
+	if (cpu_wp_tbl[i].pll_rate != cpu_wp_tbl[cpu_curr_wp].pll_rate)
+		clk_set_rate(&mcu_pll_clk, cpu_wp_tbl[i].pll_rate);
+	cpu_curr_wp = i;
+	return 0;
+}
+
+static int __switch_cpu_rate(unsigned long rate)
+{
+	int prev;
+	unsigned long tmp;
+	int arm_div, fi, fd, start, end;
+	if (cpu_wp_tbl[cpu_curr_wp].cpu_rate > rate) {
+		start = cpu_curr_wp + 2;
+		end = cpu_wp_nr;
+		prev = cpu_curr_wp;
+	} else {
+		start = cpu_wp_offset + 2;
+		end = cpu_curr_wp;
+		prev = cpu_wp_offset;
+	}
+	while (start < end) {
+		arm_div = __get_arm_div(cpu_wp_tbl[start].pdr0_reg, &fi, &fd);
+		tmp = (mcu_pll_clk.rate * fi) / (arm_div * fd);
+		if (tmp == rate) {
+			prev = start;
+			break;
+		}
+		if (tmp < rate) {
+			if (prev < start)
+				prev = start;
+		} else {
+			break;
+		}
+		start += 2;
+	}
+	if (start >= end)
+		return -EINVAL;
+
+	if (prev == cpu_curr_wp)
+		return 0;
+
+	__raw_writel(cpu_wp_tbl[prev].pdr0_reg, MXC_CCM_PDR0);
+
+	cpu_curr_wp = prev;
+	return 0;
+}
+
+static int __get_arm_div(unsigned long pdr0, int *fi, int *fd)
+{
+	int *pclk_mux;
+	if (pdr0 & MXC_CCM_PDR0_AUTO_CON) {
+		pclk_mux = g_clk_mux_consumer +
+		    ((pdr0 & MXC_CCM_PDR0_CON_MUX_DIV_MASK) >>
+		     MXC_CCM_PDR0_CON_MUX_DIV_OFFSET);
+	} else {
+		pclk_mux = g_clk_mux_auto +
+		    ((pdr0 & MXC_CCM_PDR0_AUTO_MUX_DIV_MASK) >>
+		     MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET);
+	}
+
+	if ((*pclk_mux) == -1) {
+		BUG();
+		return -EINVAL;
+	}
+
+	if (fi && fd) {
+		if (!CLK_CODE_PATH(*pclk_mux)) {
+			*fi = *fd = 1;
+			return CLK_CODE_ARM(*pclk_mux);
+		}
+		if (pdr0 & MXC_CCM_PDR0_AUTO_CON) {
+			*fi = 3;
+			*fd = 4;
+		} else {
+			*fi = 2;
+			*fd = 3;
+		}
+	}
+	return CLK_CODE_ARM(*pclk_mux);
+}
+
+static int __get_ahb_div(unsigned long pdr0)
+{
+	int *pclk_mux;
+	if (pdr0 & MXC_CCM_PDR0_AUTO_CON) {
+		pclk_mux = g_clk_mux_consumer +
+		    ((pdr0 & MXC_CCM_PDR0_CON_MUX_DIV_MASK) >>
+		     MXC_CCM_PDR0_CON_MUX_DIV_OFFSET);
+	} else {
+		pclk_mux = g_clk_mux_auto +
+		    ((pdr0 & MXC_CCM_PDR0_AUTO_MUX_DIV_MASK) >>
+		     MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET);
+	}
+
+	if ((*pclk_mux) == -1) {
+		BUG();
+		return -EINVAL;
+	}
+	return CLK_CODE_AHB(*pclk_mux);
+}
+
+static void sync_cpu_wb(void)
+{
+	int i;
+	struct cpu_wp *p;
+	unsigned long reg = __raw_readl(MXC_CCM_PDR0);
+	if (reg & MXC_CCM_PDR0_AUTO_CON) {
+		reg &= MXC_CCM_PDR0_CON_MUX_DIV_MASK;
+	} else {
+		reg &= MXC_CCM_PDR0_AUTO_MUX_DIV_MASK;
+	}
+	for (i = 0; i < cpu_wp_nr; i++) {
+		p = cpu_wp_tbl + cpu_curr_wp;
+		if (p->pdr0_reg == reg)
+			break;
+		cpu_curr_wp = (cpu_curr_wp + 1) % cpu_wp_nr;
+	}
+	cpu_wp_offset = cpu_curr_wp & 1;
+}
+
+static int _clk_enable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg |= 3 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	return 0;
+}
+
+static void _clk_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(3 << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static void _clk_emi_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(3 << clk->enable_shift);
+	reg |= (1 << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static int _clk_asrc_enable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(MXC_CCM_COSR);
+	__raw_writel(reg | MXC_CCM_COSR_ASRC_AUDIO_EN, MXC_CCM_COSR);
+	return 0;
+}
+
+static void _clk_asrc_disable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(MXC_CCM_COSR);
+	__raw_writel(reg & (~MXC_CCM_COSR_ASRC_AUDIO_EN), MXC_CCM_COSR);
+}
+
+static int _clk_pll_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	signed long pd = 1;	/* Pre-divider */
+	signed long mfi;	/* Multiplication Factor (Integer part) */
+	signed long mfn;	/* Multiplication Factor (Integer part) */
+	signed long mfd;	/* Multiplication Factor (Denominator Part) */
+	signed long tmp;
+	u32 ref_freq = clk->parent->rate;
+
+	if ((clk == &mcu_pll_clk)
+	    && (clk->parent->rate == cpu_wp_tbl[cpu_curr_wp].pll_rate)) {
+		__raw_writel(cpu_wp_tbl[cpu_curr_wp].pll_reg, MXC_CCM_MPCTL);
+		clk->rate = rate;
+		return 0;
+	}
+
+	while (((ref_freq / pd) * 10) > rate)
+		pd++;
+
+	if ((ref_freq / pd) < PRE_DIV_MIN_FREQ)
+		return -EINVAL;
+
+	/* the ref_freq/2 in the following is to round up */
+	mfi = (((rate / 2) * pd) + (ref_freq / 2)) / ref_freq;
+	if (mfi < 5 || mfi > 15)
+		return -EINVAL;
+
+	/* pick a mfd value that will work
+	 * then solve for mfn */
+	mfd = ref_freq / 50000;
+
+	/*
+	 *          pll_freq * pd * mfd
+	 *   mfn = --------------------  -  (mfi * mfd)
+	 *           2 * ref_freq
+	 */
+	/* the tmp/2 is for rounding */
+	tmp = ref_freq / 10000;
+	mfn =
+	    ((((((rate / 2) + (tmp / 2)) / tmp) * pd) * mfd) / 10000) -
+	    (mfi * mfd);
+
+	mfn = mfn & 0x3ff;
+	pd--;
+	mfd--;
+
+	/* Change the Pll value */
+	reg = (mfi << MXC_CCM_PCTL_MFI_OFFSET) |
+	    (mfn << MXC_CCM_PCTL_MFN_OFFSET) |
+	    (mfd << MXC_CCM_PCTL_MFD_OFFSET) | (pd << MXC_CCM_PCTL_PD_OFFSET);
+
+	if (clk == &mcu_pll_clk)
+		__raw_writel(reg, MXC_CCM_MPCTL);
+	else if (clk == &peri_pll_clk)
+		__raw_writel(reg, MXC_CCM_PPCTL);
+
+	clk->rate = rate;
+	return 0;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	if ((rate < ahb_clk.rate) || (rate % ahb_clk.rate != 0)) {
+		printk(KERN_ERR "Wrong rate %lu in _clk_cpu_set_rate\n", rate);
+		return -EINVAL;
+	}
+
+	if (clk->parent->rate == cpu_wp_tbl[cpu_curr_wp].pll_rate)
+		return __switch_cpu_wp(rate);
+
+	return __switch_cpu_rate(rate);
+}
+
+static int _clk_asrc_set_rate(struct clk *clk, unsigned long rate)
+{
+	int div;
+	unsigned long reg;
+	if (clk->parent->rate % rate)
+		return -EINVAL;
+
+	div = clk->parent->rate / rate;
+	reg = __raw_readl(MXC_CCM_COSR) & (~MXC_CCM_COSR_ASRC_AUDIO_PODF_MASK);
+	reg |= (div - 1) << MXC_CCM_COSR_ASRC_AUDIO_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_COSR);
+	clk->rate = rate;
+	return 0;
+}
+
+static void _clk_pll_recalc(struct clk *clk)
+{
+	long mfi, mfn, mfd, pdf, ref_clk, mfn_abs;
+	unsigned long reg = 0;
+	s64 temp;
+
+	ref_clk = ckih_clk.rate;
+
+	if (clk == &mcu_pll_clk)
+		reg = __raw_readl(MXC_CCM_MPCTL);
+	else if (clk == &peri_pll_clk)
+		reg = __raw_readl(MXC_CCM_PPCTL);
+	else
+		BUG();
+
+	pdf = (reg & MXC_CCM_PCTL_PD_MASK) >> MXC_CCM_PCTL_PD_OFFSET;
+	mfd = (reg & MXC_CCM_PCTL_MFD_MASK) >> MXC_CCM_PCTL_MFD_OFFSET;
+	mfi = (reg & MXC_CCM_PCTL_MFI_MASK) >> MXC_CCM_PCTL_MFI_OFFSET;
+	mfi = (mfi <= 5) ? 5 : mfi;
+	mfn = mfn_abs = reg & MXC_CCM_PCTL_MFN_MASK;
+
+	if (mfn >= 0x200) {
+		mfn |= 0xFFFFFE00;
+		mfn_abs = -mfn;
+	}
+
+	ref_clk *= 2;
+	ref_clk /= pdf + 1;
+
+	temp = (u64) ref_clk * mfn_abs;
+	do_div(temp, mfd + 1);
+	if (mfn < 0)
+		temp = -temp;
+	temp = (ref_clk * mfi) + temp;
+
+	clk->rate = temp;
+}
+
+static int _clk_peri_pll_enable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(MXC_CCM_CCMR);
+	reg |= MXC_CCM_CCMR_UPE;
+	__raw_writel(reg, MXC_CCM_CCMR);
+
+	/* No lock bit on MX31, so using max time from spec */
+	udelay(80);
+
+	return 0;
+}
+
+static void _clk_peri_pll_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCMR);
+	reg &= ~MXC_CCM_CCMR_UPE;
+	__raw_writel(reg, MXC_CCM_CCMR);
+}
+
+#define PDR0(mask, off) ((__raw_readl(MXC_CCM_PDR0) & mask) >> off)
+#define PDR1(mask, off) ((__raw_readl(MXC_CCM_PDR1) & mask) >> off)
+#define PDR2(mask, off) ((__raw_readl(MXC_CCM_PDR2) & mask) >> off)
+#define PDR3(mask, off) ((__raw_readl(MXC_CCM_PDR3) & mask) >> off)
+#define PDR4(mask, off) ((__raw_readl(MXC_CCM_PDR4) & mask) >> off)
+
+static void _clk_cpu_recalc(struct clk *clk)
+{
+	unsigned long pdr0 = __raw_readl(MXC_CCM_PDR0);
+	int arm_div, fi, fd;
+	if (clk->parent->rate == cpu_wp_tbl[cpu_curr_wp].pll_rate) {
+		clk->rate = cpu_wp_tbl[cpu_curr_wp].cpu_rate;
+	} else {
+		arm_div = __get_arm_div(pdr0, &fi, &fd);
+		clk->rate = (clk->parent->rate * fi) / (arm_div * fd);
+	}
+}
+
+static void _clk_hclk_recalc(struct clk *clk)
+{
+	unsigned long ahb_div, pdr0 = __raw_readl(MXC_CCM_PDR0);
+	ahb_div = __get_ahb_div(pdr0);
+	clk->rate = clk->parent->rate / ahb_div;
+}
+
+static void _clk_ipg_recalc(struct clk *clk)
+{
+	clk->rate = clk->parent->rate / 2;
+}
+
+static void _clk_nfc_recalc(struct clk *clk)
+{
+	unsigned long nfc_pdf;
+
+	nfc_pdf = PDR4(MXC_CCM_PDR4_NFC_PODF_MASK,
+		       MXC_CCM_PDR4_NFC_PODF_OFFSET);
+	clk->rate = clk->parent->rate / (nfc_pdf + 1);
+}
+
+static void _clk_hsp_recalc(struct clk *clk)
+{
+	int hsp_pdf;
+	unsigned long reg;
+	reg = __raw_readl(MXC_CCM_PDR0);
+	if (reg & MXC_CCM_PDR0_AUTO_CON) {
+		hsp_pdf =
+		    (reg & MXC_CCM_PDR0_HSP_PODF_MASK) >>
+		    MXC_CCM_PDR0_HSP_PODF_OFFSET;
+		reg =
+		    (reg & MXC_CCM_PDR0_CON_MUX_DIV_MASK) >>
+		    MXC_CCM_PDR0_CON_MUX_DIV_OFFSET;
+		if (hsp_pdf < 3) {
+			hsp_pdf = g_hsp_div_table[hsp_pdf][reg];
+			if (hsp_pdf > 0)
+				clk->rate = clk->parent->rate / hsp_pdf;
+		}
+	} else {
+		clk->rate = clk->parent->rate;
+	}
+}
+
+static void _clk_mlb_recalc(struct clk *clk)
+{
+	clk->rate = clk->parent->rate * 2;
+}
+
+static void _clk_usb_recalc(struct clk *clk)
+{
+	unsigned long usb_pdf, usb_prepdf;
+
+	usb_pdf = PDR4(MXC_CCM_PDR4_USB_PODF_MASK,
+		       MXC_CCM_PDR4_USB_PODF_OFFSET);
+	usb_prepdf = PDR4(MXC_CCM_PDR4_USB_PRDF_MASK,
+			  MXC_CCM_PDR4_USB_PRDF_OFFSET);
+	clk->rate = clk->parent->rate / ((usb_prepdf + 1) * (usb_pdf + 1));
+}
+
+static void _clk_csi_recalc(struct clk *clk)
+{
+	u32 reg;
+	u32 pre, post;
+
+	reg = __raw_readl(MXC_CCM_PDR2);
+	pre = (reg & MXC_CCM_PDR2_CSI_PRDF_MASK) >>
+	    MXC_CCM_PDR2_CSI_PRDF_OFFSET;
+	post = (reg & MXC_CCM_PDR2_CSI_PODF_MASK) >>
+	    MXC_CCM_PDR2_CSI_PODF_OFFSET;
+	clk->rate = clk->parent->rate / ((pre + 1) * (post + 1));
+}
+
+static unsigned long _clk_csi_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post;
+	u32 div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return clk->parent->rate / (pre * post);
+}
+
+static unsigned long _clk_asrc_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long div;
+	div = clk->parent->rate / rate;
+	if ((clk->parent->rate % rate))
+		div++;
+
+	return clk->parent->rate / div;
+}
+
+static int _clk_csi_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+
+	div = clk->parent->rate / rate;
+
+	if ((clk->parent->rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set CSI clock divider */
+	reg = __raw_readl(MXC_CCM_PDR2) &
+	    ~(MXC_CCM_PDR2_CSI_PRDF_MASK | MXC_CCM_PDR2_CSI_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_PDR2_CSI_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_PDR2_CSI_PRDF_OFFSET;
+	__raw_writel(reg, MXC_CCM_PDR2);
+
+	clk->rate = rate;
+	return 0;
+}
+
+static void _clk_per_recalc(struct clk *clk)
+{
+	unsigned long per_prdf = 0, per_podf;
+
+	if (clk->parent == &cpu_clk) {
+		per_prdf = PDR4(MXC_CCM_PDR4_PER0_PRDF_MASK,
+				MXC_CCM_PDR4_PER0_PRDF_OFFSET);
+		per_podf = PDR4(MXC_CCM_PDR4_PER0_PODF_MASK,
+				MXC_CCM_PDR4_PER0_PODF_OFFSET);
+	} else {
+		per_podf = PDR0(MXC_CCM_PDR0_PER_PODF_MASK,
+				MXC_CCM_PDR0_PER_PODF_OFFSET);
+	}
+	per_podf = (per_podf + 1) * (per_prdf + 1);
+	clk->rate = clk->parent->rate / per_podf;
+}
+
+static void _clk_uart_per_recalc(struct clk *clk)
+{
+	unsigned long pre_pdf, pro_pdf;
+	pre_pdf = PDR4(MXC_CCM_PDR4_UART_PRDF_MASK,
+		       MXC_CCM_PDR4_UART_PRDF_OFFSET);
+	pro_pdf = PDR4(MXC_CCM_PDR4_UART_PODF_MASK,
+		       MXC_CCM_PDR4_UART_PODF_OFFSET);
+	clk->rate = clk->parent->rate / ((pre_pdf + 1) * (pro_pdf + 1));
+
+}
+
+static unsigned long _clk_uart_per_round_rate(struct clk *clk,
+					      unsigned long rate)
+{
+	u32 pre, post;
+	u32 div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return clk->parent->rate / (pre * post);
+}
+
+static void _clk_ssi1_recalc(struct clk *clk)
+{
+	unsigned long ssi1_pdf, ssi1_prepdf;
+
+	ssi1_pdf = PDR2(MXC_CCM_PDR2_SSI1_PODF_MASK,
+			MXC_CCM_PDR2_SSI1_PODF_OFFSET);
+	ssi1_prepdf = PDR2(MXC_CCM_PDR2_SSI1_PRDF_MASK,
+			   MXC_CCM_PDR2_SSI1_PRDF_OFFSET);
+	clk->rate = clk->parent->rate / ((ssi1_prepdf + 1) * (ssi1_pdf + 1));
+}
+
+static void _clk_ssi2_recalc(struct clk *clk)
+{
+	unsigned long ssi2_pdf, ssi2_prepdf;
+
+	ssi2_pdf = PDR2(MXC_CCM_PDR2_SSI2_PODF_MASK,
+			MXC_CCM_PDR2_SSI2_PODF_OFFSET);
+	ssi2_prepdf = PDR2(MXC_CCM_PDR2_SSI2_PRDF_MASK,
+			   MXC_CCM_PDR2_SSI2_PRDF_OFFSET);
+	clk->rate = clk->parent->rate / ((ssi2_prepdf + 1) * (ssi2_pdf + 1));
+}
+
+static void _clk_mstick1_recalc(struct clk *clk)
+{
+	unsigned long prdf, podf;
+	prdf = PDR1(MXC_CCM_PDR1_MSHC_PRDF_MASK, MXC_CCM_PDR1_MSHC_PRDF_OFFSET);
+	podf = PDR1(MXC_CCM_PDR1_MSHC_PODF_MASK, MXC_CCM_PDR1_MSHC_PODF_OFFSET);
+	clk->rate = clk->parent->rate / ((prdf + 1) * (podf + 1));
+}
+
+static void _clk_asrc_recalc(struct clk *clk)
+{
+
+}
+
+static void _clk_sdhc_recalc(struct clk *clk)
+{
+	unsigned long prdf, podf;
+	switch (clk->id) {
+	case 0:
+		prdf = PDR3(MXC_CCM_PDR3_ESDHC1_PRDF_MASK,
+			    MXC_CCM_PDR3_ESDHC1_PRDF_OFFSET);
+		podf = PDR3(MXC_CCM_PDR3_ESDHC1_PODF_MASK,
+			    MXC_CCM_PDR3_ESDHC1_PODF_OFFSET);
+		break;
+	case 1:
+		prdf = PDR3(MXC_CCM_PDR3_ESDHC2_PRDF_MASK,
+			    MXC_CCM_PDR3_ESDHC2_PRDF_OFFSET);
+		podf = PDR3(MXC_CCM_PDR3_ESDHC2_PODF_MASK,
+			    MXC_CCM_PDR3_ESDHC2_PODF_OFFSET);
+		break;
+	case 2:
+		prdf = PDR3(MXC_CCM_PDR3_ESDHC3_PRDF_MASK,
+			    MXC_CCM_PDR3_ESDHC3_PRDF_OFFSET);
+		podf = PDR3(MXC_CCM_PDR3_ESDHC3_PODF_MASK,
+			    MXC_CCM_PDR3_ESDHC3_PODF_OFFSET);
+		break;
+	default:
+		return;
+	}
+	clk->rate = clk->parent->rate / ((prdf + 1) * (podf + 1));
+}
+
+static struct clk ckih_clk = {
+	.name = "ckih",
+	.rate = CKIH_CLK_FREQ,
+	.flags = RATE_FIXED,
+};
+
+static struct clk ckil_clk = {
+	.name = "ckil",
+	.rate = CKIL_CLK_FREQ,
+	.flags = RATE_FIXED,
+};
+
+static struct clk ckie_clk = {
+	.name = "ckie",
+	.rate = CKIE_CLK_FREQ,
+	.flags = RATE_FIXED,
+};
+
+static struct clk mcu_pll_clk = {
+	.name = "mcu_pll",
+	.parent = &ckih_clk,
+	.set_rate = _clk_pll_set_rate,
+	.recalc = _clk_pll_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk peri_pll_clk = {
+	.name = "peri_pll",
+	.parent = &ckih_clk,
+	.set_rate = _clk_pll_set_rate,
+	.recalc = _clk_pll_recalc,
+	.enable = _clk_peri_pll_enable,
+	.disable = _clk_peri_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk cpu_clk = {
+	.name = "cpu_clk",
+	.parent = &mcu_pll_clk,
+	.recalc = _clk_cpu_recalc,
+	.set_rate = _clk_cpu_set_rate,
+};
+
+static struct clk ahb_clk = {
+	.name = "ahb_clk",
+	.parent = &cpu_clk,
+	.recalc = _clk_hclk_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ipg_clk = {
+	.name = "ipg_clk",
+	.parent = &ahb_clk,
+	.recalc = _clk_ipg_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk perclk_clk = {
+	.name = "perclk_clk",
+	.parent = &ahb_clk,
+	.recalc = _clk_per_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk uart_per_clk = {
+	.name = "uart_per_clk",
+	.parent = &peri_pll_clk,
+	.recalc = _clk_uart_per_recalc,
+	.round_rate = _clk_uart_per_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk asrc_clk[] = {
+	{
+	 .name = "asrc_clk",
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_ASRC_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "asrc_audio_clk",
+	 .parent = &ckie_clk,
+	 .recalc = _clk_asrc_recalc,
+	 .round_rate = _clk_asrc_round_rate,
+	 .set_rate = _clk_asrc_set_rate,
+	 .enable = _clk_asrc_enable,
+	 .disable = _clk_asrc_disable,},
+};
+
+static struct clk ata_clk = {
+	.name = "ata_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR0,
+	.enable_shift = MXC_CCM_CGR0_ATA_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk can_clk[] = {
+	{
+	 .name = "can_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_CAN1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "can_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_CAN2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk cspi_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_CSPI1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "cspi_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_CSPI2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk ect_clk = {
+	.name = "ect_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR0,
+	.enable_shift = MXC_CCM_CGR0_ECT_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk emi_clk = {
+	.name = "emi_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR0,
+	.enable_shift = MXC_CCM_CGR0_EMI_OFFSET,
+	.disable = _clk_emi_disable,
+};
+
+static struct clk epit_clk[] = {
+	{
+	 .name = "epit_clk",
+	 .id = 0,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_EPIT1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "epit_clk",
+	 .id = 1,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_EPIT2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk esai_clk = {
+	.name = "esai_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR0,
+	.enable_shift = MXC_CCM_CGR0_ESAI_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk sdhc_clk[] = {
+	{
+	 .name = "sdhc_clk",
+	 .id = 0,
+	 .parent = &peri_pll_clk,
+	 .recalc = _clk_sdhc_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_ESDHC1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "sdhc_clk",
+	 .id = 1,
+	 .parent = &peri_pll_clk,
+	 .recalc = _clk_sdhc_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_ESDHC2_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "sdhc_clk",
+	 .id = 2,
+	 .parent = &peri_pll_clk,
+	 .recalc = _clk_sdhc_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_ESDHC3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk fec_clk = {
+	.name = "fec_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_FEC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk gpt_clk = {
+	.name = "gpt_clk",
+	.parent = &perclk_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_GPT_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk i2c_clk[] = {
+	{
+	 .name = "i2c_clk",
+	 .id = 0,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_I2C1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "i2c_clk",
+	 .id = 1,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_I2C2_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "i2c_clk",
+	 .id = 2,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_I2C3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk ipu_clk = {
+	.name = "ipu_clk",
+	.parent = &cpu_clk,
+	.recalc = _clk_hsp_recalc,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_IPU_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk kpp_clk = {
+	.name = "kpp_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_KPP_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk mlb_clk = {
+	.name = "mlb_clk",
+	.parent = &ahb_clk,
+	.recalc = _clk_mlb_recalc,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_MLB_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk mstick_clk = {
+	.name = "mstick_clk",
+	.id = 0,
+	.parent = &cpu_clk,
+	.recalc = _clk_mstick1_recalc,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_MSHC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk owire_clk = {
+	.name = "owire_clk",
+	.parent = &perclk_clk,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_OWIRE_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static struct clk pwm_clk = {
+	.name = "pwm_clk",
+	.parent = &perclk_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_PWM_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk rng_clk = {
+	.name = "rng_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_RNGC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk rtc_clk = {
+	.name = "rtc_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR2,
+	.enable_shift = MXC_CCM_CGR2_RTC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk rtic_clk = {
+	.name = "rtic_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR2,
+	.enable_shift = MXC_CCM_CGR2_RTIC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk scc_clk = {
+	.name = "scc_clk",
+	.parent = &ipg_clk,
+};
+
+static struct clk sdma_clk[] = {
+	{
+	 .name = "sdma_ahb_clk",
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_SDMA_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "sdma_ipg_clk",
+	 .parent = &ipg_clk,}
+};
+
+static struct clk spba_clk = {
+	.name = "spba_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR2,
+	.enable_shift = MXC_CCM_CGR2_SPBA_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk spdif_clk[] = {
+	{
+	 .name = "spdif_clk",
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_SPBA_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "spdif_audio_clk",
+	 .parent = &ckie_clk,},
+	{
+	 .name = "spdif_ipg_clk",
+	 .parent = &ipg_clk,},
+};
+
+static struct clk ssi_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .parent = &peri_pll_clk,
+	 .recalc = _clk_ssi1_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_SSI1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "ssi_clk",
+	 .id = 1,
+	 .parent = &peri_pll_clk,
+	 .recalc = _clk_ssi2_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_SSI2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk uart_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 0,
+	 .parent = &uart_per_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_UART1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "uart_clk",
+	 .id = 1,
+	 .parent = &uart_per_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_UART2_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "uart_clk",
+	 .id = 2,
+	 .parent = &uart_per_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_UART3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk usb_clk[] = {
+	{
+	 .name = "usb_clk",
+	 .parent = &peri_pll_clk,
+	 .recalc = _clk_usb_recalc,},
+	{
+	 .name = "usb_ahb_clk",
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_USBOTG_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk wdog_clk = {
+	.name = "wdog_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR2,
+	.enable_shift = MXC_CCM_CGR2_WDOG_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk csi_clk = {
+	.name = "csi_clk",
+	.parent = &peri_pll_clk,
+	.recalc = _clk_csi_recalc,
+	.round_rate = _clk_csi_round_rate,
+	.set_rate = _clk_csi_set_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR3,
+	.enable_shift = MXC_CCM_CGR3_CSI_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk iim_clk = {
+	.name = "iim_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR3,
+	.enable_shift = MXC_CCM_CGR3_IIM_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk nfc_clk = {
+	.name = "nfc_clk",
+	.parent = &ahb_clk,
+	.recalc = _clk_nfc_recalc,
+};
+
+static unsigned long _clk_cko1_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	if (div > 64)
+		div = (div + 1) & (~1);
+
+	if (div > 128)
+		return -EINVAL;
+
+	return clk->parent->rate / div;
+}
+
+static int _clk_cko1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div, div2;
+	u32 pre, post;
+
+	div = clk->parent->rate / rate;
+
+	if ((clk->parent->rate / div) != rate)
+		return -EINVAL;
+	if (div > 64) {
+		if (div % 1)
+			return -EINVAL;
+		div2 = MXC_CCM_COSR_CLKOUTDIV_1;
+		div >>= 1;
+	} else {
+		div2 = 0;
+	}
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	reg = __raw_readl(MXC_CCM_COSR) &
+	    ~(MXC_CCM_COSR_CLKOUT_PREDIV_MASK |
+	      MXC_CCM_COSR_CLKOUT_PRODIV_MASK | MXC_CCM_COSR_CLKOUTDIV_1);
+	reg |= ((pre - 1) << MXC_CCM_COSR_CLKOUT_PREDIV_OFFSET) |
+	    ((post - 1) << MXC_CCM_COSR_CLKOUT_PRODIV_OFFSET) | div2;
+	__raw_writel(reg, MXC_CCM_COSR);
+
+	return 0;
+}
+
+static void _clk_cko1_recalc(struct clk *clk)
+{
+	u32 pre, post, factor;
+	u32 reg = __raw_readl(MXC_CCM_COSR);
+
+	pre = (reg & MXC_CCM_COSR_CLKOUT_PREDIV_MASK) >>
+	    MXC_CCM_COSR_CLKOUT_PREDIV_OFFSET;
+
+	post = (reg & MXC_CCM_COSR_CLKOUT_PRODIV_MASK) >>
+	    MXC_CCM_COSR_CLKOUT_PRODIV_OFFSET;
+
+	factor = ((reg & MXC_CCM_COSR_CLKOUTDIV_1) != 0) << 1;
+	clk->rate = clk->parent->rate / (factor * (pre + 1) * (post + 1));
+}
+
+static int _clk_cko1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+	reg = __raw_readl(MXC_CCM_COSR) & ~MXC_CCM_COSR_CLKOSEL_MASK;
+
+	if (parent == &ckil_clk)
+		reg |= 0 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &ckih_clk)
+		reg |= 1 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &ckie_clk)
+		reg |= 2 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &peri_pll_clk)
+		reg |= 6 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &cpu_clk)
+		reg |= 7 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &ahb_clk)
+		reg |= 8 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &ipg_clk)
+		reg |= 9 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &usb_clk[1])
+		reg |= 0xB << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &sdhc_clk[1])
+		reg |= 0xC << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &ssi_clk[1])
+		reg |= 0xD << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &mlb_clk)
+		reg |= 0xE << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &csi_clk)
+		reg |= 0x10 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &spdif_clk[0])
+		reg |= 0x11 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &uart_clk[1])
+		reg |= 0x12 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &asrc_clk[0])
+		reg |= 0x13 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else
+		return -EINVAL;
+
+	__raw_writel(reg, MXC_CCM_COSR);
+	return 0;
+}
+
+static int _clk_cko1_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_COSR) | MXC_CCM_COSR_CLKOEN;
+	__raw_writel(reg, MXC_CCM_COSR);
+
+	return 0;
+}
+
+static void _clk_cko1_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_COSR) & ~MXC_CCM_COSR_CLKOEN;
+	__raw_writel(reg, MXC_CCM_COSR);
+}
+
+static struct clk cko1_clk = {
+	.name = "cko1_clk",
+	.recalc = _clk_cko1_recalc,
+	.set_rate = _clk_cko1_set_rate,
+	.round_rate = _clk_cko1_round_rate,
+	.set_parent = _clk_cko1_set_parent,
+	.enable = _clk_cko1_enable,
+	.disable = _clk_cko1_disable,
+};
+
+static struct clk *mxc_clks[] = {
+	&ckih_clk,
+	&ckil_clk,
+	&ckie_clk,
+	&mcu_pll_clk,
+	&peri_pll_clk,
+	&cpu_clk,
+	&ahb_clk,
+	&ipg_clk,
+	&perclk_clk,
+	&uart_per_clk,
+	&asrc_clk[0],
+	&asrc_clk[1],
+	&ata_clk,
+	&can_clk[0],
+	&can_clk[1],
+	&cspi_clk[0],
+	&cspi_clk[1],
+	&ect_clk,
+	&emi_clk,
+	&epit_clk[0],
+	&epit_clk[1],
+	&esai_clk,
+	&sdhc_clk[0],
+	&sdhc_clk[1],
+	&sdhc_clk[2],
+	&fec_clk,
+	&gpt_clk,
+	&i2c_clk[0],
+	&i2c_clk[1],
+	&i2c_clk[2],
+	&ipu_clk,
+	&kpp_clk,
+	&mlb_clk,
+	&mstick_clk,
+	&owire_clk,
+	&rng_clk,
+	&pwm_clk,
+	&rtc_clk,
+	&rtic_clk,
+	&scc_clk,
+	&sdma_clk[0],
+	&sdma_clk[1],
+	&spba_clk,
+	&spdif_clk[0],
+	&spdif_clk[1],
+	&spdif_clk[2],
+	&ssi_clk[0],
+	&ssi_clk[1],
+	&uart_clk[0],
+	&uart_clk[1],
+	&uart_clk[2],
+	&usb_clk[0],
+	&usb_clk[1],
+	&wdog_clk,
+	&csi_clk,
+	&iim_clk,
+	&nfc_clk,
+	&cko1_clk,
+};
+
+extern void propagate_rate(struct clk *tclk);
+
+static void mxc_clockout_scan(void)
+{
+	u32 reg = __raw_readl(MXC_CCM_COSR) & MXC_CCM_COSR_CLKOSEL_MASK;
+	reg >>= MXC_CCM_COSR_CLKOSEL_OFFSET;
+	switch (reg) {
+	case 0:
+		cko1_clk.parent = &ckil_clk;
+		break;
+	case 1:
+		cko1_clk.parent = &ckih_clk;
+		break;
+	case 2:
+		cko1_clk.parent = &ckie_clk;
+		break;
+	case 6:
+		cko1_clk.parent = &peri_pll_clk;
+		break;
+	case 7:
+		cko1_clk.parent = &cpu_clk;
+		break;
+	case 8:
+		cko1_clk.parent = &ahb_clk;
+		break;
+	case 9:
+		cko1_clk.parent = &ipg_clk;
+		break;
+	case 0xB:
+		cko1_clk.parent = &usb_clk[1];
+		break;
+	case 0xC:
+		cko1_clk.parent = &sdhc_clk[1];
+		break;
+	case 0xD:
+		cko1_clk.parent = &ssi_clk[1];
+		break;
+	case 0xE:
+		cko1_clk.parent = &mlb_clk;
+		break;
+	case 0x10:
+		cko1_clk.parent = &csi_clk;
+		break;
+	case 0x11:
+		cko1_clk.parent = &spdif_clk[0];
+		break;
+	case 0x12:
+		cko1_clk.parent = &uart_clk[1];
+		break;
+	case 0x13:
+		cko1_clk.parent = &asrc_clk[0];
+		break;
+	}
+}
+
+static void mxc_update_clocks(void)
+{
+	unsigned long reg;
+	reg = __raw_readl(MXC_CCM_PDR0);
+	if (!(reg & MXC_CCM_PDR0_AUTO_CON))
+		ipu_clk.parent = &ahb_clk;
+
+	if (reg & MXC_CCM_PDR0_PER_SEL)
+		perclk_clk.parent = &cpu_clk;
+	else
+		perclk_clk.parent = &peri_pll_clk;
+
+	reg = __raw_readl(MXC_CCM_PDR1);
+	if (reg & MXC_CCM_PDR1_MSHC_M_U)
+		mstick_clk.parent = &cpu_clk;
+	else
+		mstick_clk.parent = &peri_pll_clk;
+
+	reg = __raw_readl(MXC_CCM_PDR2);
+	if (reg & MXC_CCM_PDR2_CSI_M_U)
+		csi_clk.parent = &cpu_clk;
+	else
+		csi_clk.parent = &peri_pll_clk;
+
+	if (reg & MXC_CCM_PDR2_SSI_M_U) {
+		ssi_clk[0].parent = &cpu_clk;
+		ssi_clk[1].parent = &cpu_clk;
+	} else {
+		ssi_clk[0].parent = &peri_pll_clk;
+		ssi_clk[1].parent = &peri_pll_clk;
+	}
+	reg = __raw_readl(MXC_CCM_PDR3);
+	if (reg & MXC_CCM_PDR3_SPDIF_M_U)
+		spdif_clk[0].parent = &cpu_clk;
+	else
+		spdif_clk[0].parent = &peri_pll_clk;
+
+	if (reg & MXC_CCM_PDR3_UART_M_U)
+		uart_per_clk.parent = &cpu_clk;
+	else
+		uart_per_clk.parent = &peri_pll_clk;
+
+	if (reg & MXC_CCM_PDR3_ESDHC_M_U) {
+		sdhc_clk[0].parent = &cpu_clk;
+		sdhc_clk[1].parent = &cpu_clk;
+		sdhc_clk[2].parent = &cpu_clk;
+	} else {
+		sdhc_clk[0].parent = &peri_pll_clk;
+		sdhc_clk[1].parent = &peri_pll_clk;
+		sdhc_clk[2].parent = &peri_pll_clk;
+	}
+	reg = __raw_readl(MXC_CCM_PDR4);
+	if (reg & MXC_CCM_PDR4_USB_M_U)
+		usb_clk[0].parent = &cpu_clk;
+	else
+		usb_clk[0].parent = &peri_pll_clk;
+
+	mxc_clockout_scan();
+}
+
+int __init mxc_clocks_init(void)
+{
+	struct clk **clkp;
+	for (clkp = mxc_clks; clkp < mxc_clks + ARRAY_SIZE(mxc_clks); clkp++)
+		clk_register(*clkp);
+
+	/* Turn off all possible clocks */
+	__raw_writel(MXC_CCM_CGR0_EMI_MASK, MXC_CCM_CGR0);
+	__raw_writel(MXC_CCM_CGR1_GPIO1_MASK | MXC_CCM_CGR1_GPIO2_MASK |
+		     MXC_CCM_CGR1_GPIO3_MASK | MXC_CCM_CGR1_GPT_MASK |
+		     MXC_CCM_CGR1_IOMUXC_MASK, MXC_CCM_CGR1);
+	__raw_writel(MXC_CCM_CGR2_MAX_MASK | MXC_CCM_CGR2_SPBA_MASK,
+		     MXC_CCM_CGR2);
+	__raw_writel(MXC_CCM_CGR3_IIM_MASK, MXC_CCM_CGR3);
+
+	mxc_update_clocks();
+	pr_info("Clock input source is %ld\n", ckih_clk.rate);
+
+	/* This will propagate to all children and init all the clock rates */
+	propagate_rate(&ckih_clk);
+
+	clk_enable(&mcu_pll_clk);
+	clk_enable(&gpt_clk);
+	clk_enable(&emi_clk);
+	clk_enable(&iim_clk);
+	clk_enable(&spba_clk);
+
+	/* Init serial PLL according */
+	clk_set_rate(&peri_pll_clk, 300000000);
+
+	clk_enable(&peri_pll_clk);
+	return 0;
+}
+
+/*!
+ * Function to get timer clock rate early in boot process before clock tree is
+ * initialized.
+ *
+ * @return	Clock rate for timer
+ */
+unsigned long __init clk_early_get_timer_rate(void)
+{
+	/* Determine which high frequency clock source is coming in */
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	sync_cpu_wb();
+	mcu_pll_clk.recalc(&mcu_pll_clk);
+	cpu_clk.recalc(&cpu_clk);
+	ahb_clk.recalc(&ahb_clk);
+	ipg_clk.recalc(&ipg_clk);
+	perclk_clk.recalc(&perclk_clk);
+	return perclk_clk.rate;
+}
diff --git a/arch/arm/mach-mx35/cpu.c b/arch/arm/mach-mx35/cpu.c
new file mode 100644
index 0000000..021d547
--- /dev/null
+++ b/arch/arm/mach-mx35/cpu.c
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mach-mx35/cpu.c
+ *
+ * @brief This file contains the CPU initialization code.
+ *
+ * @ingroup MSL_MX35
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/hardware/cache-l2x0.h>
+
+/*!
+ * CPU initialization. It is called by fixup_mxc_board()
+ */
+void __init mxc_cpu_init(void)
+{
+	/* Setup Peripheral Port Remap register for AVIC */
+	asm("ldr r0, =0xC0000015				\n\
+	 mcr p15, 0, r0, c15, c2, 4");
+	/*TODO:Add code to check chip version */
+}
+
+/*!
+ * Post CPU init code
+ *
+ * @return 0 always
+ */
+static int __init post_cpu_init(void)
+{
+	void *l2_base;
+	unsigned long aips_reg;
+
+	/* Initialize L2 cache */
+	l2_base = ioremap(L2CC_BASE_ADDR, SZ_4K);
+	if (l2_base)
+		l2x0_init(l2_base, 0x00030024, 0x00000000);
+
+	/*
+	 * S/W workaround: Clear the off platform peripheral modules
+	 * Supervisor Protect bit for SDMA to access them.
+	 */
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x40));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x44));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x48));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x4C));
+	aips_reg = __raw_readl(IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
+	aips_reg &= 0x00FFFFFF;
+	__raw_writel(aips_reg, IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x40));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x44));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x48));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x4C));
+	aips_reg = __raw_readl(IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
+	aips_reg &= 0x00FFFFFF;
+	__raw_writel(aips_reg, IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
+
+	return 0;
+}
+
+postcore_initcall(post_cpu_init);
diff --git a/arch/arm/mach-mx35/crm_regs.h b/arch/arm/mach-mx35/crm_regs.h
new file mode 100644
index 0000000..4840fad
--- /dev/null
+++ b/arch/arm/mach-mx35/crm_regs.h
@@ -0,0 +1,419 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ARCH_ARM_MACH_MX35_CRM_REGS_H__
+#define __ARCH_ARM_MACH_MX35_CRM_REGS_H__
+
+#define CKIH_CLK_FREQ           24000000
+#define CKIE_CLK_FREQ		24576000
+#define CKIL_CLK_FREQ           32000
+
+#define MXC_CCM_BASE		IO_ADDRESS(CCM_BASE_ADDR)
+
+/* Register addresses */
+#define MXC_CCM_CCMR		(MXC_CCM_BASE + 0x00)
+#define MXC_CCM_PDR0		(MXC_CCM_BASE + 0x04)
+#define MXC_CCM_PDR1		(MXC_CCM_BASE + 0x08)
+#define MXC_CCM_PDR2		(MXC_CCM_BASE + 0x0C)
+#define MXC_CCM_PDR3		(MXC_CCM_BASE + 0x10)
+#define MXC_CCM_PDR4		(MXC_CCM_BASE + 0x14)
+#define MXC_CCM_RCSR		(MXC_CCM_BASE + 0x18)
+#define MXC_CCM_MPCTL		(MXC_CCM_BASE + 0x1C)
+#define MXC_CCM_PPCTL		(MXC_CCM_BASE + 0x20)
+#define MXC_CCM_ACMR		(MXC_CCM_BASE + 0x24)
+#define MXC_CCM_COSR		(MXC_CCM_BASE + 0x28)
+#define MXC_CCM_CGR0		(MXC_CCM_BASE + 0x2C)
+#define MXC_CCM_CGR1		(MXC_CCM_BASE + 0x30)
+#define MXC_CCM_CGR2		(MXC_CCM_BASE + 0x34)
+#define MXC_CCM_CGR3		(MXC_CCM_BASE + 0x38)
+#define MXC_CCM_RESV		(MXC_CCM_BASE + 0x3C)
+#define MXC_CCM_DCVR0		(MXC_CCM_BASE + 0x40)
+#define MXC_CCM_DCVR1		(MXC_CCM_BASE + 0x44)
+#define MXC_CCM_DCVR2		(MXC_CCM_BASE + 0x48)
+#define MXC_CCM_DCVR3		(MXC_CCM_BASE + 0x4C)
+#define MXC_CCM_LTR0		(MXC_CCM_BASE + 0x50)
+#define MXC_CCM_LTR1		(MXC_CCM_BASE + 0x54)
+#define MXC_CCM_LTR2		(MXC_CCM_BASE + 0x58)
+#define MXC_CCM_LTR3		(MXC_CCM_BASE + 0x5C)
+#define MXC_CCM_LTBR0		(MXC_CCM_BASE + 0x60)
+#define MXC_CCM_LTBR1		(MXC_CCM_BASE + 0x64)
+#define MXC_CCM_PMCR0		(MXC_CCM_BASE + 0x68)
+#define MXC_CCM_PMCR1		(MXC_CCM_BASE + 0x6C)
+#define MXC_CCM_PMCR2		(MXC_CCM_BASE + 0x70)
+
+/* Register bit definitions */
+#define MXC_CCM_CCMR_WFI                        (1 << 30)
+#define MXC_CCM_CCMR_STBY_EXIT_SRC              (1 << 29)
+#define MXC_CCM_CCMR_VSTBY                      (1 << 28)
+#define MXC_CCM_CCMR_WBEN                       (1 << 27)
+#define MXC_CCM_CCMR_VOL_RDY_CNT_OFFSET        20
+#define MXC_CCM_CCMR_VOL_RDY_CNT_MASK          (0xF << 20)
+#define MXC_CCM_CCMR_ROMW_OFFSET               18
+#define MXC_CCM_CCMR_ROMW_MASK                 (0x3 << 18)
+#define MXC_CCM_CCMR_RAMW_OFFSET               21
+#define MXC_CCM_CCMR_RAMW_MASK                 (0x3 << 21)
+#define MXC_CCM_CCMR_LPM_OFFSET                 14
+#define MXC_CCM_CCMR_LPM_MASK                   (0x3 << 14)
+#define MXC_CCM_CCMR_UPE                        (1 << 9)
+#define MXC_CCM_CCMR_MPE                        (1 << 3)
+
+#define MXC_CCM_PDR0_PER_SEL			26
+#define MXC_CCM_PDR0_IPU_HND_BYP                23
+#define MXC_CCM_PDR0_HSP_PODF_OFFSET            20
+#define MXC_CCM_PDR0_HSP_PODF_MASK              (0x3 << 20)
+#define MXC_CCM_PDR0_CON_MUX_DIV_OFFSET       	16
+#define MXC_CCM_PDR0_CON_MUX_DIV_MASK           (0xF << 16)
+#define MXC_CCM_PDR0_CKIL_SEL			15
+#define MXC_CCM_PDR0_PER_PODF_OFFSET            12
+#define MXC_CCM_PDR0_PER_PODF_MASK              (0xF << 12)
+#define MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET        9
+#define MXC_CCM_PDR0_AUTO_MUX_DIV_MASK          (0x7 << 9)
+#define MXC_CCM_PDR0_AUTO_CON	                0x1
+
+#define MXC_CCM_PDR1_MSHC_PRDF_OFFSET           28
+#define MXC_CCM_PDR1_MSHC_PRDF_MASK             (0x7 << 28)
+#define MXC_CCM_PDR1_MSHC_PODF_OFFSET           22
+#define MXC_CCM_PDR1_MSHC_PODF_MASK             (0x3F << 22)
+#define MXC_CCM_PDR1_MSHC_M_U 			(1<<7)
+
+#define MXC_CCM_PDR2_SSI2_PRDF_OFFSET           27
+#define MXC_CCM_PDR2_SSI2_PRDF_MASK             (0x7 << 27)
+#define MXC_CCM_PDR2_SSI1_PRDF_OFFSET           24
+#define MXC_CCM_PDR2_SSI1_PRDF_MASK             (0x7 << 24)
+#define MXC_CCM_PDR2_CSI_PRDF_OFFSET            19
+#define MXC_CCM_PDR2_CSI_PRDF_MASK              (0x7 << 19)
+#define MXC_CCM_PDR2_CSI_PODF_OFFSET            16
+#define MXC_CCM_PDR2_CSI_PODF_MASK              (0x7 << 16)
+#define MXC_CCM_PDR2_SSI2_PODF_OFFSET           8
+#define MXC_CCM_PDR2_SSI2_PODF_MASK             (0x3F << 8)
+#define MXC_CCM_PDR2_CSI_M_U			7
+#define MXC_CCM_PDR2_SSI_M_U			6
+#define MXC_CCM_PDR2_SSI1_PODF_OFFSET           0
+#define MXC_CCM_PDR2_SSI1_PODF_MASK             (0x3F)
+
+#define MXC_CCM_PDR3_SPDIF_PRDF_OFFSET          29
+#define MXC_CCM_PDR3_SPDIF_PRDF_MASK            (0x7 << 29)
+#define MXC_CCM_PDR3_SPDIF_PODF_OFFSET          23
+#define MXC_CCM_PDR3_SPDIF_PODF_MASK            (0x3F << 23)
+#define MXC_CCM_PDR3_SPDIF_M_U			22
+#define MXC_CCM_PDR3_ESDHC3_PRDF_OFFSET         19
+#define MXC_CCM_PDR3_ESDHC3_PRDF_MASK           (0x7 << 19)
+#define MXC_CCM_PDR3_ESDHC3_PODF_OFFSET         16
+#define MXC_CCM_PDR3_ESDHC3_PODF_MASK           (0x7 << 16)
+#define MXC_CCM_PDR3_UART_M_U			15
+#define MXC_CCM_PDR3_ESDHC2_PRDF_OFFSET         11
+#define MXC_CCM_PDR3_ESDHC2_PRDF_MASK           (0x7 << 11)
+#define MXC_CCM_PDR3_ESDHC2_PODF_OFFSET         8
+#define MXC_CCM_PDR3_ESDHC2_PODF_MASK           (0x7 << 8)
+#define MXC_CCM_PDR3_ESDHC_M_U			6
+#define MXC_CCM_PDR3_ESDHC1_PRDF_OFFSET         3
+#define MXC_CCM_PDR3_ESDHC1_PRDF_MASK           (0x7 << 3)
+#define MXC_CCM_PDR3_ESDHC1_PODF_OFFSET         0
+#define MXC_CCM_PDR3_ESDHC1_PODF_MASK           (0x7)
+
+#define MXC_CCM_PDR4_NFC_PODF_OFFSET           	28
+#define MXC_CCM_PDR4_NFC_PODF_MASK            	(0xF << 28)
+#define MXC_CCM_PDR4_USB_PRDF_OFFSET          	25
+#define MXC_CCM_PDR4_USB_PRDF_MASK            	(0x7 << 25)
+#define MXC_CCM_PDR4_USB_PODF_OFFSET          	22
+#define MXC_CCM_PDR4_USB_PODF_MASK            	(0x7 << 22)
+#define MXC_CCM_PDR4_PER0_PRDF_OFFSET          	19
+#define MXC_CCM_PDR4_PER0_PRDF_MASK            	(0x7 << 19)
+#define MXC_CCM_PDR4_PER0_PODF_OFFSET          	16
+#define MXC_CCM_PDR4_PER0_PODF_MASK            	(0x7 << 16)
+#define MXC_CCM_PDR4_UART_PRDF_OFFSET          	13
+#define MXC_CCM_PDR4_UART_PRDF_MASK            	(0x7 << 13)
+#define MXC_CCM_PDR4_UART_PODF_OFFSET          	10
+#define MXC_CCM_PDR4_UART_PODF_MASK            	(0x7 << 10)
+#define MXC_CCM_PDR4_USB_M_U			9
+
+/* Bit definitions for RCSR */
+#define MXC_CCM_RCSR_BUS_WIDTH			(1 << 29)
+#define MXC_CCM_RCSR_BUS_16BIT			(1 << 29)
+#define MXC_CCM_RCSR_PAGE_SIZE			(3 << 27)
+#define MXC_CCM_RCSR_PAGE_512			(0 << 27)
+#define MXC_CCM_RCSR_PAGE_2K			(1 << 27)
+#define MXC_CCM_RCSR_PAGE_4K1			(2 << 27)
+#define MXC_CCM_RCSR_PAGE_4K2			(3 << 27)
+#define MXC_CCM_RCSR_SOFT_RESET			(1 << 15)
+#define MXC_CCM_RCSR_NF16B			(1 << 14)
+#define MXC_CCM_RCSR_NFC_4K			(1 << 9)
+#define MXC_CCM_RCSR_NFC_FMS			(1 << 8)
+
+/* Bit definitions for both MCU, PERIPHERAL PLL control registers */
+#define MXC_CCM_PCTL_BRM                        0x80000000
+#define MXC_CCM_PCTL_PD_OFFSET                  26
+#define MXC_CCM_PCTL_PD_MASK                    (0xF << 26)
+#define MXC_CCM_PCTL_MFD_OFFSET                 16
+#define MXC_CCM_PCTL_MFD_MASK                   (0x3FF << 16)
+#define MXC_CCM_PCTL_MFI_OFFSET                 10
+#define MXC_CCM_PCTL_MFI_MASK                   (0xF << 10)
+#define MXC_CCM_PCTL_MFN_OFFSET                 0
+#define MXC_CCM_PCTL_MFN_MASK                   0x3FF
+
+/* Bit definitions for Audio clock mux register*/
+#define MXC_CCM_ACMR_ESAI_CLK_SEL_OFFSET	12
+#define MXC_CCM_ACMR_ESAI_CLK_SEL_MASK		(0xF << 12)
+#define MXC_CCM_ACMR_SPDIF_CLK_SEL_OFFSET	8
+#define MXC_CCM_ACMR_SPDIF_CLK_SEL_MASK		(0xF << 8)
+#define MXC_CCM_ACMR_SSI1_CLK_SEL_OFFSET	4
+#define MXC_CCM_ACMR_SSI1_CLK_SEL_MASK		(0xF << 4)
+#define MXC_CCM_ACMR_SSI2_CLK_SEL_OFFSET	0
+#define MXC_CCM_ACMR_SSI2_CLK_SEL_MASK		(0xF << 0)
+
+/* Bit definitions for Clock gating Register*/
+#define MXC_CCM_CGR0_ASRC_OFFSET             	0
+#define MXC_CCM_CGR0_ASRC_MASK               	(0x3 << 0)
+#define MXC_CCM_CGR0_ATA_OFFSET             	2
+#define MXC_CCM_CGR0_ATA_MASK               	(0x3 << 2)
+#define MXC_CCM_CGR0_CAN1_OFFSET                6
+#define MXC_CCM_CGR0_CAN1_MASK                  (0x3 << 6)
+#define MXC_CCM_CGR0_CAN2_OFFSET                8
+#define MXC_CCM_CGR0_CAN2_MASK                  (0x3 << 8)
+#define MXC_CCM_CGR0_CSPI1_OFFSET               10
+#define MXC_CCM_CGR0_CSPI1_MASK                 (0x3 << 10)
+#define MXC_CCM_CGR0_CSPI2_OFFSET               12
+#define MXC_CCM_CGR0_CSPI2_MASK                 (0x3 << 12)
+#define MXC_CCM_CGR0_ECT_OFFSET               	14
+#define MXC_CCM_CGR0_ECT_MASK                 	(0x3 << 14)
+#define MXC_CCM_CGR0_EMI_OFFSET               	18
+#define MXC_CCM_CGR0_EMI_MASK                 	(0x3 << 18)
+#define MXC_CCM_CGR0_EPIT1_OFFSET               20
+#define MXC_CCM_CGR0_EPIT1_MASK                 (0x3 << 20)
+#define MXC_CCM_CGR0_EPIT2_OFFSET               22
+#define MXC_CCM_CGR0_EPIT2_MASK                 (0x3 << 22)
+#define MXC_CCM_CGR0_ESAI_OFFSET                24
+#define MXC_CCM_CGR0_ESAI_MASK                  (0x3 << 24)
+#define MXC_CCM_CGR0_ESDHC1_OFFSET              26
+#define MXC_CCM_CGR0_ESDHC1_MASK                (0x3 << 26)
+#define MXC_CCM_CGR0_ESDHC2_OFFSET              28
+#define MXC_CCM_CGR0_ESDHC2_MASK                (0x3 << 28)
+#define MXC_CCM_CGR0_ESDHC3_OFFSET              30
+#define MXC_CCM_CGR0_ESDHC3_MASK                (0x3 << 30)
+
+#define MXC_CCM_CGR1_FEC_OFFSET              	0
+#define MXC_CCM_CGR1_FEC_MASK                	(0x3 << 0)
+#define MXC_CCM_CGR1_GPIO1_OFFSET           	2
+#define MXC_CCM_CGR1_GPIO1_MASK             	(0x3 << 2)
+#define MXC_CCM_CGR1_GPIO2_OFFSET           	4
+#define MXC_CCM_CGR1_GPIO2_MASK             	(0x3 << 4)
+#define MXC_CCM_CGR1_GPIO3_OFFSET               6
+#define MXC_CCM_CGR1_GPIO3_MASK                 (0x3 << 6)
+#define MXC_CCM_CGR1_GPT_OFFSET                 8
+#define MXC_CCM_CGR1_GPT_MASK                   (0x3 << 8)
+#define MXC_CCM_CGR1_I2C1_OFFSET                10
+#define MXC_CCM_CGR1_I2C1_MASK                  (0x3 << 10)
+#define MXC_CCM_CGR1_I2C2_OFFSET                12
+#define MXC_CCM_CGR1_I2C2_MASK                  (0x3 << 12)
+#define MXC_CCM_CGR1_I2C3_OFFSET                14
+#define MXC_CCM_CGR1_I2C3_MASK                  (0x3 << 14)
+#define MXC_CCM_CGR1_IOMUXC_OFFSET              16
+#define MXC_CCM_CGR1_IOMUXC_MASK                (0x3 << 16)
+#define MXC_CCM_CGR1_IPU_OFFSET              	18
+#define MXC_CCM_CGR1_IPU_MASK                	(0x3 << 18)
+#define MXC_CCM_CGR1_KPP_OFFSET                 20
+#define MXC_CCM_CGR1_KPP_MASK                   (0x3 << 20)
+#define MXC_CCM_CGR1_MLB_OFFSET                 22
+#define MXC_CCM_CGR1_MLB_MASK                   (0x3 << 22)
+#define MXC_CCM_CGR1_MSHC_OFFSET               	24
+#define MXC_CCM_CGR1_MSHC_MASK                 	(0x3 << 24)
+#define MXC_CCM_CGR1_OWIRE_OFFSET              	26
+#define MXC_CCM_CGR1_OWIRE_MASK                 (0x3 << 26)
+#define MXC_CCM_CGR1_PWM_OFFSET               	28
+#define MXC_CCM_CGR1_PWM_MASK                 	(0x3 << 28)
+#define MXC_CCM_CGR1_RNGC_OFFSET               	30
+#define MXC_CCM_CGR1_RNGC_MASK                 	(0x3 << 30)
+
+#define MXC_CCM_CGR2_RTC_OFFSET                	0
+#define MXC_CCM_CGR2_RTC_MASK                  	(0x3 << 0)
+#define MXC_CCM_CGR2_RTIC_OFFSET               	2
+#define MXC_CCM_CGR2_RTIC_MASK                 	(0x3 << 2)
+#define MXC_CCM_CGR2_SCC_OFFSET               	4
+#define MXC_CCM_CGR2_SCC_MASK                 	(0x3 << 4)
+#define MXC_CCM_CGR2_SDMA_OFFSET                6
+#define MXC_CCM_CGR2_SDMA_MASK                  (0x3 << 6)
+#define MXC_CCM_CGR2_SPBA_OFFSET                8
+#define MXC_CCM_CGR2_SPBA_MASK                  (0x3 << 8)
+#define MXC_CCM_CGR2_SPDIF_OFFSET               10
+#define MXC_CCM_CGR2_SPDIF_MASK                 (0x3 << 10)
+#define MXC_CCM_CGR2_SSI1_OFFSET                12
+#define MXC_CCM_CGR2_SSI1_MASK                  (0x3 << 12)
+#define MXC_CCM_CGR2_SSI2_OFFSET              	14
+#define MXC_CCM_CGR2_SSI2_MASK                	(0x3 << 14)
+#define MXC_CCM_CGR2_UART1_OFFSET              	16
+#define MXC_CCM_CGR2_UART1_MASK                	(0x3 << 16)
+#define MXC_CCM_CGR2_UART2_OFFSET              	18
+#define MXC_CCM_CGR2_UART2_MASK                	(0x3 << 18)
+#define MXC_CCM_CGR2_UART3_OFFSET              	20
+#define MXC_CCM_CGR2_UART3_MASK                	(0x3 << 20)
+#define MXC_CCM_CGR2_USBOTG_OFFSET             	22
+#define MXC_CCM_CGR2_USBOTG_MASK                (0x3 << 22)
+#define MXC_CCM_CGR2_WDOG_OFFSET              	24
+#define MXC_CCM_CGR2_WDOG_MASK                	(0x3 << 24)
+#define MXC_CCM_CGR2_MAX_OFFSET              	26
+#define MXC_CCM_CGR2_MAX_MASK                	(0x3 << 26)
+#define MXC_CCM_CGR2_AUDMUX_OFFSET              30
+#define MXC_CCM_CGR2_AUDMUX_MASK                (0x3 << 30)
+
+#define MXC_CCM_CGR3_CSI_OFFSET              	0
+#define MXC_CCM_CGR3_CSI_MASK                	(0x3 << 0)
+#define MXC_CCM_CGR3_IIM_OFFSET              	2
+#define MXC_CCM_CGR3_IIM_MASK                	(0x3 << 2)
+#define MXC_CCM_CGR3_GPU2D_OFFSET              	4
+#define MXC_CCM_CGR3_GPU2D_MASK                	(0x3 << 4)
+/*
+ * LTR0 register offsets
+ */
+#define MXC_CCM_LTR0_DIV3CK_OFFSET              28
+#define MXC_CCM_LTR0_DIV3CK_MASK                (0x3 << 28)
+#define MXC_CCM_LTR0_DNTHR_OFFSET               16
+#define MXC_CCM_LTR0_DNTHR_MASK                 (0x3F << 16)
+#define MXC_CCM_LTR0_UPTHR_OFFSET               22
+#define MXC_CCM_LTR0_UPTHR_MASK                 (0x3F << 22)
+
+/*
+ * LTR1 register offsets
+ */
+#define MXC_CCM_LTR1_PNCTHR_OFFSET              0
+#define MXC_CCM_LTR1_PNCTHR_MASK                0x3F
+#define MXC_CCM_LTR1_UPCNT_OFFSET               6
+#define MXC_CCM_LTR1_UPCNT_MASK                 (0xFF << 6)
+#define MXC_CCM_LTR1_DNCNT_OFFSET               14
+#define MXC_CCM_LTR1_DNCNT_MASK                 (0xFF << 14)
+#define MXC_CCM_LTR1_LTBRSR_MASK                0x400000
+#define MXC_CCM_LTR1_LTBRSR_OFFSET              22
+#define MXC_CCM_LTR1_LTBRSR                     0x400000
+#define MXC_CCM_LTR1_LTBRSH                     0x800000
+
+/*
+ * LTR2 bit definitions. x ranges from 0 for WSW9 to 6 for WSW15
+ */
+#define MXC_CCM_LTR2_WSW_OFFSET(x)	(11 + (x) * 3)
+#define MXC_CCM_LTR2_WSW_MASK(x)	(0x7 << MXC_CCM_LTR2_WSW_OFFSET((x)))
+#define MXC_CCM_LTR2_EMAC_OFFSET        0
+#define MXC_CCM_LTR2_EMAC_MASK          0x1FF
+
+/*
+ * LTR3 bit definitions. x ranges from 0 for WSW0 to 8 for WSW8
+ */
+#define MXC_CCM_LTR3_WSW_OFFSET(x)     	(5 + (x) * 3)
+#define MXC_CCM_LTR3_WSW_MASK(x)       	(0x7 << MXC_CCM_LTR3_WSW_OFFSET((x)))
+
+#define MXC_CCM_PMCR0_DFSUP1                    0x80000000
+#define MXC_CCM_PMCR0_DFSUP1_SPLL               (0 << 31)
+#define MXC_CCM_PMCR0_DFSUP1_MPLL               (1 << 31)
+#define MXC_CCM_PMCR0_DFSUP0                    0x40000000
+#define MXC_CCM_PMCR0_DFSUP0_PLL                (0 << 30)
+#define MXC_CCM_PMCR0_DFSUP0_PDR                (1 << 30)
+#define MXC_CCM_PMCR0_DFSUP_MASK                (0x3 << 30)
+
+#define DVSUP_TURBO				0
+#define DVSUP_HIGH				1
+#define DVSUP_MEDIUM				2
+#define DVSUP_LOW				3
+#define MXC_CCM_PMCR0_DVSUP_TURBO               (DVSUP_TURBO << 28)
+#define MXC_CCM_PMCR0_DVSUP_HIGH                (DVSUP_HIGH << 28)
+#define MXC_CCM_PMCR0_DVSUP_MEDIUM              (DVSUP_MEDIUM << 28)
+#define MXC_CCM_PMCR0_DVSUP_LOW                 (DVSUP_LOW << 28)
+#define MXC_CCM_PMCR0_DVSUP_OFFSET              28
+#define MXC_CCM_PMCR0_DVSUP_MASK                (0x3 << 28)
+#define MXC_CCM_PMCR0_UDSC                      0x08000000
+#define MXC_CCM_PMCR0_UDSC_MASK                 (1 << 27)
+#define MXC_CCM_PMCR0_UDSC_UP                   (1 << 27)
+#define MXC_CCM_PMCR0_UDSC_DOWN                 (0 << 27)
+
+#define MXC_CCM_PMCR0_VSCNT_1                   (0x0 << 24)
+#define MXC_CCM_PMCR0_VSCNT_2                   (0x1 << 24)
+#define MXC_CCM_PMCR0_VSCNT_3                   (0x2 << 24)
+#define MXC_CCM_PMCR0_VSCNT_4                   (0x3 << 24)
+#define MXC_CCM_PMCR0_VSCNT_5                   (0x4 << 24)
+#define MXC_CCM_PMCR0_VSCNT_6                   (0x5 << 24)
+#define MXC_CCM_PMCR0_VSCNT_7                   (0x6 << 24)
+#define MXC_CCM_PMCR0_VSCNT_8                   (0x7 << 24)
+#define MXC_CCM_PMCR0_VSCNT_OFFSET              24
+#define MXC_CCM_PMCR0_VSCNT_MASK                (0x7 << 24)
+#define MXC_CCM_PMCR0_DVFEV                     0x00800000
+#define MXC_CCM_PMCR0_DVFIS                     0x00400000
+#define MXC_CCM_PMCR0_LBMI                      0x00200000
+#define MXC_CCM_PMCR0_LBFL                      0x00100000
+#define MXC_CCM_PMCR0_LBCF_4                    (0x0 << 18)
+#define MXC_CCM_PMCR0_LBCF_8                    (0x1 << 18)
+#define MXC_CCM_PMCR0_LBCF_12                   (0x2 << 18)
+#define MXC_CCM_PMCR0_LBCF_16                   (0x3 << 18)
+#define MXC_CCM_PMCR0_LBCF_OFFSET               18
+#define MXC_CCM_PMCR0_LBCF_MASK                 (0x3 << 18)
+#define MXC_CCM_PMCR0_PTVIS                     0x00020000
+#define MXC_CCM_PMCR0_UPDTEN                    0x00010000
+#define MXC_CCM_PMCR0_UPDTEN_MASK               (0x1 << 16)
+#define MXC_CCM_PMCR0_FSVAIM                    0x00008000
+#define MXC_CCM_PMCR0_FSVAI_OFFSET              13
+#define MXC_CCM_PMCR0_FSVAI_MASK                (0x3 << 13)
+#define MXC_CCM_PMCR0_DPVCR                     0x00001000
+#define MXC_CCM_PMCR0_DPVV                      0x00000800
+#define MXC_CCM_PMCR0_WFIM                      0x00000400
+#define MXC_CCM_PMCR0_DRCE3                     0x00000200
+#define MXC_CCM_PMCR0_DRCE2                     0x00000100
+#define MXC_CCM_PMCR0_DRCE1                     0x00000080
+#define MXC_CCM_PMCR0_DRCE0                     0x00000040
+#define MXC_CCM_PMCR0_DCR                       0x00000020
+#define MXC_CCM_PMCR0_DVFEN                     0x00000010
+#define MXC_CCM_PMCR0_PTVAIM                    0x00000008
+#define MXC_CCM_PMCR0_PTVAI_OFFSET              1
+#define MXC_CCM_PMCR0_PTVAI_MASK                (0x3 << 1)
+#define MXC_CCM_PMCR0_DPTEN                     0x00000001
+
+#define MXC_CCM_PMCR1_DVGP_OFFSET               0
+#define MXC_CCM_PMCR1_DVGP_MASK                 (0xF)
+
+#define MXC_CCM_PMCR1_PLLRDIS                      (0x1 << 7)
+#define MXC_CCM_PMCR1_EMIRQ_EN                      (0x1 << 8)
+
+#define MXC_CCM_DCVR_ULV_MASK                   (0x3FF << 22)
+#define MXC_CCM_DCVR_ULV_OFFSET                 22
+#define MXC_CCM_DCVR_LLV_MASK                   (0x3FF << 12)
+#define MXC_CCM_DCVR_LLV_OFFSET                 12
+#define MXC_CCM_DCVR_ELV_MASK                   (0x3FF << 2)
+#define MXC_CCM_DCVR_ELV_OFFSET                 2
+
+#define MXC_CCM_PDR2_MST2_PDF_MASK              (0x3F << 7)
+#define MXC_CCM_PDR2_MST2_PDF_OFFSET            7
+#define MXC_CCM_PDR2_MST1_PDF_MASK              0x3F
+#define MXC_CCM_PDR2_MST1_PDF_OFFSET            0
+
+#define MXC_CCM_COSR_CLKOSEL_MASK               0x1F
+#define MXC_CCM_COSR_CLKOSEL_OFFSET             0
+#define MXC_CCM_COSR_CLKOEN                     (1 << 5)
+#define MXC_CCM_COSR_CLKOUTDIV_1             	(1 << 6)
+#define MXC_CCM_COSR_CLKOUT_PREDIV_MASK         (0x7 << 10)
+#define MXC_CCM_COSR_CLKOUT_PREDIV_OFFSET       10
+#define MXC_CCM_COSR_CLKOUT_PRODIV_MASK         (0x7 << 13)
+#define MXC_CCM_COSR_CLKOUT_PRODIV_OFFSET       13
+#define MXC_CCM_COSR_SSI1_RX_SRC_SEL_MASK       (0x3 << 16)
+#define MXC_CCM_COSR_SSI1_RX_SRC_SEL_OFFSET     16
+#define MXC_CCM_COSR_SSI1_TX_SRC_SEL_MASK       (0x3 << 18)
+#define MXC_CCM_COSR_SSI1_TX_SRC_SEL_OFFSET     18
+#define MXC_CCM_COSR_SSI2_RX_SRC_SEL_MASK       (0x3 << 20)
+#define MXC_CCM_COSR_SSI2_RX_SRC_SEL_OFFSET     20
+#define MXC_CCM_COSR_SSI2_TX_SRC_SEL_MASK       (0x3 << 22)
+#define MXC_CCM_COSR_SSI2_TX_SRC_SEL_OFFSET     22
+#define MXC_CCM_COSR_ASRC_AUDIO_EN              (1 << 24)
+#define MXC_CCM_COSR_ASRC_AUDIO_PODF_MASK       (0x3F << 25)
+#define MXC_CCM_COSR_ASRC_AUDIO_PODF_OFFSET     25
+
+/*
+ * PMCR0 register offsets
+ */
+#define MXC_CCM_PMCR0_LBFL_OFFSET   20
+#define MXC_CCM_PMCR0_DFSUP0_OFFSET 30
+#define MXC_CCM_PMCR0_DFSUP1_OFFSET 31
+
+#endif				/* __ARCH_ARM_MACH_MX3_CRM_REGS_H__ */
diff --git a/arch/arm/mach-mx35/devices.c b/arch/arm/mach-mx35/devices.c
new file mode 100644
index 0000000..e6f6845
--- /dev/null
+++ b/arch/arm/mach-mx35/devices.c
@@ -0,0 +1,353 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/spba.h>
+#include <asm/arch/sdma.h>
+
+#include "iomux.h"
+#include "sdma_script_code.h"
+
+void mxc_sdma_get_script_info(sdma_script_start_addrs * sdma_script_addr)
+{
+	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
+	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+	sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
+
+	sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
+
+	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = uartsh_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
+
+	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
+
+	sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
+
+	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+
+	sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = spdif_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = mcu_2_spdif_ADDR;
+
+	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+	sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr = ext_mem__ipu_ram_ADDR;
+	sdma_script_addr->mxc_sdma_descrambler_addr = descrambler_ADDR;
+
+	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code;
+	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
+	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR;
+}
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_RTC_MXC) || defined(CONFIG_RTC_MXC_MODULE)
+static struct resource rtc_resources[] = {
+	{
+	 .start = RTC_BASE_ADDR,
+	 .end = RTC_BASE_ADDR + 0x30,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MXC_INT_RTC,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+static struct platform_device mxc_rtc_device = {
+	.name = "mxc_rtc",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(rtc_resources),
+	.resource = rtc_resources,
+};
+static void mxc_init_rtc(void)
+{
+	(void)platform_device_register(&mxc_rtc_device);
+}
+#else
+static inline void mxc_init_rtc(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
+static struct resource wdt_resources[] = {
+	{
+	 .start = WDOG1_BASE_ADDR,
+	 .end = WDOG1_BASE_ADDR + 0x30,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_wdt_device = {
+	.name = "mxc_wdt",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(wdt_resources),
+	.resource = wdt_resources,
+};
+
+static void mxc_init_wdt(void)
+{
+	(void)platform_device_register(&mxc_wdt_device);
+}
+#else
+static inline void mxc_init_wdt(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_IPU) || defined(CONFIG_MXC_IPU_MODULE)
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 1,
+};
+
+static struct resource ipu_resources[] = {
+	{
+	 .start = IPU_CTRL_BASE_ADDR,
+	 .end = IPU_CTRL_BASE_ADDR + SZ_4K,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MXC_INT_IPU_SYN,
+	 .flags = IORESOURCE_IRQ,
+	 },
+	{
+	 .start = MXC_INT_IPU_ERR,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct platform_device mxc_ipu_device = {
+	.name = "mxc_ipu",
+	.id = -1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_ipu_data,
+		},
+	.num_resources = ARRAY_SIZE(ipu_resources),
+	.resource = ipu_resources,
+};
+
+static void mxc_init_ipu(void)
+{
+	platform_device_register(&mxc_ipu_device);
+}
+#else
+static inline void mxc_init_ipu(void)
+{
+}
+#endif
+
+/* I2C controller and device data */
+#if defined(CONFIG_I2C_MXC) || defined(CONFIG_I2C_MXC_MODULE)
+
+#ifdef CONFIG_I2C_MXC_SELECT1
+/*!
+ * Resource definition for the I2C1
+ */
+static struct resource mxci2c1_resources[] = {
+	[0] = {
+	       .start = I2C_BASE_ADDR,
+	       .end = I2C_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_I2C,
+	       .end = MXC_INT_I2C,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c1_data = {
+	.i2c_clk = 100000,
+};
+#endif
+
+#ifdef CONFIG_I2C_MXC_SELECT2
+/*!
+ * Resource definition for the I2C2
+ */
+static struct resource mxci2c2_resources[] = {
+	[0] = {
+	       .start = I2C2_BASE_ADDR,
+	       .end = I2C2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_I2C2,
+	       .end = MXC_INT_I2C2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c2_data = {
+	.i2c_clk = 100000,
+};
+#endif
+
+#ifdef CONFIG_I2C_MXC_SELECT3
+/*!
+ * Resource definition for the I2C3
+ */
+static struct resource mxci2c3_resources[] = {
+	[0] = {
+	       .start = I2C3_BASE_ADDR,
+	       .end = I2C3_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_I2C3,
+	       .end = MXC_INT_I2C3,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c3_data = {
+	.i2c_clk = 100000,
+};
+#endif
+
+/*! Device Definition for MXC I2C1 */
+static struct platform_device mxci2c_devices[] = {
+#ifdef CONFIG_I2C_MXC_SELECT1
+	{
+	 .name = "mxc_i2c",
+	 .id = 0,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = &mxci2c1_data,
+		 },
+	 .num_resources = ARRAY_SIZE(mxci2c1_resources),
+	 .resource = mxci2c1_resources,},
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT2
+	{
+	 .name = "mxc_i2c",
+	 .id = 1,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = &mxci2c2_data,
+		 },
+	 .num_resources = ARRAY_SIZE(mxci2c2_resources),
+	 .resource = mxci2c2_resources,},
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT3
+	{
+	 .name = "mxc_i2c",
+	 .id = 2,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = &mxci2c3_data,
+		 },
+	 .num_resources = ARRAY_SIZE(mxci2c3_resources),
+	 .resource = mxci2c3_resources,},
+#endif
+};
+
+static inline void mxc_init_i2c(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mxci2c_devices); i++) {
+		if (platform_device_register(&mxci2c_devices[i]) < 0)
+			dev_err(&mxci2c_devices[i].dev,
+				"Unable to register I2C device\n");
+	}
+}
+#else
+static inline void mxc_init_i2c(void)
+{
+}
+#endif
+
+struct mxc_gpio_port mxc_gpio_ports[GPIO_PORT_NUM] = {
+	{
+	 .num = 0,
+	 .base = IO_ADDRESS(GPIO1_BASE_ADDR),
+	 .irq = MXC_INT_GPIO1,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE,
+	 },
+	{
+	 .num = 1,
+	 .base = IO_ADDRESS(GPIO2_BASE_ADDR),
+	 .irq = MXC_INT_GPIO2,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN,
+	 },
+	{
+	 .num = 2,
+	 .base = IO_ADDRESS(GPIO3_BASE_ADDR),
+	 .irq = MXC_INT_GPIO3,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 2,
+	 },
+};
+
+static struct platform_device mxc_dma_device = {
+	.name = "mxc_dma",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+};
+
+static inline void mxc_init_dma(void)
+{
+	(void)platform_device_register(&mxc_dma_device);
+}
+
+static int __init mxc_init_devices(void)
+{
+	mxc_init_wdt();
+	mxc_init_ipu();
+	mxc_init_i2c();
+	mxc_init_rtc();
+	mxc_init_dma();
+
+	/* SPBA configuration for SSI2 - SDMA and MCU are set */
+	spba_take_ownership(SPBA_SSI2, SPBA_MASTER_C | SPBA_MASTER_A);
+	return 0;
+}
+
+arch_initcall(mxc_init_devices);
diff --git a/arch/arm/mach-mx35/dma.c b/arch/arm/mach-mx35/dma.c
new file mode 100644
index 0000000..3da50db
--- /dev/null
+++ b/arch/arm/mach-mx35/dma.c
@@ -0,0 +1,163 @@
+/*
+ *  Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/dma.h>
+#include <asm/arch/hardware.h>
+
+#include "serial.h"
+
+struct mxc_sdma_info_entry_s {
+	mxc_dma_device_t device;
+	mxc_sdma_channel_params_t *chnl_info;
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_RXTL,
+			.per_address = UART1_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART1_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_TXTL,
+			.per_address = UART1_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART1_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_RXTL,
+			.per_address = UART2_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART2_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_TXTL,
+			.per_address = UART2_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART2_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_RXTL,
+			.per_address = UART3_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART3_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_TXTL,
+			.per_address = UART3_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART3_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
+	.chnl_params = {
+			.peripheral_type = MEMORY,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MEMORY,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static struct mxc_sdma_info_entry_s mxc_sdma_active_dma_info[] = {
+	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
+	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
+	{MXC_DMA_UART2_RX, &mxc_sdma_uart2_rx_params},
+	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
+	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
+	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
+};
+
+static int mxc_sdma_info_entrys =
+    sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id)
+{
+	struct mxc_sdma_info_entry_s *p = mxc_sdma_active_dma_info;
+	int i;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		if (p->device == channel_id)
+			return p->chnl_info;
+	}
+	return NULL;
+}
+
+EXPORT_SYMBOL(mxc_sdma_get_channel_params);
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t *chnl)
+{
+	/* No channels statically allocated for MX35 */
+}
+
+EXPORT_SYMBOL(mxc_get_static_channels);
diff --git a/arch/arm/mach-mx35/iomux.c b/arch/arm/mach-mx35/iomux.c
new file mode 100644
index 0000000..5806e7b
--- /dev/null
+++ b/arch/arm/mach-mx35/iomux.c
@@ -0,0 +1,216 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup GPIO_MX35 Board GPIO and Muxing Setup
+ * @ingroup MSL_MX35
+ */
+/*!
+ * @file mach-mx35/iomux.c
+ *
+ * @brief I/O Muxing control functions
+ *
+ * @ingroup GPIO_MX35
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/hardware.h>
+#include <asm/arch/gpio.h>
+#include "iomux.h"
+
+/*!
+ * IOMUX register (base) addresses
+ */
+enum iomux_reg_addr {
+	IOMUXGPR = IO_ADDRESS(IOMUXC_BASE_ADDR),
+	/*!< General purpose */
+	IOMUXSW_MUX_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + 4,
+	/*!< MUX control */
+	IOMUXSW_MUX_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x324,
+	/*!< last MUX control register */
+	IOMUXSW_PAD_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x328,
+	/*!< Pad control */
+	IOMUXSW_PAD_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x794,
+	/*!< last Pad control register */
+	IOMUXSW_INPUT_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x7AC,
+	/*!< input select register */
+	IOMUXSW_INPUT_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x9F4,
+	/*!< last input select register */
+};
+
+#define MUX_PIN_NUM_MAX		\
+		(((IOMUXSW_PAD_END - IOMUXSW_PAD_CTL) >> 2) + 1)
+#define MUX_INPUT_NUM_MUX	\
+		(((IOMUXSW_INPUT_END - IOMUXSW_INPUT_CTL) >> 2) + 1)
+
+#define PIN_TO_IOMUX_INDEX(pin) ((PIN_TO_IOMUX_PAD(pin) - 0x328) >> 2)
+
+static DEFINE_SPINLOCK(gpio_mux_lock);
+static u8 iomux_pin_res_table[MUX_PIN_NUM_MAX];
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ * FIXED ME: for backward compatible. Will be static function!
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  cfg		an output function as defined in \b #iomux_pin_cfg_t
+ *
+ * @return 		0 if successful; Non-zero otherwise
+ */
+static int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
+{
+	u32 ret = 0;
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	u32 mux_reg = PIN_TO_IOMUX_MUX(pin);
+	u8 *rp;
+
+	BUG_ON(pin_index > MUX_PIN_NUM_MAX);
+	if (mux_reg != NON_MUX_I) {
+		mux_reg += IOMUXGPR;
+		BUG_ON((mux_reg > IOMUXSW_MUX_END)
+		       || (mux_reg < IOMUXSW_MUX_CTL));
+		spin_lock(&gpio_mux_lock);
+		__raw_writel(cfg, mux_reg);
+		/*
+		 * Log a warning if a pin changes ownership
+		 */
+		rp = iomux_pin_res_table + pin_index;
+		if ((cfg & *rp) && (*rp != cfg)) {
+			/*Console: how to do */
+			printk(KERN_ERR "iomux_config_mux: Warning: iomux pin"
+			       " config changed, index=%d register=%d, "
+			       " prev=0x%x new=0x%x\n", pin_index, mux_reg,
+			       *rp, cfg);
+			ret = -EINVAL;
+		}
+		*rp = cfg;
+		spin_unlock(&gpio_mux_lock);
+	}
+
+	return ret;
+}
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
+{
+	int ret = iomux_config_mux(pin, cfg);
+	if (GPIO_TO_PORT(IOMUX_TO_GPIO(pin)) < GPIO_PORT_NUM) {
+		if (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_GPIO) ||
+		    (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_FUNC) &&
+		     ((pin == MX35_PIN_GPIO1_0) || (pin == MX35_PIN_GPIO1_1) ||
+		      (pin == MX35_PIN_GPIO2_0) || (pin == MX35_PIN_GPIO3_0))))
+			ret |= mxc_request_gpio(pin);
+	}
+	return ret;
+}
+
+EXPORT_SYMBOL(mxc_request_iomux);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
+{
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	u8 *rp = iomux_pin_res_table + pin_index;
+
+	BUG_ON((pin_index > MUX_PIN_NUM_MAX));
+
+	*rp = 0;
+	if (GPIO_TO_PORT(IOMUX_TO_GPIO(pin)) < GPIO_PORT_NUM) {
+		if (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_GPIO) ||
+		    (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_FUNC) &&
+		     ((pin == MX35_PIN_GPIO1_0) || (pin == MX35_PIN_GPIO1_1) ||
+		      (pin == MX35_PIN_GPIO2_0) || (pin == MX35_PIN_GPIO3_0))))
+			mxc_free_gpio(pin);
+	}
+}
+
+EXPORT_SYMBOL(mxc_free_iomux);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin     a pin number as defined in \b #iomux_pin_name_t
+ * @param  config  the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
+{
+	u32 pad_reg = IOMUXGPR + PIN_TO_IOMUX_PAD(pin);
+
+	BUG_ON((pad_reg > IOMUXSW_PAD_END) || (pad_reg < IOMUXSW_PAD_CTL));
+
+	spin_lock(&gpio_mux_lock);
+	__raw_writel(config, pad_reg);
+	spin_unlock(&gpio_mux_lock);
+}
+
+EXPORT_SYMBOL(mxc_iomux_set_pad);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en)
+{
+	u32 l;
+
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(IOMUXGPR);
+
+	if (en)
+		l |= gp;
+	else
+		l &= ~gp;
+
+	__raw_writel(l, IOMUXGPR);
+	spin_unlock(&gpio_mux_lock);
+}
+
+EXPORT_SYMBOL(mxc_iomux_set_gpr);
+
+/*!
+ * This function configures input path.
+ *
+ * @param input index of input select register as defined in \b
+ *  			#iomux_input_select_t
+ * @param config the binary value of elements defined in \b
+ * 			#iomux_input_config_t
+ */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config)
+{
+	u32 reg = IOMUXSW_INPUT_CTL + (input << 2);
+
+	BUG_ON(input >= MUX_INPUT_NUM_MUX);
+
+	spin_lock(&gpio_mux_lock);
+	__raw_writel(config, reg);
+	spin_unlock(&gpio_mux_lock);
+}
+
+EXPORT_SYMBOL(mxc_iomux_set_input);
diff --git a/arch/arm/mach-mx35/iomux.h b/arch/arm/mach-mx35/iomux.h
new file mode 100644
index 0000000..41918bc
--- /dev/null
+++ b/arch/arm/mach-mx35/iomux.h
@@ -0,0 +1,290 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MACH_MX35_IOMUX_H__
+#define __MACH_MX35_IOMUX_H__
+
+#include <linux/types.h>
+
+/*!
+ * @file mach-mx35/iomux.h
+ *
+ * @brief I/O Muxing control definitions and functions
+ *
+ * @ingroup GPIO_MX35
+ */
+
+/*!
+ * various IOMUX functions
+ */
+typedef enum iomux_pin_config {
+	MUX_CONFIG_FUNC = 0,	/*!< used as function */
+	MUX_CONFIG_ALT1,	/*!< used as alternate function 1 */
+	MUX_CONFIG_ALT2,	/*!< used as alternate function 2 */
+	MUX_CONFIG_ALT3,	/*!< used as alternate function 3 */
+	MUX_CONFIG_ALT4,	/*!< used as alternate function 4 */
+	MUX_CONFIG_ALT5,	/*!< used as alternate function 5 */
+	MUX_CONFIG_ALT6,	/*!< used as alternate function 6 */
+	MUX_CONFIG_ALT7,	/*!< used as alternate function 7 */
+	MUX_CONFIG_SION = 0x1 << 4,	/*!< used as LOOPBACK:MUX SION bit */
+	MUX_CONFIG_GPIO = MUX_CONFIG_ALT5,	/*!< used as GPIO */
+} iomux_pin_cfg_t;
+
+/*!
+ * various IOMUX pad functions
+ */
+typedef enum iomux_pad_config {
+	PAD_CTL_DRV_3_3V = 0x0 << 13,
+	PAD_CTL_DRV_1_8V = 0x1 << 13,
+	PAD_CTL_HYS_CMOS = 0x0 << 8,
+	PAD_CTL_HYS_SCHMITZ = 0x1 << 8,
+	PAD_CTL_PKE_NONE = 0x0 << 7,
+	PAD_CTL_PKE_ENABLE = 0x1 << 7,
+	PAD_CTL_PUE_KEEPER = 0x0 << 6,
+	PAD_CTL_PUE_PUD = 0x1 << 6,
+	PAD_CTL_100K_PD = 0x0 << 4,
+	PAD_CTL_47K_PU = 0x1 << 4,
+	PAD_CTL_100K_PU = 0x2 << 4,
+	PAD_CTL_22K_PU = 0x3 << 4,
+	PAD_CTL_ODE_CMOS = 0x0 << 3,
+	PAD_CTL_ODE_OpenDrain = 0x1 << 3,
+	PAD_CTL_DRV_NORMAL = 0x0 << 1,
+	PAD_CTL_DRV_HIGH = 0x1 << 1,
+	PAD_CTL_DRV_MAX = 0x2 << 1,
+	PAD_CTL_SRE_SLOW = 0x0 << 0,
+	PAD_CTL_SRE_FAST = 0x1 << 0
+} iomux_pad_config_t;
+
+/*!
+ * various IOMUX general purpose functions
+ */
+typedef enum iomux_gp_func {
+	MUX_SDCTL_CSD0_SEL = 0x1 << 0,
+	MUX_SDCTL_CSD1_SEL = 0x1 << 1,
+	MUX_TAMPER_DETECT_EN = 0x1 << 2,
+} iomux_gp_func_t;
+
+/*!
+ * various IOMUX input select register index
+ */
+typedef enum iomux_input_select {
+	MUX_IN_AMX_P5_RXCLK = 0,
+	MUX_IN_AMX_P5_RXFS,
+	MUX_IN_AMX_P6_DA,
+	MUX_IN_AMX_P6_DB,
+	MUX_IN_AMX_P6_RXCLK,
+	MUX_IN_AMX_P6_RXFS,
+	MUX_IN_AMX_P6_TXCLK,
+	MUX_IN_AMX_P6_TXFS,
+	MUX_IN_CAN1_CANRX,
+	MUX_IN_CAN2_CANRX,
+	MUX_IN_CCM_32K_MUXED,
+	MUX_IN_CCM_PMIC_RDY,
+	MUX_IN_CSPI1_SS2_B,
+	MUX_IN_CSPI1_SS3_B,
+	MUX_IN_CSPI2_CLK_IN,
+	MUX_IN_CSPI2_DATAREADY_B,
+	MUX_IN_CSPI2_MISO,
+	MUX_IN_CSPI2_MOSI,
+	MUX_IN_CSPI2_SS0_B,
+	MUX_IN_CSPI2_SS1_B,
+	MUX_IN_CSPI2_SS2_B,
+	MUX_IN_CSPI2_SS3_B,
+	MUX_IN_EMI_WEIM_DTACK_B,
+	MUX_IN_ESDHC1_DAT4_IN,
+	MUX_IN_ESDHC1_DAT5_IN,
+	MUX_IN_ESDHC1_DAT6_IN,
+	MUX_IN_ESDHC1_DAT7_IN,
+	MUX_IN_ESDHC3_CARD_CLK_IN,
+	MUX_IN_ESDHC3_CMD_IN,
+	MUX_IN_ESDHC3_DAT0,
+	MUX_IN_ESDHC3_DAT1,
+	MUX_IN_ESDHC3_DAT2,
+	MUX_IN_ESDHC3_DAT3,
+	MUX_IN_GPIO1_IN_0,
+	MUX_IN_GPIO1_IN_10,
+	MUX_IN_GPIO1_IN_11,
+	MUX_IN_GPIO1_IN_1,
+	MUX_IN_GPIO1_IN_20,
+	MUX_IN_GPIO1_IN_21,
+	MUX_IN_GPIO1_IN_22,
+	MUX_IN_GPIO1_IN_2,
+	MUX_IN_GPIO1_IN_3,
+	MUX_IN_GPIO1_IN_4,
+	MUX_IN_GPIO1_IN_5,
+	MUX_IN_GPIO1_IN_6,
+	MUX_IN_GPIO1_IN_7,
+	MUX_IN_GPIO1_IN_8,
+	MUX_IN_GPIO1_IN_9,
+	MUX_IN_GPIO2_IN_0,
+	MUX_IN_GPIO2_IN_10,
+	MUX_IN_GPIO2_IN_11,
+	MUX_IN_GPIO2_IN_12,
+	MUX_IN_GPIO2_IN_13,
+	MUX_IN_GPIO2_IN_14,
+	MUX_IN_GPIO2_IN_15,
+	MUX_IN_GPIO2_IN_16,
+	MUX_IN_GPIO2_IN_17,
+	MUX_IN_GPIO2_IN_18,
+	MUX_IN_GPIO2_IN_19,
+	MUX_IN_GPIO2_IN_20,
+	MUX_IN_GPIO2_IN_21,
+	MUX_IN_GPIO2_IN_22,
+	MUX_IN_GPIO2_IN_23,
+	MUX_IN_GPIO2_IN_24,
+	MUX_IN_GPIO2_IN_25,
+	MUX_IN_GPIO2_IN_26,
+	MUX_IN_GPIO2_IN_27,
+	MUX_IN_GPIO2_IN_28,
+	MUX_IN_GPIO2_IN_29,
+	MUX_IN_GPIO2_IN_2,
+	MUX_IN_GPIO2_IN_30,
+	MUX_IN_GPIO2_IN_31,
+	MUX_IN_GPIO2_IN_3,
+	MUX_IN_GPIO2_IN_4,
+	MUX_IN_GPIO2_IN_5,
+	MUX_IN_GPIO2_IN_6,
+	MUX_IN_GPIO2_IN_7,
+	MUX_IN_GPIO2_IN_8,
+	MUX_IN_GPIO2_IN_9,
+	MUX_IN_GPIO3_IN_0,
+	MUX_IN_GPIO3_IN_10,
+	MUX_IN_GPIO3_IN_11,
+	MUX_IN_GPIO3_IN_12,
+	MUX_IN_GPIO3_IN_13,
+	MUX_IN_GPIO3_IN_14,
+	MUX_IN_GPIO3_IN_15,
+	MUX_IN_GPIO3_IN_4,
+	MUX_IN_GPIO3_IN_5,
+	MUX_IN_GPIO3_IN_6,
+	MUX_IN_GPIO3_IN_7,
+	MUX_IN_GPIO3_IN_8,
+	MUX_IN_GPIO3_IN_9,
+	MUX_IN_I2C3_SCL_IN,
+	MUX_IN_I2C3_SDA_IN,
+	MUX_IN_IPU_DISPB_D0_VSYNC,
+	MUX_IN_IPU_DISPB_D12_VSYNC,
+	MUX_IN_IPU_DISPB_SD_D,
+	MUX_IN_IPU_SENSB_DATA_0,
+	MUX_IN_IPU_SENSB_DATA_1,
+	MUX_IN_IPU_SENSB_DATA_2,
+	MUX_IN_IPU_SENSB_DATA_3,
+	MUX_IN_IPU_SENSB_DATA_4,
+	MUX_IN_IPU_SENSB_DATA_5,
+	MUX_IN_IPU_SENSB_DATA_6,
+	MUX_IN_IPU_SENSB_DATA_7,
+	MUX_IN_KPP_COL_0,
+	MUX_IN_KPP_COL_1,
+	MUX_IN_KPP_COL_2,
+	MUX_IN_KPP_COL_3,
+	MUX_IN_KPP_COL_4,
+	MUX_IN_KPP_COL_5,
+	MUX_IN_KPP_COL_6,
+	MUX_IN_KPP_COL_7,
+	MUX_IN_KPP_ROW_0,
+	MUX_IN_KPP_ROW_1,
+	MUX_IN_KPP_ROW_2,
+	MUX_IN_KPP_ROW_3,
+	MUX_IN_KPP_ROW_4,
+	MUX_IN_KPP_ROW_5,
+	MUX_IN_KPP_ROW_6,
+	MUX_IN_KPP_ROW_7,
+	MUX_IN_OWIRE_BATTERY_LINE,
+	MUX_IN_SPDIF_HCKT_CLK2,
+	MUX_IN_SPDIF_SPDIF_IN1,
+	MUX_IN_UART3_UART_RTS_B,
+	MUX_IN_UART3_UART_RXD_MUX,
+	MUX_IN_USB_OTG_DATA_0,
+	MUX_IN_USB_OTG_DATA_1,
+	MUX_IN_USB_OTG_DATA_2,
+	MUX_IN_USB_OTG_DATA_3,
+	MUX_IN_USB_OTG_DATA_4,
+	MUX_IN_USB_OTG_DATA_5,
+	MUX_IN_USB_OTG_DATA_6,
+	MUX_IN_USB_OTG_DATA_7,
+	MUX_IN_USB_OTG_DIR,
+	MUX_IN_USB_OTG_NXT,
+	MUX_IN_USB_UH2_DATA_0,
+	MUX_IN_USB_UH2_DATA_1,
+	MUX_IN_USB_UH2_DATA_2,
+	MUX_IN_USB_UH2_DATA_3,
+	MUX_IN_USB_UH2_DATA_4,
+	MUX_IN_USB_UH2_DATA_5,
+	MUX_IN_USB_UH2_DATA_6,
+	MUX_IN_USB_UH2_DATA_7,
+	MUX_IN_USB_UH2_DIR,
+	MUX_IN_USB_UH2_NXT,
+	MUX_IN_USB_UH2_USB_OC,
+} iomux_input_select_t;
+
+/*!
+ * various IOMUX input functions
+ */
+typedef enum iomux_input_config {
+	INPUT_CTL_PATH0 = 0x0,
+	INPUT_CTL_PATH1,
+	INPUT_CTL_PATH2,
+	INPUT_CTL_PATH3,
+	INPUT_CTL_PATH4,
+	INPUT_CTL_PATH5,
+	INPUT_CTL_PATH6,
+	INPUT_CTL_PATH7,
+} iomux_input_cfg_t;
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b
+ *				#iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config);
+
+/*!
+ * This function configures input path.
+ *
+ * @param  input        index of input select register as defined in \b
+ * 				#iomux_input_select_t
+ * @param  config       the binary value of elements defined in \b
+ *				#iomux_input_cfg_t
+ */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config);
+#endif
diff --git a/arch/arm/mach-mx35/mm.c b/arch/arm/mach-mx35/mm.c
new file mode 100644
index 0000000..1a5fbc9
--- /dev/null
+++ b/arch/arm/mach-mx35/mm.c
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <asm/hardware.h>
+#include <asm/pgtable.h>
+#include <asm/mach/map.h>
+
+/*!
+ * @file mach-mx35/mm.c
+ *
+ * @brief This file creates static mapping between physical to virtual memory.
+ *
+ * @ingroup Memory_MX35
+ */
+
+/*!
+ * This structure defines the MX35 memory map.
+ */
+static struct map_desc mxc_io_desc[] __initdata = {
+	{
+	 .virtual = IRAM_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(IRAM_BASE_ADDR),
+	 .length = IRAM_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = X_MEMC_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(X_MEMC_BASE_ADDR),
+	 .length = X_MEMC_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = NFC_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(NFC_BASE_ADDR),
+	 .length = NFC_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = ROMP_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(ROMP_BASE_ADDR),
+	 .length = ROMP_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = AVIC_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AVIC_BASE_ADDR),
+	 .length = AVIC_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = AIPS1_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPS1_BASE_ADDR),
+	 .length = AIPS1_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = SPBA0_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(SPBA0_BASE_ADDR),
+	 .length = SPBA0_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = AIPS2_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPS2_BASE_ADDR),
+	 .length = AIPS2_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+};
+
+/*!
+ * This function initializes the memory map. It is called during the
+ * system startup to create static physical to virtual memory map for
+ * the IO modules.
+ */
+void __init mxc_map_io(void)
+{
+	iotable_init(mxc_io_desc, ARRAY_SIZE(mxc_io_desc));
+}
diff --git a/arch/arm/mach-mx35/mx35_3stack.c b/arch/arm/mach-mx35/mx35_3stack.c
new file mode 100644
index 0000000..7c9c61f
--- /dev/null
+++ b/arch/arm/mach-mx35/mx35_3stack.c
@@ -0,0 +1,405 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/flash.h>
+#endif
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/memory.h>
+#include <asm/arch/gpio.h>
+
+#include "board-mx35_3stack.h"
+#include "crm_regs.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx35/mx35_3stack.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX35
+ */
+
+unsigned int mx35_3stack_board_io;
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+/* MTD NOR flash */
+
+#if defined(CONFIG_MTD_MXC) || defined(CONFIG_MTD_MXC_MODULE)
+
+static struct mtd_partition mxc_nor_partitions[] = {
+	{
+	 .name = "Bootloader",
+	 .size = 512 * 1024,
+	 .offset = 0x00000000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+	{
+	 .name = "nor.Kernel",
+	 .size = 4 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0},
+	{
+	 .name = "nor.userfs",
+	 .size = 30 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0},
+	{
+	 .name = "nor.rootfs",
+	 .size = 28 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = MTD_WRITEABLE},
+	{
+	 .name = "FIS directory",
+	 .size = 12 * 1024,
+	 .offset = 0x01FE0000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+	{
+	 .name = "Redboot config",
+	 .size = MTDPART_SIZ_FULL,
+	 .offset = 0x01FFF000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+};
+
+static struct flash_platform_data mxc_flash_data = {
+	.map_name = "cfi_probe",
+	.width = 2,
+	.parts = mxc_nor_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nor_partitions),
+};
+
+static struct resource mxc_flash_resource = {
+	.start = 0xa0000000,
+	.end = 0xa0000000 + 0x04000000 - 1,
+	.flags = IORESOURCE_MEM,
+
+};
+
+static struct platform_device mxc_nor_mtd_device = {
+	.name = "mxc_nor_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_flash_data,
+		},
+	.num_resources = 1,
+	.resource = &mxc_flash_resource,
+};
+
+static void mxc_init_nor_mtd(void)
+{
+	(void)platform_device_register(&mxc_nor_mtd_device);
+}
+#else
+static void mxc_init_nor_mtd(void)
+{
+}
+#endif
+
+/* MTD NAND flash */
+
+#if defined(CONFIG_MTD_NAND_MXC) || defined(CONFIG_MTD_NAND_MXC_MODULE)
+
+static struct mtd_partition mxc_nand_partitions[] = {
+	{
+	 .name = "IPL-SPL",
+	 .offset = 0,
+	 .size = 256 * 1024},
+	{
+	 .name = "nand.kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 4 * 1024 * 1024},
+	{
+	 .name = "nand.rootfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 96 * 1024 * 1024},
+	{
+	 .name = "nand.configure",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 8 * 1024 * 1024},
+	{
+	 .name = "nand.userfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL},
+};
+
+static struct flash_platform_data mxc_nand_data = {
+	.parts = mxc_nand_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nand_partitions),
+	.width = 1,
+};
+
+static struct platform_device mxc_nand_mtd_device = {
+	.name = "mxc_nand_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_nand_data,
+		},
+};
+
+static void mxc_init_nand_mtd(void)
+{
+	if (__raw_readl(MXC_CCM_RCSR) & MXC_CCM_RCSR_NF16B)
+		mxc_nand_data.width = 2;
+
+	platform_device_register(&mxc_nand_mtd_device);
+}
+#else
+static inline void mxc_init_nand_mtd(void)
+{
+}
+#endif
+
+static struct i2c_board_info mxc_i2c_board_info[] __initdata = {
+	{
+	 .driver_name = "mc9sdz60",
+	 .addr = 0x69,
+	 },
+	{
+	 .driver_name = "max8660",
+	 .addr = 0x34,
+	 },
+};
+
+#if  defined(CONFIG_SMSC911X) || defined(CONFIG_SMSC911X_MODULE)
+static struct resource smsc911x_resources[] = {
+	{
+	 .start = LAN9217_BASE_ADDR,
+	 .end = LAN9217_BASE_ADDR + 0x100,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = LAN9217_IRQ,
+	 .end = LAN9217_IRQ,
+	 .flags = IORESOURCE_IRQ,
+	 }
+};
+
+static struct platform_device mxc_smsc911x_device = {
+	.name = "smsc911x",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(smsc911x_resources),
+	.resource = smsc911x_resources,
+};
+
+static void mxc_init_enet(void)
+{
+	platform_device_register(&mxc_smsc911x_device);
+}
+#else
+static inline void mxc_init_enet(void)
+{
+}
+#endif
+
+#if defined(CONFIG_FEC) || defined(CONFIG_FEC_MODULE)
+unsigned int expio_intr_fec;
+
+EXPORT_SYMBOL(expio_intr_fec);
+#endif
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	mxc_cpu_init();
+
+#ifdef CONFIG_DISCONTIGMEM
+	do {
+		int nid;
+		mi->nr_banks = MXC_NUMNODES;
+		for (nid = 0; nid < mi->nr_banks; nid++)
+			SET_NODE(mi, nid);
+	} while (0);
+#endif
+}
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	mxc_cpu_common_init();
+
+	mxc_clocks_init();
+	early_console_setup(saved_command_line);
+	mxc_gpio_init();
+	mx35_3stack_gpio_init();
+	mxc_init_enet();
+	mxc_init_nor_mtd();
+	mxc_init_nand_mtd();
+
+	i2c_register_board_info(0, mxc_i2c_board_info,
+				ARRAY_SIZE(mxc_i2c_board_info));
+}
+
+#define PLL_PCTL_REG(brmo, pd, mfd, mfi, mfn)		\
+		(((brmo) << 31) + (((pd) - 1) << 26) + (((mfd) - 1) << 16) + \
+		((mfi)  << 10) + mfn)
+
+/* For 24MHz input clock */
+#define PLL_665MHZ		PLL_PCTL_REG(1, 1, 48, 13, 41)
+#define PLL_532MHZ		PLL_PCTL_REG(1, 1, 12, 11, 1)
+#define PLL_399MHZ		PLL_PCTL_REG(0, 1, 16, 8, 5)
+
+/* working point(wp): 0,1 - 133MHz; 2,3 - 266MHz; 4,5 - 399MHz;*/
+/* auto input clock table */
+static struct cpu_wp cpu_wp_auto[] = {
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 133000000,
+	 .pdr0_reg = (0x2 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 133000000,
+	 .pdr0_reg = (0x6 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 266000000,
+	 .pdr0_reg = (0x1 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 266000000,
+	 .pdr0_reg = (0x5 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 399000000,
+	 .pdr0_reg = (0x0 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 399000000,
+	 .pdr0_reg = (0x6 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+};
+
+/* consumer input clock table */
+static struct cpu_wp cpu_wp_con[] = {
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 133000000,
+	 .pdr0_reg = (0x6 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 133000000,
+	 .pdr0_reg = (0xE << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 266000000,
+	 .pdr0_reg = (0x2 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 266000000,
+	 .pdr0_reg = (0xA << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 399000000,
+	 .pdr0_reg = (0x1 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 399000000,
+	 .pdr0_reg = (0x9 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 532000000,
+	 .pdr0_reg = (0x0 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 532000000,
+	 .pdr0_reg = (0x8 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_665MHZ,
+	 .pll_rate = 665000000,
+	 .cpu_rate = 665000000,
+	 .pdr0_reg = (0x7 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+};
+
+struct cpu_wp *get_cpu_wp(int *wp)
+{
+	if (__raw_readl(MXC_CCM_PDR0) & MXC_CCM_PDR0_AUTO_CON) {
+		*wp = 9;
+		return cpu_wp_con;
+	} else {
+		*wp = 6;
+		return cpu_wp_auto;
+	}
+}
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX35_3DS data structure.
+ */
+/* *INDENT-OFF* */
+MACHINE_START(MX35_3DS, "Freescale MX35 3-Stack Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.phys_io = AIPS1_BASE_ADDR,
+	.io_pg_offst = ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params = PHYS_OFFSET + 0x100,
+	.fixup = fixup_mxc_board,
+	.map_io = mxc_map_io,
+	.init_irq = mxc_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx35/mx35_3stack_cpld.c b/arch/arm/mach-mx35/mx35_3stack_cpld.c
new file mode 100644
index 0000000..2ecf128
--- /dev/null
+++ b/arch/arm/mach-mx35/mx35_3stack_cpld.c
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/gpio.h>
+
+#include "board-mx35_3stack.h"
+#include "crm_regs.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx35/mx35_3stack_cpld.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX35
+ */
+static void mxc_expio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 expio_irq;
+	u32 index, mask;
+	desc->chip->mask(irq);	/* irq = gpio irq number */
+
+	index = __raw_readw(mx35_3stack_board_io + INTR_STATUS_REG);
+	mask = __raw_readw(mx35_3stack_board_io + INTR_MASK_REG);
+
+	if (unlikely(!(index & (~mask)))) {
+		printk(KERN_ERR "\nEXPIO: Spurious interrupt:0x%0x\n\n", index);
+		pr_info("CPLD IMR(0x38)=0x%x, PENDING(0x28)=0x%x\n", mask,
+			index);
+		goto out;
+	}
+	index = index & (~mask);
+	expio_irq = MXC_EXP_IO_BASE;
+	for (; index != 0; index >>= 1, expio_irq++) {
+		struct irq_desc *d;
+		if ((index & 1) == 0)
+			continue;
+		d = irq_desc + expio_irq;
+		if (unlikely(!(d->handle_irq))) {
+			printk(KERN_ERR "\nEXPIO irq: %d unhandeled\n",
+			       expio_irq);
+			BUG();	/* oops */
+		}
+		d->handle_irq(expio_irq, d);
+	}
+
+      out:
+	desc->chip->ack(irq);
+	desc->chip->unmask(irq);
+}
+
+/*
+ * Disable an expio pin's interrupt by setting the bit in the imr.
+ * @param irq           an expio virtual irq number
+ */
+static void expio_mask_irq(u32 irq)
+{
+	u16 reg, expio = MXC_IRQ_TO_EXPIO(irq);
+
+	reg = __raw_readw(mx35_3stack_board_io + INTR_MASK_REG);
+	/* mask the interrupt */
+	__raw_writew(reg | (1 << expio), mx35_3stack_board_io + INTR_MASK_REG);
+}
+
+/*
+ * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
+ * @param irq           an expanded io virtual irq number
+ */
+static void expio_ack_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* clear the interrupt status */
+	__raw_writew(1 << expio, mx35_3stack_board_io + INTR_RESET_REG);
+	__raw_writew(0, mx35_3stack_board_io + INTR_RESET_REG);
+	/* mask the interrupt */
+	expio_mask_irq(irq);
+}
+
+/*
+ * Enable a expio pin's interrupt by clearing the bit in the imr.
+ * @param irq           a expio virtual irq number
+ */
+static void expio_unmask_irq(u32 irq)
+{
+	u16 reg, expio = MXC_IRQ_TO_EXPIO(irq);
+
+	reg = __raw_readw(mx35_3stack_board_io + INTR_MASK_REG);
+	/* unmask the interrupt */
+	__raw_writew(reg & (~(1 << expio)),
+		     mx35_3stack_board_io + INTR_MASK_REG);
+}
+
+static struct irq_chip expio_irq_chip = {
+	.ack = expio_ack_irq,
+	.mask = expio_mask_irq,
+	.unmask = expio_unmask_irq,
+};
+
+static int __init mxc_expio_init(void)
+{
+	int i;
+
+	mx35_3stack_board_io = (u32) ioremap(BOARD_IO_ADDR, SZ_4K);
+	if (mx35_3stack_board_io == 0)
+		return -ENOMEM;
+
+	if ((__raw_readw(mx35_3stack_board_io + MAGIC_NUMBER1_REG) != 0xAAAA) ||
+	    (__raw_readw(mx35_3stack_board_io + MAGIC_NUMBER2_REG) != 0x5555))
+		return -ENODEV;
+
+	pr_info("3-Stack Debug board detected, rev = 0x%04X\n",
+		readw(mx35_3stack_board_io + CPLD_CODE_VER_REG));
+
+	/*
+	 * Configure INT line as GPIO input
+	 */
+	mxc_request_iomux(EXPIO_PARENT_INT, MUX_CONFIG_FUNC);
+	mxc_set_gpio_direction(EXPIO_PARENT_INT, 1);
+
+	/* disable the interrupt and clear the status */
+	__raw_writew(0, mx35_3stack_board_io + INTR_MASK_REG);
+	__raw_writew(0xFFFF, mx35_3stack_board_io + INTR_RESET_REG);
+	__raw_writew(0, mx35_3stack_board_io + INTR_RESET_REG);
+	__raw_writew(0x1F, mx35_3stack_board_io + INTR_MASK_REG);
+	for (i = MXC_EXP_IO_BASE; i < (MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES);
+	     i++) {
+		set_irq_chip(i, &expio_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_type(IOMUX_TO_IRQ(EXPIO_PARENT_INT), IRQT_LOW);
+	set_irq_chained_handler(IOMUX_TO_IRQ(EXPIO_PARENT_INT),
+				mxc_expio_irq_handler);
+	return 0;
+}
+
+arch_initcall(mxc_expio_init);
diff --git a/arch/arm/mach-mx35/mx35_3stack_gpio.c b/arch/arm/mach-mx35/mx35_3stack_gpio.c
new file mode 100644
index 0000000..08c2c3f
--- /dev/null
+++ b/arch/arm/mach-mx35/mx35_3stack_gpio.c
@@ -0,0 +1,228 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/gpio.h>
+#include "board-mx35_3stack.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx35/mx35_3stack_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO_MX35
+ */
+
+/*!
+ * This system-wise GPIO function initializes the pins during system startup.
+ * All the statically linked device drivers should put the proper GPIO
+ * initialization code inside this function. It is called by \b fixup_mx31ads()
+ * during system startup. This function is board specific.
+ */
+void mx35_3stack_gpio_init(void)
+{
+	/* config CS5 */
+	mxc_request_iomux(MX35_PIN_CS5, MUX_CONFIG_FUNC);
+
+}
+
+/*!
+ * Setup GPIO for a UART port to be active
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_active(int port, int no_irda)
+{
+	/*
+	 * Configure the IOMUX control registers for the UART signals
+	 */
+	switch (port) {
+		/* UART 1 IOMUX Configs */
+	case 0:
+		mxc_request_iomux(MX35_PIN_RXD1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_TXD1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_RTS1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_CTS1, MUX_CONFIG_FUNC);
+
+		mxc_iomux_set_pad(MX35_PIN_RXD1,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX35_PIN_TXD1,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		mxc_iomux_set_pad(MX35_PIN_RTS1,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX35_PIN_CTS1,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+
+		break;
+		/* UART 2 IOMUX Configs */
+	case 1:
+		mxc_request_iomux(MX35_PIN_TXD2, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_RXD2, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_RTS2, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_CTS2, MUX_CONFIG_FUNC);
+		mxc_iomux_set_pad(MX35_PIN_RXD2,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX35_PIN_TXD2,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		mxc_iomux_set_pad(MX35_PIN_RTS2,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX35_PIN_CTS2,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		break;
+		/* UART 3 IOMUX Configs */
+	case 2:
+		mxc_request_iomux(MX35_PIN_FEC_TX_CLK, MUX_CONFIG_ALT2);
+		mxc_request_iomux(MX35_PIN_FEC_RX_CLK, MUX_CONFIG_ALT2);
+		mxc_request_iomux(MX35_PIN_FEC_COL, MUX_CONFIG_ALT2);
+		mxc_request_iomux(MX35_PIN_FEC_RX_DV, MUX_CONFIG_ALT2);
+
+		mxc_iomux_set_input(MUX_IN_UART3_UART_RTS_B, INPUT_CTL_PATH2);
+		mxc_iomux_set_input(MUX_IN_UART3_UART_RXD_MUX, INPUT_CTL_PATH3);
+		break;
+	default:
+		break;
+	}
+
+}
+
+EXPORT_SYMBOL(gpio_uart_active);
+
+/*!
+ * Setup GPIO for a UART port to be inactive
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_inactive(int port, int no_irda)
+{
+	switch (port) {
+	case 0:
+		mxc_request_gpio(MX35_PIN_RXD1);
+		mxc_request_gpio(MX35_PIN_TXD1);
+		mxc_request_gpio(MX35_PIN_RTS1);
+		mxc_request_gpio(MX35_PIN_CTS1);
+
+		mxc_free_iomux(MX35_PIN_RXD1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_TXD1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_RTS1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_CTS1, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		mxc_request_gpio(MX35_PIN_RXD2);
+		mxc_request_gpio(MX35_PIN_TXD2);
+		mxc_request_gpio(MX35_PIN_RTS2);
+		mxc_request_gpio(MX35_PIN_CTS2);
+
+		mxc_free_iomux(MX35_PIN_RXD2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_TXD2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_RTS2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_CTS2, MUX_CONFIG_GPIO);
+		break;
+	case 2:
+		mxc_request_gpio(MX35_PIN_FEC_TX_CLK);
+		mxc_request_gpio(MX35_PIN_FEC_RX_CLK);
+		mxc_request_gpio(MX35_PIN_FEC_COL);
+		mxc_request_gpio(MX35_PIN_FEC_RX_DV);
+
+		mxc_free_iomux(MX35_PIN_FEC_TX_CLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_FEC_RX_CLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_FEC_COL, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_FEC_RX_DV, MUX_CONFIG_GPIO);
+
+		mxc_iomux_set_input(MUX_IN_UART3_UART_RTS_B, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_UART3_UART_RXD_MUX, INPUT_CTL_PATH0);
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_uart_inactive);
+
+/*!
+ * Configure the IOMUX GPR register to receive shared SDMA UART events
+ *
+ * @param  port         a UART port
+ */
+void config_uartdma_event(int port)
+{
+}
+
+EXPORT_SYMBOL(config_uartdma_event);
+
+void gpio_fec_active(void)
+{
+
+}
+
+EXPORT_SYMBOL(gpio_fec_active);
+
+void gpio_fec_inactive(void)
+{
+
+}
+
+EXPORT_SYMBOL(gpio_fec_inactive);
+
+/*!
+ * Setup GPIO for an I2C device to be active
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_active(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		mxc_request_iomux(MX35_PIN_I2C1_CLK, MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_I2C1_DAT, MUX_CONFIG_SION);
+
+		mxc_iomux_set_pad(MX35_PIN_I2C1_CLK, 0x1e8);
+		mxc_iomux_set_pad(MX35_PIN_I2C1_DAT, 0x1e8);
+		break;
+	case 1:
+		mxc_request_iomux(MX35_PIN_I2C2_CLK, MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_I2C2_DAT, MUX_CONFIG_SION);
+
+		mxc_iomux_set_pad(MX35_PIN_I2C2_CLK, 0x1e8);
+		mxc_iomux_set_pad(MX35_PIN_I2C2_DAT, 0x1e8);
+
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_i2c_active);
+
+/*!
+ * Setup GPIO for an I2C device to be inactive
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_inactive(int i2c_num)
+{
+	/*TODO:complete inactive function */
+}
+
+EXPORT_SYMBOL(gpio_i2c_inactive);
diff --git a/arch/arm/mach-mx35/mx35evb.c b/arch/arm/mach-mx35/mx35evb.c
new file mode 100644
index 0000000..9cffbe7
--- /dev/null
+++ b/arch/arm/mach-mx35/mx35evb.c
@@ -0,0 +1,396 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
+#include <linux/platform_device.h>
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/flash.h>
+#endif
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/keypad.h>
+#include <asm/arch/memory.h>
+#include <asm/arch/gpio.h>
+
+#include "board-mx35evb.h"
+#include "crm_regs.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx35/mx35evb.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX35
+ */
+
+unsigned int mx35evb_board_io;
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+/* MTD NOR flash */
+
+#if defined(CONFIG_MTD_MXC) || defined(CONFIG_MTD_MXC_MODULE)
+
+static struct mtd_partition mxc_nor_partitions[] = {
+	{
+	 .name = "Bootloader",
+	 .size = 512 * 1024,
+	 .offset = 0x00000000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+	{
+	 .name = "nor.Kernel",
+	 .size = 4 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0},
+	{
+	 .name = "nor.userfs",
+	 .size = 30 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0},
+	{
+	 .name = "nor.rootfs",
+	 .size = 28 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = MTD_WRITEABLE},
+	{
+	 .name = "FIS directory",
+	 .size = 12 * 1024,
+	 .offset = 0x01FE0000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+	{
+	 .name = "Redboot config",
+	 .size = MTDPART_SIZ_FULL,
+	 .offset = 0x01FFF000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+};
+
+static struct flash_platform_data mxc_flash_data = {
+	.map_name = "cfi_probe",
+	.width = 2,
+	.parts = mxc_nor_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nor_partitions),
+};
+
+static struct resource mxc_flash_resource = {
+	.start = 0xa0000000,
+	.end = 0xa0000000 + 0x04000000 - 1,
+	.flags = IORESOURCE_MEM,
+
+};
+
+static struct platform_device mxc_nor_mtd_device = {
+	.name = "mxc_nor_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_flash_data,
+		},
+	.num_resources = 1,
+	.resource = &mxc_flash_resource,
+};
+
+static void mxc_init_nor_mtd(void)
+{
+	(void)platform_device_register(&mxc_nor_mtd_device);
+}
+#else
+static void mxc_init_nor_mtd(void)
+{
+}
+#endif
+
+/* MTD NAND flash */
+
+#if defined(CONFIG_MTD_NAND_MXC) || defined(CONFIG_MTD_NAND_MXC_MODULE)
+
+static struct mtd_partition mxc_nand_partitions[] = {
+	{
+	 .name = "IPL-SPL",
+	 .offset = 0,
+	 .size = 256 * 1024},
+	{
+	 .name = "nand.kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 4 * 1024 * 1024},
+	{
+	 .name = "nand.rootfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 96 * 1024 * 1024},
+	{
+	 .name = "nand.configure",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 8 * 1024 * 1024},
+	{
+	 .name = "nand.userfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL},
+};
+
+static struct flash_platform_data mxc_nand_data = {
+	.parts = mxc_nand_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nand_partitions),
+	.width = 1,
+};
+
+static struct platform_device mxc_nand_mtd_device = {
+	.name = "mxc_nand_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_nand_data,
+		},
+};
+
+static void mxc_init_nand_mtd(void)
+{
+	if (__raw_readl(MXC_CCM_RCSR) & MXC_CCM_RCSR_NF16B)
+		mxc_nand_data.width = 2;
+
+	platform_device_register(&mxc_nand_mtd_device);
+}
+#else
+static inline void mxc_init_nand_mtd(void)
+{
+}
+#endif
+
+#if  defined(CONFIG_SMSC911X) || defined(CONFIG_SMSC911X_MODULE)
+static struct resource smsc911x_resources[] = {
+	{
+	 .start = ENET_BASE_ADDRESS,
+	 .end = ENET_BASE_ADDRESS + 0x100,
+	 .flags = IORESOURCE_MEM,},
+	{
+	 .start = EXPIO_INT_ENET,
+	 .end = EXPIO_INT_ENET,
+	 .flags = IORESOURCE_IRQ,}
+};
+
+static struct platform_device mxc_smsc911x_device = {
+	.name = "smsc911x",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(smsc911x_resources),
+	.resource = smsc911x_resources,
+};
+
+static void mxc_init_enet(void)
+{
+	int i;
+	/*reset ext uart in cpld */
+	__raw_writew(PBC_BCTRL1_ENET_RST_B, PBC_BCTRL1_SET);
+	/*delay some time for reset finish */
+	for (i = 0; i < 10000; i++) ;
+	__raw_writew(PBC_BCTRL1_ENET_RST_B, PBC_BCTRL1_CLR);
+
+	platform_device_register(&mxc_smsc911x_device);
+}
+#else
+static inline void mxc_init_enet(void)
+{
+}
+#endif
+
+#if defined(CONFIG_FEC) || defined(CONFIG_FEC_MODULE)
+unsigned int expio_intr_fec;
+
+EXPORT_SYMBOL(expio_intr_fec);
+#endif
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	mxc_cpu_init();
+
+#ifdef CONFIG_DISCONTIGMEM
+	do {
+		int nid;
+		mi->nr_banks = MXC_NUMNODES;
+		for (nid = 0; nid < mi->nr_banks; nid++)
+			SET_NODE(mi, nid);
+	} while (0);
+#endif
+}
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	mxc_cpu_common_init();
+	mxc_clocks_init();
+	early_console_setup(saved_command_line);
+	mxc_gpio_init();
+	mx35evb_gpio_init();
+	mxc_init_enet();
+	mxc_init_nor_mtd();
+	mxc_init_nand_mtd();
+
+}
+
+#define PLL_PCTL_REG(brmo, pd, mfd, mfi, mfn)		\
+		(((brmo) << 31) + (((pd) - 1) << 26) + (((mfd) - 1) << 16) + \
+		((mfi)  << 10) + mfn)
+
+/* For 24MHz input clock */
+#define PLL_665MHZ		PLL_PCTL_REG(1, 1, 48, 13, 41)
+#define PLL_532MHZ		PLL_PCTL_REG(1, 1, 12, 11, 1)
+#define PLL_399MHZ		PLL_PCTL_REG(0, 1, 16, 8, 5)
+
+/* working point(wp): 0,1 - 133MHz; 2,3 - 266MHz; 4,5 - 399MHz;*/
+/* auto input clock table */
+static struct cpu_wp cpu_wp_auto[] = {
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 133000000,
+	 .pdr0_reg = (0x2 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 133000000,
+	 .pdr0_reg = (0x6 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 266000000,
+	 .pdr0_reg = (0x1 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 266000000,
+	 .pdr0_reg = (0x5 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 399000000,
+	 .pdr0_reg = (0x0 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 399000000,
+	 .pdr0_reg = (0x6 << MXC_CCM_PDR0_AUTO_MUX_DIV_OFFSET),},
+};
+
+/* consumer input clock table */
+static struct cpu_wp cpu_wp_con[] = {
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 133000000,
+	 .pdr0_reg = (0x6 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 133000000,
+	 .pdr0_reg = (0xE << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 266000000,
+	 .pdr0_reg = (0x2 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 266000000,
+	 .pdr0_reg = (0xA << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 399000000,
+	 .pdr0_reg = (0x1 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 399000000,
+	 .pdr0_reg = (0x9 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 532000000,
+	 .pdr0_reg = (0x0 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 532000000,
+	 .pdr0_reg = (0x8 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+	{
+	 .pll_reg = PLL_665MHZ,
+	 .pll_rate = 665000000,
+	 .cpu_rate = 665000000,
+	 .pdr0_reg = (0x7 << MXC_CCM_PDR0_CON_MUX_DIV_OFFSET),},
+};
+
+struct cpu_wp *get_cpu_wp(int *wp)
+{
+	if (__raw_readl(MXC_CCM_PDR0) & MXC_CCM_PDR0_AUTO_CON) {
+		*wp = 9;
+		return cpu_wp_con;
+	} else {
+		*wp = 6;
+		return cpu_wp_auto;
+	}
+}
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX35EVB data structure.
+ */
+/* *INDENT-OFF* */
+MACHINE_START(MX35EVB, "Freescale MX35 EVB")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.phys_io = AIPS1_BASE_ADDR,
+	.io_pg_offst = ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params = PHYS_OFFSET + 0x100,
+	.fixup = fixup_mxc_board,
+	.map_io = mxc_map_io,
+	.init_irq = mxc_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx35/mx35evb_cpld.c b/arch/arm/mach-mx35/mx35evb_cpld.c
new file mode 100644
index 0000000..f44e805
--- /dev/null
+++ b/arch/arm/mach-mx35/mx35evb_cpld.c
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/gpio.h>
+
+#include "board-mx35evb.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx35/mx35evb_cpld.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX35
+ */
+
+static void mxc_expio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	/*TODO:virtual interrupt dispatcher */
+}
+
+/*
+ * Disable an expio pin's interrupt by setting the bit in the imr.
+ * @param irq           an expio virtual irq number
+ */
+static void expio_mask_irq(u32 irq)
+{
+	/*TODO:mask virtual interrupt #irq */
+}
+
+/*
+ * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
+ * @param irq           an expanded io virtual irq number
+ */
+static void expio_ack_irq(u32 irq)
+{
+	/*TODO:ack & mask virtual interrupt #irq */
+}
+
+/*
+ * Enable a expio pin's interrupt by clearing the bit in the imr.
+ * @param irq           a expio virtual irq number
+ */
+static void expio_unmask_irq(u32 irq)
+{
+	/*TODO:enable virtual interrupt #irq */
+}
+
+static struct irq_chip expio_irq_chip = {
+	.ack = expio_ack_irq,
+	.mask = expio_mask_irq,
+	.unmask = expio_unmask_irq,
+};
+
+static int __init mxc_expio_init(void)
+{
+	/*TODO:enable virtual interrupts generated by CPLD */
+	return 0;
+}
+
+arch_initcall(mxc_expio_init);
diff --git a/arch/arm/mach-mx35/mx35evb_gpio.c b/arch/arm/mach-mx35/mx35evb_gpio.c
new file mode 100644
index 0000000..769c2ce
--- /dev/null
+++ b/arch/arm/mach-mx35/mx35evb_gpio.c
@@ -0,0 +1,188 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/gpio.h>
+#include "board-mx35evb.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx35/mx35evb_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO_MX35
+ */
+
+/*!
+ * This system-wise GPIO function initializes the pins during system startup.
+ * All the statically linked device drivers should put the proper GPIO
+ * initialization code inside this function. It is called by \b fixup_mx31ads()
+ * during system startup. This function is board specific.
+ */
+void mx35evb_gpio_init(void)
+{
+	/* config CS4 */
+	mxc_request_iomux(MX35_PIN_CS4, MUX_CONFIG_FUNC);
+
+}
+
+/*!
+ * Setup GPIO for a UART port to be active
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_active(int port, int no_irda)
+{
+	/*
+	 * Configure the IOMUX control registers for the UART signals
+	 */
+	switch (port) {
+		/* UART 1 IOMUX Configs */
+	case 0:
+		mxc_request_iomux(MX35_PIN_RXD1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_TXD1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_RTS1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_CTS1, MUX_CONFIG_FUNC);
+
+		mxc_iomux_set_pad(MX35_PIN_RXD1,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX35_PIN_TXD1,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		mxc_iomux_set_pad(MX35_PIN_RTS1,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX35_PIN_CTS1,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+
+		break;
+		/* UART 2 IOMUX Configs */
+	case 1:
+		mxc_request_iomux(MX35_PIN_TXD2, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_RXD2, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_RTS2, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_CTS2, MUX_CONFIG_FUNC);
+
+		mxc_iomux_set_pad(MX35_PIN_RXD2,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX35_PIN_TXD2,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		mxc_iomux_set_pad(MX35_PIN_RTS2,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX35_PIN_CTS2,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+
+		break;
+		/* UART 3 IOMUX Configs */
+	case 2:
+		mxc_request_iomux(MX35_PIN_FEC_TX_CLK, MUX_CONFIG_ALT2);
+		mxc_request_iomux(MX35_PIN_FEC_RX_CLK, MUX_CONFIG_ALT2);
+		mxc_request_iomux(MX35_PIN_FEC_COL, MUX_CONFIG_ALT2);
+		mxc_request_iomux(MX35_PIN_FEC_RX_DV, MUX_CONFIG_ALT2);
+
+		mxc_iomux_set_input(MUX_IN_UART3_UART_RTS_B, INPUT_CTL_PATH2);
+		mxc_iomux_set_input(MUX_IN_UART3_UART_RXD_MUX, INPUT_CTL_PATH3);
+		break;
+	default:
+		break;
+	}
+
+}
+
+EXPORT_SYMBOL(gpio_uart_active);
+
+/*!
+ * Setup GPIO for a UART port to be inactive
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_inactive(int port, int no_irda)
+{
+	switch (port) {
+	case 0:
+		mxc_request_gpio(MX35_PIN_RXD1);
+		mxc_request_gpio(MX35_PIN_TXD1);
+		mxc_request_gpio(MX35_PIN_RTS1);
+		mxc_request_gpio(MX35_PIN_CTS1);
+
+		mxc_free_iomux(MX35_PIN_RXD1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_TXD1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_RTS1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_CTS1, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		mxc_request_gpio(MX35_PIN_RXD2);
+		mxc_request_gpio(MX35_PIN_TXD2);
+		mxc_request_gpio(MX35_PIN_RTS2);
+		mxc_request_gpio(MX35_PIN_CTS2);
+
+		mxc_free_iomux(MX35_PIN_RXD2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_TXD2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_RTS2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_CTS2, MUX_CONFIG_GPIO);
+		break;
+	case 2:
+		mxc_request_gpio(MX35_PIN_FEC_TX_CLK);
+		mxc_request_gpio(MX35_PIN_FEC_RX_CLK);
+		mxc_request_gpio(MX35_PIN_FEC_COL);
+		mxc_request_gpio(MX35_PIN_FEC_RX_DV);
+
+		mxc_free_iomux(MX35_PIN_FEC_TX_CLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_FEC_RX_CLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_FEC_COL, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX35_PIN_FEC_RX_DV, MUX_CONFIG_GPIO);
+
+		mxc_iomux_set_input(MUX_IN_UART3_UART_RTS_B, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_UART3_UART_RXD_MUX, INPUT_CTL_PATH0);
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_uart_inactive);
+
+/*!
+ * Configure the IOMUX GPR register to receive shared SDMA UART events
+ *
+ * @param  port         a UART port
+ */
+void config_uartdma_event(int port)
+{
+}
+
+EXPORT_SYMBOL(config_uartdma_event);
+
+void gpio_fec_active(void)
+{
+	/*TODO:require the pins related with FEC */
+}
+
+EXPORT_SYMBOL(gpio_fec_active);
+
+void gpio_fec_inactive(void)
+{
+	/*TODO:release the pins related with FEC */
+}
+
+EXPORT_SYMBOL(gpio_fec_inactive);
diff --git a/arch/arm/mach-mx35/sdma_script_code.h b/arch/arm/mach-mx35/sdma_script_code.h
new file mode 100644
index 0000000..8b6a178
--- /dev/null
+++ b/arch/arm/mach-mx35/sdma_script_code.h
@@ -0,0 +1,212 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/****************************************************************************
+
+			SDMA RELEASE LABEL: 	"SS14_RINGO"
+
+*****************************************************************************/
+
+#ifndef SDMA_SCRIPT_CODE_H
+#define SDMA_SCRIPT_CODE_H
+
+/*!
+ * SDMA ROM scripts start addresses and sizes
+ */
+
+#define start_ADDR	0
+#define start_SIZE	22
+
+#define core_ADDR	80
+#define core_SIZE	232
+
+#define common_ADDR	312
+#define common_SIZE	330
+
+#define ap_2_ap_ADDR	642
+#define ap_2_ap_SIZE	41
+
+#define app_2_mcu_ADDR	683
+#define app_2_mcu_SIZE	64
+
+#define mcu_2_app_ADDR	747
+#define mcu_2_app_SIZE	70
+
+#define uart_2_mcu_ADDR	817
+#define uart_2_mcu_SIZE	75
+
+#define shp_2_mcu_ADDR	892
+#define shp_2_mcu_SIZE	69
+
+#define mcu_2_shp_ADDR	961
+#define mcu_2_shp_SIZE	72
+
+#define per_2_shp_ADDR	1033
+#define per_2_shp_SIZE	78
+
+#define shp_2_per_ADDR	1111
+#define shp_2_per_SIZE	72
+
+#define uartsh_2_mcu_ADDR	1183
+#define uartsh_2_mcu_SIZE	69
+
+#define mcu_2_ata_ADDR	1252
+#define mcu_2_ata_SIZE	81
+
+#define ata_2_mcu_ADDR	1333
+#define ata_2_mcu_SIZE	96
+
+#define loop_DMAs_routines_ADDR	1429
+#define loop_DMAs_routines_SIZE	227
+
+#define test_ADDR	1656
+#define test_SIZE	63
+
+#define signature_ADDR	1023
+#define signature_SIZE	1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define app_2_per_ADDR	6144
+#define app_2_per_SIZE	66
+
+#define descrambler_ADDR	6210
+#define descrambler_SIZE	129
+
+#define ext_mem__ipu_ram_ADDR	6339
+#define ext_mem__ipu_ram_SIZE	123
+
+#define mcu_2_spdif_ADDR	6462
+#define mcu_2_spdif_SIZE	59
+
+#define per_2_app_ADDR	6521
+#define per_2_app_SIZE	74
+
+#define spdif_2_mcu_ADDR	6595
+#define spdif_2_mcu_SIZE	32
+
+#define uart_2_per_ADDR	6627
+#define uart_2_per_SIZE	73
+
+#define uartsh_2_per_ADDR	6700
+#define uartsh_2_per_SIZE	67
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define RAM_CODE_START_ADDR		6144
+#define RAM_CODE_SIZE			623
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+
+static const short sdma_code[] = {
+	0xc1e3, 0x57db, 0x52fb, 0x6ac3, 0x52f3, 0x6ad7, 0x008f, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x0478, 0x7d03, 0x0479, 0x7d1c, 0x7c21,
+	0x0479, 0x7c14, 0x6ddd, 0x56ee, 0x62c8, 0x7e28, 0x0660, 0x7d02,
+	0x0210, 0x0212, 0x6ac8, 0x7f22, 0x0212, 0x6ac8, 0x7f1f, 0x0212,
+	0x6ac8, 0x7f1c, 0x2003, 0x4800, 0x7cef, 0x9836, 0x6ddd, 0x7802,
+	0x62c8, 0x6ac8, 0x9835, 0x6dde, 0x0015, 0x7802, 0x62c8, 0x6ac8,
+	0x9835, 0x0015, 0x0015, 0x7801, 0x62d8, 0x7c08, 0x6ddf, 0x7f06,
+	0x0000, 0x4d00, 0x7d05, 0xc1fa, 0x57db, 0x9806, 0xc273, 0x0454,
+	0xc20a, 0x9801, 0xc13c, 0x7d4a, 0x0970, 0x0111, 0x5111, 0x5ad1,
+	0x5bd9, 0xc14e, 0x5ce1, 0x7d02, 0x0200, 0x9848, 0x08ff, 0x0011,
+	0x28ff, 0x00bc, 0x0288, 0x3a03, 0x4a00, 0x7c67, 0x0015, 0x0015,
+	0x4800, 0x7d2d, 0x58c1, 0x028e, 0x3a03, 0x4a00, 0x7c58, 0x028d,
+	0x3a03, 0x4a00, 0x7c54, 0x6e05, 0x6d01, 0x0d00, 0x0549, 0x5dc9,
+	0x2d49, 0x0f01, 0x660b, 0xd8b2, 0x50c9, 0x284c, 0x00cd, 0x7c01,
+	0x05a0, 0x5de9, 0x50c9, 0x2849, 0x05d0, 0x7c05, 0x4d00, 0x7c01,
+	0x0f01, 0xd890, 0x0692, 0x6e0b, 0x6e28, 0x7e39, 0x7f38, 0x55e9,
+	0x1d01, 0x50c1, 0x2001, 0x58c1, 0x4800, 0x7d01, 0x986a, 0x52d1,
+	0x53d9, 0x54e1, 0xc159, 0x7dbc, 0x0200, 0x9842, 0x0200, 0x9842,
+	0x0b04, 0x0a00, 0x0c00, 0x0760, 0x7c0b, 0x0803, 0x058b, 0x2501,
+	0x7801, 0x0517, 0x008d, 0x009c, 0x0d01, 0x7801, 0x0517, 0x0295,
+	0x058f, 0x3d03, 0x0715, 0x4d01, 0x7d02, 0x4d02, 0x7c03, 0x0d00,
+	0x054e, 0x07ad, 0x1c01, 0x4c08, 0x7ce6, 0x0c00, 0x2301, 0x4b00,
+	0x7ce2, 0x0006, 0x0611, 0x0610, 0x0611, 0x0610, 0x0006, 0x0007,
+	0x6004, 0x680c, 0x50c1, 0x0017, 0x0017, 0xc256, 0x048b, 0x0498,
+	0x0454, 0x5ce1, 0x9887, 0x0e70, 0x0611, 0x5616, 0xc13c, 0x7d2a,
+	0x5ade, 0x008e, 0xc14e, 0x7c26, 0x5be0, 0x5ef0, 0x5ce8, 0x0688,
+	0x08ff, 0x0011, 0x28ff, 0x00bc, 0x53f6, 0x05df, 0x7d0b, 0x6dc5,
+	0x03df, 0x7d03, 0x6bd5, 0xd912, 0x98ee, 0x6b05, 0xc5f5, 0x7e27,
+	0x7f29, 0x98ee, 0x6d01, 0x03df, 0x7d05, 0x6bd5, 0xc61f, 0x7e18,
+	0x7f1a, 0x98ee, 0x6b05, 0xc595, 0x7e07, 0x7f06, 0x52de, 0x53e6,
+	0xc159, 0x7dd7, 0x0200, 0x98c6, 0x0007, 0x6004, 0x680c, 0x53f6,
+	0x028e, 0x00a3, 0xc256, 0x048b, 0x0498, 0x0454, 0x068a, 0x98ee,
+	0x0207, 0x680c, 0x6ddf, 0x0107, 0x68ff, 0x60d0, 0x98f7, 0x0207,
+	0x68ff, 0x6d28, 0x0107, 0x6004, 0x680c, 0x98f7, 0x0007, 0x68ff,
+	0x60d0, 0x98f7, 0x0288, 0x03a5, 0x3b03, 0x3d03, 0x4d00, 0x7d0a,
+	0x0804, 0x00a5, 0x00da, 0x7d1a, 0x02a0, 0x7b01, 0x65d8, 0x7eee,
+	0x65ff, 0x7eec, 0x0804, 0x02d0, 0x7d11, 0x4b00, 0x7c0f, 0x008a,
+	0x3003, 0x6dcf, 0x6bdf, 0x0015, 0x0015, 0x7b02, 0x65d8, 0x0000,
+	0x7edd, 0x63ff, 0x7edb, 0x3a03, 0x6dcd, 0x6bdd, 0x008a, 0x7b02,
+	0x65d8, 0x0000, 0x7ed3, 0x65ff, 0x7ed1, 0x0006, 0xc1d9, 0xc1e3,
+	0x57db, 0x52f3, 0x6a01, 0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+	0x5deb, 0x56fb, 0x0478, 0x7d28, 0x0479, 0x7c16, 0x0015, 0x0015,
+	0x0388, 0x620a, 0x0808, 0x7801, 0x0217, 0x5a06, 0x7f1d, 0x620a,
+	0x0808, 0x7801, 0x0217, 0x5a26, 0x7f17, 0x2301, 0x4b00, 0x7cf1,
+	0x0b70, 0x0311, 0x5313, 0x996d, 0x0015, 0x0015, 0x0015, 0x7804,
+	0x620b, 0x5a06, 0x620b, 0x5a26, 0x7c07, 0x0000, 0x55eb, 0x4d00,
+	0x7d06, 0xc1fa, 0x57db, 0x9943, 0x0007, 0x680c, 0xc213, 0xc20a,
+	0x9940, 0xc1e3, 0x57db, 0x52f3, 0x6ac5, 0x52fb, 0x6ad3, 0x008f,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5deb, 0x0478, 0x7d03, 0x0479,
+	0x7d20, 0x7c25, 0x0479, 0x7c19, 0x59e3, 0x56ee, 0x61c8, 0x7e2e,
+	0x62c8, 0x7e2c, 0x65c8, 0x7e2a, 0x0660, 0x7d03, 0x0112, 0x0112,
+	0x999b, 0x0512, 0x0512, 0x0211, 0x02a9, 0x02ad, 0x6ac8, 0x7f1e,
+	0x2003, 0x4800, 0x7ceb, 0x51e3, 0x99b5, 0x7802, 0x62c8, 0x6ac8,
+	0x99b4, 0x6dce, 0x0015, 0x7802, 0x62c8, 0x6ac8, 0x99b4, 0x6dcf,
+	0x0015, 0x0015, 0x7801, 0x62d8, 0x7c09, 0x6ddf, 0x7f07, 0x0000,
+	0x55eb, 0x4d00, 0x7d06, 0xc1fa, 0x57db, 0x997f, 0x0007, 0x68ff,
+	0xc213, 0xc20a, 0x997a, 0xc1d9, 0xc1e3, 0x57db, 0x52f3, 0x6a05,
+	0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x56fb, 0x0015, 0x0015,
+	0x0015, 0x7804, 0x5206, 0x6a0b, 0x5226, 0x6a0b, 0x7c08, 0x6a28,
+	0x7f06, 0x0000, 0x4d00, 0x7d05, 0xc1fa, 0x57db, 0x99c8, 0xc277,
+	0x0454, 0xc20a, 0x99c5, 0xc1e3, 0x57db, 0x52f3, 0x6ad5, 0x56fb,
+	0x028e, 0x1a94, 0x6ac3, 0x62c8, 0x0269, 0x7d1e, 0x1e94, 0x6ee3,
+	0x62d0, 0x5aeb, 0x62c8, 0x0248, 0x6ed3, 0x6ac8, 0x2694, 0x52eb,
+	0x6ad5, 0x6ee3, 0x62c8, 0x026e, 0x7d27, 0x6ac8, 0x7f23, 0x2501,
+	0x4d00, 0x7d26, 0x028e, 0x1a98, 0x6ac3, 0x62c8, 0x6ec3, 0x0260,
+	0x7df1, 0x62d0, 0xc27a, 0x9a28, 0x6ee3, 0x008f, 0x2001, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x62c8, 0x026e, 0x7d0e, 0x6ac8, 0x7f0a,
+	0x2001, 0x7cf9, 0x6add, 0x7f06, 0x0000, 0x4d00, 0x7d09, 0xc1fa,
+	0x57db, 0x99e7, 0x0007, 0x6aff, 0x62d0, 0xc27a, 0x0458, 0x0454,
+	0x6add, 0x7ff8, 0xc20a, 0x99e4, 0xc1d9, 0xc1e3, 0x57db, 0x52f3,
+	0x6ad5, 0x56fb, 0x028e, 0x1a94, 0x5202, 0x0269, 0x7d17, 0x1e94,
+	0x5206, 0x0248, 0x5a06, 0x2694, 0x5206, 0x026e, 0x7d26, 0x6ac8,
+	0x7f22, 0x2501, 0x4d00, 0x7d27, 0x028e, 0x1a98, 0x5202, 0x0260,
+	0x7df3, 0x6add, 0x7f18, 0x62d0, 0xc27a, 0x9a6b, 0x008f, 0x2001,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5206, 0x026e, 0x7d0e, 0x6ac8,
+	0x7f0a, 0x2001, 0x7cf9, 0x6add, 0x7f06, 0x0000, 0x4d00, 0x7d0b,
+	0xc1fa, 0x57db, 0x9a31, 0x0007, 0x6aff, 0x6add, 0x7ffc, 0x62d0,
+	0xc27a, 0x0458, 0x0454, 0x6add, 0x7ff6, 0xc20a, 0x9a2e
+};
+#endif
diff --git a/arch/arm/mach-mx35/serial.c b/arch/arm/mach-mx35/serial.c
new file mode 100644
index 0000000..2929bfe
--- /dev/null
+++ b/arch/arm/mach-mx35/serial.c
@@ -0,0 +1,180 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*!
+ * @file mach-mx35/serial.c
+ *
+ * @brief This file contains the UART initiliazation.
+ *
+ * @ingroup MSL_MX35
+ */
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <asm/hardware.h>
+#include <asm/arch/mxc_uart.h>
+#include <asm/arch/spba.h>
+#include "serial.h"
+#include "board-mx35evb.h"
+#include "board-mx35_3stack.h"
+
+#if defined(CONFIG_SERIAL_MXC) || defined(CONFIG_SERIAL_MXC_MODULE)
+
+/*!
+ * This is an array where each element holds information about a UART port,
+ * like base address of the UART, interrupt numbers etc. This structure is
+ * passed to the serial_core.c file. Based on which UART is used, the core file
+ * passes back the appropriate port structure as an argument to the control
+ * functions.
+ */
+static uart_mxc_port mxc_ports[] = {
+	[0] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART1_BASE_ADDR),
+			.mapbase = UART1_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART1_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 0,
+			},
+	       .ints_muxed = UART1_MUX_INTS,
+	       .irqs = {UART1_INT2, UART1_INT3},
+	       .mode = UART1_MODE,
+	       .ir_mode = UART1_IR,
+	       .enabled = UART1_ENABLED,
+	       .hardware_flow = UART1_HW_FLOW,
+	       .cts_threshold = UART1_UCR4_CTSTL,
+	       .dma_enabled = UART1_DMA_ENABLE,
+	       .dma_rxbuf_size = UART1_DMA_RXBUFSIZE,
+	       .rx_threshold = UART1_UFCR_RXTL,
+	       .tx_threshold = UART1_UFCR_TXTL,
+	       .shared = UART1_SHARED_PERI,
+	       .dma_tx_id = MXC_DMA_UART1_TX,
+	       .dma_rx_id = MXC_DMA_UART1_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       .ir_tx_inv = MXC_IRDA_TX_INV,
+	       .ir_rx_inv = MXC_IRDA_RX_INV,
+	       },
+	[1] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART2_BASE_ADDR),
+			.mapbase = UART2_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART2_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 1,
+			},
+	       .ints_muxed = UART2_MUX_INTS,
+	       .irqs = {UART2_INT2, UART2_INT3},
+	       .mode = UART2_MODE,
+	       .ir_mode = UART2_IR,
+	       .enabled = UART2_ENABLED,
+	       .hardware_flow = UART2_HW_FLOW,
+	       .cts_threshold = UART2_UCR4_CTSTL,
+	       .dma_enabled = UART2_DMA_ENABLE,
+	       .dma_rxbuf_size = UART2_DMA_RXBUFSIZE,
+	       .rx_threshold = UART2_UFCR_RXTL,
+	       .tx_threshold = UART2_UFCR_TXTL,
+	       .shared = UART2_SHARED_PERI,
+	       .dma_tx_id = MXC_DMA_UART2_TX,
+	       .dma_rx_id = MXC_DMA_UART2_RX,
+	       .rxd_mux = MXC_UART_IR_RXDMUX,
+	       .ir_tx_inv = MXC_IRDA_TX_INV,
+	       .ir_rx_inv = MXC_IRDA_RX_INV,
+	       },
+#if UART3_ENABLED == 1
+	[2] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART3_BASE_ADDR),
+			.mapbase = UART3_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART3_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 2,
+			},
+	       .ints_muxed = UART3_MUX_INTS,
+	       .irqs = {UART3_INT2, UART3_INT3},
+	       .mode = UART3_MODE,
+	       .ir_mode = UART3_IR,
+	       .enabled = UART3_ENABLED,
+	       .hardware_flow = UART3_HW_FLOW,
+	       .cts_threshold = UART3_UCR4_CTSTL,
+	       .dma_enabled = UART3_DMA_ENABLE,
+	       .dma_rxbuf_size = UART3_DMA_RXBUFSIZE,
+	       .rx_threshold = UART3_UFCR_RXTL,
+	       .tx_threshold = UART3_UFCR_TXTL,
+	       .shared = UART3_SHARED_PERI,
+	       .dma_tx_id = MXC_DMA_UART3_TX,
+	       .dma_rx_id = MXC_DMA_UART3_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       .ir_tx_inv = MXC_IRDA_TX_INV,
+	       .ir_rx_inv = MXC_IRDA_RX_INV,
+	       },
+#endif
+};
+
+static struct platform_device mxc_uart_device1 = {
+	.name = "mxcintuart",
+	.id = 0,
+	.dev = {
+		.platform_data = &mxc_ports[0],
+		},
+};
+
+static struct platform_device mxc_uart_device2 = {
+	.name = "mxcintuart",
+	.id = 1,
+	.dev = {
+		.platform_data = &mxc_ports[1],
+		},
+};
+
+#if UART3_ENABLED == 1
+static struct platform_device mxc_uart_device3 = {
+	.name = "mxcintuart",
+	.id = 2,
+	.dev = {
+		.platform_data = &mxc_ports[2],
+		},
+};
+#endif
+
+static int __init mxc_init_uart(void)
+{
+	/* Register all the MXC UART platform device structures */
+	platform_device_register(&mxc_uart_device1);
+	platform_device_register(&mxc_uart_device2);
+
+	/* Grab ownership of shared UARTs 3 and 4, only when enabled */
+#if UART3_ENABLED == 1
+#if UART3_DMA_ENABLE == 1
+	spba_take_ownership(UART3_SHARED_PERI, (SPBA_MASTER_A | SPBA_MASTER_C));
+#else
+	spba_take_ownership(UART3_SHARED_PERI, SPBA_MASTER_A);
+#endif				/* UART3_DMA_ENABLE */
+	platform_device_register(&mxc_uart_device3);
+#endif				/* UART3_ENABLED */
+
+	return 0;
+}
+
+#else
+static int __init mxc_init_uart(void)
+{
+	return 0;
+}
+#endif
+
+arch_initcall(mxc_init_uart);
diff --git a/arch/arm/mach-mx35/serial.h b/arch/arm/mach-mx35/serial.h
new file mode 100644
index 0000000..d18bb22
--- /dev/null
+++ b/arch/arm/mach-mx35/serial.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright 20088888888 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX35_SERIAL_H__
+#define __ARCH_ARM_MACH_MX35_SERIAL_H__
+
+/*!
+ * @file mach-mx35/serial.h
+ *
+ * @ingroup MSL_MX35
+ */
+#include <asm/arch/mxc_uart.h>
+
+/* UART 1 configuration */
+/*!
+ * This option allows to choose either an interrupt-driven software controlled
+ * hardware flow control (set this option to 0) or hardware-driven hardware
+ * flow control (set this option to 1).
+ */
+#define UART1_HW_FLOW           1
+/*!
+ * This specifies the threshold at which the CTS pin is deasserted by the
+ * RXFIFO. Set this value in Decimal to anything from 0 to 32 for
+ * hardware-driven hardware flow control. Read the HW spec while specifying
+ * this value. When using interrupt-driven software controlled hardware
+ * flow control set this option to -1.
+ */
+#define UART1_UCR4_CTSTL        16
+/*!
+ * This is option to enable (set this option to 1) or disable DMA data transfer
+ */
+#define UART1_DMA_ENABLE        0
+/*!
+ * Specify the size of the DMA receive buffer. The minimum buffer size is 512
+ * bytes. The buffer size should be a multiple of 256.
+ */
+#define UART1_DMA_RXBUFSIZE     1024
+/*!
+ * Specify the MXC UART's Receive Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the RxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_RXTL         16
+/*!
+ * Specify the MXC UART's Transmit Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the TxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_TXTL         16
+/* UART 2 configuration */
+#define UART2_HW_FLOW           0
+#define UART2_UCR4_CTSTL        -1
+#define UART2_DMA_ENABLE        0
+#define UART2_DMA_RXBUFSIZE     512
+#define UART2_UFCR_RXTL         16
+#define UART2_UFCR_TXTL         16
+/* UART 3 configuration */
+#define UART3_HW_FLOW           1
+#define UART3_UCR4_CTSTL        16
+#define UART3_DMA_ENABLE        1
+#define UART3_DMA_RXBUFSIZE     1024
+#define UART3_UFCR_RXTL         16
+#define UART3_UFCR_TXTL         16
+
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+/*
+ * Is the MUXED interrupt output sent to the ARM core
+ */
+#define INTS_NOTMUXED           0
+#define INTS_MUXED              1
+/* UART 1 configuration */
+/*!
+ * This define specifies whether the muxed ANDed interrupt line or the
+ * individual interrupts from the UART port is integrated with the ARM core.
+ * There exists a define like this for each UART port. Valid values that can
+ * be used are \b INTS_NOTMUXED or \b INTS_MUXED.
+ */
+#define UART1_MUX_INTS          INTS_MUXED
+/*!
+ * This define specifies the transmitter interrupt number or the interrupt
+ * number of the ANDed interrupt in case the interrupts are muxed. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_INT1              MXC_INT_UART1
+/*!
+ * This define specifies the receiver interrupt number. If the interrupts of
+ * the UART are muxed, then we specify here a dummy value -1. There exists a
+ * define like this for each UART port.
+ */
+#define UART1_INT2              -1
+/*!
+ * This specifies the master interrupt number. If the interrupts of the UART
+ * are muxed, then we specify here a dummy value of -1. There exists a define
+ * like this for each UART port.
+ */
+#define UART1_INT3              -1
+/*!
+ * This specifies if the UART is a shared peripheral. It holds the shared
+ * peripheral number if it is shared or -1 if it is not shared. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_SHARED_PERI       -1
+/* UART 2 configuration */
+#define UART2_MUX_INTS          INTS_MUXED
+#define UART2_INT1              MXC_INT_UART2
+#define UART2_INT2              -1
+#define UART2_INT3              -1
+#define UART2_SHARED_PERI       -1
+/* UART 3 configuration */
+#define UART3_MUX_INTS          INTS_MUXED
+#define UART3_INT1              MXC_INT_UART3
+#define UART3_INT2              -1
+#define UART3_INT3              -1
+#define UART3_SHARED_PERI       SPBA_UART3
+
+#endif				/* __ARCH_ARM_MACH_MX35_SERIAL_H__ */
diff --git a/arch/arm/mach-mx35/system.c b/arch/arm/mach-mx35/system.c
new file mode 100644
index 0000000..7841346
--- /dev/null
+++ b/arch/arm/mach-mx35/system.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/clk.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include <asm/arch/clock.h>
+#include "crm_regs.h"
+
+/*!
+ * @defgroup MSL_MX35 i.MX35 Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @file mach-mx35/system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup MSL_MX35
+ */
+
+extern int mxc_jtag_enabled;
+
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks.
+	 */
+	if (!mxc_jtag_enabled) {
+		cpu_do_idle();
+	}
+}
+
+/*
+ * This function resets the system. It is called by machine_restart().
+ *
+ * @param  mode         indicates different kinds of resets
+ */
+void arch_reset(char mode)
+{
+	/* Assert SRS signal */
+	mxc_wd_reset();
+}
diff --git a/arch/arm/plat-mxc/Kconfig b/arch/arm/plat-mxc/Kconfig
index ece95c3..9c396bb 100644
--- a/arch/arm/plat-mxc/Kconfig
+++ b/arch/arm/plat-mxc/Kconfig
@@ -23,6 +23,15 @@ config ARCH_MX37
     help
       This enables support for systems based on Freescale i.MX37
 
+config ARCH_MX35
+    bool "MX35-based"
+        select CPU_V6
+        select CACHE_L2X0
+        #select USB_ARCH_HAS_EHCI
+        select ARCH_HAS_EVTMON
+    help
+      This enables support for systems based on Freescale i.MX35
+
 config ARCH_MX3
 	bool "MX3-based"
 	select CPU_V6
@@ -55,6 +64,8 @@ source "arch/arm/mach-mx21/Kconfig"
 
 source "arch/arm/mach-mx3/Kconfig"
 
+source "arch/arm/mach-mx35/Kconfig"
+
 source "arch/arm/mach-mx37/Kconfig"
 
 source "arch/arm/mach-mxc91321/Kconfig"
diff --git a/arch/arm/plat-mxc/sdma/sdma.c b/arch/arm/plat-mxc/sdma/sdma.c
index a2946c4..241b7ec 100644
--- a/arch/arm/plat-mxc/sdma/sdma.c
+++ b/arch/arm/plat-mxc/sdma/sdma.c
@@ -323,7 +323,9 @@ static unsigned short sdma_get_pc(sdma_periphT peripheral_type,
 			res = -EINVAL;
 		}
 	} else if (peripheral_type == SSI_SP || peripheral_type == MMC ||
-		   peripheral_type == SDHC || peripheral_type == CSPI_SP) {
+		   peripheral_type == SDHC || peripheral_type == CSPI_SP ||
+		   peripheral_type == ESAI || peripheral_type == MSHC_SP ||
+		   peripheral_type == ASRC) {
 		switch (transfer_type) {
 		case per_2_int:
 			res = sdma_script_addrs.mxc_sdma_shp_2_per_addr;
@@ -363,12 +365,21 @@ static unsigned short sdma_get_pc(sdma_periphT peripheral_type,
 		res = sdma_script_addrs.mxc_sdma_ap_2_ap_fixed_addr;
 	} else if (peripheral_type == SPDIF) {
 		switch (transfer_type) {
+		case per_2_emi:
+			res = sdma_script_addrs.mxc_sdma_spdif_2_mcu_addr;
+			break;
 		case emi_2_per:
 			res = sdma_script_addrs.mxc_sdma_mcu_2_spdif_addr;
 			break;
 		default:
 			res = -EINVAL;
 		}
+	} else if (peripheral_type == IPU_MEMORY) {
+		if (transfer_type == emi_2_per) {
+			res = sdma_script_addrs.mxc_sdma_ext_mem_2_ipu_addr;
+		} else {
+			res = -EINVAL;
+		}
 	}
 
 	if (res < 0) {
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 495d25c..5650190 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -12,7 +12,7 @@
 #
 #   http://www.arm.linux.org.uk/developer/machines/?action=new
 #
-# Last update: Tue Nov 6 20:08:39 2007
+# Last update: Thu Feb 28 10:25:44 2008
 #
 # machine_is_xxx	CONFIG_xxxx		MACH_TYPE_xxx		number
 #
@@ -661,7 +661,6 @@ a9200ec			MACH_A9200EC		A9200EC			645
 pnx0105			MACH_PNX0105		PNX0105			646
 adcpoecpu		MACH_ADCPOECPU		ADCPOECPU		647
 csb637			MACH_CSB637		CSB637			648
-ml675050		MACH_ML69Q6203		ML69Q6203		649
 mb9200			MACH_MB9200		MB9200			650
 kulun			MACH_KULUN		KULUN			651
 snapper			MACH_SNAPPER		SNAPPER			652
@@ -953,7 +952,6 @@ fred_jack		MACH_FRED_JACK		FRED_JACK		939
 ttg_color1		MACH_TTG_COLOR1		TTG_COLOR1		940
 nxeb500hmi		MACH_NXEB500HMI		NXEB500HMI		941
 netdcu8			MACH_NETDCU8		NETDCU8			942
-ml675050_dev_sys	MACH_ML675050_CPU_BOA	ML675050_CPU_BOA	943
 ng_fvx538		MACH_NG_FVX538		NG_FVX538		944
 ng_fvs338		MACH_NG_FVS338		NG_FVS338		945
 pnx4103			MACH_PNX4103		PNX4103			946
@@ -1299,7 +1297,7 @@ xp179			MACH_XP179		XP179			1290
 h4300			MACH_H4300		H4300			1291
 goramo_mlr		MACH_GORAMO_MLR		GORAMO_MLR		1292
 mxc30020evb		MACH_MXC30020EVB	MXC30020EVB		1293
-adsbitsyg5		MACH_ADSBITSIMX		ADSBITSIMX		1294
+adsbitsyg5		MACH_ADSBITSYG5		ADSBITSYG5		1294
 adsportalplus		MACH_ADSPORTALPLUS	ADSPORTALPLUS		1295
 mmsp2plus		MACH_MMSP2PLUS		MMSP2PLUS		1296
 em_x270			MACH_EM_X270		EM_X270			1297
@@ -1369,9 +1367,8 @@ tik27			MACH_TIK27		TIK27			1360
 mx_uc7420		MACH_MX_UC7420		MX_UC7420		1361
 rirm3			MACH_RIRM3		RIRM3			1362
 pelco_odyssey		MACH_PELCO_ODYSSEY	PELCO_ODYSSEY		1363
-arm920t			MACH_ARM920T		ARM920T			1364
-add_abox		MACH_ADD_ABOX		ADD_ABOX		1365
-add_tpid		MACH_ADD_TPID		ADD_TPID		1366
+adx_abox		MACH_ADX_ABOX		ADX_ABOX		1365
+adx_tpid		MACH_ADX_TPID		ADX_TPID		1366
 minicheck		MACH_MINICHECK		MINICHECK		1367
 idam			MACH_IDAM		IDAM			1368
 mario_mx		MACH_MARIO_MX		MARIO_MX		1369
@@ -1387,7 +1384,6 @@ olip8			MACH_OLIP8		OLIP8			1378
 ghi270hg		MACH_GHI270HG		GHI270HG		1379
 davinci_dm6467_evm	MACH_DAVINCI_DM6467_EVM	DAVINCI_DM6467_EVM	1380
 davinci_dm355_evm	MACH_DAVINCI_DM350_EVM	DAVINCI_DM350_EVM	1381
-ocearm			MACH_OCEARMTEST		OCEARMTEST		1382
 blackriver		MACH_BLACKRIVER		BLACKRIVER		1383
 sandgate_wp		MACH_SANDGATEWP		SANDGATEWP		1384
 cdotbwsg		MACH_CDOTBWSG		CDOTBWSG		1385
@@ -1410,7 +1406,6 @@ ochaya1050		MACH_OCHAYA1050		OCHAYA1050		1401
 lep9261			MACH_LEP9261		LEP9261			1402
 svenmeb			MACH_SVENMEB		SVENMEB			1403
 fortunet2ne		MACH_FORTUNET2NE	FORTUNET2NE		1404
-omap2			MACH_OMAP2		OMAP2			1405
 nxhx			MACH_NXHX		NXHX			1406
 realview_pb11mp		MACH_REALVIEW_PB11MP	REALVIEW_PB11MP		1407
 ids500			MACH_IDS500		IDS500			1408
@@ -1434,13 +1429,10 @@ ezreganut9200		MACH_EZREGANUT9200	EZREGANUT9200		1425
 sarge			MACH_SARGE		SARGE			1426
 a696			MACH_A696		A696			1427
 turtle1916		MACH_TURTLE		TURTLE			1428
-pxa1916			MACH_MY5910TURTLE	MY5910TURTLE		1429
 mx27_3ds		MACH_MX27_3DS		MX27_3DS		1430
 bishop			MACH_BISHOP		BISHOP			1431
 pxx			MACH_PXX		PXX			1432
 redwood			MACH_REDWOOD		REDWOOD			1433
-dummy			MACH_OMAP2430DLP	OMAP2430DLP		1434
-dummy_board		MACH_OMAP2430OSK	OMAP2430OSK		1435
 omap_2430dlp		MACH_OMAP_2430DLP	OMAP_2430DLP		1436
 omap_2430osk		MACH_OMAP_2430OSK	OMAP_2430OSK		1437
 sardine			MACH_SARDINE		SARDINE			1438
@@ -1470,8 +1462,8 @@ herald			MACH_HERMES		HERMES			1461
 artemis			MACH_ARTEMIS		ARTEMIS			1462
 htctitan		MACH_HTCTITAN		HTCTITAN		1463
 qranium			MACH_QRANIUM		QRANIUM			1464
-add_wsc2		MACH_ADD_WSC2		ADD_WSC2		1465
-add_medinet		MACH_ADD_MEDINET	ADD_MEDINET		1466
+adx_wsc2		MACH_ADX_WSC2		ADX_WSC2		1465
+adx_medcom		MACH_ADX_MEDINET	ADX_MEDINET		1466
 bboard			MACH_BBOARD		BBOARD			1467
 cambria			MACH_CAMBRIA		CAMBRIA			1468
 mt7xxx			MACH_MT7XXX		MT7XXX			1469
@@ -1526,7 +1518,6 @@ adma			MACH_ADMA		ADMA			1517
 wp188			MACH_WP188		WP188			1518
 corsica			MACH_CORSICA		CORSICA			1519
 bigeye			MACH_BIGEYE		BIGEYE			1520
-machine_is_arm2410	MACH_MACHINE_IS_ARM2410	MACHINE_IS_ARM2410	1521
 tll5000			MACH_TLL5000		TLL5000			1522
 hni270			MACH_HNI_X270		HNI_X270		1523
 qong			MACH_QONG		QONG			1524
@@ -1541,7 +1532,112 @@ actux4			MACH_ACTUX4		ACTUX4			1532
 esl_omap		MACH_ESL_OMAP		ESL_OMAP		1533
 omap2evm		MACH_OMAP2EVM		OMAP2EVM		1534
 omap3evm		MACH_OMAP3EVM		OMAP3EVM		1535
-add_pcu57		MACH_ADD_PCU57		ADD_PCU57		1536
+adx_pcu57		MACH_ADX_PCU57		ADX_PCU57		1536
 monaco			MACH_MONACO		MONACO			1537
 levante			MACH_LEVANTE		LEVANTE			1538
+tmxipx425		MACH_TMXIPX425		TMXIPX425		1539
+leep			MACH_LEEP		LEEP			1540
+raad			MACH_RAAD		RAAD			1541
+dns323			MACH_DNS323		DNS323			1542
+ap1000			MACH_AP1000		AP1000			1543
+a9sam6432		MACH_A9SAM6432		A9SAM6432		1544
+shiny			MACH_SHINY		SHINY			1545
+omap3_beagle		MACH_OMAP3_BEAGLE	OMAP3_BEAGLE		1546
+csr_bdb2		MACH_CSR_BDB2		CSR_BDB2		1547
+nokia_n810		MACH_NOKIA_N810		NOKIA_N810		1548
+c270			MACH_C270		C270			1549
+sentry			MACH_SENTRY		SENTRY			1550
+pcm038			MACH_PCM038		PCM038			1551
+anc300			MACH_ANC300		ANC300			1552
+htckaiser		MACH_HTCKAISER		HTCKAISER		1553
+sbat100			MACH_SBAT100		SBAT100			1554
+modunorm		MACH_MODUNORM		MODUNORM		1555
+pelos_twarm		MACH_PELOS_TWARM	PELOS_TWARM		1556
+flank			MACH_FLANK		FLANK			1557
+sirloin			MACH_SIRLOIN		SIRLOIN			1558
+brisket			MACH_BRISKET		BRISKET			1559
+chuck			MACH_CHUCK		CHUCK			1560
+otter			MACH_OTTER		OTTER			1561
+davinci_ldk		MACH_DAVINCI_LDK	DAVINCI_LDK		1562
+phreedom		MACH_PHREEDOM		PHREEDOM		1563
+sg310			MACH_SG310		SG310			1564
+ts_x09			MACH_TS209		TS209			1565
+at91cap9adk		MACH_AT91CAP9ADK	AT91CAP9ADK		1566
+tion9315		MACH_TION9315		TION9315		1567
+mast			MACH_MAST		MAST			1568
+pfw			MACH_PFW		PFW			1569
+yl_p2440		MACH_YL_P2440		YL_P2440		1570
+zsbc32			MACH_ZSBC32		ZSBC32			1571
+omap_pace2		MACH_OMAP_PACE2		OMAP_PACE2		1572
+imx_pace2		MACH_IMX_PACE2		IMX_PACE2		1573
+mx31moboard		MACH_MX31MOBOARD	MX31MOBOARD		1574
 mx37_3ds		MACH_MX37_3DS		MX37_3DS		1575
+rcc			MACH_RCC		RCC			1576
+dmp			MACH_ARM9		ARM9			1577
+vision_ep9307		MACH_VISION_EP9307	VISION_EP9307		1578
+scly1000		MACH_SCLY1000		SCLY1000		1579
+fontel_ep		MACH_FONTEL_EP		FONTEL_EP		1580
+voiceblue3g		MACH_VOICEBLUE3G	VOICEBLUE3G		1581
+tt9200			MACH_TT9200		TT9200			1582
+digi2410		MACH_DIGI2410		DIGI2410		1583
+terastation_pro2	MACH_TERASTATION_PRO2	TERASTATION_PRO2	1584
+linkstation_pro		MACH_LINKSTATION_PRO	LINKSTATION_PRO		1585
+motorola_a780		MACH_MOTOROLA_A780	MOTOROLA_A780		1587
+motorola_e6		MACH_MOTOROLA_E6	MOTOROLA_E6		1588
+motorola_e2		MACH_MOTOROLA_E2	MOTOROLA_E2		1589
+motorola_e680		MACH_MOTOROLA_E680	MOTOROLA_E680		1590
+ur2410			MACH_UR2410		UR2410			1591
+tas9261			MACH_TAS9261		TAS9261			1592
+davinci_hermes_hd	MACH_HERMES_HD		HERMES_HD		1593
+davinci_perseo_hd	MACH_PERSEO_HD		PERSEO_HD		1594
+stargazer2		MACH_STARGAZER2		STARGAZER2		1595
+e350			MACH_E350		E350			1596
+wpcm450			MACH_WPCM450		WPCM450			1597
+cartesio		MACH_CARTESIO		CARTESIO		1598
+toybox			MACH_TOYBOX		TOYBOX			1599
+tx27			MACH_TX27		TX27			1600
+ts409			MACH_TS409		TS409			1601
+p300			MACH_P300		P300			1602
+xdacomet		MACH_XDACOMET		XDACOMET		1603
+dexflex2		MACH_DEXFLEX2		DEXFLEX2		1604
+ow			MACH_OW			OW			1605
+armebs3			MACH_ARMEBS3		ARMEBS3			1606
+u3			MACH_U3			U3			1607
+smdk2450		MACH_SMDK2450		SMDK2450		1608
+rsi_ews			MACH_RSI_EWS		RSI_EWS			1609
+tnb			MACH_TNB		TNB			1610
+toepath			MACH_TOEPATH		TOEPATH			1611
+kb9263			MACH_KB9263		KB9263			1612
+mt7108			MACH_MT7108		MT7108			1613
+smtr2440		MACH_SMTR2440		SMTR2440		1614
+manao			MACH_MANAO		MANAO			1615
+cm_x300			MACH_CM_X300		CM_X300			1616
+gulfstream_kp		MACH_GULFSTREAM_KP	GULFSTREAM_KP		1617
+lanreadyfn522		MACH_LANREADYFN522	LANREADYFN522		1618
+arma37			MACH_ARMA37		ARMA37			1619
+mendel			MACH_MENDEL		MENDEL			1620
+pelco_iliad		MACH_PELCO_ILIAD	PELCO_ILIAD		1621
+unit2p			MACH_UNIT2P		UNIT2P			1622
+inc20otter		MACH_INC20OTTER		INC20OTTER		1623
+at91sam9g20ek		MACH_AT91SAM9G20EK	AT91SAM9G20EK		1624
+sc_ge2			MACH_STORCENTER		STORCENTER		1625
+smdk6410		MACH_SMDK6410		SMDK6410		1626
+u300			MACH_U300		U300			1627
+u500			MACH_U500		U500			1628
+ds9260			MACH_DS9260		DS9260			1629
+riverrock		MACH_RIVERROCK		RIVERROCK		1630
+scibath			MACH_SCIBATH		SCIBATH			1631
+at91sam7se		MACH_AT91SAM7SE512EK	AT91SAM7SE512EK		1632
+wrt350n_v2		MACH_WRT350N_V2		WRT350N_V2		1633
+multimedia		MACH_MULTIMEDIA		MULTIMEDIA		1634
+marvin			MACH_MARVIN		MARVIN			1635
+x500			MACH_X500		X500			1636
+awlug4lcu		MACH_AWLUG4LCU		AWLUG4LCU		1637
+palermoc		MACH_PALERMOC		PALERMOC		1638
+omap_3430labrador	MACH_OMAP_3430LABRADOR	OMAP_3430LABRADOR	1639
+ip500			MACH_IP500		IP500			1640
+mx35ads			MACH_MACH_MX35ADS	MACH_MX35ADS		1641
+ase2			MACH_ASE2		ASE2			1642
+mx35evb			MACH_MX35EVB		MX35EVB			1643
+aml_m8050		MACH_AML_M8050		AML_M8050		1644
+mx35_3ds		MACH_MX35_3DS		MX35_3DS		1645
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 7944d4d..a307875 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -1820,7 +1820,7 @@ config 68360_ENET
 
 config FEC
 	tristate "FEC ethernet controller"
-	depends on M523x || M527x || M5272 || M528x || M520x || ARCH_MX27 || ARCH_MX37 
+	depends on M523x || M527x || M5272 || M528x || M520x || ARCH_MX27 || ARCH_MX37 || ARCH_MX35
 	help
 	  Say Y here if you want to use the built-in 10/100 Fast ethernet
 	  controller on some Motorola/Freescale processors.
diff --git a/drivers/net/fec.c b/drivers/net/fec.c
index 99b3efd..749f9b8 100644
--- a/drivers/net/fec.c
+++ b/drivers/net/fec.c
@@ -25,7 +25,7 @@
  * Copyright (c) 2004-2006 Macq Electronique SA.
  */
 /*
- * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 #include <linux/module.h>
@@ -694,7 +694,6 @@ while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) {
 			skb_reserve(skb, 2);    /*skip 2bytes, so ipheader is align 4bytes*/
 			skb_put(skb,pkt_len-4); /* Make room */
 		skb_copy_to_linear_data(skb, data, pkt_len-4);
-					pkt_len-4, 0);
 		} else {
 			struct sk_buff * pskb = fep->rx_skbuff[rx_index];
 
@@ -2057,8 +2056,8 @@ static void __inline__ fec_arch_exit(void)
 static void __inline__ fec_request_intrs(struct net_device *dev)
 {
 	/* Setup interrupt handlers. */
-	if (request_irq(INT_FEC, fec_enet_interrupt, 0, "fec", dev) != 0)
-		panic("FEC: Could not allocate FEC IRQ(%d)!\n", INT_FEC);
+	if (request_irq(MXC_INT_FEC, fec_enet_interrupt, 0, "fec", dev) != 0)
+		panic("FEC: Could not allocate FEC IRQ(%d)!\n", MXC_INT_FEC);
 	/* TODO: disable now due to CPLD issue */
 	if (request_irq(expio_intr_fec, mii_link_interrupt, 0, "fec(MII)", dev) != 0)
 		panic("FEC: Could not allocate FEC(MII) IRQ(%d)!\n", expio_intr_fec);
@@ -2380,7 +2379,6 @@ static void mii_display_config(struct work_struct *work)
 {
 	struct fec_enet_private *fep = container_of(work, struct fec_enet_private, phy_task);
 	struct net_device *dev = fep->netdev;
-	struct net_device *dev = fep->net;
 	uint status = fep->phy_status;
 
 	/*
@@ -2418,7 +2416,6 @@ static void mii_relink(struct work_struct *work)
 {
 	struct fec_enet_private *fep = container_of(work, struct fec_enet_private, phy_task);
 	struct net_device *dev = fep->netdev;
-	struct net_device *dev = fep->net;
 	int duplex;
 
 	/*
@@ -3063,7 +3060,7 @@ fec_stop(struct net_device *dev)
 static int __init fec_enet_module_init(void)
 {
 	struct net_device *dev;
-	int i, j, err;
+	int i, err;
 	DECLARE_MAC_BUF(mac);
 
 	printk("FEC ENET Version 0.2\n");
diff --git a/include/asm-arm/arch-mxc/hardware.h b/include/asm-arm/arch-mxc/hardware.h
index 781b5a6..043fa4d 100644
--- a/include/asm-arm/arch-mxc/hardware.h
+++ b/include/asm-arm/arch-mxc/hardware.h
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -12,7 +12,7 @@
  * @file arch-mxc/hardware.h
  * @brief This file contains the hardware definitions of the board.
  *
- * @ingroup MSL_MX27 MSL_MX31 MSL_MX37 MSL_MXC91321
+ * @ingroup MSL_MX27 MSL_MX31 MSL_MX35 MSL_MX37 MSL_MXC91321
  */
 #ifndef __ASM_ARCH_MXC_HARDWARE_H__
 #define __ASM_ARCH_MXC_HARDWARE_H__
@@ -72,6 +72,13 @@ static inline int type## _rev (int rev)		\
 #define cpu_is_mx32()		(0)
 #endif
 
+#ifdef CONFIG_ARCH_MX35
+#include <asm/arch/mx35.h>
+#define cpu_is_mx35()   (1)
+#else
+#define cpu_is_mx35()   (0)
+#endif
+
 #ifdef CONFIG_ARCH_MX37
 #include <asm/arch/mx37.h>
 #define cpu_is_mx37()   (1)
@@ -110,6 +117,7 @@ MXC_REV(cpu_is_mx21);
 MXC_REV(cpu_is_mx27);
 MXC_REV(cpu_is_mx31);
 MXC_REV(cpu_is_mx32);
+MXC_REV(cpu_is_mx35);
 MXC_REV(cpu_is_mx37);
 #endif
 
diff --git a/include/asm-arm/arch-mxc/memory.h b/include/asm-arm/arch-mxc/memory.h
index 7a1e07d..ea6fba0 100644
--- a/include/asm-arm/arch-mxc/memory.h
+++ b/include/asm-arm/arch-mxc/memory.h
@@ -15,7 +15,7 @@
 #include <asm/sizes.h>
 
 /* Start of physical RAM */
-#ifdef CONFIG_MACH_MXC30031ADS
+#if defined(CONFIG_MACH_MXC30031ADS) || defined(CONFIG_MACH_MX35EVB)
 #define PHYS_OFFSET             UL(0x90000000)
 #endif
 
diff --git a/include/asm-arm/arch-mxc/mx35.h b/include/asm-arm/arch-mxc/mx35.h
new file mode 100644
index 0000000..266b83c
--- /dev/null
+++ b/include/asm-arm/arch-mxc/mx35.h
@@ -0,0 +1,429 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX35_H__
+#define __ASM_ARCH_MXC_MX35_H__
+
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#error "Do not include directly."
+#endif
+
+#include <asm/arch/mx35_pins.h>
+
+/*!
+ * @file arch-mxc/mx35.h
+ * @brief This file contains register definitions.
+ *
+ * @ingroup MSL_MX35
+ */
+/*!
+ * defines the OS clock tick rate
+ */
+#define CLOCK_TICK_RATE         16625000
+
+/*!
+ * Register an interrupt handler for the SMN as well as the SCC.  In some
+ * implementations, the SMN is not connected at all, and in others, it is
+ * on the same interrupt line as the SCM. Comment this line out accordingly
+ */
+#define USE_SMN_INTERRUPT
+
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+#define MXC_UART_NR 3
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive Irda data.
+ */
+#define MXC_UART_IR_RXDMUX      0x0004
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive UART data.
+ */
+#define MXC_UART_RXDMUX         0x0004
+
+/*!
+ * This option is used to set or clear the dspdma bit in the SDMA config
+ * register.
+ */
+#define MXC_SDMA_DSPDMA         0
+
+/*!
+ * Define this option to specify we are using the newer SDMA module.
+ */
+#define MXC_SDMA_V2
+
+/*
+ * IRAM
+ */
+#define IRAM_BASE_ADDR		0x10000000	/* internal ram */
+#define IRAM_BASE_ADDR_VIRT	0xF8400000
+#define IRAM_SIZE		SZ_128K
+
+/*
+ * L2CC
+ */
+#define L2CC_BASE_ADDR		0x30000000
+
+/*
+ * AIPS 1
+ */
+#define AIPS1_BASE_ADDR 	0x43F00000
+#define AIPS1_BASE_ADDR_VIRT	0xF8500000
+#define AIPS1_SIZE		SZ_1M
+
+#define MAX_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00004000)
+#define EVTMON_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00008000)
+#define CLKCTL_BASE_ADDR	(AIPS1_BASE_ADDR + 0x0000C000)
+#define ETB_SLOT4_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00010000)
+#define ETB_SLOT5_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00014000)
+#define ECT_CTIO_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00018000)
+#define I2C_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00080000)
+#define I2C3_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00084000)
+#define ATA_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0008C000)
+#define UART1_BASE_ADDR 	(AIPS1_BASE_ADDR + 0x00090000)
+#define UART2_BASE_ADDR 	(AIPS1_BASE_ADDR + 0x00094000)
+#define I2C2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00098000)
+#define OWIRE_BASE_ADDR 	(AIPS1_BASE_ADDR + 0x0009C000)
+#define SSI1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A0000)
+#define CSPI1_BASE_ADDR 	(AIPS1_BASE_ADDR + 0x000A4000)
+#define KPP_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A8000)
+#define IOMUXC_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000AC000)
+#define ECT_IP1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B8000)
+#define ECT_IP2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000BC000)
+
+/*
+ * SPBA global module enabled #0
+ */
+#define SPBA0_BASE_ADDR 	0x50000000
+#define SPBA0_BASE_ADDR_VIRT	0xF8600000
+#define SPBA0_SIZE		SZ_1M
+
+#define UART3_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x0000C000)
+#define CSPI2_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x00010000)
+#define SSI2_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00014000)
+#define ATA_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00020000)
+#define MSHC1_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00024000)
+#define SPDIF_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00028000)
+#define ASRC_BASE_ADDR		(SPBA0_BASE_ADDR + 0x0002C000)
+#define ESAI_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00034000)
+#define FEC_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00038000)
+#define SPBA_CTRL_BASE_ADDR	(SPBA0_BASE_ADDR + 0x0003C000)
+
+/*!
+ * defines for SPBA modules
+ */
+#define SPBA_UART3	0x0C
+#define SPBA_CSPI2	0x10
+#define SPBA_SSI2	0x14
+#define SPBA_ATA	0x20
+#define SPBA_MSHC	0x24
+#define SPBA_SPDIR	0x28
+#define SPBA_ASRC	0x2C
+#define SPBA_ESAI	0x34
+#define SPBA_FEC	0x38
+
+/*!
+ * Defines for modules using static and dynamic DMA channels
+ */
+#define MXC_DMA_CHANNEL_UART1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC1  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC2  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC3  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MEMORY  MXC_DMA_DYNAMIC_CHANNEL
+
+/*
+ * AIPS 2
+ */
+#define AIPS2_BASE_ADDR		0x53F00000
+#define AIPS2_BASE_ADDR_VIRT	0xF8700000
+#define AIPS2_SIZE		SZ_1M
+#define CCM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00080000)
+#define GPT1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00090000)
+#define EPIT1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00094000)
+#define EPIT2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00098000)
+#define GPIO3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A4000)
+#define SCC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000AC000)
+#define RNGA_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000B0000)
+#define MMC_SDHC1_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000B4000)
+#define MMC_SDHC2_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000B8000)
+#define MMC_SDHC3_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000BC000)
+#define IPU_CTRL_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000C0000)
+#define AUDMUX_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000C4000)
+#define GPIO1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000CC000)
+#define GPIO2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D0000)
+#define SDMA_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D4000)
+#define RTC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D8000)
+#define WDOG1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DC000)
+#define PWM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E0000)
+#define CAN1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E4000)
+#define CAN2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E8000)
+#define RTIC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000EC000)
+#define IIM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000F0000)
+#define OTG_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000F4000)
+#define MLB_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000F8000)
+
+/*
+ * ROMP and AVIC
+ */
+#define ROMP_BASE_ADDR		0x60000000
+#define ROMP_BASE_ADDR_VIRT	0xF8800000
+#define ROMP_SIZE		SZ_1M
+
+#define AVIC_BASE_ADDR		0x68000000
+#define AVIC_BASE_ADDR_VIRT	0xF8900000
+#define AVIC_SIZE		SZ_1M
+
+/*
+ * SDRAM, WEIM, M3IF, EMI controllers
+ */
+#define X_MEMC_BASE_ADDR	0xB8000000
+#define X_MEMC_BASE_ADDR_VIRT	0xF8A00000
+#define X_MEMC_SIZE		SZ_1M
+
+#define ESDCTL_BASE_ADDR	(X_MEMC_BASE_ADDR + 0x1000)
+#define WEIM_BASE_ADDR		(X_MEMC_BASE_ADDR + 0x2000)
+#define M3IF_BASE_ADDR		(X_MEMC_BASE_ADDR + 0x3000)
+#define EMI_CTL_BASE_ADDR	(X_MEMC_BASE_ADDR + 0x4000)
+
+/*
+ * NFC controller
+ */
+#define NFC_BASE_ADDR		0xBB000000
+#define NFC_BASE_ADDR_VIRT    	0xF8B00000
+#define NFC_SIZE		SZ_1M
+
+/*
+ * Memory regions and CS
+ */
+/* MX35 ADS SDRAM is from 0x80000000, 64M */
+#define IPU_MEM_BASE_ADDR       0x70000000
+#define CSD0_BASE_ADDR          0x80000000
+#define CSD1_BASE_ADDR          0x90000000
+
+#define SDRAM_BASE_ADDR         CSD1_BASE_ADDR
+
+#define CS0_BASE_ADDR           0xA0000000
+#define CS1_BASE_ADDR           0xA8000000
+#define CS2_BASE_ADDR           0xB0000000
+#define CS3_BASE_ADDR           0xB2000000
+#define CS4_BASE_ADDR           0xB4000000
+#define CS5_BASE_ADDR           0xB6000000
+
+/*!
+ * This macro defines the physical to virtual address mapping for all the
+ * peripheral modules. It is used by passing in the physical address as x
+ * and returning the virtual address. If the physical address is not mapped,
+ * it returns 0xDEADBEEF
+ */
+#define IO_ADDRESS(x)   \
+	(((x >= IRAM_BASE_ADDR) && (x < (IRAM_BASE_ADDR + IRAM_SIZE))) ? IRAM_IO_ADDRESS(x):\
+	((x >= AIPS1_BASE_ADDR) && (x < (AIPS1_BASE_ADDR + AIPS1_SIZE))) ? AIPS1_IO_ADDRESS(x):\
+	((x >= SPBA0_BASE_ADDR) && (x < (SPBA0_BASE_ADDR + SPBA0_SIZE))) ? SPBA0_IO_ADDRESS(x):\
+	((x >= AIPS2_BASE_ADDR) && (x < (AIPS2_BASE_ADDR + AIPS2_SIZE))) ? AIPS2_IO_ADDRESS(x):\
+	((x >= ROMP_BASE_ADDR) && (x < (ROMP_BASE_ADDR + ROMP_SIZE))) ? ROMP_IO_ADDRESS(x):\
+	((x >= AVIC_BASE_ADDR) && (x < (AVIC_BASE_ADDR + AVIC_SIZE))) ? AVIC_IO_ADDRESS(x):\
+	((x >= NFC_BASE_ADDR) && (x < (NFC_BASE_ADDR + NFC_SIZE))) ? NFC_IO_ADDRESS(x):\
+	((x >= X_MEMC_BASE_ADDR) && (x < (X_MEMC_BASE_ADDR + X_MEMC_SIZE))) ? X_MEMC_IO_ADDRESS(x):\
+	0xDEADBEEF)
+
+/*
+ * define the address mapping macros: in physical address order
+ */
+
+#define IRAM_IO_ADDRESS(x)  \
+	(((x) - IRAM_BASE_ADDR) + IRAM_BASE_ADDR_VIRT)
+
+#define AIPS1_IO_ADDRESS(x)  \
+	(((x) - AIPS1_BASE_ADDR) + AIPS1_BASE_ADDR_VIRT)
+
+#define SPBA0_IO_ADDRESS(x)  \
+	(((x) - SPBA0_BASE_ADDR) + SPBA0_BASE_ADDR_VIRT)
+
+#define AIPS2_IO_ADDRESS(x)  \
+	(((x) - AIPS2_BASE_ADDR) + AIPS2_BASE_ADDR_VIRT)
+
+#define ROMP_IO_ADDRESS(x)  \
+	(((x) - ROMP_BASE_ADDR) + ROMP_BASE_ADDR_VIRT)
+
+#define AVIC_IO_ADDRESS(x)  \
+	(((x) - AVIC_BASE_ADDR) + AVIC_BASE_ADDR_VIRT)
+
+#define X_MEMC_IO_ADDRESS(x)  \
+	(((x) - X_MEMC_BASE_ADDR) + X_MEMC_BASE_ADDR_VIRT)
+
+#define NFC_IO_ADDRESS(x) \
+	(((x) - NFC_BASE_ADDR) + NFC_BASE_ADDR_VIRT)
+
+/*
+ * DMA request assignments
+ */
+#define DMA_REQ_ASRC_DMA6  41
+#define DMA_REQ_ASRC_DMA5  40
+#define DMA_REQ_ASRC_DMA4  39
+#define DMA_REQ_ASRC_DMA3  38
+#define DMA_REQ_ASRC_DMA2  37
+#define DMA_REQ_ASRC_DMA1  36
+#define DMA_REQ_RSVD3      35
+#define DMA_REQ_RSVD2      34
+#define DMA_REQ_ESAI_TX    33
+#define DMA_REQ_ESAI_RX    32
+#define DMA_REQ_ECT        31
+#define DMA_REQ_NFC        30
+#define DMA_REQ_SSI1_TX1   29
+#define DMA_REQ_SSI1_RX1   28
+#define DMA_REQ_SSI1_TX2   27
+#define DMA_REQ_SSI1_RX2   26
+#define DMA_REQ_SSI2_TX1   25
+#define DMA_REQ_SSI2_RX1   24
+#define DMA_REQ_SSI2_TX2   23
+#define DMA_REQ_SSI2_RX2   22
+#define DMA_REQ_IPU        21
+#define DMA_REQ_RSVD1      20
+#define DMA_REQ_UART1_TX   19
+#define DMA_REQ_UART1_RX   18
+#define DMA_REQ_UART2_TX   17
+#define DMA_REQ_UART2_RX   16
+#define DMA_REQ_EXTREQ1    15
+#define DMA_REQ_EXTREQ2    14
+#define DMA_REQ_SPDIF_TX   13
+#define DMA_REQ_SPDIF_RX   12
+#define DMA_REQ_UART3_TX   11
+#define DMA_REQ_UART3_RX   10
+#define DMA_REQ_CSPI1_TX   9
+#define DMA_REQ_CSPI1_RX   8
+#define DMA_REQ_CSPI2_TX   7
+#define DMA_REQ_CSPI2_RX   6
+#define DMA_REQ_MSHC       5
+#define DMA_REQ_ATA_RX     4
+#define DMA_REQ_ATA_TX     3
+#define DMA_REQ_ATA_TX_END 2
+#define DMA_REQ_DPTC	   1
+#define DMA_REQ_DVFS  	   1
+#define DMA_REQ_EXTREQ0    0
+
+/*
+ * Interrupt numbers
+ */
+#define MXC_INT_BASE			0
+#define MXC_INT_RESV0	            	0
+#define MXC_INT_RESV1               	1
+#define MXC_INT_OWIRE         	    	2
+#define MXC_INT_I2C3                	3
+#define MXC_INT_I2C2                	4
+#define MXC_INT_RESV2	            	5
+#define MXC_INT_RTIC                	6
+#define MXC_INT_MMC_SDHC1           	7
+#define MXC_INT_MMC_SDHC2           	8
+#define MXC_INT_MMC_SDHC3           	9
+#define MXC_INT_I2C                 	10
+#define MXC_INT_SSI1                	11
+#define MXC_INT_SSI2                	12
+#define MXC_INT_CSPI2               	13
+#define MXC_INT_CSPI1               	14
+#define MXC_INT_ATA                 	15
+#define MXC_INT_GPU2D               	16
+#define MXC_INT_ASRC                	17
+#define MXC_INT_UART3               	18
+#define MXC_INT_IIM                 	19
+#define MXC_INT_RESV20              	20
+#define MXC_INT_RESV21              	21
+#define MXC_INT_RNGC                	22
+#define MXC_INT_EVTMON              	23
+#define MXC_INT_KPP                 	24
+#define MXC_INT_RTC                 	25
+#define MXC_INT_PWM                 	26
+#define MXC_INT_EPIT2               	27
+#define MXC_INT_EPIT1               	28
+#define MXC_INT_GPT                 	29
+#define MXC_INT_POWERFAIL           	30
+#define MXC_INT_CCM                 	31
+#define MXC_INT_UART2               	32
+#define MXC_INT_NANDFC              	33
+#define MXC_INT_SDMA                	34
+#define MXC_INT_USB_HS              	35
+#define MXC_INT_RESV36              	36
+#define MXC_INT_USB_OTG             	37
+#define MXC_INT_RESV38              	38
+#define MXC_INT_MSHC1               	39
+#define MXC_INT_ESAI                	40
+#define MXC_INT_IPU_ERR             	41
+#define MXC_INT_IPU_SYN             	42
+#define MXC_INT_CAN1                	43
+#define MXC_INT_CAN2                	44
+#define MXC_INT_UART1               	45
+#define MXC_INT_MLB                 	46
+#define MXC_INT_SPDIF               	47
+#define MXC_INT_ECT                 	48
+#define MXC_INT_SCC_SCM             	49
+#define MXC_INT_SCC_SMN             	50
+#define MXC_INT_GPIO2               	51
+#define MXC_INT_GPIO1               	52
+#define MXC_INT_RESV53              	53
+#define MXC_INT_RESV54              	54
+#define MXC_INT_WDOG                	55
+#define MXC_INT_GPIO3               	56
+#define MXC_INT_FEC                 	57
+#define MXC_INT_EXT_POWER           	58
+#define MXC_INT_EXT_TEMPER          	59
+#define MXC_INT_EXT_SENSOR60        	60
+#define MXC_INT_EXT_SENSOR61        	61
+#define MXC_INT_EXT_WDOG            	62
+#define MXC_INT_EXT_TV              	63
+
+#define MXC_MAX_INT_LINES       	64
+
+/*!
+ * Interrupt Number for ARM11 PMU
+ */
+#define ARM11_PMU_IRQ		MXC_INT_EVTMON
+/* Check this*/
+#define INT_DVFS           	MXC_INT_POWERFAIL
+
+#define	MXC_GPIO_INT_BASE	(MXC_MAX_INT_LINES)
+
+/*!
+ * Number of GPIO port as defined in the IC Spec
+ */
+#define GPIO_PORT_NUM           3
+/*!
+ * Number of GPIO pins per port
+ */
+#define GPIO_NUM_PIN            32
+
+/*!
+ * NFMS bit in RCSR register for pagesize of nandflash
+ */
+#define NFMS		(*((volatile u32 *)IO_ADDRESS(CCM_BASE_ADDR+0xc)))
+#define NFMS_BIT 		30
+#define NFMS_NF_DWIDTH 		31
+#define NFMS_NF_PG_SZ 		30
+
+#endif				/*  __ASM_ARCH_MXC_MX35_H__ */
diff --git a/include/asm-arm/arch-mxc/mx35_pins.h b/include/asm-arm/arch-mxc/mx35_pins.h
new file mode 100644
index 0000000..f019915
--- /dev/null
+++ b/include/asm-arm/arch-mxc/mx35_pins.h
@@ -0,0 +1,347 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX35_PINS_H__
+#define __ASM_ARCH_MXC_MX35_PINS_H__
+
+/*!
+ * @file arch-mxc/mx35_pins.h
+ *
+ * @brief MX35 I/O Pin List
+ *
+ * @ingroup GPIO_MX35
+ */
+
+#ifndef __ASSEMBLY__
+
+/*!
+ * @name IOMUX/PAD Bit field definitions
+ */
+
+/*! @{ */
+
+/*!
+ * In order to identify pins more effectively, each mux-controlled pin's
+ * enumerated value is constructed in the following way:
+ *
+ * -------------------------------------------------------------------
+ * 31-30 | 29 - 25 |24 - 21| 20 - 10| 9 - 0
+ * -------------------------------------------------------------------
+ * IO_P  |  IO_I   | RSVD  | PAD_I | MUX_I
+ * -------------------------------------------------------------------
+ *
+ * Bit 0 to 7 contains MUX_I used to identify the register
+ * offset (base is IOMUX_module_base ) defined in the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. The similar field
+ * definitions are used for the pad control register.the MX35_PIN_A0 is
+ * defined in the enumeration: ( 0x28 << MUX_I) |( 0x368 << PAD_I)
+ * So the absolute address is: IOMUX_module_base + 0x28.
+ * The pad control register offset is: 0x368.
+ */
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio port number (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 1's for error checking in the functions. (gpio port 7 is invalid)
+ */
+#define MUX_IO_P	30
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio offset bit (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 0's since they are don't cares. So for port 2 pin 21, bit 31-24
+ * will be (1 << MUX_IO_P) | (21 << MUX_IO_I).
+ */
+#define MUX_IO_I	25
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * MUX control register offset
+ */
+#define MUX_I		0
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * PAD control register offset
+ */
+#define PAD_I		10
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * reserved filed
+ */
+#define RSVD_I		21
+
+#define NON_GPIO_I	0x3
+#define PIN_TO_MUX_MASK	((1<<(PAD_I - MUX_I)) - 1)
+#define PIN_TO_PAD_MASK	((1<<(RSVD_I - PAD_I)) - 1)
+#define NON_MUX_I	PIN_TO_MUX_MASK
+
+#define _MXC_BUILD_PIN(gp, gi, mi, pi) \
+		(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | \
+		((mi) << MUX_I) | ((pi) << PAD_I))
+
+#define _MXC_BUILD_GPIO_PIN(gp, gi, mi, pi) \
+		_MXC_BUILD_PIN(gp, gi, mi, pi)
+
+#define _MXC_BUILD_NON_GPIO_PIN(mi, pi) \
+		_MXC_BUILD_PIN(NON_GPIO_I, 0, mi, pi)
+
+#define PIN_TO_IOMUX_MUX(pin) ((pin >> MUX_I) & PIN_TO_MUX_MASK)
+#define PIN_TO_IOMUX_PAD(pin) ((pin >> PAD_I) & PIN_TO_PAD_MASK)
+
+/*! @} End IOMUX/PAD Bit field definitions */
+
+/*!
+ * This enumeration is constructed based on the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the MX35 IC Spec. Each enumerated
+ * value is constructed based on the rules described above.
+ */
+typedef enum iomux_pins {
+	MX35_PIN_CAPTURE = _MXC_BUILD_GPIO_PIN(0, 4, 0x4, 0x328),
+	MX35_PIN_COMPARE = _MXC_BUILD_GPIO_PIN(0, 5, 0x8, 0x32C),
+	MX35_PIN_WATCHDOG_RST = _MXC_BUILD_GPIO_PIN(0, 6, 0xC, 0x330),
+	MX35_PIN_GPIO1_0 = _MXC_BUILD_GPIO_PIN(0, 0, 0x10, 0x334),
+	MX35_PIN_GPIO1_1 = _MXC_BUILD_GPIO_PIN(0, 1, 0x14, 0x338),
+	MX35_PIN_GPIO2_0 = _MXC_BUILD_GPIO_PIN(1, 0, 0x18, 0x33C),
+	MX35_PIN_GPIO3_0 = _MXC_BUILD_GPIO_PIN(2, 1, 0x1C, 0x340),
+	MX35_PIN_CLKO = _MXC_BUILD_GPIO_PIN(0, 8, 0x20, 0x34C),
+
+	MX35_PIN_POWER_FAIL = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x360),
+	MX35_PIN_VSTBY = _MXC_BUILD_GPIO_PIN(0, 7, 0x24, 0x364),
+	MX35_PIN_A0 = _MXC_BUILD_NON_GPIO_PIN(0x28, 0x368),
+	MX35_PIN_A1 = _MXC_BUILD_NON_GPIO_PIN(0x2C, 0x36C),
+	MX35_PIN_A2 = _MXC_BUILD_NON_GPIO_PIN(0x30, 0x370),
+	MX35_PIN_A3 = _MXC_BUILD_NON_GPIO_PIN(0x34, 0x374),
+	MX35_PIN_A4 = _MXC_BUILD_NON_GPIO_PIN(0x38, 0x378),
+	MX35_PIN_A5 = _MXC_BUILD_NON_GPIO_PIN(0x3C, 0x37C),
+	MX35_PIN_A6 = _MXC_BUILD_NON_GPIO_PIN(0x40, 0x380),
+	MX35_PIN_A7 = _MXC_BUILD_NON_GPIO_PIN(0x44, 0x384),
+	MX35_PIN_A8 = _MXC_BUILD_NON_GPIO_PIN(0x48, 0x388),
+	MX35_PIN_A9 = _MXC_BUILD_NON_GPIO_PIN(0x4C, 0x38C),
+	MX35_PIN_A10 = _MXC_BUILD_NON_GPIO_PIN(0x50, 0x390),
+	MX35_PIN_MA10 = _MXC_BUILD_NON_GPIO_PIN(0x54, 0x394),
+	MX35_PIN_A11 = _MXC_BUILD_NON_GPIO_PIN(0x58, 0x398),
+	MX35_PIN_A12 = _MXC_BUILD_NON_GPIO_PIN(0x5C, 0x39C),
+	MX35_PIN_A13 = _MXC_BUILD_NON_GPIO_PIN(0x60, 0x3A0),
+	MX35_PIN_A14 = _MXC_BUILD_NON_GPIO_PIN(0x64, 0x3A4),
+	MX35_PIN_A15 = _MXC_BUILD_NON_GPIO_PIN(0x68, 0x3A8),
+	MX35_PIN_A16 = _MXC_BUILD_NON_GPIO_PIN(0x6C, 0x3AC),
+	MX35_PIN_A17 = _MXC_BUILD_NON_GPIO_PIN(0x70, 0x3B0),
+	MX35_PIN_A18 = _MXC_BUILD_NON_GPIO_PIN(0x74, 0x3B4),
+	MX35_PIN_A19 = _MXC_BUILD_NON_GPIO_PIN(0x78, 0x3B8),
+	MX35_PIN_A20 = _MXC_BUILD_NON_GPIO_PIN(0x7C, 0x3BC),
+	MX35_PIN_A21 = _MXC_BUILD_NON_GPIO_PIN(0x80, 0x3C0),
+	MX35_PIN_A22 = _MXC_BUILD_NON_GPIO_PIN(0x84, 0x3C4),
+	MX35_PIN_A23 = _MXC_BUILD_NON_GPIO_PIN(0x88, 0x3C8),
+	MX35_PIN_A24 = _MXC_BUILD_NON_GPIO_PIN(0x8C, 0x3CC),
+	MX35_PIN_A25 = _MXC_BUILD_NON_GPIO_PIN(0x90, 0x3D0),
+
+	MX35_PIN_EB0 = _MXC_BUILD_NON_GPIO_PIN(0x94, 0x46C),
+	MX35_PIN_EB1 = _MXC_BUILD_NON_GPIO_PIN(0x98, 0x470),
+	MX35_PIN_OE = _MXC_BUILD_NON_GPIO_PIN(0x9C, 0x474),
+	MX35_PIN_CS0 = _MXC_BUILD_NON_GPIO_PIN(0xA0, 0x478),
+	MX35_PIN_CS1 = _MXC_BUILD_NON_GPIO_PIN(0xA4, 0x47C),
+	MX35_PIN_CS2 = _MXC_BUILD_NON_GPIO_PIN(0xA8, 0x480),
+	MX35_PIN_CS3 = _MXC_BUILD_NON_GPIO_PIN(0xAC, 0x484),
+	MX35_PIN_CS4 = _MXC_BUILD_GPIO_PIN(0, 20, 0xB0, 0x488),
+	MX35_PIN_CS5 = _MXC_BUILD_GPIO_PIN(0, 21, 0xB4, 0x48C),
+	MX35_PIN_NFCE_B = _MXC_BUILD_GPIO_PIN(0, 22, 0xB8, 0x490),
+
+	MX35_PIN_LBA = _MXC_BUILD_NON_GPIO_PIN(0xBC, 0x498),
+	MX35_PIN_BCLK = _MXC_BUILD_NON_GPIO_PIN(0xC0, 0x49C),
+	MX35_PIN_RW = _MXC_BUILD_NON_GPIO_PIN(0xC4, 0x4A0),
+
+	MX35_PIN_NFWE_B = _MXC_BUILD_GPIO_PIN(0, 18, 0xC8, 0x4CC),
+	MX35_PIN_NFRE_B = _MXC_BUILD_GPIO_PIN(0, 19, 0xCC, 0x4D0),
+	MX35_PIN_NFALE = _MXC_BUILD_GPIO_PIN(0, 20, 0xD0, 0x4D4),
+	MX35_PIN_NFCLE = _MXC_BUILD_GPIO_PIN(0, 21, 0xD4, 0x4D8),
+	MX35_PIN_NFWP_B = _MXC_BUILD_GPIO_PIN(0, 22, 0xD8, 0x4DC),
+	MX35_PIN_NFRB = _MXC_BUILD_GPIO_PIN(0, 23, 0xDC, 0x4E0),
+
+	MX35_PIN_D15 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x4E4),
+	MX35_PIN_D14 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x4E8),
+	MX35_PIN_D13 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x4EC),
+	MX35_PIN_D12 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x4F0),
+	MX35_PIN_D11 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x4F4),
+	MX35_PIN_D10 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x4F8),
+	MX35_PIN_D9 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x4FC),
+	MX35_PIN_D8 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x500),
+	MX35_PIN_D7 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x504),
+	MX35_PIN_D6 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x508),
+	MX35_PIN_D5 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x50C),
+	MX35_PIN_D4 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x510),
+	MX35_PIN_D3 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x514),
+	MX35_PIN_D2 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x518),
+	MX35_PIN_D1 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x51C),
+	MX35_PIN_D0 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x520),
+
+	MX35_PIN_CSI_D8 = _MXC_BUILD_GPIO_PIN(0, 20, 0xE0, 0x524),
+	MX35_PIN_CSI_D9 = _MXC_BUILD_GPIO_PIN(0, 21, 0xE4, 0x528),
+	MX35_PIN_CSI_D10 = _MXC_BUILD_GPIO_PIN(0, 22, 0xE8, 0x52C),
+	MX35_PIN_CSI_D11 = _MXC_BUILD_GPIO_PIN(0, 23, 0xEC, 0x530),
+	MX35_PIN_CSI_D12 = _MXC_BUILD_GPIO_PIN(0, 24, 0xF0, 0x534),
+	MX35_PIN_CSI_D13 = _MXC_BUILD_GPIO_PIN(0, 25, 0xF4, 0x538),
+	MX35_PIN_CSI_D14 = _MXC_BUILD_GPIO_PIN(0, 26, 0xF8, 0x53C),
+	MX35_PIN_CSI_D15 = _MXC_BUILD_GPIO_PIN(0, 27, 0xFC, 0x540),
+	MX35_PIN_CSI_MCLK = _MXC_BUILD_GPIO_PIN(0, 28, 0x100, 0x544),
+	MX35_PIN_CSI_VSYNC = _MXC_BUILD_GPIO_PIN(0, 29, 0x104, 0x548),
+	MX35_PIN_CSI_HSYNC = _MXC_BUILD_GPIO_PIN(0, 30, 0x108, 0x54C),
+	MX35_PIN_CSI_PIXCLK = _MXC_BUILD_GPIO_PIN(0, 31, 0x10C, 0x550),
+
+	MX35_PIN_I2C1_CLK = _MXC_BUILD_GPIO_PIN(1, 24, 0x110, 0x554),
+	MX35_PIN_I2C1_DAT = _MXC_BUILD_GPIO_PIN(1, 25, 0x114, 0x558),
+	MX35_PIN_I2C2_CLK = _MXC_BUILD_GPIO_PIN(1, 26, 0x118, 0x55C),
+	MX35_PIN_I2C2_DAT = _MXC_BUILD_GPIO_PIN(1, 27, 0x11C, 0x560),
+
+	MX35_PIN_STXD4 = _MXC_BUILD_GPIO_PIN(1, 28, 0x120, 0x564),
+	MX35_PIN_SRXD4 = _MXC_BUILD_GPIO_PIN(1, 29, 0x124, 0x568),
+	MX35_PIN_SCK4 = _MXC_BUILD_GPIO_PIN(1, 30, 0x128, 0x56C),
+	MX35_PIN_SXFS4 = _MXC_BUILD_GPIO_PIN(1, 31, 0x12C, 0x570),
+	MX35_PIN_STXD5 = _MXC_BUILD_GPIO_PIN(0, 0, 0x130, 0x574),
+	MX35_PIN_SRXD5 = _MXC_BUILD_GPIO_PIN(0, 1, 0x134, 0x578),
+	MX35_PIN_SCK5 = _MXC_BUILD_GPIO_PIN(0, 2, 0x138, 0x57C),
+	MX35_PIN_SXFS5 = _MXC_BUILD_GPIO_PIN(0, 3, 0x13C, 0x580),
+
+	MX35_PIN_SCKR = _MXC_BUILD_GPIO_PIN(0, 4, 0x140, 0x584),
+	MX35_PIN_FSR = _MXC_BUILD_GPIO_PIN(0, 5, 0x144, 0x588),
+	MX35_PIN_HCKR = _MXC_BUILD_GPIO_PIN(0, 6, 0x148, 0x58C),
+	MX35_PIN_SCKT = _MXC_BUILD_GPIO_PIN(0, 7, 0x14C, 0x590),
+	MX35_PIN_FST = _MXC_BUILD_GPIO_PIN(0, 8, 0x150, 0x594),
+	MX35_PIN_HCKT = _MXC_BUILD_GPIO_PIN(0, 9, 0x154, 0x598),
+	MX35_PIN_TX5_RX0 = _MXC_BUILD_GPIO_PIN(0, 10, 0x158, 0x59C),
+	MX35_PIN_TX4_RX1 = _MXC_BUILD_GPIO_PIN(0, 11, 0x15C, 0x5A0),
+	MX35_PIN_TX3_RX2 = _MXC_BUILD_GPIO_PIN(0, 12, 0x160, 0x5A4),
+	MX35_PIN_TX2_RX3 = _MXC_BUILD_GPIO_PIN(0, 13, 0x164, 0x5A8),
+	MX35_PIN_TX1 = _MXC_BUILD_GPIO_PIN(0, 14, 0x168, 0x5AC),
+	MX35_PIN_TX0 = _MXC_BUILD_GPIO_PIN(0, 15, 0x16C, 0x5B0),
+
+	MX35_PIN_CSPI1_MOSI = _MXC_BUILD_GPIO_PIN(0, 16, 0x170, 0x5B4),
+	MX35_PIN_CSPI1_MISO = _MXC_BUILD_GPIO_PIN(0, 17, 0x174, 0x5B8),
+	MX35_PIN_CSPI1_SS0 = _MXC_BUILD_GPIO_PIN(0, 18, 0x178, 0x5BC),
+	MX35_PIN_CSPI1_SS1 = _MXC_BUILD_GPIO_PIN(0, 19, 0x17C, 0x5C0),
+	MX35_PIN_CSPI1_SCLK = _MXC_BUILD_GPIO_PIN(2, 4, 0x180, 0x5C4),
+	MX35_PIN_CSPI1_SPI_RDY = _MXC_BUILD_GPIO_PIN(2, 5, 0x184, 0x5C8),
+
+	MX35_PIN_RXD1 = _MXC_BUILD_GPIO_PIN(2, 6, 0x188, 0x5CC),
+	MX35_PIN_TXD1 = _MXC_BUILD_GPIO_PIN(2, 7, 0x18C, 0x5D0),
+	MX35_PIN_RTS1 = _MXC_BUILD_GPIO_PIN(2, 8, 0x190, 0x5D4),
+	MX35_PIN_CTS1 = _MXC_BUILD_GPIO_PIN(2, 9, 0x194, 0x5D8),
+	MX35_PIN_RXD2 = _MXC_BUILD_GPIO_PIN(2, 10, 0x198, 0x5DC),
+	MX35_PIN_TXD2 = _MXC_BUILD_GPIO_PIN(1, 11, 0x19C, 0x5E0),
+	MX35_PIN_RTS2 = _MXC_BUILD_GPIO_PIN(1, 12, 0x1A0, 0x5E4),
+	MX35_PIN_CTS2 = _MXC_BUILD_GPIO_PIN(1, 13, 0x1A4, 0x5E8),
+
+	MX35_PIN_USBOTG_PWR = _MXC_BUILD_GPIO_PIN(2, 14, 0x1A8, 0x60C),
+	MX35_PIN_USBOTG_OC = _MXC_BUILD_GPIO_PIN(2, 15, 0x1AC, 0x610),
+
+	MX35_PIN_LD0 = _MXC_BUILD_GPIO_PIN(1, 0, 0x1B0, 0x614),
+	MX35_PIN_LD1 = _MXC_BUILD_GPIO_PIN(1, 1, 0x1B4, 0x618),
+	MX35_PIN_LD2 = _MXC_BUILD_GPIO_PIN(1, 2, 0x1B8, 0x61C),
+	MX35_PIN_LD3 = _MXC_BUILD_GPIO_PIN(1, 3, 0x1BC, 0x620),
+	MX35_PIN_LD4 = _MXC_BUILD_GPIO_PIN(1, 4, 0x1C0, 0x624),
+	MX35_PIN_LD5 = _MXC_BUILD_GPIO_PIN(1, 5, 0x1C4, 0x628),
+	MX35_PIN_LD6 = _MXC_BUILD_GPIO_PIN(1, 6, 0x1C8, 0x62C),
+	MX35_PIN_LD7 = _MXC_BUILD_GPIO_PIN(1, 7, 0x1CC, 0x630),
+	MX35_PIN_LD8 = _MXC_BUILD_GPIO_PIN(1, 8, 0x1D0, 0x634),
+	MX35_PIN_LD9 = _MXC_BUILD_GPIO_PIN(1, 9, 0x1D4, 0x638),
+	MX35_PIN_LD10 = _MXC_BUILD_GPIO_PIN(1, 10, 0x1D8, 0x63C),
+	MX35_PIN_LD11 = _MXC_BUILD_GPIO_PIN(1, 11, 0x1DC, 0x640),
+	MX35_PIN_LD12 = _MXC_BUILD_GPIO_PIN(1, 12, 0x1E0, 0x644),
+	MX35_PIN_LD13 = _MXC_BUILD_GPIO_PIN(1, 13, 0x1E4, 0x648),
+	MX35_PIN_LD14 = _MXC_BUILD_GPIO_PIN(1, 14, 0x1E8, 0x64C),
+	MX35_PIN_LD15 = _MXC_BUILD_GPIO_PIN(1, 15, 0x1EC, 0x650),
+	MX35_PIN_LD16 = _MXC_BUILD_GPIO_PIN(1, 16, 0x1F0, 0x654),
+	MX35_PIN_LD17 = _MXC_BUILD_GPIO_PIN(1, 17, 0x1F4, 0x658),
+	MX35_PIN_LD18 = _MXC_BUILD_GPIO_PIN(2, 24, 0x1F8, 0x65C),
+	MX35_PIN_LD19 = _MXC_BUILD_GPIO_PIN(2, 25, 0x1FC, 0x660),
+	MX35_PIN_LD20 = _MXC_BUILD_GPIO_PIN(2, 26, 0x200, 0x664),
+	MX35_PIN_LD21 = _MXC_BUILD_GPIO_PIN(2, 27, 0x204, 0x668),
+	MX35_PIN_LD22 = _MXC_BUILD_GPIO_PIN(2, 28, 0x208, 0x66C),
+	MX35_PIN_LD23 = _MXC_BUILD_GPIO_PIN(2, 29, 0x20C, 0x670),
+
+	MX35_PIN_D3_HSYNC = _MXC_BUILD_GPIO_PIN(2, 30, 0x210, 0x674),
+	MX35_PIN_D3_FPSHIFT = _MXC_BUILD_GPIO_PIN(2, 31, 0x214, 0x678),
+	MX35_PIN_D3_DRDY = _MXC_BUILD_GPIO_PIN(0, 0, 0x218, 0x67C),
+	MX35_PIN_CONTRAST = _MXC_BUILD_GPIO_PIN(0, 1, 0x21C, 0x680),
+	MX35_PIN_D3_VSYNC = _MXC_BUILD_GPIO_PIN(0, 2, 0x220, 0x684),
+	MX35_PIN_D3_REV = _MXC_BUILD_GPIO_PIN(0, 3, 0x224, 0x688),
+	MX35_PIN_D3_CLS = _MXC_BUILD_GPIO_PIN(0, 4, 0x228, 0x68C),
+	MX35_PIN_D3_SPL = _MXC_BUILD_GPIO_PIN(0, 5, 0x22C, 0x690),
+
+	MX35_PIN_SD1_CMD = _MXC_BUILD_GPIO_PIN(0, 6, 0x230, 0x694),
+	MX35_PIN_SD1_CLK = _MXC_BUILD_GPIO_PIN(0, 7, 0x234, 0x698),
+	MX35_PIN_SD1_DATA0 = _MXC_BUILD_GPIO_PIN(0, 8, 0x238, 0x69C),
+	MX35_PIN_SD1_DATA1 = _MXC_BUILD_GPIO_PIN(0, 9, 0x23C, 0x6A0),
+	MX35_PIN_SD1_DATA2 = _MXC_BUILD_GPIO_PIN(0, 10, 0x240, 0x6A4),
+	MX35_PIN_SD1_DATA3 = _MXC_BUILD_GPIO_PIN(0, 11, 0x244, 0x6A8),
+	MX35_PIN_SD2_CMD = _MXC_BUILD_GPIO_PIN(1, 0, 0x248, 0x6AC),
+	MX35_PIN_SD2_CLK = _MXC_BUILD_GPIO_PIN(1, 1, 0x24C, 0x6B0),
+	MX35_PIN_SD2_DATA0 = _MXC_BUILD_GPIO_PIN(1, 2, 0x250, 0x6B4),
+	MX35_PIN_SD2_DATA1 = _MXC_BUILD_GPIO_PIN(1, 3, 0x254, 0x6B8),
+	MX35_PIN_SD2_DATA2 = _MXC_BUILD_GPIO_PIN(1, 4, 0x258, 0x6BC),
+	MX35_PIN_SD2_DATA3 = _MXC_BUILD_GPIO_PIN(1, 5, 0x25C, 0x6C0),
+
+	MX35_PIN_ATA_CS0 = _MXC_BUILD_GPIO_PIN(1, 6, 0x260, 0x6C4),
+	MX35_PIN_ATA_CS1 = _MXC_BUILD_GPIO_PIN(1, 7, 0x264, 0x6C8),
+	MX35_PIN_ATA_DIOR = _MXC_BUILD_GPIO_PIN(1, 8, 0x268, 0x6CC),
+	MX35_PIN_ATA_DIOW = _MXC_BUILD_GPIO_PIN(1, 9, 0x26C, 0x6D0),
+	MX35_PIN_ATA_DMACK = _MXC_BUILD_GPIO_PIN(1, 10, 0x270, 0x6D4),
+	MX35_PIN_ATA_RESET_B = _MXC_BUILD_GPIO_PIN(1, 11, 0x274, 0x6D8),
+	MX35_PIN_ATA_IORDY = _MXC_BUILD_GPIO_PIN(1, 12, 0x278, 0x6DC),
+	MX35_PIN_ATA_DATA0 = _MXC_BUILD_GPIO_PIN(1, 13, 0x27C, 0x6E0),
+	MX35_PIN_ATA_DATA1 = _MXC_BUILD_GPIO_PIN(1, 14, 0x280, 0x6E4),
+	MX35_PIN_ATA_DATA2 = _MXC_BUILD_GPIO_PIN(1, 15, 0x284, 0x6E8),
+	MX35_PIN_ATA_DATA3 = _MXC_BUILD_GPIO_PIN(1, 16, 0x288, 0x6EC),
+	MX35_PIN_ATA_DATA4 = _MXC_BUILD_GPIO_PIN(1, 17, 0x28C, 0x6F0),
+	MX35_PIN_ATA_DATA5 = _MXC_BUILD_GPIO_PIN(1, 18, 0x290, 0x6F4),
+	MX35_PIN_ATA_DATA6 = _MXC_BUILD_GPIO_PIN(1, 19, 0x294, 0x6F8),
+	MX35_PIN_ATA_DATA7 = _MXC_BUILD_GPIO_PIN(1, 20, 0x298, 0x6FC),
+	MX35_PIN_ATA_DATA8 = _MXC_BUILD_GPIO_PIN(1, 21, 0x29C, 0x700),
+	MX35_PIN_ATA_DATA9 = _MXC_BUILD_GPIO_PIN(1, 22, 0x2A0, 0x704),
+	MX35_PIN_ATA_DATA10 = _MXC_BUILD_GPIO_PIN(1, 23, 0x2A4, 0x708),
+	MX35_PIN_ATA_DATA11 = _MXC_BUILD_GPIO_PIN(1, 24, 0x2A8, 0x70C),
+	MX35_PIN_ATA_DATA12 = _MXC_BUILD_GPIO_PIN(1, 25, 0x2AC, 0x710),
+	MX35_PIN_ATA_DATA13 = _MXC_BUILD_GPIO_PIN(1, 26, 0x2B0, 0x714),
+	MX35_PIN_ATA_DATA14 = _MXC_BUILD_GPIO_PIN(1, 27, 0x2B4, 0x718),
+	MX35_PIN_ATA_DATA15 = _MXC_BUILD_GPIO_PIN(1, 28, 0x2B8, 0x71C),
+	MX35_PIN_ATA_INTRQ = _MXC_BUILD_GPIO_PIN(1, 29, 0x2BC, 0x720),
+	MX35_PIN_ATA_BUFF_EN = _MXC_BUILD_GPIO_PIN(1, 30, 0x2C0, 0x724),
+	MX35_PIN_ATA_DMARQ = _MXC_BUILD_GPIO_PIN(1, 31, 0x2C4, 0x728),
+	MX35_PIN_ATA_DA0 = _MXC_BUILD_GPIO_PIN(2, 0, 0x2C8, 0x72C),
+	MX35_PIN_ATA_DA1 = _MXC_BUILD_GPIO_PIN(2, 1, 0x2CC, 0x730),
+	MX35_PIN_ATA_DA2 = _MXC_BUILD_GPIO_PIN(2, 2, 0x2D0, 0x734),
+
+	MX35_PIN_MLB_CLK = _MXC_BUILD_GPIO_PIN(2, 3, 0x2D4, 0x738),
+	MX35_PIN_MLB_DAT = _MXC_BUILD_GPIO_PIN(2, 4, 0x2D8, 0x73C),
+	MX35_PIN_MLB_SIG = _MXC_BUILD_GPIO_PIN(2, 5, 0x2DC, 0x740),
+
+	MX35_PIN_FEC_TX_CLK = _MXC_BUILD_GPIO_PIN(2, 6, 0x2E0, 0x744),
+	MX35_PIN_FEC_RX_CLK = _MXC_BUILD_GPIO_PIN(2, 7, 0x2E4, 0x748),
+	MX35_PIN_FEC_RX_DV = _MXC_BUILD_GPIO_PIN(2, 8, 0x2E8, 0x74C),
+	MX35_PIN_FEC_COL = _MXC_BUILD_GPIO_PIN(2, 9, 0x2EC, 0x750),
+	MX35_PIN_FEC_RDATA0 = _MXC_BUILD_GPIO_PIN(2, 10, 0x2F0, 0x754),
+	MX35_PIN_FEC_TDATA0 = _MXC_BUILD_GPIO_PIN(2, 11, 0x2F4, 0x758),
+	MX35_PIN_FEC_TX_EN = _MXC_BUILD_GPIO_PIN(2, 12, 0x2F8, 0x75C),
+	MX35_PIN_FEC_MDC = _MXC_BUILD_GPIO_PIN(2, 13, 0x2FC, 0x760),
+	MX35_PIN_FEC_MDIO = _MXC_BUILD_GPIO_PIN(2, 14, 0x300, 0x764),
+	MX35_PIN_FEC_TX_ERR = _MXC_BUILD_GPIO_PIN(2, 15, 0x304, 0x768),
+	MX35_PIN_FEC_RX_ERR = _MXC_BUILD_GPIO_PIN(2, 16, 0x308, 0x76C),
+	MX35_PIN_FEC_CRS = _MXC_BUILD_GPIO_PIN(2, 17, 0x30C, 0x770),
+	MX35_PIN_FEC_RDATA1 = _MXC_BUILD_GPIO_PIN(2, 18, 0x310, 0x774),
+	MX35_PIN_FEC_TDATA1 = _MXC_BUILD_GPIO_PIN(2, 19, 0x314, 0x778),
+	MX35_PIN_FEC_RDATA2 = _MXC_BUILD_GPIO_PIN(2, 20, 0x318, 0x77C),
+	MX35_PIN_FEC_TDATA2 = _MXC_BUILD_GPIO_PIN(2, 21, 0x31C, 0x780),
+	MX35_PIN_FEC_RDATA3 = _MXC_BUILD_GPIO_PIN(2, 22, 0x320, 0x784),
+	MX35_PIN_FEC_TDATA3 = _MXC_BUILD_GPIO_PIN(2, 23, 0x324, 0x788),
+} iomux_pin_name_t;
+
+#endif
+#endif
diff --git a/include/asm-arm/arch-mxc/sdma.h b/include/asm-arm/arch-mxc/sdma.h
index b218bd1..b72b62e 100644
--- a/include/asm-arm/arch-mxc/sdma.h
+++ b/include/asm-arm/arch-mxc/sdma.h
@@ -66,6 +66,7 @@ typedef enum {
 	per_2_int,		/*!< Peripheral to internal RAM */
 	per_2_emi,		/*!< Peripheral to internal EMI memory */
 	per_2_dsp,		/*!< Peripheral to DSP memory */
+	per_2_per,		/*!< Peripheral to Peripheral */
 	int_2_per,		/*!< Internal RAM to peripheral */
 	int_2_int,		/*!< Internal RAM to Internal RAM */
 	int_2_emi,		/*!< Internal RAM to EMI memory */
@@ -98,10 +99,14 @@ typedef enum {
 	CCM,			/*!< CCM */
 	EXT,			/*!< External peripheral */
 	MSHC,			/*!< Memory Stick Host Controller */
+	MSHC_SP,		/*!< Shared Memory Stick Host Controller */
 	DSP,			/*!< DSP */
 	MEMORY,			/*!< Memory */
 	FIFO_MEMORY,		/*!< FIFO type Memory */
-	SPDIF			/*!< SPDIF */
+	SPDIF,			/*!< SPDIF */
+	IPU_MEMORY,		/*!< IPU Memory */
+	ASRC,			/*!< ASRC */
+	ESAI,			/*!< ESAI */
 } sdma_periphT;
 
 #ifndef TRANSFER_32BIT
@@ -249,9 +254,17 @@ typedef struct {
 	/*! address of mcu_2_mshc script */
 	int mxc_sdma_mcu_2_mshc_addr;
 
+	/*! address of spdif_2_mcu script */
+	int mxc_sdma_spdif_2_mcu_addr;
 	/*! address of mcu_2_spdif script */
 	int mxc_sdma_mcu_2_spdif_addr;
 
+	/*! address of ext_mem_2_ipu script */
+	int mxc_sdma_ext_mem_2_ipu_addr;
+
+	/*! address of descrambler script */
+	int mxc_sdma_descrambler_addr;
+
 	/*! address of dptc_dvfs script */
 	int mxc_sdma_dptc_dvfs_addr;
 
-- 
1.5.4.4

