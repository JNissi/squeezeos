From e3fd2a1d0cc56531c6c1f9db45616b3416de2a20 Mon Sep 17 00:00:00 2001
From: Wallace Wang <r59996@freescale.com>
Date: Mon, 26 May 2008 17:33:59 +0800
Subject: [PATCH] ENGR00077635 Optimize the ASRC driver

Move asrc header file to include/asm-arm/arch-mxc
Remove the 16bit ASRC DMA
Put the clock in the ASRC platform ata
Add dma buffer chain

Signed-off-by: Wallace Wang <r59996@freescale.com>
---
 arch/arm/mach-mx35/devices.c        |   21 ++--
 arch/arm/mach-mx35/dma.c            |  114 ++------------------
 drivers/mxc/asrc/mxc_asrc.c         |  151 ++++++++++++++------------
 drivers/mxc/asrc/mxc_asrc.h         |  199 -----------------------------------
 include/asm-arm/arch-mxc/dma.h      |   18 +--
 include/asm-arm/arch-mxc/mxc.h      |    5 +
 include/asm-arm/arch-mxc/mxc_asrc.h |  198 ++++++++++++++++++++++++++++++++++
 7 files changed, 313 insertions(+), 393 deletions(-)

diff --git a/arch/arm/mach-mx35/devices.c b/arch/arm/mach-mx35/devices.c
index 073a24b..ca95815 100644
--- a/arch/arm/mach-mx35/devices.c
+++ b/arch/arm/mach-mx35/devices.c
@@ -524,11 +524,14 @@ static struct resource asrc_resources[] = {
 	 },
 };
 
-static struct platform_device mxc_alsa_asrc_device = {
+static struct mxc_asrc_platform_data mxc_asrc_data;
+
+static struct platform_device mxc_asrc_device = {
 	.name = "mxc_asrc",
 	.id = 0,
 	.dev = {
 		.release = mxc_nop_release,
+		.platform_data = &mxc_asrc_data,
 		},
 	.num_resources = ARRAY_SIZE(asrc_resources),
 	.resource = asrc_resources,
@@ -536,16 +539,12 @@ static struct platform_device mxc_alsa_asrc_device = {
 
 static inline void mxc_init_asrc(void)
 {
-	struct clk *asrc_clk;
-	struct clk *asrc_audio_clk;
-	asrc_clk = clk_get(NULL, "asrc_clk");
-	clk_enable(asrc_clk);
-	clk_put(asrc_clk);
-	asrc_audio_clk = clk_get(NULL, "asrc_audio_clk");
-	clk_enable(asrc_audio_clk);
-	clk_set_rate(asrc_audio_clk, 768000);
-	clk_put(asrc_audio_clk);
-	platform_device_register(&mxc_alsa_asrc_device);
+	mxc_asrc_data.asrc_core_clk = clk_get(NULL, "asrc_clk");
+	clk_put(mxc_asrc_data.asrc_core_clk);
+	mxc_asrc_data.asrc_audio_clk = clk_get(NULL, "asrc_audio_clk");
+	clk_set_rate(mxc_asrc_data.asrc_audio_clk, 768000);
+	clk_put(mxc_asrc_data.asrc_audio_clk);
+	platform_device_register(&mxc_asrc_device);
 }
 
 static int __init mxc_init_devices(void)
diff --git a/arch/arm/mach-mx35/dma.c b/arch/arm/mach-mx35/dma.c
index 75c1d1c..ccf582b 100644
--- a/arch/arm/mach-mx35/dma.c
+++ b/arch/arm/mach-mx35/dma.c
@@ -515,91 +515,7 @@ static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
 	.chnl_priority = 2,
 };
 
-static mxc_sdma_channel_params_t mxc_sdma_asrca_16bit_rx_params = {
-	.chnl_params = {
-			.watermark_level = MXC_ASRC_FIFO_WML,
-			.per_address = ASRC_BASE_ADDR + MXC_ASRCA_RX_REG,
-			.peripheral_type = ASRC,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_ASRC_DMA1,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_ASRCA_RX,
-	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_asrca_16bit_tx_params = {
-	.chnl_params = {
-			.watermark_level = MXC_ASRC_FIFO_WML,
-			.per_address = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
-			.peripheral_type = ASRC,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_ASRC_DMA4,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_ASRCA_TX,
-	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_asrcb_16bit_rx_params = {
-	.chnl_params = {
-			.watermark_level = MXC_ASRC_FIFO_WML,
-			.per_address = ASRC_BASE_ADDR + MXC_ASRCB_RX_REG,
-			.peripheral_type = ASRC,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_ASRC_DMA2,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_ASRCB_RX,
-	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_asrcb_16bit_tx_params = {
-	.chnl_params = {
-			.watermark_level = MXC_ASRC_FIFO_WML,
-			.per_address = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
-			.peripheral_type = ASRC,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_ASRC_DMA5,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_ASRCB_TX,
-	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_asrcc_16bit_rx_params = {
-	.chnl_params = {
-			.watermark_level = MXC_ASRC_FIFO_WML * 3,
-			.per_address = ASRC_BASE_ADDR + MXC_ASRCC_RX_REG,
-			.peripheral_type = ASRC,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_ASRC_DMA3,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_ASRCC_RX,
-	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_asrcc_16bit_tx_params = {
-	.chnl_params = {
-			.watermark_level = MXC_ASRC_FIFO_WML * 3,
-			.per_address = ASRC_BASE_ADDR + MXC_ASRCC_TX_REG,
-			.peripheral_type = ASRC,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_ASRC_DMA6,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_ASRCC_TX,
-	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_asrca_32bit_rx_params = {
+static mxc_sdma_channel_params_t mxc_sdma_asrca_rx_params = {
 	.chnl_params = {
 			.watermark_level = MXC_ASRC_FIFO_WML,
 			.per_address = ASRC_BASE_ADDR + MXC_ASRCA_RX_REG,
@@ -613,7 +529,7 @@ static mxc_sdma_channel_params_t mxc_sdma_asrca_32bit_rx_params = {
 	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
 };
 
-static mxc_sdma_channel_params_t mxc_sdma_asrca_32bit_tx_params = {
+static mxc_sdma_channel_params_t mxc_sdma_asrca_tx_params = {
 	.chnl_params = {
 			.watermark_level = MXC_ASRC_FIFO_WML,
 			.per_address = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
@@ -627,7 +543,7 @@ static mxc_sdma_channel_params_t mxc_sdma_asrca_32bit_tx_params = {
 	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
 };
 
-static mxc_sdma_channel_params_t mxc_sdma_asrcb_32bit_rx_params = {
+static mxc_sdma_channel_params_t mxc_sdma_asrcb_rx_params = {
 	.chnl_params = {
 			.watermark_level = MXC_ASRC_FIFO_WML,
 			.per_address = ASRC_BASE_ADDR + MXC_ASRCB_RX_REG,
@@ -641,7 +557,7 @@ static mxc_sdma_channel_params_t mxc_sdma_asrcb_32bit_rx_params = {
 	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
 };
 
-static mxc_sdma_channel_params_t mxc_sdma_asrcb_32bit_tx_params = {
+static mxc_sdma_channel_params_t mxc_sdma_asrcb_tx_params = {
 	.chnl_params = {
 			.watermark_level = MXC_ASRC_FIFO_WML,
 			.per_address = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
@@ -655,7 +571,7 @@ static mxc_sdma_channel_params_t mxc_sdma_asrcb_32bit_tx_params = {
 	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
 };
 
-static mxc_sdma_channel_params_t mxc_sdma_asrcc_32bit_rx_params = {
+static mxc_sdma_channel_params_t mxc_sdma_asrcc_rx_params = {
 	.chnl_params = {
 			.watermark_level = MXC_ASRC_FIFO_WML * 3,
 			.per_address = ASRC_BASE_ADDR + MXC_ASRCC_RX_REG,
@@ -669,7 +585,7 @@ static mxc_sdma_channel_params_t mxc_sdma_asrcc_32bit_rx_params = {
 	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
 };
 
-static mxc_sdma_channel_params_t mxc_sdma_asrcc_32bit_tx_params = {
+static mxc_sdma_channel_params_t mxc_sdma_asrcc_tx_params = {
 	.chnl_params = {
 			.watermark_level = MXC_ASRC_FIFO_WML * 3,
 			.per_address = ASRC_BASE_ADDR + MXC_ASRCC_TX_REG,
@@ -717,18 +633,12 @@ static struct mxc_sdma_info_entry_s mxc_sdma_active_dma_info[] = {
 	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
 	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
 	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
-	{MXC_DMA_ASRC_16BIT_A_RX, &mxc_sdma_asrca_16bit_rx_params},
-	{MXC_DMA_ASRC_16BIT_A_TX, &mxc_sdma_asrca_16bit_tx_params},
-	{MXC_DMA_ASRC_16BIT_B_RX, &mxc_sdma_asrcb_16bit_rx_params},
-	{MXC_DMA_ASRC_16BIT_B_TX, &mxc_sdma_asrcb_16bit_tx_params},
-	{MXC_DMA_ASRC_16BIT_C_RX, &mxc_sdma_asrcc_16bit_rx_params},
-	{MXC_DMA_ASRC_16BIT_C_TX, &mxc_sdma_asrcc_16bit_tx_params},
-	{MXC_DMA_ASRC_32BIT_A_RX, &mxc_sdma_asrca_32bit_rx_params},
-	{MXC_DMA_ASRC_32BIT_A_TX, &mxc_sdma_asrca_32bit_tx_params},
-	{MXC_DMA_ASRC_32BIT_B_RX, &mxc_sdma_asrcb_32bit_rx_params},
-	{MXC_DMA_ASRC_32BIT_B_TX, &mxc_sdma_asrcb_32bit_tx_params},
-	{MXC_DMA_ASRC_32BIT_C_RX, &mxc_sdma_asrcc_32bit_rx_params},
-	{MXC_DMA_ASRC_32BIT_C_TX, &mxc_sdma_asrcc_32bit_tx_params},
+	{MXC_DMA_ASRC_A_RX, &mxc_sdma_asrca_rx_params},
+	{MXC_DMA_ASRC_A_TX, &mxc_sdma_asrca_tx_params},
+	{MXC_DMA_ASRC_B_RX, &mxc_sdma_asrcb_rx_params},
+	{MXC_DMA_ASRC_B_TX, &mxc_sdma_asrcb_tx_params},
+	{MXC_DMA_ASRC_C_RX, &mxc_sdma_asrcc_rx_params},
+	{MXC_DMA_ASRC_C_TX, &mxc_sdma_asrcc_tx_params},
 	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
 };
 
diff --git a/drivers/mxc/asrc/mxc_asrc.c b/drivers/mxc/asrc/mxc_asrc.c
index 67a7032..9ad3ed4 100644
--- a/drivers/mxc/asrc/mxc_asrc.c
+++ b/drivers/mxc/asrc/mxc_asrc.c
@@ -23,6 +23,7 @@
 #include <linux/platform_device.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/clk.h>
 #include <linux/fs.h>
 #include <linux/slab.h>
 #include <linux/ctype.h>
@@ -31,12 +32,12 @@
 #include <linux/types.h>
 #include <linux/version.h>
 #include <linux/interrupt.h>
-#include <asm/arch/dma.h>
-#include <asm/irq.h>
-#include <asm/memory.h>
 #include <linux/proc_fs.h>
 #include <linux/dma-mapping.h>
-#include "mxc_asrc.h"
+#include <asm/irq.h>
+#include <asm/memory.h>
+#include <asm/arch/dma.h>
+#include <asm/arch/mxc_asrc.h>
 
 static int asrc_major;
 static struct class *asrc_class;
@@ -109,6 +110,7 @@ static const unsigned char asrc_divider_table[] = {
 static struct asrc_data *g_asrc_data;
 static struct proc_dir_entry *proc_asrc;
 static unsigned long asrc_vrt_base_addr;
+static struct mxc_asrc_platform_data *mxc_asrc_data;
 
 static int asrc_set_clock_ratio(enum asrc_pair_index index,
 				int input_sample_rate, int output_sample_rate)
@@ -344,10 +346,11 @@ void asrc_start_conv(enum asrc_pair_index index)
 	unsigned long lock_flags;
 	spin_lock_irqsave(&data_lock, lock_flags);
 	reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCTR_REG);
+	if ((reg & 0x0E) == 0)
+		clk_enable(mxc_asrc_data->asrc_audio_clk);
 	reg |= (1 << (1 + index));
 	__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCTR_REG);
 	spin_unlock_irqrestore(&data_lock, lock_flags);
-
 	return;
 }
 
@@ -358,10 +361,11 @@ void asrc_stop_conv(enum asrc_pair_index index)
 	int reg;
 	unsigned long lock_flags;
 	spin_lock_irqsave(&data_lock, lock_flags);
-
 	reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCTR_REG);
 	reg &= ~(1 << (1 + index));
 	__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCTR_REG);
+	if ((reg & 0x0E) == 0)
+		clk_disable(mxc_asrc_data->asrc_audio_clk);
 	spin_unlock_irqrestore(&data_lock, lock_flags);
 	return;
 }
@@ -468,13 +472,7 @@ static void asrc_input_dma_callback(void *data, int error, unsigned int count)
 
 	params = data;
 	spin_lock_irqsave(&input_int_lock, lock_flags);
-	block = list_entry(params->input_queue.next, struct dma_block, queue);
-	list_del(params->input_queue.next);
-	list_add_tail(&block->queue, &params->input_done_queue);
-	params->input_counter++;
-	if (params->input_counter > 1)
-		pr_info("asrc_input_dma_callback - counter: %d\n",
-			params->input_counter);
+	params->input_queue_empty--;
 	if (!list_empty(&params->input_queue)) {
 		block =
 		    list_entry(params->input_queue.next,
@@ -486,8 +484,11 @@ static void asrc_input_dma_callback(void *data, int error, unsigned int count)
 		mxc_dma_config(params->input_dma_channel, &dma_request,
 			       1, MXC_DMA_MODE_WRITE);
 		mxc_dma_enable(params->input_dma_channel);
-	} else
-		params->input_queue_empty = 1;
+		list_del(params->input_queue.next);
+		list_add_tail(&block->queue, &params->input_done_queue);
+		params->input_queue_empty++;
+	}
+	params->input_counter++;
 	wake_up_interruptible(&params->input_wait_queue);
 	spin_unlock_irqrestore(&input_int_lock, lock_flags);
 	return;
@@ -502,13 +503,7 @@ static void asrc_output_dma_callback(void *data, int error, unsigned int count)
 
 	params = data;
 	spin_lock_irqsave(&output_int_lock, lock_flags);
-	block = list_entry(params->output_queue.next, struct dma_block, queue);
-	list_del(params->output_queue.next);
-	list_add_tail(&block->queue, &params->output_done_queue);
-	params->output_counter++;
-	if (params->output_counter > 1)
-		pr_info("asrc_output_dma_callback - counter: %d\n",
-			params->output_counter);
+	params->output_queue_empty--;
 
 	if (!list_empty(&params->output_queue)) {
 		block =
@@ -521,8 +516,12 @@ static void asrc_output_dma_callback(void *data, int error, unsigned int count)
 		mxc_dma_config(params->output_dma_channel, &dma_request,
 			       1, MXC_DMA_MODE_READ);
 		mxc_dma_enable(params->output_dma_channel);
-	} else
-		params->output_queue_empty = 1;
+		list_del(params->output_queue.next);
+		list_add_tail(&block->queue, &params->output_done_queue);
+		params->output_queue_empty++;
+	}
+
+	params->output_counter++;
 	wake_up_interruptible(&params->output_wait_queue);
 	spin_unlock_irqrestore(&output_int_lock, lock_flags);
 	return;
@@ -661,33 +660,18 @@ static int asrc_ioctl(struct inode *inode, struct file *file,
 
 			/* TBD - need to update when new SDMA interface ready */
 			if (config.pair == ASRC_PAIR_A) {
-				if (config.frame_bits > 16) {
-					rx_id = MXC_DMA_ASRC_32BIT_A_RX;
-					tx_id = MXC_DMA_ASRC_32BIT_A_TX;
-				} else {
-					rx_id = MXC_DMA_ASRC_16BIT_A_RX;
-					tx_id = MXC_DMA_ASRC_16BIT_A_TX;
-				}
+				rx_id = MXC_DMA_ASRC_A_RX;
+				tx_id = MXC_DMA_ASRC_A_TX;
 				rx_name = asrc_pair_id[0];
 				tx_name = asrc_pair_id[1];
 			} else if (config.pair == ASRC_PAIR_B) {
-				if (config.frame_bits > 16) {
-					rx_id = MXC_DMA_ASRC_32BIT_B_RX;
-					tx_id = MXC_DMA_ASRC_32BIT_B_TX;
-				} else {
-					rx_id = MXC_DMA_ASRC_16BIT_B_RX;
-					tx_id = MXC_DMA_ASRC_16BIT_B_TX;
-				}
+				rx_id = MXC_DMA_ASRC_B_RX;
+				tx_id = MXC_DMA_ASRC_B_TX;
 				rx_name = asrc_pair_id[2];
 				tx_name = asrc_pair_id[3];
 			} else {
-				if (config.frame_bits > 16) {
-					rx_id = MXC_DMA_ASRC_32BIT_C_RX;
-					tx_id = MXC_DMA_ASRC_32BIT_C_TX;
-				} else {
-					rx_id = MXC_DMA_ASRC_16BIT_C_RX;
-					tx_id = MXC_DMA_ASRC_16BIT_C_TX;
-				}
+				rx_id = MXC_DMA_ASRC_C_RX;
+				tx_id = MXC_DMA_ASRC_C_TX;
 				rx_name = asrc_pair_id[4];
 				tx_name = asrc_pair_id[5];
 			}
@@ -776,8 +760,7 @@ static int asrc_ioctl(struct inode *inode, struct file *file,
 			params->input_dma[buf.index].length = buf.length;
 			list_add_tail(&params->input_dma[buf.index].
 				      queue, &params->input_queue);
-			if (params->input_queue_empty == 1) {
-				pr_info("INPUT QUEUE empty\n");
+			if (params->input_queue_empty == 0) {
 				block =
 				    list_entry(params->input_queue.next,
 					       struct dma_block, queue);
@@ -791,8 +774,11 @@ static int asrc_ioctl(struct inode *inode, struct file *file,
 					       input_dma_channel,
 					       &dma_request, 1,
 					       MXC_DMA_MODE_WRITE);
-				params->input_queue_empty = 0;
 				mxc_dma_enable(params->input_dma_channel);
+				params->input_queue_empty++;
+				list_del(params->input_queue.next);
+				list_add_tail(&block->queue,
+					      &params->input_done_queue);
 			}
 			spin_unlock_irqrestore(&input_int_lock, lock_flags);
 			break;
@@ -852,8 +838,7 @@ static int asrc_ioctl(struct inode *inode, struct file *file,
 			params->output_dma[buf.index].length = buf.length;
 			list_add_tail(&params->output_dma[buf.index].
 				      queue, &params->output_queue);
-			if (params->output_queue_empty == 1) {
-				pr_info("OUTPUT QUEUE empty\n");
+			if (params->output_queue_empty == 0) {
 				block =
 				    list_entry(params->output_queue.
 					       next, struct dma_block, queue);
@@ -867,8 +852,11 @@ static int asrc_ioctl(struct inode *inode, struct file *file,
 					       output_dma_channel,
 					       &dma_request, 1,
 					       MXC_DMA_MODE_READ);
-				params->output_queue_empty = 0;
 				mxc_dma_enable(params->output_dma_channel);
+				list_del(params->output_queue.next);
+				list_add_tail(&block->queue,
+					      &params->output_done_queue);
+				params->output_queue_empty++;
 			}
 			spin_unlock_irqrestore(&output_int_lock, lock_flags);
 			break;
@@ -930,26 +918,44 @@ static int asrc_ioctl(struct inode *inode, struct file *file,
 				    ("ASRC_START_CONV - no block available\n");
 				break;
 			}
+			while (!list_empty(&params->input_queue)) {
+				block =
+				    list_entry(params->input_queue.next,
+					       struct dma_block, queue);
 
-			block =
-			    list_entry(params->input_queue.next,
-				       struct dma_block, queue);
+				dma_request.num_of_bytes = block->length;
+				dma_request.src_addr =
+				    (dma_addr_t) block->dma_paddr;
+				dma_request.dst_addr =
+				    (ASRC_BASE_ADDR + ASRC_ASRDIA_REG +
+				     (index << 3));
+				mxc_dma_config(params->input_dma_channel,
+					       &dma_request, 1,
+					       MXC_DMA_MODE_WRITE);
+				params->input_queue_empty++;
+				list_del(params->input_queue.next);
+				list_add_tail(&block->queue,
+					      &params->input_done_queue);
+			}
 
-			dma_request.num_of_bytes = block->length;
-			dma_request.src_addr = (dma_addr_t) block->dma_paddr;
-			dma_request.dst_addr =
-			    (ASRC_BASE_ADDR + ASRC_ASRDIA_REG + (index << 3));
-			mxc_dma_config(params->input_dma_channel,
-				       &dma_request, 1, MXC_DMA_MODE_WRITE);
-			block =
-			    list_entry(params->output_queue.next,
-				       struct dma_block, queue);
-			dma_request.num_of_bytes = block->length;
-			dma_request.src_addr =
-			    (ASRC_BASE_ADDR + ASRC_ASRDOA_REG + (index << 3));
-			dma_request.dst_addr = (dma_addr_t) block->dma_paddr;
-			mxc_dma_config(params->output_dma_channel,
-				       &dma_request, 1, MXC_DMA_MODE_READ);
+			while (!list_empty(&params->output_queue)) {
+				block =
+				    list_entry(params->output_queue.next,
+					       struct dma_block, queue);
+				dma_request.num_of_bytes = block->length;
+				dma_request.src_addr =
+				    (ASRC_BASE_ADDR + ASRC_ASRDOA_REG +
+				     (index << 3));
+				dma_request.dst_addr =
+				    (dma_addr_t) block->dma_paddr;
+				mxc_dma_config(params->output_dma_channel,
+					       &dma_request, 1,
+					       MXC_DMA_MODE_READ);
+				params->output_queue_empty++;
+				list_del(params->output_queue.next);
+				list_add_tail(&block->queue,
+					      &params->output_done_queue);
+			}
 			params->asrc_active = 1;
 
 			mxc_dma_enable(params->input_dma_channel);
@@ -1194,6 +1200,10 @@ static int mxc_asrc_probe(struct platform_device *pdev)
 	asrc_vrt_base_addr =
 	    (unsigned long)ioremap(res->start, res->end - res->start + 1);
 
+	mxc_asrc_data =
+	    (struct mxc_asrc_platform_data *)pdev->dev.platform_data;
+	clk_enable(mxc_asrc_data->asrc_core_clk);
+
 	asrc_proc_create();
 	err = mxc_init_asrc();
 	if (err < 0)
@@ -1202,6 +1212,7 @@ static int mxc_asrc_probe(struct platform_device *pdev)
 	goto out;
 
       err_out_class:
+	clk_disable(mxc_asrc_data->asrc_core_clk);
 	class_device_destroy(asrc_class, MKDEV(asrc_major, 0));
 	class_destroy(asrc_class);
       err_out_chrdev:
@@ -1223,6 +1234,8 @@ static int mxc_asrc_remove(struct platform_device *pdev)
 {
 	free_irq(MXC_INT_ASRC, NULL);
 	kfree(g_asrc_data);
+	clk_disable(mxc_asrc_data->asrc_core_clk);
+	mxc_asrc_data = NULL;
 	iounmap((unsigned long __iomem *)asrc_vrt_base_addr);
 	remove_proc_entry(proc_asrc->name, NULL);
 	class_device_destroy(asrc_class, MKDEV(asrc_major, 0));
diff --git a/drivers/mxc/asrc/mxc_asrc.h b/drivers/mxc/asrc/mxc_asrc.h
deleted file mode 100644
index f20dd46..0000000
--- a/drivers/mxc/asrc/mxc_asrc.h
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-/*!
- * @file mx35_asrc.h
- *
- * @brief MX35 Asynchronous Sample Rate Converter
- *
- * @ingroup ??
- */
-
-#ifndef __MXC_ASRC_H__
-#define __MXC_ASRC_H__
-
-#include <asm/semaphore.h>
-
-#define ASRC_ASRCTR_REG 	0x00
-#define ASRC_ASRIER_REG 	0x04
-#define ASRC_ASRCNCR_REG 	0x0C
-#define ASRC_ASRCFG_REG 	0x10
-#define ASRC_ASRCSR_REG 	0x14
-#define ASRC_ASRCDR1_REG 	0x18
-#define ASRC_ASRCDR2_REG 	0x1C
-#define ASRC_ASRSTR_REG 	0x20
-#define ASRC_ASRRA_REG 		0x24
-#define ASRC_ASRRB_REG 		0x28
-#define ASRC_ASRRC_REG 		0x2C
-#define ASRC_ASRPM1_REG 	0x40
-#define ASRC_ASRPM2_REG 	0x44
-#define ASRC_ASRPM3_REG 	0x48
-#define ASRC_ASRPM4_REG 	0x4C
-#define ASRC_ASRPM5_REG 	0x50
-#define ASRC_ASRTFR1		0x54
-#define ASRC_ASRCCR_REG 	0x5C
-#define ASRC_ASRDIA_REG 	0x60
-#define ASRC_ASRDOA_REG 	0x64
-#define ASRC_ASRDIB_REG 	0x68
-#define ASRC_ASRDOB_REG 	0x6C
-#define ASRC_ASRDIC_REG 	0x70
-#define ASRC_ASRDOC_REG 	0x74
-#define ASRC_ASRIDRHA_REG 	0x80
-#define ASRC_ASRIDRLA_REG 	0x84
-#define ASRC_ASRIDRHB_REG 	0x88
-#define ASRC_ASRIDRLB_REG 	0x8C
-#define ASRC_ASRIDRHC_REG 	0x90
-#define ASRC_ASRIDRLC_REG 	0x94
-#define ASRC_ASR76K_REG 	0x98
-#define ASRC_ASR56K_REG 	0x9C
-
-#define ASRC_DMA_BUFFER_NUM 8
-
-/*ASRC driver enum and architecture */
-enum asrc_pair_index {
-	ASRC_PAIR_A,
-	ASRC_PAIR_B,
-	ASRC_PAIR_C
-};
-
-enum asrc_inclk {
-	INCLK_NONE = 0x03,
-	INCLK_ESAI_RX = 0x00,
-	INCLK_SSI1_RX = 0x01,
-	INCLK_SSI2_RX = 0x02,
-	INCLK_SPDIF_RX = 0x04,
-	INCLK_MLB_CLK = 0x05,
-	INCLK_ESAI_TX = 0x08,
-	INCLK_SSI1_TX = 0x09,
-	INCLK_SSI2_TX = 0x0a,
-	INCLK_SPDIF_TX = 0x0c,
-	INCLK_ASRCK1_CLK = 0x0f,
-};
-
-enum asrc_outclk {
-	OUTCLK_NONE = 0x03,
-	OUTCLK_ESAI_TX = 0x00,
-	OUTCLK_SSI1_TX = 0x01,
-	OUTCLK_SSI2_TX = 0x02,
-	OUTCLK_SPDIF_TX = 0x04,
-	OUTCLK_MLB_CLK = 0x05,
-	OUTCLK_ESAI_RX = 0x08,
-	OUTCLK_SSI1_RX = 0x09,
-	OUTCLK_SSI2_RX = 0x0a,
-	OUTCLK_SPDIF_RX = 0x0c,
-	OUTCLK_ASRCK1_CLK = 0x0f,
-};
-
-struct asrc_config {
-	enum asrc_pair_index pair;
-	unsigned int frame_bits;
-	unsigned int channel_num;
-	unsigned int buffer_num;
-	unsigned int dma_buffer_size;
-	unsigned int input_sample_rate;
-	unsigned int output_sample_rate;
-	enum asrc_inclk inclk;
-	enum asrc_outclk outclk;
-};
-
-struct asrc_pair {
-	unsigned int start_channel;
-	unsigned int chn_num;
-	unsigned int chn_max;
-	unsigned int active;
-};
-
-struct asrc_data {
-	struct asrc_pair asrc_pair[3];
-};
-
-/*Stream interface structure */
-struct asrc_req {
-	unsigned int chn_num;
-	enum asrc_pair_index index;
-};
-
-struct asrc_querybuf {
-	unsigned int buffer_index;
-	unsigned int input_length;
-	unsigned int output_length;
-	unsigned long input_offset;
-	unsigned long output_offset;
-};
-
-struct asrc_buffer {
-	unsigned int index;
-	unsigned int length;
-};
-
-struct dma_block {
-	unsigned int index;
-	unsigned int length;
-	unsigned char *dma_vaddr;
-	dma_addr_t dma_paddr;
-	struct list_head queue;
-};
-
-struct asrc_pair_params {
-	enum asrc_pair_index index;
-	struct list_head input_queue;
-	struct list_head input_done_queue;
-	struct list_head output_queue;
-	struct list_head output_done_queue;
-	wait_queue_head_t input_wait_queue;
-	wait_queue_head_t output_wait_queue;
-	unsigned int input_counter;
-	unsigned int output_counter;
-	unsigned int input_queue_empty;
-	unsigned int output_queue_empty;
-	unsigned int input_dma_channel;
-	unsigned int output_dma_channel;
-	unsigned int input_buffer_size;
-	unsigned int output_buffer_size;
-	unsigned int buffer_num;
-	unsigned int pair_hold;
-	unsigned int asrc_active;
-	struct dma_block input_dma[ASRC_DMA_BUFFER_NUM];
-	struct dma_block output_dma[ASRC_DMA_BUFFER_NUM];
-	struct semaphore busy_lock;
-};
-
-char *asrc_pair_id[] = {
-	[0] = "ASRC RX PAIR A",
-	[1] = "ASRC TX PAIR A",
-	[2] = "ASRC RX PAIR B",
-	[3] = "ASRC TX PAIR B",
-	[4] = "ASRC RX PAIR C",
-	[5] = "ASRC TX PAIR C",
-};
-
-#define ASRC_IOC_MAGIC	'C'
-
-#define ASRC_REQ_PAIR	_IOWR(ASRC_IOC_MAGIC, 0, struct asrc_req)
-#define ASRC_CONIFG_PAIR	_IOWR(ASRC_IOC_MAGIC, 1, struct asrc_config)
-#define ASRC_RELEASE_PAIR	_IOW(ASRC_IOC_MAGIC, 2, enum asrc_pair_index)
-#define ASRC_QUERYBUF	_IOWR(ASRC_IOC_MAGIC, 3, struct asrc_buffer)
-#define ASRC_Q_INBUF	_IOW(ASRC_IOC_MAGIC, 4, struct asrc_buffer)
-#define ASRC_DQ_INBUF	_IOW(ASRC_IOC_MAGIC, 5, struct asrc_buffer)
-#define ASRC_Q_OUTBUF	_IOW(ASRC_IOC_MAGIC, 6, struct asrc_buffer)
-#define ASRC_DQ_OUTBUF	_IOW(ASRC_IOC_MAGIC, 7, struct asrc_buffer)
-#define ASRC_START_CONV	_IOW(ASRC_IOC_MAGIC, 8, enum asrc_pair_index)
-#define ASRC_STOP_CONV	_IOW(ASRC_IOC_MAGIC, 9, enum asrc_pair_index)
-
-extern int asrc_req_pair(int chn_num, enum asrc_pair_index *index);
-extern void asrc_release_pair(enum asrc_pair_index index);
-extern int asrc_config_pair(struct asrc_config *config);
-extern void asrc_start_conv(enum asrc_pair_index index);
-extern void asrc_stop_conv(enum asrc_pair_index index);
-
-#endif				/* __MXC_ASRC_H__ */
diff --git a/include/asm-arm/arch-mxc/dma.h b/include/asm-arm/arch-mxc/dma.h
index 212ffcd..de8c55b 100644
--- a/include/asm-arm/arch-mxc/dma.h
+++ b/include/asm-arm/arch-mxc/dma.h
@@ -91,18 +91,12 @@ typedef enum mxc_dma_device {
 	MXC_DMA_SPDIF_16BIT_RX,
 	MXC_DMA_SPDIF_32BIT_TX,
 	MXC_DMA_SPDIF_32BIT_RX,
-	MXC_DMA_ASRC_16BIT_A_RX,
-	MXC_DMA_ASRC_16BIT_A_TX,
-	MXC_DMA_ASRC_16BIT_B_RX,
-	MXC_DMA_ASRC_16BIT_B_TX,
-	MXC_DMA_ASRC_16BIT_C_RX,
-	MXC_DMA_ASRC_16BIT_C_TX,
-	MXC_DMA_ASRC_32BIT_A_RX,
-	MXC_DMA_ASRC_32BIT_A_TX,
-	MXC_DMA_ASRC_32BIT_B_RX,
-	MXC_DMA_ASRC_32BIT_B_TX,
-	MXC_DMA_ASRC_32BIT_C_RX,
-	MXC_DMA_ASRC_32BIT_C_TX,
+	MXC_DMA_ASRC_A_RX,
+	MXC_DMA_ASRC_A_TX,
+	MXC_DMA_ASRC_B_RX,
+	MXC_DMA_ASRC_B_TX,
+	MXC_DMA_ASRC_C_RX,
+	MXC_DMA_ASRC_C_TX,
 	MXC_DMA_TEST_RAM2D2RAM,
 	MXC_DMA_TEST_RAM2RAM2D,
 	MXC_DMA_TEST_RAM2D2RAM2D,
diff --git a/include/asm-arm/arch-mxc/mxc.h b/include/asm-arm/arch-mxc/mxc.h
index 7752418..b78ab7d 100644
--- a/include/asm-arm/arch-mxc/mxc.h
+++ b/include/asm-arm/arch-mxc/mxc.h
@@ -98,6 +98,11 @@ struct mxc_spdif_platform_data {
 	struct clk *spdif_core_clk;
 };
 
+struct mxc_asrc_platform_data {
+	struct clk *asrc_core_clk;
+	struct clk *asrc_audio_clk;
+};
+
 struct mxc_lcd_platform_data {
 	char *io_reg;
 	char *core_reg;
diff --git a/include/asm-arm/arch-mxc/mxc_asrc.h b/include/asm-arm/arch-mxc/mxc_asrc.h
new file mode 100644
index 0000000..5a47691
--- /dev/null
+++ b/include/asm-arm/arch-mxc/mxc_asrc.h
@@ -0,0 +1,198 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx35_asrc.h
+ *
+ * @brief MX35 Asynchronous Sample Rate Converter
+ *
+ * @ingroup ??
+ */
+
+#ifndef __MXC_ASRC_H__
+#define __MXC_ASRC_H__
+
+#define ASRC_IOC_MAGIC	'C'
+
+#define ASRC_REQ_PAIR	_IOWR(ASRC_IOC_MAGIC, 0, struct asrc_req)
+#define ASRC_CONIFG_PAIR	_IOWR(ASRC_IOC_MAGIC, 1, struct asrc_config)
+#define ASRC_RELEASE_PAIR	_IOW(ASRC_IOC_MAGIC, 2, enum asrc_pair_index)
+#define ASRC_QUERYBUF	_IOWR(ASRC_IOC_MAGIC, 3, struct asrc_buffer)
+#define ASRC_Q_INBUF	_IOW(ASRC_IOC_MAGIC, 4, struct asrc_buffer)
+#define ASRC_DQ_INBUF	_IOW(ASRC_IOC_MAGIC, 5, struct asrc_buffer)
+#define ASRC_Q_OUTBUF	_IOW(ASRC_IOC_MAGIC, 6, struct asrc_buffer)
+#define ASRC_DQ_OUTBUF	_IOW(ASRC_IOC_MAGIC, 7, struct asrc_buffer)
+#define ASRC_START_CONV	_IOW(ASRC_IOC_MAGIC, 8, enum asrc_pair_index)
+#define ASRC_STOP_CONV	_IOW(ASRC_IOC_MAGIC, 9, enum asrc_pair_index)
+
+enum asrc_pair_index {
+	ASRC_PAIR_A,
+	ASRC_PAIR_B,
+	ASRC_PAIR_C
+};
+
+enum asrc_inclk {
+	INCLK_NONE = 0x03,
+	INCLK_ESAI_RX = 0x00,
+	INCLK_SSI1_RX = 0x01,
+	INCLK_SSI2_RX = 0x02,
+	INCLK_SPDIF_RX = 0x04,
+	INCLK_MLB_CLK = 0x05,
+	INCLK_ESAI_TX = 0x08,
+	INCLK_SSI1_TX = 0x09,
+	INCLK_SSI2_TX = 0x0a,
+	INCLK_SPDIF_TX = 0x0c,
+	INCLK_ASRCK1_CLK = 0x0f,
+};
+
+enum asrc_outclk {
+	OUTCLK_NONE = 0x03,
+	OUTCLK_ESAI_TX = 0x00,
+	OUTCLK_SSI1_TX = 0x01,
+	OUTCLK_SSI2_TX = 0x02,
+	OUTCLK_SPDIF_TX = 0x04,
+	OUTCLK_MLB_CLK = 0x05,
+	OUTCLK_ESAI_RX = 0x08,
+	OUTCLK_SSI1_RX = 0x09,
+	OUTCLK_SSI2_RX = 0x0a,
+	OUTCLK_SPDIF_RX = 0x0c,
+	OUTCLK_ASRCK1_CLK = 0x0f,
+};
+
+struct asrc_config {
+	enum asrc_pair_index pair;
+	unsigned int channel_num;
+	unsigned int buffer_num;
+	unsigned int dma_buffer_size;
+	unsigned int input_sample_rate;
+	unsigned int output_sample_rate;
+	enum asrc_inclk inclk;
+	enum asrc_outclk outclk;
+};
+
+struct asrc_pair {
+	unsigned int start_channel;
+	unsigned int chn_num;
+	unsigned int chn_max;
+	unsigned int active;
+};
+
+struct asrc_req {
+	unsigned int chn_num;
+	enum asrc_pair_index index;
+};
+
+struct asrc_querybuf {
+	unsigned int buffer_index;
+	unsigned int input_length;
+	unsigned int output_length;
+	unsigned long input_offset;
+	unsigned long output_offset;
+};
+
+struct asrc_buffer {
+	unsigned int index;
+	unsigned int length;
+};
+
+#ifdef __KERNEL__
+
+#define ASRC_DMA_BUFFER_NUM 8
+
+#define ASRC_ASRCTR_REG 	0x00
+#define ASRC_ASRIER_REG 	0x04
+#define ASRC_ASRCNCR_REG 	0x0C
+#define ASRC_ASRCFG_REG 	0x10
+#define ASRC_ASRCSR_REG 	0x14
+#define ASRC_ASRCDR1_REG 	0x18
+#define ASRC_ASRCDR2_REG 	0x1C
+#define ASRC_ASRSTR_REG 	0x20
+#define ASRC_ASRRA_REG 		0x24
+#define ASRC_ASRRB_REG 		0x28
+#define ASRC_ASRRC_REG 		0x2C
+#define ASRC_ASRPM1_REG 	0x40
+#define ASRC_ASRPM2_REG 	0x44
+#define ASRC_ASRPM3_REG 	0x48
+#define ASRC_ASRPM4_REG 	0x4C
+#define ASRC_ASRPM5_REG 	0x50
+#define ASRC_ASRTFR1		0x54
+#define ASRC_ASRCCR_REG 	0x5C
+#define ASRC_ASRDIA_REG 	0x60
+#define ASRC_ASRDOA_REG 	0x64
+#define ASRC_ASRDIB_REG 	0x68
+#define ASRC_ASRDOB_REG 	0x6C
+#define ASRC_ASRDIC_REG 	0x70
+#define ASRC_ASRDOC_REG 	0x74
+#define ASRC_ASRIDRHA_REG 	0x80
+#define ASRC_ASRIDRLA_REG 	0x84
+#define ASRC_ASRIDRHB_REG 	0x88
+#define ASRC_ASRIDRLB_REG 	0x8C
+#define ASRC_ASRIDRHC_REG 	0x90
+#define ASRC_ASRIDRLC_REG 	0x94
+#define ASRC_ASR76K_REG 	0x98
+#define ASRC_ASR56K_REG 	0x9C
+
+struct dma_block {
+	unsigned int index;
+	unsigned int length;
+	unsigned char *dma_vaddr;
+	dma_addr_t dma_paddr;
+	struct list_head queue;
+};
+
+struct asrc_pair_params {
+	enum asrc_pair_index index;
+	struct list_head input_queue;
+	struct list_head input_done_queue;
+	struct list_head output_queue;
+	struct list_head output_done_queue;
+	wait_queue_head_t input_wait_queue;
+	wait_queue_head_t output_wait_queue;
+	unsigned int input_counter;
+	unsigned int output_counter;
+	unsigned int input_queue_empty;
+	unsigned int output_queue_empty;
+	unsigned int input_dma_channel;
+	unsigned int output_dma_channel;
+	unsigned int input_buffer_size;
+	unsigned int output_buffer_size;
+	unsigned int buffer_num;
+	unsigned int pair_hold;
+	unsigned int asrc_active;
+	struct dma_block input_dma[ASRC_DMA_BUFFER_NUM];
+	struct dma_block output_dma[ASRC_DMA_BUFFER_NUM];
+	struct semaphore busy_lock;
+};
+
+struct asrc_data {
+	struct asrc_pair asrc_pair[3];
+};
+
+char *asrc_pair_id[] = {
+	[0] = "ASRC RX PAIR A",
+	[1] = "ASRC TX PAIR A",
+	[2] = "ASRC RX PAIR B",
+	[3] = "ASRC TX PAIR B",
+	[4] = "ASRC RX PAIR C",
+	[5] = "ASRC TX PAIR C",
+};
+
+extern int asrc_req_pair(int chn_num, enum asrc_pair_index *index);
+extern void asrc_release_pair(enum asrc_pair_index index);
+extern int asrc_config_pair(struct asrc_config *config);
+extern void asrc_start_conv(enum asrc_pair_index index);
+extern void asrc_stop_conv(enum asrc_pair_index index);
+
+#endif				/* __kERNEL__ */
+
+#endif				/* __MXC_ASRC_H__ */
-- 
1.5.4.4

