From d325d8abd1aad678421620da3c4b058cd2be8538 Mon Sep 17 00:00:00 2001
From: Jingyu Zhou <b02241@freescale.com>
Date: Wed, 23 Jul 2008 16:43:15 +0800
Subject: [PATCH] ENGR00084893 add audio loopback control

add audio loopback control

Signed-off-by: Zhou Jingyu <Jingyu.Zhou@freescale.com>
---
 drivers/char/mxc_si4702.c             |    6 ----
 drivers/mxc/pmic/mc13783/pmic_audio.c |    1 -
 sound/arm/mxc-alsa-mixer.c            |   50 +++++++++++++++++++++++++++++++++
 sound/soc/codecs/ak4647.c             |   34 +++++++++++++++++++++-
 4 files changed, 83 insertions(+), 8 deletions(-)

diff --git a/drivers/char/mxc_si4702.c b/drivers/char/mxc_si4702.c
index 6b5641e..fce241a 100644
--- a/drivers/char/mxc_si4702.c
+++ b/drivers/char/mxc_si4702.c
@@ -25,7 +25,6 @@
 #include <linux/err.h>
 #include <linux/mxc_si4702.h>
 #include <asm-arm/arch-mxc/mxc.h>
-#include <asm-arm/arch-mxc/pmic_audio.h>
 
 #define SI4702_DEV_NAME		"si4702"
 #define DEV_MAJOR		0
@@ -636,12 +635,10 @@ static int cmd(unsigned int index)
 	case FM_SHUTDOWN:
 		dev_err(&si4702_client->dev, "FM_SHUTDOWN\n");
 		si4702_shutdown();
-		pmic_audio_fm_output_enable(0);
 		break;
 	case FM_STARTUP:
 		dev_err(&si4702_client->dev, "FM_STARTUP\n");
 		plat_data->reset();
-		pmic_audio_fm_output_enable(1);
 		si4702_startup();
 		break;
 	case FM_RESET:
@@ -853,8 +850,6 @@ static int open_si4702(struct inode *inode, struct file *file)
 		return -ENODEV;
 	}
 
-	pmic_audio_fm_output_enable(1);
-
 	return 0;
 }
 
@@ -866,7 +861,6 @@ static int release_si4702(struct inode *inode, struct file *file)
 	/* inactive, free GPIO, cut power */
 	plat_data->gpio_put();
 
-	pmic_audio_fm_output_enable(0);
 	spin_lock(&count_lock);
 	count--;
 	spin_unlock(&count_lock);
diff --git a/drivers/mxc/pmic/mc13783/pmic_audio.c b/drivers/mxc/pmic/mc13783/pmic_audio.c
index 2495fd9..8db6c41 100644
--- a/drivers/mxc/pmic/mc13783/pmic_audio.c
+++ b/drivers/mxc/pmic/mc13783/pmic_audio.c
@@ -132,7 +132,6 @@ EXPORT_SYMBOL(pmic_audio_output_get_config);
 EXPORT_SYMBOL(pmic_audio_output_enable_phantom_ground);
 EXPORT_SYMBOL(pmic_audio_output_disable_phantom_ground);
 EXPORT_SYMBOL(pmic_audio_set_autodetect);
-EXPORT_SYMBOL(pmic_audio_fm_output_enable);
 #ifdef DEBUG_AUDIO
 EXPORT_SYMBOL(pmic_audio_dump_registers);
 #endif				/* DEBUG_AUDIO */
diff --git a/sound/arm/mxc-alsa-mixer.c b/sound/arm/mxc-alsa-mixer.c
index f11b50c..7ded3fc 100644
--- a/sound/arm/mxc-alsa-mixer.c
+++ b/sound/arm/mxc-alsa-mixer.c
@@ -260,6 +260,43 @@ static int pmic_pb_balance_put(struct snd_kcontrol *kcontrol,
 
 /* Balance control end */
 
+/* loopback control start */
+static int pmic_loopback_info(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_info *uinfo)
+{
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int pmic_loopback_get(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *uvalue)
+{
+	uvalue->value.integer.value[0] = kcontrol->private_value;
+	return 0;
+
+}
+static int pmic_loopback_put(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *uvalue)
+{
+	int changed;
+	long flag = uvalue->value.integer.value[0];
+	changed =
+	    (uvalue->value.integer.value[0] == kcontrol->private_value) ? 0 : 1;
+	kcontrol->private_value = uvalue->value.integer.value[0];
+	if (flag)
+		pmic_audio_fm_output_enable(true);
+	else
+		pmic_audio_fm_output_enable(false);
+
+	return changed;
+}
+
+/* Loopback control end */
+
 /* Kcontrol structure definitions */
 struct snd_kcontrol_new pmic_control_pb_vol __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -318,6 +355,16 @@ struct snd_kcontrol_new pmic_control_ip_sw __devinitdata = {
 	.private_value = 0xffab5,
 };
 
+struct snd_kcontrol_new pmic_control_loop_out __devinitdata = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Loopback Line-in",
+	.index = 0x00,
+	.info = pmic_loopback_info,
+	.get = pmic_loopback_get,
+	.put = pmic_loopback_put,
+	.private_value = 0,
+};
+
 /*!
   * This function registers the control components of ALSA Mixer
   * It is called by ALSA PCM init.
@@ -354,6 +401,9 @@ int mxc_alsa_create_ctl(struct snd_card *card, void *p_value)
 	if ((err =
 	     snd_ctl_add(card, snd_ctl_new1(&pmic_control_ip_sw, p_value))) < 0)
 		return err;
+	err = snd_ctl_add(card, snd_ctl_new1(&pmic_control_loop_out, p_value));
+	if (err < 0)
+		return err;
 
 	return 0;
 }
diff --git a/sound/soc/codecs/ak4647.c b/sound/soc/codecs/ak4647.c
index 172c03c..2c9c365 100644
--- a/sound/soc/codecs/ak4647.c
+++ b/sound/soc/codecs/ak4647.c
@@ -133,6 +133,11 @@ static void dump_all_regs(void)
 }
 #endif
 
+static int loopback_xhandle_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol);
+static int loopback_xhandle_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol);
+
 static const char *ak4647_hp_out[] = { "Stereo", "Mono" };
 
 static const char *ak4647_left_in[] = { "LIN1", "LIN2" };
@@ -148,6 +153,8 @@ static const struct soc_enum ak4647_enum[] = {
 	SOC_ENUM_SINGLE(AK4647_PM3, 2, 2, ak4647_right_in),
 };
 
+#undef snd_soc_info_bool_ext
+#define snd_soc_info_bool_ext		snd_ctl_boolean_mono_info
 static const struct snd_kcontrol_new ak4647_snd_controls[] = {
 	SOC_ENUM("Headphone Output", ak4647_enum[0]),
 	SOC_ENUM("Playback Deemphasis", ak4647_enum[1]),
@@ -165,6 +172,8 @@ static const struct snd_kcontrol_new ak4647_snd_controls[] = {
 		   AK4647_RIGHT_INPUT_VOLUME, 0, 242, 0),
 	SOC_SINGLE("Left Playback Volume", AK4647_LEFT_DGT_VOLUME, 0, 255, 1),
 	SOC_SINGLE("Right Playback Volume", AK4647_RIGHT_DGT_VOLUME, 0, 255, 1),
+	SOC_SINGLE_BOOL_EXT("Loopback Line-in", 0,
+			    loopback_xhandle_get, loopback_xhandle_put),
 };
 
 /* add non dapm controls */
@@ -754,7 +763,30 @@ int pmic_audio_fm_output_enable(bool enable)
 	}
 	return 0;
 }
-EXPORT_SYMBOL(pmic_audio_fm_output_enable);
+
+static int loopback_xhandle_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = kcontrol->private_value;
+	return 0;
+}
+
+static int loopback_xhandle_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	int changed;
+	long flag = ucontrol->value.integer.value[0];
+	changed =
+	    (ucontrol->value.integer.value[0] ==
+	     kcontrol->private_value) ? 0 : 1;
+	kcontrol->private_value = flag;
+	if (flag)
+		pmic_audio_fm_output_enable(true);
+	else
+		pmic_audio_fm_output_enable(false);
+
+	return changed;
+}
 
 subsys_initcall(ak4647_init);
 module_exit(ak4647_exit);
-- 
1.5.4.4

