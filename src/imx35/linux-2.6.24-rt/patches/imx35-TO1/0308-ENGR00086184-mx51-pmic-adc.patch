From fb22ab3bac27cc35ef8f05fd9a7940c2a2b77ccd Mon Sep 17 00:00:00 2001
From: Shen Yong <b00984@freescale.com>
Date: Thu, 31 Jul 2008 16:45:52 +0800
Subject: [PATCH] ENGR00086184 mx51: pmic adc

add pmic mc13892 adc support

Signed-off-by: Kevin Shen <b00984@freescale.com>
---
 arch/arm/configs/imx51_3stack_defconfig  |   25 +-
 arch/arm/mach-mx51/mx51_3stack.c         |    2 +-
 arch/arm/mach-mx51/mx51_3stack_gpio.c    |    9 +-
 drivers/input/touchscreen/Kconfig        |    2 +-
 drivers/mxc/pmic/Kconfig                 |    4 +-
 drivers/mxc/pmic/Makefile                |    2 +-
 drivers/mxc/pmic/core/mc13892.c          |   95 +++-
 drivers/mxc/pmic/core/pmic_core_i2c.c    |   87 +++-
 drivers/mxc/pmic/mc13892/Kconfig         |   48 ++
 drivers/mxc/pmic/mc13892/Makefile        |   10 +
 drivers/mxc/pmic/mc13892/pmic_adc.c      |  975 ++++++++++++++++++++++++++++++
 include/asm-arm/arch-mxc/pmic_external.h |   82 +++-
 12 files changed, 1307 insertions(+), 34 deletions(-)

diff --git a/arch/arm/configs/imx51_3stack_defconfig b/arch/arm/configs/imx51_3stack_defconfig
index 37ad72d..f725a31 100644
--- a/arch/arm/configs/imx51_3stack_defconfig
+++ b/arch/arm/configs/imx51_3stack_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.24
-# Wed Jul 16 16:41:37 2008
+# Wed Jul 30 17:04:37 2008
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -637,7 +637,18 @@ CONFIG_KEYBOARD_MXC=y
 # CONFIG_INPUT_MOUSE is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TABLET is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_MXC=y
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_UCB1400 is not set
 # CONFIG_INPUT_MISC is not set
 
 #
@@ -852,6 +863,12 @@ CONFIG_MXC_PMIC=y
 # MXC PMIC Client Drivers
 #
 CONFIG_MXC_PMIC_MC13892=y
+CONFIG_MXC_MC13892_ADC=y
+CONFIG_MXC_MC13892_RTC=y
+CONFIG_MXC_MC13892_LIGHT=y
+CONFIG_MXC_MC13892_BATTERY=y
+CONFIG_MXC_MC13892_CONNECTIVITY=y
+CONFIG_MXC_MC13892_POWER=y
 
 #
 # Advanced Power Management devices
@@ -883,6 +900,10 @@ CONFIG_MXC_PMIC_MC13892=y
 #
 
 #
+# MXC Bluetooth support
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
diff --git a/arch/arm/mach-mx51/mx51_3stack.c b/arch/arm/mach-mx51/mx51_3stack.c
index 9f8e6da..0f019be 100644
--- a/arch/arm/mach-mx51/mx51_3stack.c
+++ b/arch/arm/mach-mx51/mx51_3stack.c
@@ -231,7 +231,7 @@ static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
 	{
 	 .driver_name = "mc13892",
 	 .addr = 0x08,
-	 .platform_data = (void *)MXC_INT_GPIO1_INT5,
+	 .platform_data = (void *)MX51_PIN_GPIO1_5,
 	 },
 
 };
diff --git a/arch/arm/mach-mx51/mx51_3stack_gpio.c b/arch/arm/mach-mx51/mx51_3stack_gpio.c
index 17c7a3d..66c48d9 100644
--- a/arch/arm/mach-mx51/mx51_3stack_gpio.c
+++ b/arch/arm/mach-mx51/mx51_3stack_gpio.c
@@ -459,7 +459,14 @@ EXPORT_SYMBOL(gpio_i2c_inactive);
 
 void gpio_pmic_active(void)
 {
-	mxc_request_iomux(MX51_PIN_GPIO1_5, IOMUX_CONFIG_GPIO);
+	mxc_request_iomux(MX51_PIN_GPIO1_5, IOMUX_CONFIG_GPIO
+			  | IOMUX_CONFIG_SION);
+	mxc_iomux_set_pad(MX51_PIN_GPIO1_5, PAD_CTL_SRE_SLOW |
+			  PAD_CTL_ODE_OPENDRAIN_NONE |
+			  PAD_CTL_DRV_MEDIUM |
+			  PAD_CTL_100K_PU |
+			  PAD_CTL_HYS_ENABLE |
+			  PAD_CTL_DRV_VOT_HIGH | PAD_CTL_DDR_INPUT_CMOS);
 	mxc_set_gpio_direction(MX51_PIN_GPIO1_5, 1);
 }
 
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 8256537..ab36294 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -136,7 +136,7 @@ config TOUCHSCREEN_HP7XX
 
 config TOUCHSCREEN_MXC
 	tristate "MXC touchscreen input driver"
-	depends on MXC_MC13783_ADC
+	depends on MXC_MC13783_ADC || MXC_MC13892_ADC
 	help
 	  Say Y here if you have an MXC based board with touchscreen
 	  attached to it.
diff --git a/drivers/mxc/pmic/Kconfig b/drivers/mxc/pmic/Kconfig
index 85f3a5d..8b20bf3 100644
--- a/drivers/mxc/pmic/Kconfig
+++ b/drivers/mxc/pmic/Kconfig
@@ -51,6 +51,8 @@ config MXC_PMIC_MC13783
 	This is the MXC MC13783(PMIC) client drivers support. It include
 	ADC, Audio, Battery, Connectivity, Light, Power and RTC.
 
+source "drivers/mxc/pmic/mc13783/Kconfig"
+
 config MXC_PMIC_MC13892
 	tristate "MC13892 Client Drivers"
 	depends on MXC_I2C_PMIC_CORE
@@ -59,7 +61,7 @@ config MXC_PMIC_MC13892
 	This is the MXC MC13892(PMIC) client drivers support. It include
 	ADC, Battery, Connectivity, Light, Power and RTC.
 
-source "drivers/mxc/pmic/mc13783/Kconfig"
+source "drivers/mxc/pmic/mc13892/Kconfig"
 
 config MXC_PMIC_SC55112
 	tristate "SC55112 Client Drivers"
diff --git a/drivers/mxc/pmic/Makefile b/drivers/mxc/pmic/Makefile
index b4b1076..8908576 100644
--- a/drivers/mxc/pmic/Makefile
+++ b/drivers/mxc/pmic/Makefile
@@ -4,6 +4,6 @@
 
 obj-y				+= core/
 obj-$(CONFIG_MXC_PMIC_MC13783)	+= mc13783/
-#obj-$(CONFIG_MXC_PMIC_MC13892)	+= mc13892/
+obj-$(CONFIG_MXC_PMIC_MC13892)	+= mc13892/
 obj-$(CONFIG_MXC_PMIC_MC9SDZ60) += mc9sdz60/
 
diff --git a/drivers/mxc/pmic/core/mc13892.c b/drivers/mxc/pmic/core/mc13892.c
index ff88728..8613c1f 100644
--- a/drivers/mxc/pmic/core/mc13892.c
+++ b/drivers/mxc/pmic/core/mc13892.c
@@ -93,20 +93,109 @@ int pmic_write(int reg_num, const unsigned int reg_val)
 
 int pmic_init_registers(void)
 {
+	CHECK_ERROR(pmic_write(REG_INT_MASK0, 0xFFFFFF));
+	CHECK_ERROR(pmic_write(REG_INT_MASK0, 0xFFFFFF));
+	CHECK_ERROR(pmic_write(REG_INT_STATUS0, 0xFFFFFF));
+	CHECK_ERROR(pmic_write(REG_INT_STATUS1, 0xFFFFFF));
+
 	return PMIC_SUCCESS;
 }
 
+static unsigned int events_enabled0;
+static unsigned int events_enabled1;
+
 unsigned int pmic_get_active_events(unsigned int *active_events)
 {
-	return 0;
+	unsigned int count = 0;
+	unsigned int status0, status1;
+	int bit_set;
+
+	pmic_read(REG_INT_STATUS0, &status0);
+	pmic_read(REG_INT_STATUS1, &status1);
+	pmic_write(REG_INT_STATUS0, status0);
+	pmic_write(REG_INT_STATUS1, status1);
+	status0 &= events_enabled0;
+	status1 &= events_enabled1;
+
+	while (status0) {
+		bit_set = ffs(status0) - 1;
+		*(active_events + count) = bit_set;
+		count++;
+		status0 ^= (1 << bit_set);
+	}
+	while (status1) {
+		bit_set = ffs(status1) - 1;
+		*(active_events + count) = bit_set + 24;
+		count++;
+		status1 ^= (1 << bit_set);
+	}
+
+	return count;
 }
 
+#define EVENT_MASK_0			0x387fff
+#define EVENT_MASK_1			0x1177eb
+
 int pmic_event_unmask(type_event event)
 {
-	return 0;
+	unsigned int event_mask = 0;
+	unsigned int mask_reg = 0;
+	unsigned int event_bit = 0;
+	int ret;
+
+	if (event < EVENT_1HZI) {
+		mask_reg = REG_INT_MASK0;
+		event_mask = EVENT_MASK_0;
+		event_bit = (1 << event);
+		events_enabled0 |= event_bit;
+	} else {
+		event -= 24;
+		mask_reg = REG_INT_MASK1;
+		event_mask = EVENT_MASK_1;
+		event_bit = (1 << event);
+		events_enabled1 |= event_bit;
+	}
+
+	if ((event_bit & event_mask) == 0) {
+		pr_debug("Error: unmasking a reserved/unused event\n");
+		return PMIC_ERROR;
+	}
+
+	ret = pmic_write_reg(mask_reg, 0, event_bit);
+
+	pr_debug("Enable Event : %d\n", event);
+
+	return ret;
 }
 
 int pmic_event_mask(type_event event)
 {
-	return 0;
+	unsigned int event_mask = 0;
+	unsigned int mask_reg = 0;
+	unsigned int event_bit = 0;
+	int ret;
+
+	if (event < EVENT_1HZI) {
+		mask_reg = REG_INT_MASK0;
+		event_mask = EVENT_MASK_0;
+		event_bit = (1 << event);
+		events_enabled0 &= ~event_bit;
+	} else {
+		event -= 24;
+		mask_reg = REG_INT_MASK1;
+		event_mask = EVENT_MASK_1;
+		event_bit = (1 << event);
+		events_enabled1 &= ~event_bit;
+	}
+
+	if ((event_bit & event_mask) == 0) {
+		pr_debug("Error: masking a reserved/unused event\n");
+		return PMIC_ERROR;
+	}
+
+	ret = pmic_write_reg(mask_reg, event_bit, event_bit);
+
+	pr_debug("Disable Event : %d\n", event);
+
+	return ret;
 }
diff --git a/drivers/mxc/pmic/core/pmic_core_i2c.c b/drivers/mxc/pmic/core/pmic_core_i2c.c
index 5720892..919f4e3 100644
--- a/drivers/mxc/pmic/core/pmic_core_i2c.c
+++ b/drivers/mxc/pmic/core/pmic_core_i2c.c
@@ -23,8 +23,6 @@
  * Includes
  */
 
-#define DEBUG
-
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -57,6 +55,53 @@ static pmic_version_t mxc_pmic_version;
 unsigned int active_events[MAX_ACTIVE_EVENTS];
 struct i2c_client *mc13892_client;
 
+/*
+ * Platform device structure for PMIC client drivers
+ */
+static struct platform_device adc_ldm = {
+	.name = "pmic_adc",
+	.id = 1,
+};
+static struct platform_device battery_ldm = {
+	.name = "pmic_battery",
+	.id = 1,
+};
+static struct platform_device power_ldm = {
+	.name = "pmic_power",
+	.id = 1,
+};
+static struct platform_device rtc_ldm = {
+	.name = "pmic_rtc",
+	.id = 1,
+};
+static struct platform_device light_ldm = {
+	.name = "pmic_light",
+	.id = 1,
+};
+
+static void pmic_pdev_register(void)
+{
+	platform_device_register(&adc_ldm);
+	platform_device_register(&battery_ldm);
+	platform_device_register(&rtc_ldm);
+	platform_device_register(&power_ldm);
+	platform_device_register(&light_ldm);
+	reg_mc13783_probe();
+}
+
+/*!
+ * This function unregisters platform device structures for
+ * PMIC client drivers.
+ */
+static void pmic_pdev_unregister(void)
+{
+	platform_device_unregister(&adc_ldm);
+	platform_device_unregister(&battery_ldm);
+	platform_device_unregister(&rtc_ldm);
+	platform_device_unregister(&power_ldm);
+	platform_device_unregister(&light_ldm);
+}
+
 void pmic_bh_handler(struct work_struct *work);
 
 /*!
@@ -92,6 +137,7 @@ void pmic_bh_handler(struct work_struct *work)
 	unsigned int count = 0;
 
 	count = pmic_get_active_events(active_events);
+	pr_debug("active events number %d\n", count);
 
 	for (loop = 0; loop < count; loop++)
 		pmic_event_callback(active_events[loop]);
@@ -135,13 +181,13 @@ static ssize_t mc13892_show(struct device *dev,
 
 	for (i = 0; i < offset; i++) {
 		pmic_read(i, &value);
-		printk(KERN_INFO "reg%02d: %06x\t\t", i, value);
+		pr_info("reg%02d: %06x\t\t", i, value);
 		pmic_read(i + offset, &value);
-		printk(KERN_INFO "reg%02d: %06x\t\t", i + offset, value);
+		pr_info("reg%02d: %06x\t\t", i + offset, value);
 		pmic_read(i + offset * 2, &value);
-		printk(KERN_INFO "reg%02d: %06x\t\t", i + offset * 2, value);
+		pr_info("reg%02d: %06x\t\t", i + offset * 2, value);
 		pmic_read(i + offset * 3, &value);
-		printk(KERN_INFO "reg%02d: %06x\n", i + offset * 3, value);
+		pr_info("reg%02d: %06x\n", i + offset * 3, value);
 	}
 
 	return 0;
@@ -161,7 +207,7 @@ static ssize_t mc13892_store(struct device *dev,
 
 	if (p == NULL) {
 		pmic_read(reg, &value);
-		printk(KERN_INFO "reg%02d: %06x\n", reg, value);
+		pr_debug("reg%02d: %06x\n", reg, value);
 		return count;
 	}
 
@@ -171,9 +217,9 @@ static ssize_t mc13892_store(struct device *dev,
 
 	ret = pmic_write(reg, value);
 	if (ret == 0)
-		printk(KERN_INFO "write reg%02d: %06x\n", reg, value);
+		pr_debug("write reg%02d: %06x\n", reg, value);
 	else
-		printk(KERN_INFO "register update failed\n");
+		pr_debug("register update failed\n");
 
 	return count;
 }
@@ -192,7 +238,7 @@ static int __devinit pmic_probe(struct i2c_client *client)
 	int ret = 0;
 	int pmic_irq;
 
-	printk(KERN_INFO "start probe pmic 13892\n");
+	pr_debug("start probe pmic 13892\n");
 
 	ret = is_chip_onboard(client);
 
@@ -219,8 +265,11 @@ static int __devinit pmic_probe(struct i2c_client *client)
 	if (pmic_irq == 0)
 		return PMIC_ERROR;
 
-	set_irq_type(pmic_irq, IRQF_TRIGGER_RISING);
-	ret = request_irq(pmic_irq, pmic_irq_handler, 0, "PMIC_IRQ", 0);
+	set_irq_type(IOMUX_TO_IRQ(pmic_irq), IRQF_TRIGGER_RISING);
+	ret =
+	    request_irq(IOMUX_TO_IRQ(pmic_irq), pmic_irq_handler, 0, "PMIC_IRQ",
+			0);
+
 	if (ret) {
 		dev_err(&client->dev, "request irq %d error!\n", pmic_irq);
 		return ret;
@@ -232,13 +281,19 @@ static int __devinit pmic_probe(struct i2c_client *client)
 	if (ret)
 		dev_err(&client->dev, "create device file failed!\n");
 
-	printk(KERN_INFO "Device %s probed\n", client->dev.bus_id);
+	pmic_pdev_register();
+
+	pr_debug("Device %s probed\n", client->dev.bus_id);
 
 	return PMIC_SUCCESS;
 }
 
 static int pmic_remove(struct i2c_client *client)
 {
+	int pmic_irq = (int)(client->dev.platform_data);
+
+	free_irq(pmic_irq, 0);
+	pmic_pdev_unregister();
 	return 0;
 }
 
@@ -265,13 +320,13 @@ static struct i2c_driver pmic_driver = {
 
 static int __init pmic_init(void)
 {
-	printk(KERN_INFO "Registering the PMIC Protocol Driver\n");
+	pr_debug("Registering the PMIC Protocol Driver\n");
 	return i2c_add_driver(&pmic_driver);
 }
 
 static void __exit pmic_exit(void)
 {
-	printk(KERN_INFO "Unregistering the PMIC Protocol Driver\n");
+	pr_debug("Unregistering the PMIC Protocol Driver\n");
 	return i2c_del_driver(&pmic_driver);
 }
 
@@ -279,7 +334,7 @@ static void __exit pmic_exit(void)
  * Module entry points
  */
 /* subsys_initcall_sync(pmic_init); */
-module_init(pmic_init);
+subsys_initcall_sync(pmic_init);
 module_exit(pmic_exit);
 
 MODULE_DESCRIPTION("Core/Protocol driver for PMIC");
diff --git a/drivers/mxc/pmic/mc13892/Kconfig b/drivers/mxc/pmic/mc13892/Kconfig
new file mode 100644
index 0000000..930e06a
--- /dev/null
+++ b/drivers/mxc/pmic/mc13892/Kconfig
@@ -0,0 +1,48 @@
+#
+# PMIC Modules configuration
+#
+
+config MXC_MC13892_ADC
+	tristate "MC13892 ADC support"
+	depends on MXC_PMIC_MC13892
+	---help---
+	This is the MC13892 ADC module driver. This module provides kernel API
+	for the ADC system of MC13892.
+	It controls also the touch screen interface.
+	If you want MC13892 ADC support, you should say Y here
+
+config MXC_MC13892_RTC
+	tristate "MC13892 Real Time Clock (RTC) support"
+	depends on MXC_PMIC_MC13892
+	---help---
+	This is the MC13892 RTC module driver. This module provides kernel API
+	for RTC part of MC13892.
+	If you want MC13892 RTC support, you should say Y here
+config MXC_MC13892_LIGHT
+	tristate "MC13892 Light and Backlight support"
+	depends on MXC_PMIC_MC13892
+	---help---
+	This is the MC13892 Light module driver. This module provides kernel API
+	for led and backlight control part of MC13892.
+	If you want MC13892 Light support, you should say Y here
+config MXC_MC13892_BATTERY
+	tristate "MC13892 Battery API support"
+	depends on MXC_PMIC_MC13892
+	---help---
+	This is the MC13892 battery module driver. This module provides kernel API
+	for battery control part of MC13892.
+	If you want MC13892 battery support, you should say Y here
+config MXC_MC13892_CONNECTIVITY
+	tristate "MC13892 Connectivity API support"
+	depends on MXC_PMIC_MC13892
+	---help---
+	This is the MC13892 connectivity module driver. This module provides kernel API
+	for USB/RS232 connectivity control part of MC13892.
+	If you want MC13892 connectivity support, you should say Y here
+config MXC_MC13892_POWER
+	tristate "MC13892 Power API support"
+	depends on MXC_PMIC_MC13892
+	---help---
+	This is the MC13892 power and supplies module driver. This module provides kernel API
+	for power and regulator control part of MC13892.
+	If you want MC13892 power support, you should say Y here
diff --git a/drivers/mxc/pmic/mc13892/Makefile b/drivers/mxc/pmic/mc13892/Makefile
new file mode 100644
index 0000000..d2ec3d6
--- /dev/null
+++ b/drivers/mxc/pmic/mc13892/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the mc13783 pmic drivers.
+#
+
+obj-$(CONFIG_MXC_MC13892_ADC) += pmic_adc.o
+#obj-$(CONFIG_MXC_MC13892_RTC) += pmic_rtc.o
+#obj-$(CONFIG_MXC_MC13892_LIGHT) += pmic_light.o
+#obj-$(CONFIG_MXC_MC13892_BATTERY) += pmic_battery.o
+#obj-$(CONFIG_MXC_MC13892_CONNECTIVITY) += pmic_convity.o
+#obj-$(CONFIG_MXC_MC13892_POWER) += pmic_power.o
diff --git a/drivers/mxc/pmic/mc13892/pmic_adc.c b/drivers/mxc/pmic/mc13892/pmic_adc.c
new file mode 100644
index 0000000..2a2076e
--- /dev/null
+++ b/drivers/mxc/pmic/mc13892/pmic_adc.c
@@ -0,0 +1,975 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#define DEBUG
+
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/device.h>
+
+#include <asm/arch/pmic_adc.h>
+#include <asm/arch/pmic_power.h>
+#include <asm/arch/pmic_status.h>
+
+#include "../core/pmic.h"
+
+#define         DEF_ADC_0     0x008000
+#define         DEF_ADC_3     0x0001c0
+
+#define ADC_NB_AVAILABLE        2
+
+#define MAX_CHANNEL             7
+
+#define MC13892_ADC0_TS_M_LSH	14
+#define MC13892_ADC0_TS_M_WID	3
+
+/*
+ * Maximun allowed variation in the three X/Y co-ordinates acquired from
+ * touch-screen
+ */
+#define DELTA_Y_MAX             50
+#define DELTA_X_MAX             50
+
+/*
+ * ADC 0
+ */
+#define ADC_WAIT_TSI_0		0x001400
+
+#define ADC_INC                 0x030000
+#define ADC_BIS                 0x800000
+#define ADC_CHRGRAW_D5          0x008000
+
+/*
+ * ADC 1
+ */
+
+#define ADC_EN                  0x000001
+#define ADC_SGL_CH              0x000002
+#define ADC_ADSEL               0x000008
+#define ADC_CH_0_POS            5
+#define ADC_CH_0_MASK           0x0000E0
+#define ADC_CH_1_POS            8
+#define ADC_CH_1_MASK           0x000700
+#define ADC_DELAY_POS           11
+#define ADC_DELAY_MASK          0x07F800
+#define ADC_ATO                 0x080000
+#define ASC_ADC                 0x100000
+#define ADC_WAIT_TSI_1		0x300001
+#define ADC_NO_ADTRIG           0x200000
+
+/*
+ * ADC 2 - 4
+ */
+#define ADD1_RESULT_MASK        0x00000FFC
+#define ADD2_RESULT_MASK        0x00FFC000
+#define ADC_TS_MASK             0x00FFCFFC
+
+#define ADC_WCOMP               0x040000
+#define ADC_WCOMP_H_POS         0
+#define ADC_WCOMP_L_POS         9
+#define ADC_WCOMP_H_MASK        0x00003F
+#define ADC_WCOMP_L_MASK        0x007E00
+
+#define ADC_MODE_MASK           0x00003F
+
+#define ADC_INT_BISDONEI        0x02
+
+typedef enum adc_state {
+	ADC_FREE,
+	ADC_USED,
+	ADC_MONITORING,
+} t_adc_state;
+
+typedef enum reading_mode {
+	/*!
+	 * Enables lithium cell reading
+	 */
+	M_LITHIUM_CELL = 0x000001,
+	/*!
+	 * Enables charge current reading
+	 */
+	M_CHARGE_CURRENT = 0x000002,
+	/*!
+	 * Enables battery current reading
+	 */
+	M_BATTERY_CURRENT = 0x000004,
+} t_reading_mode;
+
+typedef struct {
+	/*!
+	 * Delay before first conversion
+	 */
+	unsigned int delay;
+	/*!
+	 * sets the ATX bit for delay on all conversion
+	 */
+	bool conv_delay;
+	/*!
+	 * Sets the single channel mode
+	 */
+	bool single_channel;
+	/*!
+	 * Channel selection 1
+	 */
+	t_channel channel_0;
+	/*!
+	 * Channel selection 2
+	 */
+	t_channel channel_1;
+	/*!
+	 * Used to configure ADC mode with t_reading_mode
+	 */
+	t_reading_mode read_mode;
+	/*!
+	 * Sets the Touch screen mode
+	 */
+	bool read_ts;
+	/*!
+	 * Wait TSI event before touch screen reading
+	 */
+	bool wait_tsi;
+	/*!
+	 * Sets CHRGRAW scaling to divide by 5
+	 * Only supported on 2.0 and higher
+	 */
+	bool chrgraw_devide_5;
+	/*!
+	 * Return ADC values
+	 */
+	unsigned int value[8];
+	/*!
+	 * Return touch screen values
+	 */
+	t_touch_screen ts_value;
+} t_adc_param;
+
+static int pmic_adc_filter(t_touch_screen *ts_curr);
+int mc13892_adc_request(bool read_ts);
+int mc13892_adc_release(int adc_index);
+t_reading_mode mc13892_set_read_mode(t_channel channel);
+PMIC_STATUS mc13892_adc_read_ts(t_touch_screen *touch_sample, int wait_tsi);
+
+/* internal function */
+static void callback_tsi(void *);
+static void callback_adcdone(void *);
+static void callback_adcbisdone(void *);
+
+static int swait;
+
+static int suspend_flag;
+
+static wait_queue_head_t suspendq;
+
+/* EXPORTED FUNCTIONS */
+EXPORT_SYMBOL(pmic_adc_init);
+EXPORT_SYMBOL(pmic_adc_deinit);
+EXPORT_SYMBOL(pmic_adc_convert);
+EXPORT_SYMBOL(pmic_adc_convert_8x);
+EXPORT_SYMBOL(pmic_adc_set_touch_mode);
+EXPORT_SYMBOL(pmic_adc_get_touch_mode);
+EXPORT_SYMBOL(pmic_adc_get_touch_sample);
+
+static DECLARE_COMPLETION(adcdone_it);
+static DECLARE_COMPLETION(adcbisdone_it);
+static DECLARE_COMPLETION(adc_tsi);
+static pmic_event_callback_t tsi_event;
+static pmic_event_callback_t event_adc;
+static pmic_event_callback_t event_adc_bis;
+static bool data_ready_adc_1;
+static bool data_ready_adc_2;
+static bool adc_ts;
+static bool wait_ts;
+static bool monitor_en;
+static bool monitor_adc;
+static DECLARE_MUTEX(convert_mutex);
+
+static DECLARE_WAIT_QUEUE_HEAD(queue_adc_busy);
+static t_adc_state adc_dev[2];
+
+static unsigned channel_num[] = {
+	0,
+	1,
+	3,
+	4,
+	2,
+	0,
+	1,
+	3,
+	4,
+	-1,
+	5,
+	6,
+	7,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1
+};
+
+static int pmic_adc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	suspend_flag = 1;
+	CHECK_ERROR(pmic_write_reg(REG_ADC0, DEF_ADC_0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC1, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC2, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC3, DEF_ADC_3, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC4, 0, PMIC_ALL_BITS));
+
+	return 0;
+};
+
+static int pmic_adc_resume(struct platform_device *pdev)
+{
+	/* nothing for mc13892 adc */
+	unsigned int adc_0_reg, adc_1_reg;
+	suspend_flag = 0;
+
+	/* let interrupt of TSI again */
+	adc_0_reg = ADC_WAIT_TSI_0;
+	CHECK_ERROR(pmic_write_reg(REG_ADC0, adc_0_reg, PMIC_ALL_BITS));
+	adc_1_reg = ADC_WAIT_TSI_1 | (ADC_BIS * adc_ts);
+	CHECK_ERROR(pmic_write_reg(REG_ADC1, adc_1_reg, PMIC_ALL_BITS));
+
+	while (swait > 0) {
+		swait--;
+		wake_up_interruptible(&suspendq);
+	}
+
+	return 0;
+};
+
+static void callback_tsi(void *unused)
+{
+	pr_debug("*** TSI IT mc13892 PMIC_ADC_GET_TOUCH_SAMPLE ***\n");
+	if (wait_ts) {
+		complete(&adc_tsi);
+		pmic_event_mask(EVENT_TSI);
+	}
+}
+
+static void callback_adcdone(void *unused)
+{
+	if (data_ready_adc_1)
+		complete(&adcdone_it);
+}
+
+static void callback_adcbisdone(void *unused)
+{
+	pr_debug("* adcdone bis it callback *\n");
+	if (data_ready_adc_2)
+		complete(&adcbisdone_it);
+}
+
+static int pmic_adc_filter(t_touch_screen *ts_curr)
+{
+	unsigned int ydiff, xdiff;
+	unsigned int sample_sumx, sample_sumy;
+
+	if (ts_curr->contact_resistance == 0) {
+		ts_curr->x_position = 0;
+		ts_curr->y_position = 0;
+		return 0;
+	}
+
+	ydiff = abs(ts_curr->y_position1 - ts_curr->y_position2);
+	if (ydiff > DELTA_Y_MAX) {
+		pr_debug("pmic_adc_filter: Ret pos y\n");
+		return -1;
+	}
+
+	xdiff = abs(ts_curr->x_position1 - ts_curr->x_position2);
+	if (xdiff > DELTA_X_MAX) {
+		pr_debug("mc13892_adc_filter: Ret pos x\n");
+		return -1;
+	}
+
+	sample_sumx = ts_curr->x_position1 + ts_curr->x_position2;
+	sample_sumy = ts_curr->y_position1 + ts_curr->y_position2;
+
+	ts_curr->y_position = sample_sumy / 2;
+	ts_curr->x_position = sample_sumx / 2;
+
+	return 0;
+}
+
+int pmic_adc_init(void)
+{
+	unsigned int reg_value = 0, i = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	for (i = 0; i < ADC_NB_AVAILABLE; i++)
+		adc_dev[i] = ADC_FREE;
+
+	CHECK_ERROR(pmic_write_reg(REG_ADC0, DEF_ADC_0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC1, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC2, 0, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC3, DEF_ADC_3, PMIC_ALL_BITS));
+	CHECK_ERROR(pmic_write_reg(REG_ADC4, 0, PMIC_ALL_BITS));
+	reg_value = 0x001000;
+
+	data_ready_adc_1 = false;
+	data_ready_adc_2 = false;
+	adc_ts = false;
+	wait_ts = false;
+	monitor_en = false;
+	monitor_adc = false;
+
+	/* sub to ADCDone IT */
+	event_adc.param = NULL;
+	event_adc.func = callback_adcdone;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_ADCDONEI, event_adc));
+
+	/* sub to ADCDoneBis IT */
+	event_adc_bis.param = NULL;
+	event_adc_bis.func = callback_adcbisdone;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_ADCBISDONEI, event_adc_bis));
+
+	/* sub to Touch Screen IT */
+	tsi_event.param = NULL;
+	tsi_event.func = callback_tsi;
+	CHECK_ERROR(pmic_event_subscribe(EVENT_TSI, tsi_event));
+
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS pmic_adc_deinit(void)
+{
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_ADCDONEI, event_adc));
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_ADCBISDONEI, event_adc_bis));
+	CHECK_ERROR(pmic_event_unsubscribe(EVENT_TSI, tsi_event));
+
+	return PMIC_SUCCESS;
+}
+
+int mc13892_adc_init_param(t_adc_param * adc_param)
+{
+	int i = 0;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	adc_param->delay = 0;
+	adc_param->conv_delay = false;
+	adc_param->single_channel = false;
+	adc_param->channel_0 = BATTERY_VOLTAGE;
+	adc_param->channel_1 = BATTERY_VOLTAGE;
+	adc_param->read_mode = 0;
+	adc_param->wait_tsi = 0;
+	adc_param->chrgraw_devide_5 = true;
+	adc_param->read_ts = false;
+	adc_param->ts_value.x_position = 0;
+	adc_param->ts_value.y_position = 0;
+	adc_param->ts_value.contact_resistance = 0;
+	for (i = 0; i <= MAX_CHANNEL; i++)
+		adc_param->value[i] = 0;
+
+	return 0;
+}
+
+PMIC_STATUS mc13892_adc_convert(t_adc_param * adc_param)
+{
+	bool use_bis = false;
+	unsigned int adc_0_reg = 0, adc_1_reg = 0, reg_1 = 0, result_reg =
+	    0, i = 0;
+	unsigned int result = 0, temp = 0;
+	pmic_version_t mc13892_ver;
+	pr_debug("mc13892 ADC - mc13892_adc_convert ....\n");
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (adc_param->wait_tsi) {
+		/* configure adc to wait tsi interrupt */
+		INIT_COMPLETION(adc_tsi);
+
+		/*for ts don't use bis */
+		/*put ts in interrupt mode */
+		/* still kep reference? */
+		adc_0_reg = 0x001400 | (ADC_BIS * 0);
+		pmic_event_unmask(EVENT_TSI);
+		CHECK_ERROR(pmic_write_reg(REG_ADC0, adc_0_reg, PMIC_ALL_BITS));
+		/*for ts don't use bis */
+		adc_1_reg = 0x200001 | (ADC_BIS * 0);
+		CHECK_ERROR(pmic_write_reg(REG_ADC1, adc_1_reg, PMIC_ALL_BITS));
+		pr_debug("wait tsi ....\n");
+		wait_ts = true;
+		wait_for_completion_interruptible(&adc_tsi);
+		wait_ts = false;
+	}
+	if (adc_param->read_ts == false)
+		down(&convert_mutex);
+	use_bis = mc13892_adc_request(adc_param->read_ts);
+	if (use_bis < 0) {
+		pr_debug("process has received a signal and got interrupted\n");
+		return -EINTR;
+	}
+
+	/* CONFIGURE ADC REG 0 */
+	adc_0_reg = 0;
+	adc_1_reg = 0;
+	if (adc_param->read_ts == false) {
+		adc_0_reg = adc_param->read_mode & 0x00003F;
+		/* add auto inc */
+		adc_0_reg |= ADC_INC;
+		if (use_bis) {
+			/* add adc bis */
+			adc_0_reg |= ADC_BIS;
+		}
+		mc13892_ver = pmic_get_version();
+		if (mc13892_ver.revision >= 20)
+			if (adc_param->chrgraw_devide_5)
+				adc_0_reg |= ADC_CHRGRAW_D5;
+
+		if (adc_param->single_channel)
+			adc_1_reg |= ADC_SGL_CH;
+
+		if (adc_param->conv_delay)
+			adc_1_reg |= ADC_ATO;
+
+		if (adc_param->single_channel)
+			adc_1_reg |= ADC_SGL_CH;
+
+		adc_1_reg |= (adc_param->channel_0 << ADC_CH_0_POS) &
+		    ADC_CH_0_MASK;
+		adc_1_reg |= (adc_param->channel_1 << ADC_CH_1_POS) &
+		    ADC_CH_1_MASK;
+	} else {
+		adc_0_reg = 0x002400 | (ADC_BIS * use_bis) | ADC_INC;
+	}
+	pr_debug("Write Reg %i = %x\n", REG_ADC0, adc_0_reg);
+	/*Change has been made here */
+	CHECK_ERROR(pmic_write_reg(REG_ADC0, adc_0_reg,
+				   ADC_INC | ADC_BIS | ADC_CHRGRAW_D5 |
+				   0xfff00ff));
+	/* CONFIGURE ADC REG 1 */
+	if (adc_param->read_ts == false) {
+		adc_1_reg |= ADC_NO_ADTRIG;
+		adc_1_reg |= ADC_EN;
+		adc_1_reg |= (adc_param->delay << ADC_DELAY_POS) &
+		    ADC_DELAY_MASK;
+		if (use_bis)
+			adc_1_reg |= ADC_BIS;
+	} else {
+		/* configure and start convert to read x and y position */
+		/* configure to read 2 value in channel selection 1 & 2 */
+		adc_1_reg = 0x100409 | (ADC_BIS * use_bis) | ADC_NO_ADTRIG;
+		/* set ATOx = 5, it could be better for ts ADC */
+		adc_1_reg |= 0x002800;
+	}
+	reg_1 = adc_1_reg;
+	if (use_bis == 0) {
+		data_ready_adc_1 = false;
+		adc_1_reg |= ASC_ADC;
+		data_ready_adc_1 = true;
+		pr_debug("Write Reg %i = %x\n", REG_ADC1, adc_1_reg);
+		INIT_COMPLETION(adcdone_it);
+		CHECK_ERROR(pmic_write_reg(REG_ADC1, adc_1_reg,
+					   ADC_SGL_CH | ADC_ATO | ADC_ADSEL
+					   | ADC_CH_0_MASK | ADC_CH_1_MASK |
+					   ADC_NO_ADTRIG | ADC_EN |
+					   ADC_DELAY_MASK | ASC_ADC | ADC_BIS));
+		pr_debug("wait adc done \n");
+		wait_for_completion_interruptible(&adcdone_it);
+		data_ready_adc_1 = false;
+	} else {
+		data_ready_adc_2 = false;
+		adc_1_reg |= ASC_ADC;
+		data_ready_adc_2 = true;
+		INIT_COMPLETION(adcbisdone_it);
+		CHECK_ERROR(pmic_write_reg(REG_ADC1, adc_1_reg, 0xFFFFFF));
+		temp = 0x800000;
+		CHECK_ERROR(pmic_write_reg(REG_ADC3, temp, 0xFFFFFF));
+		pr_debug("wait adc done bis\n");
+		wait_for_completion_interruptible(&adcbisdone_it);
+		data_ready_adc_2 = false;
+	}
+	/* read result and store in adc_param */
+	result = 0;
+	if (use_bis == 0)
+		result_reg = REG_ADC2;
+	else
+		result_reg = REG_ADC4;
+
+	CHECK_ERROR(pmic_write_reg(REG_ADC1, 4 << ADC_CH_1_POS,
+				   ADC_CH_0_MASK | ADC_CH_1_MASK));
+
+	for (i = 0; i <= 3; i++) {
+		CHECK_ERROR(pmic_read_reg(result_reg, &result, PMIC_ALL_BITS));
+		adc_param->value[i] = ((result & ADD1_RESULT_MASK) >> 2);
+		adc_param->value[i + 4] = ((result & ADD2_RESULT_MASK) >> 14);
+		pr_debug("value[%d] = %d, value[%d] = %d\n",
+			 i, adc_param->value[i],
+			 i + 4, adc_param->value[i + 4]);
+	}
+	if (adc_param->read_ts) {
+		adc_param->ts_value.x_position = adc_param->value[0];
+		adc_param->ts_value.x_position1 = adc_param->value[0];
+		adc_param->ts_value.x_position2 = adc_param->value[1];
+		adc_param->ts_value.y_position = adc_param->value[3];
+		adc_param->ts_value.y_position1 = adc_param->value[3];
+		adc_param->ts_value.y_position2 = adc_param->value[4];
+		adc_param->ts_value.contact_resistance = adc_param->value[6];
+	}
+
+	/*if (adc_param->read_ts) {
+	   adc_param->ts_value.x_position = adc_param->value[2];
+	   adc_param->ts_value.y_position = adc_param->value[5];
+	   adc_param->ts_value.contact_resistance = adc_param->value[6];
+	   } */
+	mc13892_adc_release(use_bis);
+	if (adc_param->read_ts == false)
+		up(&convert_mutex);
+
+	return PMIC_SUCCESS;
+}
+
+t_reading_mode mc13892_set_read_mode(t_channel channel)
+{
+	t_reading_mode read_mode = 0;
+
+	switch (channel) {
+	case CHARGE_CURRENT:
+		read_mode = M_CHARGE_CURRENT;
+		break;
+	case BATTERY_CURRENT:
+		read_mode = M_BATTERY_CURRENT;
+		break;
+	default:
+		read_mode = 0;
+	}
+
+	return read_mode;
+}
+
+PMIC_STATUS pmic_adc_convert(t_channel channel, unsigned short *result)
+{
+	t_adc_param adc_param;
+	PMIC_STATUS ret;
+
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	channel = channel_num[channel];
+	if (channel == -1) {
+		pr_debug("Wrong channel ID\n");
+		return PMIC_PARAMETER_ERROR;
+	}
+	mc13892_adc_init_param(&adc_param);
+	pr_debug("pmic_adc_convert\n");
+	adc_param.read_ts = false;
+	adc_param.single_channel = true;
+	adc_param.read_mode = mc13892_set_read_mode(channel);
+
+	/* Find the group */
+	if (channel <= 7)
+		adc_param.channel_0 = channel;
+	else
+		return PMIC_PARAMETER_ERROR;
+
+	ret = mc13892_adc_convert(&adc_param);
+	*result = adc_param.value[0];
+	return ret;
+}
+
+PMIC_STATUS pmic_adc_convert_8x(t_channel channel, unsigned short *result)
+{
+	t_adc_param adc_param;
+	int i;
+	PMIC_STATUS ret;
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	channel = channel_num[channel];
+
+	if (channel == -1) {
+		pr_debug("Wrong channel ID\n");
+		return PMIC_PARAMETER_ERROR;
+	}
+	mc13892_adc_init_param(&adc_param);
+	pr_debug("pmic_adc_convert_8x\n");
+	adc_param.read_ts = false;
+	adc_param.single_channel = true;
+	adc_param.read_mode = mc13892_set_read_mode(channel);
+
+	if (channel <= 7) {
+		adc_param.channel_0 = channel;
+		adc_param.channel_1 = channel;
+	} else
+		return PMIC_PARAMETER_ERROR;
+
+	ret = mc13892_adc_convert(&adc_param);
+	for (i = 0; i <= 7; i++)
+		result[i] = adc_param.value[i];
+
+	return ret;
+}
+
+PMIC_STATUS pmic_adc_set_touch_mode(t_touch_mode touch_mode)
+{
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	CHECK_ERROR(pmic_write_reg(REG_ADC0,
+				   BITFVAL(MC13892_ADC0_TS_M, touch_mode),
+				   BITFMASK(MC13892_ADC0_TS_M)));
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS pmic_adc_get_touch_mode(t_touch_mode * touch_mode)
+{
+	unsigned int value;
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	CHECK_ERROR(pmic_read_reg(REG_ADC0, &value, PMIC_ALL_BITS));
+
+	*touch_mode = BITFEXT(value, MC13892_ADC0_TS_M);
+
+	return PMIC_SUCCESS;
+}
+
+PMIC_STATUS pmic_adc_get_touch_sample(t_touch_screen *touch_sample, int wait)
+{
+	if (mc13892_adc_read_ts(touch_sample, wait) != 0)
+		return PMIC_ERROR;
+	if (0 == pmic_adc_filter(touch_sample))
+		return PMIC_SUCCESS;
+	else
+		return PMIC_ERROR;
+}
+
+PMIC_STATUS mc13892_adc_read_ts(t_touch_screen *ts_value, int wait_tsi)
+{
+	t_adc_param param;
+	pr_debug("mc13892_adc : mc13892_adc_read_ts\n");
+	if (suspend_flag == 1)
+		return -EBUSY;
+
+	if (wait_ts) {
+		pr_debug("mc13892_adc : error TS busy \n");
+		return PMIC_ERROR;
+	}
+	mc13892_adc_init_param(&param);
+	param.wait_tsi = wait_tsi;
+	param.read_ts = true;
+	if (mc13892_adc_convert(&param) != 0)
+		return PMIC_ERROR;
+	/* check if x-y is ok */
+	if (param.ts_value.contact_resistance < 1000) {
+		ts_value->x_position = param.ts_value.x_position;
+		ts_value->x_position1 = param.ts_value.x_position1;
+		ts_value->x_position2 = param.ts_value.x_position2;
+
+		ts_value->y_position = param.ts_value.y_position;
+		ts_value->y_position1 = param.ts_value.y_position1;
+		ts_value->y_position2 = param.ts_value.y_position2;
+
+		ts_value->contact_resistance =
+		    param.ts_value.contact_resistance + 1;
+
+	} else {
+		ts_value->x_position = 0;
+		ts_value->y_position = 0;
+		ts_value->contact_resistance = 0;
+
+	}
+	return PMIC_SUCCESS;
+}
+
+int mc13892_adc_request(bool read_ts)
+{
+	int adc_index = -1;
+	if (read_ts != 0) {
+		/*for ts we use bis=0 */
+		if (adc_dev[0] == ADC_USED)
+			return -1;
+		/*no wait here */
+		adc_dev[0] = ADC_USED;
+		adc_index = 0;
+	} else {
+		/*for other adc use bis = 1 */
+		if (adc_dev[1] == ADC_USED) {
+			return -1;
+			/*no wait here */
+		}
+		adc_dev[1] = ADC_USED;
+		adc_index = 1;
+	}
+	pr_debug("mc13892_adc : request ADC %d\n", adc_index);
+	return adc_index;
+}
+
+int mc13892_adc_release(int adc_index)
+{
+	while (suspend_flag == 1) {
+		swait++;
+		/* Block if the device is suspended */
+		if (wait_event_interruptible(suspendq, (suspend_flag == 0)))
+			return -ERESTARTSYS;
+	}
+
+	pr_debug("mc13892_adc : release ADC %d\n", adc_index);
+	if ((adc_dev[adc_index] == ADC_MONITORING) ||
+	    (adc_dev[adc_index] == ADC_USED)) {
+		adc_dev[adc_index] = ADC_FREE;
+		wake_up(&queue_adc_busy);
+		return 0;
+	}
+	return -1;
+}
+
+#ifdef DEBUG
+static t_adc_param adc_param_db;
+
+static ssize_t adc_info(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	int *value = adc_param_db.value;
+
+	pr_debug("adc_info\n");
+
+	pr_debug("ch0\t\t%d\n", adc_param_db.channel_0);
+	pr_debug("ch1\t\t%d\n", adc_param_db.channel_1);
+	pr_debug("d5\t\t%d\n", adc_param_db.chrgraw_devide_5);
+	pr_debug("conv delay\t%d\n", adc_param_db.conv_delay);
+	pr_debug("delay\t\t%d\n", adc_param_db.delay);
+	pr_debug("read mode\t%d\n", adc_param_db.read_mode);
+	pr_debug("read ts\t\t%d\n", adc_param_db.read_ts);
+	pr_debug("single ch\t%d\n", adc_param_db.single_channel);
+	pr_debug("wait ts int\t%d\n", adc_param_db.wait_tsi);
+	pr_debug("value0-3:\t%d\t%d\t%d\t%d\n", value[0], value[1],
+		 value[2], value[3]);
+	pr_debug("value4-7:\t%d\t%d\t%d\t%d\n", value[4], value[5],
+		 value[6], value[7]);
+
+	return 0;
+}
+
+enum {
+	ADC_SET_CH0 = 0,
+	ADC_SET_CH1,
+	ADC_SET_DV5,
+	ADC_SET_CON_DELAY,
+	ADC_SET_DELAY,
+	ADC_SET_RM,
+	ADC_SET_RT,
+	ADC_SET_S_CH,
+	ADC_SET_WAIT_TS,
+	ADC_INIT_P,
+	ADC_START,
+	ADC_TS,
+	ADC_TS_READ,
+	ADC_TS_CAL,
+	ADC_CMD_MAX
+};
+
+static const char *const adc_cmd[ADC_CMD_MAX] = {
+	[ADC_SET_CH0] = "ch0",
+	[ADC_SET_CH1] = "ch1",
+	[ADC_SET_DV5] = "dv5",
+	[ADC_SET_CON_DELAY] = "cd",
+	[ADC_SET_DELAY] = "dl",
+	[ADC_SET_RM] = "rm",
+	[ADC_SET_RT] = "rt",
+	[ADC_SET_S_CH] = "sch",
+	[ADC_SET_WAIT_TS] = "wt",
+	[ADC_INIT_P] = "init",
+	[ADC_START] = "start",
+	[ADC_TS] = "touch",
+	[ADC_TS_READ] = "touchr",
+	[ADC_TS_CAL] = "cal"
+};
+
+static int cmd(unsigned int index, int value)
+{
+	t_touch_screen ts;
+
+	switch (index) {
+	case ADC_SET_CH0:
+		adc_param_db.channel_0 = value;
+		break;
+	case ADC_SET_CH1:
+		adc_param_db.channel_1 = value;
+		break;
+	case ADC_SET_DV5:
+		adc_param_db.chrgraw_devide_5 = value;
+		break;
+	case ADC_SET_CON_DELAY:
+		adc_param_db.conv_delay = value;
+		break;
+	case ADC_SET_RM:
+		adc_param_db.read_mode = value;
+		break;
+	case ADC_SET_RT:
+		adc_param_db.read_ts = value;
+		break;
+	case ADC_SET_S_CH:
+		adc_param_db.single_channel = value;
+		break;
+	case ADC_SET_WAIT_TS:
+		adc_param_db.wait_tsi = value;
+		break;
+	case ADC_INIT_P:
+		mc13892_adc_init_param(&adc_param_db);
+		break;
+	case ADC_START:
+		mc13892_adc_convert(&adc_param_db);
+		break;
+	case ADC_TS:
+		pmic_adc_get_touch_sample(&ts, 1);
+		pr_debug("x = %d\n", ts.x_position);
+		pr_debug("y = %d\n", ts.y_position);
+		pr_debug("p = %d\n", ts.contact_resistance);
+		break;
+	case ADC_TS_READ:
+		pmic_adc_get_touch_sample(&ts, 0);
+		pr_debug("x = %d\n", ts.x_position);
+		pr_debug("y = %d\n", ts.y_position);
+		pr_debug("p = %d\n", ts.contact_resistance);
+		break;
+	case ADC_TS_CAL:
+		break;
+	default:
+		pr_debug("error command\n");
+		break;
+	}
+	return 0;
+}
+
+static ssize_t adc_ctl(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	int state = 0;
+	const char *const *s;
+	char *p, *q;
+	int error;
+	int len, value = 0;
+
+	pr_debug("adc_ctl\n");
+
+	q = NULL;
+	q = memchr(buf, ' ', count);
+
+	if (q != NULL) {
+		len = q - buf;
+		q += 1;
+		value = simple_strtoul(q, NULL, 10);
+	} else {
+		p = memchr(buf, '\n', count);
+		len = p ? p - buf : count;
+	}
+
+	for (s = &adc_cmd[state]; state < ADC_CMD_MAX; s++, state++) {
+		if (*s && !strncmp(buf, *s, len))
+			break;
+	}
+	if (state < ADC_CMD_MAX && *s)
+		error = cmd(state, value);
+	else
+		error = -EINVAL;
+
+	return count;
+}
+
+#else
+static ssize_t adc_info(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return 0;
+}
+
+static ssize_t adc_ctl(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	return count;
+}
+
+#endif
+
+static DEVICE_ATTR(adc, 0644, adc_info, adc_ctl);
+
+static int pmic_adc_module_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	pr_debug("PMIC ADC start probe\n");
+	ret = device_create_file(&(pdev->dev), &dev_attr_adc);
+	if (ret) {
+		pr_debug("Can't create device file!\n");
+		return -ENODEV;
+	}
+
+	init_waitqueue_head(&suspendq);
+
+	ret = pmic_adc_init();
+	if (ret != PMIC_SUCCESS) {
+		pr_debug("Error in pmic_adc_init.\n");
+		goto rm_dev_file;
+	}
+
+	pr_debug("PMIC ADC successfully probed\n");
+	return 0;
+
+      rm_dev_file:
+	device_remove_file(&(pdev->dev), &dev_attr_adc);
+	return ret;
+}
+
+static int pmic_adc_module_remove(struct platform_device *pdev)
+{
+	pmic_adc_deinit();
+	pr_debug("PMIC ADC successfully removed\n");
+	return 0;
+}
+
+static struct platform_driver pmic_adc_driver_ldm = {
+	.driver = {
+		   .name = "pmic_adc",
+		   },
+	.suspend = pmic_adc_suspend,
+	.resume = pmic_adc_resume,
+	.probe = pmic_adc_module_probe,
+	.remove = pmic_adc_module_remove,
+};
+
+static int __init pmic_adc_module_init(void)
+{
+	pr_debug("PMIC ADC driver loading...\n");
+	return platform_driver_register(&pmic_adc_driver_ldm);
+}
+
+static void __exit pmic_adc_module_exit(void)
+{
+	platform_driver_unregister(&pmic_adc_driver_ldm);
+	pr_debug("PMIC ADC driver successfully unloaded\n");
+}
+
+module_init(pmic_adc_module_init);
+module_exit(pmic_adc_module_exit);
+
+MODULE_DESCRIPTION("PMIC ADC device driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/include/asm-arm/arch-mxc/pmic_external.h b/include/asm-arm/arch-mxc/pmic_external.h
index 3b86457..f7287da 100644
--- a/include/asm-arm/arch-mxc/pmic_external.h
+++ b/include/asm-arm/arch-mxc/pmic_external.h
@@ -867,22 +867,88 @@ enum {
 	REG_TEST2,
 	REG_TEST3,
 	REG_TEST4,
-	REG_ARBITRATION_SWITCHERS,	/*for compile */
-	REG_INTERRUPT_MASK_1,
-	REG_SWITCHERS_4,
-	REG_POWER_MISCELLANEOUS,
 };
 
 typedef enum {
-	place_holder1,
+	EVENT_ADCDONEI = 0,
+	EVENT_ADCBISDONEI = 1,
+	EVENT_TSI = 2,
+	EVENT_VBUSVI = 3,
+	EVENT_IDFACI = 4,
+	EVENT_USBOVI = 5,
+	EVENT_CHGDETI = 6,
+	EVENT_CHGFAULTI = 7,
+	EVENT_CHGREVI = 8,
+	EVENT_CHGRSHORTI = 9,
+	EVENT_CCCVI = 10,
+	EVENT_CHGCURRI = 11,
+	EVENT_BPONI = 12,
+	EVENT_LOBATLI = 13,
+	EVENT_LOBATHI = 14,
+	EVENT_IDFLOATI = 19,
+	EVENT_IDGNDI = 20,
+	EVENT_SE1I = 21,
+	EVENT_CKDETI = 22,
+	EVENT_1HZI = 24,
+	EVENT_TODAI = 25,
+	EVENT_PWRONI = 27,
+	EVENT_WDIRESETI = 29,
+	EVENT_SYSRSTI = 30,
+	EVENT_RTCRSTI = 31,
+	EVENT_PCI = 32,
+	EVENT_WARMI = 33,
+	EVENT_MEMHLDI = 34,
+	EVENT_THWARNLI = 36,
+	EVENT_THWARNHI = 37,
+	EVENT_CLKI = 38,
+	EVENT_SCPI = 40,
+	EVENT_LBPI = 44,
+	EVENT_NB,
 } type_event;
 
 typedef enum {
-	place_holder2,
+	SENSE_VBUSVS = 3,
+	SENSE_IDFACS = 4,
+	SENSE_USBOVS = 5,
+	SENSE_CHGDETS = 6,
+	SENSE_CHGREVS = 8,
+	SENSE_CHGRSHORTS = 9,
+	SENSE_CCCVS = 10,
+	SENSE_CHGCURRS = 11,
+	SENSE_BPONS = 12,
+	SENSE_LOBATLS = 13,
+	SENSE_LOBATHS = 14,
+	SENSE_IDFLOATS = 19,
+	SENSE_IDGNDS = 20,
+	SENSE_SE1S = 21,
+	SENSE_PWRONS = 27,
+	SENSE_THWARNLS = 36,
+	SENSE_THWARNHS = 37,
+	SENSE_CLKS = 38,
+	SENSE_LBPS = 44,
+	SENSE_NB,
 } t_sensor;
 
-typedef enum {
-	place_holder3,
+typedef struct {
+	bool sense_vbusvs;
+	bool sense_idfacs;
+	bool sense_usbovs;
+	bool sense_chgdets;
+	bool sense_chgrevs;
+	bool sense_chgrshorts;
+	bool sense_cccvs;
+	bool sense_chgcurrs;
+	bool sense_bpons;
+	bool sense_lobatls;
+	bool sense_lobaths;
+	bool sense_idfloats;
+	bool sense_idgnds;
+	bool sense_se1s;
+	bool sense_pwrons;
+	bool sense_thwarnls;
+	bool sense_thwarnhs;
+	bool sense_clks;
+	bool sense_lbps;
 } t_sensor_bits;
 
 extern struct i2c_client *mc13892_client;
-- 
1.5.4.4

