From 81c27e50994bd74924ac1752fdf30414b3fa4ea8 Mon Sep 17 00:00:00 2001
From: Rob Herring <r.herring@freescale.com>
Date: Mon, 21 Apr 2008 15:03:22 -0500
Subject: [PATCH] ENGR00069553 ipu3 improve interlaced timing and disabling

Fix flicker issue with TV out in PAL mode. The DC disable sequence has been
reworked significantly.
Change interlaced timing to use NL and EOL events instead of user event.
Set fb2 to correct pixel fmt (UYVY).
Disable TVE MV to fix skew at top of NTSC CRTs

Signed-off-by: Rob Herring <r.herring@freescale.com>
---
 drivers/mxc/ipu3/ipu_common.c    |   24 +++++-
 drivers/mxc/ipu3/ipu_disp.c      |  152 +++++++++++++++++++++-----------------
 drivers/mxc/ipu3/ipu_regs.h      |   10 +++
 drivers/video/mxc/mxc_ipuv3_fb.c |    6 ++
 drivers/video/mxc/tve.c          |    7 ++-
 include/asm-arm/arch-mxc/ipu.h   |    3 +-
 6 files changed, 129 insertions(+), 73 deletions(-)

diff --git a/drivers/mxc/ipu3/ipu_common.c b/drivers/mxc/ipu3/ipu_common.c
index 10b532c..c4d2fea 100644
--- a/drivers/mxc/ipu3/ipu_common.c
+++ b/drivers/mxc/ipu3/ipu_common.c
@@ -288,12 +288,20 @@ void ipu_dump_registers(void)
  */
 int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t *params)
 {
+	int ret = 0;
 	uint32_t ipu_conf;
 	uint32_t reg;
 	unsigned long lock_flags;
 
 	dev_dbg(g_ipu_dev, "init channel = %d\n", IPU_CHAN_ID(channel));
 
+	/* re-enable error interrupts every time a channel is initialized */
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(5));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(6));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(9));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(10));
+
+
 	spin_lock_irqsave(&ipu_lock, lock_flags);
 
 	ipu_conf = __raw_readl(IPU_CONF);
@@ -346,6 +354,11 @@ int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t *params)
 		ipu_rot_use_count++;
 		break;
 	case MEM_DC_SYNC:
+		if (params->mem_dc_sync.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
 		g_ipu_di_channel[params->mem_dc_sync.di] = MEM_DC_SYNC;
 		_ipu_dc_init(1, params->mem_dc_sync.di,
 			     params->mem_dc_sync.interlaced);
@@ -354,6 +367,11 @@ int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t *params)
 		ipu_dmfc_use_count++;
 		break;
 	case MEM_BG_SYNC:
+		if (params->mem_dc_sync.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
 		g_ipu_di_channel[params->mem_dp_bg_sync.di] = MEM_BG_SYNC;
 		_ipu_dp_init(channel, params->mem_dp_bg_sync.in_pixel_fmt,
 			     params->mem_dp_bg_sync.out_pixel_fmt);
@@ -395,9 +413,9 @@ int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t *params)
 
 	__raw_writel(ipu_conf, IPU_CONF);
 
+err:
 	spin_unlock_irqrestore(&ipu_lock, lock_flags);
-
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL(ipu_init_channel);
 
@@ -492,7 +510,7 @@ void ipu_uninit_channel(ipu_channel_t channel)
 		if (g_ipu_di_channel[0] == MEM_BG_SYNC) {
 			g_ipu_di_channel[0] = CHAN_NONE;
 			ipu_di_use_count[0]--;
-		} else if (g_ipu_di_channel[1] == MEM_DC_SYNC) {
+		} else if (g_ipu_di_channel[1] == MEM_BG_SYNC) {
 			g_ipu_di_channel[1] = CHAN_NONE;
 			ipu_di_use_count[1]--;
 		}
diff --git a/drivers/mxc/ipu3/ipu_disp.c b/drivers/mxc/ipu3/ipu_disp.c
index d64832a..8b34955 100644
--- a/drivers/mxc/ipu3/ipu_disp.c
+++ b/drivers/mxc/ipu3/ipu_disp.c
@@ -282,15 +282,9 @@ void _ipu_dc_init(int dc_chan, int di, bool interlaced)
 
 	if ((dc_chan == 1) || (dc_chan == 5)) {
 		if (interlaced) {
-			reg = 0;
-			reg |= dc_chan << DC_UGDE_0_ID_CODED_OFFSET;
-			reg |= 1 << DC_UGDE_0_EV_PRIORITY_OFFSET;
-			reg |= DC_UGDE_0_ODD_EN;
-			__raw_writel(reg, DC_UGDE_0(0));
-
-			_ipu_dc_link_event(dc_chan, DC_EVT_NL, 0, 0);
-			_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 0, 0);
-			_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 0, 0);
+			_ipu_dc_link_event(dc_chan, DC_EVT_NL, 0, 3);
+			_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 0, 2);
+			_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 0, 1);
 		} else {
 			_ipu_dc_link_event(dc_chan, DC_EVT_NL, 2, 3);
 			_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 3, 2);
@@ -302,29 +296,31 @@ void _ipu_dc_init(int dc_chan, int di, bool interlaced)
 		_ipu_dc_link_event(dc_chan, DC_EVT_EOFIELD, 0, 0);
 		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN, 0, 0);
 		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR, 0, 0);
+
+		/* Make sure other DC sync channel is not assigned same DI */
+		reg = __raw_readl(DC_WR_CH_CONF(6 - dc_chan));
+		if ((di << 2) == (reg & DC_WR_CH_CONF_PROG_DI_ID)) {
+			reg &= ~DC_WR_CH_CONF_PROG_DI_ID;
+			reg |= di ? 0 : DC_WR_CH_CONF_PROG_DI_ID;
+			__raw_writel(reg, DC_WR_CH_CONF(6 - dc_chan));
+		}
 	} else {
 		/* async channels */
 	}
 
-	reg = 0x9A;
+	reg = 0x1A;
 	reg |= di << 2;
 	if (interlaced)
 		reg |= DC_WR_CH_CONF_FIELD_MODE;
+	__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
+	__raw_writel(0x00000000, DC_WR_CH_ADDR(dc_chan));
 
-	if (dc_chan == 1) {
-		__raw_writel(reg, DC_WR_CH_CONF_1);
-		__raw_writel(0x00000000, DC_WR_CH_ADDR_1);
-	} else if (dc_chan == 5) {
-		__raw_writel(reg, DC_WR_CH_CONF_5);
-		__raw_writel(0x00000000, DC_WR_CH_ADDR_5);
-	}
-	__raw_writel(0x00000044, DC_GEN);
+	__raw_writel(0x00000084, DC_GEN);
 }
 
 void _ipu_dc_uninit(int dc_chan)
 {
 	if ((dc_chan == 1) || (dc_chan == 5)) {
-		__raw_writel(0, DC_UGDE_0(0));
 		_ipu_dc_link_event(dc_chan, DC_EVT_NL, 0, 0);
 		_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 0, 0);
 		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 0, 0);
@@ -375,84 +371,102 @@ void _ipu_dp_dc_enable(ipu_channel_t channel)
 		return;
 	}
 
+	reg = __raw_readl(dc_ch_conf);
+	reg |= 4 << DC_WR_CH_CONF_PROG_TYPE_OFFSET;
+	__raw_writel(reg, dc_ch_conf);
+
 	reg = __raw_readl(IPU_DISP_GEN);
 	if (g_ipu_di_channel[0] == channel)
 		reg |= DI0_COUNTER_RELEASE;
 	else if (g_ipu_di_channel[1] == channel)
 		reg |= DI1_COUNTER_RELEASE;
 	__raw_writel(reg, IPU_DISP_GEN);
+}
+
+static irqreturn_t dc_irq_handler(int irq, void *dev_id)
+{
+	u32 reg;
+	uint32_t *dc_ch_conf;
+	ipu_channel_t channel;
+	struct completion *comp = dev_id;
+
+	if (irq == IPU_IRQ_DP_SF_END) {
+		channel = MEM_BG_SYNC;
+		dc_ch_conf = DC_WR_CH_CONF_5;
+	} else if (irq == IPU_IRQ_DC_FC_1) {
+		channel = MEM_DC_SYNC;
+		dc_ch_conf = DC_WR_CH_CONF_1;
+	} else {
+		return IRQ_HANDLED;
+	}
 
 	reg = __raw_readl(dc_ch_conf);
-	reg |= 4 << DC_WR_CH_CONF_PROG_TYPE_OFFSET;
+	reg &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;
 	__raw_writel(reg, dc_ch_conf);
+
+	reg = __raw_readl(IPU_DISP_GEN);
+	if (g_ipu_di_channel[0] == channel)
+		reg &= ~DI0_COUNTER_RELEASE;
+	else if (g_ipu_di_channel[1] == channel)
+		reg &= ~DI1_COUNTER_RELEASE;
+	__raw_writel(reg, IPU_DISP_GEN);
+
+	complete(comp);
+	return IRQ_HANDLED;
 }
 
 void _ipu_dp_dc_disable(ipu_channel_t channel)
 {
+	int ret;
 	uint32_t lock_flags;
 	uint32_t reg;
 	uint32_t *dc_ch_conf;
 	int irq = 0;
-	int timeout = 30;
+	int timeout = 50;
+	DECLARE_COMPLETION_ONSTACK(dc_comp);
 
-	if (channel == MEM_FG_SYNC) {
-		dc_ch_conf = DC_WR_CH_CONF_5;
-		irq = IPU_IRQ_DP_SF_END;
-	} else if (channel == MEM_DC_SYNC) {
+	if (channel == MEM_DC_SYNC) {
 		dc_ch_conf = DC_WR_CH_CONF_1;
 		irq = IPU_IRQ_DC_FC_1;
 	} else if (channel == MEM_BG_SYNC) {
 		dc_ch_conf = DC_WR_CH_CONF_5;
 		irq = IPU_IRQ_DP_SF_END;
-	} else {
-		return;
-	}
-
-	if (channel == MEM_FG_SYNC) {
+	} else if (channel == MEM_FG_SYNC) {
 		/* Disable FG channel */
+
+		spin_lock_irqsave(&ipu_lock, lock_flags);
+
 		reg = __raw_readl(DP_COM_CONF(DP_SYNC));
 		__raw_writel(reg & ~DP_COM_CONF_FG_EN, DP_COM_CONF(DP_SYNC));
 
 		reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
 		__raw_writel(reg, IPU_SRM_PRI2);
-	}
 
-	__raw_writel(IPUIRQ_2_MASK(irq), IPUIRQ_2_STATREG(irq));
-	while ((__raw_readl(IPUIRQ_2_STATREG(irq)) & IPUIRQ_2_MASK(irq)) == 0) {
-		timeout--;
-		msleep(1);
-		if (timeout == 0) {
-			ipu_dump_registers();
-			break;
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+		__raw_writel(IPUIRQ_2_MASK(IPU_IRQ_DP_SF_END),
+			     IPUIRQ_2_STATREG(IPU_IRQ_DP_SF_END));
+		while ((__raw_readl(IPUIRQ_2_STATREG(IPU_IRQ_DP_SF_END)) &
+			IPUIRQ_2_MASK(IPU_IRQ_DP_SF_END)) == 0) {
+			msleep(2);
+			timeout -= 2;
+			if (timeout <= 0)
+				break;
 		}
+		return;
+	} else {
+		return;
 	}
-	dev_dbg(g_ipu_dev, "timeout = %d ms\n", (30 - timeout));
-
-	/* Wait for DI triple buffer to empty */
-	if (g_ipu_di_channel[0] == channel)
-		while ((__raw_readl(DC_STAT) & 0x00000002) != 0x00000002) ;
-	else if (g_ipu_di_channel[1] == channel)
-		while ((__raw_readl(DC_STAT) & 0x00000020) != 0x00000020) ;
 
-	udelay(50);
-
-	if (channel == MEM_FG_SYNC)
+	ipu_clear_irq(irq);
+	ret = ipu_request_irq(irq, dc_irq_handler, 0, NULL, &dc_comp);
+	if (ret < 0) {
+		dev_err(g_ipu_dev, "DC irq %d in use\n", irq);
 		return;
-
-	spin_lock_irqsave(&ipu_lock, lock_flags);
-
-	reg = __raw_readl(dc_ch_conf);
-	reg &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;
-	__raw_writel(reg, dc_ch_conf);
-
-	reg = __raw_readl(IPU_DISP_GEN);
-	if (g_ipu_di_channel[0] == channel)
-		reg &= ~DI0_COUNTER_RELEASE;
-	else if (g_ipu_di_channel[1] == channel)
-		reg &= ~DI1_COUNTER_RELEASE;
-	__raw_writel(reg, IPU_DISP_GEN);
-
-	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	}
+	ret = wait_for_completion_timeout(&dc_comp, msecs_to_jiffies(50));
+	dev_dbg(g_ipu_dev, "DC stop timeout - %d * 10ms\n", 5 - ret);
+	ipu_free_irq(irq, &dc_comp);
 }
 
 void _ipu_init_dc_mappings(void)
@@ -610,7 +624,7 @@ int32_t ipu_init_sync_panel(int disp, uint32_t pixel_clk,
 		field1_offset = v_sync_width + v_start_width + height / 2 +
 		    v_end_width;
 		if (sig.odd_field_first) {
-			field0_offset = field1_offset;
+			field0_offset = field1_offset - 1;
 			field1_offset = 0;
 		}
 		v_total += v_start_width + v_end_width;
@@ -630,7 +644,7 @@ int32_t ipu_init_sync_panel(int disp, uint32_t pixel_clk,
 		/* Active Field ? */
 		_ipu_di_sync_config(disp, 4,
 				    field0_offset ?
-				    field0_offset - 1 : field1_offset - 2,
+				    field0_offset : field1_offset - 2,
 				    1, v_start_width + v_sync_width, 1, 2, 2,
 				    0, DI_SYNC_NONE, DI_SYNC_NONE, 0, 0);
 
@@ -664,13 +678,15 @@ int32_t ipu_init_sync_panel(int disp, uint32_t pixel_clk,
 				    0, DI_SYNC_NONE,
 				    0, DI_SYNC_NONE, 6, DI_SYNC_NONE,
 				    DI_SYNC_NONE, 0, 0);
+		reg = __raw_readl(DI_SW_GEN1(disp, 9));
+		reg |= 0x8000;
+		__raw_writel(reg, DI_SW_GEN1(disp, 9));
 
 		/* Init template microcode */
 		_ipu_dc_write_tmpl(0, WROD(0), 0, map, SYNC_WAVE, 0, 8);
 
-		__raw_writel(width - 1, DC_UGDE_3(0));
-		__raw_writel(v_start_width + v_end_width + height / 2 - 1,
-			     DI_SCR_CONF(disp));
+		__raw_writel(v_sync_width + v_start_width +
+			     v_end_width + height / 2 - 1, DI_SCR_CONF(disp));
 
 		if (sig.Hsync_pol)
 			di_gen |= DI_GEN_POLARITY_3;
diff --git a/drivers/mxc/ipu3/ipu_regs.h b/drivers/mxc/ipu3/ipu_regs.h
index 9e18b4b..7fc6d16 100644
--- a/drivers/mxc/ipu3/ipu_regs.h
+++ b/drivers/mxc/ipu3/ipu_regs.h
@@ -171,6 +171,15 @@ extern u32 *ipu_tpmem_base;
 #define DC_EVT_NEW_CHAN		7
 #define DC_EVT_NEW_DATA		8
 
+#define dc_ch_offset(ch) \
+({ \
+	const char _offset[] = { \
+		0, 0x1C, 0x38, 0x54, 0x58, 0x5C, 0x78, 0, 0x94, 0xB4}; \
+	_offset[ch]; \
+})
+#define DC_WR_CH_CONF(ch)	(ipu_dc_reg + dc_ch_offset(ch)/4)
+#define DC_WR_CH_ADDR(ch)	(ipu_dc_reg + dc_ch_offset(ch)/4 + 4/4)
+
 #define DC_WR_CH_CONF_1		(ipu_dc_reg + 0x001C/4)
 #define DC_WR_CH_ADDR_1		(ipu_dc_reg + 0x0020/4)
 #define DC_WR_CH_CONF_5		(ipu_dc_reg + 0x005C/4)
@@ -391,6 +400,7 @@ enum {
 	DC_WR_CH_CONF_FIELD_MODE = 0x00000200,
 	DC_WR_CH_CONF_PROG_TYPE_OFFSET = 5,
 	DC_WR_CH_CONF_PROG_TYPE_MASK = 0x000000E0,
+	DC_WR_CH_CONF_PROG_DI_ID = 0x00000004,
 
 	DC_UGDE_0_ODD_EN = 0x02000000,
 	DC_UGDE_0_ID_CODED_MASK = 0x00000007,
diff --git a/drivers/video/mxc/mxc_ipuv3_fb.c b/drivers/video/mxc/mxc_ipuv3_fb.c
index bfaac69..46084f8 100644
--- a/drivers/video/mxc/mxc_ipuv3_fb.c
+++ b/drivers/video/mxc/mxc_ipuv3_fb.c
@@ -279,6 +279,7 @@ static int mxcfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 {
 	u32 vtotal;
 	u32 htotal;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
 
 	if (var->xres_virtual < var->xres)
 		var->xres_virtual = var->xres;
@@ -296,6 +297,11 @@ static int mxcfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 	    (var->bits_per_pixel != 16))
 		var->bits_per_pixel = default_bpp;
 
+	if (mxc_fbi->ipu_ch == MEM_DC_SYNC && mxc_fbi->ipu_di == 1) {
+		var->bits_per_pixel = 16;
+		var->nonstd = IPU_PIX_FMT_UYVY;
+	}
+
 	switch (var->bits_per_pixel) {
 	case 16:
 		var->red.length = 5;
diff --git a/drivers/video/mxc/tve.c b/drivers/video/mxc/tve.c
index 44b3403..2d4709f 100644
--- a/drivers/video/mxc/tve.c
+++ b/drivers/video/mxc/tve.c
@@ -346,7 +346,12 @@ static int tve_probe(struct platform_device *pdev)
 	__raw_writel(CD_SM_INT | CD_LM_INT, tve.base + TVE_STAT_REG);
 	__raw_writel(CD_SM_INT | CD_LM_INT, tve.base + TVE_INT_CONT_REG);
 
-	__raw_writel(0x00000002, tve.base + TVE_MV_CONT_REG);
+	__raw_writel(0x00000000, tve.base + 0x34);
+	__raw_writel(0x00000000, tve.base + 0x38);
+	__raw_writel(0x00000000, tve.base + 0x3C);
+	__raw_writel(0x00000000, tve.base + 0x40);
+	__raw_writel(0x00000000, tve.base + 0x44);
+	__raw_writel(0x00000000, tve.base + TVE_MV_CONT_REG);
 
 	ret = fb_register_client(&nb);
 	if (ret < 0)
diff --git a/include/asm-arm/arch-mxc/ipu.h b/include/asm-arm/arch-mxc/ipu.h
index 3677cb2..80286c5 100644
--- a/include/asm-arm/arch-mxc/ipu.h
+++ b/include/asm-arm/arch-mxc/ipu.h
@@ -368,15 +368,16 @@ typedef union {
 	} mem_sdc_fg;
 	struct {
 		uint32_t di;
+		bool interlaced;
 		uint32_t in_pixel_fmt;
 		uint32_t out_pixel_fmt;
-		bool interlaced;
 	} mem_dp_bg_sync;
 	struct {
 		uint32_t temp;
 	} mem_sdc_bg;
 	struct {
 		uint32_t di;
+		bool interlaced;
 		uint32_t in_pixel_fmt;
 		uint32_t out_pixel_fmt;
 	} mem_dp_fg_sync;
-- 
1.5.4.4

