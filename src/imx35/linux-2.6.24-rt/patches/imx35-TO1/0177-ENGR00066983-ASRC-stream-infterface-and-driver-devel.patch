From 5c4ddb7f26d6864c0046b48dcec59afc01d305ed Mon Sep 17 00:00:00 2001
From: Wallace Wang <r59996@freescale.com>
Date: Tue, 20 May 2008 03:13:08 +0800
Subject: [PATCH] ENGR00066983 ASRC stream infterface and driver development

ASRC driver interface
ASRC stream interface
ASRC proc entry to assign asrc channels

Signed-off-by: Wallace Wang <r59996@freescale.com>
---
 arch/arm/configs/imx35_3stack_defconfig |    7 +-
 arch/arm/mach-mx35/devices.c            |   33 +
 arch/arm/mach-mx35/dma.c                |  188 +++++
 drivers/mxc/Kconfig                     |    1 +
 drivers/mxc/Makefile                    |    1 +
 drivers/mxc/asrc/Kconfig                |   13 +
 drivers/mxc/asrc/Makefile               |    7 +
 drivers/mxc/asrc/mxc_asrc.c             | 1269 +++++++++++++++++++++++++++++++
 drivers/mxc/asrc/mxc_asrc.h             |  199 +++++
 include/asm-arm/arch-mxc/dma.h          |   12 +
 include/asm-arm/arch-mxc/mx35.h         |    8 +-
 11 files changed, 1736 insertions(+), 2 deletions(-)

diff --git a/arch/arm/configs/imx35_3stack_defconfig b/arch/arm/configs/imx35_3stack_defconfig
index 99e7f15..7d3d0b2 100644
--- a/arch/arm/configs/imx35_3stack_defconfig
+++ b/arch/arm/configs/imx35_3stack_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.24
-# Sun May 18 17:16:34 2008
+# Tue May 20 02:33:31 2008
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -1320,6 +1320,11 @@ CONFIG_MXC_HWEVENT=y
 #
 
 #
+# MXC Asynchronous Sample Rate Converter support
+#
+CONFIG_MXC_ASRC=y
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
diff --git a/arch/arm/mach-mx35/devices.c b/arch/arm/mach-mx35/devices.c
index a49f3ca..8579da8 100644
--- a/arch/arm/mach-mx35/devices.c
+++ b/arch/arm/mach-mx35/devices.c
@@ -494,6 +494,38 @@ static void mxc_init_audio(void)
 	platform_device_register(&mxc_alsa_device);
 }
 
+static struct resource asrc_resources[] = {
+	{
+	 .start = ASRC_BASE_ADDR,
+	 .end = ASRC_BASE_ADDR + 0x9C,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_alsa_asrc_device = {
+	.name = "mxc_asrc",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(asrc_resources),
+	.resource = asrc_resources,
+};
+
+static inline void mxc_init_asrc(void)
+{
+	struct clk *asrc_clk;
+	struct clk *asrc_audio_clk;
+	asrc_clk = clk_get(NULL, "asrc_clk");
+	clk_enable(asrc_clk);
+	clk_put(asrc_clk);
+	asrc_audio_clk = clk_get(NULL, "asrc_audio_clk");
+	clk_enable(asrc_audio_clk);
+	clk_set_rate(asrc_audio_clk, 768000);
+	clk_put(asrc_audio_clk);
+	platform_device_register(&mxc_alsa_asrc_device);
+}
+
 static int __init mxc_init_devices(void)
 {
 	mxc_init_wdt();
@@ -504,6 +536,7 @@ static int __init mxc_init_devices(void)
 	mxc_init_dma();
 	mxc_init_spdif();
 	mxc_init_audio();
+	mxc_init_asrc();
 
 	/* SPBA configuration for SSI2 - SDMA and MCU are set */
 	spba_take_ownership(SPBA_SSI2, SPBA_MASTER_C | SPBA_MASTER_A);
diff --git a/arch/arm/mach-mx35/dma.c b/arch/arm/mach-mx35/dma.c
index a4f81ab..75c1d1c 100644
--- a/arch/arm/mach-mx35/dma.c
+++ b/arch/arm/mach-mx35/dma.c
@@ -29,6 +29,14 @@
 #define MXC_SSI_TXFIFO_WML        0x4
 #define MXC_SSI_RXFIFO_WML        0x6
 
+#define MXC_ASRC_FIFO_WML	0x40
+#define MXC_ASRCA_RX_REG	0x60
+#define MXC_ASRCA_TX_REG	0x64
+#define MXC_ASRCB_RX_REG	0x68
+#define MXC_ASRCB_TX_REG	0x6C
+#define MXC_ASRCC_RX_REG        0x70
+#define MXC_ASRCC_TX_REG        0x74
+
 struct mxc_sdma_info_entry_s {
 	mxc_dma_device_t device;
 	mxc_sdma_channel_params_t *chnl_info;
@@ -507,6 +515,174 @@ static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
 	.chnl_priority = 2,
 };
 
+static mxc_sdma_channel_params_t mxc_sdma_asrca_16bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCA_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ASRC_DMA1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrca_16bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ASRC_DMA4,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcb_16bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCB_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ASRC_DMA2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcb_16bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ASRC_DMA5,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcc_16bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML * 3,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCC_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ASRC_DMA3,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCC_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcc_16bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML * 3,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCC_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ASRC_DMA6,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCC_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrca_32bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCA_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ASRC_DMA1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrca_32bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ASRC_DMA4,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcb_32bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCB_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ASRC_DMA2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcb_32bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ASRC_DMA5,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcc_32bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML * 3,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCC_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ASRC_DMA3,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCC_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcc_32bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML * 3,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCC_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ASRC_DMA6,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCC_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
 static struct mxc_sdma_info_entry_s mxc_sdma_active_dma_info[] = {
 	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
 	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
@@ -541,6 +717,18 @@ static struct mxc_sdma_info_entry_s mxc_sdma_active_dma_info[] = {
 	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
 	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
 	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
+	{MXC_DMA_ASRC_16BIT_A_RX, &mxc_sdma_asrca_16bit_rx_params},
+	{MXC_DMA_ASRC_16BIT_A_TX, &mxc_sdma_asrca_16bit_tx_params},
+	{MXC_DMA_ASRC_16BIT_B_RX, &mxc_sdma_asrcb_16bit_rx_params},
+	{MXC_DMA_ASRC_16BIT_B_TX, &mxc_sdma_asrcb_16bit_tx_params},
+	{MXC_DMA_ASRC_16BIT_C_RX, &mxc_sdma_asrcc_16bit_rx_params},
+	{MXC_DMA_ASRC_16BIT_C_TX, &mxc_sdma_asrcc_16bit_tx_params},
+	{MXC_DMA_ASRC_32BIT_A_RX, &mxc_sdma_asrca_32bit_rx_params},
+	{MXC_DMA_ASRC_32BIT_A_TX, &mxc_sdma_asrca_32bit_tx_params},
+	{MXC_DMA_ASRC_32BIT_B_RX, &mxc_sdma_asrcb_32bit_rx_params},
+	{MXC_DMA_ASRC_32BIT_B_TX, &mxc_sdma_asrcb_32bit_tx_params},
+	{MXC_DMA_ASRC_32BIT_C_RX, &mxc_sdma_asrcc_32bit_rx_params},
+	{MXC_DMA_ASRC_32BIT_C_TX, &mxc_sdma_asrcc_32bit_tx_params},
 	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
 };
 
diff --git a/drivers/mxc/Kconfig b/drivers/mxc/Kconfig
index 8b1633d..cdbd7b4 100644
--- a/drivers/mxc/Kconfig
+++ b/drivers/mxc/Kconfig
@@ -25,6 +25,7 @@ source "drivers/mxc/security/Kconfig"
 source "drivers/mxc/hmp4e/Kconfig"
 source "drivers/mxc/hw_event/Kconfig"
 source "drivers/mxc/vpu/Kconfig"
+source "drivers/mxc/asrc/Kconfig"
 
 endmenu
 
diff --git a/drivers/mxc/Makefile b/drivers/mxc/Makefile
index b1d9a48..64e0a0c 100644
--- a/drivers/mxc/Makefile
+++ b/drivers/mxc/Makefile
@@ -11,3 +11,4 @@ obj-$(CONFIG_MXC_HMP4E)         	+= hmp4e/
 obj-y                                   += security/
 obj-$(CONFIG_MXC_VPU)                   += vpu/
 obj-$(CONFIG_MXC_HWEVENT)               += hw_event/
+obj-$(CONFIG_MXC_ASRC)                 += asrc/
diff --git a/drivers/mxc/asrc/Kconfig b/drivers/mxc/asrc/Kconfig
new file mode 100644
index 0000000..a4c66b1
--- /dev/null
+++ b/drivers/mxc/asrc/Kconfig
@@ -0,0 +1,13 @@
+#
+# ASRC configuration
+#
+
+menu "MXC Asynchronous Sample Rate Converter support"
+
+config MXC_ASRC
+	tristate "ASRC support"
+	depends on ARCH_MX35
+	---help---
+         Say Y to get the ASRC service.
+
+endmenu
diff --git a/drivers/mxc/asrc/Makefile b/drivers/mxc/asrc/Makefile
new file mode 100644
index 0000000..0d2487d
--- /dev/null
+++ b/drivers/mxc/asrc/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the kernel Asynchronous Sample Rate Converter driver
+#
+
+ifeq ($(CONFIG_ARCH_MX35),y)
+	obj-$(CONFIG_MXC_ASRC) += mxc_asrc.o
+endif
diff --git a/drivers/mxc/asrc/mxc_asrc.c b/drivers/mxc/asrc/mxc_asrc.c
new file mode 100644
index 0000000..67a7032
--- /dev/null
+++ b/drivers/mxc/asrc/mxc_asrc.c
@@ -0,0 +1,1269 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_asrc.c
+ *
+ * @brief MXC Asynchronous Sample Rate Converter
+ *
+ * @ingroup SOUND
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/pagemap.h>
+#include <linux/vmalloc.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/interrupt.h>
+#include <asm/arch/dma.h>
+#include <asm/irq.h>
+#include <asm/memory.h>
+#include <linux/proc_fs.h>
+#include <linux/dma-mapping.h>
+#include "mxc_asrc.h"
+
+static int asrc_major;
+static struct class *asrc_class;
+#define ASRC_PROC_PATH        "driver/asrc"
+
+#define ASRC_RATIO_DECIMAL_DEPTH 26
+
+DEFINE_SPINLOCK(data_lock);
+DEFINE_SPINLOCK(input_int_lock);
+DEFINE_SPINLOCK(output_int_lock);
+
+enum asrc_status {
+	ASRC_ASRSTR_AIDEA = 0x01,
+	ASRC_ASRSTR_AIDEB = 0x02,
+	ASRC_ASRSTR_AIDEC = 0x04,
+	ASRC_ASRSTR_AODFA = 0x08,
+	ASRC_ASRSTR_AODFB = 0x10,
+	ASRC_ASRSTR_AODFC = 0x20,
+	ASRC_ASRSTR_AOLE = 0x40,
+	ASRC_ASRSTR_FPWT = 0x80,
+	ASRC_ASRSTR_AIDUA = 0x100,
+	ASRC_ASRSTR_AIDUB = 0x200,
+	ASRC_ASRSTR_AIDUC = 0x400,
+	ASRC_ASRSTR_AODOA = 0x800,
+	ASRC_ASRSTR_AODOB = 0x1000,
+	ASRC_ASRSTR_AODOC = 0x2000,
+	ASRC_ASRSTR_AIOLA = 0x4000,
+	ASRC_ASRSTR_AIOLB = 0x8000,
+	ASRC_ASRSTR_AIOLC = 0x10000,
+	ASRC_ASRSTR_AOOLA = 0x20000,
+	ASRC_ASRSTR_AOOLB = 0x40000,
+	ASRC_ASRSTR_AOOLC = 0x80000,
+	ASRC_ASRSTR_ATQOA = 0x100000,
+	ASRC_ASRSTR_DSLCNT = 0x200000,
+};
+
+static const unsigned char asrc_process_table[][8][2] = {
+	/* 32kHz 44.1kHz 48kHz   64kHz   88.2kHz 96kHz  128kHz   192kHz */
+/*8kHz*/
+	{{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},},
+/*12kHz*/
+	{{0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},},
+/*16kHz*/
+	{{0, 1}, {0, 1}, {0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},},
+/*24kHz*/
+	{{0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0},},
+/*32kHz*/
+	{{0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 0}, {0, 0}, {0, 0},},
+/*44.1kHz*/
+	{{0, 2}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 0}, {0, 0},},
+/*48kHz*/
+	{{0, 2}, {0, 2}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 0},},
+/*64kHz*/
+	{{0, 2}, {0, 2}, {0, 2}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 0},},
+/*88.2kHz*/
+	{{1, 2}, {1, 2}, {1, 2}, {1, 1}, {1, 1}, {1, 1}, {1, 1}, {1, 1},},
+/*96kHz*/
+	{{1, 2}, {1, 2}, {1, 2}, {1, 1}, {1, 1}, {1, 1}, {1, 1}, {1, 1},},
+/*128kHz*/
+	{{1, 2}, {1, 2}, {1, 2}, {1, 1}, {1, 1}, {1, 1}, {1, 1}, {1, 1},},
+/*192kHz*/
+	{{2, 2}, {2, 2}, {2, 2}, {2, 1}, {2, 1}, {2, 1}, {2, 1}, {2, 1},},
+};
+
+static const unsigned char asrc_divider_table[] = {
+/*8kHz 12kHz 16kHz 24kHz 32kHz 44.1kHz 48kHz 64kHz 88.2kHz 96kHz 128kHz 192kHz*/
+	0x15, 0x06, 0x14, 0x05, 0x13, 0x04, 0x04, 0x12, 0x03, 0x03, 0x11, 0x02,
+};
+
+static struct asrc_data *g_asrc_data;
+static struct proc_dir_entry *proc_asrc;
+static unsigned long asrc_vrt_base_addr;
+
+static int asrc_set_clock_ratio(enum asrc_pair_index index,
+				int input_sample_rate, int output_sample_rate)
+{
+	int i;
+	int integ = 0;
+	unsigned long reg_val = 0;
+
+	if (output_sample_rate == 0)
+		return -1;
+
+	while (input_sample_rate >= output_sample_rate) {
+		input_sample_rate -= output_sample_rate;
+		integ++;
+	}
+	reg_val |= (integ << 26);
+
+	for (i = 1; i <= ASRC_RATIO_DECIMAL_DEPTH; i++) {
+		if ((input_sample_rate * 2) >= output_sample_rate) {
+			reg_val |= (1 << (ASRC_RATIO_DECIMAL_DEPTH - i));
+			input_sample_rate =
+			    input_sample_rate * 2 - output_sample_rate;
+		} else
+			input_sample_rate = input_sample_rate << 1;
+
+		if (input_sample_rate == 0)
+			break;
+	}
+
+	__raw_writel(reg_val,
+		     (asrc_vrt_base_addr + ASRC_ASRIDRLA_REG + (index << 3)));
+	__raw_writel((reg_val >> 24),
+		     (asrc_vrt_base_addr + ASRC_ASRIDRHA_REG + (index << 3)));
+
+	return 0;
+}
+
+static int asrc_set_process_configuration(enum asrc_pair_index index,
+					  int input_sample_rate,
+					  int output_sample_rate)
+{
+	int i = 0, j = 0;
+	unsigned long reg;
+
+	if (input_sample_rate == 8000)
+		i = 0;
+	else if (input_sample_rate == 12000)
+		i = 1;
+	else if (input_sample_rate == 16000)
+		i = 2;
+	else if (input_sample_rate == 24000)
+		i = 3;
+	else if (input_sample_rate == 32000)
+		i = 4;
+	else if (input_sample_rate == 44100)
+		i = 5;
+	else if (input_sample_rate == 48000)
+		i = 6;
+	else if (input_sample_rate == 64000)
+		i = 7;
+	else if (input_sample_rate == 88200)
+		i = 8;
+	else if (input_sample_rate == 96000)
+		i = 9;
+	else if (input_sample_rate == 128000)
+		i = 10;
+	else if (input_sample_rate == 192000)
+		i = 11;
+	else
+		return -1;
+
+	if (output_sample_rate == 32000)
+		j = 0;
+	else if (output_sample_rate == 44100)
+		j = 1;
+	else if (output_sample_rate == 48000)
+		j = 2;
+	else if (output_sample_rate == 64000)
+		j = 3;
+	else if (output_sample_rate == 88200)
+		j = 4;
+	else if (output_sample_rate == 96000)
+		j = 5;
+	else if (output_sample_rate == 128000)
+		j = 6;
+	else if (output_sample_rate == 192000)
+		j = 7;
+	else
+		return -1;
+
+	reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCFG_REG);
+	reg &= ~(0x0f << (6 + (index << 2)));
+	reg |=
+	    ((asrc_process_table[i][j][0] << (6 + (index << 2))) |
+	     (asrc_process_table[i][j][1] << (8 + (index << 2))));
+	__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCFG_REG);
+
+	if (index == ASRC_PAIR_A) {
+		reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCDR1_REG);
+		reg &= 0xfc0fc0;
+		reg |=
+		    (asrc_divider_table[i] | (asrc_divider_table[j + 4] << 12));
+		__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCDR1_REG);
+	} else if (index == ASRC_PAIR_B) {
+		reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCDR1_REG);
+		reg &= 0x3f03f;
+		reg |=
+		    ((asrc_divider_table[i] << 6) |
+		     (asrc_divider_table[j + 4] << 18));
+		__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCDR1_REG);
+	} else {
+		reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCDR2_REG);
+		reg =
+		    (asrc_divider_table[i] | (asrc_divider_table[j + 4] << 6));
+		__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCDR2_REG);
+	}
+
+	return 0;
+}
+
+int asrc_req_pair(int chn_num, enum asrc_pair_index *index)
+{
+	int err = 0;
+	unsigned long lock_flags;
+	spin_lock_irqsave(&data_lock, lock_flags);
+	if (chn_num > 2) {
+		if (g_asrc_data->asrc_pair[ASRC_PAIR_C].active
+		    || (chn_num > g_asrc_data->asrc_pair[ASRC_PAIR_C].chn_max))
+			err = -EBUSY;
+		else {
+			*index = ASRC_PAIR_C;
+			g_asrc_data->asrc_pair[ASRC_PAIR_C].chn_num = chn_num;
+			g_asrc_data->asrc_pair[ASRC_PAIR_C].active = 1;
+		}
+	} else {
+		if (g_asrc_data->asrc_pair[ASRC_PAIR_A].active ||
+		    (g_asrc_data->asrc_pair[ASRC_PAIR_A].chn_max == 0)) {
+			if (g_asrc_data->asrc_pair[ASRC_PAIR_B].
+			    active
+			    || (g_asrc_data->asrc_pair[ASRC_PAIR_B].
+				chn_max == 0))
+				err = -EBUSY;
+			else {
+				*index = ASRC_PAIR_B;
+				g_asrc_data->asrc_pair[ASRC_PAIR_B].chn_num = 2;
+				g_asrc_data->asrc_pair[ASRC_PAIR_B].active = 1;
+			}
+		} else {
+			*index = ASRC_PAIR_A;
+			g_asrc_data->asrc_pair[ASRC_PAIR_A].chn_num = 2;
+			g_asrc_data->asrc_pair[ASRC_PAIR_A].active = 1;
+		}
+	}
+	spin_unlock_irqrestore(&data_lock, lock_flags);
+	return err;
+}
+
+EXPORT_SYMBOL(asrc_req_pair);
+
+void asrc_release_pair(enum asrc_pair_index index)
+{
+	unsigned long reg;
+	unsigned long lock_flags;
+	spin_lock_irqsave(&data_lock, lock_flags);
+	g_asrc_data->asrc_pair[index].active = 0;
+	/********Disable PAIR*************/
+	reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCTR_REG);
+	reg &= ~(1 << (index + 1));
+	__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCTR_REG);
+	spin_unlock_irqrestore(&data_lock, lock_flags);
+}
+
+EXPORT_SYMBOL(asrc_release_pair);
+
+int asrc_config_pair(struct asrc_config *config)
+{
+	int err = 0;
+	int reg, tmp;
+	unsigned long lock_flags;
+	/* Set the channel number */
+	reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCNCR_REG);
+	spin_lock_irqsave(&data_lock, lock_flags);
+	g_asrc_data->asrc_pair[config->pair].chn_num = config->channel_num;
+	spin_unlock_irqrestore(&data_lock, lock_flags);
+	reg &= ~(0x07 << (3 * config->pair));
+	tmp = (((config->channel_num + 1) / 2) << (3 * config->pair));
+	reg |= tmp;
+	__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCNCR_REG);
+
+	/* Set the clock source */
+	reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCSR_REG);
+	tmp = ~(0x0f << (config->pair << 2));
+	reg &= tmp;
+	tmp = ~(0x0f << (12 + (config->pair << 2)));
+	reg &= tmp;
+	reg |=
+	    ((config->inclk << (config->pair << 2)) | (config->
+						       outclk << (12 +
+								  (config->
+								   pair <<
+								   2))));
+
+	__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCSR_REG);
+
+	reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCTR_REG);
+	if ((config->inclk & 0x0f) != INCLK_NONE) {
+		reg |= (1 << (20 + config->pair));
+		reg &= ~(1 << (14 + (config->pair << 1)));
+		__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCTR_REG);
+	} else {
+		reg &= ~(1 << (20 + config->pair));
+		reg |= (0x03 << (13 + (config->pair << 1)));
+		__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCTR_REG);
+		err =
+		    asrc_set_clock_ratio(config->pair,
+					 config->input_sample_rate,
+					 config->output_sample_rate);
+		if (err < 0)
+			return err;
+	}
+
+	err = asrc_set_process_configuration(config->pair,
+					     config->input_sample_rate,
+					     config->output_sample_rate);
+	return err;
+}
+
+EXPORT_SYMBOL(asrc_config_pair);
+
+void asrc_start_conv(enum asrc_pair_index index)
+{
+	int reg;
+	unsigned long lock_flags;
+	spin_lock_irqsave(&data_lock, lock_flags);
+	reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCTR_REG);
+	reg |= (1 << (1 + index));
+	__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCTR_REG);
+	spin_unlock_irqrestore(&data_lock, lock_flags);
+
+	return;
+}
+
+EXPORT_SYMBOL(asrc_start_conv);
+
+void asrc_stop_conv(enum asrc_pair_index index)
+{
+	int reg;
+	unsigned long lock_flags;
+	spin_lock_irqsave(&data_lock, lock_flags);
+
+	reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCTR_REG);
+	reg &= ~(1 << (1 + index));
+	__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCTR_REG);
+	spin_unlock_irqrestore(&data_lock, lock_flags);
+	return;
+}
+
+EXPORT_SYMBOL(asrc_stop_conv);
+
+/*!
+ * @brief asrc interrupt handler
+ */
+static irqreturn_t asrc_isr(int irq, void *dev_id)
+{
+	unsigned long status;
+	status = __raw_readl(asrc_vrt_base_addr + ASRC_ASRSTR_REG);
+
+	if (status & ASRC_ASRSTR_AOLE) {
+		pr_info("asrc overload error\n");
+		/*****How to clear it, write 1 to this bit?*/
+	}
+
+	if (status & ASRC_ASRSTR_AIDUA)
+		pr_info("input data buffer A has underflowed\n");
+
+	if (status & ASRC_ASRSTR_AIDUB)
+		pr_info("input data buffer B has underflowed\n");
+
+	if (status & ASRC_ASRSTR_AIDUC)
+		pr_info("input data buffer C has underflowed\n");
+
+	if (status & ASRC_ASRSTR_AODOA)
+		pr_info("output data buffer A has overflowed\n");
+
+	if (status & ASRC_ASRSTR_AODOB)
+		pr_info("output data buffer B has overflowed\n");
+
+	if (status & ASRC_ASRSTR_AODOC)
+		pr_info("output data buffer C has overflowed\n");
+
+	return IRQ_HANDLED;
+}
+
+static int mxc_init_asrc(void)
+{
+
+	/* Halt ASRC internal FP when input FIFO needs data for pair A, B, C */
+	__raw_writel(0x0001, asrc_vrt_base_addr + ASRC_ASRCTR_REG);
+
+	/* Enable overflow interrupt */
+	__raw_writel(0x00, asrc_vrt_base_addr + ASRC_ASRIER_REG);
+
+	/* Default 6: 2: 2 channel assignment */
+	__raw_writel(0xC9, asrc_vrt_base_addr + ASRC_ASRCNCR_REG);
+
+	/* Parameter Registers recommended settings */
+	__raw_writel(0x7fffff, asrc_vrt_base_addr + ASRC_ASRPM1_REG);
+	__raw_writel(0x255555, asrc_vrt_base_addr + ASRC_ASRPM2_REG);
+	__raw_writel(0xff7280, asrc_vrt_base_addr + ASRC_ASRPM3_REG);
+	__raw_writel(0xff7280, asrc_vrt_base_addr + ASRC_ASRPM4_REG);
+	__raw_writel(0xff7280, asrc_vrt_base_addr + ASRC_ASRPM5_REG);
+
+	/* Set the processing clock for 76KHz, 133M  */
+	__raw_writel(0x06D6, asrc_vrt_base_addr + ASRC_ASR76K_REG);
+
+	/* Set the processing clock for 56KHz, 133M */
+	__raw_writel(0x0947, asrc_vrt_base_addr + ASRC_ASR56K_REG);
+
+	if (request_irq(MXC_INT_ASRC, asrc_isr, 0, "asrc", NULL))
+		return -1;
+
+	return 0;
+}
+
+static int asrc_get_output_buffer_size(int input_buffer_size,
+				       int input_sample_rate,
+				       int output_sample_rate)
+{
+	int i = 0;
+	int outbuffer_size = 0;
+	int outsample = output_sample_rate;
+	while (outsample >= input_sample_rate) {
+		++i;
+		outsample -= input_sample_rate;
+	}
+	outbuffer_size = i * input_buffer_size;
+	i = 1;
+	while (((input_buffer_size >> i) > 2) && (outsample != 0)) {
+		if (((outsample << 1) - input_sample_rate) >= 0) {
+			outsample = (outsample << 1) - input_sample_rate;
+			outbuffer_size += (input_buffer_size >> i);
+		} else {
+			outsample = outsample << 1;
+		}
+		i++;
+	}
+	outbuffer_size = (outbuffer_size >> 3) << 3;
+	return outbuffer_size;
+}
+
+static void asrc_input_dma_callback(void *data, int error, unsigned int count)
+{
+	struct asrc_pair_params *params;
+	struct dma_block *block;
+	mxc_dma_requestbuf_t dma_request;
+	unsigned long lock_flags;
+
+	params = data;
+	spin_lock_irqsave(&input_int_lock, lock_flags);
+	block = list_entry(params->input_queue.next, struct dma_block, queue);
+	list_del(params->input_queue.next);
+	list_add_tail(&block->queue, &params->input_done_queue);
+	params->input_counter++;
+	if (params->input_counter > 1)
+		pr_info("asrc_input_dma_callback - counter: %d\n",
+			params->input_counter);
+	if (!list_empty(&params->input_queue)) {
+		block =
+		    list_entry(params->input_queue.next,
+			       struct dma_block, queue);
+		dma_request.src_addr = (dma_addr_t) block->dma_paddr;
+		dma_request.dst_addr =
+		    (ASRC_BASE_ADDR + ASRC_ASRDIA_REG + (params->index << 3));
+		dma_request.num_of_bytes = block->length;
+		mxc_dma_config(params->input_dma_channel, &dma_request,
+			       1, MXC_DMA_MODE_WRITE);
+		mxc_dma_enable(params->input_dma_channel);
+	} else
+		params->input_queue_empty = 1;
+	wake_up_interruptible(&params->input_wait_queue);
+	spin_unlock_irqrestore(&input_int_lock, lock_flags);
+	return;
+}
+
+static void asrc_output_dma_callback(void *data, int error, unsigned int count)
+{
+	struct asrc_pair_params *params;
+	struct dma_block *block;
+	mxc_dma_requestbuf_t dma_request;
+	unsigned long lock_flags;
+
+	params = data;
+	spin_lock_irqsave(&output_int_lock, lock_flags);
+	block = list_entry(params->output_queue.next, struct dma_block, queue);
+	list_del(params->output_queue.next);
+	list_add_tail(&block->queue, &params->output_done_queue);
+	params->output_counter++;
+	if (params->output_counter > 1)
+		pr_info("asrc_output_dma_callback - counter: %d\n",
+			params->output_counter);
+
+	if (!list_empty(&params->output_queue)) {
+		block =
+		    list_entry(params->output_queue.next,
+			       struct dma_block, queue);
+		dma_request.src_addr =
+		    (ASRC_BASE_ADDR + ASRC_ASRDOA_REG + (params->index << 3));
+		dma_request.dst_addr = (dma_addr_t) block->dma_paddr;
+		dma_request.num_of_bytes = block->length;
+		mxc_dma_config(params->output_dma_channel, &dma_request,
+			       1, MXC_DMA_MODE_READ);
+		mxc_dma_enable(params->output_dma_channel);
+	} else
+		params->output_queue_empty = 1;
+	wake_up_interruptible(&params->output_wait_queue);
+	spin_unlock_irqrestore(&output_int_lock, lock_flags);
+	return;
+}
+
+static void mxc_free_dma_buf(struct asrc_pair_params *params)
+{
+	int i;
+	for (i = 0; i < ASRC_DMA_BUFFER_NUM; i++) {
+		if (params->input_dma[i].dma_vaddr != NULL) {
+			dma_free_coherent(0,
+					  params->input_buffer_size,
+					  params->input_dma[i].
+					  dma_vaddr,
+					  params->input_dma[i].dma_paddr);
+			params->input_dma[i].dma_vaddr = NULL;
+		}
+		if (params->output_dma[i].dma_vaddr != NULL) {
+			dma_free_coherent(0,
+					  params->output_buffer_size,
+					  params->output_dma[i].
+					  dma_vaddr,
+					  params->output_dma[i].dma_paddr);
+			params->output_dma[i].dma_vaddr = NULL;
+		}
+	}
+
+	return;
+}
+
+static int mxc_allocate_dma_buf(struct asrc_pair_params *params)
+{
+	int i;
+
+	for (i = 0; i < ASRC_DMA_BUFFER_NUM; i++) {
+		params->input_dma[i].dma_vaddr =
+		    dma_alloc_coherent(0, params->input_buffer_size,
+				       &params->input_dma[i].dma_paddr,
+				       GFP_DMA | GFP_KERNEL);
+		if (params->input_dma[i].dma_vaddr == NULL) {
+			mxc_free_dma_buf(params);
+			pr_info("can't allocate buff\n");
+			return -ENOBUFS;
+		}
+	}
+	for (i = 0; i < ASRC_DMA_BUFFER_NUM; i++) {
+		params->output_dma[i].dma_vaddr =
+		    dma_alloc_coherent(0,
+				       params->output_buffer_size,
+				       &params->output_dma[i].dma_paddr,
+				       GFP_DMA | GFP_KERNEL);
+		if (params->output_dma[i].dma_vaddr == NULL) {
+			mxc_free_dma_buf(params);
+			return -ENOBUFS;
+		}
+	}
+
+	return 0;
+}
+
+/*!
+ * asrc interface - ioctl function
+ *
+ * @param inode      struct inode *
+ *
+ * @param file       struct file *
+ *
+ * @param cmd    unsigned int
+ *
+ * @param arg        unsigned long
+ *
+ * @return           0 success, ENODEV for invalid device instance,
+ *                   -1 for other errors.
+ */
+static int asrc_ioctl(struct inode *inode, struct file *file,
+		      unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+	struct asrc_pair_params *params;
+	params = file->private_data;
+
+	if (down_interruptible(&params->busy_lock))
+		return -EBUSY;
+
+	switch (cmd) {
+	case ASRC_REQ_PAIR:
+		{
+			struct asrc_req req;
+			if (copy_from_user(&req, (void __user *)arg,
+					   sizeof(struct asrc_req))) {
+				err = -EFAULT;
+				break;
+			}
+			err = asrc_req_pair(req.chn_num, &req.index);
+			if (err < 0)
+				break;
+			params->pair_hold = 1;
+			if (copy_to_user
+			    ((void __user *)arg, &req, sizeof(struct asrc_req)))
+				err = -EFAULT;
+
+			break;
+		}
+	case ASRC_CONIFG_PAIR:
+		{
+			struct asrc_config config;
+			mxc_dma_device_t rx_id, tx_id;
+			char *rx_name, *tx_name;
+			int channel = -1;
+			if (copy_from_user
+			    (&config, (void __user *)arg,
+			     sizeof(struct asrc_config))) {
+				err = -EFAULT;
+				break;
+			}
+			config.inclk = INCLK_NONE;
+			config.outclk = OUTCLK_ASRCK1_CLK;
+			err = asrc_config_pair(&config);
+			if (err < 0)
+				break;
+			params->output_buffer_size =
+			    asrc_get_output_buffer_size(config.
+							dma_buffer_size,
+							config.
+							input_sample_rate,
+							config.
+							output_sample_rate);
+			params->input_buffer_size = config.dma_buffer_size;
+			if (config.buffer_num > ASRC_DMA_BUFFER_NUM)
+				params->buffer_num = ASRC_DMA_BUFFER_NUM;
+			else
+				params->buffer_num = config.buffer_num;
+			err = mxc_allocate_dma_buf(params);
+			if (err < 0)
+				break;
+
+			/* TBD - need to update when new SDMA interface ready */
+			if (config.pair == ASRC_PAIR_A) {
+				if (config.frame_bits > 16) {
+					rx_id = MXC_DMA_ASRC_32BIT_A_RX;
+					tx_id = MXC_DMA_ASRC_32BIT_A_TX;
+				} else {
+					rx_id = MXC_DMA_ASRC_16BIT_A_RX;
+					tx_id = MXC_DMA_ASRC_16BIT_A_TX;
+				}
+				rx_name = asrc_pair_id[0];
+				tx_name = asrc_pair_id[1];
+			} else if (config.pair == ASRC_PAIR_B) {
+				if (config.frame_bits > 16) {
+					rx_id = MXC_DMA_ASRC_32BIT_B_RX;
+					tx_id = MXC_DMA_ASRC_32BIT_B_TX;
+				} else {
+					rx_id = MXC_DMA_ASRC_16BIT_B_RX;
+					tx_id = MXC_DMA_ASRC_16BIT_B_TX;
+				}
+				rx_name = asrc_pair_id[2];
+				tx_name = asrc_pair_id[3];
+			} else {
+				if (config.frame_bits > 16) {
+					rx_id = MXC_DMA_ASRC_32BIT_C_RX;
+					tx_id = MXC_DMA_ASRC_32BIT_C_TX;
+				} else {
+					rx_id = MXC_DMA_ASRC_16BIT_C_RX;
+					tx_id = MXC_DMA_ASRC_16BIT_C_TX;
+				}
+				rx_name = asrc_pair_id[4];
+				tx_name = asrc_pair_id[5];
+			}
+			channel = mxc_dma_request(rx_id, rx_name);
+			params->input_dma_channel = channel;
+			err = mxc_dma_callback_set(channel, (mxc_dma_callback_t)
+						   asrc_input_dma_callback,
+						   (void *)params);
+			channel = mxc_dma_request(tx_id, tx_name);
+			params->output_dma_channel = channel;
+			err = mxc_dma_callback_set(channel, (mxc_dma_callback_t)
+						   asrc_output_dma_callback,
+						   (void *)params);
+			/* TBD - need to update when new SDMA interface ready */
+			params->input_queue_empty = 0;
+			params->output_queue_empty = 0;
+			INIT_LIST_HEAD(&params->input_queue);
+			INIT_LIST_HEAD(&params->input_done_queue);
+			INIT_LIST_HEAD(&params->output_queue);
+			INIT_LIST_HEAD(&params->output_done_queue);
+			init_waitqueue_head(&params->input_wait_queue);
+			init_waitqueue_head(&params->output_wait_queue);
+
+			if (copy_to_user
+			    ((void __user *)arg, &config,
+			     sizeof(struct asrc_config)))
+				err = -EFAULT;
+			break;
+		}
+	case ASRC_QUERYBUF:
+		{
+			struct asrc_querybuf buffer;
+			if (copy_from_user
+			    (&buffer, (void __user *)arg,
+			     sizeof(struct asrc_querybuf))) {
+				err = -EFAULT;
+				break;
+			}
+			buffer.input_offset =
+			    (unsigned long)params->input_dma[buffer.
+							     buffer_index].
+			    dma_paddr;
+			buffer.input_length = params->input_buffer_size;
+			buffer.output_offset =
+			    (unsigned long)params->output_dma[buffer.
+							      buffer_index].
+			    dma_paddr;
+			buffer.output_length = params->output_buffer_size;
+			if (copy_to_user
+			    ((void __user *)arg, &buffer,
+			     sizeof(struct asrc_querybuf)))
+				err = -EFAULT;
+			break;
+		}
+	case ASRC_RELEASE_PAIR:
+		{
+			enum asrc_pair_index index;
+			if (copy_from_user
+			    (&index, (void __user *)arg,
+			     sizeof(enum asrc_pair_index))) {
+				err = -EFAULT;
+				break;
+			}
+
+			mxc_dma_free(params->input_dma_channel);
+			mxc_dma_free(params->output_dma_channel);
+			mxc_free_dma_buf(params);
+			asrc_release_pair(index);
+			params->pair_hold = 0;
+			break;
+		}
+	case ASRC_Q_INBUF:
+		{
+			struct asrc_buffer buf;
+			struct dma_block *block;
+			mxc_dma_requestbuf_t dma_request;
+			unsigned long lock_flags;
+			if (copy_from_user
+			    (&buf, (void __user *)arg,
+			     sizeof(struct asrc_buffer))) {
+				err = -EFAULT;
+				break;
+			}
+			spin_lock_irqsave(&input_int_lock, lock_flags);
+			params->input_dma[buf.index].index = buf.index;
+			params->input_dma[buf.index].length = buf.length;
+			list_add_tail(&params->input_dma[buf.index].
+				      queue, &params->input_queue);
+			if (params->input_queue_empty == 1) {
+				pr_info("INPUT QUEUE empty\n");
+				block =
+				    list_entry(params->input_queue.next,
+					       struct dma_block, queue);
+				dma_request.src_addr =
+				    (dma_addr_t) block->dma_paddr;
+				dma_request.dst_addr =
+				    (ASRC_BASE_ADDR + ASRC_ASRDIA_REG +
+				     (params->index << 3));
+				dma_request.num_of_bytes = block->length;
+				mxc_dma_config(params->
+					       input_dma_channel,
+					       &dma_request, 1,
+					       MXC_DMA_MODE_WRITE);
+				params->input_queue_empty = 0;
+				mxc_dma_enable(params->input_dma_channel);
+			}
+			spin_unlock_irqrestore(&input_int_lock, lock_flags);
+			break;
+		}
+	case ASRC_DQ_INBUF:{
+			struct asrc_buffer buf;
+			struct dma_block *block;
+			unsigned long lock_flags;
+			if (copy_from_user
+			    (&buf, (void __user *)arg,
+			     sizeof(struct asrc_buffer))) {
+				err = -EFAULT;
+				break;
+			}
+			if (!wait_event_interruptible_timeout
+			    (params->input_wait_queue,
+			     params->input_counter != 0, 10 * HZ)) {
+				pr_info
+				    ("ASRC_DQ_INBUF timeout counter %x\n",
+				     params->input_counter);
+				err = -ETIME;
+				break;
+			} else if (signal_pending(current)) {
+				pr_info("ASRC_DQ_INBUF interrupt received\n");
+				err = -ERESTARTSYS;
+				break;
+			}
+			spin_lock_irqsave(&input_int_lock, lock_flags);
+			params->input_counter--;
+			block =
+			    list_entry(params->input_done_queue.next,
+				       struct dma_block, queue);
+			list_del(params->input_done_queue.next);
+			spin_unlock_irqrestore(&input_int_lock, lock_flags);
+			buf.index = block->index;
+			buf.length = block->length;
+			if (copy_to_user
+			    ((void __user *)arg, &buf,
+			     sizeof(struct asrc_buffer)))
+				err = -EFAULT;
+
+			break;
+		}
+	case ASRC_Q_OUTBUF:{
+			struct asrc_buffer buf;
+			struct dma_block *block;
+			mxc_dma_requestbuf_t dma_request;
+			unsigned long lock_flags;
+			if (copy_from_user
+			    (&buf, (void __user *)arg,
+			     sizeof(struct asrc_buffer))) {
+				err = -EFAULT;
+				break;
+			}
+			spin_lock_irqsave(&output_int_lock, lock_flags);
+			params->output_dma[buf.index].index = buf.index;
+			params->output_dma[buf.index].length = buf.length;
+			list_add_tail(&params->output_dma[buf.index].
+				      queue, &params->output_queue);
+			if (params->output_queue_empty == 1) {
+				pr_info("OUTPUT QUEUE empty\n");
+				block =
+				    list_entry(params->output_queue.
+					       next, struct dma_block, queue);
+				dma_request.src_addr =
+				    (ASRC_BASE_ADDR + ASRC_ASRDOA_REG +
+				     (params->index << 3));
+				dma_request.dst_addr =
+				    (dma_addr_t) block->dma_paddr;
+				dma_request.num_of_bytes = block->length;
+				mxc_dma_config(params->
+					       output_dma_channel,
+					       &dma_request, 1,
+					       MXC_DMA_MODE_READ);
+				params->output_queue_empty = 0;
+				mxc_dma_enable(params->output_dma_channel);
+			}
+			spin_unlock_irqrestore(&output_int_lock, lock_flags);
+			break;
+		}
+	case ASRC_DQ_OUTBUF:{
+			struct asrc_buffer buf;
+			struct dma_block *block;
+			unsigned long lock_flags;
+			if (copy_from_user
+			    (&buf, (void __user *)arg,
+			     sizeof(struct asrc_buffer))) {
+				err = -EFAULT;
+				break;
+			}
+
+			if (!wait_event_interruptible_timeout
+			    (params->output_wait_queue,
+			     params->output_counter != 0, 10 * HZ)) {
+				pr_info
+				    ("ASRC_DQ_OUTBUF timeout counter %x\n",
+				     params->output_counter);
+				err = -ETIME;
+				break;
+			} else if (signal_pending(current)) {
+				pr_info("ASRC_DQ_INBUF interrupt received\n");
+				err = -ERESTARTSYS;
+				break;
+			}
+			spin_lock_irqsave(&output_int_lock, lock_flags);
+			params->output_counter--;
+			block =
+			    list_entry(params->output_done_queue.next,
+				       struct dma_block, queue);
+			list_del(params->output_done_queue.next);
+			spin_unlock_irqrestore(&output_int_lock, lock_flags);
+			buf.index = block->index;
+			buf.length = block->length;
+			if (copy_to_user
+			    ((void __user *)arg, &buf,
+			     sizeof(struct asrc_buffer)))
+				err = -EFAULT;
+
+			break;
+		}
+	case ASRC_START_CONV:{
+			enum asrc_pair_index index;
+			struct dma_block *block;
+			mxc_dma_requestbuf_t dma_request;
+			if (copy_from_user
+			    (&index, (void __user *)arg,
+			     sizeof(enum asrc_pair_index))) {
+				err = -EFAULT;
+				break;
+			}
+
+			if (list_empty(&params->input_queue)) {
+				err = -EFAULT;
+				pr_info
+				    ("ASRC_START_CONV - no block available\n");
+				break;
+			}
+
+			block =
+			    list_entry(params->input_queue.next,
+				       struct dma_block, queue);
+
+			dma_request.num_of_bytes = block->length;
+			dma_request.src_addr = (dma_addr_t) block->dma_paddr;
+			dma_request.dst_addr =
+			    (ASRC_BASE_ADDR + ASRC_ASRDIA_REG + (index << 3));
+			mxc_dma_config(params->input_dma_channel,
+				       &dma_request, 1, MXC_DMA_MODE_WRITE);
+			block =
+			    list_entry(params->output_queue.next,
+				       struct dma_block, queue);
+			dma_request.num_of_bytes = block->length;
+			dma_request.src_addr =
+			    (ASRC_BASE_ADDR + ASRC_ASRDOA_REG + (index << 3));
+			dma_request.dst_addr = (dma_addr_t) block->dma_paddr;
+			mxc_dma_config(params->output_dma_channel,
+				       &dma_request, 1, MXC_DMA_MODE_READ);
+			params->asrc_active = 1;
+
+			mxc_dma_enable(params->input_dma_channel);
+			mxc_dma_enable(params->output_dma_channel);
+			asrc_start_conv(index);
+			break;
+		}
+	case ASRC_STOP_CONV:{
+			enum asrc_pair_index index;
+			if (copy_from_user
+			    (&index, (void __user *)arg,
+			     sizeof(enum asrc_pair_index))) {
+				err = -EFAULT;
+				break;
+			}
+
+			mxc_dma_disable(params->input_dma_channel);
+			mxc_dma_disable(params->output_dma_channel);
+			asrc_stop_conv(index);
+			params->asrc_active = 0;
+			break;
+		}
+	default:
+		break;
+	}
+
+	up(&params->busy_lock);
+	return err;
+}
+
+/*!
+ * asrc interface - open function
+ *
+ * @param inode        structure inode *
+ *
+ * @param file         structure file *
+ *
+ * @return  status    0 success, ENODEV invalid device instance,
+ *      ENOBUFS failed to allocate buffer, ERESTARTSYS interrupted by user
+ */
+static int mxc_asrc_open(struct inode *inode, struct file *file)
+{
+	int err = 0;
+	struct asrc_pair_params *pair_params;
+
+	if (signal_pending(current))
+		return -EINTR;
+
+	pair_params = kzalloc(sizeof(struct asrc_pair_params), GFP_KERNEL);
+	if (pair_params == NULL) {
+		pr_debug("Failed to allocate pair_params\n");
+		err = -ENOBUFS;
+	}
+
+	init_MUTEX(&pair_params->busy_lock);
+	file->private_data = pair_params;
+	return err;
+}
+
+/*!
+ * asrc interface - close function
+ *
+ * @param inode    struct inode *
+ * @param file        structure file *
+ *
+ * @return status     0 Success, EINTR busy lock error, ENOBUFS remap_page error
+ */
+static int mxc_asrc_close(struct inode *inode, struct file *file)
+{
+	struct asrc_pair_params *pair_params;
+
+	pair_params = file->private_data;
+	if (pair_params->asrc_active == 1) {
+		mxc_dma_disable(pair_params->input_dma_channel);
+		mxc_dma_disable(pair_params->output_dma_channel);
+		asrc_stop_conv(pair_params->index);
+		wake_up_interruptible(&pair_params->input_wait_queue);
+		wake_up_interruptible(&pair_params->output_wait_queue);
+	}
+	if (pair_params->pair_hold == 1) {
+		mxc_dma_free(pair_params->input_dma_channel);
+		mxc_dma_free(pair_params->output_dma_channel);
+		mxc_free_dma_buf(pair_params);
+		asrc_release_pair(pair_params->index);
+	}
+	kfree(pair_params);
+	file->private_data = NULL;
+	return 0;
+}
+
+/*!
+ * asrc interface - mmap function
+ *
+ * @param file        structure file *
+ *
+ * @param vma         structure vm_area_struct *
+ *
+ * @return status     0 Success, EINTR busy lock error, ENOBUFS remap_page error
+ */
+static int mxc_asrc_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long size;
+	int res = 0;
+	size = vma->vm_end - vma->vm_start;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	if (remap_pfn_range(vma, vma->vm_start,
+			    vma->vm_pgoff, size, vma->vm_page_prot))
+		return -ENOBUFS;
+
+	vma->vm_flags &= ~VM_IO;
+	return res;
+}
+
+static struct file_operations asrc_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = asrc_ioctl,
+	.mmap = mxc_asrc_mmap,
+	.open = mxc_asrc_open,
+	.release = mxc_asrc_close,
+};
+
+static int asrc_read_proc_attr(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	unsigned long reg;
+	int len = 0;
+
+	reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCNCR_REG);
+
+	len += sprintf(page, "ANCA: %d\n", (int)(reg & 0x7));
+	len += sprintf(page + len, "ANCB: %d\n", (int)((reg >> 3) & 0x7));
+	len += sprintf(page + len, "ANCC: %d\n", (int)((reg >> 6) & 0x7));
+
+	if (off > len)
+		return 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return min(count, len - (int)off);
+}
+
+static int asrc_write_proc_attr(struct file *file, const char *buffer,
+				unsigned long count, void *data)
+{
+	char buf[50];
+	unsigned long reg;
+	int na, nb, nc;
+	if (count > 48)
+		return -EINVAL;
+
+	if (copy_from_user(buf, buffer, count)) {
+		pr_debug("Attr proc write, Failed to copy buffer from user\n");
+		return -EFAULT;
+	}
+
+	reg = __raw_readl(asrc_vrt_base_addr + ASRC_ASRCNCR_REG);
+	sscanf(buf, "ANCA: %d\nANCB: %d\nANCC: %d", &na, &nb, &nc);
+	if ((na + nb + nc) != 5) {
+		pr_info("Wrong ASRCNR settings\n");
+		return -EFAULT;
+	}
+	reg = na | (nb << 3) | (nc << 6);
+
+	__raw_writel(reg, asrc_vrt_base_addr + ASRC_ASRCNCR_REG);
+
+	return count;
+}
+
+static void asrc_proc_create(void)
+{
+	struct proc_dir_entry *proc_attr;
+
+	proc_asrc = proc_mkdir(ASRC_PROC_PATH, NULL);
+	if (proc_asrc) {
+		proc_attr = create_proc_entry("ChSettings",
+					      S_IFREG | S_IRUGO |
+					      S_IWUSR, proc_asrc);
+		if (proc_attr) {
+			proc_attr->read_proc = asrc_read_proc_attr;
+			proc_attr->write_proc = asrc_write_proc_attr;
+			proc_attr->size = 48;
+			proc_attr->uid = proc_attr->gid = 0;
+			proc_attr->owner = THIS_MODULE;
+		} else {
+			pr_info("Failed to create proc attribute entry \n");
+		}
+	} else {
+		pr_info("ASRC: Failed to create proc entry %s\n",
+			ASRC_PROC_PATH);
+	}
+}
+
+/*!
+ * Entry point for the asrc device
+ *
+ * @param	pdev Pionter to the registered platform device
+ * @return  Error code indicating success or failure
+ */
+static int mxc_asrc_probe(struct platform_device *pdev)
+{
+	int err = 0;
+	struct resource *res;
+	struct class_device *temp_class;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENOENT;
+
+	g_asrc_data = kzalloc(sizeof(struct asrc_data), GFP_KERNEL);
+
+	if (g_asrc_data == NULL) {
+		pr_info("Failed to allocate g_asrc_data\n");
+		return -ENOMEM;
+	}
+
+	g_asrc_data->asrc_pair[0].chn_max = 2;
+	g_asrc_data->asrc_pair[1].chn_max = 2;
+	g_asrc_data->asrc_pair[2].chn_max = 6;
+
+	asrc_major = register_chrdev(asrc_major, "mxc_asrc", &asrc_fops);
+	if (asrc_major < 0) {
+		pr_info("Unable to register asrc device\n");
+		err = -EBUSY;
+		goto error;
+	}
+
+	asrc_class = class_create(THIS_MODULE, "mxc_asrc");
+	if (IS_ERR(asrc_class)) {
+		err = PTR_ERR(asrc_class);
+		goto err_out_chrdev;
+	}
+
+	temp_class = class_device_create(asrc_class, NULL,
+					 MKDEV(asrc_major, 0), NULL,
+					 "mxc_asrc");
+	if (IS_ERR(temp_class)) {
+		err = PTR_ERR(temp_class);
+		goto err_out_class;
+	}
+
+	asrc_vrt_base_addr =
+	    (unsigned long)ioremap(res->start, res->end - res->start + 1);
+
+	asrc_proc_create();
+	err = mxc_init_asrc();
+	if (err < 0)
+		goto err_out_class;
+
+	goto out;
+
+      err_out_class:
+	class_device_destroy(asrc_class, MKDEV(asrc_major, 0));
+	class_destroy(asrc_class);
+      err_out_chrdev:
+	unregister_chrdev(asrc_major, "mxc_asrc");
+      error:
+	kfree(g_asrc_data);
+      out:
+	pr_info("mxc_asrc registered\n");
+	return err;
+}
+
+/*!
+ * Exit asrc device
+ *
+ * @param	pdev Pionter to the registered platform device
+ * @return  Error code indicating success or failure
+ */
+static int mxc_asrc_remove(struct platform_device *pdev)
+{
+	free_irq(MXC_INT_ASRC, NULL);
+	kfree(g_asrc_data);
+	iounmap((unsigned long __iomem *)asrc_vrt_base_addr);
+	remove_proc_entry(proc_asrc->name, NULL);
+	class_device_destroy(asrc_class, MKDEV(asrc_major, 0));
+	class_destroy(asrc_class);
+	unregister_chrdev(asrc_major, "mxc_asrc");
+	return 0;
+}
+
+/*! mxc asrc driver definition
+ *
+ */
+static struct platform_driver mxc_asrc_driver = {
+	.driver = {
+		   .name = "mxc_asrc",
+		   },
+	.probe = mxc_asrc_probe,
+	.remove = mxc_asrc_remove,
+};
+
+/*!
+ * Register asrc driver
+ *
+ */
+static __init int asrc_init(void)
+{
+	int ret;
+	ret = platform_driver_register(&mxc_asrc_driver);
+	return ret;
+}
+
+/*!
+ * Exit and free the asrc data
+ *
+ */ static void __exit asrc_exit(void)
+{
+	platform_driver_unregister(&mxc_asrc_driver);
+	return;
+}
+
+module_init(asrc_init);
+module_exit(asrc_exit);
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Asynchronous Sample Rate Converter");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/asrc/mxc_asrc.h b/drivers/mxc/asrc/mxc_asrc.h
new file mode 100644
index 0000000..f20dd46
--- /dev/null
+++ b/drivers/mxc/asrc/mxc_asrc.h
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx35_asrc.h
+ *
+ * @brief MX35 Asynchronous Sample Rate Converter
+ *
+ * @ingroup ??
+ */
+
+#ifndef __MXC_ASRC_H__
+#define __MXC_ASRC_H__
+
+#include <asm/semaphore.h>
+
+#define ASRC_ASRCTR_REG 	0x00
+#define ASRC_ASRIER_REG 	0x04
+#define ASRC_ASRCNCR_REG 	0x0C
+#define ASRC_ASRCFG_REG 	0x10
+#define ASRC_ASRCSR_REG 	0x14
+#define ASRC_ASRCDR1_REG 	0x18
+#define ASRC_ASRCDR2_REG 	0x1C
+#define ASRC_ASRSTR_REG 	0x20
+#define ASRC_ASRRA_REG 		0x24
+#define ASRC_ASRRB_REG 		0x28
+#define ASRC_ASRRC_REG 		0x2C
+#define ASRC_ASRPM1_REG 	0x40
+#define ASRC_ASRPM2_REG 	0x44
+#define ASRC_ASRPM3_REG 	0x48
+#define ASRC_ASRPM4_REG 	0x4C
+#define ASRC_ASRPM5_REG 	0x50
+#define ASRC_ASRTFR1		0x54
+#define ASRC_ASRCCR_REG 	0x5C
+#define ASRC_ASRDIA_REG 	0x60
+#define ASRC_ASRDOA_REG 	0x64
+#define ASRC_ASRDIB_REG 	0x68
+#define ASRC_ASRDOB_REG 	0x6C
+#define ASRC_ASRDIC_REG 	0x70
+#define ASRC_ASRDOC_REG 	0x74
+#define ASRC_ASRIDRHA_REG 	0x80
+#define ASRC_ASRIDRLA_REG 	0x84
+#define ASRC_ASRIDRHB_REG 	0x88
+#define ASRC_ASRIDRLB_REG 	0x8C
+#define ASRC_ASRIDRHC_REG 	0x90
+#define ASRC_ASRIDRLC_REG 	0x94
+#define ASRC_ASR76K_REG 	0x98
+#define ASRC_ASR56K_REG 	0x9C
+
+#define ASRC_DMA_BUFFER_NUM 8
+
+/*ASRC driver enum and architecture */
+enum asrc_pair_index {
+	ASRC_PAIR_A,
+	ASRC_PAIR_B,
+	ASRC_PAIR_C
+};
+
+enum asrc_inclk {
+	INCLK_NONE = 0x03,
+	INCLK_ESAI_RX = 0x00,
+	INCLK_SSI1_RX = 0x01,
+	INCLK_SSI2_RX = 0x02,
+	INCLK_SPDIF_RX = 0x04,
+	INCLK_MLB_CLK = 0x05,
+	INCLK_ESAI_TX = 0x08,
+	INCLK_SSI1_TX = 0x09,
+	INCLK_SSI2_TX = 0x0a,
+	INCLK_SPDIF_TX = 0x0c,
+	INCLK_ASRCK1_CLK = 0x0f,
+};
+
+enum asrc_outclk {
+	OUTCLK_NONE = 0x03,
+	OUTCLK_ESAI_TX = 0x00,
+	OUTCLK_SSI1_TX = 0x01,
+	OUTCLK_SSI2_TX = 0x02,
+	OUTCLK_SPDIF_TX = 0x04,
+	OUTCLK_MLB_CLK = 0x05,
+	OUTCLK_ESAI_RX = 0x08,
+	OUTCLK_SSI1_RX = 0x09,
+	OUTCLK_SSI2_RX = 0x0a,
+	OUTCLK_SPDIF_RX = 0x0c,
+	OUTCLK_ASRCK1_CLK = 0x0f,
+};
+
+struct asrc_config {
+	enum asrc_pair_index pair;
+	unsigned int frame_bits;
+	unsigned int channel_num;
+	unsigned int buffer_num;
+	unsigned int dma_buffer_size;
+	unsigned int input_sample_rate;
+	unsigned int output_sample_rate;
+	enum asrc_inclk inclk;
+	enum asrc_outclk outclk;
+};
+
+struct asrc_pair {
+	unsigned int start_channel;
+	unsigned int chn_num;
+	unsigned int chn_max;
+	unsigned int active;
+};
+
+struct asrc_data {
+	struct asrc_pair asrc_pair[3];
+};
+
+/*Stream interface structure */
+struct asrc_req {
+	unsigned int chn_num;
+	enum asrc_pair_index index;
+};
+
+struct asrc_querybuf {
+	unsigned int buffer_index;
+	unsigned int input_length;
+	unsigned int output_length;
+	unsigned long input_offset;
+	unsigned long output_offset;
+};
+
+struct asrc_buffer {
+	unsigned int index;
+	unsigned int length;
+};
+
+struct dma_block {
+	unsigned int index;
+	unsigned int length;
+	unsigned char *dma_vaddr;
+	dma_addr_t dma_paddr;
+	struct list_head queue;
+};
+
+struct asrc_pair_params {
+	enum asrc_pair_index index;
+	struct list_head input_queue;
+	struct list_head input_done_queue;
+	struct list_head output_queue;
+	struct list_head output_done_queue;
+	wait_queue_head_t input_wait_queue;
+	wait_queue_head_t output_wait_queue;
+	unsigned int input_counter;
+	unsigned int output_counter;
+	unsigned int input_queue_empty;
+	unsigned int output_queue_empty;
+	unsigned int input_dma_channel;
+	unsigned int output_dma_channel;
+	unsigned int input_buffer_size;
+	unsigned int output_buffer_size;
+	unsigned int buffer_num;
+	unsigned int pair_hold;
+	unsigned int asrc_active;
+	struct dma_block input_dma[ASRC_DMA_BUFFER_NUM];
+	struct dma_block output_dma[ASRC_DMA_BUFFER_NUM];
+	struct semaphore busy_lock;
+};
+
+char *asrc_pair_id[] = {
+	[0] = "ASRC RX PAIR A",
+	[1] = "ASRC TX PAIR A",
+	[2] = "ASRC RX PAIR B",
+	[3] = "ASRC TX PAIR B",
+	[4] = "ASRC RX PAIR C",
+	[5] = "ASRC TX PAIR C",
+};
+
+#define ASRC_IOC_MAGIC	'C'
+
+#define ASRC_REQ_PAIR	_IOWR(ASRC_IOC_MAGIC, 0, struct asrc_req)
+#define ASRC_CONIFG_PAIR	_IOWR(ASRC_IOC_MAGIC, 1, struct asrc_config)
+#define ASRC_RELEASE_PAIR	_IOW(ASRC_IOC_MAGIC, 2, enum asrc_pair_index)
+#define ASRC_QUERYBUF	_IOWR(ASRC_IOC_MAGIC, 3, struct asrc_buffer)
+#define ASRC_Q_INBUF	_IOW(ASRC_IOC_MAGIC, 4, struct asrc_buffer)
+#define ASRC_DQ_INBUF	_IOW(ASRC_IOC_MAGIC, 5, struct asrc_buffer)
+#define ASRC_Q_OUTBUF	_IOW(ASRC_IOC_MAGIC, 6, struct asrc_buffer)
+#define ASRC_DQ_OUTBUF	_IOW(ASRC_IOC_MAGIC, 7, struct asrc_buffer)
+#define ASRC_START_CONV	_IOW(ASRC_IOC_MAGIC, 8, enum asrc_pair_index)
+#define ASRC_STOP_CONV	_IOW(ASRC_IOC_MAGIC, 9, enum asrc_pair_index)
+
+extern int asrc_req_pair(int chn_num, enum asrc_pair_index *index);
+extern void asrc_release_pair(enum asrc_pair_index index);
+extern int asrc_config_pair(struct asrc_config *config);
+extern void asrc_start_conv(enum asrc_pair_index index);
+extern void asrc_stop_conv(enum asrc_pair_index index);
+
+#endif				/* __MXC_ASRC_H__ */
diff --git a/include/asm-arm/arch-mxc/dma.h b/include/asm-arm/arch-mxc/dma.h
index 2e886e7..212ffcd 100644
--- a/include/asm-arm/arch-mxc/dma.h
+++ b/include/asm-arm/arch-mxc/dma.h
@@ -91,6 +91,18 @@ typedef enum mxc_dma_device {
 	MXC_DMA_SPDIF_16BIT_RX,
 	MXC_DMA_SPDIF_32BIT_TX,
 	MXC_DMA_SPDIF_32BIT_RX,
+	MXC_DMA_ASRC_16BIT_A_RX,
+	MXC_DMA_ASRC_16BIT_A_TX,
+	MXC_DMA_ASRC_16BIT_B_RX,
+	MXC_DMA_ASRC_16BIT_B_TX,
+	MXC_DMA_ASRC_16BIT_C_RX,
+	MXC_DMA_ASRC_16BIT_C_TX,
+	MXC_DMA_ASRC_32BIT_A_RX,
+	MXC_DMA_ASRC_32BIT_A_TX,
+	MXC_DMA_ASRC_32BIT_B_RX,
+	MXC_DMA_ASRC_32BIT_B_TX,
+	MXC_DMA_ASRC_32BIT_C_RX,
+	MXC_DMA_ASRC_32BIT_C_TX,
 	MXC_DMA_TEST_RAM2D2RAM,
 	MXC_DMA_TEST_RAM2RAM2D,
 	MXC_DMA_TEST_RAM2D2RAM2D,
diff --git a/include/asm-arm/arch-mxc/mx35.h b/include/asm-arm/arch-mxc/mx35.h
index 6ee1e02..4c0b648 100644
--- a/include/asm-arm/arch-mxc/mx35.h
+++ b/include/asm-arm/arch-mxc/mx35.h
@@ -169,6 +169,12 @@
 #define MXC_DMA_CHANNEL_MEMORY  MXC_DMA_DYNAMIC_CHANNEL
 #define MXC_DMA_CHANNEL_SPDIF_TX        MXC_DMA_DYNAMIC_CHANNEL
 #define MXC_DMA_CHANNEL_SPDIF_RX        MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCC_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCC_TX  MXC_DMA_DYNAMIC_CHANNEL
 
 /*
  * AIPS 2
@@ -239,7 +245,7 @@
 #define CSD0_BASE_ADDR          0x80000000
 #define CSD1_BASE_ADDR          0x90000000
 
-#define SDRAM_BASE_ADDR         CSD1_BASE_ADDR
+#define SDRAM_BASE_ADDR         CSD0_BASE_ADDR
 
 #define CS0_BASE_ADDR           0xA0000000
 #define CS1_BASE_ADDR           0xA8000000
-- 
1.5.4.4

