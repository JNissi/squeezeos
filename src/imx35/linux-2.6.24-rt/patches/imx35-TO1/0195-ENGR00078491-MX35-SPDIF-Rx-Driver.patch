From 4dc507085d23ff6631cab3de52d580cd666ba77a Mon Sep 17 00:00:00 2001
From: Xinyu Chen <xinyu.chen@freescale.com>
Date: Fri, 30 May 2008 17:55:40 +0800
Subject: [PATCH] ENGR00078491 MX35 SPDIF Rx Driver

Add support for SPDIF Rx to MX35

Signed-off-by: Xinyu Chen <b03824@freescale.com>
---
 arch/arm/mach-mx35/devices.c          |    4 +-
 arch/arm/mach-mx35/mx35_3stack_gpio.c |    1 -
 sound/arm/mxc-alsa-spdif.c            |  383 +++++++++++++++++---------------
 3 files changed, 205 insertions(+), 183 deletions(-)

diff --git a/arch/arm/mach-mx35/devices.c b/arch/arm/mach-mx35/devices.c
index ca95815..75de6ce 100644
--- a/arch/arm/mach-mx35/devices.c
+++ b/arch/arm/mach-mx35/devices.c
@@ -471,7 +471,7 @@ static struct mxc_spdif_platform_data mxc_spdif_data = {
 	.spdif_clk_44100 = 3,	/* spdif_ext_clk source for 44.1KHz */
 	.spdif_clk_48000 = 0,	/* audio osc source */
 	.spdif_clkid = 0,
-	.spdif_clk = NULL,
+	.spdif_clk = NULL,	/* spdif bus clk */
 };
 
 static struct platform_device mxc_alsa_spdif_device = {
@@ -487,7 +487,7 @@ static struct platform_device mxc_alsa_spdif_device = {
 
 static inline void mxc_init_spdif(void)
 {
-	mxc_spdif_data.spdif_clk = clk_get(NULL, "spdif_audio_clk");
+	mxc_spdif_data.spdif_clk = clk_get(NULL, "spdif_ipg_clk");
 	clk_put(mxc_spdif_data.spdif_clk);
 	mxc_spdif_data.spdif_core_clk = clk_get(NULL, "spdif_clk");
 	clk_put(mxc_spdif_data.spdif_core_clk);
diff --git a/arch/arm/mach-mx35/mx35_3stack_gpio.c b/arch/arm/mach-mx35/mx35_3stack_gpio.c
index acccfa3..be9197d 100644
--- a/arch/arm/mach-mx35/mx35_3stack_gpio.c
+++ b/arch/arm/mach-mx35/mx35_3stack_gpio.c
@@ -712,7 +712,6 @@ void gpio_spdif_active(void)
 	mxc_request_iomux(MX35_PIN_SRXD5, MUX_CONFIG_ALT1);
 	mxc_iomux_set_pad(MX35_PIN_SRXD5, PAD_CTL_PKE_ENABLE
 			  | PAD_CTL_100K_PU | PAD_CTL_HYS_SCHMITZ);
-	mxc_iomux_set_input(MUX_IN_SPDIF_SPDIF_IN1, INPUT_CTL_PATH1);
 	/* SPDIF ext clock */
 	mxc_request_iomux(MX35_PIN_SCK5, MUX_CONFIG_ALT1);
 }
diff --git a/sound/arm/mxc-alsa-spdif.c b/sound/arm/mxc-alsa-spdif.c
index 4ac69f8..740bd2b 100644
--- a/sound/arm/mxc-alsa-spdif.c
+++ b/sound/arm/mxc-alsa-spdif.c
@@ -224,6 +224,93 @@ struct spdif_mixer_control {
 	unsigned int ready_buf;
 };
 
+/*!
+ * This structure represents an audio stream in term of
+ * channel DMA, HW configuration on spdif controller.
+ */
+struct mxc_spdif_stream {
+
+	/*!
+	 * identification string
+	 */
+	char *id;
+	/*!
+	 * device identifier for DMA
+	 */
+	int dma_wchannel;
+	/*!
+	 * we are using this stream for transfer now
+	 */
+	int active:1;
+	/*!
+	 * current transfer period
+	 */
+	int period;
+	/*!
+	 * current count of transfered periods
+	 */
+	int periods;
+	/*!
+	 * are we recording - flag used to do DMA trans. for sync
+	 */
+	int tx_spin;
+	/*!
+	 * for locking in DMA operations
+	 */
+	spinlock_t dma_lock;
+	/*!
+	 * Alsa substream pointer
+	 */
+	struct snd_pcm_substream *stream;
+};
+
+struct mxc_spdif_device {
+	/*!
+	 * SPDIF module register base address
+	 */
+	unsigned long __iomem *reg_base;
+
+	/*!
+	 * spdif tx available or not
+	 */
+	int mxc_spdif_tx;
+
+	/*!
+	 * spdif rx available or not
+	 */
+	int mxc_spdif_rx;
+
+	/*!
+	 * spdif 44100 clock src
+	 */
+	int spdif_txclk_44100;
+
+	/*!
+	 * spdif 48000 clock src
+	 */
+	int spdif_txclk_48000;
+
+	/*!
+	 * ALSA SPDIF sound card handle
+	 */
+	struct snd_card *card;
+
+	/*!
+	 * ALSA spdif driver type handle
+	 */
+	struct snd_pcm *pcm;
+
+	/*!
+	 * DPLL locked status
+	 */
+	atomic_t dpll_locked;
+
+	/*!
+	 * Playback/Capture substream
+	 */
+	struct mxc_spdif_stream s[2];
+};
+
 static struct spdif_mixer_control mxc_spdif_control;
 
 static unsigned long spdif_base_addr;
@@ -338,28 +425,26 @@ static int spdif_set_rx_clksrc(enum spdif_clk_src clksrc,
  * Get RX data clock rate
  * given the SPDIF bus_clk
  */
-static int spdif_get_rxclk_rate(struct clk *bus_clk)
+static int spdif_get_rxclk_rate(struct clk *bus_clk, enum spdif_gainsel gainsel)
 {
-	unsigned long freqmeas, phaseconf, busclk_freq = 0, gainsel;
+	unsigned long freqmeas, phaseconf, busclk_freq = 0;
+	u64 tmpval64;
 	enum spdif_clk_src clksrc;
 
 	freqmeas = __raw_readl(spdif_base_addr + SPDIF_REG_SRFM);
 	phaseconf = __raw_readl(spdif_base_addr + SPDIF_REG_SRPC);
 
 	clksrc = (phaseconf >> SRPC_CLKSRC_SEL_OFFSET) & 0x0F;
-	if (clksrc > 4 || !(phaseconf & SRPC_DPLL_LOCKED)) {
+	if (clksrc < 5 && (phaseconf & SRPC_DPLL_LOCKED)) {
 		/* get bus clock from system */
 		busclk_freq = clk_get_rate(bus_clk);
 	}
 
-	gainsel = (phaseconf >> SRPC_GAINSEL_OFFSET) & 0x7;
-	if (busclk_freq == 0) {
-		/* the spdif is configured bus clock as rx clock */
-		return gainsel_multi[gainsel];
-	}
-
-	/* FreqMeas_CLK = (BUS_CLK*FreqMeas[23:0])/2^10*GAINSEL */
-	return (busclk_freq * freqmeas) / gainsel_multi[gainsel];
+	/* FreqMeas_CLK = (BUS_CLK*FreqMeas[23:0])/2^10/GAINSEL/128 */
+	tmpval64 = (u64) busclk_freq * freqmeas;
+	do_div(tmpval64, gainsel_multi[gainsel]);
+	do_div(tmpval64, 128 * 1024);
+	return (int)tmpval64;
 }
 
 /*!
@@ -422,7 +507,8 @@ static int spdif_intr_status(void)
 	unsigned long value;
 
 	value = __raw_readl(SPDIF_REG_SIS + spdif_base_addr) & 0xffffff;
-	__raw_writel(0, SPDIF_REG_SIC + spdif_base_addr);
+	value &= __raw_readl(spdif_base_addr + SPDIF_REG_SIE);
+	__raw_writel(value, SPDIF_REG_SIC + spdif_base_addr);
 
 	return value;
 }
@@ -436,11 +522,9 @@ static irqreturn_t spdif_isr(int irq, void *dev_id)
 	int line;
 
 	int_stat = spdif_intr_status();
-	int_stat &= __raw_readl(spdif_base_addr + SPDIF_REG_SIE);
 
 	while ((line = ffs(int_stat)) != 0) {
 		int_stat &= ~(1UL << (line - 1));
-		pr_info("SPDIF interrupt trigger:%d\n", line - 1);
 		if (spdif_irq_handlers[line - 1] != NULL)
 			spdif_irq_handlers[line - 1] (line - 1, dev_id);
 	}
@@ -470,11 +554,16 @@ static void spdif_irq_fifo(unsigned int bit, void *devid)
  */
 static void spdif_irq_dpll_lock(unsigned int bit, void *devid)
 {
-	if (bit == INT_DPLL_LOCKED) {
+	struct mxc_spdif_device *chip = (struct mxc_spdif_device *)devid;
+	unsigned int locked = __raw_readl(spdif_base_addr + SPDIF_REG_SRPC);
+
+	if (locked & SRPC_DPLL_LOCKED) {
 		pr_debug("SPDIF Rx dpll locked\n");
+		atomic_set(&chip->dpll_locked, 1);
 	} else {
 		/* INT_LOSS_LOCK */
 		pr_debug("SPDIF Rx dpll loss lock\n");
+		atomic_set(&chip->dpll_locked, 0);
 	}
 }
 
@@ -486,43 +575,50 @@ static void spdif_irq_dpll_lock(unsigned int bit, void *devid)
  */
 static void spdif_irq_uq(unsigned int bit, void *devid)
 {
-	unsigned long val, flags;
+	unsigned long val;
 	int index;
 	struct spdif_mixer_control *ctrl = &mxc_spdif_control;
 
-	spin_lock_irqsave(ctrl->ctl_lock, flags);
-
+	bit = 1 << bit;
 	/* get U/Q channel datas */
 	switch (bit) {
 
 	case INT_URX_OV:	/* read U data */
 		pr_debug("User bit receive overrun\n");
 	case INT_URX_FUL:
-		if (unlikely((ctrl->upos % SPDIF_UBITS_SIZE) + 3
-			     > SPDIF_UBITS_SIZE)) {
-			dev_err((struct device *)devid,
-				"User bit receivce buffer overflow\n");
+		pr_debug("U bit receive full\n");
+
+		if (ctrl->upos >= SPDIF_UBITS_SIZE * 2) {
+			ctrl->upos = 0;
+		} else if (unlikely((ctrl->upos % SPDIF_UBITS_SIZE) + 3
+				    > SPDIF_UBITS_SIZE)) {
+			pr_err("User bit receivce buffer overflow\n");
 			break;
 		}
 		val = __raw_readl(spdif_base_addr + SPDIF_REG_SQU);
 		ctrl->subcode[ctrl->upos++] = val >> 16;
 		ctrl->subcode[ctrl->upos++] = val >> 8;
 		ctrl->subcode[ctrl->upos++] = val;
+
 		break;
 
 	case INT_QRX_OV:	/* read Q data */
 		pr_debug("Q bit receive overrun\n");
 	case INT_QRX_FUL:
-		if (unlikely((ctrl->qpos % SPDIF_QSUB_SIZE) + 3
-			     > SPDIF_QSUB_SIZE)) {
-			dev_err((struct device *)devid,
-				"Q bit receivce buffer overflow\n");
+		pr_debug("Q bit receive full\n");
+
+		if (ctrl->qpos >= SPDIF_QSUB_SIZE * 2) {
+			ctrl->qpos = 0;
+		} else if (unlikely((ctrl->qpos % SPDIF_QSUB_SIZE) + 3
+				    > SPDIF_QSUB_SIZE)) {
+			pr_err("Q bit receivce buffer overflow\n");
 			break;
 		}
 		val = __raw_readl(spdif_base_addr + SPDIF_REG_SRQ);
 		ctrl->qsub[ctrl->qpos++] = val >> 16;
 		ctrl->qsub[ctrl->qpos++] = val >> 8;
 		ctrl->qsub[ctrl->qpos++] = val;
+
 		break;
 
 	case INT_UQ_ERR:	/* read U/Q data and do buffer reset */
@@ -530,24 +626,19 @@ static void spdif_irq_uq(unsigned int bit, void *devid)
 		val = __raw_readl(spdif_base_addr + SPDIF_REG_SQU);
 		val = __raw_readl(spdif_base_addr + SPDIF_REG_SRQ);
 		/* drop this U/Q buffer */
-		index = ctrl->qpos / SPDIF_QSUB_SIZE;
-		ctrl->ready_buf &= ~(1 << index);
-		ctrl->upos = index * SPDIF_UBITS_SIZE;
-		ctrl->qpos = index * SPDIF_QSUB_SIZE;
+		ctrl->ready_buf = ctrl->upos = ctrl->qpos = 0;
 		break;
 
 	case INT_UQ_SYNC:	/* U/Q buffer reset */
-		index = ctrl->qpos / SPDIF_QSUB_SIZE;
+		pr_debug("U/Q sync receive\n");
+
+		if (ctrl->qpos == 0)
+			break;
+		index = (ctrl->qpos - 1) / SPDIF_QSUB_SIZE;
 		/* set ready to this buffer */
-		ctrl->ready_buf &= ~(1 << index);
-		index = index ? 0 : 1;
-		ctrl->ready_buf |= 1 << index;
-		ctrl->upos = index * SPDIF_UBITS_SIZE;
-		ctrl->qpos = index * SPDIF_QSUB_SIZE;
+		ctrl->ready_buf = index + 1;
 		break;
 	}
-
-	spin_unlock_irqrestore(&ctrl->ctl_lock, flags);
 }
 
 /*!
@@ -579,8 +670,7 @@ static void spdif_irq_valnogood(unsigned int bit, void *devid)
  */
 static void spdif_irq_cnew(unsigned int bit, void *devid)
 {
-	/* get channel status */
-	/* FIXME: no need to fetch in ISR, user can define */
+	pr_debug("SPDIF interrupt cstatus new\n");
 }
 
 /*!
@@ -666,94 +756,10 @@ static void spdif_tx_uninit(void)
 
 }
 
-/*!
- * This structure represents an audio stream in term of
- * channel DMA, HW configuration on spdif controller.
- */
-struct mxc_spdif_stream {
-
-	/*!
-	 * identification string
-	 */
-	char *id;
-	/*!
-	 * device identifier for DMA
-	 */
-	int dma_wchannel;
-	/*!
-	 * we are using this stream for transfer now
-	 */
-	int active:1;
-	/*!
-	 * current transfer period
-	 */
-	int period;
-	/*!
-	 * current count of transfered periods
-	 */
-	int periods;
-	/*!
-	 * are we recording - flag used to do DMA trans. for sync
-	 */
-	int tx_spin;
-	/*!
-	 * for locking in DMA operations
-	 */
-	spinlock_t dma_lock;
-	/*!
-	 * Alsa substream pointer
-	 */
-	struct snd_pcm_substream *stream;
-};
-
-struct mxc_spdif_device {
-	/*!
-	 * SPDIF module register base address
-	 */
-	unsigned long __iomem *reg_base;
-
-	/*!
-	 * spdif tx available or not
-	 */
-	int mxc_spdif_tx;
-
-	/*!
-	 * spdif rx available or not
-	 */
-	int mxc_spdif_rx;
-
-	/*!
-	 * spdif 44100 clock src
-	 */
-	int spdif_txclk_44100;
-
-	/*!
-	 * spdif 48000 clock src
-	 */
-	int spdif_txclk_48000;
-
-	/*!
-	 * ALSA SPDIF sound card handle
-	 */
-	struct snd_card *card;
-
-	/*!
-	 * ALSA spdif driver type handle
-	 */
-	struct snd_pcm *pcm;
-
-	/*!
-	 * DPLL locked status
-	 */
-	atomic_t dpll_locked;
-
-	/*!
-	 * Playback/Capture substream
-	 */
-	struct mxc_spdif_stream s[2];
-};
-
 static unsigned int spdif_playback_rates[] = { 32000, 44100, 48000 };
+static unsigned int spdif_capture_rates[] = {
+	16000, 32000, 44100, 48000, 64000, 96000
+};
 
 /*!
   * this structure represents the sample rates supported
@@ -766,8 +772,8 @@ static struct snd_pcm_hw_constraint_list hw_playback_rates_stereo = {
 };
 
 static struct snd_pcm_hw_constraint_list hw_capture_rates_stereo = {
-	.count = ARRAY_SIZE(spdif_playback_rates),
-	.list = spdif_playback_rates,
+	.count = ARRAY_SIZE(spdif_capture_rates),
+	.list = spdif_capture_rates,
 	.mask = 0,
 };
 
@@ -808,10 +814,12 @@ static struct snd_pcm_hardware snd_spdif_capture_hw = {
 		 SNDRV_PCM_INFO_MMAP_VALID |
 		 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
 	.formats = SNDRV_PCM_FMTBIT_S24_LE,
-	.rates = (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
-		  SNDRV_PCM_RATE_48000),
-	.rate_min = 32000,
-	.rate_max = 48000,
+	.rates =
+	    (SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100
+	     | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_64000 |
+	     SNDRV_PCM_RATE_96000),
+	.rate_min = 16000,
+	.rate_max = 96000,
 	.channels_min = 2,
 	.channels_max = 2,
 	.buffer_bytes_max = SPDIF_MAX_BUF_SIZE,
@@ -855,15 +863,15 @@ spdif_configure_dma_channel(struct mxc_spdif_stream *s,
 					    "SPDIF TX DMA");
 		}
 
-		pr_debug("spdif_configure_dma_channel: %d\n", channel);
 	} else if (s->stream->stream == SNDRV_PCM_STREAM_CAPTURE) {
 
 		channel = mxc_dma_request(MXC_DMA_SPDIF_32BIT_RX,
 					  "SPDIF RX DMA");
 
-		pr_debug("spdif_configure_dma_channel: %d\n", channel);
-
 	}
+
+	pr_debug("spdif_configure_dma_channel: %d\n", channel);
+
 	ret = mxc_dma_callback_set(channel,
 				   (mxc_dma_callback_t) callback, (void *)s);
 	if (ret != 0) {
@@ -921,16 +929,16 @@ static u_int spdif_get_dma_pos(struct mxc_spdif_stream *s)
   */
 static void spdif_stop_tx(struct mxc_spdif_stream *s)
 {
-	unsigned long flags;
 	struct snd_pcm_substream *substream;
 	struct snd_pcm_runtime *runtime;
 	unsigned int dma_size;
 	unsigned int offset;
+
 	substream = s->stream;
 	runtime = substream->runtime;
 	dma_size = frames_to_bytes(runtime, runtime->period_size);
 	offset = dma_size * s->periods;
-	spin_lock_irqsave(&s->dma_lock, flags);
+
 	s->active = 0;
 	s->period = 0;
 	s->periods = 0;
@@ -940,7 +948,6 @@ static void spdif_stop_tx(struct mxc_spdif_stream *s)
 	spdif_dma_enable(SCR_DMA_TX_EN, 0);
 	dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
 			 DMA_TO_DEVICE);
-	spin_unlock_irqrestore(&s->dma_lock, flags);
 }
 
 /*!
@@ -1056,13 +1063,18 @@ static void spdif_tx_callback(void *data, int error, unsigned int count)
 	previous_period = s->periods;
 	dma_size = frames_to_bytes(runtime, runtime->period_size);
 	offset = dma_size * previous_period;
+
+	spin_lock(&s->dma_lock);
 	s->tx_spin = 0;
 	s->periods++;
 	s->periods %= runtime->periods;
 	dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
 			 DMA_TO_DEVICE);
+	spin_unlock(&s->dma_lock);
+
 	if (s->active)
 		snd_pcm_period_elapsed(s->stream);
+
 	spin_lock(&s->dma_lock);
 	spdif_start_tx(s);
 	spin_unlock(&s->dma_lock);
@@ -1083,9 +1095,11 @@ snd_mxc_spdif_playback_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct mxc_spdif_device *chip;
 	struct mxc_spdif_stream *s;
 	int err = 0;
+	unsigned long flags;
 	chip = snd_pcm_substream_chip(substream);
 	s = &chip->s[SNDRV_PCM_STREAM_PLAYBACK];
-	spin_lock(&s->dma_lock);
+
+	spin_lock_irqsave(&s->dma_lock, flags);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 		s->tx_spin = 0;
@@ -1116,7 +1130,7 @@ snd_mxc_spdif_playback_trigger(struct snd_pcm_substream *substream, int cmd)
 		err = -EINVAL;
 		break;
 	}
-	spin_unlock(&s->dma_lock);
+	spin_unlock_irqrestore(&s->dma_lock, flags);
 	return err;
 }
 
@@ -1194,8 +1208,6 @@ static int snd_card_mxc_spdif_playback_open(struct snd_pcm_substream *substream)
 	chip = snd_pcm_substream_chip(substream);
 
 	spdif_data = chip->card->dev->platform_data;
-	/* enable core clock */
-	clk_enable(spdif_data->spdif_core_clk);
 	/* enable tx clock */
 	clk_enable(spdif_data->spdif_clk);
 
@@ -1215,7 +1227,6 @@ static int snd_card_mxc_spdif_playback_open(struct snd_pcm_substream *substream)
 	return 0;
       failed:
 	clk_disable(spdif_data->spdif_clk);
-	clk_disable(spdif_data->spdif_core_clk);
 	return err;
 }
 
@@ -1242,7 +1253,6 @@ static int snd_card_mxc_spdif_playback_close(struct snd_pcm_substream
 	spdif_intr_enable(INT_TXFIFO_RESYNC, 0);
 	spdif_tx_uninit();
 	clk_disable(spdif_data->spdif_clk);
-	clk_disable(spdif_data->spdif_core_clk);
 	mxc_dma_free(chip->s[SNDRV_PCM_STREAM_PLAYBACK].dma_wchannel);
 	chip->s[SNDRV_PCM_STREAM_PLAYBACK].dma_wchannel = 0;
 
@@ -1258,7 +1268,6 @@ static int snd_card_mxc_spdif_playback_close(struct snd_pcm_substream
   */
 static void spdif_stop_rx(struct mxc_spdif_stream *s)
 {
-	unsigned long flags;
 	struct snd_pcm_substream *substream;
 	struct snd_pcm_runtime *runtime;
 	unsigned int dma_size;
@@ -1269,8 +1278,6 @@ static void spdif_stop_rx(struct mxc_spdif_stream *s)
 	dma_size = frames_to_bytes(runtime, runtime->period_size);
 	offset = dma_size * s->periods;
 
-	spin_lock_irqsave(&s->dma_lock, flags);
-
 	s->active = 0;
 	s->period = 0;
 	s->periods = 0;
@@ -1280,7 +1287,6 @@ static void spdif_stop_rx(struct mxc_spdif_stream *s)
 	spdif_dma_enable(SCR_DMA_RX_EN, 0);
 	dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
 			 DMA_FROM_DEVICE);
-	spin_unlock_irqrestore(&s->dma_lock, flags);
 }
 
 /*!
@@ -1346,7 +1352,7 @@ static void spdif_start_rx(struct mxc_spdif_stream *s)
 
 		if ((s->period < s->periods)
 		    && ((s->period + runtime->periods - s->periods) > 1)) {
-			pr_debug("audio playback chain dma: already double  \
+			pr_debug("audio capture chain dma: already double  \
 				buffered\n");
 			return;
 		}
@@ -1407,12 +1413,15 @@ static void spdif_rx_callback(void *data, int error, unsigned int count)
 	dma_size = frames_to_bytes(runtime, runtime->period_size);
 	offset = dma_size * previous_period;
 
+	spin_lock(&s->dma_lock);
 	s->tx_spin = 0;
 	s->periods++;
 	s->periods %= runtime->periods;
 
 	dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
 			 DMA_FROM_DEVICE);
+	spin_unlock(&s->dma_lock);
+
 	if (s->active)
 		snd_pcm_period_elapsed(s->stream);
 	spin_lock(&s->dma_lock);
@@ -1435,9 +1444,11 @@ snd_mxc_spdif_capture_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct mxc_spdif_device *chip;
 	struct mxc_spdif_stream *s;
 	int err = 0;
+	unsigned long flags;
 	chip = snd_pcm_substream_chip(substream);
 	s = &chip->s[SNDRV_PCM_STREAM_CAPTURE];
-	spin_lock(&s->dma_lock);
+
+	spin_lock_irqsave(&s->dma_lock, flags);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 		s->tx_spin = 0;
@@ -1468,7 +1479,7 @@ snd_mxc_spdif_capture_trigger(struct snd_pcm_substream *substream, int cmd)
 		err = -EINVAL;
 		break;
 	}
-	spin_unlock(&s->dma_lock);
+	spin_unlock_irqrestore(&s->dma_lock, flags);
 	return err;
 }
 
@@ -1499,7 +1510,7 @@ static int snd_mxc_spdif_capture_prepare(struct snd_pcm_substream *substream)
 			  INT_LOSS_LOCK, 1);
 
 	/* setup rx clock source */
-	spdif_set_rx_clksrc(spdif_data->spdif_clkid, SPDIF_DEFAULT_GAINSEL, 0);
+	spdif_set_rx_clksrc(spdif_data->spdif_clkid, SPDIF_DEFAULT_GAINSEL, 1);
 
 	/* setup DMA controller for spdif rx */
 	err = spdif_configure_dma_channel(&chip->
@@ -1509,13 +1520,14 @@ static int snd_mxc_spdif_capture_prepare(struct snd_pcm_substream *substream)
 		pr_info("snd_mxc_spdif_playback_prepare - err < 0\n");
 		return err;
 	}
-	/**
-	 * FIXME: dump registers
-	 */
+
+	/* Debug: dump registers */
 	pr_debug("SCR: 0x%08x\n", __raw_readl(spdif_base_addr + SPDIF_REG_SCR));
 	pr_debug("SIE: 0x%08x\n", __raw_readl(spdif_base_addr + SPDIF_REG_SIE));
 	pr_debug("SRPC: 0x%08x\n",
 		 __raw_readl(spdif_base_addr + SPDIF_REG_SRPC));
+	pr_debug("FreqMeas: 0x%08x\n",
+		 __raw_readl(spdif_base_addr + SPDIF_REG_SRFM));
 
 	return 0;
 }
@@ -1553,8 +1565,6 @@ static int snd_card_mxc_spdif_capture_open(struct snd_pcm_substream *substream)
 	chip = snd_pcm_substream_chip(substream);
 
 	spdif_data = chip->card->dev->platform_data;
-	/* enable core clock */
-	clk_enable(spdif_data->spdif_core_clk);
 	/* enable rx bus clock */
 	clk_enable(spdif_data->spdif_clk);
 
@@ -1580,7 +1590,6 @@ static int snd_card_mxc_spdif_capture_open(struct snd_pcm_substream *substream)
 
       failed:
 	clk_disable(spdif_data->spdif_clk);
-	clk_disable(spdif_data->spdif_core_clk);
 	return err;
 }
 
@@ -1602,6 +1611,10 @@ static int snd_card_mxc_spdif_capture_close(struct snd_pcm_substream
 	spdif_data = chip->card->dev->platform_data;
 
 	pr_debug("SIS: 0x%08x\n", __raw_readl(spdif_base_addr + SPDIF_REG_SIS));
+	pr_debug("SRPC: 0x%08x\n",
+		 __raw_readl(spdif_base_addr + SPDIF_REG_SRPC));
+	pr_debug("FreqMeas: 0x%08x\n",
+		 __raw_readl(spdif_base_addr + SPDIF_REG_SRFM));
 
 	spdif_intr_enable(INT_DPLL_LOCKED | INT_SYM_ERR | INT_BIT_ERR |
 			  INT_URX_FUL | INT_URX_OV | INT_QRX_FUL | INT_QRX_OV |
@@ -1609,7 +1622,6 @@ static int snd_card_mxc_spdif_capture_close(struct snd_pcm_substream
 			  INT_LOSS_LOCK, 0);
 	spdif_rx_uninit();
 	clk_disable(spdif_data->spdif_clk);
-	clk_disable(spdif_data->spdif_core_clk);
 	mxc_dma_free(chip->s[SNDRV_PCM_STREAM_CAPTURE].dma_wchannel);
 	chip->s[SNDRV_PCM_STREAM_CAPTURE].dma_wchannel = 0;
 	return 0;
@@ -1774,6 +1786,9 @@ static int snd_mxc_spdif_capture_get(struct snd_kcontrol *kcontrol,
 {
 	unsigned int cstatus;
 
+	if (!(__raw_readl(spdif_base_addr + SPDIF_REG_SIS) & INT_CNEW))
+		return -EAGAIN;
+
 	cstatus = __raw_readl(spdif_base_addr + SPDIF_REG_SRCSLH);
 	ucontrol->value.iec958.status[0] = (cstatus >> 16) & 0xFF;
 	ucontrol->value.iec958.status[1] = (cstatus >> 8) & 0xFF;
@@ -1783,6 +1798,9 @@ static int snd_mxc_spdif_capture_get(struct snd_kcontrol *kcontrol,
 	ucontrol->value.iec958.status[4] = (cstatus >> 8) & 0xFF;
 	ucontrol->value.iec958.status[5] = cstatus & 0xFF;
 
+	/* clear intr */
+	__raw_writel(INT_CNEW, spdif_base_addr + SPDIF_REG_SIC);
+
 	return 0;
 }
 
@@ -1798,11 +1816,10 @@ static int snd_mxc_spdif_subcode_get(struct snd_kcontrol *kcontrol,
 
 	spin_lock_irqsave(&mxc_spdif_control.ctl_lock, flags);
 	if (mxc_spdif_control.ready_buf) {
-		int index = 1 << mxc_spdif_control.ready_buf;
 		memcpy(&ucontrol->value.iec958.subcode[0],
-		       &mxc_spdif_control.subcode[(index - 1) *
-						  SPDIF_UBITS_SIZE],
-		       SPDIF_UBITS_SIZE);
+		       &mxc_spdif_control.
+		       subcode[(mxc_spdif_control.ready_buf -
+				1) * SPDIF_UBITS_SIZE], SPDIF_UBITS_SIZE);
 	} else {
 		ret = -EAGAIN;
 	}
@@ -1835,10 +1852,10 @@ static int snd_mxc_spdif_qget(struct snd_kcontrol *kcontrol,
 
 	spin_lock_irqsave(&mxc_spdif_control.ctl_lock, flags);
 	if (mxc_spdif_control.ready_buf) {
-		int index = 1 << mxc_spdif_control.ready_buf;
 		memcpy(&ucontrol->value.bytes.data[0],
-		       &mxc_spdif_control.qsub[(index - 1) * SPDIF_QSUB_SIZE],
-		       SPDIF_QSUB_SIZE);
+		       &mxc_spdif_control.
+		       qsub[(mxc_spdif_control.ready_buf -
+			     1) * SPDIF_QSUB_SIZE], SPDIF_QSUB_SIZE);
 	} else {
 		ret = -EAGAIN;
 	}
@@ -1868,8 +1885,10 @@ static int snd_mxc_spdif_vbit_get(struct snd_kcontrol *kcontrol,
 {
 	unsigned int int_val;
 
-	int_val = __raw_readl(SPDIF_REG_SIS);
-	ucontrol->value.integer.value[0] = (int_val & INT_VAL_NOGOOD) == 0;
+	int_val = __raw_readl(spdif_base_addr + SPDIF_REG_SIS);
+	ucontrol->value.integer.value[0] = (int_val & INT_VAL_NOGOOD) != 0;
+	__raw_writel(INT_VAL_NOGOOD, spdif_base_addr + SPDIF_REG_SIC);
+
 	return 0;
 }
 
@@ -1881,8 +1900,8 @@ static int snd_mxc_spdif_rxrate_info(struct snd_kcontrol *kcontrol,
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
-	uinfo->value.integer.min = 32;
-	uinfo->value.integer.max = 48;
+	uinfo->value.integer.min = 16000;
+	uinfo->value.integer.max = 96000;
 	return 0;
 }
 
@@ -1901,7 +1920,8 @@ static int snd_mxc_spdif_rxrate_get(struct snd_kcontrol *kcontrol,
 
 	if (atomic_read(&chip->dpll_locked)) {
 		ucontrol->value.integer.value[0] =
-		    spdif_get_rxclk_rate(spdif_data->spdif_clk);
+		    spdif_get_rxclk_rate(spdif_data->spdif_clk,
+					 SPDIF_DEFAULT_GAINSEL);
 	} else {
 		ucontrol->value.integer.value[0] = 0;
 	}
@@ -1931,7 +1951,7 @@ static int snd_mxc_spdif_usync_get(struct snd_kcontrol *kcontrol,
 {
 	unsigned int int_val;
 
-	int_val = __raw_readl(SPDIF_REG_SRCD);
+	int_val = __raw_readl(spdif_base_addr + SPDIF_REG_SRCD);
 	ucontrol->value.integer.value[0] = (int_val & SRCD_CD_USER) != 0;
 	return 0;
 }
@@ -1947,7 +1967,7 @@ static int snd_mxc_spdif_usync_put(struct snd_kcontrol *kcontrol,
 	unsigned int int_val;
 
 	int_val = ucontrol->value.integer.value[0] << SRCD_CD_USER_OFFSET;
-	__raw_writel(int_val, SPDIF_REG_SRCD);
+	__raw_writel(int_val, spdif_base_addr + SPDIF_REG_SRCD);
 	return 0;
 }
 
@@ -1998,7 +2018,7 @@ static struct snd_kcontrol_new snd_mxc_spdif_ctrls[] = {
 	/* DPLL lock info get controller */
 	{
 	 .iface = SNDRV_CTL_ELEM_IFACE_PCM,
-	 .name = "IEC958 RX Sample Rate",
+	 .name = "RX Sample Rate",
 	 .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
 	 .info = snd_mxc_spdif_rxrate_info,
 	 .get = snd_mxc_spdif_rxrate_get,
@@ -2006,7 +2026,7 @@ static struct snd_kcontrol_new snd_mxc_spdif_ctrls[] = {
 	/* User bit sync mode set/get controller */
 	{
 	 .iface = SNDRV_CTL_ELEM_IFACE_PCM,
-	 .name = "IEC958 User-bit SyncMode",
+	 .name = "IEC958 USyncMode CDText",
 	 .access =
 	 SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE |
 	 SNDRV_CTL_ELEM_ACCESS_VOLATILE,
@@ -2126,21 +2146,20 @@ static int mxc_alsa_spdif_probe(struct platform_device
 			goto nodev;
 	}
 
+	clk_enable(plat_data->spdif_core_clk);
 	/*!
 	 * SPDIF interrupt initialization
 	 * software reset to SPDIF
 	 */
-	clk_enable(plat_data->spdif_core_clk);
 	spdif_softreset();
 	/* disable all the interrupts */
 	spdif_intr_enable(0xffffff, 0);
 	/* spdif interrupt register and disable */
-	if (request_irq(MXC_INT_SPDIF, spdif_isr, 0, "spdif", chip->card->dev)) {
+	if (request_irq(MXC_INT_SPDIF, spdif_isr, 0, "spdif", chip)) {
 		pr_err("MXC spdif: failed to request irq\n");
 		err = -EBUSY;
 		goto nodev;
 	}
-	clk_disable(plat_data->spdif_core_clk);
 
 	if (chip->mxc_spdif_tx)
 		spin_lock_init(&chip->s[SNDRV_PCM_STREAM_PLAYBACK].dma_lock);
@@ -2173,15 +2192,19 @@ static int mxc_alsa_spdif_remove(struct platform_device *pdev)
 {
 	struct mxc_spdif_device *chip;
 	struct snd_card *card;
+	struct mxc_spdif_platform_data *plat_data;
 
 	card = platform_get_drvdata(pdev);
+	plat_data = pdev->dev.platform_data;
 	chip = card->private_data;
-	free_irq(MXC_INT_SPDIF, card->dev);
+	free_irq(MXC_INT_SPDIF, chip);
 	iounmap(chip->reg_base);
 
 	snd_card_free(card);
 	platform_set_drvdata(pdev, NULL);
 
+	clk_disable(plat_data->spdif_core_clk);
+
 	return 0;
 }
 
-- 
1.5.4.4

