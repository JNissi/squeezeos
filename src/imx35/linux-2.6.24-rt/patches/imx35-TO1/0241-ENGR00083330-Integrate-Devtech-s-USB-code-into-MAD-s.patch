From 39fe385ca69d84592821ff6d8459d319838a1307 Mon Sep 17 00:00:00 2001
From: Bruce Schmid <duck@freescale.com>
Date: Fri, 6 Jun 2008 15:09:31 -0600
Subject: [PATCH] ENGR00083330 Integrate Devtech's USB code into MAD's kernel

USB: mxc infrastructure changes

Signed-off-by: Bruce Schmid <duck@freescale.com>
---
 arch/arm/plat-mxc/Kconfig                 |   73 +++++-----
 arch/arm/plat-mxc/Makefile                |    5 +-
 arch/arm/plat-mxc/isp1301xc.c             |   20 ++-
 arch/arm/plat-mxc/isp1504xc.c             |   15 +-
 arch/arm/plat-mxc/mc13783_xc.c            |   60 ++++----
 arch/arm/plat-mxc/serialxc.c              |    2 +-
 arch/arm/plat-mxc/usb_common.c            |  240 ++++++++++-------------------
 arch/arm/plat-mxc/utmixc.c                |   11 +-
 include/asm-arm/arch-mxc/arc_otg.h        |   14 ++-
 include/asm-arm/arch-mxc/fsl_usb.h        |   57 +++++++
 include/asm-arm/arch-mxc/fsl_usb_gadget.h |   40 +++++
 include/linux/fsl_devices.h               |   25 ++--
 include/linux/usb/fsl_xcvr.h              |   17 ++-
 13 files changed, 310 insertions(+), 269 deletions(-)

diff --git a/arch/arm/plat-mxc/Kconfig b/arch/arm/plat-mxc/Kconfig
index c39ff32..713293b 100644
--- a/arch/arm/plat-mxc/Kconfig
+++ b/arch/arm/plat-mxc/Kconfig
@@ -110,63 +110,62 @@ config DMA_ZONE_SIZE
 	  This is the size in MB for the DMA zone. The DMA zone is used for
 	  dedicated memory for large contiguous video buffers
 
-choice
-        prompt "Select USB OTG transceiver"
-        depends on USB_ARCH_HAS_EHCI
-        default INTERN_UTMI
+# set iff we need the 1504 transceiver code
+config ISP1504_MXC
+	bool
+	select ISP1504_MXC_OTG if USB_GADGET && USB_EHCI_HCD && USB_OTG
+	default y if USB_EHCI_FSL_1504 || USB_GADGET_FSL_1504
 
-config INTERN_UTMI
-	bool "Internal UTMI transceiver"
+config ISP1504_MXC_OTG
+	tristate
 	help
-	  Support for the internal USB transceiver on MXC platforms
+	  Support for USB OTG pin detect using the ISP1504 transceiver on MXC platforms.
 
-config ISP1504_MXC
-	bool "ISP1504 transceiver support"
-	#depends on USB_ARCH_HAS_EHCI
-	help
-	  Support for the ISP1504 USB transceiver on MXC platforms.
-endchoice
-
-choice
-	prompt "Select serial USB transceiver"
-	depends on USB_EHCI_ARC_OTGFS || USB_GADGET_ARC_OTGFS
+# set iff we need the UTMI transceiver code
+config UTMI_MXC
+	bool
+	default y if USB_EHCI_FSL_UTMI || USB_GADGET_FSL_UTMI
+	depends on ARCH_MX35 || ARCH_MX37
 
+# set iff we need the 1301 transceiver code
 config ISP1301_MXC
-	bool "ISP1301 transceiver support"
+	bool
+	default y if USB_EHCI_FSL_1301 || USB_GADGET_FSL_1301
 	select I2C_MXC
-	help
-	  Support for the ISP1301 USB transceiver on MXC platforms.
 
+# set iff we need the mx13783 transceiver code
 config MC13783_MXC
-	bool "MC13783 transceiver support"
+	bool
+	default y if USB_EHCI_FSL_MC13783 || USB_GADGET_FSL_MC13783
 	select SPI_MXC
-	help
-	  Support for the MC13783 USB transceiver on MXC platforms.
-endchoice
 
 choice
-	prompt "Select serial USB mode"
+	prompt "Select serial USB transceiver mode"
 	depends on ISP1301_MXC || MC13783_MXC
-
-config MXC_USB_SB3
-	bool "USB Single End Bidirection Mode"
-	help
-	  If you say yes to this option, the serial tranceiver is on SB3 mode
+	default MXC_USB_SU6
 
 config MXC_USB_SU6
-	bool "USB Single End Unidirection Mode"
+	bool "Single Ended Unidirectional Mode"
 	help
-	  If you say yes to this option, the serial tranceiver is on SU6 mode
+	  If you say yes to this option, the serial tranceiver operates in SU6 mode.
+	  This option will work for either the Freescale MC13783 or Philips ISP1301
+	  transceiver.
 
-config MXC_USB_DB4
-	bool "USB Differential Bidirection Mode"
+config MXC_USB_SB3
+	bool "Single Ended Bidirectional Mode"
 	help
-	  If you say yes to this option, the serial tranceiver is on DB4 mode
+	  If you say yes to this option, the serial tranceiver operates in SB3 mode.
+	  Not recommended for the Freescale MC13783.
 
 config MXC_USB_DU6
-	bool "USB Differential Unidirection Mode"
+	bool "Differential Unidirectional Mode"
+	help
+	  If you say yes to this option, the serial tranceiver operates in DU6 mode.
+
+config MXC_USB_DB4
+	bool "Differential Bidirectional Mode"
 	help
-	  If you say yes to this option, the serial tranceiver is on DU6 mode
+	  If you say yes to this option, the serial tranceiver operates in DB4 mode.
 
 endchoice
 
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
index 873d25f..2f83197 100644
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -28,12 +28,9 @@ obj-$(CONFIG_LEDS) += leds.o
 
 # USB support
 obj-$(CONFIG_ISP1504_MXC) += isp1504xc.o
-
 obj-$(CONFIG_ISP1301_MXC) += isp1301xc.o
-
-obj-$(CONFIG_INTERN_UTMI) += utmixc.o
-
 obj-$(CONFIG_MC13783_MXC) += mc13783_xc.o
+obj-$(CONFIG_USB_EHCI_FSL_UTMI) += utmixc.o
 
 ifneq ($(CONFIG_USB_EHCI_ARC_H1),)
 obj-y += serialxc.o
diff --git a/arch/arm/plat-mxc/isp1301xc.c b/arch/arm/plat-mxc/isp1301xc.c
index e27e73d..4954ee3 100644
--- a/arch/arm/plat-mxc/isp1301xc.c
+++ b/arch/arm/plat-mxc/isp1301xc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -195,7 +195,7 @@ static inline void isp1301_set_serial_host(void)
 			  (VBUS_DRV | DP_PULLDOWN | DM_PULLDOWN));
 }
 
-/* set ISP1301 as USB device*/
+/* set ISP1301 as USB device */
 static inline void isp1301_set_serial_dev(void)
 {
 	pr_debug("%s\n", __FUNCTION__);
@@ -219,7 +219,7 @@ static inline void isp1301_set_serial_dev(void)
 			  (DP_PULLDOWN | DM_PULLDOWN | DP_PULLUP));
 }
 
-static void isp1301_set_vbus_power(u32 * view, int on)
+static void isp1301_set_vbus_power(struct fsl_xcvr_ops *this, int on)
 {
 	pr_debug("%s(on=%d)\n", __FUNCTION__, on);
 	if (on) {
@@ -239,6 +239,19 @@ static void isp1301_set_vbus_power(u32 * view, int on)
 	}
 }
 
+/*
+ * Enable or disable the D+ pullup.
+ */
+static void isp1301_pullup(int on)
+{
+	pr_debug("%s(%d)\n", __func__, on);
+
+	if (on)
+		isp1301_write_reg(ISP1301_CTRL_REG1_SET, DP_PULLUP);
+	else
+		isp1301_write_reg(ISP1301_CTRL_REG1_CLR, DP_PULLUP);
+}
+
 static struct fsl_xcvr_ops isp1301_ops_otg = {
 	.name = "isp1301",
 	.xcvr_type = PORTSC_PTS_SERIAL,
@@ -247,6 +260,7 @@ static struct fsl_xcvr_ops isp1301_ops_otg = {
 	.set_host = isp1301_set_serial_host,
 	.set_device = isp1301_set_serial_dev,
 	.set_vbus_power = isp1301_set_vbus_power,
+	.pullup = isp1301_pullup,
 };
 
 extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
diff --git a/arch/arm/plat-mxc/isp1504xc.c b/arch/arm/plat-mxc/isp1504xc.c
index c0f4317..ef18c90 100644
--- a/arch/arm/plat-mxc/isp1504xc.c
+++ b/arch/arm/plat-mxc/isp1504xc.c
@@ -16,6 +16,7 @@
 #include <linux/types.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
 #include <linux/delay.h>
 #include <linux/usb/fsl_xcvr.h>
 
@@ -59,7 +60,7 @@
  * @param       view  the ULPI VIEWPORT register address
  * @return	return isp1504 register value
  */
-static u8 isp1504_read(int reg, volatile u32 * view)
+static u8 isp1504_read(int reg, volatile u32 *view)
 {
 	u32 data;
 
@@ -88,7 +89,7 @@ static u8 isp1504_read(int reg, volatile u32 * view)
  * @param	reg   which register
  * @param       view  the ULPI VIEWPORT register address
  */
-static void isp1504_set(u8 bits, int reg, volatile u32 * view)
+static void isp1504_set(u8 bits, int reg, volatile u32 *view)
 {
 	u32 data;
 
@@ -116,7 +117,7 @@ static void isp1504_set(u8 bits, int reg, volatile u32 * view)
  * @param	reg   in this register
  * @param       view  the ULPI VIEWPORT register address
  */
-static void isp1504_clear(u8 bits, int reg, volatile u32 * view)
+static void isp1504_clear(u8 bits, int reg, volatile u32 *view)
 {
 	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
 		      ((reg + ISP1504_REG_CLEAR) << ULPIVW_ADDR_SHIFT) |
@@ -129,7 +130,7 @@ static void isp1504_clear(u8 bits, int reg, volatile u32 * view)
 
 extern int gpio_usbotg_hs_active(void);
 
-static void isp1508_fix(u32 * view)
+static void isp1508_fix(u32 *view)
 {
 	if (!machine_is_mx31_3ds())
 		gpio_usbotg_hs_active();
@@ -147,8 +148,10 @@ static void isp1508_fix(u32 * view)
  * @param       view  viewport register
  * @param       on    power on or off
  */
-static void isp1504_set_vbus_power(u32 * view, int on)
+static void isp1504_set_vbus_power(struct fsl_xcvr_ops *this, int on)
 {
+	u32 *view = this->pdata->regs + ULPIVW_OFF;
+
 	pr_debug("real %s(on=%d) view=0x%p\n", __FUNCTION__, on, view);
 
 	pr_debug("ULPI Vendor ID 0x%x    Product ID 0x%x\n",
@@ -223,8 +226,6 @@ static struct fsl_xcvr_ops isp1504_ops = {
 	.init = isp1504_init,
 	.uninit = isp1504_uninit,
 	.suspend = isp1504_suspend,
-	.set_host = NULL,
-	.set_device = NULL,
 	.set_vbus_power = isp1504_set_vbus_power,
 	.set_remote_wakeup = isp1504_set_remote_wakeup,
 };
diff --git a/arch/arm/plat-mxc/mc13783_xc.c b/arch/arm/plat-mxc/mc13783_xc.c
index 963d9e6..8cbc54d 100644
--- a/arch/arm/plat-mxc/mc13783_xc.c
+++ b/arch/arm/plat-mxc/mc13783_xc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -40,33 +40,33 @@ DECLARE_MUTEX(pmic_mx);
 
 static void pmic_event_handler(const PMIC_CONVITY_EVENTS event)
 {
-	if (event & USB_DETECT_4V4_RISE) {
-		pr_debug("%s: USB_DETECT_4V4_RISE\n", __FUNCTION__);
-	}
-	if (event & USB_DETECT_4V4_FALL) {
-		pr_debug("%s: USB_DETECT_4V4_FALL\n", __FUNCTION__);
-	}
-	if (event & USB_DETECT_2V0_RISE) {
-		pr_debug("%s: USB_DETECT_2V0_RISE\n", __FUNCTION__);
-	}
-	if (event & USB_DETECT_2V0_FALL) {
-		pr_debug("%s: USB_DETECT_2V0_FALL\n", __FUNCTION__);
-	}
-	if (event & USB_DETECT_0V8_RISE) {
-		pr_debug("%s: USB_DETECT_0V8_RISE\n", __FUNCTION__);
-	}
-	if (event & USB_DETECT_0V8_FALL) {
-		pr_debug("%s: USB_DETECT_0V8_FALL\n", __FUNCTION__);
-	}
+	if (event & USB_DETECT_4V4_RISE)
+		pr_debug("%s: USB_DETECT_4V4_RISE\n", __func__);
+
+	if (event & USB_DETECT_4V4_FALL)
+		pr_debug("%s: USB_DETECT_4V4_FALL\n", __func__);
+
+	if (event & USB_DETECT_2V0_RISE)
+		pr_debug("%s: USB_DETECT_2V0_RISE\n", __func__);
+
+	if (event & USB_DETECT_2V0_FALL)
+		pr_debug("%s: USB_DETECT_2V0_FALL\n", __func__);
+
+	if (event & USB_DETECT_0V8_RISE)
+		pr_debug("%s: USB_DETECT_0V8_RISE\n", __func__);
+
+	if (event & USB_DETECT_0V8_FALL)
+		pr_debug("%s: USB_DETECT_0V8_FALL\n", __func__);
+
 	if (event & USB_DETECT_MINI_B) {
-		pr_debug("%s: USB_DETECT_MINI_B\n", __FUNCTION__);
+		pr_debug("%s: USB_DETECT_MINI_B\n", __func__);
 		otg_set_serial_peripheral();
 		g_event = USB_DETECT_MINI_B;
 		p_event = MC13783_USB_DETECT_MINI_B;
 		schedule_work(&xc_work);
 	}
 	if (event & USB_DETECT_MINI_A) {
-		pr_debug("%s: USB_DETECT_MINI_A\n", __FUNCTION__);
+		pr_debug("%s: USB_DETECT_MINI_A\n", __func__);
 		otg_set_serial_host();
 		g_event = USB_DETECT_MINI_A;
 		p_event = MC13783_USB_DETECT_MINI_A;
@@ -148,9 +148,9 @@ static inline void mc13783_set_host(void)
 	rs |= pmic_convity_usb_otg_set_config(pmic_handle, USB_UDM_PD);
 	rs |= pmic_convity_usb_otg_set_config(pmic_handle, USB_UDP_PD);
 
-	if (rs != PMIC_SUCCESS) {
+	if (rs != PMIC_SUCCESS)
 		printk(KERN_ERR "mc13783_set_host failed\n");
-	}
+
 }
 
 static inline void mc13783_set_peripheral(void)
@@ -164,12 +164,11 @@ static inline void mc13783_set_peripheral(void)
 	rs |= pmic_convity_usb_otg_set_config(pmic_handle, USB_OTG_SE0CONN);
 	rs |= pmic_convity_usb_otg_set_config(pmic_handle, USB_PU);
 
-	if (rs != PMIC_SUCCESS) {
+	if (rs != PMIC_SUCCESS)
 		printk(KERN_ERR "mc13783_set_peripheral failed\n");
-	}
 }
 
-void mc13783_set_vbus_power(u32 * view, int on)
+void mc13783_set_vbus_power(struct fsl_xcvr_ops *this, int on)
 {
 	if (on) {
 		p_event = MC13783_USB_VBUS_ON;
@@ -206,9 +205,8 @@ static void xc_workqueue_handler(struct work_struct *work)
 		    pmic_convity_usb_otg_clear_config(pmic_handle,
 						      USB_VBUS_CURRENT_LIMIT_LOW_30MS);
 
-		if (rs != PMIC_SUCCESS) {
+		if (rs != PMIC_SUCCESS)
 			printk(KERN_ERR "MC13783_USB_VBUS_OFF failed\n");
-		}
 		break;
 	case MC13783_USB_DETECT_MINI_A:
 		rs = pmic_convity_set_output(pmic_handle, true, true);
@@ -216,9 +214,8 @@ static void xc_workqueue_handler(struct work_struct *work)
 		    pmic_convity_usb_otg_set_config(pmic_handle,
 						    USB_VBUS_CURRENT_LIMIT_LOW_30MS);
 
-		if (rs != PMIC_SUCCESS) {
+		if (rs != PMIC_SUCCESS)
 			printk(KERN_ERR "MC13783_USB_VBUS_ON failed\n");
-		}
 		break;
 	default:
 		break;
@@ -256,9 +253,8 @@ int mc13783xc_init(void)
 	rs |= pmic_convity_usb_otg_clear_config(pmic_handle, USB_USBCNTRL);
 	rs |= pmic_convity_usb_otg_clear_config(pmic_handle, USB_DP150K_PU);
 
-	if (rs != PMIC_SUCCESS) {
+	if (rs != PMIC_SUCCESS)
 		printk(KERN_ERR "pmic configuration failed\n");
-	}
 
 	fsl_usb_xcvr_register(&mc13783_ops_otg);
 
diff --git a/arch/arm/plat-mxc/serialxc.c b/arch/arm/plat-mxc/serialxc.c
index 6115df2..6fe6ad8 100644
--- a/arch/arm/plat-mxc/serialxc.c
+++ b/arch/arm/plat-mxc/serialxc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
diff --git a/arch/arm/plat-mxc/usb_common.c b/arch/arm/plat-mxc/usb_common.c
index a116649..7e01a8f 100644
--- a/arch/arm/plat-mxc/usb_common.c
+++ b/arch/arm/plat-mxc/usb_common.c
@@ -60,7 +60,10 @@ static int fsl_check_usbclk(void)
 	unsigned long freq;
 
 	usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
-	clk_enable(usb_ahb_clk);
+	if (clk_enable(usb_ahb_clk)) {
+		printk(KERN_ERR "clk_enable(usb_ahb_clk) failed\n");
+		return -EINVAL;
+	}
 	clk_put(usb_ahb_clk);
 
 	usb_clk = clk_get(NULL, "usb_clk");
@@ -78,7 +81,7 @@ void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops)
 {
 	int i;
 
-	pr_debug("%s\n", __FUNCTION__);
+	pr_debug("%s\n", __func__);
 	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
 		if (g_xc_ops[i] == NULL) {
 			g_xc_ops[i] = xcvr_ops;
@@ -86,16 +89,15 @@ void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops)
 		}
 	}
 
-	pr_debug("Failed %s\n", __FUNCTION__);
+	pr_debug("Failed %s\n", __func__);
 }
-
 EXPORT_SYMBOL(fsl_usb_xcvr_register);
 
 void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops)
 {
 	int i;
 
-	pr_debug("%s\n", __FUNCTION__);
+	pr_debug("%s\n", __func__);
 	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
 		if (g_xc_ops[i] == xcvr_ops) {
 			g_xc_ops[i] = NULL;
@@ -103,18 +105,17 @@ void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops)
 		}
 	}
 
-	pr_debug("Failed %s\n", __FUNCTION__);
+	pr_debug("Failed %s\n", __func__);
 }
-
 EXPORT_SYMBOL(fsl_usb_xcvr_unregister);
 
 static struct fsl_xcvr_ops *fsl_usb_get_xcvr(char *name)
 {
 	int i;
 
-	pr_debug("%s\n", __FUNCTION__);
+	pr_debug("%s\n", __func__);
 	if (name == NULL) {
-		printk(KERN_ERR "None tranceiver name be passed\n");
+		printk(KERN_ERR "get_xcvr(): No tranceiver name\n");
 		return NULL;
 	}
 
@@ -123,7 +124,7 @@ static struct fsl_xcvr_ops *fsl_usb_get_xcvr(char *name)
 			return g_xc_ops[i];
 		}
 	}
-	pr_debug("Failed %s\n", __FUNCTION__);
+	pr_debug("Failed %s\n", __func__);
 	return NULL;
 }
 
@@ -146,8 +147,8 @@ static u64 ehci_dmamask = ~(u32) 0;
  * to register each host interface.
  */
 static int instance_id = 0;
-struct platform_device *host_pdev_register(struct resource *res, int n_res, struct fsl_usb2_platform_data
-					   *config)
+struct platform_device *host_pdev_register(struct resource *res, int n_res,
+					   struct fsl_usb2_platform_data *config)
 {
 	struct platform_device *pdev;
 	int rc;
@@ -179,7 +180,8 @@ struct platform_device *host_pdev_register(struct resource *res, int n_res, stru
 		return NULL;
 	}
 
-	printk(KERN_INFO "usb: %s registered\n", config->name);
+	printk(KERN_INFO "usb: %s host (%s) registered\n", config->name,
+	       config->transceiver);
 	pr_debug("pdev=0x%p  dev=0x%p  resources=0x%p  pdata=0x%p\n",
 		 pdev, &pdev->dev, pdev->resource, pdev->dev.platform_data);
 
@@ -188,89 +190,21 @@ struct platform_device *host_pdev_register(struct resource *res, int n_res, stru
 	return pdev;
 }
 
-static int fsl_usb_mem_init(struct platform_device *pdev)
-{
-	struct resource *res;
-	struct fsl_usb2_platform_data *pdata;
-
-	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
-
-	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev, pdata);
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "no MEM resource.\n");
-		return -ENODEV;
-	}
-
-	pdata->r_start = res->start;
-	pdata->r_len = res->end - res->start + 1;
-	pr_debug("%s: MEM resource start=0x%x  len=0x%x\n", pdata->name,
-		 res->start, pdata->r_len);
-
-	if (!request_mem_region(pdata->r_start, pdata->r_len, "OTG")) {
-		dev_err(&pdev->dev, "request_mem_region failed\n");
-		return -EBUSY;
-	}
-	pdata->regs = ioremap(pdata->r_start, pdata->r_len);
-	pr_debug("ioremapped to 0x%p\n", pdata->regs);
-
-	if (pdata->regs == NULL) {
-		dev_err(&pdev->dev, "ioremap failed\n");
-		release_mem_region(pdata->r_start, pdata->r_len);
-		return -EFAULT;
-	}
-
-	pr_debug("%s: success\n", __FUNCTION__);
-	return 0;
-}
-
-static int fsl_usb_mem_map(struct platform_device *pdev)
-{
-	struct resource *res;
-	struct fsl_usb2_platform_data *pdata;
-
-	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
-
-	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev, pdata);
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "no MEM resource.\n");
-		return -ENODEV;
-	}
-
-	pdata->r_start = res->start;
-	pdata->r_len = res->end - res->start + 1;
-	pr_debug("%s: MEM resource start=0x%x  len=0x%x\n", pdata->name,
-		 res->start, pdata->r_len);
-
-	pdata->regs = ioremap(pdata->r_start, pdata->r_len);
-	pr_debug("ioremapped to 0x%p\n", pdata->regs);
-
-	if (pdata->regs == NULL) {
-		dev_err(&pdev->dev, "ioremap failed\n");
-		return -EFAULT;
-	}
-
-	pr_debug("%s: success\n", __FUNCTION__);
-	return 0;
-}
-
+/* DDD looks like this is needed by Belcarra code */
 void fsl_platform_set_vbus_power(struct fsl_usb2_platform_data *pdata, int on)
 {
 	if (pdata->xcvr_ops && pdata->xcvr_ops->set_vbus_power)
-		pdata->xcvr_ops->set_vbus_power((u32 *) pdata->viewport, on);
+		pdata->xcvr_ops->set_vbus_power(pdata->xcvr_ops, on);
 }
-
 EXPORT_SYMBOL(fsl_platform_set_vbus_power);
 
+/* DDD looks like this is needed by Belcarra code */
 void fsl_platform_perform_remote_wakeup(struct fsl_usb2_platform_data *pdata)
 {
 	if (pdata->xcvr_ops && pdata->xcvr_ops->set_remote_wakeup)
-		pdata->xcvr_ops->set_remote_wakeup((u32 *) pdata->viewport);
+		pdata->xcvr_ops->set_remote_wakeup(
+			(u32 *)(pdata->regs + ULPIVW_OFF));
 }
-
 EXPORT_SYMBOL(fsl_platform_perform_remote_wakeup);
 
 #if defined(CONFIG_USB_OTG)
@@ -285,47 +219,70 @@ static struct otg_transceiver *xceiv;
  */
 struct otg_transceiver *otg_get_transceiver(void)
 {
-	pr_debug("%s xceiv=0x%p\n", __FUNCTION__, xceiv);
+	pr_debug("%s xceiv=0x%p\n", __func__, xceiv);
 	if (xceiv)
 		get_device(xceiv->dev);
 	return xceiv;
 }
-
 EXPORT_SYMBOL(otg_get_transceiver);
 
 int otg_set_transceiver(struct otg_transceiver *x)
 {
-	pr_debug("%s xceiv=0x%p  x=0x%p\n", __FUNCTION__, xceiv, x);
+	pr_debug("%s xceiv=0x%p  x=0x%p\n", __func__, xceiv, x);
 	if (xceiv && x)
 		return -EBUSY;
 	xceiv = x;
 	return 0;
 }
-
 EXPORT_SYMBOL(otg_set_transceiver);
+
+static struct resource *otg_resources;
+
+struct resource *otg_get_resources(void)
+{
+	return otg_resources;
+}
+EXPORT_SYMBOL(otg_get_resources);
+
+int otg_set_resources(struct resource *resources)
+{
+	otg_resources = resources;
+	return 0;
+}
+EXPORT_SYMBOL(otg_set_resources);
 #endif
 
 static void usbh1_set_serial_xcvr(void)
 {
-	pr_debug("%s: \n", __FUNCTION__);
-	USBCTRL &= ~(UCTRL_H1SIC_MASK | UCTRL_BPE);	/* disable bypass mode */
-	USBCTRL |= UCTRL_H1SIC_SU6 |	/* single-ended / unidir. */
-	    UCTRL_H1WIE | UCTRL_H1DT |	/* disable H1 TLL */
-	    UCTRL_H1PM;		/* power mask */
-	UH1_PORTSC1 &= ~PORTSC_PTS_MASK;
-	UH1_PORTSC1 |= PORTSC_PTS_SERIAL;
+	pr_debug("%s: \n", __func__);
+	USBCTRL &= ~(UCTRL_H1SIC_MASK | UCTRL_BPE); /* disable bypass mode */
+	USBCTRL |= UCTRL_H1SIC_SU6 |		/* single-ended / unidir. */
+		   UCTRL_H1WIE | UCTRL_H1DT |	/* disable H1 TLL */
+		   UCTRL_H1PM;			/* power mask */
 }
 
 static void usbh2_set_ulpi_xcvr(void)
 {
-	USBCTRL &= ~(UCTRL_H2SIC_MASK | UCTRL_BPE);	/* disable bypass mode */
+	u32 tmp;
+
+	pr_debug("%s\n", __func__);
+	USBCTRL &= ~(UCTRL_H2SIC_MASK | UCTRL_BPE);
 	USBCTRL |= UCTRL_H2WIE |	/* wakeup intr enable */
-	    UCTRL_H2UIE |	/* ULPI intr enable */
-	    UCTRL_H2DT |	/* disable H2 TLL */
-	    UCTRL_H2PM;		/* power mask */
+		   UCTRL_H2UIE |	/* ULPI intr enable */
+		   UCTRL_H2DT |		/* disable H2 TLL */
+		   UCTRL_H2PM;		/* power mask */
 
-	/* set ULPI xcvr */
-	UH2_PORTSC1 = (UH2_PORTSC1 & (~PORTSC_PTS_MASK)) | PORTSC_PTS_ULPI;
+	/* must set ULPI phy before turning off clock */
+	tmp = UH2_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_ULPI;
+	UH2_PORTSC1 = tmp;
+
+	UH2_USBCMD |= UCMD_RESET;	/* reset the controller */
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	msleep(100);
 
 	/* Turn off the usbpll for ulpi tranceivers */
 	clk_disable(usb_clk);
@@ -368,14 +325,10 @@ extern void usbh2_put_xcvr_power(struct device *dev);
 
 int fsl_usb_host_init(struct platform_device *pdev)
 {
-	struct fsl_usb2_platform_data *pdata;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 	struct fsl_xcvr_ops *xops;
-	int rc;
 
-	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
-
-	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev,
-		 pdata->name);
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __func__, pdev, pdata);
 
 	xops = fsl_usb_get_xcvr(pdata->transceiver);
 	if (!xops) {
@@ -384,6 +337,8 @@ int fsl_usb_host_init(struct platform_device *pdev)
 	}
 	pdata->xcvr_ops = xops;
 	pdata->xcvr_type = xops->xcvr_type;
+	pdata->pdev = pdev;
+	xops->pdata = pdata;
 
 	if (fsl_check_usbclk() != 0)
 		return -EINVAL;
@@ -399,18 +354,15 @@ int fsl_usb_host_init(struct platform_device *pdev)
 		usbh2_get_xcvr_power(&(pdev->dev));
 	}
 
-	pr_debug("%s: grab pins\n", __FUNCTION__);
+	pr_debug("%s: grab pins\n", __func__);
 	if (pdata->gpio_usb_active())
 		return -EINVAL;
 
-	/* request_mem_region and ioremap registers */
-	if ((rc = fsl_usb_mem_init(pdev))) {
-		pdata->gpio_usb_inactive();	/* release our pins */
-		return rc;
+	if (clk_enable(usb_clk)) {
+		printk(KERN_ERR "clk_enable(usb_clk) failed\n");
+		return -EINVAL;
 	}
 
-	clk_enable(usb_clk);
-
 	if (xops->init)
 		xops->init(xops);
 
@@ -423,24 +375,19 @@ int fsl_usb_host_init(struct platform_device *pdev)
 		usbh2_set_ulpi_xcvr();
 	}
 
-	pr_debug("%s: %s success\n", __FUNCTION__, pdata->name);
+	pr_debug("%s: %s success\n", __func__, pdata->name);
 	return 0;
 }
-
 EXPORT_SYMBOL(fsl_usb_host_init);
 
 void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata)
 {
-	pr_debug("%s\n", __FUNCTION__);
+	pr_debug("%s\n", __func__);
 
 	if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
 		pdata->xcvr_ops->uninit(pdata->xcvr_ops);
 
-	iounmap(pdata->regs);
-	release_mem_region(pdata->r_start, pdata->r_len);
-
 	pdata->regs = NULL;
-	pdata->r_start = pdata->r_len = 0;
 
 	pdata->gpio_usb_inactive();
 	if (pdata->xcvr_type == PORTSC_PTS_SERIAL)
@@ -451,20 +398,16 @@ void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata)
 		kfree(pdata->xcvr_pwr);
 	}
 }
-
 EXPORT_SYMBOL(fsl_usb_host_uninit);
 
 static void otg_set_serial_xcvr(void)
 {
-	u32 tmp;
-
-	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
-	tmp |= PORTSC_PTS_SERIAL;
-	UOG_PORTSC1 = tmp;
+	pr_debug("%s\n", __func__);
 }
 
 void otg_set_serial_host(void)
 {
+	pr_debug("%s\n", __func__);
 	/* set USBCTRL for host operation
 	 * disable: bypass mode,
 	 * set: single-ended/unidir/6 wire, OTG wakeup intr enable,
@@ -487,7 +430,6 @@ void otg_set_serial_host(void)
 
 	USB_OTG_MIRROR = OTGM_VBUSVAL | OTGM_ASESVLD;	/* 0xa */
 }
-
 EXPORT_SYMBOL(otg_set_serial_host);
 
 void otg_set_serial_peripheral(void)
@@ -514,13 +456,13 @@ void otg_set_serial_peripheral(void)
 
 	USB_OTG_MIRROR = OTGM_VBUSVAL | OTGM_BSESVLD | OTGM_IDIDG;	/* oxd */
 }
-
 EXPORT_SYMBOL(otg_set_serial_peripheral);
 
 static void otg_set_ulpi_xcvr(void)
 {
 	u32 tmp;
 
+	pr_debug("%s\n", __func__);
 	USBCTRL &= ~UCTRL_OSIC_MASK;
 #if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX3)
 	USBCTRL &= ~UCTRL_BPE;
@@ -529,7 +471,7 @@ static void otg_set_ulpi_xcvr(void)
 	    UCTRL_OWIE |	/* OTG wakeup intr enable */
 	    UCTRL_OPM;		/* power mask */
 
-	/* set ULPI xcvr */
+	/* must set ULPI phy before turning off clock */
 	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
 	tmp |= PORTSC_PTS_ULPI;
 	UOG_PORTSC1 = tmp;
@@ -571,7 +513,6 @@ int fsl_usb_xcvr_suspend(struct fsl_xcvr_ops *xcvr_ops)
 	}
 	return 0;
 }
-
 EXPORT_SYMBOL(fsl_usb_xcvr_suspend);
 
 static void otg_set_utmi_xcvr(void)
@@ -621,35 +562,32 @@ static int otg_used = 0;
 
 int usbotg_init(struct platform_device *pdev)
 {
-	struct fsl_usb2_platform_data *pdata;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 	struct fsl_xcvr_ops *xops;
-	int rc;
-
-	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
 
-	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev, pdata);
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __func__, pdev, pdata);
 
 	xops = fsl_usb_get_xcvr(pdata->transceiver);
 	if (!xops) {
-		printk(KERN_ERR "OTG transceiver ops missing\n");
+		printk(KERN_ERR "DR transceiver ops missing\n");
 		return -EINVAL;
 	}
 	pdata->xcvr_ops = xops;
 	pdata->xcvr_type = xops->xcvr_type;
+	pdata->pdev = pdev;
+	xops->pdata = pdata;
 
 	if (!otg_used) {
 		if (fsl_check_usbclk() != 0)
 			return -EINVAL;
 
-		pr_debug("%s: grab pins\n", __FUNCTION__);
+		pr_debug("%s: grab pins\n", __func__);
 		if (pdata->gpio_usb_active())
 			return -EINVAL;
 
-		clk_enable(usb_clk);
-
-		/* request_mem_region and ioremap registers */
-		if ((rc = fsl_usb_mem_init(pdev))) {
-			return rc;
+		if (clk_enable(usb_clk)) {
+			printk(KERN_ERR "clk_enable(usb_clk) failed\n");
+			return -EINVAL;
 		}
 
 		if (xops->init)
@@ -669,31 +607,24 @@ int usbotg_init(struct platform_device *pdev)
 		} else if (xops->xcvr_type == PORTSC_PTS_UTMI) {
 			otg_set_utmi_xcvr();
 		}
-	} else {
-		fsl_usb_mem_map(pdev);
 	}
 
 	otg_used++;
-	pr_debug("%s: success\n", __FUNCTION__);
+	pr_debug("%s: success\n", __func__);
 	return 0;
 }
-
 EXPORT_SYMBOL(usbotg_init);
 
 void usbotg_uninit(struct fsl_usb2_platform_data *pdata)
 {
-	pr_debug("%s\n", __FUNCTION__);
+	pr_debug("%s\n", __func__);
 
 	otg_used--;
 	if (!otg_used) {
 		if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
 			pdata->xcvr_ops->uninit(pdata->xcvr_ops);
 
-		iounmap(pdata->regs);
-		release_mem_region(pdata->r_start, pdata->r_len);
-
 		pdata->regs = NULL;
-		pdata->r_start = pdata->r_len = 0;
 
 		if (machine_is_mx31_3ds()) {
 			if (pdata->xcvr_ops && pdata->xcvr_ops->suspend)
@@ -706,5 +637,4 @@ void usbotg_uninit(struct fsl_usb2_platform_data *pdata)
 			clk_disable(usb_clk);
 	}
 }
-
 EXPORT_SYMBOL(usbotg_uninit);
diff --git a/arch/arm/plat-mxc/utmixc.c b/arch/arm/plat-mxc/utmixc.c
index 0b78eff..ccf4a8c 100644
--- a/arch/arm/plat-mxc/utmixc.c
+++ b/arch/arm/plat-mxc/utmixc.c
@@ -14,10 +14,12 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
+#include <linux/device.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/err.h>
 #include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
 #include <linux/usb/fsl_xcvr.h>
 
 #include <asm/hardware.h>
@@ -38,16 +40,13 @@ static void usb_utmi_uninit(struct fsl_xcvr_ops *this)
  * @param       view  viewport register
  * @param       on    power on or off
  */
-static void set_power(u32 *view, int on)
+static void set_power(struct fsl_xcvr_ops *this, int on)
 {
-	struct device *dev;
-	struct platform_device *pdev;
+	struct device *dev = &this->pdata->pdev->dev;
 	struct regulator *usbotg_regux;
 
-	pr_debug("real %s(on=%d) view=0x%p\n", __FUNCTION__, on, view);
+	pr_debug("real %s(on=%d) pdata=0x%p\n", __func__, on, this->pdata);
 	if (machine_is_mx37_3ds()) {
-		pdev = (struct platform_device *)view;
-		dev = &(pdev->dev);
 		usbotg_regux = regulator_get(dev, "DCDC2");
 		if (on) {
 			regulator_enable(usbotg_regux);
diff --git a/include/asm-arm/arch-mxc/arc_otg.h b/include/asm-arm/arch-mxc/arc_otg.h
index 9c7a810..22b9821 100644
--- a/include/asm-arm/arch-mxc/arc_otg.h
+++ b/include/asm-arm/arch-mxc/arc_otg.h
@@ -37,7 +37,6 @@
 #define UOG_HWHOST		USBOTG_REG32(0x08)	/* Host h/w params */
 #define UOG_HWTXBUF		USBOTG_REG32(0x10)	/* TX buffer h/w params */
 #define UOG_HWRXBUF		USBOTG_REG32(0x14)	/* RX buffer h/w params */
-#define UOG_SBUSCFG             USBOTG_REG32(0x90)      /* System bus interface */
 #define UOG_CAPLENGTH		USBOTG_REG16(0x100)	/* Capability register length */
 #define UOG_HCIVERSION		USBOTG_REG16(0x102)	/* Host Interface version */
 #define UOG_HCSPARAMS		USBOTG_REG32(0x104)	/* Host control structural params */
@@ -200,7 +199,7 @@
 #define  OTGSC_IE_A_SESSION_VALID	(1 << 26)
 #define  OTGSC_IE_B_SESSION_VALID	(1 << 27)
 #define  OTGSC_IE_B_SESSION_END		(1 << 28)
-#define  OTGSC_IE_1ms_TIMER		(1 << 19)
+#define  OTGSC_IE_1ms_TIMER		(1 << 29)
 #define  OTGSC_IE_DATA_PULSE		(1 << 30)
 
 #if 1				/* FIXME these here for compatibility between my names and Leo's */
@@ -212,6 +211,14 @@
 #define  OTGSC_INTERRUPT_STATUS_BITS_MASK	OTGSC_IS_MASK
 #endif
 
+/* x_USBMODE */
+#define USBMODE_SLOM		(1 << 3)	/* setup lockout mode */
+#define USBMODE_ES		(1 << 2)	/* (big) endian select */
+#define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
+#define USBMODE_CM_HOST		(3 << 0)	/* host */
+#define USBMODE_CM_DEVICE	(2 << 0)	/* device */
+#define USBMODE_CM_reserved	(1 << 0)	/* reserved */
+
 /* USBCTRL */
 #define UCTRL_OWIR		(1 << 31)	/* OTG wakeup intr request received */
 #define UCTRL_OSIC_MASK		(3 << 29)	/* OTG  Serial Interface Config: */
@@ -243,7 +250,7 @@
 #define UCTRL_H1SIC_SU6		(2 << 13)	/* single-ended/unidirectional 6 wire */
 #define UCTRL_H1SIC_SB3		(3 << 13)	/* single-ended/bidirectional  3 wire */
 
-#define UCTRL_PP                (1 << 11)       /* The power polarity bit controls the polarity of the pwr output signal*/
+#define UCTRL_PP                (1 << 11)       /* power polarity bit */
 #define UCTRL_H1WIE		(1 << 11)	/* HOST1 wakeup intr enable */
 #define UCTRL_H1BPVAL_RXDP	(1 << 10)	/* HOST1 RxDp status in bypass mode */
 #define UCTRL_XCSO              (1 << 10)       /* Xcvr Clock Select for OTG port */
@@ -281,6 +288,7 @@
 #define USB_UTMI_PHYCTRL_UTMI_ENABLE   0x01000000
 
 /* ULPIVIEW register bits */
+#define ULPIVW_OFF		(0x170)
 #define ULPIVW_WU		(1 << 31)	/* Wakeup */
 #define ULPIVW_RUN		(1 << 30)	/* read/write run */
 #define ULPIVW_WRITE		(1 << 29)	/* 0=read  1=write */
diff --git a/include/asm-arm/arch-mxc/fsl_usb.h b/include/asm-arm/arch-mxc/fsl_usb.h
new file mode 100644
index 0000000..5803c2d
--- /dev/null
+++ b/include/asm-arm/arch-mxc/fsl_usb.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * USB Host side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+#include <asm/arch/arc_otg.h>
+
+/* ehci_arc_hc_driver.flags value */
+#define FSL_PLATFORM_HC_FLAGS (HCD_USB2 | HCD_MEMORY)
+
+static void fsl_setup_phy(struct ehci_hcd *ehci,
+			  enum fsl_usb2_phy_modes phy_mode,
+			  int port_offset);
+
+static inline void fsl_platform_usb_setup(struct ehci_hcd *ehci)
+{
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = ehci_to_hcd(ehci)->self.controller->platform_data;
+	fsl_setup_phy(ehci, pdata->phy_mode, 0);
+}
+
+static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
+{
+	unsigned int temp;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = hcd->self.controller->platform_data;
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_host)
+		pdata->xcvr_ops->set_host();
+
+	/* set host mode */
+	temp = readl(hcd->regs + 0x1a8);
+	writel(temp | USBMODE_CM_HOST, hcd->regs + 0x1a8);
+}
+
+/* Needed for i2c/serial transceivers */
+static inline void
+fsl_platform_set_vbus_power(struct fsl_usb2_platform_data *pdata, int on)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_vbus_power)
+		pdata->xcvr_ops->set_vbus_power(pdata->xcvr_ops, on);
+}
diff --git a/include/asm-arm/arch-mxc/fsl_usb_gadget.h b/include/asm-arm/arch-mxc/fsl_usb_gadget.h
new file mode 100644
index 0000000..d3c581e
--- /dev/null
+++ b/include/asm-arm/arch-mxc/fsl_usb_gadget.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * USB Gadget side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+
+/* Needed for i2c/serial transceivers */
+static inline void
+fsl_platform_set_device_mode(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_device)
+		pdata->xcvr_ops->set_device();
+}
+
+static inline void
+fsl_platform_pullup_enable(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->pullup)
+		pdata->xcvr_ops->pullup(1);
+}
+
+static inline void
+fsl_platform_pullup_disable(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->pullup)
+		pdata->xcvr_ops->pullup(0);
+}
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index 69acfec..b077896 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -99,33 +99,30 @@ enum fsl_usb2_phy_modes {
 	FSL_USB2_PHY_SERIAL,
 };
 
+struct platform_device;
 struct fsl_usb2_platform_data {
 	/* board specific information */
-	enum fsl_usb2_operating_modes operating_mode;
-	enum fsl_usb2_phy_modes phy_mode;
-	unsigned int port_enables;
+	enum fsl_usb2_operating_modes	operating_mode;
+	enum fsl_usb2_phy_modes		phy_mode;
+	unsigned int			port_enables;
 
-	/* DDD this could arguably be moved to a separate
-	 * fsl usb2 device header file
-	 */
 	char *name;		/* pretty print */
 	int (*platform_init) (struct platform_device *);
 	void (*platform_uninit) (struct fsl_usb2_platform_data *);
-	int (*platform_verify) (struct platform_device *);
+	void __iomem *regs;	/* ioremap'd register base */
 	u32 xcvr_type;		/* PORTSC_PTS_* */
 	char *transceiver;	/* transceiver name */
-	// DDD combine usbmode and view into 1 register-base variable
-	u32 usbmode;		/* address of usbmode register */
-	u32 viewport;		/* address of ulpiview register */
-	u32 r_start;		/* start of MEM resource */
-	u32 r_len;		/* length of MEM resource */
-	void __iomem *regs;	/* ioremap'd register base */
-	int does_otg;
 	unsigned power_budget;	/* for hcd->power_budget */
+	struct platform_device *pdev;
 	struct fsl_xcvr_ops *xcvr_ops;
 	struct fsl_xcvr_power *xcvr_pwr;
 	int (*gpio_usb_active) (void);
 	void (*gpio_usb_inactive) (void);
+	unsigned			big_endian_mmio : 1;
+	unsigned			big_endian_desc : 1;
+	unsigned			es : 1;	/* need USBMODE:ES */
+	unsigned			have_sysif_regs : 1;
+	unsigned			le_setup_buf : 1;
 };
 
 /* Flags in fsl_usb2_mph_platform_data */
diff --git a/include/linux/usb/fsl_xcvr.h b/include/linux/usb/fsl_xcvr.h
index b15990a..8cc8172 100644
--- a/include/linux/usb/fsl_xcvr.h
+++ b/include/linux/usb/fsl_xcvr.h
@@ -9,19 +9,22 @@
  * @uninit: transceiver- and board-specific uninitialization function
  * @set_host:
  * @set_device:
+ * @pullup: enable or disable D+ pullup
  *
  */
 struct fsl_xcvr_ops {
 	char *name;
 	u32 xcvr_type;
+	struct fsl_usb2_platform_data *pdata;
 
-	void (*init) (struct fsl_xcvr_ops * ops);
-	void (*uninit) (struct fsl_xcvr_ops * ops);
-   void (*suspend) (struct fsl_xcvr_ops *ops);
-	void (*set_host) (void);
-	void (*set_device) (void);
-	void (*set_vbus_power) (u32 * view, int on);
-	void (*set_remote_wakeup) (u32 * view);
+	void (*init)(struct fsl_xcvr_ops *ops);
+	void (*uninit)(struct fsl_xcvr_ops *ops);
+	void (*suspend)(struct fsl_xcvr_ops *ops);
+	void (*set_host)(void);
+	void (*set_device)(void);
+	void (*set_vbus_power)(struct fsl_xcvr_ops *ops, int on);
+	void (*set_remote_wakeup)(u32 *view);
+	void (*pullup)(int on);
 };
 
 struct fsl_xcvr_power {
-- 
1.5.4.4

