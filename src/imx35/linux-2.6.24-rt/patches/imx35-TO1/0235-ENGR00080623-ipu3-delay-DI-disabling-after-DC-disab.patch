From ac1e5b3195d0de0a23623208ba74112d2f48b63b Mon Sep 17 00:00:00 2001
From: Rob Herring <r.herring@freescale.com>
Date: Tue, 17 Jun 2008 21:33:33 -0500
Subject: [PATCH] ENGR00080623 ipu3: delay DI disabling after DC disable

The LCD can only be re-enabled every other time. The disabling of the
DI counter needs to be delayed some after disabling the DC.

Signed-off-by: Rob Herring <r.herring@freescale.com>
---
 drivers/mxc/ipu3/ipu_disp.c |   15 ++++++++-------
 1 files changed, 8 insertions(+), 7 deletions(-)

diff --git a/drivers/mxc/ipu3/ipu_disp.c b/drivers/mxc/ipu3/ipu_disp.c
index 41149ae..86754d4 100644
--- a/drivers/mxc/ipu3/ipu_disp.c
+++ b/drivers/mxc/ipu3/ipu_disp.c
@@ -457,13 +457,6 @@ static irqreturn_t dc_irq_handler(int irq, void *dev_id)
 	reg &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;
 	__raw_writel(reg, dc_ch_conf);
 
-	reg = __raw_readl(IPU_DISP_GEN);
-	if (g_ipu_di_channel[0] == channel)
-		reg &= ~DI0_COUNTER_RELEASE;
-	else if (g_ipu_di_channel[1] == channel)
-		reg &= ~DI1_COUNTER_RELEASE;
-	__raw_writel(reg, IPU_DISP_GEN);
-
 	complete(comp);
 	return IRQ_HANDLED;
 }
@@ -518,6 +511,14 @@ void _ipu_dp_dc_disable(ipu_channel_t channel)
 		return;
 	}
 	ret = wait_for_completion_timeout(&dc_comp, msecs_to_jiffies(50));
+
+	reg = __raw_readl(IPU_DISP_GEN);
+	if (g_ipu_di_channel[0] == channel)
+		reg &= ~DI0_COUNTER_RELEASE;
+	else if (g_ipu_di_channel[1] == channel)
+		reg &= ~DI1_COUNTER_RELEASE;
+	__raw_writel(reg, IPU_DISP_GEN);
+
 	dev_dbg(g_ipu_dev, "DC stop timeout - %d * 10ms\n", 5 - ret);
 	ipu_free_irq(irq, &dc_comp);
 }
-- 
1.5.4.4

