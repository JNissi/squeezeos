From 36878f53375238acb2b53ad21a6316c23a88eabd Mon Sep 17 00:00:00 2001
From: Jason Liu <r64343@freescale.com>
Date: Fri, 14 Mar 2008 22:52:12 -0500
Subject: [PATCH] ENGR00068802 remove the jffs2 workaround

remove the jffs2 workaround from nand driver

Signed-off-by: Jason Liu <r64343@freescale.com>
---
 drivers/mtd/nand/mxc_nd2.c |  195 +++++---------------------------------------
 1 files changed, 20 insertions(+), 175 deletions(-)

diff --git a/drivers/mtd/nand/mxc_nd2.c b/drivers/mtd/nand/mxc_nd2.c
index 05dfccb..702f6a1 100644
--- a/drivers/mtd/nand/mxc_nd2.c
+++ b/drivers/mtd/nand/mxc_nd2.c
@@ -27,7 +27,7 @@
 #include <asm/io.h>
 #include "mxc_nd2.h"
 
-#define DVR_VER "2.3"
+#define DVR_VER "2.4"
 
 /* Global address Variables */
 static u32 nfc_axi_base, nfc_ip_base;
@@ -62,51 +62,7 @@ static int hardware_ecc = 0;
 static int hardware_ecc = 1;
 #endif
 
-static int page_to_block_shift;
 static int g_page_mask;
-static int scan_done;
-static int skip_erase;
-static u8 *oob_data_shadow_p;
-/*
- * OOB data that is shadowed in the SDRAM to prevent the Spare only access
- * to the Nand chip. This is valid only for the JFFS2 File System.
- */
-static uint8_t *shadow_oob_data;
-
-static uint8_t oob_data_512[] = {
-	0x85, 0x19, 0x03, 0x20, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
-};
-
-static uint8_t oob_data_2k[] = {
-	0xff, 0xff, 0x85, 0x19, 0x03, 0x20, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
-};
-
-static uint8_t oob_data_4k[] = {
-	0xff, 0xff, 0x85, 0x19, 0x03, 0x20, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
-};
 
 static struct clk *nfc_clk;
 
@@ -139,7 +95,7 @@ static struct nand_ecclayout nand_hw_eccoob_4k = {
  */
 
 /*!
- * @file mxc_nd3.c
+ * @file mxc_nd2.c
  *
  * @brief This file contains the hardware specific layer for NAND Flash on
  * MXC processor
@@ -165,45 +121,6 @@ static irqreturn_t mxc_nfc_irq(int irq, void *dev_id)
 static u8 mxc_main_xfer_buf[4096] ____cacheline_aligned;
 
 /*
- * Functions that operate on the shadow table maintained in the RAM.
- * Each block in the Nand chip has one bit entry in this table
- * indicating if the block has a JFFS2 clean marker.
- * mark_oob_data_dirty - marks a block to indicate that the block has a JFFS2
- * clean marker
- * is_oob_data_dirty - checks if the block has a JFFS2 clean marker
- * mark_oob_data_clean - marks a block to indicate that the block is erased
- * and doesnot contain JFFS2 clean marker.
- */
-
-static void mark_oob_data_dirty(u32 page, int update_sp)
-{
-	u32 blk = page >> page_to_block_shift;
-	u32 off = blk / 8;
-	u32 bit = blk % 8;
-
-	oob_data_shadow_p[off] |= (1 << bit);
-}
-
-static int is_oob_data_dirty(u32 page)
-{
-	u32 blk = page >> page_to_block_shift;
-	u32 off = blk / 8;
-	u32 bit = blk % 8;
-
-	return oob_data_shadow_p[off] & (1 << bit);
-}
-
-static void mark_oob_data_clean(u32 page)
-{
-
-	u32 blk = page >> page_to_block_shift;
-	u32 off = blk / 8;
-	u32 bit = blk % 8;
-
-	oob_data_shadow_p[off] &= ~(1 << bit);
-}
-
-/*
  * Functions to handle 32-bit aligned memcpy.
  */
 static void nfc_memcpy(void *dst, const void *src, int len)
@@ -781,29 +698,6 @@ static void read_full_page(struct mtd_info *mtd, int page_addr)
 	}
 }
 
-/*
- * Function to check if the page read is a clean page.(Valid only
- * the first page of the block.
- * It is done by checking if all spare data of the page is all 0xFF.
- * This is valid even if ECC generated is all 0xFF as the JFFS2 places
- * clean marker bytes in the first page of each block which is non 0xFF.
- */
-static int is_page_clean(struct mtd_info *mtd)
-{
-	volatile u32 *p = (u32 *) SPARE_AREA0;
-	int len;
-
-	/*Check spare page */
-	len = mtd->oobsize;
-	for (; len > 0; len -= 4) {
-		if (*p++ != 0xFFFFFFFF) {
-			return 0;
-		}
-	}
-
-	return 1;
-}
-
 /*!
  * This function is used by the upper layer to write command to NAND Flash for
  * different operations to be carried out on NAND Flash
@@ -852,21 +746,8 @@ static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
 	case NAND_CMD_SEQIN:
 		if (column >= mtd->writesize) {
 			g_nandfc_info.bSpareOnly = true;
-			mark_oob_data_dirty(page_addr, 1);
 		} else {
-			if (is_oob_data_dirty(page_addr)) {
-				copy_spare(mtd, shadow_oob_data,
-					   (char *)SPARE_AREA0, mtd->oobsize,
-					   false);
-			} else {
-				copy_spare(mtd,
-					   ((struct nand_chip *)(mtd->priv))->
-					   oob_poi, (char *)SPARE_AREA0,
-					   mtd->oobsize, false);
-			}
 			g_nandfc_info.bSpareOnly = false;
-			/* Set program pointer to page start */
-			send_cmd(NAND_CMD_READ0, false);
 		}
 		useirq = false;
 		break;
@@ -884,24 +765,9 @@ static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
 		break;
 
 	case NAND_CMD_ERASE1:
-		/*Decide to erase */
-		if (!IS_4K_PAGE_NAND) {
-			read_full_page(mtd, page_addr);
-			if (is_page_clean(mtd)) {
-				mark_oob_data_clean(page_addr);
-				skip_erase = 1;
-				return;
-			}
-		}
 		useirq = false;
 		break;
 	case NAND_CMD_ERASE2:
-		if (!IS_4K_PAGE_NAND) {
-			if (skip_erase) {
-				skip_erase = 0;
-				return;
-			}
-		}
 		useirq = false;
 		break;
 	}
@@ -963,9 +829,6 @@ static void mxc_low_erase(struct mtd_info *mtd)
 #define mxc_low_erase(x)
 #endif
 
-/* Kevin: why do we need this???,
- * Yes, to avoid LED event trigger functions which will add code, -Raj*/
-
 static int mxc_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 {
 	unsigned long timeo = jiffies;
@@ -999,12 +862,6 @@ static int mxc_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 static int mxc_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
 			     int page, int sndcmd)
 {
-	if (scan_done && is_oob_data_dirty(page)) {
-		memcpy((void *)chip->oob_poi, (void *)shadow_oob_data,
-		       mtd->oobsize);
-		return 0;
-	}
-
 	if (sndcmd) {
 		read_full_page(mtd, page);
 		sndcmd = 0;
@@ -1022,23 +879,23 @@ static int mxc_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
 	int read_oob_col = 0;
 	volatile uint16_t *p_addr = SPARE_AREA0;
 
-	//FIXME Check for bad block marking
-	if (0xFF == buf[chip->badblockpos]) {
-		mark_oob_data_dirty(page, 1);
-	} else {
-		send_cmd(NAND_CMD_READ0, false);
-		send_cmd(NAND_CMD_SEQIN, false);
-		mxc_do_addr_cycle(mtd, read_oob_col, page);
+	send_cmd(NAND_CMD_READ0, false);
+	send_cmd(NAND_CMD_SEQIN, false);
+	mxc_do_addr_cycle(mtd, read_oob_col, page);
 
-		memcpy((void *)p_addr, buf, mtd->oobsize);
-		/* Send command to program the OOB data */
+	/* copy the oob data */
+	copy_spare(mtd, (char *)p_addr, (char *)buf, mtd->oobsize, false);
+
+	if (IS_LARGE_PAGE_NAND)
+		PROG_PAGE();
+	else
 		send_prog_page(0);
-		send_cmd(NAND_CMD_PAGEPROG, true);
 
-		status = mxc_nand_wait(mtd, chip);
-		if (status & NAND_STATUS_FAIL)
-			return -EIO;
-	}
+	send_cmd(NAND_CMD_PAGEPROG, true);
+
+	status = mxc_nand_wait(mtd, chip);
+	if (status & NAND_STATUS_FAIL)
+		return -EIO;
 	return 0;
 }
 
@@ -1145,27 +1002,25 @@ static struct nand_bbt_descr bbt_mirror_descr = {
 static int mxc_nand_scan_bbt(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	int n;
 
-	/* Do some configurations before scanning */
-	page_to_block_shift = this->phys_erase_shift - this->page_shift;
 	g_page_mask = this->pagemask;
 
 	if (IS_2K_PAGE_NAND) {
 		SET_NFMS(1 << NFMS_NF_PG_SZ);
 		this->ecc.layout = &nand_hw_eccoob_2k;
-		shadow_oob_data = oob_data_2k;
 	} else if (IS_4K_PAGE_NAND) {
 		SET_NFMS(1 << NFMS_NF_PG_SZ);
 		this->ecc.layout = &nand_hw_eccoob_4k;
-		shadow_oob_data = oob_data_4k;
 	} else {
 		this->ecc.layout = &nand_hw_eccoob_512;
-		shadow_oob_data = oob_data_512;
 	}
 
 	/* propagate ecc.layout to mtd_info */
 	mtd->ecclayout = this->ecc.layout;
+
+	/* jffs2 not write oob */
+	mtd->flags &= ~MTD_OOB_WRITEABLE;
+
 	if (IS_4K_PAGE_NAND) {
 		this->bbt_td = &bbt_main_descr;
 		this->bbt_md = &bbt_mirror_descr;
@@ -1178,15 +1033,6 @@ static int mxc_nand_scan_bbt(struct mtd_info *mtd)
 		    &largepage_memorybased : &smallpage_memorybased;
 	}
 
-	n = mtd->size >> this->phys_erase_shift;
-	/* each bit is used for one page's dirty information */
-	oob_data_shadow_p = (u8 *) kzalloc(n / 8, GFP_KERNEL);
-	if (!oob_data_shadow_p) {
-		printk(KERN_ERR "%s: failed to allocate oob_data_shadow_p\n",
-		       __FUNCTION__);
-		kfree(mxc_nand_data);
-		return -ENOMEM;
-	}
 	/* Build bad block table */
 	return nand_scan_bbt(mtd, this->badblock_pattern);
 }
@@ -1309,7 +1155,6 @@ static int __init mxcnd_probe(struct platform_device *pdev)
 		err = -ENXIO;
 		goto out_1;
 	}
-	scan_done = 1;
 
 	/* Register the partitions */
 #ifdef CONFIG_MTD_PARTITIONS
-- 
1.5.4.4

