From cca46c4243f4a66853ab34322495c3e82ea7bfb1 Mon Sep 17 00:00:00 2001
From: Jun Li <r65092@freescale.com>
Date: Fri, 25 Apr 2008 19:17:04 +0800
Subject: [PATCH] ENGR00058765 MX35 FEC driver

Support FEC driver in i.MX35 platform

Signed-off-by: Jun Li <r65092@freescale.com>
---
 arch/arm/mach-mx35/mx35_3stack_gpio.c |  106 ++++++++++++++++++++++++++++++++-
 drivers/net/fec.c                     |   58 +++++++++++++++++-
 2 files changed, 159 insertions(+), 5 deletions(-)

diff --git a/arch/arm/mach-mx35/mx35_3stack_gpio.c b/arch/arm/mach-mx35/mx35_3stack_gpio.c
index b65ce6a..f4f9db7 100644
--- a/arch/arm/mach-mx35/mx35_3stack_gpio.c
+++ b/arch/arm/mach-mx35/mx35_3stack_gpio.c
@@ -18,6 +18,7 @@
 #include <asm/io.h>
 #include <asm/hardware.h>
 #include <asm/arch/gpio.h>
+#include <asm/arch/pmic_external.h>
 #include "board-mx35_3stack.h"
 #include "iomux.h"
 
@@ -173,16 +174,117 @@ EXPORT_SYMBOL(config_uartdma_event);
 
 void gpio_fec_active(void)
 {
-
+	mxc_request_iomux(MX35_PIN_FEC_TX_CLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RX_CLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RX_DV, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_COL, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RDATA0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_TDATA0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_TX_EN, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_MDC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_MDIO, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_TX_ERR, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RX_ERR, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_CRS, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RDATA1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_TDATA1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RDATA2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_TDATA2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_RDATA3, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_FEC_TDATA3, MUX_CONFIG_FUNC);
+
+#define FEC_PAD_CTL_COMMON (PAD_CTL_DRV_3_3V|PAD_CTL_PUE_PUD| \
+			PAD_CTL_ODE_CMOS|PAD_CTL_DRV_NORMAL|PAD_CTL_SRE_SLOW)
+	mxc_iomux_set_pad(MX35_PIN_FEC_TX_CLK, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RX_CLK, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RX_DV, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_COL, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RDATA0, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_TDATA0, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_CMOS|PAD_CTL_PKE_NONE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_TX_EN, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_CMOS|PAD_CTL_PKE_NONE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_MDC, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_CMOS|PAD_CTL_PKE_NONE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_MDIO, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE|PAD_CTL_22K_PU);
+	mxc_iomux_set_pad(MX35_PIN_FEC_TX_ERR, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_CMOS|PAD_CTL_PKE_NONE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RX_ERR, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_CRS, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RDATA1, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_TDATA1, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_CMOS|PAD_CTL_PKE_NONE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RDATA2, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_TDATA2, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_CMOS|PAD_CTL_PKE_NONE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_RDATA3, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE|PAD_CTL_100K_PD);
+	mxc_iomux_set_pad(MX35_PIN_FEC_TDATA3, FEC_PAD_CTL_COMMON|
+		PAD_CTL_HYS_CMOS|PAD_CTL_PKE_NONE|PAD_CTL_100K_PD);
+#undef FEC_PAD_CTL_COMMON
+
+	/* FEC enable */
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_GPIO_CONTROL_1, 2, 1);
+	/* FEC reset */
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_RESET_1, 7, 0);
+	msleep(10);
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_RESET_1, 7, 1);
+	msleep(100);
 }
-
 EXPORT_SYMBOL(gpio_fec_active);
 
 void gpio_fec_inactive(void)
 {
-
+	mxc_request_gpio(MX35_PIN_FEC_TX_CLK);
+	mxc_request_gpio(MX35_PIN_FEC_RX_CLK);
+	mxc_request_gpio(MX35_PIN_FEC_RX_DV);
+	mxc_request_gpio(MX35_PIN_FEC_COL);
+	mxc_request_gpio(MX35_PIN_FEC_RDATA0);
+	mxc_request_gpio(MX35_PIN_FEC_TDATA0);
+	mxc_request_gpio(MX35_PIN_FEC_TX_EN);
+	mxc_request_gpio(MX35_PIN_FEC_MDC);
+	mxc_request_gpio(MX35_PIN_FEC_MDIO);
+	mxc_request_gpio(MX35_PIN_FEC_TX_ERR);
+	mxc_request_gpio(MX35_PIN_FEC_RX_ERR);
+	mxc_request_gpio(MX35_PIN_FEC_CRS);
+	mxc_request_gpio(MX35_PIN_FEC_RDATA1);
+	mxc_request_gpio(MX35_PIN_FEC_TDATA1);
+	mxc_request_gpio(MX35_PIN_FEC_RDATA2);
+	mxc_request_gpio(MX35_PIN_FEC_TDATA2);
+	mxc_request_gpio(MX35_PIN_FEC_RDATA3);
+	mxc_request_gpio(MX35_PIN_FEC_TDATA3);
+
+	mxc_free_iomux(MX35_PIN_FEC_TX_CLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RX_CLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RX_DV, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_COL, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RDATA0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_TDATA0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_TX_EN, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_MDC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_MDIO, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_TX_ERR, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RX_ERR, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_CRS, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RDATA1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_TDATA1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RDATA2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_TDATA2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_RDATA3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX35_PIN_FEC_TDATA3, MUX_CONFIG_GPIO);
+
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_GPIO_CONTROL_1, 2, 0);
 }
-
 EXPORT_SYMBOL(gpio_fec_inactive);
 
 /*!
diff --git a/drivers/net/fec.c b/drivers/net/fec.c
index 749f9b8..5de7380 100644
--- a/drivers/net/fec.c
+++ b/drivers/net/fec.c
@@ -52,6 +52,7 @@
 #include <asm/io.h>
 #include <asm/pgtable.h>
 #include <asm/cacheflush.h>
+#include <asm/mach-types.h>
 
 #if defined(CONFIG_M523x) || defined(CONFIG_M527x) || \
     defined(CONFIG_M5272) || defined(CONFIG_M528x) || \
@@ -1264,6 +1265,26 @@ static phy_info_t phy_info_dp83848= {
 	},
 };
 
+static phy_info_t phy_info_lan8700 = {
+	0x0007C0C,
+	"LAN8700",
+	(const phy_cmd_t []) { /* config */
+		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
+		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) { /* startup */
+		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
+		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) { /* act_int */
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) { /* shutdown */
+		{ mk_mii_end, }
+	},
+};
 /* ------------------------------------------------------------------------- */
 
 static phy_info_t const * const phy_info[] = {
@@ -1273,6 +1294,7 @@ static phy_info_t const * const phy_info[] = {
 	&phy_info_am79c874,
 	&phy_info_ks8721bl,
 	&phy_info_dp83848,
+	&phy_info_lan8700,
 	NULL
 };
 
@@ -2059,7 +2081,8 @@ static void __inline__ fec_request_intrs(struct net_device *dev)
 	if (request_irq(MXC_INT_FEC, fec_enet_interrupt, 0, "fec", dev) != 0)
 		panic("FEC: Could not allocate FEC IRQ(%d)!\n", MXC_INT_FEC);
 	/* TODO: disable now due to CPLD issue */
-	if (request_irq(expio_intr_fec, mii_link_interrupt, 0, "fec(MII)", dev) != 0)
+	if ((expio_intr_fec > 0) &&
+	(request_irq(expio_intr_fec, mii_link_interrupt, 0, "fec(MII)", dev) != 0))
 		panic("FEC: Could not allocate FEC(MII) IRQ(%d)!\n", expio_intr_fec);
 	disable_irq(expio_intr_fec);
 }
@@ -2100,12 +2123,15 @@ static void __inline__ fec_get_mac(struct net_device *dev)
 		fec_mac_base = FEC_IIM_BASE + MXC_IIMMAC;
 	}
 
+	memset(tmpaddr, 0, ETH_ALEN);
+	if (!machine_is_mx35_3ds()) {
 	/*
 	 * Get MAC address from IIM.
 	 * If it is all 1's or 0's, use the default.
 	 */
-	for (i = 0; i < ETH_ALEN; i++) {
-		tmpaddr[ETH_ALEN-1-i] = __raw_readb(fec_mac_base + i * 4);
+		for (i = 0; i < ETH_ALEN; i++) {
+			tmpaddr[ETH_ALEN-1-i] = __raw_readb(fec_mac_base + i * 4);
+		}
 	}
 	iap = &tmpaddr[0];
 
@@ -2123,6 +2149,32 @@ static void __inline__ fec_get_mac(struct net_device *dev)
 		dev->dev_addr[ETH_ALEN-1] = fec_mac_default[ETH_ALEN-1] + fep->index;
 }
 
+#ifndef MODULE
+static int fec_mac_setup(char *new_mac)
+{
+	char *ptr, *p = new_mac;
+	int i = 0;
+
+	while (p && (*p) && i < 6) {
+		ptr = strchr(p, ':');
+		if (ptr)
+			*ptr++ = '\0';
+
+		if (strlen(p)) {
+			unsigned long tmp = simple_strtoul(p, NULL, 16);
+			if (tmp > 0xff)
+				break;
+			fec_mac_default[i++] = tmp;
+		}
+		p = ptr;
+	}
+
+	return 0;
+}
+
+__setup("fec_mac=", fec_mac_setup);
+#endif
+
 static void __inline__ fec_enable_phy_intr(void)
 {
 	enable_irq(expio_intr_fec);
-- 
1.5.4.4

