From 694c3f5778b7535e2684745ebd726fb2dbb29990 Mon Sep 17 00:00:00 2001
From: Bruce Schmid <duck@freescale.com>
Date: Fri, 6 Jun 2008 15:15:42 -0600
Subject: [PATCH] ENGR00083330-5 Integrate Devtech's USB code patch 5/12

USB: mx3 platform_device registration

Signed-off-by: Bruce Schmid <duck@freescale.com>
---
 arch/arm/mach-mx3/Makefile |   10 +++-
 arch/arm/mach-mx3/usb.h    |  116 ++++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-mx3/usb_dr.c |  125 ++++++++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-mx3/usb_h1.c |   53 +++++++++++++++++++
 arch/arm/mach-mx3/usb_h2.c |   88 +++++++++++++++++++++++++++++++
 5 files changed, 391 insertions(+), 1 deletions(-)

diff --git a/arch/arm/mach-mx3/Makefile b/arch/arm/mach-mx3/Makefile
index 7055541..1b880e3 100644
--- a/arch/arm/mach-mx3/Makefile
+++ b/arch/arm/mach-mx3/Makefile
@@ -4,10 +4,18 @@
 
 # Object file lists.
 
-obj-y			:= system.o iomux.o cpu.o mm.o clock.o usb.o dptc.o devices.o serial.o dma.o mxc_pm.o dvfs_v2.o
+obj-y			:= system.o iomux.o cpu.o mm.o clock.o dptc.o devices.o serial.o dma.o mxc_pm.o dvfs_v2.o
 obj-$(CONFIG_MACH_MX31ADS)	+= mx31ads.o mx31ads_gpio.o
 obj-$(CONFIG_MACH_MX31_3DS)	+= mx3_3stack.o mx3_3stack_gpio.o
 
 # power management
 obj-$(CONFIG_MXC_DVFS)  += dvfs.o
 obj-$(CONFIG_PM) 		+= pm.o
+
+obj-$(CONFIG_USB_EHCI_ARC_H1)	+= usb_h1.o
+obj-$(CONFIG_USB_EHCI_ARC_H2)	+= usb_h2.o
+
+ifneq ($(strip $(CONFIG_USB_GADGET_ARC) $(CONFIG_USB_EHCI_ARC_OTG)),)
+	obj-y	+= usb_dr.o
+endif
+
diff --git a/arch/arm/mach-mx3/usb.h b/arch/arm/mach-mx3/usb.h
new file mode 100644
index 0000000..d272195
--- /dev/null
+++ b/arch/arm/mach-mx3/usb.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_fs_active(void);
+extern void gpio_usbotg_fs_inactive(void);
+extern int gpio_usbotg_hs_active(void);
+extern void gpio_usbotg_hs_inactive(void);
+extern struct platform_device *host_pdev_register(struct resource *res,
+		  int n_res, struct fsl_usb2_platform_data *config);
+
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbh1_active(void);
+extern void gpio_usbh1_inactive(void);
+extern int gpio_usbh2_active(void);
+extern void gpio_usbh2_inactive(void);
+
+/*
+ * Determine which platform_data struct to use for the DR controller,
+ * based on which transceiver is configured.
+ * PDATA is a pointer to it.
+ */
+#if defined(CONFIG_ISP1504_MXC)
+static struct fsl_usb2_platform_data __maybe_unused dr_1504_config;
+#define PDATA (&dr_1504_config)
+#elif defined(CONFIG_ISP1301_MXC)
+static struct fsl_usb2_platform_data __maybe_unused dr_1301_config;
+#define PDATA (&dr_1301_config)
+#elif defined(CONFIG_MC13783_MXC)
+static struct fsl_usb2_platform_data __maybe_unused dr_13783_config;
+#define PDATA (&dr_13783_config)
+#endif
+
+
+/*
+ * Used to set pdata->operating_mode before registering the platform_device.
+ * If OTG is configured, the controller operates in OTG mode,
+ * otherwise it's either host or device.
+ */
+#ifdef CONFIG_USB_OTG
+#define DR_UDC_MODE	FSL_USB2_DR_OTG
+#define DR_HOST_MODE	FSL_USB2_DR_OTG
+#else
+#define DR_UDC_MODE	FSL_USB2_DR_DEVICE
+#define DR_HOST_MODE	FSL_USB2_DR_HOST
+#endif
+
+
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+static inline void dr_register_host(struct resource *r, int rs)
+{
+	PDATA->operating_mode = DR_HOST_MODE;
+	host_pdev_register(r, rs, PDATA);
+}
+#else
+static inline void dr_register_host(struct resource *r, int rs)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC
+static struct platform_device dr_udc_device;
+
+static inline void dr_register_udc(void)
+{
+	PDATA->operating_mode = DR_UDC_MODE;
+	dr_udc_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_udc_device))
+		printk(KERN_ERR "usb: can't register DR gadget\n");
+	else
+		printk(KERN_INFO "usb: DR gadget (%s) registered\n",
+		       PDATA->transceiver);
+}
+#else
+static inline void dr_register_udc(void)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_OTG
+static struct platform_device dr_otg_device;
+
+/*
+ * set the proper operating_mode and
+ * platform_data pointer, then register the
+ * device.
+ */
+static inline void dr_register_otg(void)
+{
+	PDATA->operating_mode = FSL_USB2_DR_OTG;
+	dr_otg_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_otg_device))
+		printk(KERN_ERR "usb: can't register otg device\n");
+	else
+		printk(KERN_INFO "usb: DR OTG registered\n");
+}
+#else
+static inline void dr_register_otg(void)
+{
+}
+#endif
diff --git a/arch/arm/mach-mx3/usb_dr.c b/arch/arm/mach-mx3/usb_dr.c
new file mode 100644
index 0000000..4d8cf17
--- /dev/null
+++ b/arch/arm/mach-mx3/usb_dr.c
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <asm/arch/arc_otg.h>
+#include "usb.h"
+
+/*
+ * platform data structs
+ * 	- Which one to use is determined by CONFIG options in usb.h
+ * 	- operating_mode plugged at run time
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_13783_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init,
+	.platform_uninit   = usbotg_uninit,
+	.phy_mode          = FSL_USB2_PHY_SERIAL,
+	.power_budget      = 150,		/* 150 mA max power */
+	.gpio_usb_active   = gpio_usbotg_fs_active,
+	.gpio_usb_inactive = gpio_usbotg_fs_inactive,
+	.transceiver       = "mc13783",
+};
+
+static struct fsl_usb2_platform_data __maybe_unused dr_1301_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init,
+	.platform_uninit   = usbotg_uninit,
+	.phy_mode          = FSL_USB2_PHY_SERIAL,
+	.power_budget      = 150,		/* 150 mA max power */
+	.gpio_usb_active   = gpio_usbotg_fs_active,
+	.gpio_usb_inactive = gpio_usbotg_fs_inactive,
+	.transceiver       = "isp1301",
+};
+
+static struct fsl_usb2_platform_data __maybe_unused dr_1504_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init,
+	.platform_uninit   = usbotg_uninit,
+	.phy_mode          = FSL_USB2_PHY_ULPI,
+	.power_budget      = 150,		/* 150 mA max power */
+	.gpio_usb_active   = gpio_usbotg_hs_active,
+	.gpio_usb_inactive = gpio_usbotg_hs_inactive,
+	.transceiver       = "isp1504",
+};
+
+
+/*
+ * resources
+ */
+static struct resource otg_resources[] = {
+	[0] = {
+		.start = (u32)(USB_OTGREGS_BASE),
+		.end   = (u32)(USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_USB3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+
+static u64 dr_udc_dmamask = ~(u32) 0;
+static void dr_udc_release(struct device *dev)
+{
+}
+
+static u64 dr_otg_dmamask = ~(u32) 0;
+static void dr_otg_release(struct device *dev)
+{
+}
+
+/*
+ * platform device structs
+ * 	dev.platform_data field plugged at run time
+ */
+static struct platform_device __maybe_unused dr_udc_device = {
+	.name = "fsl-usb2-udc",
+	.id   = -1,
+	.dev  = {
+		.release           = dr_udc_release,
+		.dma_mask          = &dr_udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+static struct platform_device __maybe_unused dr_otg_device = {
+	.name = "fsl-usb2-otg",
+	.id = -1,
+	.dev = {
+		.release           = dr_otg_release,
+		.dma_mask          = &dr_otg_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+static int __init usb_dr_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	dr_register_otg();
+	dr_register_host(otg_resources, ARRAY_SIZE(otg_resources));
+	dr_register_udc();
+
+	return 0;
+}
+
+module_init(usb_dr_init);
diff --git a/arch/arm/mach-mx3/usb_h1.c b/arch/arm/mach-mx3/usb_h1.c
new file mode 100644
index 0000000..42395e4
--- /dev/null
+++ b/arch/arm/mach-mx3/usb_h1.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <asm/arch/arc_otg.h>
+#include "usb.h"
+
+static struct fsl_usb2_platform_data usbh1_config = {
+	.name              = "Host 1",
+	.platform_init     = fsl_usb_host_init,
+	.platform_uninit   = fsl_usb_host_uninit,
+	.operating_mode    = FSL_USB2_MPH_HOST,
+	.phy_mode          = FSL_USB2_PHY_SERIAL,
+	.power_budget      = 150,		/* 150 mA max power */
+	.gpio_usb_active   = gpio_usbh1_active,
+	.gpio_usb_inactive = gpio_usbh1_inactive,
+	.transceiver       = "serial",
+};
+
+static struct resource usbh1_resources[] = {
+	[0] = {
+		.start = (u32) (USB_H1REGS_BASE),
+		.end   = (u32) (USB_H1REGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_USB1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static int __init usbh1_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	host_pdev_register(usbh1_resources, ARRAY_SIZE(usbh1_resources),
+			   &usbh1_config);
+	return 0;
+}
+module_init(usbh1_init);
diff --git a/arch/arm/mach-mx3/usb_h2.c b/arch/arm/mach-mx3/usb_h2.c
new file mode 100644
index 0000000..6e8d41a
--- /dev/null
+++ b/arch/arm/mach-mx3/usb_h2.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/regulator/regulator.h>
+#include <asm/arch/arc_otg.h>
+#include "usb.h"
+
+static struct fsl_usb2_platform_data usbh2_config = {
+	.name              = "Host 2",
+	.platform_init     = fsl_usb_host_init,
+	.platform_uninit   = fsl_usb_host_uninit,
+	.operating_mode    = FSL_USB2_MPH_HOST,
+	.phy_mode          = FSL_USB2_PHY_ULPI,
+	.power_budget      = 150,		/* 150 mA max power */
+	.gpio_usb_active   = gpio_usbh2_active,
+	.gpio_usb_inactive = gpio_usbh2_inactive,
+	.transceiver       = "isp1504",
+};
+
+static struct resource usbh2_resources[] = {
+	[0] = {
+		.start = (u32) (USB_H2REGS_BASE),
+		.end   = (u32) (USB_H2REGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_USB2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+void usbh2_get_xcvr_power(struct device *dev)
+{
+	struct regulator *usbh2_regux;
+
+	usbh2_regux = regulator_get(dev, "GPO1");
+	regulator_enable(usbh2_regux);
+	((struct fsl_usb2_platform_data *)dev->platform_data)->
+		xcvr_pwr->regu1 = usbh2_regux;
+
+	usbh2_regux = regulator_get(dev, "GPO3");
+	regulator_enable(usbh2_regux);
+	((struct fsl_usb2_platform_data *)dev->platform_data)->
+		xcvr_pwr->regu2 = usbh2_regux;
+}
+EXPORT_SYMBOL(usbh2_get_xcvr_power);
+
+void usbh2_put_xcvr_power(struct device *dev)
+{
+	struct regulator *usbh2_regux;
+
+	usbh2_regux = ((struct fsl_usb2_platform_data *)dev->
+			platform_data)->xcvr_pwr->regu2;
+	regulator_disable(usbh2_regux);
+	regulator_put(usbh2_regux, dev);
+
+	usbh2_regux = ((struct fsl_usb2_platform_data *)dev->
+			platform_data)->xcvr_pwr->regu1;
+	regulator_disable(usbh2_regux);
+	regulator_put(usbh2_regux, dev);
+}
+EXPORT_SYMBOL(usbh2_put_xcvr_power);
+
+
+static int __init usbh2_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	host_pdev_register(usbh2_resources, ARRAY_SIZE(usbh2_resources),
+			   &usbh2_config);
+	return 0;
+}
+module_init(usbh2_init);
-- 
1.5.4.4

