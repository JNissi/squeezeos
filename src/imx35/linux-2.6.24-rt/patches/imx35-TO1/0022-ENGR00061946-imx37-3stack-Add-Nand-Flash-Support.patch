From d8ca5d7dbc41429957d864f8bd2fdf04e4bf9d1d Mon Sep 17 00:00:00 2001
From: Kevin Zhang <akz002@freescale.com>
Date: Tue, 22 Jan 2008 15:30:14 -0600
Subject: [PATCH] ENGR00061946 imx37 3stack Add Nand Flash Support

Description:
Add NAND flash support on i.MX37 3-stack board. It uses the flash-based
bad-block table for bad block management.
---
 arch/arm/configs/imx37_3stack_defconfig |   35 ++++-
 arch/arm/mach-mx37/Kconfig              |   16 ++
 arch/arm/mach-mx37/mx37_3stack.c        |   16 ++-
 drivers/mtd/nand/mxc_nd2.c              |  214 ++++++++++++++++++++------
 drivers/mtd/nand/mxc_nd2.h              |  248 +++++++++++++++++++++++--------
 drivers/mtd/nand/nand_ids.c             |    3 +
 include/asm-arm/arch-mxc/mx37.h         |   18 +-
 7 files changed, 415 insertions(+), 135 deletions(-)

diff --git a/arch/arm/configs/imx37_3stack_defconfig b/arch/arm/configs/imx37_3stack_defconfig
index 0719508..bfa9a02 100644
--- a/arch/arm/configs/imx37_3stack_defconfig
+++ b/arch/arm/configs/imx37_3stack_defconfig
@@ -1,6 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.22
+# Thu Jan 10 14:33:39 2008
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -42,8 +43,11 @@ CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_IPC_NS is not set
 CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
 # CONFIG_UTS_NS is not set
+# CONFIG_AUDIT is not set
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
@@ -167,6 +171,8 @@ CONFIG_MXC_SDMA_API=y
 # MX37 Options
 #
 CONFIG_MACH_MX37_3DS=y
+CONFIG_ARCH_MXC_HAS_NFC_V3=y
+CONFIG_ARCH_MXC_HAS_NFC_V3_1=y
 
 #
 # Device options
@@ -242,7 +248,7 @@ CONFIG_ALIGNMENT_TRAP=y
 #
 CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw ip=off"
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw rootfstype=jffs2 ip=off"
 # CONFIG_XIP_KERNEL is not set
 # CONFIG_KEXEC is not set
 
@@ -375,7 +381,6 @@ CONFIG_FW_LOADER=m
 #
 CONFIG_CONNECTOR=y
 CONFIG_PROC_EVENTS=y
-
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
 # CONFIG_MTD_CONCAT is not set
@@ -387,10 +392,9 @@ CONFIG_MTD_CMDLINE_PARTS=y
 #
 # User Modules And Translation Layers
 #
-# CONFIG_MTD_CHAR is not set
-# CONFIG_MTD_BLKDEVS is not set
-# CONFIG_MTD_BLOCK is not set
-# CONFIG_MTD_BLOCK_RO is not set
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
 # CONFIG_FTL is not set
 # CONFIG_NFTL is not set
 # CONFIG_INFTL is not set
@@ -439,7 +443,18 @@ CONFIG_MTD_CFI_I2=y
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_NAND is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_MXC_V3=y
+# CONFIG_MTD_NAND_MXC_SWECC is not set
+# CONFIG_MTD_NAND_MXC_FORCE_CE is not set
+# CONFIG_MXC_NAND_LOW_LEVEL_ERASE is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
 # CONFIG_MTD_ONENAND is not set
 
 #
@@ -464,8 +479,10 @@ CONFIG_MTD_CFI_I2=y
 # CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
 # CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
 
 #
 # SCSI device support
@@ -500,12 +517,14 @@ CONFIG_SCSI_WAIT_SCAN=m
 #
 # CONFIG_SCSI_SPI_ATTRS is not set
 # CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
 # CONFIG_SCSI_SAS_ATTRS is not set
 # CONFIG_SCSI_SAS_LIBSAS is not set
 
 #
 # SCSI low-level drivers
 #
+# CONFIG_ISCSI_TCP is not set
 # CONFIG_SCSI_AHA152X is not set
 # CONFIG_SCSI_AIC7XXX_OLD is not set
 # CONFIG_SCSI_IN2000 is not set
@@ -764,6 +783,7 @@ CONFIG_SPI_MXC_SELECT2=y
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
 # CONFIG_DAB is not set
 
 #
@@ -891,6 +911,7 @@ CONFIG_EXT2_FS=y
 # CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
 CONFIG_INOTIFY=y
diff --git a/arch/arm/mach-mx37/Kconfig b/arch/arm/mach-mx37/Kconfig
index 1393530..9a37866 100644
--- a/arch/arm/mach-mx37/Kconfig
+++ b/arch/arm/mach-mx37/Kconfig
@@ -15,6 +15,22 @@ config MXC_SDMA_API
            This selects the Freescale MXC SDMA API.
            If unsure, say N.
 
+config ARCH_MXC_HAS_NFC_V3
+        bool "MXC NFC Hardware Version 3"
+        depends on ARCH_MX37
+        default y
+        help
+           This selects the Freescale MXC Nand Flash Controller Hardware Version 3
+           If unsure, say N.
+
+config ARCH_MXC_HAS_NFC_V3_1
+        bool "MXC NFC Hardware Version 3.1"
+        depends on ARCH_MXC_HAS_NFC_V3
+        default y
+        help
+           This selects the Freescale MXC Nand Flash Controller Hardware Version 3.1
+           If unsure, say N.
+
 menu "Device options"
 
 config I2C_MXC_SELECT1
diff --git a/arch/arm/mach-mx37/mx37_3stack.c b/arch/arm/mach-mx37/mx37_3stack.c
index 8590e20..66f9b37 100644
--- a/arch/arm/mach-mx37/mx37_3stack.c
+++ b/arch/arm/mach-mx37/mx37_3stack.c
@@ -71,9 +71,9 @@ unsigned long board_get_ckih_rate(void)
 	|| defined(CONFIG_MTD_NAND_MXC_V2) || defined(CONFIG_MTD_NAND_MXC_V2_MODULE) \
 	|| defined(CONFIG_MTD_NAND_MXC_V3)
 
-static struct mtd_partition mxc_nand_partitions[4] = {
+static struct mtd_partition mxc_nand_partitions[] = {
 	{
-	 .name = "IPL-SPL",
+	 .name = "bootloader",
 	 .offset = 0,
 	 .size = 2 * 1024 * 1024},
 	{
@@ -85,9 +85,17 @@ static struct mtd_partition mxc_nand_partitions[4] = {
 	 .offset = MTDPART_OFS_APPEND,
 	 .size = 128 * 1024 * 1024},
 	{
-	 .name = "nand.userfs",
+	 .name = "nand.userfs1",
 	 .offset = MTDPART_OFS_APPEND,
-	 .size = MTDPART_SIZ_FULL},
+	 .size = 256 * 1024 * 1024},
+	{
+	 .name = "nand.userfs2",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 512 * 1024 * 1024},
+	{
+	 .name = "nand.userfs3",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 1024 * 1024 * 1024},
 };
 
 static struct flash_platform_data mxc_nand_data = {
diff --git a/drivers/mtd/nand/mxc_nd2.c b/drivers/mtd/nand/mxc_nd2.c
index 2a2f8a4..05dfccb 100644
--- a/drivers/mtd/nand/mxc_nd2.c
+++ b/drivers/mtd/nand/mxc_nd2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -89,6 +89,25 @@ static uint8_t oob_data_2k[] = {
 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
 };
 
+static uint8_t oob_data_4k[] = {
+	0xff, 0xff, 0x85, 0x19, 0x03, 0x20, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+};
+
 static struct clk *nfc_clk;
 
 /*
@@ -108,6 +127,13 @@ static struct nand_ecclayout nand_hw_eccoob_2k = {
 	.oobfree = {{2, 4}}
 };
 
+static struct nand_ecclayout nand_hw_eccoob_4k = {
+	.eccbytes = 9,
+	.eccpos = {7, 8, 9, 10, 11, 12, 13, 14, 15},
+	.oobavail = 4,
+	.oobfree = {{2, 4}}
+};
+
 /*!
  * @defgroup NAND_MTD NAND Flash MTD Driver for MXC processors
  */
@@ -136,7 +162,7 @@ static irqreturn_t mxc_nfc_irq(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static u8 mxc_main_xfer_buf[2048] ____cacheline_aligned;
+static u8 mxc_main_xfer_buf[4096] ____cacheline_aligned;
 
 /*
  * Functions that operate on the shadow table maintained in the RAM.
@@ -206,6 +232,37 @@ static void nfc_memcpy(void *dst, const void *src, int len)
 	}
 }
 
+/*
+ * Functions to transfer data to/from spare erea.
+ */
+static void copy_spare(struct mtd_info *mtd, char *pbuf, char *pspare, int len,
+		       bool bfrom)
+{
+	u16 ooblen = mtd->oobsize;
+	u8 i, count, size;
+
+	count = mtd->writesize >> 9;
+	size = (ooblen / count >> 1) << 1;
+
+	if (bfrom) {
+		for (i = 0; i < count - 1; i++) {
+			nfc_memcpy((void *)(pbuf + i * size),
+				   (void *)(pspare + i * SPARE_LEN), size);
+		}
+
+		nfc_memcpy((void *)(pbuf + i * size),
+			   (void *)(pspare + i * SPARE_LEN), len - i * size);
+	} else {
+		for (i = 0; i < count - 1; i++) {
+			nfc_memcpy((void *)(pspare + i * SPARE_LEN),
+				   (void *)(pbuf + i * size), size);
+		}
+
+		nfc_memcpy((void *)(pspare + i * SPARE_LEN),
+			   (void *)(pbuf + i * size), len - i * size);
+	}
+}
+
 /*!
  * This function polls the NFC to wait for the basic operation to complete by
  * checking the INT bit of config2 register.
@@ -223,15 +280,16 @@ static void wait_op_done(int maxRetries, bool useirq)
 				  REG_NFC_INTRRUPT);
 			wait_event(irq_waitq,
 				   (raw_read(REG_NFC_OPS_STAT) & NFC_OPS_STAT));
-			raw_write((raw_read(REG_NFC_OPS_STAT) & ~NFC_OPS_STAT),
-				  REG_NFC_OPS_STAT);
+			WRITE_NFC_IP_REG((raw_read(REG_NFC_OPS_STAT) &
+					  ~NFC_OPS_STAT), REG_NFC_OPS_STAT);
 		}
 	} else {
 		while (1) {
 			maxRetries--;
 			if (raw_read(REG_NFC_OPS_STAT) & NFC_OPS_STAT) {
-				raw_write((raw_read(REG_NFC_OPS_STAT) &
-					   ~NFC_OPS_STAT), REG_NFC_OPS_STAT);
+				WRITE_NFC_IP_REG((raw_read(REG_NFC_OPS_STAT) &
+						  ~NFC_OPS_STAT),
+						 REG_NFC_OPS_STAT);
 				break;
 			}
 			udelay(1);
@@ -425,15 +483,17 @@ static int mxc_check_ecc_status(struct mtd_info *mtd)
 	u16 ecc_stat, err;
 	int no_subpages = 1;
 	int ret = 0;
+	u8 ecc_bit_mask, err_limit;
 
-	if (IS_2K_PAGE_NAND) {
-		no_subpages = 4;
-	}
+	ecc_bit_mask = (IS_4BIT_ECC ? 0x7 : 0xf);
+	err_limit = (IS_4BIT_ECC ? 0x4 : 0x8);
+
+	no_subpages = mtd->writesize >> 9;
 
 	ecc_stat = raw_read(REG_NFC_ECC_STATUS_RESULT);
 	do {
-		err = ecc_stat & 0x7;
-		if (err > 0x4) {
+		err = ecc_stat & ecc_bit_mask;
+		if (err > err_limit) {
 			return -1;
 		} else {
 			ret += err;
@@ -573,6 +633,8 @@ static void mxc_nand_write_buf(struct mtd_info *mtd,
 	panic("re-work needed\n");
 	if (g_nandfc_info.colAddr >= mtd->writesize || g_nandfc_info.bSpareOnly) {
 		base = (uint32_t *) SPARE_AREA0;
+		copy_spare(mtd, (char *)buf, (char *)base, len, false);
+		return;
 	} else {
 		g_nandfc_info.colAddr += len;
 		base = (uint32_t *) MAIN_AREA0;
@@ -596,6 +658,8 @@ static void mxc_nand_read_buf(struct mtd_info *mtd, u_char * buf, int len)
 
 	if (g_nandfc_info.colAddr >= mtd->writesize || g_nandfc_info.bSpareOnly) {
 		base = (uint32_t *) SPARE_AREA0;
+		copy_spare(mtd, buf, (char *)base, len, true);
+		return;
 	} else {
 		base = (uint32_t *) MAIN_AREA0;
 		g_nandfc_info.colAddr += len;
@@ -683,6 +747,9 @@ static void mxc_do_addr_cycle(struct mtd_info *mtd, int column, int page_addr)
 		if (IS_2K_PAGE_NAND) {
 			/* another col addr cycle for 2k page */
 			send_addr((column >> 8) & 0xF, false);
+		} else if (IS_4K_PAGE_NAND) {
+			/* another col addr cycle for 4k page */
+			send_addr((column >> 8) & 0x1F, false);
 		}
 	}
 	if (page_addr != -1) {
@@ -704,10 +771,11 @@ static void read_full_page(struct mtd_info *mtd, int page_addr)
 
 	mxc_do_addr_cycle(mtd, 0, page_addr);
 
-	if (IS_2K_PAGE_NAND) {
+	if (IS_LARGE_PAGE_NAND) {
 		send_cmd(NAND_CMD_READSTART, false);
-		READ_2K_PAGE;
-		mxc_swap_2k_bi_main_sp();
+		READ_PAGE();
+		if (IS_2K_PAGE_NAND)
+			mxc_swap_2k_bi_main_sp();
 	} else {
 		send_read_page(0);
 	}
@@ -787,10 +855,14 @@ static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
 			mark_oob_data_dirty(page_addr, 1);
 		} else {
 			if (is_oob_data_dirty(page_addr)) {
-				memcpy((void *)SPARE_AREA0, shadow_oob_data,
-				       mtd->oobsize);
+				copy_spare(mtd, shadow_oob_data,
+					   (char *)SPARE_AREA0, mtd->oobsize,
+					   false);
 			} else {
-				memset((void *)SPARE_AREA0, 0xFF, mtd->oobsize);
+				copy_spare(mtd,
+					   ((struct nand_chip *)(mtd->priv))->
+					   oob_poi, (char *)SPARE_AREA0,
+					   mtd->oobsize, false);
 			}
 			g_nandfc_info.bSpareOnly = false;
 			/* Set program pointer to page start */
@@ -801,8 +873,9 @@ static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
 
 	case NAND_CMD_PAGEPROG:
 		if (!g_nandfc_info.bSpareOnly) {
-			if (IS_2K_PAGE_NAND) {
-			PROG_2K_PAGE} else {
+			if (IS_LARGE_PAGE_NAND) {
+				PROG_PAGE();
+			} else {
 				send_prog_page(0);
 			}
 		} else {
@@ -812,18 +885,22 @@ static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
 
 	case NAND_CMD_ERASE1:
 		/*Decide to erase */
-		read_full_page(mtd, page_addr);
-		if (is_page_clean(mtd)) {
-			mark_oob_data_clean(page_addr);
-			skip_erase = 1;
-			return;
+		if (!IS_4K_PAGE_NAND) {
+			read_full_page(mtd, page_addr);
+			if (is_page_clean(mtd)) {
+				mark_oob_data_clean(page_addr);
+				skip_erase = 1;
+				return;
+			}
 		}
 		useirq = false;
 		break;
 	case NAND_CMD_ERASE2:
-		if (skip_erase) {
-			skip_erase = 0;
-			return;
+		if (!IS_4K_PAGE_NAND) {
+			if (skip_erase) {
+				skip_erase = 0;
+				return;
+			}
 		}
 		useirq = false;
 		break;
@@ -843,11 +920,11 @@ static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
 
 	case NAND_CMD_READOOB:
 	case NAND_CMD_READ0:
-		if (IS_2K_PAGE_NAND) {
+		if (IS_LARGE_PAGE_NAND) {
 			/* send read confirm command */
 			send_cmd(NAND_CMD_READSTART, true);
 			/* read for each AREA */
-			READ_2K_PAGE;
+			READ_PAGE();
 		} else {
 			send_read_page(0);
 		}
@@ -933,7 +1010,7 @@ static int mxc_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
 		sndcmd = 0;
 	}
 
-	nfc_memcpy((void *)chip->oob_poi, (void *)SPARE_AREA0, mtd->oobsize);
+	copy_spare(mtd, chip->oob_poi, (char *)SPARE_AREA0, mtd->oobsize, true);
 	return sndcmd;
 }
 
@@ -977,12 +1054,12 @@ static void mxc_swap_2k_bi_main_sp(void)
 {
 	u16 tmp1, tmp2, new_tmp1;
 
-	tmp1 = __raw_readw(BAD_BLK_MARKER_464);
-	tmp2 = __raw_readw(BAD_BLK_MARKER_SP_0);
+	tmp1 = __raw_readw(BAD_BLK_MARKER_MA);
+	tmp2 = __raw_readw(BAD_BLK_MARKER_SP);
 	new_tmp1 = (tmp1 & 0xFF00) | (tmp2 >> 8);
 	tmp2 = (tmp1 << 8) | (tmp2 & 0xFF);
-	__raw_writew(new_tmp1, BAD_BLK_MARKER_464);
-	__raw_writew(tmp2, BAD_BLK_MARKER_SP_0);
+	__raw_writew(new_tmp1, BAD_BLK_MARKER_MA);
+	__raw_writew(tmp2, BAD_BLK_MARKER_SP);
 
 }
 
@@ -1040,18 +1117,48 @@ static struct nand_bbt_descr largepage_memorybased = {
 	.pattern = scan_ff_pattern
 };
 
+/* Generic flash bbt decriptors
+*/
+static uint8_t bbt_pattern[] = { 'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = { '1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
 static int mxc_nand_scan_bbt(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
+	int n;
 
 	/* Do some configurations before scanning */
 	page_to_block_shift = this->phys_erase_shift - this->page_shift;
 	g_page_mask = this->pagemask;
 
 	if (IS_2K_PAGE_NAND) {
-		NFMS |= (1 << NFMS_NF_PG_SZ);
+		SET_NFMS(1 << NFMS_NF_PG_SZ);
 		this->ecc.layout = &nand_hw_eccoob_2k;
 		shadow_oob_data = oob_data_2k;
+	} else if (IS_4K_PAGE_NAND) {
+		SET_NFMS(1 << NFMS_NF_PG_SZ);
+		this->ecc.layout = &nand_hw_eccoob_4k;
+		shadow_oob_data = oob_data_4k;
 	} else {
 		this->ecc.layout = &nand_hw_eccoob_512;
 		shadow_oob_data = oob_data_512;
@@ -1059,13 +1166,27 @@ static int mxc_nand_scan_bbt(struct mtd_info *mtd)
 
 	/* propagate ecc.layout to mtd_info */
 	mtd->ecclayout = this->ecc.layout;
-
-	this->bbt_td = NULL;
-	this->bbt_md = NULL;
+	if (IS_4K_PAGE_NAND) {
+		this->bbt_td = &bbt_main_descr;
+		this->bbt_md = &bbt_mirror_descr;
+	} else {
+		this->bbt_td = NULL;
+		this->bbt_md = NULL;
+	}
 	if (!this->badblock_pattern) {
 		this->badblock_pattern = (mtd->writesize > 512) ?
 		    &largepage_memorybased : &smallpage_memorybased;
 	}
+
+	n = mtd->size >> this->phys_erase_shift;
+	/* each bit is used for one page's dirty information */
+	oob_data_shadow_p = (u8 *) kzalloc(n / 8, GFP_KERNEL);
+	if (!oob_data_shadow_p) {
+		printk(KERN_ERR "%s: failed to allocate oob_data_shadow_p\n",
+		       __FUNCTION__);
+		kfree(mxc_nand_data);
+		return -ENOMEM;
+	}
 	/* Build bad block table */
 	return nand_scan_bbt(mtd, this->badblock_pattern);
 }
@@ -1084,7 +1205,7 @@ static int __init mxcnd_probe(struct platform_device *pdev)
 	struct nand_chip *this;
 	struct mtd_info *mtd;
 	struct flash_platform_data *flash = pdev->dev.platform_data;
-	int nr_parts = 0, n, err = 0;
+	int nr_parts = 0, err = 0;
 
 	nfc_axi_base = IO_ADDRESS(NFC_AXI_BASE_ADDR);
 	nfc_ip_base = IO_ADDRESS(NFC_BASE_ADDR);
@@ -1123,11 +1244,14 @@ static int __init mxcnd_probe(struct platform_device *pdev)
 	this->read_buf = mxc_nand_read_buf;
 	this->verify_buf = mxc_nand_verify_buf;
 	this->scan_bbt = mxc_nand_scan_bbt;
+	if (IS_4K_PAGE_NAND)
+		this->options |= NAND_USE_FLASH_BBT;	/* always use flash based bbt */
+
 	/* NAND bus width determines access funtions used by upper layer */
 	if (flash->width == 2) {
 		this->read_byte = mxc_nand_read_byte16;
 		this->options |= NAND_BUSWIDTH_16;
-		NFMS |= (1 << NFMS_NF_DWIDTH);
+		SET_NFMS(1 << NFMS_NF_DWIDTH);
 	}
 
 	nfc_clk = clk_get(&pdev->dev, "nfc_clk");
@@ -1204,16 +1328,6 @@ static int __init mxcnd_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, mtd);
 
-	n = mtd->size / mtd->erasesize;
-	/* each bit is used for one page's dirty information */
-	oob_data_shadow_p = (u8 *) kzalloc(n / 8, GFP_KERNEL);
-	if (!oob_data_shadow_p) {
-		printk(KERN_ERR "%s: failed to allocate oob_data_shadow_p\n",
-		       __FUNCTION__);
-		err = -ENOMEM;
-		goto out;
-	}
-
 	/* Erase all the blocks of a NAND -- depend on the config */
 	mxc_low_erase(mtd);
 
diff --git a/drivers/mtd/nand/mxc_nd2.h b/drivers/mtd/nand/mxc_nd2.h
index 174afde..1483ae4 100644
--- a/drivers/mtd/nand/mxc_nd2.h
+++ b/drivers/mtd/nand/mxc_nd2.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -12,7 +12,7 @@
  */
 
 /*!
- * @file mxc_nd.h
+ * @file mxc_nd2.h
  *
  * @brief This file contains the NAND Flash Controller register information.
  *
@@ -25,51 +25,129 @@
 
 #include <asm/hardware.h>
 
-#define IS_2K_PAGE_NAND	  (mtd->writesize == NAND_PAGESIZE_2KB)
-#define NAND_PAGESIZE_2KB NAND_MAX_PAGESIZE
+#define IS_2K_PAGE_NAND		(mtd->writesize == NAND_PAGESIZE_2KB)
+#define IS_4K_PAGE_NAND		(mtd->writesize == NAND_PAGESIZE_4KB)
+#define NAND_PAGESIZE_2KB	2048
+#define NAND_PAGESIZE_4KB	4096
+#define IS_LARGE_PAGE_NAND	(mtd->writesize > 512)
 
 #ifdef CONFIG_ARCH_MXC_HAS_NFC_V3
 /*
  * For V3 NFC registers Definition
  */
-
 /* AXI Bus Mapped */
-#define NFC_AXI_BASE_ADDR      		NFC_BASE_ADDR_AXI
-#define NFC_FLASH_ADDR_CMD      	(nfc_axi_base + 0xE00)
-#define NFC_CONFIG1             	(nfc_axi_base + 0xE04)
-#define NFC_ECC_STATUS_RESULT   	(nfc_axi_base + 0xE08)
-#define LAUNCH_NFC              	(nfc_axi_base + 0xE0C)
+#define NFC_AXI_BASE_ADDR		NFC_BASE_ADDR_AXI
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_1
+#define MXC_INT_NANDFC			MXC_INT_EMI
+#define NFC_FLASH_ADDR_CMD		(nfc_axi_base + 0x1E00)
+#define NFC_CONFIG1			(nfc_axi_base + 0x1E04)
+#define NFC_ECC_STATUS_RESULT		(nfc_axi_base + 0x1E08)
+#define LAUNCH_NFC			(nfc_axi_base + 0x1E0c)
+#define NFC_WRPROT			(nfc_ip_base + 0x00)
+#define NFC_WRPROT_UNLOCK_BLK_ADD0	(nfc_ip_base + 0x04)
+#define NFC_WRPROT_UNLOCK_BLK_ADD1	(nfc_ip_base + 0x08)
+#define NFC_WRPROT_UNLOCK_BLK_ADD2	(nfc_ip_base + 0x0c)
+#define NFC_WRPROT_UNLOCK_BLK_ADD3	(nfc_ip_base + 0x10)
+#define NFC_CONFIG2			(nfc_ip_base + 0x14)
+#define NFC_IPC				(nfc_ip_base + 0x18)
+#define NFC_AXI_ERR_ADD			(nfc_ip_base + 0x1c)
+#else
+#define NFC_FLASH_ADDR_CMD		(nfc_axi_base + 0xE00)
+#define NFC_CONFIG1			(nfc_axi_base + 0xE04)
+#define NFC_ECC_STATUS_RESULT		(nfc_axi_base + 0xE08)
+#define LAUNCH_NFC			(nfc_axi_base + 0xE0C)
 
 /* IP Bus Mapped */
-#define NFC_WRPROT              	(nfc_ip_base + 0x00)
-#define NFC_WRPROT_UNLOCK_BLK_ADD0      (nfc_ip_base + 0x04)
-#define NFC_WRPROT_UNLOCK_BLK_ADD1      (nfc_ip_base + 0x08)
-#define NFC_WRPROT_UNLOCK_BLK_ADD2      (nfc_ip_base + 0x0C)
-#define NFC_WRPROT_UNLOCK_BLK_ADD3      (nfc_ip_base + 0x10)
-#define NFC_CONFIG2             	(nfc_ip_base + 0x14)
+#define NFC_WRPROT			(nfc_ip_base + 0x00)
+#define NFC_WRPROT_UNLOCK_BLK_ADD0	(nfc_ip_base + 0x04)
+#define NFC_WRPROT_UNLOCK_BLK_ADD1	(nfc_ip_base + 0x08)
+#define NFC_WRPROT_UNLOCK_BLK_ADD2	(nfc_ip_base + 0x0C)
+#define NFC_WRPROT_UNLOCK_BLK_ADD3	(nfc_ip_base + 0x10)
+#define NFC_CONFIG2			(nfc_ip_base + 0x14)
 #define NFC_IPC				(nfc_ip_base + 0x18)
 #define NFC_AXI_ERR_ADD			(nfc_ip_base + 0x1C)
-
+#endif
 /*!
  * Addresses for NFC RAM BUFFER Main area 0
  */
-#define MAIN_AREA0        		(volatile u16 *)IO_ADDRESS(NFC_BASE_ADDR_AXI + 0x000)
-#define MAIN_AREA1        		(volatile u16 *)IO_ADDRESS(NFC_BASE_ADDR_AXI + 0x200)
-#define MAIN_AREA2        		(volatile u16 *)IO_ADDRESS(NFC_BASE_ADDR_AXI + 0x400)
-#define MAIN_AREA3        		(volatile u16 *)IO_ADDRESS(NFC_BASE_ADDR_AXI + 0x600)
+#define MAIN_AREA0        		((volatile u16 *)(nfc_axi_base + 0x000))
+#define MAIN_AREA1        		((volatile u16 *)(nfc_axi_base + 0x200))
+#define MAIN_AREA2        		((volatile u16 *)(nfc_axi_base + 0x400))
+#define MAIN_AREA3        		((volatile u16 *)(nfc_axi_base + 0x600))
+
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_1
+#define MAIN_AREA4        		((volatile u16 *)(nfc_axi_base + 0x800))
+#define MAIN_AREA5        		((volatile u16 *)(nfc_axi_base + 0xa00))
+#define MAIN_AREA6        		((volatile u16 *)(nfc_axi_base + 0xc00))
+#define MAIN_AREA7        		((volatile u16 *)(nfc_axi_base + 0xe00))
 
 /*!
  * Addresses for NFC SPARE BUFFER Spare area 0
  */
-#define SPARE_AREA0       		(volatile u16 *)IO_ADDRESS(NFC_BASE_ADDR_AXI + 0x800)
-#define SPARE_AREA1       		(volatile u16 *)IO_ADDRESS(NFC_BASE_ADDR_AXI + 0x810)
-#define SPARE_AREA2       		(volatile u16 *)IO_ADDRESS(NFC_BASE_ADDR_AXI + 0x820)
-#define SPARE_AREA3       		(volatile u16 *)IO_ADDRESS(NFC_BASE_ADDR_AXI + 0x830)
+#define SPARE_AREA0       		((volatile u16 *)(nfc_axi_base + 0x1000))
+#define SPARE_AREA1       		((volatile u16 *)(nfc_axi_base + 0x1040))
+#define SPARE_AREA2       		((volatile u16 *)(nfc_axi_base + 0x1080))
+#define SPARE_AREA3       		((volatile u16 *)(nfc_axi_base + 0x10c0))
+#define SPARE_AREA4       		((volatile u16 *)(nfc_axi_base + 0x1100))
+#define SPARE_AREA5       		((volatile u16 *)(nfc_axi_base + 0x1140))
+#define SPARE_AREA6       		((volatile u16 *)(nfc_axi_base + 0x1180))
+#define SPARE_AREA7       		((volatile u16 *)(nfc_axi_base + 0x11c0))
+#define SPARE_LEN			64
+#define SPARE_COUNT			8
+#define SPARE_SIZE			(SPARE_LEN * SPARE_COUNT)
+#else
+#define SPARE_AREA0       		((volatile u16 *)(nfc_axi_base + 0x800))
+#define SPARE_AREA1       		((volatile u16 *)(nfc_axi_base + 0x810))
+#define SPARE_AREA2       		((volatile u16 *)(nfc_axi_base + 0x820))
+#define SPARE_AREA3       		((volatile u16 *)(nfc_axi_base + 0x830))
+#define SPARE_LEN			16
+#define SPARE_COUNT			4
+#define SPARE_SIZE			(SPARE_LEN * SPARE_COUNT)
+#endif
 
-/* read column 464-465 byte but only 464 for bad block marker */
-#define BAD_BLK_MARKER_464      IO_ADDRESS(NFC_BASE_ADDR_AXI + 0x600 + 464)
-/* read column 0-1 byte, but only 1 is used for swapped main area data */
-#define BAD_BLK_MARKER_SP_0     IO_ADDRESS(NFC_BASE_ADDR_AXI + 0x800)
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_1
+#define SPAS_MASK			0xFF00FFFF
+#define IS_4BIT_ECC			\
+	((raw_read(NFC_CONFIG2) & NFC_ECC_MODE_4) >> 6)
+/* Dummy define for compilation. Not used */
+#define BAD_BLK_MARKER_MA		0
+/* Dummy define for compilation. Not used */
+#define BAD_BLK_MARKER_SP		0
+
+#define SET_SPAS(v)			\
+	raw_write(((raw_read(NFC_CONFIG2) & SPAS_MASK) | ((v) << 16)), NFC_CONFIG2)
+
+#define SET_ECC_MODE(v ) 		 	\
+	do {					\
+		if ((v) == NFC_SPAS_218)  {	\
+			raw_write((raw_read(NFC_CONFIG2) & NFC_ECC_MODE_8) , NFC_CONFIG2);	\
+		}else{				\
+			raw_write((raw_read(NFC_CONFIG2) | NFC_ECC_MODE_4) , NFC_CONFIG2);	\
+		}				\
+	} while(0)
+
+#define WRITE_NFC_IP_REG(val,reg) 			\
+	do {	 					\
+		raw_write(NFC_IPC_CREQ, NFC_IPC);	\
+		while(!((*(volatile u32*)NFC_IPC & NFC_IPC_ACK)>>1));\
+		raw_write(val, reg);			\
+		raw_write(0, NFC_IPC);			\
+	} while(0)
+
+#define SET_NFMS(v)
+
+#else
+#define IS_4BIT_ECC			1
+#define SET_SPAS(v)
+#define SET_ECC_MODE(v)
+#define SET_NFMS(v)	\
+	raw_write((raw_read(NFMS) | (v)),NFMS)
+
+#define WRITE_NFC_IP_REG(val,reg) \
+	raw_write((raw_read(REG_NFC_OPS_STAT) & ~NFC_OPS_STAT),  REG_NFC_OPS_STAT)
+
+#endif
 
 /*!
  * Set 1 to specific operation bit, rest to 0 in LAUNCH_NFC Register for
@@ -92,26 +170,43 @@
 #define RBA_BUFFER1			(1 << 4)
 #define RBA_BUFFER2			(2 << 4)
 #define RBA_BUFFER3			(3 << 4)
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_1
+#define RBA_BUFFER4			(4 << 4)
+#define RBA_BUFFER5			(5 << 4)
+#define RBA_BUFFER6			(6 << 4)
+#define RBA_BUFFER7 			(7 << 4)
+#define RBA_RESET			~(7 << 4)
+#else
 #define RBA_RESET			~(3 << 4)
+#endif
 #define NFC_RB				(1 << 29)
 #define NFC_ECC_EN			(1 << 3)
 #define NFC_CE				(1 << 1)
-#define NFC_RST				(1 << 6)
+#define NFC_RST				(1 << 2)
 #define NFC_PPB_32			(0 << 7)
 #define NFC_PPB_64			(1 << 7)
 #define NFC_PPB_128			(2 << 7)
 #define NFC_PPB_256			(3 << 7)
 #define NFC_PPB_RESET			~(3 << 7)
-#define NFC_SP_EN			(1)
+#define NFC_SP_EN			1
 #define NFC_BLS_LOCKED			(0 << 16)
 #define NFC_BLS_LOCKED_DEFAULT		(1 << 16)
 #define NFC_BLS_UNLCOKED		(2 << 16)
 #define NFC_BLS_RESET			~(3 << 16)
-#define NFC_WPC_LOCK_TIGHT		(1)
-#define NFC_WPC_LOCK			(1  << 1)
-#define NFC_WPC_UNLOCK			(1  << 2)
+#define NFC_WPC_LOCK_TIGHT		1
+#define NFC_WPC_LOCK			(1 << 1)
+#define NFC_WPC_UNLOCK			(1 << 2)
 #define NFC_WPC_RESET			~(7)
-
+#ifdef CONFIG_ARCH_MXC_HAS_NFC_V3_1
+#define NFC_ECC_MODE_4    		(1 << 6)
+#define NFC_ECC_MODE_8			~(1 << 6)
+#define NFC_SPAS_16			16
+#define NFC_SPAS_64			64
+#define NFC_SPAS_128			128
+#define NFC_SPAS_218			218
+#define NFC_IPC_CREQ			(1 << 0)
+#define NFC_IPC_ACK			(1 << 1)
+#endif
 /* NFC Register Mapping */
 #define REG_NFC_OPS_STAT		NFC_IPC
 #define REG_NFC_INTRRUPT		NFC_CONFIG2
@@ -123,7 +218,7 @@
 #define REG_NFC_ECC_EN			NFC_CONFIG2
 #define REG_NFC_ECC_STATUS_RESULT	NFC_ECC_STATUS_RESULT
 #define REG_NFC_CE			NFC_CONFIG1
-#define REG_NFC_RST			NFC_CONFIG2
+#define REG_NFC_RST			NFC_CONFIG1
 #define REG_NFC_PPB			NFC_CONFIG2
 #define REG_NFC_SP_EN			NFC_CONFIG1
 #define REG_NFC_BLS			NFC_WRPROT
@@ -134,8 +229,8 @@
 #define REG_NFC_WPC			NFC_WRPROT
 
 /* NFC V3 Specific MACRO functions definitions */
-#define raw_write(v,a)                  __raw_writel(v,a)
-#define raw_read(a)			__raw_readl(a)
+#define raw_write(v,a)		__raw_writel(v,a)
+#define raw_read(a)		__raw_readl(a)
 
 /* Explcit ack ops status (if any), before issue of any command  */
 #define ACK_OPS         	raw_write((raw_read(REG_NFC_OPS_STAT) & ~NFC_OPS_STAT), REG_NFC_OPS_STAT);
@@ -146,16 +241,16 @@
 	val = ((raw_read(REG_NFC_SET_RBA) & RBA_RESET) | buf_id);
 
 #define UNLOCK_ADDR(start_addr,end_addr)     \
-	 raw_write(start_addr | (end_addr << NFC_UNLOCK_END_ADDR_SHIFT), REG_UNLOCK_BLK_ADD0);
+	raw_write(start_addr | (end_addr << NFC_UNLOCK_END_ADDR_SHIFT), REG_UNLOCK_BLK_ADD0);
 
 #define NFC_SET_BLS(val) ((raw_read(REG_NFC_BLS) & NFC_BLS_RESET) | val )
 #define NFC_SET_WPC(val) ((raw_read(REG_NFC_WPC) & NFC_WPC_RESET) | val )
-#define CHECK_NFC_RB     raw_read(REG_NFC_RB) & NFC_RB
+#define CHECK_NFC_RB    raw_read(REG_NFC_RB) & NFC_RB
 
-#define READ_2K_PAGE	send_read_page(0);
-#define PROG_2K_PAGE    send_prog_page(0);
+#define READ_PAGE()	send_read_page(0)
+#define PROG_PAGE() 	send_prog_page(0)
 
-#elif  CONFIG_ARCH_MXC_HAS_NFC_V2
+#elif CONFIG_ARCH_MXC_HAS_NFC_V2
 
 /*
  * For V1/V2 NFC registers Definition
@@ -195,12 +290,18 @@
 #define SPARE_AREA1       (volatile u16 *)IO_ADDRESS(NFC_BASE_ADDR + 0x810)
 #define SPARE_AREA2       (volatile u16 *)IO_ADDRESS(NFC_BASE_ADDR + 0x820)
 #define SPARE_AREA3       (volatile u16 *)IO_ADDRESS(NFC_BASE_ADDR + 0x830)
-
-/* read column 464-465 byte but only 464 for bad block marker */
-#define BAD_BLK_MARKER_464      IO_ADDRESS(NFC_BASE_ADDR + 0x600 + 464)
-/* read column 0-1 byte, but only 1 is used for swapped main area data */
-#define BAD_BLK_MARKER_SP_0     IO_ADDRESS(NFC_BASE_ADDR + 0x800)
-
+#define SPARE_LEN         16
+#define SPARE_COUNT       4
+#define SPARE_SIZE        (SPARE_LEN * SPARE_COUNT)
+
+#define IS_4BIT_ECC       1
+#define SET_SPAS(v)
+#define SET_ECC_MODE(v)
+#define SET_NFMS(v)	\
+	raw_write((raw_read(NFMS) | (v)),NFMS)
+
+#define WRITE_NFC_IP_REG(val,reg) \
+	raw_write((raw_read(REG_NFC_OPS_STAT) & ~NFC_OPS_STAT),  REG_NFC_OPS_STAT)
 /*!
  * Set INT to 0, Set 1 to specific operation bit, rest to 0 in LAUNCH_NFC Register for
  * Specific operation
@@ -224,9 +325,9 @@
 #define NFC_BLS_LOCKED			0
 #define NFC_BLS_LOCKED_DEFAULT		1
 #define NFC_BLS_UNLCOKED		2
-#define NFC_WPC_LOCK_TIGHT		(1)
-#define NFC_WPC_LOCK			(1  << 1)
-#define NFC_WPC_UNLOCK			(1  << 2)
+#define NFC_WPC_LOCK_TIGHT		1
+#define NFC_WPC_LOCK			(1 << 1)
+#define NFC_WPC_UNLOCK			(1 << 2)
 #define NFC_FLASH_ADDR_SHIFT 		0
 #define NFC_UNLOCK_END_ADDR_SHIFT	0
 
@@ -254,9 +355,11 @@
 
 #define NFC_SET_BLS(val)  		val
 
-#define UNLOCK_ADDR(start_addr,end_addr)     \
-						raw_write(start_addr,REG_START_BLKADDR);\
-						raw_write(end_addr,REG_END_BLKADDR);
+#define UNLOCK_ADDR(start_addr,end_addr)		\
+{							\
+	raw_write(start_addr,REG_START_BLKADDR);	\
+        raw_write(end_addr,REG_END_BLKADDR);		\
+}
 
 #define NFC_SET_WPC(val)                val
 
@@ -264,18 +367,33 @@
 #define ACK_OPS
 #define NFC_SET_RBA(val,buf_id)
 
-#define READ_2K_PAGE           	send_read_page(0);\
-				send_read_page(1);\
-				send_read_page(2);\
-				send_read_page(3);
+#define READ_PAGE()   \
+{                     \
+	send_read_page(0);  \
+	send_read_page(1);  \
+	send_read_page(2);  \
+	send_read_page(3);  \
+}
+
+#define PROG_PAGE()   \
+{                     \
+	send_prog_page(0);  \
+	send_prog_page(1);  \
+	send_prog_page(2);  \
+	send_prog_page(3);  \
+}
 
-#define PROG_2K_PAGE            send_prog_page(0);\
-				send_prog_page(1);\
-				send_prog_page(2);\
-				send_prog_page(3);
+#define CHECK_NFC_RB            1
 
-#define CHECK_NFC_RB                1
+#endif
 
+#ifndef BAD_BLK_MARKER_MA
+#define BAD_BLK_OFFSET_MA	(0x600 + 464)
+#define BAD_BLK_OFFSET_SP	0x800
+/* read column 464-465 byte but only 464 for bad block marker */
+#define BAD_BLK_MARKER_MA	IO_ADDRESS(NFC_BASE_ADDR_AXI + BAD_BLK_OFFSET_MA)
+/* read column 0-1 byte, but only 1 is used for swapped main area data */
+#define BAD_BLK_MARKER_SP	IO_ADDRESS(NFC_BASE_ADDR_AXI + BAD_BLK_OFFSET_SP)
 #endif
 
-#endif				/* MXCND_H */
+#endif				/* __MXC_ND2_H__ */
diff --git a/drivers/mtd/nand/nand_ids.c b/drivers/mtd/nand/nand_ids.c
index a3e3ab0..4c092b8 100644
--- a/drivers/mtd/nand/nand_ids.c
+++ b/drivers/mtd/nand/nand_ids.c
@@ -111,6 +111,9 @@ struct nand_flash_dev nand_flash_ids[] = {
 	{"NAND 2GiB 1,8V 16-bit",	0xB5, 0, 2048, 0, LP_OPTIONS16},
 	{"NAND 2GiB 3,3V 16-bit",	0xC5, 0, 2048, 0, LP_OPTIONS16},
 
+	/* 32 Gigabit ,only use 2G due to the linux mtd limitation*/
+	{"NAND 4GiB 3,3V 8-bit",	0xD7, 0, 2048, 0, LP_OPTIONS},
+
 	/*
 	 * Renesas AND 1 Gigabit. Those chips do not support extended id and
 	 * have a strange page/block layout !  The chosen minimum erasesize is
diff --git a/include/asm-arm/arch-mxc/mx37.h b/include/asm-arm/arch-mxc/mx37.h
index f0eef8d..86988c6 100644
--- a/include/asm-arm/arch-mxc/mx37.h
+++ b/include/asm-arm/arch-mxc/mx37.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -234,14 +234,14 @@
  * it returns 0xDEADBEEF
  */
 #define IO_ADDRESS(x)   \
-        (((x >= (unsigned long)(IRAM_BASE_ADDR)) && (x < (unsigned long)((IRAM_BASE_ADDR + IRAM_SIZE)))) ? IRAM_IO_ADDRESS(x):\
-        ((x >= (unsigned long)PLATFORM_BASE_ADDR) && (x < (unsigned long)(PLATFORM_BASE_ADDR + PLATFORM_SIZE))) ? PLATFORM_IO_ADDRESS(x):\
-        ((x >= (unsigned long)TZIC_BASE_ADDR) && (x < (unsigned long)(TZIC_BASE_ADDR + TZIC_SIZE))) ? TZIC_IO_ADDRESS(x):\
-        ((x >= (unsigned long)DEBUG_BASE_ADDR) && (x < (unsigned long)(DEBUG_BASE_ADDR + DEBUG_SIZE))) ? DEBUG_IO_ADDRESS(x):\
-        ((x >= (unsigned long)SPBA0_BASE_ADDR) && (x < (unsigned long)(SPBA0_BASE_ADDR + SPBA0_SIZE))) ? SPBA0_IO_ADDRESS(x):\
-        ((x >= (unsigned long)AIPS1_BASE_ADDR) && (x < (unsigned long)(AIPS1_BASE_ADDR + AIPS1_SIZE))) ? AIPS1_IO_ADDRESS(x):\
-        ((x >= (unsigned long)AIPS2_BASE_ADDR) && (x < (unsigned long)(AIPS2_BASE_ADDR + AIPS2_SIZE))) ? AIPS2_IO_ADDRESS(x):\
-        ((x >= (unsigned long)(NFC_BASE_ADDR_AXI)) && (x < (unsigned long)((NFC_BASE_ADDR_AXI + NFC_AXI_SIZE)))) ? NFC_BASE_ADDR_AXI_IO_ADDRESS(x):\
+        (((x >= (unsigned long)IRAM_BASE_ADDR) && (x < (unsigned long)IRAM_BASE_ADDR + IRAM_SIZE)) ? IRAM_IO_ADDRESS(x):\
+        ((x >= (unsigned long)PLATFORM_BASE_ADDR) && (x < (unsigned long)PLATFORM_BASE_ADDR + PLATFORM_SIZE)) ? PLATFORM_IO_ADDRESS(x):\
+        ((x >= (unsigned long)TZIC_BASE_ADDR) && (x < (unsigned long)TZIC_BASE_ADDR + TZIC_SIZE)) ? TZIC_IO_ADDRESS(x):\
+        ((x >= (unsigned long)DEBUG_BASE_ADDR) && (x < (unsigned long)DEBUG_BASE_ADDR + DEBUG_SIZE)) ? DEBUG_IO_ADDRESS(x):\
+        ((x >= (unsigned long)SPBA0_BASE_ADDR) && (x < (unsigned long)SPBA0_BASE_ADDR + SPBA0_SIZE)) ? SPBA0_IO_ADDRESS(x):\
+        ((x >= (unsigned long)AIPS1_BASE_ADDR) && (x < (unsigned long)AIPS1_BASE_ADDR + AIPS1_SIZE)) ? AIPS1_IO_ADDRESS(x):\
+        ((x >= (unsigned long)AIPS2_BASE_ADDR) && (x < (unsigned long)AIPS2_BASE_ADDR + AIPS2_SIZE)) ? AIPS2_IO_ADDRESS(x):\
+        ((x >= (unsigned long)NFC_BASE_ADDR_AXI) && (x < (unsigned long)NFC_BASE_ADDR_AXI + NFC_AXI_SIZE)) ? NFC_BASE_ADDR_AXI_IO_ADDRESS(x):\
         0xDEADBEEF)
 
 /*
-- 
1.5.4.4

