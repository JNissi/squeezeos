From 55cc84d6e8d6a3372ae651fa287358a447b59fc6 Mon Sep 17 00:00:00 2001
From: Fred Fan <r01011@freescale.com>
Date: Tue, 22 Apr 2008 14:37:45 +0800
Subject: [PATCH] ENGR00072683 Implements pseudo irqs to asynchronous events On i.MX35 3-stack

Implements pseudo irqs to asynochronous events. There are sd detection events
, headset detection and gps interrupts. All of them are supportted. But just
sd detection are testted.

Signed-off-by: Fred Fan <r01011@freescale.com>
---
 arch/arm/configs/imx35_3stack_defconfig |   11 +-
 arch/arm/mach-mx35/Kconfig              |    4 +
 arch/arm/mach-mx35/Makefile             |    2 +
 arch/arm/mach-mx35/board-mx35_3stack.h  |   26 +++
 arch/arm/mach-mx35/mx35_3stack_irq.c    |  283 +++++++++++++++++++++++++++++++
 arch/arm/plat-mxc/irq.c                 |    7 +-
 drivers/mxc/pmic/core/mcu_pmic_core.c   |   20 +--
 include/asm-arm/arch-mxc/hardware.h     |   16 ++-
 include/asm-arm/arch-mxc/mx35.h         |    1 +
 9 files changed, 346 insertions(+), 24 deletions(-)

diff --git a/arch/arm/configs/imx35_3stack_defconfig b/arch/arm/configs/imx35_3stack_defconfig
index 452d830..d860631 100644
--- a/arch/arm/configs/imx35_3stack_defconfig
+++ b/arch/arm/configs/imx35_3stack_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.24
-# Tue Apr  8 14:04:22 2008
+# Sat Apr 19 14:39:46 2008
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -34,7 +34,7 @@ CONFIG_BROKEN_ON_SMP=y
 CONFIG_LOCK_KERNEL=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
 CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_LOCALVERSION_AUTO is not set
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 CONFIG_SYSVIPC_SYSCTL=y
@@ -73,8 +73,9 @@ CONFIG_SIGNALFD=y
 CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
 CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
 # CONFIG_SLOB is not set
 CONFIG_SLABINFO=y
 CONFIG_RT_MUTEXES=y
@@ -176,6 +177,7 @@ CONFIG_ARCH_MXC_HAS_NFC_V2_1=y
 #
 # Device options
 #
+CONFIG_MXC_PSEUDO_IRQS=y
 CONFIG_ARCH_HAS_EVTMON=y
 CONFIG_DMA_ZONE_SIZE=24
 
@@ -1219,6 +1221,7 @@ CONFIG_ENABLE_MUST_CHECK=y
 # CONFIG_DEBUG_FS is not set
 # CONFIG_HEADERS_CHECK is not set
 # CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SLUB_DEBUG_ON is not set
 # CONFIG_DEBUG_BUGVERBOSE is not set
 CONFIG_FRAME_POINTER=y
 # CONFIG_SAMPLES is not set
diff --git a/arch/arm/mach-mx35/Kconfig b/arch/arm/mach-mx35/Kconfig
index 9373ae5..698a014 100644
--- a/arch/arm/mach-mx35/Kconfig
+++ b/arch/arm/mach-mx35/Kconfig
@@ -4,6 +4,7 @@ menu "MX35 Options"
 config MACH_MX35_3DS
 	bool "Support MX35 3STACK platforms"
 	default y
+	select MXC_PSEUDO_IRQS if MXC_PMIC 
 	help
 	  Include support for MX35 3STACK platform. This includes specific
 	  configurations for the board and its peripherals.
@@ -70,4 +71,7 @@ config I2C_MXC_SELECT3
 
 endmenu
 
+config MXC_PSEUDO_IRQS
+	bool 
+ 
 endmenu
diff --git a/arch/arm/mach-mx35/Makefile b/arch/arm/mach-mx35/Makefile
index 060ab4d..7aaea5b 100644
--- a/arch/arm/mach-mx35/Makefile
+++ b/arch/arm/mach-mx35/Makefile
@@ -8,3 +8,5 @@ obj-y		:= system.o iomux.o cpu.o mm.o clock.o devices.o serial.o
 obj-$(CONFIG_MXC_SDMA_API) 	+= dma.o
 obj-$(CONFIG_MACH_MX35_3DS)	+= mx35_3stack.o mx35_3stack_gpio.o mx35_3stack_cpld.o
 obj-$(CONFIG_MACH_MX35EVB)	+= mx35evb.o mx35evb_cpld.o mx35evb_gpio.o
+
+obj-$(CONFIG_MXC_PSEUDO_IRQS)	+= mx35_3stack_irq.o
diff --git a/arch/arm/mach-mx35/board-mx35_3stack.h b/arch/arm/mach-mx35/board-mx35_3stack.h
index ececa51..b2b5285 100644
--- a/arch/arm/mach-mx35/board-mx35_3stack.h
+++ b/arch/arm/mach-mx35/board-mx35_3stack.h
@@ -83,6 +83,32 @@
 #define MXC_LL_UART_PADDR	UART1_BASE_ADDR
 #define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
 
+#define MXC_PSEUDO_PARENT	MXC_INT_RESV0
+
+enum {
+	MCU_INT_HEADPHONE = 0,
+	MCU_INT_GPS,
+	MCU_INT_SD1_CD,
+	MCU_INT_SD1_WP,
+	MCU_INT_SD2_CD,
+	MCU_INT_SD2_WP,
+	MCU_INT_POWER_KEY,
+	MCU_INT_KEYPAD,
+	MCU_INT_RTC,
+	MCU_INT_TS_ADC,
+};
+
+#define MXC_PSEUDO_IRQ_HEADPHONE	(MXC_PSEUDO_IO_BASE + MCU_INT_HEADPHONE)
+#define MXC_PSEUDO_IRQ_GPS	(MXC_PSEUDO_IO_BASE + MCU_INT_GPS)
+#define MXC_PSEUDO_IRQ_SD1_CD	(MXC_PSEUDO_IO_BASE + MCU_INT_SD1_CD)
+#define MXC_PSEUDO_IRQ_SD1_WP	(MXC_PSEUDO_IO_BASE + MCU_INT_SD1_WP)
+#define MXC_PSEUDO_IRQ_SD2_CD	(MXC_PSEUDO_IO_BASE + MCU_INT_SD2_CD)
+#define MXC_PSEUDO_IRQ_SD2_WP	(MXC_PSEUDO_IO_BASE + MCU_INT_SD2_WP)
+#define MXC_PSEUDO_IRQ_POWER_KEY	(MXC_PSEUDO_IO_BASE + MCU_INT_POWER_KEY)
+#define MXC_PSEUDO_IRQ_KEYPAD	(MXC_PSEUDO_IO_BASE + MCU_INT_KEYPAD)
+#define MXC_PSEUDO_IRQ_RTC	(MXC_PSEUDO_IO_BASE + MCU_INT_RTC)
+#define MXC_PSEUDO_IRQ_TS_ADC	(MXC_PSEUDO_IO_BASE + MCU_INT_TS_ADC)
+
 /*!
  * @name debug board parameters
  */
diff --git a/arch/arm/mach-mx35/mx35_3stack_irq.c b/arch/arm/mach-mx35/mx35_3stack_irq.c
new file mode 100644
index 0000000..ba608a7
--- /dev/null
+++ b/arch/arm/mach-mx35/mx35_3stack_irq.c
@@ -0,0 +1,283 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/bitops.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/gpio.h>
+#include <asm/arch/pmic_external.h>
+
+#include "board-mx35_3stack.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx35/mx35_3stack_irq.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX35
+ */
+#ifdef CONFIG_MXC_PSEUDO_IRQS
+
+/*
+ * The interrupt status and mask variables.
+ */
+static unsigned long pseudo_irq_pending;
+static unsigned long pseudo_irq_enable;
+static atomic_t pseudo_irq_state = ATOMIC_INIT(0);
+
+/*
+ * The declaration of handler of two work queue.
+ * The one is the work queue to indentify the events from MCU.
+ * The another is the work queue to change the events mask.
+ */
+static void mcu_event_handler(struct work_struct *work);
+static void mcu_state_handler(struct work_struct *work);
+
+/*!
+ * The work structure for mcu events.
+ */
+static DECLARE_WORK(mcu_event_ws, mcu_event_handler);
+static DECLARE_WORK(mcu_state_ws, mcu_state_handler);
+
+static inline void mxc_pseudo_irq_ack(void)
+{
+	disable_irq(MXC_PSEUDO_PARENT);
+	atomic_set(&pseudo_irq_state, 0);
+}
+
+static inline void mxc_pseudo_irq_trigger(void)
+{
+	if (!atomic_xchg(&pseudo_irq_state, 1))
+		enable_irq(MXC_PSEUDO_PARENT);
+}
+
+/*
+ * mask a pseudo interrupt by setting the bit in the mask variable.
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_mask_irq(u32 irq)
+{
+	int index = irq - MXC_PSEUDO_IO_BASE;
+	clear_bit(index, &pseudo_irq_enable);
+}
+
+/*
+ * disable a pseudo interrupt by triggerring a work queue
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_disable_irq(u32 irq)
+{
+	struct irq_desc *desc = irq_desc + irq;
+	desc->chip->mask(irq);
+	desc->status |= IRQ_MASKED;
+	schedule_work(&mcu_state_ws);
+}
+
+/*
+ * Acknowledge a pseudo interrupt by clearing the bit in the isr variable.
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_ack_irq(u32 irq)
+{
+	int index = irq - MXC_PSEUDO_IO_BASE;
+	/* clear the interrupt status */
+	clear_bit(index, &pseudo_irq_pending);
+}
+
+/*
+ * unmask a pseudo interrupt by clearing the bit in the imr.
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_unmask_irq(u32 irq)
+{
+	int index = irq - MXC_PSEUDO_IO_BASE;
+
+	set_bit(index, &pseudo_irq_enable);
+
+	if (test_bit(index, &pseudo_irq_pending))
+		mxc_pseudo_irq_trigger();
+}
+
+/*
+ * Enable a pseudo interrupt by triggerring a work queue
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_enable_irq(u32 irq)
+{
+	struct irq_desc *desc = irq_desc + irq;
+	desc->chip->unmask(irq);
+	desc->status &= ~IRQ_MASKED;
+	schedule_work(&mcu_state_ws);
+}
+
+static struct irq_chip pseudo_irq_chip = {
+	.ack = pseudo_ack_irq,
+	.mask = pseudo_mask_irq,
+	.disable = pseudo_disable_irq,
+	.unmask = pseudo_unmask_irq,
+	.enable = pseudo_enable_irq,
+};
+
+static void mxc_pseudo_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 pseudo_irq;
+	u32 index, mask;
+
+	desc->chip->mask(irq);
+	mxc_pseudo_irq_ack();
+
+	mask = pseudo_irq_enable;
+	index = pseudo_irq_pending;
+
+	if (unlikely(!(index & mask))) {
+		printk(KERN_ERR "\nPseudo IRQ: Spurious interrupt:0x%0x\n\n",
+		       index);
+		pr_info("IEN=0x%x, PENDING=0x%x\n", mask, index);
+		return;
+	}
+
+	index = index & mask;
+	pseudo_irq = MXC_PSEUDO_IO_BASE;
+	for (; index != 0; index >>= 1, pseudo_irq++) {
+		struct irq_desc *d;
+		if ((index & 1) == 0)
+			continue;
+		d = irq_desc + pseudo_irq;
+		if (unlikely(!(d->handle_irq))) {
+			printk(KERN_ERR "\nPseudo irq: %d unhandeled\n",
+			       pseudo_irq);
+			BUG();	/* oops */
+		}
+		d->handle_irq(pseudo_irq, d);
+		d->chip->ack(pseudo_irq);
+	}
+}
+
+/*!
+ * This function is called when mcu interrupt occurs on the processor.
+ * It is the interrupt handler for the mcu.
+ *
+ * @param        irq        the irq number
+ * @param        dev_id     the pointer on the device
+ *
+ * @return       The function returns IRQ_HANDLED when handled.
+ */
+static irqreturn_t mcu_irq_handler(int irq, void *dev_id)
+{
+	schedule_work(&mcu_event_ws);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is the work handler of mcu interrupt.
+ * It reads the events status and trigger the pseudo irq.
+ */
+static void mcu_event_handler(struct work_struct *work)
+{
+	int i, err;
+	unsigned int flag1, flag2;
+
+	/* read int flags and ack int */
+	for (i = 0; i < 3; i++) {
+		err = pmic_read_reg(REG_MCU_INT_FLAG_1, &flag1, 0xFFFFFFFF);
+		err |= pmic_read_reg(REG_MCU_INT_FLAG_2, &flag2, 0xFFFFFFFF);
+		err |= pmic_write_reg(REG_MCU_INT_FLAG_1, 0, 0xFFFFFFFF);
+		err |= pmic_write_reg(REG_MCU_INT_FLAG_2, 0, 0xFFFFFFFF);
+		if (err == PMIC_SUCCESS)
+			break;
+	}
+
+	if (i >= 3) {
+		printk(KERN_ERR "Reads MCU event fail\n");
+		goto no_new_events;
+	}
+
+	for (i = 0; flag1 && (i < MCU_INT_KEYPAD); i++, flag1 >>= 1)
+		if (flag1 & 1)
+			set_bit(i, &pseudo_irq_pending);
+
+	for (i = MCU_INT_KEYPAD; flag2 && (i <= MCU_INT_TS_ADC);
+	     i++, flag2 >>= 1)
+		if (flag2 & 1)
+			set_bit(i, &pseudo_irq_pending);
+      no_new_events:
+	if (pseudo_irq_pending & pseudo_irq_enable)
+		mxc_pseudo_irq_trigger();
+}
+
+static void mcu_state_handler(struct work_struct *work)
+{
+	int err, i;
+	unsigned int event1, event2;
+	event1 = pseudo_irq_enable & ((1 << MCU_INT_KEYPAD) - 1);
+	event2 = pseudo_irq_enable >> (MCU_INT_KEYPAD - 1);
+
+	for (i = 0; i < 3; i++) {
+		err = pmic_write_reg(REG_MCU_INT_ENABLE_1, event1, event1);
+		err |= pmic_write_reg(REG_MCU_INT_ENABLE_2, event2, event2);
+		if (err == PMIC_SUCCESS)
+			break;
+	}
+	if (i >= 3)
+		printk(KERN_ERR "Change MCU event mask fail\n");
+}
+
+static int __init mxc_pseudo_init(void)
+{
+	int i;
+
+	/* disable the interrupt and clear the status */
+	pseudo_irq_pending = 0;
+	pseudo_irq_enable = 0;
+
+	pr_info("3-Stack Pseudo interrupt rev=0.1v\n");
+
+	for (i = MXC_PSEUDO_IO_BASE;
+	     i < (MXC_PSEUDO_IO_BASE + MXC_MAX_PSEUDO_IO_LINES); i++) {
+		set_irq_chip(i, &pseudo_irq_chip);
+		set_irq_handler(i, handle_simple_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+
+	set_irq_flags(MXC_PSEUDO_PARENT, IRQF_NOAUTOEN);
+	set_irq_handler(MXC_PSEUDO_PARENT, mxc_pseudo_irq_handler);
+
+	/* Set and install PMIC IRQ handler */
+	mxc_request_iomux(MX35_PIN_GPIO1_0, MUX_CONFIG_FUNC);
+	mxc_iomux_set_pad(MX35_PIN_GPIO1_0, PAD_CTL_PKE_NONE);
+	mxc_set_gpio_direction(MX35_PIN_GPIO1_0, 1);
+
+	set_irq_type(IOMUX_TO_IRQ(MX35_PIN_GPIO1_0), IRQT_RISING);
+	if (request_irq(IOMUX_TO_IRQ(MX35_PIN_GPIO1_0), mcu_irq_handler,
+			0, "MCU_IRQ", 0)) {
+		printk(KERN_ERR "mcu request irq failed\n");
+		return -1;
+	}
+	return 0;
+}
+
+fs_initcall_sync(mxc_pseudo_init);
+#endif				/* CONFIG_MXC_PSEUDO_IRQS */
diff --git a/arch/arm/plat-mxc/irq.c b/arch/arm/plat-mxc/irq.c
index 04680d8..b04877b 100644
--- a/arch/arm/plat-mxc/irq.c
+++ b/arch/arm/plat-mxc/irq.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -371,6 +371,11 @@ void __init mxc_init_irq(void)
 	reg |= (0xF << 28);
 	__raw_writel(reg, AVIC_NIPRIORITY6);
 
+	if (MXC_INT_FORCE >= 32)
+		__raw_writel(1 << (MXC_INT_FORCE & 31), AVIC_INTFRCH);
+	else if (MXC_INT_FORCE >= 0)
+		__raw_writel(1 << MXC_INT_FORCE, AVIC_INTFRCL);
+
 	printk(KERN_INFO "MXC IRQ initialized\n");
 }
 
diff --git a/drivers/mxc/pmic/core/mcu_pmic_core.c b/drivers/mxc/pmic/core/mcu_pmic_core.c
index 688f7b3..7c7d698 100644
--- a/drivers/mxc/pmic/core/mcu_pmic_core.c
+++ b/drivers/mxc/pmic/core/mcu_pmic_core.c
@@ -143,7 +143,7 @@ int pmic_read(int reg_num, unsigned int *reg_val)
 
 	return 0;
 
-error1:
+      error1:
 	return -1;
 }
 
@@ -174,7 +174,7 @@ int pmic_write(int reg_num, const unsigned int reg_val)
 
 	return 0;
 
-error1:
+      error1:
 	DPRINTK(" reg_num = %d, write failed", reg_num);
 	return -1;
 
@@ -506,30 +506,16 @@ static int __init mcu_pmic_init(void)
 	pmic_event_list_init();
 
 	/* Set and install PMIC IRQ handler */
-	mxc_request_iomux(MX35_PIN_GPIO1_0, OUTPUTCONFIG_GPIO,
-			  INPUTCONFIG_GPIO);
-	mxc_iomux_set_pad(MX35_PIN_GPIO1_0, PAD_CTL_PKE_NONE);
-	mxc_set_gpio_direction(MX35_PIN_GPIO1_0, 1);	/* input */
-
-	err = set_irq_type(IOMUX_TO_IRQ(MX35_PIN_GPIO1_0), IRQT_RISING);
-	err = request_irq(IOMUX_TO_IRQ(MX35_PIN_GPIO1_0), pmic_irq_handler,
-			  0, "PMIC_IRQ", 0);
-	if (err) {
-		DPRINTK("mcu pmic request irq failed");
-		goto fail1;
-	}
-
 	pmic_pdev_register();
 
 	return 0;
 
-fail1:
+      fail1:
 	return err;
 }
 
 static void __exit mcu_pmic_exit(void)
 {
-	free_irq(IOMUX_TO_IRQ(MX35_PIN_GPIO1_1), 0);
 	pmic_pdev_unregister();
 }
 
diff --git a/include/asm-arm/arch-mxc/hardware.h b/include/asm-arm/arch-mxc/hardware.h
index 043fa4d..6645ff8 100644
--- a/include/asm-arm/arch-mxc/hardware.h
+++ b/include/asm-arm/arch-mxc/hardware.h
@@ -128,8 +128,20 @@ MXC_REV(cpu_is_mx37);
 #define MXC_EXP_IO_BASE		(MXC_MAX_INT_LINES + MXC_MAX_GPIO_LINES)
 #define MXC_MAX_EXP_IO_LINES	16
 
+#ifdef CONFIG_MXC_PSEUDO_IRQS
+#define MXC_PSEUDO_IO_BASE	(MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES)
+#define MXC_MAX_PSEUDO_IO_LINES 16
+#else
+#define MXC_MAX_PSEUDO_IO_LINES 0
+#endif
+
+#ifndef MXC_INT_FORCE
+#define MXC_INT_FORCE	-1
+#endif
+
 #define MXC_MAX_INTS            (MXC_MAX_INT_LINES + \
-                                MXC_MAX_GPIO_LINES + \
-                                MXC_MAX_EXP_IO_LINES)
+				MXC_MAX_GPIO_LINES + \
+				MXC_MAX_EXP_IO_LINES + \
+				MXC_MAX_PSEUDO_IO_LINES)
 
 #endif				/* __ASM_ARCH_MXC_HARDWARE_H__ */
diff --git a/include/asm-arm/arch-mxc/mx35.h b/include/asm-arm/arch-mxc/mx35.h
index 5f56030..e0c3e3d 100644
--- a/include/asm-arm/arch-mxc/mx35.h
+++ b/include/asm-arm/arch-mxc/mx35.h
@@ -400,6 +400,7 @@
 
 #define MXC_MAX_INT_LINES       	64
 
+#define MXC_INT_FORCE			MXC_INT_RESV0
 /*!
  * Interrupt Number for ARM11 PMU
  */
-- 
1.5.4.4

