From 49cbd1b2ead8413284d91d09a9529ee1ddf10786 Mon Sep 17 00:00:00 2001
From: Yves vandervennet <r55763@freescale.com>
Date: Mon, 7 Jul 2008 10:21:48 -0500
Subject: [PATCH] ENGR00083174 Fix LCD flickering that happens when MMC driver disabled

The IPU driver assumes that the IPU is not enabled when the IPU probe function
is called. This assumption is broken by redboot, that for some reasons (not
sure yet why) enables the Display Interface (DI bit of IPU CONF register on
0x53FC0000).
So, the clock use count for the IPU is <= 1 (it should be 2 when the DI is
enabled as a count value of 1 reflects that the IPU is enabled, not its
sub-systems).

When the idle thread is executed and the jtag command line option is set to
off, the EMI clock is turned off if no other master is enabled. See the file
arch/arm/mach-mx3/system.c.

 For the IPU, the condition is clock count <= 1

====>>>> the clock use count being wrong, the EMI clock is turned off, leading
to LCD image unstability.

Why the problem does not happen when USB OTG and MMC are enabled ?

   + USB OTG enabled implies its clock use count is > 0

===>> the EMI clock can not be turned off

   + MMC enabled implies SDMA use count > 0

===>> the EMI clock can not be turned off

The patch enclosed fixes the problem. The IPU CONF register is reset by the IPU
probe function. As such, whatever the bootloader does, the IPU is reset to the
right state.

Note that the problem happens with the latest revision of redboot (mine is
200824). Previous versions "affected" as well.

Signed-off-by: Yves vandervennet <r55763@freescale.com>
---
 drivers/mxc/ipu/ipu_common.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/drivers/mxc/ipu/ipu_common.c b/drivers/mxc/ipu/ipu_common.c
index 00ff5bc..3b1f696 100644
--- a/drivers/mxc/ipu/ipu_common.c
+++ b/drivers/mxc/ipu/ipu_common.c
@@ -99,6 +99,9 @@ int ipu_probe(struct platform_device *pdev)
 	g_ipu_dev = &pdev->dev;
 	g_ipu_hw_rev = ipu_conf->rev;
 
+	/* resetting the CONF register of the IPU */
+	__raw_writel(0x00000000, IPU_CONF);
+
 	/* Register IPU interrupts */
 	g_ipu_irq[0] = platform_get_irq(pdev, 0);
 	if (g_ipu_irq[0] < 0)
-- 
1.5.4.4

