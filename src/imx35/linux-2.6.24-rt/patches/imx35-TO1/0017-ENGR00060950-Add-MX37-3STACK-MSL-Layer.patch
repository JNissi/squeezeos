From 063e5dbfccaafc4ed03bc595ac3693cc91798e32 Mon Sep 17 00:00:00 2001
From: Mahesh Mahadevan <mmahesh@freescale.com>
Date: Fri, 8 Feb 2008 07:51:07 -0600
Subject: [PATCH] ENGR00060950 Add MX37 3STACK MSL Layer

Add initial support for the MX37 3-stack board
---
 arch/arm/Makefile                         |    1 +
 arch/arm/configs/imx37_3stack_defconfig   |  871 +++++++++++++++++++++++++++++
 arch/arm/mach-mx3/mx3_3stack.c            |    6 +-
 arch/arm/mach-mx37/Kconfig                |   44 ++
 arch/arm/mach-mx37/Makefile               |    9 +
 arch/arm/mach-mx37/Makefile.boot          |    3 +
 arch/arm/mach-mx37/board-mx37_3stack.h    |  105 ++++
 arch/arm/mach-mx37/clock.c                |  726 ++++++++++++++++++++++++
 arch/arm/mach-mx37/cpu.c                  |   75 +++
 arch/arm/mach-mx37/crm_regs.h             |  633 +++++++++++++++++++++
 arch/arm/mach-mx37/devices.c              |  608 ++++++++++++++++++++
 arch/arm/mach-mx37/dma.c                  |  561 +++++++++++++++++++
 arch/arm/mach-mx37/iomux.c                |  204 +++++++
 arch/arm/mach-mx37/iomux.h                |  224 ++++++++
 arch/arm/mach-mx37/mm.c                   |   82 +++
 arch/arm/mach-mx37/mx37_3stack.c          |  209 +++++++
 arch/arm/mach-mx37/mx37_3stack_gpio.c     |  451 +++++++++++++++
 arch/arm/mach-mx37/sdma_script_code.h     |  190 +++++++
 arch/arm/mach-mx37/serial.c               |  169 ++++++
 arch/arm/mach-mx37/serial.h               |  126 +++++
 arch/arm/mach-mx37/system.c               |   55 ++
 arch/arm/plat-mxc/Kconfig                 |   16 +
 arch/arm/plat-mxc/Makefile                |    4 +
 arch/arm/plat-mxc/sdma/iapi/include/epm.h |    2 +-
 arch/arm/plat-mxc/tzic.c                  |  150 +++++
 arch/arm/tools/mach-types                 |    1 +
 drivers/char/Kconfig                      |    3 +
 drivers/ide/Kconfig                       |    2 +-
 drivers/spi/Kconfig                       |    2 +-
 include/asm-arm/arch-mxc/hardware.h       |   10 +-
 include/asm-arm/arch-mxc/memory.h         |    4 +
 include/asm-arm/arch-mxc/mx37.h           |  445 +++++++++++++++
 include/asm-arm/arch-mxc/mx37_pins.h      |  266 +++++++++
 include/asm-arm/arch-mxc/mxc.h            |   28 -
 34 files changed, 6250 insertions(+), 35 deletions(-)

diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index fb6fb11..b8f1b14 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -139,6 +139,7 @@ endif
  machine-$(CONFIG_ARCH_KS8695)     := ks8695
   incdir-$(CONFIG_ARCH_MXC)	   := mxc
  machine-$(CONFIG_ARCH_MX3)	   := mx3
+ machine-$(CONFIG_ARCH_MX37)	   := mx37
  machine-$(CONFIG_ARCH_MX27)	   := mx27
  machine-$(CONFIG_ARCH_MX21)	   := mx21
  machine-$(CONFIG_ARCH_MXC91331)   := mxc91321
diff --git a/arch/arm/configs/imx37_3stack_defconfig b/arch/arm/configs/imx37_3stack_defconfig
new file mode 100644
index 0000000..dadc5fd
--- /dev/null
+++ b/arch/arm/configs/imx37_3stack_defconfig
@@ -0,0 +1,871 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.22
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_UTS_NS is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# Freescale MXC Implementations
+#
+# CONFIG_ARCH_MXC91321 is not set
+# CONFIG_ARCH_MXC92323 is not set
+# CONFIG_ARCH_MXC91311 is not set
+# CONFIG_ARCH_MXC91231 is not set
+# CONFIG_ARCH_MXC91221 is not set
+# CONFIG_ARCH_MXC91131 is not set
+CONFIG_ARCH_MX37=y
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_ARCH_MX27 is not set
+# CONFIG_ARCH_MX21 is not set
+CONFIG_MXC_SDMA_API=y
+
+#
+# MX37 Options
+#
+CONFIG_MACH_MX37_3DS=y
+
+#
+# Device options
+#
+CONFIG_MXC_TZIC=y
+CONFIG_ARCH_HAS_EVTMON=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+# CONFIG_CPU_ARM926T is not set
+CONFIG_CPU_V6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_CACHE_L2X0=y
+
+#
+# Bus support
+#
+CONFIG_ISA=y
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw ip=off"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+# CONFIG_MTD_CHAR is not set
+# CONFIG_MTD_BLKDEVS is not set
+# CONFIG_MTD_BLOCK is not set
+# CONFIG_MTD_BLOCK_RO is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+# CONFIG_MTD_MXC is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+# CONFIG_PNPACPI is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# ISDN subsystem
+#
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_UCB1400 is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXC=y
+CONFIG_SERIAL_MXC_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_NVRAM is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_MXC=y
+# CONFIG_SPI_MXC_TEST_LOOPBACK is not set
+# CONFIG_SPI_MXC_SELECT1 is not set
+CONFIG_SPI_MXC_SELECT2=y
+# CONFIG_SPI_MXC_SELECT3 is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_SPIDEV is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+# CONFIG_HWMON is not set
+
+#
+# Misc devices
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# HID Devices
+#
+CONFIG_HID=m
+# CONFIG_HID_DEBUG is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# On-The-Go and USB Peripheral Support
+#
+# CONFIG_OTG is not set
+
+#
+# 
+#
+
+#
+# 
+#
+# CONFIG_MMC is not set
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# MXC support drivers
+#
+
+#
+# MXC IPU
+#
+# CONFIG_MXC_IPU is not set
+
+#
+# MXC SSI support
+#
+# CONFIG_MXC_SSI is not set
+
+#
+# MXC Digital Audio Multiplexer support
+#
+# CONFIG_MXC_DAM is not set
+
+#
+# MXC PMIC support
+#
+# CONFIG_MXC_SPI_PMIC_CORE is not set
+# CONFIG_MXC_PMIC is not set
+
+#
+# Advanced Power Management devices
+#
+
+#
+# MXC Security Drivers
+#
+# CONFIG_MXC_SECURITY_SCC is not set
+# CONFIG_MXC_SECURITY_RNG is not set
+# CONFIG_MXC_SECURITY_RTIC is not set
+
+#
+# MXC MPEG4 Encoder Kernel module support
+#
+# CONFIG_MXC_HMP4E is not set
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# CodeTEST setup
+#
+# CONFIG_CODETEST is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/mach-mx3/mx3_3stack.c b/arch/arm/mach-mx3/mx3_3stack.c
index 47c9967..274fbfa 100644
--- a/arch/arm/mach-mx3/mx3_3stack.c
+++ b/arch/arm/mach-mx3/mx3_3stack.c
@@ -85,8 +85,8 @@ static u16 keymapping[12] = {
 
 static struct resource mxc_kpp_resources[] = {
 	[0] = {
-	       .start = INT_KPP,
-	       .end = INT_KPP,
+	       .start = MXC_INT_KPP,
+	       .end = MXC_INT_KPP,
 	       .flags = IORESOURCE_IRQ,
 	       }
 };
@@ -94,7 +94,7 @@ static struct resource mxc_kpp_resources[] = {
 static struct keypad_data keypad_plat_data = {
 	.rowmax = 3,
 	.colmax = 4,
-	.irq = INT_KPP,
+	.irq = MXC_INT_KPP,
 	.learning = 0,
 	.delay = 2,
 	.matrix = keymapping,
diff --git a/arch/arm/mach-mx37/Kconfig b/arch/arm/mach-mx37/Kconfig
new file mode 100644
index 0000000..1393530
--- /dev/null
+++ b/arch/arm/mach-mx37/Kconfig
@@ -0,0 +1,44 @@
+menu "MX37 Options"
+	depends on ARCH_MX37
+
+config MACH_MX37_3DS
+	bool "Support MX37 3-Stack platforms"
+	default y
+	help
+	  Include support for MX37 3-Stack platform. This includes specific
+	  configurations for the board and its peripherals.
+
+config MXC_SDMA_API
+        bool "Use SDMA API"
+        default y
+        help
+           This selects the Freescale MXC SDMA API.
+           If unsure, say N.
+
+menu "Device options"
+
+config I2C_MXC_SELECT1
+	bool "Enable I2C1 module"
+	default y
+	depends on I2C_MXC
+	help
+	  Enable MX37 I2C1 module.
+
+config I2C_MXC_SELECT2
+	bool "Enable I2C2 module"
+	default n
+	depends on I2C_MXC
+	help
+	  Enable MX37 I2C2 module.
+
+config I2C_MXC_SELECT3
+	bool "Enable I2C3 module"
+	default n
+	depends on I2C_MXC
+	help
+	  Enable MX37 I2C3 module.
+
+endmenu
+
+endmenu
+
diff --git a/arch/arm/mach-mx37/Makefile b/arch/arm/mach-mx37/Makefile
new file mode 100644
index 0000000..6af6dc3
--- /dev/null
+++ b/arch/arm/mach-mx37/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y			:= system.o iomux.o cpu.o mm.o clock.o devices.o serial.o dma.o
+
+obj-$(CONFIG_MACH_MX37_3DS)	+= mx37_3stack.o mx37_3stack_gpio.o
diff --git a/arch/arm/mach-mx37/Makefile.boot b/arch/arm/mach-mx37/Makefile.boot
new file mode 100644
index 0000000..1568ad4
--- /dev/null
+++ b/arch/arm/mach-mx37/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x40008000
+params_phys-y	:= 0x40000100
+initrd_phys-y	:= 0x40800000
diff --git a/arch/arm/mach-mx37/board-mx37_3stack.h b/arch/arm/mach-mx37/board-mx37_3stack.h
new file mode 100644
index 0000000..7ca4b7b
--- /dev/null
+++ b/arch/arm/mach-mx37/board-mx37_3stack.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX37_3STACK_H__
+#define __ASM_ARCH_MXC_BOARD_MX37_3STACK_H__
+
+/*!
+ * @defgroup BRDCFG_MX37 Board Configuration Options
+ * @ingroup MSL_MX37
+ */
+
+/*!
+ * @file mach-mx37/board-mx37_3stack.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX31 ADS Platform.
+ *
+ * @ingroup BRDCFG_MX37
+ */
+
+/*
+ * Include Files
+ */
+#include <asm/arch/mxc_uart.h>
+
+/*!
+ * @name MXC UART EVB board level configurations
+ */
+/*! @{ */
+/*!
+ * Specifies if the Irda transmit path is inverting
+ */
+#define MXC_IRDA_TX_INV         0
+/*!
+ * Specifies if the Irda receive path is inverting
+ */
+#define MXC_IRDA_RX_INV         0
+
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE              MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR                NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED           1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE              MODE_DCE
+#define UART2_IR                IRDA
+#define UART2_ENABLED           1
+/* UART 3 configuration */
+#define UART3_MODE              MODE_DTE
+#define UART3_IR                NO_IRDA
+#define UART3_ENABLED           1
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+#define DEBUG_BASE_ADDRESS	0x78000000	/* Use a Dummy base address */
+/* LAN9217 ethernet base address */
+#define LAN9217_BASE_ADDR	DEBUG_BASE_ADDRESS
+/* External UART */
+#define UARTA_BASE_ADDR		(DEBUG_BASE_ADDRESS + 0x8000)
+#define UARTB_BASE_ADDR		(DEBUG_BASE_ADDRESS + 0x10000)
+
+#define BOARD_IO_ADDR		0x20000
+/* LED switchs */
+#define LED_SWITCH_REG		BOARD_IO_ADDR + 0x00
+/* buttons */
+#define SWITCH_BUTTONS_REG	BOARD_IO_ADDR + 0x08
+/* status, interrupt */
+#define INTR_STATUS_REG		BOARD_IO_ADDR + 0x10
+#define INTR_MASK_REG		BOARD_IO_ADDR + 0x38
+#define INTR_RESET_REG		BOARD_IO_ADDR + 0x20
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER1_REG	BOARD_IO_ADDR + 0x40
+#define MAGIC_NUMBER2_REG	BOARD_IO_ADDR + 0x48
+/* CPLD code version */
+#define CPLD_CODE_VER_REG	BOARD_IO_ADDR + 0x50
+
+#endif				/* __ASM_ARCH_MXC_BOARD_MX37_3STACK_H__ */
diff --git a/arch/arm/mach-mx37/clock.c b/arch/arm/mach-mx37/clock.c
new file mode 100644
index 0000000..b7623d5
--- /dev/null
+++ b/arch/arm/mach-mx37/clock.c
@@ -0,0 +1,726 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+#include <asm/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/spba.h>
+
+#include "crm_regs.h"
+
+/*
+ * Define reference clock inputs
+ */
+#define CKIL_CLK_FREQ               32768
+#define CKIH_CLK_FREQ               24000000
+
+/*
+ * Defines for EMI core clock change
+ */
+#define M3IF_BASE		IO_ADDRESS(M4IF_BASE_ADDR + 0x8c)
+
+static unsigned long pll_base[] = {
+	(unsigned long)MXC_DPLL1_BASE,
+	(unsigned long)MXC_DPLL2_BASE,
+	(unsigned long)MXC_DPLL3_BASE,
+};
+
+static struct clk pll1_clk;
+static struct clk pll2_clk;
+static struct clk pll3_clk;
+static struct clk lp_apm_clk;
+static struct clk periph_apm_clk;
+static struct clk ckih_clk;
+static struct clk ckil_clk;
+
+static void _clk_pll_recalc(struct clk *clk)
+{
+	long mfi, mfn, mfd, pdf, ref_clk, mfn_abs;
+	unsigned long dp_op, dp_mfd, dp_mfn, dp_ctl, pll_hfsm, dbl;
+	unsigned long pllbase;
+	unsigned int pll_val;
+	s64 temp;
+
+	if (clk == &pll1_clk) {
+		pll_val = 1;
+		pllbase = pll_base[0];
+	} else if (clk == &pll2_clk) {
+		pll_val = 2;
+		pllbase = pll_base[1];
+	} else if (clk == &pll3_clk) {
+		pll_val = 3;
+		pllbase = pll_base[2];
+	} else {
+		return;
+	}
+
+	dp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	pll_hfsm = dp_ctl & MXC_PLL_DP_CTL_HFSM;
+	dbl = (dp_ctl & MXC_PLL_DP_CTL_DPDCK0_2_EN);
+	dbl = ((dbl >> MXC_PLL_DP_CTL_DPDCK0_2_OFFSET) & 0x1) + 1;
+
+	if (pll_hfsm == 0) {
+		dp_op = __raw_readl(pllbase + MXC_PLL_DP_OP);
+		dp_mfd = __raw_readl(pllbase + MXC_PLL_DP_MFD);
+		dp_mfn = __raw_readl(pllbase + MXC_PLL_DP_MFN);
+	} else {
+		dp_op = __raw_readl(pllbase + MXC_PLL_DP_HFS_OP);
+		dp_mfd = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFD);
+		dp_mfn = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFN);
+	}
+	pdf = dp_op & MXC_PLL_DP_OP_PDF_MASK;
+	mfi = (dp_op >> MXC_PLL_DP_OP_MFI_OFFSET) & MXC_PLL_DP_OP_PDF_MASK;
+	mfi = (mfi <= 5) ? 5 : mfi;
+	mfd = dp_mfd & MXC_PLL_DP_MFD_MASK;
+	mfn = mfn_abs = dp_mfn & MXC_PLL_DP_MFN_MASK;
+	ref_clk = clk->parent->rate;
+	/* Sign extend to 32-bits */
+	if (mfn >= 0x04000000) {
+		mfn |= 0xFC000000;
+		mfn_abs = -mfn;
+	}
+
+	ref_clk = ref_clk * 2 * dbl;
+	ref_clk /= pdf + 1;
+	temp = (u64) ref_clk *mfn_abs;
+	do_div(temp, mfd + 1);
+	if (mfn < 0)
+		temp = -temp;
+	temp = (ref_clk * mfi) + temp;
+
+	clk->rate = temp;
+}
+
+static int _clk_pll_enable(struct clk *clk)
+{
+	u32 reg;
+	u32 pllbase;
+
+	if (clk == &pll1_clk) {
+		pllbase = pll_base[0];
+	} else if (clk == &pll2_clk) {
+		pllbase = pll_base[1];
+	} else if (clk == &pll3_clk) {
+		pllbase = pll_base[2];
+	} else {
+		return -EINVAL;
+	}
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL) | MXC_PLL_DP_CTL_UPEN;
+	__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);
+
+	/* Wait for lock */
+	while (!(__raw_readl(pllbase + MXC_PLL_DP_CTL) & MXC_PLL_DP_CTL_UPEN)) ;
+
+	return 0;
+}
+
+static void _clk_pll_disable(struct clk *clk)
+{
+	u32 reg;
+	u32 pllbase;
+
+	if (clk == &pll1_clk) {
+		pllbase = pll_base[0];
+	} else if (clk == &pll2_clk) {
+		pllbase = pll_base[1];
+	} else if (clk == &pll3_clk) {
+		pllbase = pll_base[2];
+	} else {
+		return;
+	}
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL) & ~MXC_PLL_DP_CTL_UPEN;
+	__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);
+}
+
+static void _clk_arm_recalc(struct clk *clk)
+{
+	u32 cacrr, div;
+
+	cacrr = __raw_readl(MXC_CCM_CACRR);
+	div = (cacrr & MXC_CCM_CACRR_ARM_PODF_MASK) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	return 0;
+}
+
+static int _clk_lp_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	if (parent == &ckih_clk) {
+		reg = __raw_readl(MXC_CCM_CCSR) & ~MXC_CCM_CCSR_LP_APM_SEL;
+	} else if (parent == &ckil_clk) {
+		reg = __raw_readl(MXC_CCM_CCSR) | MXC_CCM_CCSR_LP_APM_SEL;
+	} else {
+		return -EINVAL;
+	}
+	__raw_writel(reg, MXC_CCM_CCSR);
+
+	return 0;
+}
+
+static void _clk_periph_apm_recalc(struct clk *clk)
+{
+	u32 reg = (__raw_readl(MXC_CCM_CAMR) & MXC_CCM_CAMR_PERIPH_CLK_SEL_MASK)
+	    >> MXC_CCM_CAMR_PERIPH_CLK_SEL_OFFSET;
+
+	if (reg == 0) {
+		pll1_clk.recalc(&pll2_clk);
+		clk->rate = pll1_clk.rate;
+	} else if (reg == 1) {
+		pll3_clk.recalc(&pll3_clk);
+		clk->rate = pll3_clk.rate;
+	} else if (reg == 2) {
+		clk->rate = CKIH_CLK_FREQ;
+	}
+}
+
+static int _clk_periph_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	if (parent == &pll1_clk) {
+		mux = 0;
+	} else if (parent == &pll3_clk) {
+		mux = 1;
+	} else if (parent == &lp_apm_clk) {
+		mux = 2;
+	} else {
+		return -EINVAL;
+	}
+
+	reg = __raw_readl(MXC_CCM_CAMR) & ~MXC_CCM_CAMR_PERIPH_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CAMR_PERIPH_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CAMR);
+
+	return 0;
+}
+
+static void _clk_periph_recalc(struct clk *clk)
+{
+	u32 reg = __raw_readl(MXC_CCM_CBCDR6);
+
+	if ((reg & MXC_CCM_CBCDR6_PERIPH_CLK_SEL) == 0) {
+		pll2_clk.recalc(&pll2_clk);
+		clk->rate = pll2_clk.rate;
+	} else {
+		periph_apm_clk.recalc(&periph_apm_clk);
+		clk->rate = periph_apm_clk.rate;
+	}
+}
+
+static int _clk_periph_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	if (parent == &pll2_clk) {
+		reg = __raw_readl(MXC_CCM_CBCDR6) &
+		    ~MXC_CCM_CBCDR6_PERIPH_CLK_SEL;
+	} else if (parent == &periph_apm_clk) {
+		reg = __raw_readl(MXC_CCM_CBCDR6) |
+		    MXC_CCM_CBCDR6_PERIPH_CLK_SEL;
+	} else {
+		return -EINVAL;
+	}
+	__raw_writel(reg, MXC_CCM_CBCDR6);
+
+	return 0;
+}
+
+static void _clk_ahb_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR2);
+	div = ((reg & MXC_CCM_CBCDR2_AHB_CORE_PODF_MASK) >>
+	       MXC_CCM_CBCDR2_AHB_CORE_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static void _clk_ipg_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR2);
+	div = ((reg & MXC_CCM_CBCDR2_IPG_CORE_PODF_MASK) >>
+	       MXC_CCM_CBCDR2_IPG_CORE_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static void _clk_uart_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_UART_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_UART_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_uart_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	if (parent == &pll1_clk) {
+		mux = 0;
+	} else if (parent == &pll2_clk) {
+		mux = 1;
+	} else if (parent == &pll3_clk) {
+		mux = 2;
+	} else if (parent == &lp_apm_clk) {
+		mux = 3;
+	} else {
+		return -EINVAL;
+	}
+
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_UART_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_UART_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static void _clk_cspi_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR2);
+	prediv = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_cspi_set_parent(struct clk *clk, struct clk *parent)
+{
+
+	return 0;
+}
+
+static void _clk_ssi1_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	prediv = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK) >>
+		  MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK) >>
+		MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+static int _clk_ssi1_set_parent(struct clk *clk, struct clk *parent)
+{
+
+	return 0;
+}
+
+static void _clk_ssi2_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	prediv = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK) >>
+		  MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK) >>
+		MXC_CCM_CS2CDR_SSI2_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_ssi2_set_parent(struct clk *clk, struct clk *parent)
+{
+
+	return 0;
+}
+
+static struct clk ckih_clk = {
+	.name = "ckih",
+	.rate = CKIH_CLK_FREQ,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ckil_clk = {
+	.name = "ckil",
+	.rate = CKIL_CLK_FREQ,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pll1_clk = {
+	.name = "pll1",
+	.parent = &ckih_clk,
+	.recalc = _clk_pll_recalc,
+//      .enable = _clk_pll_enable,
+//      .disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pll2_clk = {
+	.name = "pll2",
+	.parent = &ckih_clk,
+	.recalc = _clk_pll_recalc,
+//      .enable = _clk_pll_enable,
+//      .disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pll3_clk = {
+	.name = "pll3",
+	.parent = &ckih_clk,
+	.recalc = _clk_pll_recalc,
+//      .enable = _clk_pll_enable,
+//      .disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk lp_apm_clk = {
+	.name = "lp_apm",
+	.parent = &ckih_clk,
+	.set_parent = _clk_lp_apm_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ap_clk = {
+	.name = "cpu_clk",
+	.parent = &pll1_clk,
+	.recalc = _clk_arm_recalc,
+	.set_rate = _clk_cpu_set_rate,
+};
+
+static struct clk periph_apm_clk = {
+	.name = "peripheral_apm_clk",
+	.parent = &pll1_clk,
+	.set_parent = _clk_periph_apm_set_parent,
+	.recalc = _clk_periph_apm_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk periph_clk = {
+	.name = "peripheral_clk",
+	.parent = &pll2_clk,
+	.set_parent = _clk_periph_set_parent,
+	.recalc = _clk_periph_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk uart_main_clk = {
+	.name = "uart_main_clk",
+	.parent = &pll2_clk,
+//      .set_rate = _clk_uart_set_rate,
+//      .round_rate = _clk_uart_round_rate,
+	.recalc = _clk_uart_recalc,
+	.set_parent = _clk_uart_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ungated_ahb_clk = {
+	.name = "ungated_ahb_clk",
+	.parent = &periph_clk,
+	.recalc = _clk_ahb_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ungated_ap_pclk = {
+	.name = "ipg_clk",
+	.parent = &ungated_ahb_clk,
+	.recalc = _clk_ipg_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk cspi_main_clk = {
+	.name = "uart_main_clk",
+	.parent = &pll3_clk,
+//      .set_rate = _clk_uart_set_rate,
+//      .round_rate = _clk_uart_round_rate,
+	.recalc = _clk_cspi_recalc,
+	.set_parent = _clk_cspi_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk sdma_clk[] = {
+	{
+	 .name = "sdma_ipg_clk",
+	 .parent = &ungated_ap_pclk,
+//       .enable_reg = MXC_CRMAP_L2CGR4,
+//       .enable_shift = MXC_CRMAP_L2_GATE40_OFFSET,
+//       .enable = _clk_enable,
+//       .disable = _clk_disable,
+	 },
+	{
+	 .name = "sdma_ahb_clk",
+//       .parent = &ap_com_ahb_clk[0],
+	 .parent = &ungated_ahb_clk,
+//       .enable_reg = MXC_CRMAP_L2CGR7,
+//       .enable_shift = MXC_CRMAP_L2_GATE70_OFFSET,
+//       .enable = _clk_enable,
+//       .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart1_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 0,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart1_clk[1],
+//       .enable = _clk_uart1_enable,
+//       .disable = _clk_uart1_disable,
+	 },
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 0,
+	 .parent = &ungated_ap_pclk,
+//       .enable_reg = MXC_CRMAP_L2CGR3,
+//       .enable_shift = MXC_CRMAP_L2_GATE38_OFFSET,
+//       .enable = _clk_enable,
+//       .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart2_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 1,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart2_clk[1],
+//       .enable = _clk_uart2_enable,
+//       .disable = _clk_uart2_disable,
+	 },
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 1,
+	 .parent = &ungated_ap_pclk,
+//       .enable_reg = MXC_CRMAP_L2CGR3,
+//       .enable_shift = MXC_CRMAP_L2_GATE39_OFFSET,
+//       .enable = _clk_enable,
+//       .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart3_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 2,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart3_clk[1],
+//       .enable = _clk_uart3_enable,
+//       .disable = _clk_uart3_disable,
+	 },
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 2,
+	 .parent = &ungated_ap_pclk,
+//       .enable_reg = MXC_CRMAP_L2CGR5,
+//       .enable_shift = MXC_CRMAP_L2_GATE56_OFFSET,
+//       .enable = _clk_enable,
+//       .disable = _clk_disable,
+	 },
+};
+
+static struct clk i2c_clk[] = {
+	{
+	 .name = "i2c_clk",
+	 .id = 0,
+//      .parent = &ap_pat_ref_clk[0],
+	 .parent = &ungated_ap_pclk,
+	 },
+	{
+	 .name = "i2c_clk",
+	 .id = 1,
+	 .parent = &ungated_ap_pclk,
+	 //.enable = _clk_enable,
+	 //.enable_reg = MXC_CCM_CGR0,
+	 //.enable_shift = MXC_CCM_CGR0_I2C2_OFFSET,
+	 //.disable = _clk_disable,
+	 },
+	{
+	 .name = "i2c_clk",
+	 .id = 2,
+	 .parent = &ungated_ap_pclk,
+	 //.enable = _clk_enable,
+	 //.enable_reg = MXC_CCM_CGR0,
+	 //.enable_shift = MXC_CCM_CGR0_I2C3_OFFSET,
+	 //.disable = _clk_disable,
+	 },
+};
+
+static struct clk cspi_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 0,
+	 .parent = &cspi_main_clk,
+	 //.enable = _clk_enable,
+	 //.enable_reg = MXC_CCM_CGR2,
+	 //.enable_shift = MXC_CCM_CGR2_CSPI1_OFFSET,
+	 //.disable = _clk_disable,
+	 },
+	{
+	 .name = "cspi_clk",
+	 .id = 1,
+	 .parent = &cspi_main_clk,
+	 //.enable = _clk_enable,
+	 //.enable_reg = MXC_CCM_CGR2,
+	 //.enable_shift = MXC_CCM_CGR2_CSPI1_OFFSET,
+	 //.disable = _clk_disable,
+	 },
+	{
+	 .name = "cspi_clk",
+	 .id = 2,
+	 .parent = &cspi_main_clk,
+	 //.enable = _clk_enable,
+	 //.enable_reg = MXC_CCM_CGR2,
+	 //.enable_shift = MXC_CCM_CGR2_CSPI1_OFFSET,
+	 //.disable = _clk_disable,
+	 },
+};
+
+static struct clk ssi1_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .id = 0,
+	 .parent = &pll3_clk,
+	 .set_parent = _clk_ssi1_set_parent,
+//       .round_rate = _clk_ssi1_round_rate,
+	 .secondary = &ssi1_clk[1],
+	 .recalc = _clk_ssi1_recalc,
+//       .set_rate = _clk_ssi1_set_rate,
+//       .enable = _clk_ssi1_enable,
+//       .disable = _clk_ssi1_disable,
+	 },
+	{
+	 .name = "ssi_ipg_clk",
+	 .id = 0,
+	 .parent = &ungated_ap_pclk,
+//       .enable_reg = MXC_CRMAP_L2CGR3,
+//       .enable_shift = MXC_CRMAP_L2_GATE30_OFFSET,
+//       .enable = _clk_enable,
+//       .disable = _clk_disable,
+	 },
+};
+
+static struct clk ssi2_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .id = 1,
+	 .parent = &pll3_clk,
+	 .set_parent = _clk_ssi2_set_parent,
+//       .round_rate = _clk_ssi2_round_rate,
+	 .secondary = &ssi2_clk[1],
+	 .recalc = _clk_ssi2_recalc,
+//       .set_rate = _clk_ssi1_set_rate,
+//       .enable = _clk_ssi1_enable,
+//       .disable = _clk_ssi1_disable,
+	 },
+	{
+	 .name = "ssi_ipg_clk",
+	 .id = 1,
+	 .parent = &ungated_ap_pclk,
+//       .enable_reg = MXC_CRMAP_L2CGR3,
+//       .enable_shift = MXC_CRMAP_L2_GATE30_OFFSET,
+//       .enable = _clk_enable,
+//       .disable = _clk_disable,
+	 },
+};
+
+static struct clk *mxc_clks[] = {
+	&ckih_clk,
+	&ckil_clk,
+	&pll1_clk,
+	&pll2_clk,
+	&pll3_clk,
+	&lp_apm_clk,
+	&ap_clk,
+	&periph_apm_clk,
+	&periph_clk,
+	&uart_main_clk,
+	&ungated_ahb_clk,
+	&ungated_ap_pclk,
+	&cspi_main_clk,
+	&sdma_clk[0],
+	&sdma_clk[1],
+	&uart1_clk[0],
+	&uart1_clk[1],
+	&uart2_clk[0],
+	&uart2_clk[1],
+	&uart3_clk[0],
+	&uart3_clk[1],
+	&i2c_clk[0],
+	&i2c_clk[1],
+	&i2c_clk[2],
+	&cspi_clk[0],
+	&cspi_clk[1],
+	&cspi_clk[2],
+	&ssi1_clk[0],
+	&ssi1_clk[1],
+	&ssi2_clk[0],
+	&ssi2_clk[1],
+};
+
+extern void propagate_rate(struct clk *tclk);
+
+int __init mxc_clocks_init(void)
+{
+	struct clk **clkp;
+
+	for (clkp = mxc_clks; clkp < mxc_clks + ARRAY_SIZE(mxc_clks); clkp++) {
+		clk_register(*clkp);
+	}
+/*
+	reg = __raw_readl(MXC_CRMAP_ASCSR);
+	if (reg & MXC_CRMAP_ASCSR_PLL_SEL_MASK) {
+		pll_core_clk.parent = &bp_div_gen_clk;
+	} else {
+		pll_core_clk.parent = &ap_pll_clk;
+	}
+	if (reg & MXC_CRMAP_ASCSR_EMISEL_MASK) {
+		emi_core_clk.parent = &pll_core_clk;
+	} else {
+		emi_core_clk.parent = &ap_pll_clk;
+	}
+*/
+
+	/* This will propagate to all children and init all the clock rates */
+	propagate_rate(&ckih_clk);
+	propagate_rate(&ckil_clk);
+
+	return 0;
+}
+
+/*!
+ * Function to get timer clock rate early in boot process before clock tree is
+ * initialized.
+ *
+ * @return	Clock rate for timer
+ */
+unsigned long __init clk_early_get_timer_rate(void)
+{
+	periph_clk.recalc(&periph_clk);
+	ungated_ahb_clk.recalc(&ungated_ahb_clk);
+	ungated_ap_pclk.recalc(&ungated_ap_pclk);
+
+	return ungated_ap_pclk.rate;
+}
diff --git a/arch/arm/mach-mx37/cpu.c b/arch/arm/mach-mx37/cpu.c
new file mode 100644
index 0000000..74e6caa
--- /dev/null
+++ b/arch/arm/mach-mx37/cpu.c
@@ -0,0 +1,75 @@
+/*
+ *  Copyright (C) 2001 Deep Blue Solutions Ltd.
+ *  Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+/*!
+ * @file mach-mx37/cpu.c
+ *
+ * @brief This file contains the CPU initialization code.
+ *
+ * @ingroup MSL_MX37
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/hardware/cache-l2x0.h>
+
+/*!
+ * CPU initialization. It is called by fixup_mxc_board()
+ */
+void __init mxc_cpu_init(void)
+{
+	if (!system_rev) {
+		mxc_set_system_rev(0x37, CHIP_REV_1_0);
+	}
+}
+
+/*!
+ * Post CPU init code
+ *
+ * @return 0 always
+ */
+static int __init post_cpu_init(void)
+{
+	void *l2_base;
+	volatile unsigned long aips_reg;
+
+	/* Initialize L2 cache */
+	l2_base = ioremap(L2CC_BASE_ADDR, SZ_4K);
+	if (l2_base) {
+		l2x0_init(l2_base, 0x00030024, 0x00000000);
+	}
+
+	/*
+	 * S/W workaround: Clear the off platform peripheral modules
+	 * Supervisor Protect bit for SDMA to access them.
+	 */
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x40));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x44));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x48));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x4C));
+	aips_reg = __raw_readl(IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
+	aips_reg &= 0x00FFFFFF;
+	__raw_writel(aips_reg, IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
+
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x40));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x44));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x48));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x4C));
+	aips_reg = __raw_readl(IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
+	aips_reg &= 0x00FFFFFF;
+	__raw_writel(aips_reg, IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
+
+	return 0;
+}
+
+postcore_initcall(post_cpu_init);
diff --git a/arch/arm/mach-mx37/crm_regs.h b/arch/arm/mach-mx37/crm_regs.h
new file mode 100644
index 0000000..83d00b4
--- /dev/null
+++ b/arch/arm/mach-mx37/crm_regs.h
@@ -0,0 +1,633 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ARCH_ARM_MACH_MX37_CRM_REGS_H__
+#define __ARCH_ARM_MACH_MX37_CRM_REGS_H__
+
+#define CKIH_CLK_FREQ	24000000
+
+#define MXC_CCM_BASE	IO_ADDRESS(CCM_BASE_ADDR)
+#define MXC_DPLL1_BASE 	IO_ADDRESS(PLL0_BASE_ADDR)
+#define MXC_DPLL2_BASE 	IO_ADDRESS(PLL1_BASE_ADDR)
+#define MXC_DPLL3_BASE 	IO_ADDRESS(PLL2_BASE_ADDR)
+
+/* PLL Register Offsets */
+#define MXC_PLL_DP_CTL                  0x00
+#define MXC_PLL_DP_CONFIG               0x04
+#define MXC_PLL_DP_OP                   0x08
+#define MXC_PLL_DP_MFD                  0x0C
+#define MXC_PLL_DP_MFN                  0x10
+#define MXC_PLL_DP_HFS_OP               0x1C
+#define MXC_PLL_DP_HFS_MFD              0x20
+#define MXC_PLL_DP_HFS_MFN              0x24
+#define MXC_PLL_DP_MFN_TOGC		0x28
+#define MXC_PLL_DP_MFNMINUS		0x14
+#define MXC_PLL_DP_MFNPLUS		0x18
+#define MXC_PLL_DP_DESTAT		0x2c
+
+/* PLL Register Bit definitions */
+#define MXC_PLL_DP_CTL_DPDCK0_2_EN      0x1000
+#define MXC_PLL_DP_CTL_DPDCK0_2_OFFSET  12
+#define MXC_PLL_DP_CTL_ADE              0x800
+#define MXC_PLL_DP_CTL_REF_CLK_DIV      0x400
+#define MXC_PLL_DP_CTL_HFSM             0x80
+#define MXC_PLL_DP_CTL_PRE              0x40
+#define MXC_PLL_DP_CTL_UPEN             0x20
+#define MXC_PLL_DP_CTL_RST              0x10
+#define MXC_PLL_DP_CTL_RCP              0x8
+#define MXC_PLL_DP_CTL_PLM              0x4
+#define MXC_PLL_DP_CTL_BRM0             0x2
+#define MXC_PLL_DP_CTL_LRF              0x1
+
+#define MXC_PLL_DP_CONFIG_LDREQ		0x1
+#define MXC_PLL_DP_MFN_TOGC_TOG_DIS     0x00020000
+#define MXC_PLL_DP_MFN_TOGC_TOG_EN      0x00010000
+#define MXC_PLL_DP_DESTAT_TOG_SEL	0x80000000
+#define MXC_PLL_TOGC_CNT_VALUE    	0x00000100
+#define MXC_PLL_TOGC_CNT_MASK          	0x0000FFFF
+
+#define MXC_PLL_DP_OP_MFI_OFFSET        4
+#define MXC_PLL_DP_OP_MFI_MASK          0xF
+#define MXC_PLL_DP_OP_PDF_OFFSET        0
+#define MXC_PLL_DP_OP_PDF_MASK          0xF
+
+#define MXC_PLL_DP_MFD_OFFSET           0
+#define MXC_PLL_DP_MFD_MASK             0x7FFFFFF
+
+#define MXC_PLL_DP_MFN_OFFSET           0
+#define MXC_PLL_DP_MFN_MASK             0x7FFFFFF
+
+/* Register addresses of CCM*/
+#define MXC_CCM_CCR	(MXC_CCM_BASE + 0x00)
+#define MXC_CCM_CCDR	(MXC_CCM_BASE + 0x04)
+#define MXC_CCM_CSR	(MXC_CCM_BASE + 0x08)
+#define MXC_CCM_CCSR	(MXC_CCM_BASE + 0x0C)
+#define MXC_CCM_CACRR	(MXC_CCM_BASE + 0x10)
+#define MXC_CCM_CBCDR1	(MXC_CCM_BASE + 0x14)
+#define MXC_CCM_CBCDR2	(MXC_CCM_BASE + 0x18)
+#define MXC_CCM_CBCDR3	(MXC_CCM_BASE + 0x1C)
+#define MXC_CCM_CBCDR4	(MXC_CCM_BASE + 0x20)
+#define MXC_CCM_CBCDR5	(MXC_CCM_BASE + 0x24)
+#define MXC_CCM_CBCDR6	(MXC_CCM_BASE + 0x28)
+#define MXC_CCM_CBCDR7	(MXC_CCM_BASE + 0x2C)
+#define MXC_CCM_CAMR	(MXC_CCM_BASE + 0x30)
+#define MXC_CCM_CSCMR1	(MXC_CCM_BASE + 0x34)
+#define MXC_CCM_CSCMR2	(MXC_CCM_BASE + 0x38)
+#define MXC_CCM_CSCDR1	(MXC_CCM_BASE + 0x3C)
+#define MXC_CCM_CS1CDR	(MXC_CCM_BASE + 0x40)
+#define MXC_CCM_CS2CDR	(MXC_CCM_BASE + 0x44)
+#define MXC_CCM_CSECDR1	(MXC_CCM_BASE + 0x48)
+#define MXC_CCM_CSECDR2	(MXC_CCM_BASE + 0x4C)
+#define MXC_CCM_CECDR	(MXC_CCM_BASE + 0x50)
+#define MXC_CCM_CDCDR	(MXC_CCM_BASE + 0x54)
+#define MXC_CCM_CH1CDR	(MXC_CCM_BASE + 0x58)
+#define MXC_CCM_CH2CDR	(MXC_CCM_BASE + 0x5C)
+#define MXC_CCM_CSCDR2	(MXC_CCM_BASE + 0x60)
+#define MXC_CCM_CR2	(MXC_CCM_BASE + 0x64)
+#define MXC_CCM_CDHIPR	(MXC_CCM_BASE + 0x68)
+#define MXC_CCM_CDCR	(MXC_CCM_BASE + 0x6C)
+#define MXC_CCM_CTOR	(MXC_CCM_BASE + 0x70)
+#define MXC_CCM_CLPCR	(MXC_CCM_BASE + 0x74)
+#define MXC_CCM_CISR	(MXC_CCM_BASE + 0x78)
+#define MXC_CCM_CIMR	(MXC_CCM_BASE + 0x7C)
+#define MXC_CCM_CCOSR	(MXC_CCM_BASE + 0x80)
+#define MXC_CCM_CGPR	(MXC_CCM_BASE + 0x84)
+#define MXC_CCM_CCGR0	(MXC_CCM_BASE + 0x88)
+#define MXC_CCM_CCGR1	(MXC_CCM_BASE + 0x8C)
+#define MXC_CCM_CCGR2	(MXC_CCM_BASE + 0x90)
+#define MXC_CCM_CCGR3	(MXC_CCM_BASE + 0x94)
+#define MXC_CCM_CCGR4	(MXC_CCM_BASE + 0x98)
+#define MXC_CCM_CCGR5	(MXC_CCM_BASE + 0x9C)
+#define MXC_CCM_CMEOR	(MXC_CCM_BASE + 0xA0)
+
+/* Register bit definitions */
+#define MXC_CCM_MASK(bits, offset) \
+		(((1 << (bits)) - 1) << (offset) )
+#define MXC_CCM_GET_FIELD(reg, bits, offset) \
+		(((reg) >> (offset))&((1 << (bits)) - 1))
+#define MXC_CCM_SET_FIELD(val, bits, offset) \
+		(((val)&((1 << (bits)) - 1)) << (offset) )
+
+/* Define the bits in register CCR */
+#define MXC_CCM_CCR_FPM_512MULT		(0 << 10)
+#define MXC_CCM_CCR_FPM_1024MULT	(1 << 10)
+#define MXC_CCM_CCR_CAMP_EN		(1 << 9)
+#define MXC_CCM_CCR_FPM_EN		(1 << 8)
+#define MXC_CCM_CCR_OSCNT_OFFSET	(0)
+#define MXC_CCM_CCR_OSCNT_BITS		(8)
+
+/* Define the bits in register CCDR */
+#define MXC_CCM_CCDR_HSC_HS_MASK	(0x1 << 18)
+#define MXC_CCM_CCDR_IPU_HS_MASK	(0x1 << 17)
+#define MXC_CCM_CCDR_EMI_HS_MASK	(0x1 << 16)
+#define MXC_CCM_CCDR_LOAD_DIVIDERS	(0x1 << 0)
+
+/* Define the bits in register CCSR */
+#define MXC_CCM_CCSR_LP_APM_SEL		(0x1 << 9)
+#define MXC_CCM_CCSR_STEP_SEL_OFFSET	(7)
+#define MXC_CCM_CCSR_STEP_SEL_MASK	(0x3 << 7)
+#define MXC_CCM_CCSR_PLL2_PODF_OFFSET	(5)
+#define MXC_CCM_CCSR_PLL2_PODF_MASK	(0x3 << 5)
+#define MXC_CCM_CCSR_PLL3_PODF_OFFSET	(3)
+#define MXC_CCM_CCSR_PLL3_PODF_MASK	(0x3 << 3)
+#define MXC_CCM_CCSR_PLL1_BYPASS	(1 << 2)
+#define MXC_CCM_CCSR_PLL2_BYPASS	(1 << 1)
+#define MXC_CCM_CCSR_PLL3_BYAPSS	(1 << 0)
+
+/* Define the bits in register CACRR */
+#define MXC_CCM_CACRR_ARM_PODF_OFFSET	(0)
+#define MXC_CCM_CACRR_ARM_PODF_MASK	(0x7)
+
+/* Define the bits in register CBCDR1 */
+#define MXC_CCM_CBCDR1_VPU_CORE_PODF_OFFSET	(3)
+#define MXC_CCM_CBCDR1_VPU_CORE_PODF_MASK	(0x7 << 3)
+#define MXC_CCM_CBCDR1_APU_CORE_PODF_OFFSET	(0)
+#define MXC_CCM_CBCDR1_APU_CORE_PODF_MASK	(0x7)
+
+/* Define the bits in register CBCDR2 */
+#define MXC_CCM_CBCDR2_AHB_CORE_PODF_OFFSET	(10)
+#define MXC_CCM_CBCDR2_AHB_CORE_PODF_MASK	(0x7 << 10)
+#define MXC_CCM_CBCDR2_IPG_CORE_PODF_OFFSET	(8)
+#define MXC_CCM_CBCDR2_IPG_CORE_PODF_MASK	(0x3 << 8)
+#define MXC_CCM_CBCDR2_PERCLK_PRED1_OFFSET	(6)
+#define MXC_CCM_CBCDR2_PERCLK_PRED1_MASK	(0x3 << 6)
+#define MXC_CCM_CBCDR2_PERCLK_PRED2_OFFSET	(3)
+#define MXC_CCM_CBCDR2_PERCLK_PRED2_MASK	(0x7 << 3)
+#define MXC_CCM_CBCDR2_PERCLK_PODF_OFFSET	(0)
+#define MXC_CCM_CBCDR2_PERCLK_PODF_MASK		(0x7)
+
+/* Define the bits in register CBCDR3 */
+#define MXC_CCM_CBCDR3_AXI_A_PODF_OFFSET	(0)
+#define MXC_CCM_CBCDR3_AXI_A_PODF_MASK		(0x7)
+
+/* Define the bits in register CBCDR4 */
+#define MXC_CCM_CBCDR4_AXI_B_PODF_OFFSET	(0)
+#define MXC_CCM_CBCDR4_AXI_B_PODF_MASK		(0x7)
+
+/* Define the bits in register CBCDR5 */
+#define MXC_CCM_CBCDR5_AXI_C_PODF_OFFSET	(0)
+#define MXC_CCM_CBCDR5_AXI_C_PODF_MASK		(0x7)
+
+/* Define the bits in register CBCDR6 */
+#define MXC_CCM_CBCDR6_EMI_PODF_OFFSET	(0)
+#define MXC_CCM_CBCDR6_EMI_PODF_MASK	(0x7)
+#define MXC_CCM_CBCDR6_EMI_CLK_SEL	(0x1 << 3)
+#define MXC_CCM_CBCDR6_PERIPH_CLK_SEL	(0x1 << 4)
+
+/* Define the bits in register CBCDR7 */
+#define MXC_CCM_CBCDR7_IPG_INT_MEM_PODF_OFFSET	(3)
+#define MXC_CCM_CBCDR7_IPG_INIT_MEM_PODF_MASK	(0x3 << 3)
+#define MXC_CCM_CBCDR7_NFC_PODF_OFFSET		(0)
+#define MXC_CCM_CBCDR7_NFC_PODF_MASK		(0x7)
+
+/* Define the bits in register CAMR */
+#define MXC_CCM_CAMR_PERIPH_CLK_SEL_OFFSET	(12)
+#define MXC_CCM_CAMR_PERIPH_CLK_SEL_MASK	(0x3 << 12)
+#define MXC_CCM_CAMR_DDR_CLK_SEL_OFFSET		(10)
+#define MXC_CCM_CAMR_DDR_CLK_SEL_MASK		(0x3 << 10)
+#define MXC_CCM_CAMR_ARM_AXI_CLK_SEL_OFFSET	(8)
+#define MXC_CCM_CAMR_ARM_AXI_CLK_SEL_MASK	(0x3 << 8)
+#define MXC_CCM_CAMR_VPU_CLK_SEL_OFFSET		(6)
+#define MXC_CCM_CAMR_VPU_CLK_SEL_MASK		(0x3 << 6)
+#define MXC_CCM_CAMR_VPU_AXI_CLK_SEL_OFFSET	(4)
+#define MXC_CCM_CAMR_VPU_AXI_CLK_SEL_MASK	(0x3 << 4)
+#define MXC_CCM_CAMR_IPU_HSP_CLK_SEL_OFFSET	(2)
+#define MXC_CCM_CAMR_IPU_HSP_CLK_SEL_MASK	(0x3 << 2)
+
+/* Define the bits in register CSCMR1 */
+#define MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_OFFSET		(30)
+#define MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_MASK		(0x3 << 30)
+#define MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_OFFSET		(28)
+#define MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_MASK		(0x3 << 28)
+#define MXC_CCM_CSCMR1_DI_CLK_SEL			(0x1 << 27)
+#define MXC_CCM_CSCMR1_USB_PHY_CLK_SEL			(0x1 << 26)
+#define MXC_CCM_CSCMR1_UART_CLK_SEL_OFFSET		(24)
+#define MXC_CCM_CSCMR1_UART_CLK_SEL_MASK		(0x3 << 24)
+#define MXC_CCM_CSCMR1_USBOH2_CLK_SEL_OFFSET		(22)
+#define MXC_CCM_CSCMR1_USBOH2_CLK_SEL_MASK		(0x3 << 22)
+#define MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_OFFSET 	(20)
+#define MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_MASK 	(0x3 << 20)
+#define MXC_CCM_CSCMR1_ESDHC3_CLK_SEL			(0x1 << 19)
+#define MXC_CCM_CSCMR1_PERCLK_IPG_CLK_SEL		(0x1 << 18)
+#define MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_OFFSET	(16)
+#define MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_MASK	(0x3 << 16)
+#define MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET		(14)
+#define MXC_CCM_CSCMR1_SSI1_CLK_SEL_MASK		(0x3 << 14)
+#define MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET		(12)
+#define MXC_CCM_CSCMR1_SSI2_CLK_SEL_MASK		(0x3 << 12)
+#define MXC_CCM_CSCMR1_SSI_APM_CLK_SEL			(0x1 << 9)
+#define MXC_CCM_CSCMR1_SPDIF_CLK_SEL			(0x1 << 8)
+#define MXC_CCM_CSCMR1_TVE_CLK_SEL			(0x1 << 7)
+#define MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL			(0x1 << 6)
+#define MXC_CCM_CSCMR1_CSPI_CLK_SEL_OFFSET		(4)
+#define MXC_CCM_CSCMR1_CSPI_CLK_SEL_MASK		(0x3 << 4)
+#define MXC_CCM_CSCMR1_PERCLK_LP_APM_CLK_SEL		(0x1 << 2)
+#define MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL		(0x1 << 1)
+#define MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL		(0x1)
+
+/* Define the bits in register CSCDR1 */
+#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_OFFSET	(22)
+#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK	(0x7 << 22)
+#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET	(19)
+#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK	(0x7 << 19)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_OFFSET	(16)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_MASK	(0x7 << 16)
+#define MXC_CCM_CSCDR1_PGC_CLK_PODF_OFFSET		(14)
+#define MXC_CCM_CSCDR1_PGC_CLK_PODF_MASK		(0x3 << 14)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_OFFSET	(11)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_MASK	(0x7 << 11)
+#define MXC_CCM_CSCDR1_USBOH2_CLK_PRED_OFFSET		(8)
+#define MXC_CCM_CSCDR1_USBOH2_CLK_PRED_MASK		(0x7 << 8)
+#define MXC_CCM_CSCDR1_USBOH2_CLK_PODF_OFFSET		(6)
+#define MXC_CCM_CSCDR1_USBOH2_CLK_PODF_MASK		(0x3 << 6)
+#define MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET		(3)
+#define MXC_CCM_CSCDR1_UART_CLK_PRED_MASK		(0x7 << 3)
+#define MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET		(0)
+#define MXC_CCM_CSCDR1_UART_CLK_PODF_MASK		(0x7)
+
+/* Define the bits in register CS1CDR and CS2CDR */
+#define MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET		(6)
+#define MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET		(0)
+#define MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK		(0x3F)
+
+#define MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET		(6)
+#define MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CS2CDR_SSI2_CLK_PODF_OFFSET		(0)
+#define MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK		(0x3F)
+
+/* Define the bits in register SCECDR1 and SCECDR2 */
+#define MXC_CCM_SCECDR1_SSI_EXT1_CLK_PRED_OFFSET (6)
+#define MXC_CCM_SCECDR1_SSI_EXT1_CLK_PRED_BITS (3)
+#define MXC_CCM_SCECDR1_SSI_EXT1_CLK_PODF_OFFSET (0)
+#define MXC_CCM_SCECDR1_SSI_EXT1_CLK_PODF_BITS (6)
+#define MXC_CCM_SCECDR2_SSI_EXT2_CLK_PRED_OFFSET (6)
+#define MXC_CCM_SCECDR2_SSI_EXT2_CLK_PRED_BITS (3)
+#define MXC_CCM_SCECDR2_SSI_EXT2_CLK_PODF_OFFSET (0)
+#define MXC_CCM_SCECDR2_SSI_EXT2_CLK_PODF_BITS (6)
+
+/* Define the bits in register CECDR */
+#define MXC_CCM_CECDR_ESC_CLK_PRED_OFFSET (6)
+#define MXC_CCM_CECDR_ESC_CLK_PRED_BITS (3)
+#define MXC_CCM_CECDR_ESC_CLK_PODF_OFFSET (0)
+#define MXC_CCM_CECDR_ESC_CLK_PODF_BITS (6)
+
+/* Define the bits in register CDCDR */
+#define MXC_CCM_CDCDR_DI_CLK_PRED_OFFSET (6)
+#define MXC_CCM_CDCDR_DI_CLK_PRED_BITS (3)
+#define MXC_CCM_CDCDR_DI_CLK_PODF_OFFSET (0)
+#define MXC_CCM_CDCDR_DI_CLK_PODF_BITS (6)
+
+/* Define the bits in register CH1CDR and CH2CDR */
+#define MXC_CCM_CH1CDR_HSC1_CLK_PODF_OFFSET (0)
+#define MXC_CCM_CH1CDR_HSC1_CLK_PODF_BITS (3)
+#define MXC_CCM_CH2CDR_HSC2_CLK_PODF_OFFSET (0)
+#define MXC_CCM_CH2CDR_HSC2_CLK_PODF_BITS (3)
+
+/* Define the bits in register CSCDR2 */
+#define MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET		(25)
+#define MXC_CCM_CSCDR2_CSPI_CLK_PRED_MASK		(0x7 << 25)
+#define MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET		(19)
+#define MXC_CCM_CSCDR2_CSPI_CLK_PODF_MASK		(0x3F << 19)
+
+/* Define the bits in register CDHIPR */
+#define MXC_CCM_CDHIPR_ARM_PODF_BUSY (1<<16)
+#define MXC_CCM_CDHIPR_HSC2_CLK_PODF_BUSY (1<<9)
+#define MXC_CCM_CDHIPR_HSC1_CLK_PODF_BUSY (1<<8)
+#define MXC_CCM_CDHIPR_ESC_CLK_DIVIDER_BUSY (1<<6)
+#define MXC_CCM_CDHIPR_NFC_IPG_INT_MEM_PODF_BUSY (1<<4)
+#define MXC_CCM_CDHIPR_EMI_PODF_BUSY (1<<3)
+#define MXC_CCM_CDHIPR_AXI_C_PODF_BUSY (1<<2)
+#define MXC_CCM_CDHIPR_AXI_B_PODF_BUSY (1<<1)
+#define MXC_CCM_CDHIPR_AXI_A_PODF_BUSY (1<<0)
+
+/* Define the bits in register CDCR */
+#define MXC_CCM_CDCR_HSC2_DVFS_EN_OFFSET (8)
+#define MXC_CCM_CDCR_HSC2_DVFS_EN_BITS (1)
+#define MXC_CCM_CDCR_HSC1_DVFS_EN_OFFSET (7)
+#define MXC_CCM_CDCR_HSC1_DVFS_EN_BITS (1)
+#define MXC_CCM_CDCR_ARM_FREQ_SHIFT_DIVIDER_OFFSET (2)
+#define MXC_CCM_CDCR_ARM_FREQ_SHIFT_DIVIDER_BITS (1)
+#define MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_OFFSET (0)
+#define MXC_CCM_CDCR_ PERIPH_CLK_DVFS_PODF_BITS (2)
+
+/* Define the bits in register CLPCR */
+#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS_OFFSET (22)
+#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS_BITS (1)
+#define MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_OFFSET (21)
+#define MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_BITS (1)
+#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_OFFSET (20)
+#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_BITS (1)
+#define MXC_CCM_CLPCR_BYPASS_EMI_LPM_HS_OFFSET (19)
+#define MXC_CCM_CLPCR_BYPASS_EMI_LPM_HS_BITS (1)
+#define MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS_OFFSET (18)
+#define MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS_BITS (1)
+#define MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS_OFFSET (17)
+#define MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS_BITS (1)
+#define MXC_CCM_CLPCR_BYPASS_SAHARA_LPM_HS_OFFSET (16)
+#define MXC_CCM_CLPCR_BYPASS_SAHARA_LPM_HS_BITS (1)
+#define MXC_CCM_CLPCR_STBY_COUNT_OFFSET (9)
+#define MXC_CCM_CLPCR_STBY_COUNT _BITS (2)
+#define MXC_CCM_CLPCR_STBY_OFFSET (8)
+#define MXC_CCM_CLPCR_VSTBY_BITS (1)
+#define MXC_CCM_CLPCR_DIS_REF_OSC_OFFSET (7)
+#define MXC_CCM_CLPCR_DIS_REF_OSC_BITS (1)
+#define MXC_CCM_CLPCR_SBYOS_OFFSET (6)
+#define MXC_CCM_CLPCR_SBYOS_BITS (1)
+#define MXC_CCM_CLPCR_ARM_CLK_DIS_ON_LPM_OFFSET (5)
+#define MXC_CCM_CLPCR_ARM_CLK_DIS_ON_LPM_BITS (1)
+#define MXC_CCM_CLPCR_LPSR_CLK_SEL_OFFSET (3)
+#define MXC_CCM_CLPCR_LPSR_CLK_SEL_BITS (2)
+#define MXC_CCM_CLPCR_LPM_OFFSET (0)
+#define MXC_CCM_CLPCR_LPM_BITS (2)
+
+/* Define the bits in register ISR */
+#define MXC_CCM_ISR_ARM_PODF_LOADED (25)
+#define MXC_CCM_ISR_HSC2_CLK_PODF_LOADED (24)
+#define MXC_CCM_ISR_HSC1_CLK_PODF_LOADED (23)
+#define MXC_CCM_ISR_ESC_CLK_DIVIDER_LOADED (22)
+#define MXC_CCM_ISR_NFC_IPG_INT_MEM_PODF_LOADED (21)
+#define MXC_CCM_ISR_EMI_PODF_LOADED (20)
+#define MXC_CCM_ISR_AXI_C_PODF_LOADED (19)
+#define MXC_CCM_ISR_AXI_B_PODF_LOADED (18)
+#define MXC_CCM_ISR_AXI_A_PODF_LOADED (17)
+#define MXC_CCM_ISR_DIVIDER_LOADED (16)
+#define MXC_CCM_ISR_CHIH_READY (4)
+#define MXC_CCM_ISR_FPM_READY (3)
+#define MXC_CCM_ISR_LRF_PLL3 (2)
+#define MXC_CCM_ISR_LRF_PLL2 (1)
+#define MXC_CCM_ISR_LRF_PLL1 (0)
+
+/* Define the bits in register CCOSR */
+#define MXC_CCM_CCOSR_CKO2_EN_OFFSET  (24)
+#define MXC_CCM_CCOSR_CKO2_EN_BITS  (1)
+#define MXC_CCM_CCOSR_CKO2_DIV_OFFSET  (21)
+#define MXC_CCM_CCOSR_CKO2_DIV_BITS  (3)
+#define MXC_CCM_CCOSR_CKO2_SEL_OFFSET  (16)
+#define MXC_CCM_CCOSR_CKO2_SEL_BITS  (5)
+#define MXC_CCM_CCOSR_CKO1_EN_OFFSET  (7)
+#define MXC_CCM_CCOSR_CKO1_EN_BITS  (1)
+#define MXC_CCM_CCOSR_CKO1_DIV_OFFSET  (4)
+#define MXC_CCM_CCOSR_CKO1_DIV_BITS  (3)
+#define MXC_CCM_CCOSR_CKO1_SEL_OFFSET  (0)
+#define MXC_CCM_CCOSR_CKO1_SEL_BITS  (4)
+
+/* Define the bits in registers CGPR */
+#define MXC_CCM_CGPR_FPM_SEL_OFFSET (3)
+#define MXC_CCM_CGPR_FPM_SEL_BITS (1)
+#define MXC_CCM_CGPR_VL_L2BIST_CLKDIV_OFFSET (0)
+#define MXC_CCM_CGPR_ VL_L2BIST_CLKDIV _BITS (3)
+
+/* Define the bits in registers CCGRx */
+
+/* The definitions for gate parameter*/
+#define MXC_CCM_CCGR_CLK_OFF	(0)
+#define MXC_CCM_CCGR_CLK_ON_IN_RUN	(1)
+#define MXC_CCM_CCGR_CLK_ON_ALWAYS	(3)
+
+#define MXC_CCM_CCGR_OFF(val, index)   \
+		((val) & (~((MXC_CCM_CCGR_CLK_OFF)<<((index)<<1))))
+#define MXC_CCM_CCGR_ON(val, index, en) \
+		(MXC_CCM_CCGR_OFF(val, index) |((en)<<((index)<<1)) )
+
+/* The clock index in register CCGR1 */
+#define MXC_CCM_CCGR_XSPLIT_CLK_GATE (0)
+#define MXC_CCM_CCGR_ARM_AXI_CLK_GATE (1)
+#define MXC_CCM_CCGR_DAP_CLK_GATE (2)
+#define MXC_CCM_CCGR_CTM_CLK_GATE (3)
+#define MXC_CCM_CCGR_CTI1_CLK_GATE (4)
+#define MXC_CCM_CCGR_CTI2_CLK_GATE (5)
+#define MXC_CCM_CCGR_CTI3_CLK_GATE (6)
+#define MXC_CCM_CCGR_AHB_MUX2_CLK_GATE (7)
+#define MXC_CCM_CCGR_ROMCP_CLK_GATE (8)
+#define MXC_CCM_CCGR_ROM32K_CLK_GATE (9)
+#define MXC_CCM_CCGR_AHB_MAX_CLK_GATE (12)
+#define MXC_CCM_CCGR_AIPS_TZ1_CLK_GATE (13)
+#define MXC_CCM_CCGR_AIPS_TZ2_CLK_GATE (14)
+#define MXC_CCM_CCGR_IIM_CLK_GATE (15)
+
+/* the configuration to enable separate clock in register CCGR0*/
+#define MXC_CCM_CCGR_XSPLIT_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS	)
+#define MXC_CCM_CCGR_ARM_AXI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_DAP_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_CTM_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_CTI1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_CTI2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_CTI3_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_AHB_MUX2_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_ROMCP_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_ROM32K_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_AHB_MAX_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_AIPS_TZ1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_AIPS_TZ2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_IIM_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+
+/* The clock index in register CCGR1 */
+#define MXC_CCM_CCGR_TMAX1_CLK_GATE (0)
+#define MXC_CCM_CCGR_TMAX2_CLK_GATE (1)
+#define MXC_CCM_CCGR_TMAX3_CLK_GATE (2)
+#define MXC_CCM_CCGR_TMAX4_CLK_GATE (3)
+#define MXC_CCM_CCGR_UART1_IPG_CLK_GATE (4)
+#define MXC_CCM_CCGR_UART1_PERCLK_GATE (5)
+#define MXC_CCM_CCGR_UART2_IPG_CLK_GATE (6)
+#define MXC_CCM_CCGR_UART2_PERCLK_GATE (7)
+#define MXC_CCM_CCGR_UART3_IPG_CLK_GATE (8)
+#define MXC_CCM_CCGR_UART3_PERCLK_GATE (9)
+#define MXC_CCM_CCGR_UART4_IPG_CLK_GATE (10)
+#define MXC_CCM_CCGR_UART4_PERCLK_GATE (11)
+#define MXC_CCM_CCGR_UART5_IPG_CLK_GATE (12)
+#define MXC_CCM_CCGR_UART5_PERCLK_GATE (13)
+#define MXC_CCM_CCGR_I2C1_CLK_GATE (14)
+#define MXC_CCM_CCGR_I2C2_CLK_GATE (15)
+
+/* The configuration to enable separate clock in register CCGR1 */
+#define MXC_CCM_CCGR_TMAX1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_TMAX2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_TMAX3_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_TMAX4_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_UART1_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_UART1_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_UART2_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_UART2_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_UART3_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_UART3_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_UART4_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_UART4_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_UART5_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_UART5_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_I2C1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_I2C2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+
+/* The clock index in register CCGR2 */
+#define MXC_CCM_CCGR_I2C3_CLK_GATE (0)
+#define MXC_CCM_CCGR_EPIT1_IPG_CLK_GATE (1)
+#define MXC_CCM_CCGR_EPIT1_HIGHFREQ_CLK_GATE (2)
+#define MXC_CCM_CCGR_EPIT2_IPG_CLK_GATE (3)
+#define MXC_CCM_CCGR_EPIT2_HIGHFREQ_CLK_GATE (4)
+#define MXC_CCM_CCGR_PWM_IPG_CLK_GATE (5)
+#define MXC_CCM_CCGR_PWM_HIGHFREQ_CLK_GATE (6)
+#define MXC_CCM_CCGR_GPT_IPG_CLK_GATE (7)
+#define MXC_CCM_CCGR_GPT_HIGHFREQ_CLK_GATE (8)
+#define MXC_CCM_CCGR_OWIRE_CLK_GATE (9)
+#define MXC_CCM_CCGR_FEC_CLK_GATE (10)
+#define MXC_CCM_CCGR_USBOH2_IPG_HCLK_GATE (11)
+#define MXC_CCM_CCGR_USBOH2_60M_CLK_GATE (12)
+#define MXC_CCM_CCGR_ESDHC1_IPG_HCLK_GATE (13)
+#define MXC_CCM_CCGR_ESDHC1_PERCLK_GATE (14)
+#define MXC_CCM_CCGR_ESDHC2_IPG_HCLK_GATE (15)
+
+/* The configuration to enable separate clock in register CCGR2 */
+#define MXC_CCM_CCGR_I2C3_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_EPIT1_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_EPIT1_HIGHFREQ_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_EPIT2_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_EPIT2_HIGHFREQ_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_PWM_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_PWM_HIGHFREQ_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_GPT_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_GPT_HIGHFREQ_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_OWIRE_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_FEC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_USBOH2_IPG_HCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_USBOH2_60M_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_ESDHC1_IPG_HCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_ESDHC1_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_ESDHC2_IPG_HCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+
+/* The clock index in register CCGR3 */
+#define MXC_CCM_CCGR_ESDHC2_PERCLK_GATE (0)
+#define MXC_CCM_CCGR_ESDHC3_IPG_HCLK_GATE (1)
+#define MXC_CCM_CCGR_ESDHC3_PERCLK_GATE (2)
+#define MXC_CCM_CCGR_MSHC1_IPG_HCLK_GATE (3)
+#define MXC_CCM_CCGR_MSHC1_DI_CLK_GATE (4)
+#define MXC_CCM_CCGR_MSHC2_IPG_HCLK_GATE (5)
+#define MXC_CCM_CCGR_MSHC2_DI_CLK_GATE (6)
+#define MXC_CCM_CCGR_SSI1_IPG_CLK_GATE (7)
+#define MXC_CCM_CCGR_SSI1_SSI_CLK_GATE (8)
+#define MXC_CCM_CCGR_SSI2_IPG_CLK_GATE (9)
+#define MXC_CCM_CCGR_SSI2_SSI_CLK_GATE (10)
+#define MXC_CCM_CCGR_SSI_EXT1_CLK_GATE (11)
+#define MXC_CCM_CCGR_SSI_EXT2_CLK_GATE (12)
+#define MXC_CCM_CCGR_MARC_CLK_GATE (13)
+#define MXC_CCM_CCGR_PATA_CLK_GATE (14)
+#define MXC_CCM_CCGR_SIM_CLK_GATE (15)
+
+/* The configuration to enable separate clock in register CCGR3 */
+#define MXC_CCM_CCGR_ESDHC2_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_ESDHC3_IPG_HCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_ESDHC3_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_MSHC1_IPG_HCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_MSHC1_DI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_MSHC2_IPG_HCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_MSHC2_DI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_SSI1_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_SSI1_SSI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_SSI2_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_SSI2_SSI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_SSI_EXT1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_SSI_EXT2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_MARC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_PATA_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_SIM_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+
+/* The clock index in register CCGR4 */
+#define MXC_CCM_CCGR_HSC1_CLK_GATE (0)
+#define MXC_CCM_CCGR_HSC_ESC_CLK_GATE (1)
+#define MXC_CCM_CCGR_HSC2_CLK_GATE (2)
+#define MXC_CCM_CCGR_HSC_HSP_CLK_GATE (3)
+#define MXC_CCM_CCGR_SAHARA_CLK_GATE (4)
+#define MXC_CCM_CCGR_RTIC_CLK_GATE (5)
+#define MXC_CCM_CCGR_SDDC_CLK_GATE (6)
+#define MXC_CCM_CCGR_CSPI1_IPG_CLK_GATE (7)
+#define MXC_CCM_CCGR_CSPI1_PERCLK_GATE (8)
+#define MXC_CCM_CCGR_CSPI2_IPG_CLK_GATE (9)
+#define MXC_CCM_CCGR_CSPI2_PERCLK_GATE (10)
+#define MXC_CCM_CCGR_CSPI3_IPG_CLK_GATE (11)
+#define MXC_CCM_CCGR_CSPI3_PERCLK_GATE (12)
+#define MXC_CCM_CCGR_SRTC_CLK_GATE (13)
+#define MXC_CCM_CCGR_DI_CLK_GATE (14)
+#define MXC_CCM_CCGR_IPU_CLK_GATE (15)
+
+/* The configuration to enable separate clock in register CCGR4 */
+#define MXC_CCM_CCGR_HSC1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_HSC_ESC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_HSC2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_HSC_HSP_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_SAHARA_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_RTIC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_SDDC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_CSPI1_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_CSPI1_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_CSPI2_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_CSPI2_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_CSPI3_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_CSPI3_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_SRTC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_DI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_IPU_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+
+/* The clock index in register CCGR5 */
+#define MXC_CCM_CCGR_SDMA_CLK_GATE (0)
+#define MXC_CCM_CCGR_SPBA_CLK_GATE (1)
+#define MXC_CCM_CCGR_CSI_MCLK1_CLK_GATE (2)
+#define MXC_CCM_CCGR_CSI_MCLK2_CLK_GATE (3)
+#define MXC_CCM_CCGR_AHB_MUX1_CLK_GATE (4)
+#define MXC_CCM_CCGR_GPU_CLK_GATE (5)
+#define MXC_CCM_CCGR_VPU_CLK_GATE (6)
+#define MXC_CCM_CCGR_VPU_SERIAL_CLK_GATE (7)
+#define MXC_CCM_CCGR_APU_CLK_GATE (8)
+#define MXC_CCM_CCGR_MU_CLK_GATE (9)
+#define MXC_CCM_CCGR_EMI_CLK_GATE (11)
+#define MXC_CCM_CCGR_EMI_FAST_CLK_GATE (12)
+#define MXC_CCM_CCGR_EMI_SLOW_CLK_GATE (13)
+#define MXC_CCM_CCGR_EMI_INTR_CLK_GATE (14)
+#define MXC_CCM_CCGR_GPC_CLK_GATE (15)
+
+/* The configuration to enable separate clock in register CCGR5 */
+#define MXC_CCM_CCGR_SDMA_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_SPBA_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_CSI_MCLK1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_CSI_MCLK2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_AHB_MUX1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_GPU_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_VPU_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_VPU_SERIAL_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_APU_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_MU_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_EMI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_EMI_FAST_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_EMI_SLOW_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_EMI_INTR_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+#define MXC_CCM_CCGR_GPC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
+
+/* Define the bit in register CMEOR */
+#define MXC_CCM_CMEOR_EN_OV_HSC_ESC (1<<18)
+#define MXC_CCM_CMEOR_EN_OV_HSC_SEC (1<<17)
+#define MXC_CCM_CMEOR_EN_OV_HSC_PRIM (1<<16)
+#define MXC_CCM_CMEOR_EN_OV_EMI_INTR (1<<15)
+#define MXC_CCM_CMEOR_EN_OV_EMI_SLOW (1<<14)
+#define MXC_CCM_CMEOR_EN_OV_EMI_FAST (1<<13)
+#define MXC_CCM_CMEOR_EN_OV_GPC (1<<12)
+#define MXC_CCM_CMEOR_EN_OV_MBX3D (1<<11)
+#define MXC_CCM_CMEOR_EN_OV_MBX (1<<10)
+#define MXC_CCM_CMEOR_EN_OV_VPU (1<<9)
+#define MXC_CCM_CMEOR_EN_OV_DAP (1<<8)
+#define MXC_CCM_CMEOR_EN_OV_APU (1<<7)
+#define MXC_CCM_CMEOR_EN_OV_EPIT (1<<6)
+#define MXC_CCM_CMEOR_EN_OV_GPT (1<<5)
+#define MXC_CCM_CMEOR_EN_OV_ESDHC (1<<4)
+#define MXC_CCM_CMEOR_EN_OV_IIM (1<<3)
+#define MXC_CCM_CMEOR_EN_OV_OWIRE (1<<2)
+#define MXC_CCM_CMEOR_EN_OV_SDDC (1<<1)
+#define MXC_CCM_CMEOR_EN_OV_SAHARA (1<<0)
+
+#endif				/* __ARCH_ARM_MACH_MX37_CRM_REGS_H__ */
diff --git a/arch/arm/mach-mx37/devices.c b/arch/arm/mach-mx37/devices.c
new file mode 100644
index 0000000..253eeb8
--- /dev/null
+++ b/arch/arm/mach-mx37/devices.c
@@ -0,0 +1,608 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/spi/spi.h>
+
+#include <asm/hardware.h>
+
+#include <asm/arch/spba.h>
+#include "iomux.h"
+#include <asm/arch/sdma.h>
+#include "sdma_script_code.h"
+
+void mxc_sdma_get_script_info(sdma_script_start_addrs * sdma_script_addr)
+{
+	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
+	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code;
+	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
+	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR;
+	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = dptc_dvfs_ADDR;
+	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_per_2_app_addr = -1;
+	sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+	sdma_script_addr->mxc_sdma_per_2_shp_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = -1;
+	sdma_script_addr->mxc_sdma_shp_2_per_addr = -1;
+	sdma_script_addr->mxc_sdma_uart_2_per_addr = -1;
+	sdma_script_addr->mxc_sdma_app_2_per_addr = -1;
+}
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_W1_MASTER_MXC) || defined(CONFIG_W1_MASTER_MXC_MODULE)
+static struct mxc_w1_config mxc_w1_data = {
+	.search_rom_accelerator = 0,
+};
+
+static struct platform_device mxc_w1_devices = {
+	.name = "mxc_w1",
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_w1_data,
+		},
+	.id = 0
+};
+
+static void mxc_init_owire(void)
+{
+	(void)platform_device_register(&mxc_w1_devices);
+}
+#else
+static inline void mxc_init_owire(void)
+{
+}
+#endif
+
+#if defined(CONFIG_RTC_MXC) || defined(CONFIG_RTC_MXC_MODULE)
+static struct resource rtc_resources[] = {
+	{
+	 .start = SRTC_BASE_ADDR,
+	 .end = SRTC_BASE_ADDR + 0x40,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MXC_INT_RTC,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+static struct platform_device mxc_rtc_device = {
+	.name = "mxc_rtc",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(rtc_resources),
+	.resource = rtc_resources,
+};
+static void mxc_init_rtc(void)
+{
+	(void)platform_device_register(&mxc_rtc_device);
+}
+#else
+static inline void mxc_init_rtc(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
+
+static struct resource wdt_resources[] = {
+	{
+	 .start = WDOG1_BASE_ADDR,
+	 .end = WDOG1_BASE_ADDR + 0x30,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_wdt_device = {
+	.name = "mxc_wdt",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(wdt_resources),
+	.resource = wdt_resources,
+};
+
+static void mxc_init_wdt(void)
+{
+	(void)platform_device_register(&mxc_wdt_device);
+}
+#else
+static inline void mxc_init_wdt(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_IPU) || defined(CONFIG_MXC_IPU_MODULE)
+
+static struct resource ipu_resources[] = {
+	{
+	 .start = IPU_CTRL_BASE_ADDR,
+	 .end = IPU_CTRL_BASE_ADDR + SZ_512M,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MXC_INT_IPU_SYN,
+	 .flags = IORESOURCE_IRQ,
+	 },
+	{
+	 .start = MXC_INT_IPU_ERR,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct platform_device mxc_ipu_device = {
+	.name = "mxc_ipu",
+	.id = -1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_ipu_data,
+		},
+	.num_resources = ARRAY_SIZE(ipu_resources),
+	.resource = ipu_resources,
+};
+
+static void mxc_init_ipu(void)
+{
+	platform_device_register(&mxc_ipu_device);
+}
+#else
+static inline void mxc_init_ipu(void)
+{
+}
+#endif
+
+#if  defined(CONFIG_SND_MXC_PMIC) || defined(CONFIG_SND_MXC_PMIC_MODULE)
+static struct mxc_audio_platform_data mxc_audio_data = {
+	.ssi_num = 2,
+	.src_port = 0,
+};
+
+static struct platform_device mxc_alsa_device = {
+	.name = "mxc_alsa",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_audio_data,
+		},
+
+};
+
+static void mxc_init_audio(void)
+{
+	platform_device_register(&mxc_alsa_device);
+}
+#else
+
+static void mxc_init_audio(void)
+{
+}
+
+#endif
+
+#if defined(CONFIG_MXC_SSI) || defined(CONFIG_MXC_SSI_MODULE)
+/*!
+ * Resource definition for the SSI
+ */
+static struct resource mxcssi2_resources[] = {
+	[0] = {
+	       .start = SSI2_BASE_ADDR,
+	       .end = SSI2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+};
+
+static struct resource mxcssi1_resources[] = {
+	[0] = {
+	       .start = SSI1_BASE_ADDR,
+	       .end = SSI1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+};
+
+/*! Device Definition for MXC SSI */
+static struct platform_device mxc_ssi1_device = {
+	.name = "mxc_ssi",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_audio_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcssi1_resources),
+	.resource = mxcssi1_resources,
+};
+
+static struct platform_device mxc_ssi2_device = {
+	.name = "mxc_ssi",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_audio_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcssi2_resources),
+	.resource = mxcssi2_resources,
+};
+
+static void mxc_init_ssi(void)
+{
+	platform_device_register(&mxc_ssi1_device);
+	platform_device_register(&mxc_ssi2_device);
+}
+#else
+
+static void mxc_init_ssi(void)
+{
+}
+#endif
+
+/*!
+ * This is platform device structure for adding SCC
+ */
+#if defined(CONFIG_MXC_SECURITY_SCC) || defined(CONFIG_MXC_SECURITY_SCC_MODULE)
+static struct platform_device mxc_scc_device = {
+	.name = "mxc_scc",
+	.id = 0,
+};
+
+static void mxc_init_scc(void)
+{
+	platform_device_register(&mxc_scc_device);
+}
+#else
+static inline void mxc_init_scc(void)
+{
+}
+#endif
+
+/* SPI controller and device data */
+#if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
+
+#ifdef CONFIG_SPI_MXC_SELECT1
+/*!
+ * Resource definition for the CSPI1
+ */
+static struct resource mxcspi1_resources[] = {
+	[0] = {
+	       .start = CSPI1_BASE_ADDR,
+	       .end = CSPI1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_CSPI1,
+	       .end = MXC_INT_CSPI1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI1 */
+static struct mxc_spi_master mxcspi1_data = {
+	.maxchipselect = 4,
+	.spi_version = 23,
+};
+
+/*! Device Definition for MXC CSPI1 */
+static struct platform_device mxcspi1_device = {
+	.name = "mxc_spi",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi1_resources),
+	.resource = mxcspi1_resources,
+};
+
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+
+#ifdef CONFIG_SPI_MXC_SELECT2
+/*!
+ * Resource definition for the CSPI2
+ */
+static struct resource mxcspi2_resources[] = {
+	[0] = {
+	       .start = CSPI2_BASE_ADDR,
+	       .end = CSPI2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_CSPI2,
+	       .end = MXC_INT_CSPI2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI2 */
+static struct mxc_spi_master mxcspi2_data = {
+	.maxchipselect = 4,
+	.spi_version = 23,
+};
+
+/*! Device Definition for MXC CSPI2 */
+static struct platform_device mxcspi2_device = {
+	.name = "mxc_spi",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi2_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi2_resources),
+	.resource = mxcspi2_resources,
+};
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+
+#ifdef CONFIG_SPI_MXC_SELECT3
+/*!
+ * Resource definition for the CSPI3
+ */
+static struct resource mxcspi3_resources[] = {
+	[0] = {
+	       .start = CSPI3_BASE_ADDR,
+	       .end = CSPI3_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_CSPI3,
+	       .end = MXC_INT_CSPI3,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI3 */
+static struct mxc_spi_master mxcspi3_data = {
+	.maxchipselect = 4,
+	.spi_version = 23,
+};
+
+/*! Device Definition for MXC CSPI3 */
+static struct platform_device mxcspi3_device = {
+	.name = "mxc_spi",
+	.id = 2,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi3_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi3_resources),
+	.resource = mxcspi3_resources,
+};
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
+
+void __init mxc_init_spi(void)
+{
+	/* SPBA configuration for CSPI2 - MCU is set */
+	spba_take_ownership(SPBA_CSPI2, SPBA_MASTER_A);
+#ifdef CONFIG_SPI_MXC_SELECT1
+	if (platform_device_register(&mxcspi1_device) < 0)
+		printk("Error: Registering the SPI Controller_1\n");
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+#ifdef CONFIG_SPI_MXC_SELECT2
+	if (platform_device_register(&mxcspi2_device) < 0)
+		printk("Error: Registering the SPI Controller_2\n");
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+#ifdef CONFIG_SPI_MXC_SELECT3
+	if (platform_device_register(&mxcspi3_device) < 0)
+		printk("Error: Registering the SPI Controller_3\n");
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
+}
+#else
+void __init mxc_init_spi(void)
+{
+}
+#endif
+
+/* I2C controller and device data */
+#if defined(CONFIG_I2C_MXC) || defined(CONFIG_I2C_MXC_MODULE)
+
+#ifdef CONFIG_I2C_MXC_SELECT1
+/*!
+ * Resource definition for the I2C1
+ */
+static struct resource mxci2c1_resources[] = {
+	[0] = {
+	       .start = I2C_BASE_ADDR,
+	       .end = I2C_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_I2C,
+	       .end = MXC_INT_I2C,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c1_data = {
+	.i2c_clk = 100000,
+};
+#endif
+
+#ifdef CONFIG_I2C_MXC_SELECT2
+/*!
+ * Resource definition for the I2C2
+ */
+static struct resource mxci2c2_resources[] = {
+	[0] = {
+	       .start = I2C2_BASE_ADDR,
+	       .end = I2C2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_I2C2,
+	       .end = MXC_INT_I2C2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c2_data = {
+	.i2c_clk = 100000,
+};
+#endif
+
+#ifdef CONFIG_I2C_MXC_SELECT3
+/*!
+ * Resource definition for the I2C3
+ */
+static struct resource mxci2c3_resources[] = {
+	[0] = {
+	       .start = I2C3_BASE_ADDR,
+	       .end = I2C3_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_I2C3,
+	       .end = MXC_INT_I2C3,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c3_data = {
+	.i2c_clk = 100000,
+};
+#endif
+
+/*! Device Definition for MXC I2C1 */
+static struct platform_device mxci2c_devices[] = {
+#ifdef CONFIG_I2C_MXC_SELECT1
+	{
+	 .name = "mxc_i2c",
+	 .id = 0,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = &mxci2c1_data,
+		 },
+	 .num_resources = ARRAY_SIZE(mxci2c1_resources),
+	 .resource = mxci2c1_resources,},
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT2
+	{
+	 .name = "mxc_i2c",
+	 .id = 1,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = &mxci2c2_data,
+		 },
+	 .num_resources = ARRAY_SIZE(mxci2c2_resources),
+	 .resource = mxci2c2_resources,},
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT3
+	{
+	 .name = "mxc_i2c",
+	 .id = 2,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = &mxci2c3_data,
+		 },
+	 .num_resources = ARRAY_SIZE(mxci2c3_resources),
+	 .resource = mxci2c3_resources,},
+#endif
+};
+
+static inline void mxc_init_i2c(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mxci2c_devices); i++) {
+		if (platform_device_register(&mxci2c_devices[i]) < 0)
+			dev_err(&mxci2c_devices[i].dev,
+				"Unable to register I2C device\n");
+	}
+}
+#else
+static inline void mxc_init_i2c(void)
+{
+}
+#endif
+
+struct mxc_gpio_port mxc_gpio_ports[GPIO_PORT_NUM] = {
+	{
+	 .num = 0,
+	 .base = IO_ADDRESS(GPIO1_BASE_ADDR),
+	 .irq_0_15 = MXC_INT_GPIO1_LOW,
+	 .irq_16_31 = MXC_INT_GPIO1_HIGH,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE,
+	 },
+	{
+	 .num = 1,
+	 .base = IO_ADDRESS(GPIO2_BASE_ADDR),
+	 .irq_0_15 = MXC_INT_GPIO2_LOW,
+	 .irq_16_31 = MXC_INT_GPIO2_HIGH,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 1,
+	 },
+	{
+	 .num = 2,
+	 .base = IO_ADDRESS(GPIO3_BASE_ADDR),
+	 .irq_0_15 = MXC_INT_GPIO3_LOW,
+	 .irq_16_31 = MXC_INT_GPIO3_HIGH,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 2,
+	 },
+};
+
+static struct platform_device mxc_dma_device = {
+	.name = "mxc_dma",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+};
+
+static inline void mxc_init_dma(void)
+{
+	(void)platform_device_register(&mxc_dma_device);
+}
+
+static int __init mxc_init_devices(void)
+{
+	mxc_init_wdt();
+	mxc_init_ipu();
+	mxc_init_spi();
+	mxc_init_i2c();
+	mxc_init_rtc();
+	mxc_init_owire();
+	mxc_init_scc();
+	mxc_init_ssi();
+	mxc_init_dma();
+	mxc_init_audio();
+
+	/* SPBA configuration for SSI2 - SDMA and MCU are set */
+	spba_take_ownership(SPBA_SSI2, SPBA_MASTER_C | SPBA_MASTER_A);
+	return 0;
+}
+
+arch_initcall(mxc_init_devices);
diff --git a/arch/arm/mach-mx37/dma.c b/arch/arm/mach-mx37/dma.c
new file mode 100644
index 0000000..548fb9c
--- /dev/null
+++ b/arch/arm/mach-mx37/dma.c
@@ -0,0 +1,561 @@
+/*
+ *  Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/dma.h>
+#include <asm/arch/hardware.h>
+
+#include "serial.h"
+
+#define MXC_SSI_TX0_REG           0x0
+#define MXC_SSI_TX1_REG           0x4
+#define MXC_SSI_RX0_REG           0x8
+#define MXC_SSI_RX1_REG           0xC
+#define MXC_SSI_TXFIFO_WML        0x4
+#define MXC_SSI_RXFIFO_WML        0x6
+
+typedef struct mxc_sdma_info_entry_s {
+	mxc_dma_device_t device;
+	mxc_sdma_channel_params_t *chnl_info;
+} mxc_sdma_info_entry_t;
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_RXTL,
+			.per_address = UART1_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART1_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_TXTL,
+			.per_address = UART1_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART1_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_RXTL,
+			.per_address = UART2_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART2_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_TXTL,
+			.per_address = UART2_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART2_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_RXTL,
+			.per_address = UART3_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART3_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_TXTL,
+			.per_address = UART3_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART3_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
+	.chnl_params = {
+			.peripheral_type = MEMORY,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MEMORY,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = ATA_DMA_BASE_ADDR,
+			.peripheral_type = ATA,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ATA_TX_END,
+			.event_id2 = DMA_REQ_ATA_RX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ATA_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = ATA_DMA_BASE_ADDR + 0x18,
+			.peripheral_type = ATA,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ATA_TX_END,
+			.event_id2 = DMA_REQ_ATA_TX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ATA_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+static mxc_sdma_info_entry_t mxc_sdma_active_dma_info[] = {
+	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
+	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
+	{MXC_DMA_UART2_RX, &mxc_sdma_uart2_rx_params},
+	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
+	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
+	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_SSI1_8BIT_RX0, &mxc_sdma_ssi1_8bit_rx0_params},
+	{MXC_DMA_SSI1_8BIT_TX0, &mxc_sdma_ssi1_8bit_tx0_params},
+	{MXC_DMA_SSI1_16BIT_RX0, &mxc_sdma_ssi1_16bit_rx0_params},
+	{MXC_DMA_SSI1_16BIT_TX0, &mxc_sdma_ssi1_16bit_tx0_params},
+	{MXC_DMA_SSI1_24BIT_RX0, &mxc_sdma_ssi1_24bit_rx0_params},
+	{MXC_DMA_SSI1_24BIT_TX0, &mxc_sdma_ssi1_24bit_tx0_params},
+	{MXC_DMA_SSI1_8BIT_RX1, &mxc_sdma_ssi1_8bit_rx1_params},
+	{MXC_DMA_SSI1_8BIT_TX1, &mxc_sdma_ssi1_8bit_tx1_params},
+	{MXC_DMA_SSI1_16BIT_RX1, &mxc_sdma_ssi1_16bit_rx1_params},
+	{MXC_DMA_SSI1_16BIT_TX1, &mxc_sdma_ssi1_16bit_tx1_params},
+	{MXC_DMA_SSI1_24BIT_RX1, &mxc_sdma_ssi1_24bit_rx1_params},
+	{MXC_DMA_SSI1_24BIT_TX1, &mxc_sdma_ssi1_24bit_tx1_params},
+	{MXC_DMA_SSI2_8BIT_RX0, &mxc_sdma_ssi2_8bit_rx0_params},
+	{MXC_DMA_SSI2_8BIT_TX0, &mxc_sdma_ssi2_8bit_tx0_params},
+	{MXC_DMA_SSI2_16BIT_RX0, &mxc_sdma_ssi2_16bit_rx0_params},
+	{MXC_DMA_SSI2_16BIT_TX0, &mxc_sdma_ssi2_16bit_tx0_params},
+	{MXC_DMA_SSI2_24BIT_RX0, &mxc_sdma_ssi2_24bit_rx0_params},
+	{MXC_DMA_SSI2_24BIT_TX0, &mxc_sdma_ssi2_24bit_tx0_params},
+	{MXC_DMA_SSI2_8BIT_RX1, &mxc_sdma_ssi2_8bit_rx1_params},
+	{MXC_DMA_SSI2_8BIT_TX1, &mxc_sdma_ssi2_8bit_tx1_params},
+	{MXC_DMA_SSI2_16BIT_RX1, &mxc_sdma_ssi2_16bit_rx1_params},
+	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
+	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
+	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
+	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
+	{MXC_DMA_ATA_RX, &mxc_sdma_ata_rx_params},
+	{MXC_DMA_ATA_TX, &mxc_sdma_ata_tx_params},
+};
+
+static int mxc_sdma_info_entrys =
+    sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
+
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id)
+{
+	mxc_sdma_info_entry_t *p = mxc_sdma_active_dma_info;
+	int i;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		if (p->device == channel_id) {
+			return p->chnl_info;
+		}
+	}
+	return NULL;
+}
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t * chnl)
+{
+	/* No channels statically allocated for MX37 */
+}
+
+EXPORT_SYMBOL(mxc_sdma_get_channel_params);
+EXPORT_SYMBOL(mxc_get_static_channels);
diff --git a/arch/arm/mach-mx37/iomux.c b/arch/arm/mach-mx37/iomux.c
new file mode 100644
index 0000000..ed4607b
--- /dev/null
+++ b/arch/arm/mach-mx37/iomux.c
@@ -0,0 +1,204 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup GPIO_MX37 Board GPIO and Muxing Setup
+ * @ingroup MSL_MX37
+ */
+/*!
+ * @file mach-mx37/iomux.c
+ *
+ * @brief I/O Muxing control functions
+ *
+ * @ingroup GPIO_MX37
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/hardware.h>
+#include <asm/arch/gpio.h>
+#include "iomux.h"
+
+/*!
+ * IOMUX register (base) addresses
+ */
+enum iomux_reg_addr {
+	IOMUXGPR0 = IO_ADDRESS(IOMUXC_BASE_ADDR),	/*!< General purpose 0 */
+	IOMUXGPR1 = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x004,	/*!< General purpose 1 */
+	IOMUXSW_MUX_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + MUX_I_START,	/*!< MUX control */
+	IOMUXSW_MUX_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + PAD_I_END,	/*!< last MUX control register */
+	IOMUXSW_PAD_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + PAD_I_START,	/*!< Pad control */
+	IOMUXSW_PAD_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + PAD_I_END,	/*!< last Pad control register */
+	IOMUXSW_INPUT_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + INPUT_CTL_START,	/*!< input select register */
+	IOMUXSW_INPUT_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + INPUT_CTL_END,	/*!< last input select register */
+};
+
+#define MUX_PIN_NUM_MAX		(((IOMUXSW_MUX_END - IOMUXSW_MUX_CTL) >> 2) + 1)
+#define MUX_INPUT_NUM_MUX	(((IOMUXSW_INPUT_END - IOMUXSW_INPUT_CTL) >> 2) + 1)
+
+static u8 iomux_pin_res_table[MUX_PIN_NUM_MAX];
+static DEFINE_SPINLOCK(gpio_mux_lock);
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  config	a configuration as defined in \b #iomux_pin_cfg_t
+ *
+ * @return 		0 if successful; Non-zero otherwise
+ */
+static int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_cfg_t config)
+{
+	u32 ret = 0;
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	u32 mux_reg = IOMUXSW_MUX_CTL + PIN_TO_IOMUX_MUX(pin);
+	u32 mux_data = 0;
+	u8 *rp;
+
+	BUG_ON((mux_reg > IOMUXSW_MUX_END) || (mux_reg < IOMUXSW_MUX_CTL));
+	spin_lock(&gpio_mux_lock);
+
+	if (config == IOMUX_CONFIG_GPIO) {
+		mux_data = PIN_TO_ALT_GPIO(pin);
+	} else {
+		mux_data = config;
+	}
+
+	__raw_writel(mux_data, mux_reg);
+
+	/*
+	 * Log a warning if a pin changes ownership
+	 */
+	rp = iomux_pin_res_table + pin_index;
+	if ((mux_data & *rp) && (*rp != mux_data)) {
+		/*
+		 * Don't call printk if we're tweaking the console uart or
+		 * we'll deadlock.
+		 */
+		printk(KERN_ERR "iomux_config_mux: Warning: iomux pin"
+		       " config changed, pin=%d, "
+		       " prev=0x%x new=0x%x\n", mux_reg, *rp, mux_data);
+		ret = -EINVAL;
+	}
+	*rp = mux_data;
+	spin_unlock(&gpio_mux_lock);
+	return ret;
+}
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	a configuration as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config)
+{
+	int ret = iomux_config_mux(pin, config);
+	int gpio_port = GPIO_TO_PORT(IOMUX_TO_GPIO(pin));
+
+	if (!ret && (gpio_port != NON_GPIO_PORT)
+	    && ((config == IOMUX_CONFIG_GPIO)
+		|| (config == PIN_TO_ALT_GPIO(pin)))) {
+		ret |= mxc_request_gpio(pin);
+	}
+	return ret;
+}
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	config as defined in \b #iomux_pin_ocfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config)
+{
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	u8 *rp = iomux_pin_res_table + pin_index;
+	int gpio_port = GPIO_TO_PORT(IOMUX_TO_GPIO(pin));
+
+	BUG_ON(pin_index > MUX_PIN_NUM_MAX);
+	*rp = 0;
+	if ((gpio_port != NON_GPIO_PORT)
+	    && ((config == IOMUX_CONFIG_GPIO)
+		|| (config == PIN_TO_ALT_GPIO(pin)))) {
+		mxc_free_gpio(pin);
+	}
+}
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
+{
+	u32 pad_reg = IOMUXSW_PAD_CTL + PIN_TO_IOMUX_PAD(pin);
+
+	BUG_ON((pad_reg > IOMUXSW_PAD_END) || (pad_reg < IOMUXSW_PAD_CTL));
+	spin_lock(&gpio_mux_lock);
+	__raw_writel(config, pad_reg);
+	spin_unlock(&gpio_mux_lock);
+}
+
+unsigned int mxc_iomux_get_pad(iomux_pin_name_t pin)
+{
+	volatile u32 pad_reg = IOMUXSW_PAD_CTL + PIN_TO_IOMUX_PAD(pin);
+	return __raw_readl(pad_reg);
+}
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp     one signal as defined in \b #iomux_gp_func_t
+ * @param  en     \b #true to enable; \b #false to disable
+ * @param  index  0 for GPR0 and 1 for GPR1
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en, u8 index)
+{
+	volatile u32 l;
+
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(IOMUXGPR0 + (index << 2));
+	if (en) {
+		l |= gp;
+	} else {
+		l &= ~gp;
+	}
+	__raw_writel(l, IOMUXGPR0 + (index << 2));
+	spin_unlock(&gpio_mux_lock);
+}
+
+/*!
+ * This function configures input path.
+ *
+ * @param  input        index of input select register as defined in \b #iomux_input_select_t
+ * @param  config       the binary value of elements defined in \b #iomux_input_config_t
+ *      */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config)
+{
+	u32 reg = IOMUXSW_INPUT_CTL + (input << 2);
+
+	BUG_ON(input >= MUX_INPUT_NUM_MUX);
+	__raw_writel(config, reg);
+}
+
+EXPORT_SYMBOL(mxc_request_iomux);
+EXPORT_SYMBOL(mxc_free_iomux);
+EXPORT_SYMBOL(mxc_iomux_set_input);
+EXPORT_SYMBOL(mxc_iomux_set_pad);
+EXPORT_SYMBOL(mxc_iomux_set_gpr);
diff --git a/arch/arm/mach-mx37/iomux.h b/arch/arm/mach-mx37/iomux.h
new file mode 100644
index 0000000..1440323
--- /dev/null
+++ b/arch/arm/mach-mx37/iomux.h
@@ -0,0 +1,224 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MACH_MX37_IOMUX_H__
+#define __MACH_MX37_IOMUX_H__
+
+#include <linux/types.h>
+
+/*!
+ * @file mach-mx37/iomux.h
+ *
+ * @brief I/O Muxing control definitions and functions
+ *
+ * @ingroup GPIO_MX37
+ */
+
+/*!
+ * various IOMUX output functions
+ */
+typedef enum iomux_config {
+	IOMUX_CONFIG_ALT0,	/*!< used as alternate function 0 */
+	IOMUX_CONFIG_ALT1,	/*!< used as alternate function 1 */
+	IOMUX_CONFIG_ALT2,	/*!< used as alternate function 2 */
+	IOMUX_CONFIG_ALT3,	/*!< used as alternate function 3 */
+	IOMUX_CONFIG_ALT4,	/*!< used as alternate function 4 */
+	IOMUX_CONFIG_ALT5,	/*!< used as alternate function 5 */
+	IOMUX_CONFIG_ALT6,	/*!< used as alternate function 6 */
+	IOMUX_CONFIG_ALT7,	/*!< used as alternate function 7 */
+	IOMUX_CONFIG_GPIO,	/*!< added to help user use GPIO mode */
+	IOMUX_CONFIG_SION = 0x1 << 4,	/*!< used as LOOPBACK:MUX SION bit */
+} iomux_pin_cfg_t;
+
+/*!
+ * various IOMUX pad functions
+ */
+typedef enum iomux_pad_config {
+	PAD_CTL_SRE_SLOW = 0x0 << 0,
+	PAD_CTL_SRE_FAST = 0x1 << 0,
+	PAD_CTL_DRV_LOW = 0x0 << 1,
+	PAD_CTL_DRV_MEDIUM = 0x1 << 1,
+	PAD_CTL_DRV_HIGH = 0x2 << 1,
+	PAD_CTL_DRV_MAX = 0x3 << 1,
+	PAD_CTL_ODE_OPENDRAIN_NONE = 0x0 << 3,
+	PAD_CTL_ODE_OPENDRAIN_ENABLE = 0x1 << 3,
+	PAD_CTL_100K_PD = 0x0 << 4,
+	PAD_CTL_47K_PU = 0x1 << 4,
+	PAD_CTL_100K_PU = 0x2 << 4,
+	PAD_CTL_22K_PU = 0x3 << 4,
+	PAD_CTL_PUE_KEEPER = 0x0 << 6,
+	PAD_CTL_PUE_PULL = 0x1 << 6,
+	PAD_CTL_PKE_NONE = 0x0 << 7,
+	PAD_CTL_PKE_ENABLE = 0x1 << 7,
+	PAD_CTL_HYS_NONE = 0x0 << 8,
+	PAD_CTL_HYS_ENABLE = 0x1 << 8,
+	PAD_CTL_DDR_INPUT_CMOS = 0x0 << 9,
+	PAD_CTL_DDR_INPUT_DDR = 0x1 << 9,
+	PAD_CTL_DRV_VOT_LOW = 0x0 << 13,
+	PAD_CTL_DRV_VOT_HIGH = 0x1 << 13,
+} iomux_pad_config_t;
+
+/*!
+ * various IOMUX general purpose functions
+ */
+typedef enum iomux_gp_func {
+	MUX_IPD_ESDHC_DREQ_B = 0x0 << 0,
+	MUX_XDRQ = 0x1 << 0,
+	MUX_EMI_DMA_ACCESS_1 = 0x0 << 4,
+	MUX_KEY_COL2 = 0x1 << 4,
+	MUX_TAMPER_DETECT_EN = 0x1 << 8,
+	MUX_IPUv3D_TVE = 0x0 << 12,
+	MUX_IPUv3D_CAMP = 0x1 << 12,
+} iomux_gp_func_t;
+
+/*!
+ * various IOMUX input select register index
+ */
+typedef enum iomux_input_select {
+	MUX_IN_CCM_PLL1_BYPASS_CLK = 0,
+	MUX_IN_CCM_PLL2_BYPASS_CLK,
+	MUX_IN_CCM_PLL3_BYPASS_CLK,
+	MUX_IN_CSPI3_CSPI_CLK,
+	MUX_IN_CSPI3_MISO,
+	MUX_IN_CSPI3_MOSI,
+	MUX_IN_EMI_READ_MADDR_DATA_0,
+	MUX_IN_EMI_READ_MADDR_DATA_10,
+	MUX_IN_EMI_READ_MADDR_DATA_11,
+	MUX_IN_EMI_READ_MADDR_DATA_12,
+	MUX_IN_EMI_READ_MADDR_DATA_13,
+	MUX_IN_EMI_READ_MADDR_DATA_14,
+	MUX_IN_EMI_READ_MADDR_DATA_15,
+	MUX_IN_EMI_READ_MADDR_DATA_1,
+	MUX_IN_EMI_READ_MADDR_DATA_2,
+	MUX_IN_EMI_READ_MADDR_DATA_3,
+	MUX_IN_EMI_READ_MADDR_DATA_4,
+	MUX_IN_EMI_READ_MADDR_DATA_5,
+	MUX_IN_EMI_READ_MADDR_DATA_6,
+	MUX_IN_EMI_READ_MADDR_DATA_7,
+	MUX_IN_EMI_READ_MADDR_DATA_8,
+	MUX_IN_EMI_READ_MADDR_DATA_9,
+	MUX_IN_EMI_NFC_READ_DATA_IN_0,
+	MUX_IN_EMI_NFC_READ_DATA_IN_10,
+	MUX_IN_EMI_NFC_READ_DATA_IN_11,
+	MUX_IN_EMI_NFC_READ_DATA_IN_12,
+	MUX_IN_EMI_NFC_READ_DATA_IN_13,
+	MUX_IN_EMI_NFC_READ_DATA_IN_14,
+	MUX_IN_EMI_NFC_READ_DATA_IN_15,
+	MUX_IN_EMI_NFC_READ_DATA_IN_1,
+	MUX_IN_EMI_NFC_READ_DATA_IN_2,
+	MUX_IN_EMI_NFC_READ_DATA_IN_3,
+	MUX_IN_EMI_NFC_READ_DATA_IN_4,
+	MUX_IN_EMI_NFC_READ_DATA_IN_5,
+	MUX_IN_EMI_NFC_READ_DATA_IN_6,
+	MUX_IN_EMI_NFC_READ_DATA_IN_7,
+	MUX_IN_EMI_NFC_READ_DATA_IN_8,
+	MUX_IN_EMI_NFC_READ_DATA_IN_9,
+	MUX_IN_FEC_FEC_COL,
+	MUX_IN_FEC_FEC_CRS, MUX_IN_FEC_FEC_MDI,
+	MUX_IN_FEC_FEC_RDATA_0,
+	MUX_IN_FEC_FEC_RX_CLK,
+	MUX_IN_FEC_FEC_RX_DV,
+	MUX_IN_FEC_FEC_RX_ER,
+	MUX_IN_FEC_FEC_TX_CLK,
+	MUX_IN_I2C1_SCL,
+	MUX_IN_I2C1_SDA,
+	MUX_IN_I2C2_SCL,
+	MUX_IN_I2C2_SDA,
+	MUX_IN_I2C3_SCL,
+	MUX_IN_I2C3_SDA,
+	MUX_IN_IPU_DI_0_IND_DISPB_D0_VSYNC,
+	MUX_IN__IPU_DI_0_IND_DISPB_SD_D,
+	MUX_IN_KPP_ROW_0,
+	MUX_IN_KPP_ROW_1,
+	MUX_IN_KPP_ROW_2,
+	MUX_IN_KPP_ROW_3,
+	MUX_IN_KPP_ROW_4,
+	MUX_IN_KPP_ROW_5,
+	MUX_IN_KPP_ROW_6,
+	MUX_IN_KPP_ROW_7,
+	MUX_IN_UART1_UART_RTS_B,
+	MUX_IN_UART1_UART_RXD_MUX,
+	MUX_IN_UART2_UART_RTS_B,
+	MUX_IN_UART2_UART_RXD_MUX,
+	MUX_IN_UART3_UART_RTS_B,
+	MUX_IN_UART3_UART_RXD_MUX,
+} iomux_input_select_t;
+
+/*!
+ * various IOMUX input functions
+ */
+typedef enum iomux_input_config {
+	INPUT_CTL_PATH0 = 0x0,
+	INPUT_CTL_PATH1,
+	INPUT_CTL_PATH2,
+	INPUT_CTL_PATH3,
+	INPUT_CTL_PATH4,
+	INPUT_CTL_PATH5,
+	INPUT_CTL_PATH6,
+	INPUT_CTL_PATH7,
+} iomux_input_config_t;
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	config as defined in \b #iomux_pin_ocfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	config as defined in \b #iomux_pin_ocfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ * @param  index  0 for GPR0 and 1 for GPR1
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en, u8 index);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config);
+
+/*!
+ * This function gets the current pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @return		current pad value
+ */
+unsigned int mxc_iomux_get_pad(iomux_pin_name_t pin);
+
+/*!
+ * This function configures input path.
+ *
+ * @param  input        index of input select register as defined in \b #iomux_input_select_t
+ * @param  config       the binary value of elements defined in \b #iomux_input_config_t
+ */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config);
+
+#endif				/*  __MACH_MX37_IOMUX_H__ */
diff --git a/arch/arm/mach-mx37/mm.c b/arch/arm/mach-mx37/mm.c
new file mode 100644
index 0000000..61122ed
--- /dev/null
+++ b/arch/arm/mach-mx37/mm.c
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License.  You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <asm/hardware.h>
+#include <asm/pgtable.h>
+#include <asm/mach/map.h>
+
+/*!
+ * @file mach-mx37/mm.c
+ *
+ * @brief This file creates static mapping between physical to virtual memory.
+ *
+ * @ingroup Memory_MX37
+ */
+
+/*!
+ * This structure defines the MX37 memory map.
+ */
+static struct map_desc mxc_io_desc[] __initdata = {
+	{
+	 .virtual = IRAM_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(IRAM_BASE_ADDR),
+	 .length = IRAM_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = PLATFORM_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(PLATFORM_BASE_ADDR),
+	 .length = PLATFORM_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = DEBUG_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(DEBUG_BASE_ADDR),
+	 .length = DEBUG_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = TZIC_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(TZIC_BASE_ADDR),
+	 .length = TZIC_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = AIPS1_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPS1_BASE_ADDR),
+	 .length = AIPS1_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = SPBA0_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(SPBA0_BASE_ADDR),
+	 .length = SPBA0_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = AIPS2_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPS2_BASE_ADDR),
+	 .length = AIPS2_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = NFC_BASE_ADDR_AXI_VIRT,
+	 .pfn = __phys_to_pfn(NFC_BASE_ADDR_AXI),
+	 .length = NFC_AXI_SIZE,
+	 .type = MT_DEVICE},
+};
+
+/*!
+ * This function initializes the memory map. It is called during the
+ * system startup to create static physical to virtual memory map for
+ * the IO modules.
+ */
+void __init mxc_map_io(void)
+{
+	iotable_init(mxc_io_desc, ARRAY_SIZE(mxc_io_desc));
+}
diff --git a/arch/arm/mach-mx37/mx37_3stack.c b/arch/arm/mach-mx37/mx37_3stack.c
new file mode 100644
index 0000000..c2066ae
--- /dev/null
+++ b/arch/arm/mach-mx37/mx37_3stack.c
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/flash.h>
+#endif
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/keypad.h>
+#include <asm/arch/memory.h>
+#include <asm/arch/gpio.h>
+
+#include "board-mx37_3stack.h"
+#include "crm_regs.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx37/mx37_3stack.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX37
+ */
+
+extern void mxc_map_io(void);
+extern void mxc_init_irq(void);
+extern void mxc_cpu_init(void) __init;
+extern struct sys_timer mxc_timer;
+extern void mxc_cpu_common_init(void);
+extern int mxc_clocks_init(void);
+extern void __init early_console_setup(char *);
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+unsigned long board_get_ckih_rate(void)
+{
+	return 24000000;
+}
+
+/* MTD NAND flash */
+#if defined(CONFIG_MTD_NAND_MXC) || defined(CONFIG_MTD_NAND_MXC_MODULE) \
+	|| defined(CONFIG_MTD_NAND_MXC_V2) || defined(CONFIG_MTD_NAND_MXC_V2_MODULE) \
+	|| defined(CONFIG_MTD_NAND_MXC_V3)
+
+static struct mtd_partition mxc_nand_partitions[4] = {
+	{
+	 .name = "IPL-SPL",
+	 .offset = 0,
+	 .size = 2 * 1024 * 1024},
+	{
+	 .name = "nand.kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 4 * 1024 * 1024},
+	{
+	 .name = "nand.rootfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 128 * 1024 * 1024},
+	{
+	 .name = "nand.userfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL},
+};
+
+static struct flash_platform_data mxc_nand_data = {
+	.parts = mxc_nand_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nand_partitions),
+	.width = 1,
+};
+
+static struct platform_device mxc_nandv2_mtd_device = {
+	.name = "mxc_nandv2_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_nand_data,
+		},
+};
+
+static void mxc_init_nand_mtd(void)
+{
+//      if (__raw_readl(MXC_CCM_RCSR) & MXC_CCM_RCSR_NF16B) {
+//              mxc_nand_data.width = 2;
+//      }
+	(void)platform_device_register(&mxc_nandv2_mtd_device);
+}
+#else
+static inline void mxc_init_nand_mtd(void)
+{
+}
+#endif
+
+static struct spi_board_info mxc_spi_board_info[] __initdata = {
+	{
+	 .modalias = "cpld_spi",
+	 .max_speed_hz = 18000000,
+	 .bus_num = 2,
+	 .chip_select = 0,
+	 },
+	{
+	 .modalias = "lcd_spi",
+	 .max_speed_hz = 500000,
+	 .bus_num = 1,
+	 .chip_select = 2,},
+};
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	mxc_cpu_init();
+
+#ifdef CONFIG_DISCONTIGMEM
+	do {
+		int nid;
+		mi->nr_banks = MXC_NUMNODES;
+		for (nid = 0; nid < mi->nr_banks; nid++) {
+			SET_NODE(mi, nid);
+		}
+	} while (0);
+#endif
+}
+
+/*! PMIC */
+static struct platform_device pmic_device = {
+	.name = "wm8350-imx37-3stack",
+	.id = 0,
+};
+
+static inline void mxc_init_pmic(void)
+{
+	if (platform_device_register(&pmic_device) < 0)
+		printk(KERN_ERR "Error: Registering the PMIC.\n");
+
+}
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	mxc_cpu_common_init();
+	mxc_clocks_init();
+	mxc_gpio_init();
+	early_console_setup(saved_command_line);
+
+	spi_register_board_info(mxc_spi_board_info,
+				ARRAY_SIZE(mxc_spi_board_info));
+	mxc_init_nand_mtd();
+	mxc_init_pmic();
+}
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX37_3STACK data structure.
+ */
+/* *INDENT-OFF* */
+MACHINE_START(MX37_3DS, "Freescale MX37 3-Stack Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.phys_io = AIPS1_BASE_ADDR,
+	.io_pg_offst = ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params = PHYS_OFFSET + 0x100,
+	.fixup = fixup_mxc_board,
+	.map_io = mxc_map_io,
+	.init_irq = mxc_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx37/mx37_3stack_gpio.c b/arch/arm/mach-mx37/mx37_3stack_gpio.c
new file mode 100644
index 0000000..9db225e
--- /dev/null
+++ b/arch/arm/mach-mx37/mx37_3stack_gpio.c
@@ -0,0 +1,451 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/gpio.h>
+#include "iomux.h"
+
+/*!
+ * @file mx31ads_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO
+ */
+
+void gpio_activate_audio_ports(void);
+
+/*!
+ * Setup GPIO for a UART port to be active
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_active(int port, int no_irda)
+{
+	/*
+	 * Configure the IOMUX control registers for the UART signals
+	 * and enable the UART transceivers
+	 */
+	switch (port) {
+		/* UART 1 IOMUX Configs */
+	case 0:
+		mxc_request_iomux(MX37_PIN_UART1_RXD, IOMUX_CONFIG_ALT0);
+		mxc_iomux_set_pad(MX37_PIN_UART1_RXD, PAD_CTL_HYS_ENABLE |
+				  PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+				  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST);
+		mxc_iomux_set_input(MUX_IN_UART1_UART_RXD_MUX, INPUT_CTL_PATH4);
+		mxc_request_iomux(MX37_PIN_UART1_TXD, IOMUX_CONFIG_ALT0);
+		mxc_iomux_set_pad(MX37_PIN_UART1_TXD, PAD_CTL_HYS_ENABLE |
+				  PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+				  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST);
+		mxc_request_iomux(MX37_PIN_UART1_RTS, IOMUX_CONFIG_ALT0);
+		mxc_iomux_set_pad(MX37_PIN_UART1_RTS, PAD_CTL_HYS_ENABLE |
+				  PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+				  PAD_CTL_DRV_HIGH);
+		mxc_iomux_set_input(MUX_IN_UART1_UART_RTS_B, INPUT_CTL_PATH4);
+		mxc_request_iomux(MX37_PIN_UART1_CTS, IOMUX_CONFIG_ALT0);
+		mxc_iomux_set_pad(MX37_PIN_UART1_CTS, PAD_CTL_HYS_ENABLE |
+				  PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+				  PAD_CTL_DRV_HIGH);
+		break;
+	case 1:
+		break;
+	case 2:
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for a UART port to be inactive
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_inactive(int port, int no_irda)
+{
+
+}
+
+/*!
+ * Configure the IOMUX GPR register to receive shared SDMA UART events
+ *
+ * @param  port         a UART port
+ */
+void config_uartdma_event(int port)
+{
+
+}
+
+EXPORT_SYMBOL(gpio_uart_active);
+EXPORT_SYMBOL(gpio_uart_inactive);
+EXPORT_SYMBOL(config_uartdma_event);
+
+/*!
+ * Setup GPIO for a CSPI device to be active
+ *
+ * @param  cspi_mod         an CSPI device
+ */
+void gpio_spi_active(int cspi_mod)
+{
+ /*TODO*/}
+
+/*!
+ * Setup GPIO for a CSPI device to be inactive
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_inactive(int cspi_mod)
+{
+ /*TODO*/}
+
+/*!
+ * Setup 1-Wire to be active
+ */
+void gpio_owire_active(void)
+{
+ /*TODO*/}
+
+/*!
+ * Setup 1-Wire to be active
+ */
+void gpio_owire_inactive(void)
+{
+ /*TODO*/}
+
+EXPORT_SYMBOL(gpio_owire_active);
+EXPORT_SYMBOL(gpio_owire_inactive);
+
+/*!
+ * Setup GPIO for an I2C device to be active
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_active(int i2c_num)
+{
+	iomux_pad_config_t regval = 0;
+	switch (i2c_num) {
+	case 0:
+		/* Touch */
+		/* select I2C1_SCK as daisy chain input */
+		mxc_iomux_set_input(MUX_IN_I2C1_SCL, INPUT_CTL_PATH1);
+		/* OpenDrain enabled, 100k PU enabled */
+		mxc_iomux_set_pad(MX37_PIN_I2C1_CLK,
+				  PAD_CTL_100K_PU |
+				  PAD_CTL_ODE_OPENDRAIN_ENABLE);
+		mxc_request_iomux(MX37_PIN_I2C1_CLK, IOMUX_CONFIG_ALT0);
+		/*select I2C1_SDA as daisy chain input */
+		mxc_iomux_set_input(MUX_IN_I2C1_SDA, INPUT_CTL_PATH1);
+		/* OpenDrain enabled, 100k PU enabled */
+		mxc_iomux_set_pad(MX37_PIN_I2C1_DAT,
+				  PAD_CTL_100K_PU |
+				  PAD_CTL_ODE_OPENDRAIN_ENABLE);
+		mxc_request_iomux(MX37_PIN_I2C1_DAT, IOMUX_CONFIG_ALT0);
+		break;
+	case 1:
+		/* PMIC */
+		/*select I2C2_SCL as daisy chain input */
+		mxc_iomux_set_input(MUX_IN_I2C2_SCL, INPUT_CTL_PATH1);
+		regval = PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE |
+		    PAD_CTL_PUE_PULL | PAD_CTL_100K_PU |
+		    PAD_CTL_ODE_OPENDRAIN_ENABLE | PAD_CTL_DRV_HIGH;
+		mxc_iomux_set_pad(MX37_PIN_GPIO1_0, regval);
+		mxc_request_iomux(MX37_PIN_GPIO1_0,
+				  (IOMUX_CONFIG_SION | IOMUX_CONFIG_ALT2));
+
+		/*select I2C2_SDA as daisy chain input */
+		mxc_iomux_set_input(MUX_IN_I2C2_SDA, INPUT_CTL_PATH1);
+		mxc_iomux_set_pad(MX37_PIN_GPIO1_1, regval);
+		mxc_request_iomux(MX37_PIN_GPIO1_1,
+				  (IOMUX_CONFIG_SION | IOMUX_CONFIG_ALT2));
+		break;
+	case 2:
+		//mxc_request_iomux(MX37_PIN_CSPI2_MOSI, CONFIG_ALT1); /* I2C3_SDA */
+		//mxc_request_iomux(MX37_PIN_CSPI2_SCLK, CONFIG_ALT1); /* I2C3_SCLK */
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for an I2C device to be inactive
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_inactive(int i2c_num)
+{
+ /*TODO*/}
+
+/*!
+ * This function activates DAM ports 4 & 5 to enable
+ * audio I/O.
+ */
+void gpio_activate_audio_ports(void)
+{
+	unsigned int pad_val;
+
+	/* AUD4_TXD */
+	mxc_request_iomux(MX37_PIN_DISP1_DAT20, IOMUX_CONFIG_ALT5);
+	/* AUD4_RXD */
+	mxc_request_iomux(MX37_PIN_DISP1_DAT21, IOMUX_CONFIG_ALT5);
+	/* AUD4_TXC */
+	mxc_request_iomux(MX37_PIN_DISP1_DAT22, IOMUX_CONFIG_ALT5);
+	/* AUD4_TXFS */
+	mxc_request_iomux(MX37_PIN_DISP1_DAT23, IOMUX_CONFIG_ALT5);
+
+	pad_val = PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	    PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST;
+	mxc_iomux_set_pad(MX37_PIN_AUD5_WB_CK, PAD_CTL_100K_PU | pad_val);
+	mxc_request_iomux(MX37_PIN_AUD5_WB_CK, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX37_PIN_AUD5_WB_RXD, pad_val);
+	mxc_request_iomux(MX37_PIN_AUD5_WB_RXD, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX37_PIN_AUD5_WB_TXD, pad_val);
+	mxc_request_iomux(MX37_PIN_AUD5_WB_TXD, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX37_PIN_AUD5_WB_FS, PAD_CTL_100K_PU | pad_val);
+	mxc_request_iomux(MX37_PIN_AUD5_WB_FS, IOMUX_CONFIG_ALT0);
+
+	pad_val = mxc_iomux_get_pad(MX37_PIN_GRP_H5);
+	/* Enable hysteresis for AUD5_WB_CK, AUD5_WB_RXD, AUD5_WB_TXD, AUD5_WB_FS */
+	pad_val |= PAD_CTL_HYS_ENABLE;
+	mxc_iomux_set_pad(MX37_PIN_GRP_H5, pad_val);
+
+}
+
+EXPORT_SYMBOL(gpio_activate_audio_ports);
+
+/*!
+ * Setup GPIO for SDHC to be active
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_active(int module)
+{
+
+}
+
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+/*!
+ * Setup GPIO for SDHC1 to be inactive
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_inactive(int module)
+{
+
+}
+
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+/*
+ * Probe for the card. If present the GPIO data would be set.
+ */
+int sdhc_get_card_det_status(struct device *dev)
+{
+	return 0;
+}
+
+EXPORT_SYMBOL(sdhc_get_card_det_status);
+
+/*
+ * Return the card detect pin.
+ */
+int sdhc_init_card_det(int id)
+{
+	return 0;
+}
+
+EXPORT_SYMBOL(sdhc_init_card_det);
+
+/*!
+ * Setup GPIO for LCD to be active
+ *
+ */
+void gpio_lcd_active(void)
+{
+ /*TODO*/}
+
+/*!
+ * Setup GPIO for LCD to be inactive
+ *
+ */
+void gpio_lcd_inactive(void)
+{
+ /*TODO*/}
+
+/*!
+ * Setup pins for SLCD to be active
+ *
+ */
+void slcd_gpio_config(void)
+{
+ /*TODO*/}
+
+/*!
+ * Switch to the specified sensor - MX33 ADS has two
+ *
+ */
+void gpio_sensor_select(int sensor)
+{
+ /*TODO*/}
+
+/*!
+ * Setup GPIO for sensor to be active
+ *
+ */
+void gpio_sensor_active(void)
+{
+ /*TODO*/}
+
+EXPORT_SYMBOL(gpio_sensor_active);
+
+/*!
+ * Setup GPIO for sensor to be inactive
+ *
+ */
+void gpio_sensor_inactive(void)
+{
+ /*TODO*/}
+
+EXPORT_SYMBOL(gpio_sensor_inactive);
+
+/*!
+ * Setup GPIO for ATA interface
+ *
+ */
+void gpio_ata_active(void)
+{
+ /*TODO*/}
+
+EXPORT_SYMBOL(gpio_ata_active);
+
+/*!
+ * Restore ATA interface pins to reset values
+ *
+ */
+void gpio_ata_inactive(void)
+{
+ /*TODO*/}
+
+EXPORT_SYMBOL(gpio_ata_inactive);
+
+/*
+ * USB Host 1
+ * pins conflict with SPI1, ATA, UART3
+ */
+int gpio_usbh1_active(void)
+{
+	 /*TODO*/ return 0;
+}
+
+EXPORT_SYMBOL(gpio_usbh1_active);
+
+void gpio_usbh1_inactive(void)
+{
+ /*TODO*/}
+
+EXPORT_SYMBOL(gpio_usbh1_inactive);
+
+/*
+ * USB Host 2
+ * pins conflict with UART5, PCMCIA
+ */
+int gpio_usbh2_active(void)
+{
+	 /*TODO*/ return 0;
+}
+
+EXPORT_SYMBOL(gpio_usbh2_active);
+
+void gpio_usbh2_inactive(void)
+{
+ /*TODO*/}
+
+EXPORT_SYMBOL(gpio_usbh2_inactive);
+
+/*
+ * USB OTG HS port
+ */
+int gpio_usbotg_hs_active(void)
+{
+	 /*TODO*/ return 0;
+}
+
+EXPORT_SYMBOL(gpio_usbotg_hs_active);
+
+void gpio_usbotg_hs_inactive(void)
+{
+ /*TODO*/}
+
+EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
+
+/*
+ * USB OTG FS port
+ */
+int gpio_usbotg_fs_active(void)
+{
+	 /*TODO*/ return 0;
+}
+
+EXPORT_SYMBOL(gpio_usbotg_fs_active);
+
+void gpio_usbotg_fs_inactive(void)
+{
+ /*TODO*/}
+
+EXPORT_SYMBOL(gpio_usbotg_fs_inactive);
+
+/*!
+ * Setup GPIO for PCMCIA interface
+ *
+ */
+void gpio_pcmcia_active(void)
+{
+ /*TODO*/}
+
+EXPORT_SYMBOL(gpio_pcmcia_active);
+
+/*!
+ * Setup GPIO for pcmcia to be inactive
+ */
+void gpio_pcmcia_inactive(void)
+{
+ /*TODO*/}
+
+EXPORT_SYMBOL(gpio_pcmcia_inactive);
+
+/*!
+ * Setup GPIO for fec to be active
+ */
+void gpio_fec_active(void)
+{
+ /*TODO*/}
+
+EXPORT_SYMBOL(gpio_fec_active);
+/*!
+ * Setup GPIO for fec to be inactive
+ */
+void gpio_fec_inactive(void)
+{
+ /*TODO*/}
+
+EXPORT_SYMBOL(gpio_fec_inactive);
diff --git a/arch/arm/mach-mx37/sdma_script_code.h b/arch/arm/mach-mx37/sdma_script_code.h
new file mode 100644
index 0000000..b7df382
--- /dev/null
+++ b/arch/arm/mach-mx37/sdma_script_code.h
@@ -0,0 +1,190 @@
+
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.  */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __SDMA_SCRIPT_CODE_H__
+#define __SDMA_SCRIPT_CODE_H__
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define start_ADDR	0
+#define start_SIZE	20
+
+#define core_ADDR	80
+#define core_SIZE	232
+
+#define common_ADDR	312
+#define common_SIZE	330
+
+#define ap_2_ap_ADDR	642
+#define ap_2_ap_SIZE	41
+
+#define app_2_mcu_ADDR	683
+#define app_2_mcu_SIZE	64
+
+#define mcu_2_app_ADDR	747
+#define mcu_2_app_SIZE	70
+
+#define uart_2_mcu_ADDR	817
+#define uart_2_mcu_SIZE	75
+
+#define shp_2_mcu_ADDR	892
+#define shp_2_mcu_SIZE	69
+
+#define mcu_2_shp_ADDR	961
+#define mcu_2_shp_SIZE	72
+
+#define uartsh_2_mcu_ADDR	1033
+#define uartsh_2_mcu_SIZE	69
+
+#define mcu_2_ata_ADDR	1102
+#define mcu_2_ata_SIZE	81
+
+#define ata_2_mcu_ADDR	1183
+#define ata_2_mcu_SIZE	96
+
+#define burstDMA__2__burstDMA_routine_ADDR	1279
+#define burstDMA__2__burstDMA_routine_SIZE	227
+
+#define test_ADDR	1506
+#define test_SIZE	63
+
+#define signature_ADDR	1023
+#define signature_SIZE	1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define dptc_dvfs_ADDR	6144
+#define dptc_dvfs_SIZE	270
+
+#define ext_mem__ipu_ram_ADDR	6414
+#define ext_mem__ipu_ram_SIZE	123
+
+#define mcu_2_mshc_ADDR	6537
+#define mcu_2_mshc_SIZE	54
+
+#define mcu_2_spdif_marley_ADDR	6591
+#define mcu_2_spdif_marley_SIZE	161
+
+#define mshc_2_mcu_ADDR	6752
+#define mshc_2_mcu_SIZE	66
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define RAM_CODE_START_ADDR		6144
+#define RAM_CODE_SIZE			674
+
+/*!
+* This function returns buffer that holds the image of SDMA RAM.
+* This is required to start on a 4-byte aligned boundary on some platforms
+* for SDMA to work properly.
+*
+* @return pointer to buffer that holds the image of SDMA RAM
+*/
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static const short sdma_code[] = {
+	0xc13c, 0x7d70, 0x0800, 0x0970, 0x0111, 0x5111, 0x5ac1, 0x5bc9,
+	0x028e, 0xc14e, 0x068a, 0x7c66, 0x5dd9, 0x5ce1, 0x0bff, 0x0311,
+	0x1bff, 0x03bc, 0x5bd1, 0x1a5c, 0x6ac3, 0x63c8, 0x0363, 0x7c05,
+	0x036f, 0x7d27, 0x0374, 0x7c76, 0x9874, 0xd907, 0x3c06, 0x4c00,
+	0x7df7, 0x028f, 0x1a04, 0x6a20, 0x620b, 0x6f20, 0x301f, 0x00aa,
+	0x0462, 0x7c04, 0x4a00, 0x7d0b, 0x2001, 0x9837, 0x048a, 0x620b,
+	0x2201, 0x1c01, 0x1801, 0x02dc, 0x7d02, 0x301f, 0x00aa, 0x048f,
+	0x1c04, 0x6c04, 0x0488, 0x3c1f, 0x6c2b, 0x0045, 0x028e, 0x1a5c,
+	0x9818, 0x058f, 0x1d0c, 0x6d20, 0x650b, 0x007d, 0x7c01, 0x1d08,
+	0x007c, 0x7c01, 0x1d04, 0x6d20, 0x650b, 0x0488, 0x3c1f, 0x0417,
+	0x0417, 0x0417, 0x0417, 0x059c, 0x6d20, 0x028e, 0x1a34, 0x6ad7,
+	0x0488, 0x0804, 0x7802, 0x650b, 0x6dc8, 0x008c, 0x1a28, 0x6ad7,
+	0x63c8, 0x034c, 0x6bc8, 0x54d1, 0x4c00, 0x7d06, 0x0065, 0x7c02,
+	0x0101, 0x0025, 0x0400, 0x9814, 0x52c1, 0x53c9, 0x54e1, 0x0453,
+	0xc159, 0x7d95, 0x0200, 0x9800, 0x55d9, 0x6d04, 0x54d1, 0x058a,
+	0x2508, 0x6dc7, 0x0373, 0x7c03, 0x65c8, 0x6d0b, 0x2408, 0x0372,
+	0x7c04, 0x65c8, 0x6d0b, 0x2408, 0x9889, 0x6cce, 0x65c8, 0x6d0a,
+	0x2404, 0x6d28, 0x6504, 0x5dd9, 0x5cd1, 0x6ad7, 0x6ae3, 0x63c8,
+	0x0334, 0x6bc8, 0x0370, 0x7cad, 0x0c60, 0x0411, 0x04bb, 0x4c00,
+	0x7da8, 0x0410, 0x1c30, 0x0410, 0x04bb, 0x046d, 0x7d0a, 0x047d,
+	0x7c03, 0x047c, 0x7c01, 0x9841, 0x003b, 0x003a, 0x0039, 0x0058,
+	0x98b8, 0x047d, 0x7d03, 0x047c, 0x7d01, 0x9841, 0x005b, 0xd8fc,
+	0x1d18, 0x6d20, 0x650b, 0x0510, 0x003a, 0x0039, 0x0038, 0x00ad,
+	0xd907, 0x0c30, 0x0410, 0x04bb, 0x003c, 0x003d, 0x00ac, 0xd8fc,
+	0x007b, 0x7c04, 0x003d, 0x003c, 0x1d0c, 0x98d9, 0x048f, 0x1c14,
+	0x6c20, 0x640b, 0x4401, 0x7d04, 0x005d, 0x005c, 0x1d0c, 0x98d9,
+	0x0310, 0x3b30, 0x4b30, 0x7d01, 0x1b10, 0x0310, 0x003d, 0x003c,
+	0x00ab, 0x6ad7, 0x63c8, 0x6d20, 0x650b, 0x0560, 0x7d03, 0x005e,
+	0xd8f0, 0x9841, 0x003e, 0x0c80, 0x0410, 0x0394, 0xd8f0, 0x640b,
+	0x037f, 0x7d02, 0x1a14, 0x98ed, 0x1a0c, 0x6ad7, 0x6cc8, 0x9841,
+	0x0c7f, 0x0410, 0x03b4, 0x04b8, 0x03ac, 0x640b, 0x6bc8, 0x028e,
+	0x1a04, 0x6ad7, 0x6cc8, 0x0006, 0x058f, 0x1d08, 0x6d20, 0x650b,
+	0x007d, 0x7c01, 0x1d38, 0x007c, 0x7c01, 0x1d1c, 0x0006, 0x048b,
+	0x042c, 0x0454, 0x042b, 0x6ad7, 0x6cc8, 0x0006, 0x0e70, 0x0611,
+	0x5616, 0xc13c, 0x7d2a, 0x5ade, 0x008e, 0xc14e, 0x7c26, 0x5be0,
+	0x5ef0, 0x5ce8, 0x0688, 0x08ff, 0x0011, 0x28ff, 0x00bc, 0x53f6,
+	0x05df, 0x7d0b, 0x6dc5, 0x03df, 0x7d03, 0x6bd5, 0xd95d, 0x9939,
+	0x6b05, 0xc55f, 0x7e27, 0x7f29, 0x9939, 0x6d01, 0x03df, 0x7d05,
+	0x6bd5, 0xc589, 0x7e18, 0x7f1a, 0x9939, 0x6b05, 0xc4ff, 0x7e07,
+	0x7f06, 0x52de, 0x53e6, 0xc159, 0x7dd7, 0x0200, 0x9911, 0x0007,
+	0x6004, 0x680c, 0x53f6, 0x028e, 0x00a3, 0xc256, 0x048b, 0x0498,
+	0x0454, 0x068a, 0x9939, 0x0207, 0x680c, 0x6ddf, 0x0107, 0x68ff,
+	0x60d0, 0x9942, 0x0207, 0x68ff, 0x6d28, 0x0107, 0x6004, 0x680c,
+	0x9942, 0x0007, 0x68ff, 0x60d0, 0x9942, 0x0288, 0x03a5, 0x3b03,
+	0x3d03, 0x4d00, 0x7d0a, 0x0804, 0x00a5, 0x00da, 0x7d1a, 0x02a0,
+	0x7b01, 0x65d8, 0x7eee, 0x65ff, 0x7eec, 0x0804, 0x02d0, 0x7d11,
+	0x4b00, 0x7c0f, 0x008a, 0x3003, 0x6dcf, 0x6bdf, 0x0015, 0x0015,
+	0x7b02, 0x65d8, 0x0000, 0x7edd, 0x63ff, 0x7edb, 0x3a03, 0x6dcd,
+	0x6bdd, 0x008a, 0x7b02, 0x65d8, 0x0000, 0x7ed3, 0x65ff, 0x7ed1,
+	0x0006, 0xc1d9, 0x0b70, 0x0311, 0x5313, 0x58d3, 0x008b, 0x5efb,
+	0xc13c, 0x7d2b, 0x5ac0, 0x5bc8, 0xc14e, 0x7c27, 0x6d00, 0x0388,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d1a, 0x0e70, 0x0611,
+	0x522e, 0x02b9, 0x4a00, 0x7c07, 0x52fe, 0x50d3, 0x02b8, 0x4a00,
+	0x7c02, 0x0400, 0x999e, 0x56fb, 0x620b, 0x7e06, 0x5a06, 0x7f06,
+	0x0000, 0x2504, 0x7d05, 0x999e, 0x0007, 0x680c, 0x0007, 0x0454,
+	0x008b, 0x52c0, 0x53c8, 0xc159, 0x7dd6, 0x0200, 0x9990, 0xc1d9,
+	0xc1e3, 0x0800, 0x005f, 0x00ac, 0x58e3, 0x0478, 0x7d5c, 0x0479,
+	0x7d01, 0x0515, 0x0515, 0xda38, 0xda57, 0x0479, 0x7d26, 0x54e3,
+	0x047f, 0x7d12, 0x50eb, 0x56fb, 0x0015, 0x52db, 0x7806, 0x5402,
+	0x5c06, 0x1a01, 0x5402, 0x5c26, 0x1a01, 0x54e3, 0x043f, 0x5ce3,
+	0x4d00, 0x7d4e, 0x0479, 0x7d14, 0x047f, 0x7d01, 0xda57, 0x52f3,
+	0x6a21, 0x56db, 0x7803, 0x620b, 0x5a06, 0x1e01, 0x7f34, 0x7e33,
+	0x6200, 0x5af3, 0x047f, 0x7dde, 0x9a20, 0x54e3, 0x047f, 0x7cda,
+	0x54e3, 0x047f, 0x7d01, 0xda57, 0x54eb, 0x0fff, 0x0711, 0x1fff,
+	0x56db, 0x52f3, 0x6a21, 0x630b, 0x028b, 0x03bf, 0xda32, 0x5b06,
+	0x2401, 0x4c00, 0x7d0b, 0x1e01, 0x038a, 0x03b7, 0x0312, 0x0312,
+	0xda32, 0x5b06, 0x1e01, 0x2401, 0x4c00, 0x7ced, 0x0b70, 0x0311,
+	0x5313, 0x7f09, 0x7e08, 0x6200, 0x5af3, 0x54e3, 0x047f, 0x7db2,
+	0x57db, 0xc1fa, 0x99cd, 0x0007, 0x680c, 0x54e3, 0x0478, 0x7c02,
+	0x0800, 0x9a2e, 0x0479, 0x7d01, 0x0517, 0x0517, 0x5deb, 0xc213,
+	0xc20a, 0x99c1, 0x0808, 0x7801, 0x0317, 0x0006, 0x020a, 0x0006,
+	0x070a, 0xda36, 0x1a05, 0x0215, 0x5adb, 0x0708, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x080c,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x4800, 0x7dd2, 0x58eb, 0x0006,
+	0xc1d9, 0x0b70, 0x0311, 0x5313, 0x58d3, 0x008b, 0x5efb, 0xc13c,
+	0x7d37, 0x5ac0, 0x5bc8, 0xc14e, 0x7c33, 0x0388, 0x6d04, 0x0dff,
+	0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d24, 0x0e70, 0x0611, 0x522e,
+	0x02b9, 0x4a00, 0x7c09, 0x52fe, 0x50d3, 0x02b8, 0x4a00, 0x7c04,
+	0x6a28, 0x7f0c, 0x0400, 0x9a75, 0x56fb, 0x5206, 0x7e10, 0x6a0b,
+	0x6a28, 0x7f04, 0x0000, 0x2504, 0x7d0c, 0x9a75, 0x0007, 0x680c,
+	0x680c, 0x6204, 0x6a04, 0x6a2b, 0x6a28, 0x0007, 0x680c, 0x0007,
+	0x0454, 0x6a28, 0x7ff3, 0x008b, 0x52c0, 0x53c8, 0xc159, 0x7dca,
+	0x0200, 0x9a67
+};
+#endif
diff --git a/arch/arm/mach-mx37/serial.c b/arch/arm/mach-mx37/serial.c
new file mode 100644
index 0000000..21db51a
--- /dev/null
+++ b/arch/arm/mach-mx37/serial.c
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*!
+ * @file mach-mx37/serial.c
+ *
+ * @brief This file contains the UART initiliazation.
+ *
+ * @ingroup MSL_MX37
+ */
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <asm/hardware.h>
+#include <asm/arch/mxc_uart.h>
+#include <asm/arch/spba.h>
+#include "serial.h"
+#include "board-mx37_3stack.h"
+
+#if defined(CONFIG_SERIAL_MXC) || defined(CONFIG_SERIAL_MXC_MODULE)
+
+/*!
+ * This is an array where each element holds information about a UART port,
+ * like base address of the UART, interrupt numbers etc. This structure is
+ * passed to the serial_core.c file. Based on which UART is used, the core file
+ * passes back the appropriate port structure as an argument to the control
+ * functions.
+ */
+static uart_mxc_port mxc_ports[] = {
+	[0] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART1_BASE_ADDR),
+			.mapbase = UART1_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART1_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 0,
+			},
+	       .ints_muxed = UART1_MUX_INTS,
+	       .irqs = {UART1_INT2, UART1_INT3},
+	       .mode = UART1_MODE,
+	       .ir_mode = UART1_IR,
+	       .enabled = UART1_ENABLED,
+	       .hardware_flow = UART1_HW_FLOW,
+	       .cts_threshold = UART1_UCR4_CTSTL,
+	       .dma_enabled = UART1_DMA_ENABLE,
+	       .dma_rxbuf_size = UART1_DMA_RXBUFSIZE,
+	       .rx_threshold = UART1_UFCR_RXTL,
+	       .tx_threshold = UART1_UFCR_TXTL,
+	       .shared = UART1_SHARED_PERI,
+	       .dma_tx_id = MXC_DMA_UART1_TX,
+	       .dma_rx_id = MXC_DMA_UART1_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[1] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART2_BASE_ADDR),
+			.mapbase = UART2_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART2_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 1,
+			},
+	       .ints_muxed = UART2_MUX_INTS,
+	       .irqs = {UART2_INT2, UART2_INT3},
+	       .mode = UART2_MODE,
+	       .ir_mode = UART2_IR,
+	       .enabled = UART2_ENABLED,
+	       .hardware_flow = UART2_HW_FLOW,
+	       .cts_threshold = UART2_UCR4_CTSTL,
+	       .dma_enabled = UART2_DMA_ENABLE,
+	       .dma_rxbuf_size = UART2_DMA_RXBUFSIZE,
+	       .rx_threshold = UART2_UFCR_RXTL,
+	       .tx_threshold = UART2_UFCR_TXTL,
+	       .shared = UART2_SHARED_PERI,
+	       .dma_tx_id = MXC_DMA_UART2_TX,
+	       .dma_rx_id = MXC_DMA_UART2_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[2] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART3_BASE_ADDR),
+			.mapbase = UART3_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART3_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 2,
+			},
+	       .ints_muxed = UART3_MUX_INTS,
+	       .irqs = {UART3_INT2, UART3_INT3},
+	       .mode = UART3_MODE,
+	       .ir_mode = UART3_IR,
+	       .enabled = UART3_ENABLED,
+	       .hardware_flow = UART3_HW_FLOW,
+	       .cts_threshold = UART3_UCR4_CTSTL,
+	       .dma_enabled = UART3_DMA_ENABLE,
+	       .dma_rxbuf_size = UART3_DMA_RXBUFSIZE,
+	       .rx_threshold = UART3_UFCR_RXTL,
+	       .tx_threshold = UART3_UFCR_TXTL,
+	       .shared = UART3_SHARED_PERI,
+	       .dma_tx_id = MXC_DMA_UART3_TX,
+	       .dma_rx_id = MXC_DMA_UART3_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+};
+
+static struct platform_device mxc_uart_device1 = {
+	.name = "mxcintuart",
+	.id = 0,
+	.dev = {
+		.platform_data = &mxc_ports[0],
+		},
+};
+
+static struct platform_device mxc_uart_device2 = {
+	.name = "mxcintuart",
+	.id = 1,
+	.dev = {
+		.platform_data = &mxc_ports[1],
+		},
+};
+
+static struct platform_device mxc_uart_device3 = {
+	.name = "mxcintuart",
+	.id = 2,
+	.dev = {
+		.platform_data = &mxc_ports[2],
+		},
+};
+
+static int __init mxc_init_uart(void)
+{
+	/* Register all the MXC UART platform device structures */
+	platform_device_register(&mxc_uart_device1);
+	platform_device_register(&mxc_uart_device2);
+
+	/* Grab ownership of shared UARTs 3 and 4, only when enabled */
+#if UART3_ENABLED == 1
+#if UART3_DMA_ENABLE == 1
+	spba_take_ownership(UART3_SHARED_PERI, (SPBA_MASTER_A | SPBA_MASTER_C));
+#else
+	spba_take_ownership(UART3_SHARED_PERI, SPBA_MASTER_A);
+#endif				/* UART3_DMA_ENABLE */
+	platform_device_register(&mxc_uart_device3);
+#endif				/* UART3_ENABLED */
+
+	return 0;
+}
+
+#else
+static int __init mxc_init_uart(void)
+{
+	return 0;
+}
+#endif
+
+arch_initcall(mxc_init_uart);
diff --git a/arch/arm/mach-mx37/serial.h b/arch/arm/mach-mx37/serial.h
new file mode 100644
index 0000000..926d44d
--- /dev/null
+++ b/arch/arm/mach-mx37/serial.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX37_SERIAL_H__
+#define __ARCH_ARM_MACH_MX37_SERIAL_H__
+
+#include <asm/arch/mxc_uart.h>
+
+/* UART 1 configuration */
+/*!
+ * This option allows to choose either an interrupt-driven software controlled
+ * hardware flow control (set this option to 0) or hardware-driven hardware
+ * flow control (set this option to 1).
+ */
+#define UART1_HW_FLOW           1
+/*!
+ * This specifies the threshold at which the CTS pin is deasserted by the
+ * RXFIFO. Set this value in Decimal to anything from 0 to 32 for
+ * hardware-driven hardware flow control. Read the HW spec while specifying
+ * this value. When using interrupt-driven software controlled hardware
+ * flow control set this option to -1.
+ */
+#define UART1_UCR4_CTSTL        16
+/*!
+ * This is option to enable (set this option to 1) or disable DMA data transfer
+ */
+#define UART1_DMA_ENABLE        0
+/*!
+ * Specify the size of the DMA receive buffer. The minimum buffer size is 512
+ * bytes. The buffer size should be a multiple of 256.
+ */
+#define UART1_DMA_RXBUFSIZE     1024
+/*!
+ * Specify the MXC UART's Receive Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the RxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_RXTL         16
+/*!
+ * Specify the MXC UART's Transmit Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the TxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_TXTL         16
+/* UART 2 configuration */
+#define UART2_HW_FLOW           0
+#define UART2_UCR4_CTSTL        -1
+#define UART2_DMA_ENABLE        0
+#define UART2_DMA_RXBUFSIZE     512
+#define UART2_UFCR_RXTL         16
+#define UART2_UFCR_TXTL         16
+/* UART 3 configuration */
+#define UART3_HW_FLOW           1
+#define UART3_UCR4_CTSTL        16
+#define UART3_DMA_ENABLE        1
+#define UART3_DMA_RXBUFSIZE     1024
+#define UART3_UFCR_RXTL         16
+#define UART3_UFCR_TXTL         16
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+/*
+ * Is the MUXED interrupt output sent to the ARM core
+ */
+#define INTS_NOTMUXED           0
+#define INTS_MUXED              1
+/* UART 1 configuration */
+/*!
+ * This define specifies whether the muxed ANDed interrupt line or the
+ * individual interrupts from the UART port is integrated with the ARM core.
+ * There exists a define like this for each UART port. Valid values that can
+ * be used are \b INTS_NOTMUXED or \b INTS_MUXED.
+ */
+#define UART1_MUX_INTS          INTS_MUXED
+/*!
+ * This define specifies the transmitter interrupt number or the interrupt
+ * number of the ANDed interrupt in case the interrupts are muxed. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_INT1              MXC_INT_UART1
+/*!
+ * This define specifies the receiver interrupt number. If the interrupts of
+ * the UART are muxed, then we specify here a dummy value -1. There exists a
+ * define like this for each UART port.
+ */
+#define UART1_INT2              -1
+/*!
+ * This specifies the master interrupt number. If the interrupts of the UART
+ * are muxed, then we specify here a dummy value of -1. There exists a define
+ * like this for each UART port.
+ */
+#define UART1_INT3              -1
+/*!
+ * This specifies if the UART is a shared peripheral. It holds the shared
+ * peripheral number if it is shared or -1 if it is not shared. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_SHARED_PERI       -1
+/* UART 2 configuration */
+#define UART2_MUX_INTS          INTS_MUXED
+#define UART2_INT1              MXC_INT_UART2
+#define UART2_INT2              -1
+#define UART2_INT3              -1
+#define UART2_SHARED_PERI       -1
+/* UART 3 configuration */
+#define UART3_MUX_INTS          INTS_MUXED
+#define UART3_INT1              MXC_INT_UART3
+#define UART3_INT2              -1
+#define UART3_INT3              -1
+#define UART3_SHARED_PERI       SPBA_UART3
+
+#endif				/* __ARCH_ARM_MACH_MX37_SERIAL_H__ */
diff --git a/arch/arm/mach-mx37/system.c b/arch/arm/mach-mx37/system.c
new file mode 100644
index 0000000..e90663c
--- /dev/null
+++ b/arch/arm/mach-mx37/system.c
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/clk.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include <asm/arch/clock.h>
+#include "crm_regs.h"
+
+/*!
+ * @defgroup MSL_MX37 i.MX37 Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @file mach-mx37/system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup MSL_MX37
+ */
+
+extern int mxc_jtag_enabled;
+
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void arch_idle(void)
+{
+	if (!mxc_jtag_enabled) {
+		cpu_do_idle();
+	}
+}
+
+/*
+ * This function resets the system. It is called by machine_restart().
+ *
+ * @param  mode         indicates different kinds of resets
+ */
+void arch_reset(char mode)
+{
+	/* Assert SRS signal */
+	mxc_wd_reset();
+}
diff --git a/arch/arm/plat-mxc/Kconfig b/arch/arm/plat-mxc/Kconfig
index 9b9e0e9..b39251c 100644
--- a/arch/arm/plat-mxc/Kconfig
+++ b/arch/arm/plat-mxc/Kconfig
@@ -13,6 +13,16 @@ config ARCH_MXC91321
 	select MXC_DSP_BRINGUP
 	select ARCH_HAS_EVTMON
 
+config ARCH_MX37
+    bool "MX37-based"
+	select CPU_V6
+	select CACHE_L2X0
+	#select USB_ARCH_HAS_EHCI
+	select ARCH_HAS_EVTMON
+	select MXC_TZIC
+    help
+      This enables support for systems based on Freescale i.MX37
+
 config ARCH_MX3
 	bool "MX3-based"
 	select CPU_V6
@@ -45,6 +55,8 @@ source "arch/arm/mach-mx21/Kconfig"
 
 source "arch/arm/mach-mx3/Kconfig"
 
+source "arch/arm/mach-mx37/Kconfig"
+
 source "arch/arm/mach-mxc91321/Kconfig"
 
 
@@ -54,6 +66,10 @@ source "arch/arm/mach-mxc91321/Kconfig"
 
 endmenu
 
+config MXC_TZIC
+	bool
+	depends on ARCH_MXC
+
 config MXC_DSP_BRINGUP
 	bool
 	depends on ARCH_MXC
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
index 495ce3d..935fe28 100644
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -9,7 +9,11 @@ ifneq ($(CONFIG_ARCH_MX21)$(CONFIG_ARCH_MX27),y)
 obj-y += time.o spba.o sdma/
 endif
 
+ifeq ($(CONFIG_MXC_TZIC),y)
+obj-y += tzic.o
+else
 obj-y += irq.o
+endif
 
 obj-$(CONFIG_ARCH_MX21) += dma_mx2.o
 obj-$(CONFIG_ARCH_MX27) += dma_mx2.o usb_common.o
diff --git a/arch/arm/plat-mxc/sdma/iapi/include/epm.h b/arch/arm/plat-mxc/sdma/iapi/include/epm.h
index ad6ea95..8356e44 100644
--- a/arch/arm/plat-mxc/sdma/iapi/include/epm.h
+++ b/arch/arm/plat-mxc/sdma/iapi/include/epm.h
@@ -46,7 +46,7 @@
 #define SDMA_XTRIG_CONF1        *((volatile unsigned long *)(SDMA_BASE_IO_ADDR + 0x070))
 #define SDMA_XTRIG_CONF2        *((volatile unsigned long *)(SDMA_BASE_IO_ADDR + 0x074))
 
-#if defined(CONFIG_ARCH_MXC91221) || defined(CONFIG_ARCH_MXC92323)
+#if defined(CONFIG_ARCH_MXC91221) || defined(CONFIG_ARCH_MXC92323) || defined(CONFIG_ARCH_MX37)
 #define SDMA_CHNENBL_0          *((volatile unsigned long *)(SDMA_BASE_IO_ADDR + 0x200))
 #define SDMA_CHNENBL_1          *((volatile unsigned long *)(SDMA_BASE_IO_ADDR + 0x204))
 #define SDMA_CHNENBL_2          *((volatile unsigned long *)(SDMA_BASE_IO_ADDR + 0x208))
diff --git a/arch/arm/plat-mxc/tzic.c b/arch/arm/plat-mxc/tzic.c
new file mode 100644
index 0000000..64615cc
--- /dev/null
+++ b/arch/arm/plat-mxc/tzic.c
@@ -0,0 +1,150 @@
+/*
+ *  Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+
+/*
+ *****************************************
+ * TZIC Registers                        *
+ *****************************************
+ */
+#define TZIC_BASE               IO_ADDRESS(TZIC_BASE_ADDR)
+#define TZIC_INTCNTL            (TZIC_BASE + 0x0000)	/* control register */
+#define TZIC_INTTYPE            (TZIC_BASE + 0x0004)	/* Controller type register */
+#define TZIC_IMPID              (TZIC_BASE + 0x0008)	/* Distributor Implementer Identification Register */
+#define TZIC_PRIOMASK           (TZIC_BASE + 0x000C)	/* Priority Mask Reg */
+#define TZIC_SYNCCTRL           (TZIC_BASE + 0x0010)	/* Synchronizer Control register */
+#define TZIC_DSMINT             (TZIC_BASE + 0x0014)	/* DSM interrupt Holdoffregister */
+#define TZIC_INTSEC0            (TZIC_BASE + 0x0080)	/* interrupt security register 0 */
+#define TZIC_ENSET0             (TZIC_BASE + 0x0100)	/* Enable Set Register 0 */
+#define TZIC_ENCLEAR0           (TZIC_BASE + 0x0180)	/* Enable Clear Register 0 */
+#define TZIC_SRCSET0            (TZIC_BASE + 0x0200)	/* Source Set Register 0 */
+#define TZIC_SRCCLAR0           (TZIC_BASE + 0x0280)	/* Source Clear Register 0 */
+#define TZIC_PRIORITY0          (TZIC_BASE + 0x0400)	/* Priority Register 0 */
+#define TZIC_PND0               (TZIC_BASE + 0x0D00)	/* Pending Register 0 */
+#define TZIC_HIPND0             (TZIC_BASE + 0x0D80)	/* High Priority Pending Register */
+#define TZIC_WAKEUP0            (TZIC_BASE + 0x0E00)	/* Wakeup Config Register */
+#define TZIC_SWINT              (TZIC_BASE + 0x0F00)	/* Software Interrupt Rigger Register */
+#define TZIC_ID0                (TZIC_BASE + 0x0FD0)	/* Indentification Register 0 */
+
+/*!
+ * Disable interrupt number "irq" in the TZIC
+ *
+ * @param  irq          interrupt source number
+ */
+static void mxc_mask_irq(unsigned int irq)
+{
+	int index, off;
+
+	index = irq >> 5;
+	off = irq & 0x1F;
+	__raw_writel(1 << off, TZIC_ENCLEAR0 + (index << 2));
+}
+
+/*!
+ * Enable interrupt number "irq" in the TZIC
+ *
+ * @param  irq          interrupt source number
+ */
+static void mxc_unmask_irq(unsigned int irq)
+{
+	int index, off;
+
+	index = irq >> 5;
+	off = irq & 0x1F;
+	__raw_writel(1 << off, TZIC_ENSET0 + (index << 2));
+}
+
+/*!
+ * Set interrupt number "irq" in the TZIC as a wake-up source.
+ *
+ * @param  irq          interrupt source number
+ * @param  enable       enable as wake-up if equal to non-zero
+ * 			disble as wake-up if equal to zero
+ *
+ * @return       This function returns 0 on success.
+ */
+static int mxc_set_wake_irq(unsigned int irq, unsigned int enable)
+{
+	int index, off;
+	u32 reg;
+
+	index = irq >> 5;
+	off = irq & 0x1F;
+	reg = __raw_readl(TZIC_WAKEUP0 + (index << 2));
+
+	if (enable) {
+		reg |= (1 << off);
+	} else {
+		reg &= ~(1 << off);
+	}
+
+	__raw_writel(reg, TZIC_WAKEUP0 + (index << 2));
+
+	return 0;
+}
+
+static struct irq_chip mxc_tzic_chip = {
+	.name = "MXC_TZIC",
+	.ack = mxc_mask_irq,
+	.mask = mxc_mask_irq,
+	.unmask = mxc_unmask_irq,
+	.set_wake = mxc_set_wake_irq,
+};
+
+/*!
+ * This function initializes the TZIC hardware and disables all the
+ * interrupts. It registers the interrupt enable and disable functions
+ * to the kernel for each interrupt source.
+ */
+void __init mxc_init_irq(void)
+{
+	int i;
+
+	/* put the TZIC into the reset value with
+	 * all interrupts disabled
+	 */
+	i = __raw_readl(TZIC_INTCNTL);
+
+	__raw_writel(0x80010001, TZIC_INTCNTL);
+	i = __raw_readl(TZIC_INTCNTL);
+	__raw_writel(0x1f, TZIC_PRIOMASK);
+	i = __raw_readl(TZIC_PRIOMASK);
+	__raw_writel(0x02, TZIC_SYNCCTRL);
+	i = __raw_readl(TZIC_SYNCCTRL);
+	for (i = 0; i < 4; i++) {
+		__raw_writel(0xFFFFFFFF, TZIC_INTSEC0 + i * 4);
+	}
+	/* disable all interrupts */
+	for (i = 0; i < 4; i++) {
+		__raw_writel(0xFFFFFFFF, TZIC_ENCLEAR0 + i * 4);
+	}
+
+	/* all IRQ no FIQ Warning :: No selection */
+
+	for (i = 0; i < MXC_MAX_INT_LINES; i++) {
+		set_irq_chip(i, &mxc_tzic_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+
+	printk(KERN_INFO "MXC IRQ initialized\n");
+}
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 35b5644..495d25c 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1544,3 +1544,4 @@ omap3evm		MACH_OMAP3EVM		OMAP3EVM		1535
 add_pcu57		MACH_ADD_PCU57		ADD_PCU57		1536
 monaco			MACH_MONACO		MONACO			1537
 levante			MACH_LEVANTE		LEVANTE			1538
+mx37_3ds		MACH_MX37_3DS		MX37_3DS		1575
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index e8ff4c3..80f7edc 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -415,6 +415,7 @@ config MXC_MU
 	bool "MXC Messaging Unit Driver"
 	depends on ARCH_MXC
 	depends on !ARCH_MX3
+	depends on !ARCH_MX37
 	depends on !ARCH_MX27
 	depends on !ARCH_MX21
 	select INPUT
@@ -428,6 +429,7 @@ config MXC_IPC
 	depends on MXC_MU && MXC_SDMA_API
 	depends on ARCH_MXC
 	depends on !ARCH_MX3
+	depends on !ARCH_MX37
 	depends on !ARCH_MX27
 	depends on !ARCH_MX21
 	default y
@@ -440,6 +442,7 @@ config MXC_SUPER_GEM
 	depends on MXC_SDMA_API
 	depends on ARCH_MXC
 	depends on !ARCH_MX3
+	depends on !ARCH_MX37
 	depends on !ARCH_MX27
 	depends on !ARCH_MX21
 	default n
diff --git a/drivers/ide/Kconfig b/drivers/ide/Kconfig
index 6f455ae..9871a53 100644
--- a/drivers/ide/Kconfig
+++ b/drivers/ide/Kconfig
@@ -889,7 +889,7 @@ config BLK_DEV_IDE_BAST
 
 config BLK_DEV_IDE_MXC
         tristate "Freescale MXC IDE support"
-        depends on ARM && ( ARCH_MX3 || ARCH_MX27 )
+        depends on ARM && ( ARCH_MX3 || ARCH_MX27 || ARCH_MX37)
         help
           Say Y here if you want to support the IDE controller on the
           Freescale iMX3 processor.
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 13d10aa..b141fb8 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -215,7 +215,7 @@ config SPI_MXC_SELECT2
 
 config SPI_MXC_SELECT3
 	bool "CSPI3"
-	depends on SPI_MXC && (ARCH_MX3 || ARCH_MX27)
+	depends on SPI_MXC && (ARCH_MX3 || ARCH_MX27 || ARCH_MX37)
 	default n
 
 #
diff --git a/include/asm-arm/arch-mxc/hardware.h b/include/asm-arm/arch-mxc/hardware.h
index 9a58f06..781b5a6 100644
--- a/include/asm-arm/arch-mxc/hardware.h
+++ b/include/asm-arm/arch-mxc/hardware.h
@@ -12,7 +12,7 @@
  * @file arch-mxc/hardware.h
  * @brief This file contains the hardware definitions of the board.
  *
- * @ingroup MSL_MX27 MSL_MX31 MSL_MXC91321
+ * @ingroup MSL_MX27 MSL_MX31 MSL_MX37 MSL_MXC91321
  */
 #ifndef __ASM_ARCH_MXC_HARDWARE_H__
 #define __ASM_ARCH_MXC_HARDWARE_H__
@@ -72,6 +72,13 @@ static inline int type## _rev (int rev)		\
 #define cpu_is_mx32()		(0)
 #endif
 
+#ifdef CONFIG_ARCH_MX37
+#include <asm/arch/mx37.h>
+#define cpu_is_mx37()   (1)
+#else
+#define cpu_is_mx37()   (0)
+#endif
+
 #ifdef CONFIG_ARCH_MX21
 #include <asm/arch/mx21.h>
 #define cpu_is_mx21()		(1)
@@ -103,6 +110,7 @@ MXC_REV(cpu_is_mx21);
 MXC_REV(cpu_is_mx27);
 MXC_REV(cpu_is_mx31);
 MXC_REV(cpu_is_mx32);
+MXC_REV(cpu_is_mx37);
 #endif
 
 #include <asm/arch/mxc.h>
diff --git a/include/asm-arm/arch-mxc/memory.h b/include/asm-arm/arch-mxc/memory.h
index 3217609..0376542 100644
--- a/include/asm-arm/arch-mxc/memory.h
+++ b/include/asm-arm/arch-mxc/memory.h
@@ -23,6 +23,10 @@
 #define PHYS_OFFSET             UL(0xA0000000)
 #endif
 
+#ifdef CONFIG_MACH_MX37_3DS
+#define PHYS_OFFSET             UL(0x40000000)
+#endif
+
 #ifndef PHYS_OFFSET
 #define PHYS_OFFSET	        UL(0x80000000)
 #endif
diff --git a/include/asm-arm/arch-mxc/mx37.h b/include/asm-arm/arch-mxc/mx37.h
new file mode 100644
index 0000000..f0eef8d
--- /dev/null
+++ b/include/asm-arm/arch-mxc/mx37.h
@@ -0,0 +1,445 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX37_H__
+#define __ASM_ARCH_MXC_MX37_H__
+
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#error "Do not include directly."
+#endif
+
+#include <asm/arch/mx37_pins.h>
+
+/*!
+ * @file arch-mxc/mx37.h
+ * @brief This file contains register definitions.
+ *
+ * @ingroup MSL_MX37
+ */
+/*!
+ * defines the hardware clock tick rate
+ */
+#define CLOCK_TICK_RATE         16625000
+
+/*!
+ * Register an interrupt handler for the SMN as well as the SCC.  In some
+ * implementations, the SMN is not connected at all, and in others, it is
+ * on the same interrupt line as the SCM. Comment this line out accordingly
+ */
+#define USE_SMN_INTERRUPT
+
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+#define MXC_UART_NR 3
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive Irda data.
+ */
+#define MXC_UART_IR_RXDMUX      0x0004
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive UART data.
+ */
+#define MXC_UART_RXDMUX         0x0004
+
+/*!
+ * This option is used to set or clear the dspdma bit in the SDMA config
+ * register.
+ */
+#define MXC_SDMA_DSPDMA         0
+
+/*
+ * IRAM
+ */
+#define IRAM_BASE_ADDR		0x10000000	/* internal ram */
+#define IRAM_BASE_ADDR_VIRT	0xF8000000
+#define IRAM_SIZE		SZ_128K
+
+/*
+ * NFC
+ */
+#define NFC_BASE_ADDR_AXI	0x7FFF0000	/* NAND flash AXI */
+#define NFC_BASE_ADDR_AXI_VIRT	0xF9000000
+#define NFC_AXI_SIZE		SZ_64K
+
+/*
+ * L2CC
+ */
+#define L2CC_BASE_ADDR		0xB0000000
+
+#define PLATFORM_BASE_ADDR	0xB0400000
+#define PLATFORM_BASE_ADDR_VIRT 0xFA000000
+#define PLATFORM_SIZE		SZ_1M
+#define EVTMON_BASE_ADDR	(PLATFORM_BASE_ADDR + 0x00000000)
+#define ARM1176_BASE_ADDR	(PLATFORM_BASE_ADDR + 0x00002000)
+
+#define TZIC_BASE_ADDR		0xB0800000
+#define TZIC_BASE_ADDR_VIRT	0xFA100000
+#define TZIC_SIZE		SZ_1M
+
+#define DEBUG_BASE_ADDR		0xB0C00000
+#define DEBUG_BASE_ADDR_VIRT	0xFA200000
+#define DEBUG_SIZE		SZ_1M
+#define ETB_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00001000)
+#define ETM_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00002000)
+#define TPIU_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00003000)
+#define CTI0_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00004000)
+#define CTI1_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00005000)
+#define CTI2_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00006000)
+
+/*
+ * AIPS 1
+ */
+#define AIPS1_BASE_ADDR 	0xC3F00000
+#define AIPS1_BASE_ADDR_VIRT	0xFC000000
+#define AIPS1_SIZE		SZ_1M
+
+#define MAX_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00080000)
+#define GPIO1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00084000)
+#define GPIO2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00088000)
+#define GPIO3_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0008C000)
+#define KPP_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00094000)
+#define WDOG1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00098000)
+#define WDOG2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0009C000)
+#define GPT1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A0000)
+#define SRTC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A4000)
+#define IOMUXC_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000A8000)
+#define IIM_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000AC000)
+#define CSU_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000B0000)
+#define SDMA_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000B4000)
+#define SCC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000BC000)
+#define ROMCP_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000C0000)
+#define RTIC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000C4000)
+#define VPU_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D0000)
+#define USBOH2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000D4000)
+#define ATA_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D8000)
+#define MSHC1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000E0000)
+#define FEC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000E8000)
+#define RNGC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000EC000)
+#define TVE_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000F0000)
+
+/*
+ * SPBA global module enabled #0
+ */
+#define SPBA0_BASE_ADDR 	0xC0000000
+#define SPBA0_BASE_ADDR_VIRT	0xFC100000
+#define SPBA0_SIZE		SZ_1M
+
+#define MMC_SDHC1_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00004000)
+#define MMC_SDHC2_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00008000)
+#define UART3_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x0000C000)
+#define CSPI2_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x00010000)
+#define SSI2_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00014000)
+#define MMC_SDHC3_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00020000)
+#define SPDIF_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00028000)
+#define ATA_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00034000)
+#define SPBA_CTRL_BASE_ADDR	(SPBA0_BASE_ADDR + 0x0003C000)
+
+/*!
+ * defines for SPBA modules
+ */
+#define SPBA_SDHC1	0x04
+#define SPBA_SDHC2	0x08
+#define SPBA_UART3	0x0C
+#define SPBA_CSPI2	0x10
+#define SPBA_SSI2	0x14
+#define SPBA_SDHC3	0x20
+#define SPBA_SPDIF	0x28
+#define SPBA_ATA	0x34
+
+/*!
+ * Defines for modules using static and dynamic DMA channels
+ */
+#define MXC_DMA_CHANNEL_UART1_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC1		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC2		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_RX		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_TX		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_RX		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_TX		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI3_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI3_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_RX		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_TX		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MEMORY		MXC_DMA_DYNAMIC_CHANNEL
+
+/*
+ * AIPS 2
+ */
+#define AIPS2_BASE_ADDR		0xE3F00000
+#define AIPS2_BASE_ADDR_VIRT	0xFC200000
+#define AIPS2_SIZE		SZ_1M
+
+#define PLL0_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00080000)
+#define PLL1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00084000)
+#define PLL2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00088000)
+#define CCM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0008C000)
+#define GPC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00090000)
+#define SRC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00094000)
+#define EPIT1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00098000)
+#define EPIT2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0009C000)
+#define PWM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A0000)
+#define OWIRE_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000A4000)
+#define CSPI3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A8000)
+#define CSPI1_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000AC000)
+#define UART1_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000B0000)
+#define UART2_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000BC000)
+#define I2C3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C0000)
+#define I2C2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C4000)
+#define I2C_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C8000)
+#define SSI1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000CC000)
+#define AUDMUX_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000D0000)
+#define EMI_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DBF00)
+
+#define M4IF_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D8000)
+#define ESDCTL_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000D9000)
+#define WEIM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DA000)
+#define NFC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DB000)
+
+/*
+ * Memory regions and CS
+ */
+#define CSD0_BASE_ADDR          0x40000000
+#define CSD1_BASE_ADDR          0x50000000
+
+#define CS0_BASE_ADDR           0x60000000
+#define CS1_BASE_ADDR           0x68000000
+#define CS2_BASE_ADDR           0x70000000
+
+/*!
+ * This macro defines the physical to virtual address mapping for all the
+ * peripheral modules. It is used by passing in the physical address as x
+ * and returning the virtual address. If the physical address is not mapped,
+ * it returns 0xDEADBEEF
+ */
+#define IO_ADDRESS(x)   \
+        (((x >= (unsigned long)(IRAM_BASE_ADDR)) && (x < (unsigned long)((IRAM_BASE_ADDR + IRAM_SIZE)))) ? IRAM_IO_ADDRESS(x):\
+        ((x >= (unsigned long)PLATFORM_BASE_ADDR) && (x < (unsigned long)(PLATFORM_BASE_ADDR + PLATFORM_SIZE))) ? PLATFORM_IO_ADDRESS(x):\
+        ((x >= (unsigned long)TZIC_BASE_ADDR) && (x < (unsigned long)(TZIC_BASE_ADDR + TZIC_SIZE))) ? TZIC_IO_ADDRESS(x):\
+        ((x >= (unsigned long)DEBUG_BASE_ADDR) && (x < (unsigned long)(DEBUG_BASE_ADDR + DEBUG_SIZE))) ? DEBUG_IO_ADDRESS(x):\
+        ((x >= (unsigned long)SPBA0_BASE_ADDR) && (x < (unsigned long)(SPBA0_BASE_ADDR + SPBA0_SIZE))) ? SPBA0_IO_ADDRESS(x):\
+        ((x >= (unsigned long)AIPS1_BASE_ADDR) && (x < (unsigned long)(AIPS1_BASE_ADDR + AIPS1_SIZE))) ? AIPS1_IO_ADDRESS(x):\
+        ((x >= (unsigned long)AIPS2_BASE_ADDR) && (x < (unsigned long)(AIPS2_BASE_ADDR + AIPS2_SIZE))) ? AIPS2_IO_ADDRESS(x):\
+        ((x >= (unsigned long)(NFC_BASE_ADDR_AXI)) && (x < (unsigned long)((NFC_BASE_ADDR_AXI + NFC_AXI_SIZE)))) ? NFC_BASE_ADDR_AXI_IO_ADDRESS(x):\
+        0xDEADBEEF)
+
+/*
+ * define the address mapping macros: in physical address order
+ */
+
+#define IRAM_IO_ADDRESS(x)  \
+        (((x) - IRAM_BASE_ADDR) + IRAM_BASE_ADDR_VIRT)
+
+#define PLATFORM_IO_ADDRESS(x)  \
+        (((x) - PLATFORM_BASE_ADDR) + PLATFORM_BASE_ADDR_VIRT)
+
+#define TZIC_IO_ADDRESS(x)  \
+        (((x) - TZIC_BASE_ADDR) + TZIC_BASE_ADDR_VIRT)
+
+#define DEBUG_IO_ADDRESS(x)  \
+        (((x) - DEBUG_BASE_ADDR) + DEBUG_BASE_ADDR_VIRT)
+
+#define SPBA0_IO_ADDRESS(x)  \
+        (((x) - SPBA0_BASE_ADDR) + SPBA0_BASE_ADDR_VIRT)
+
+#define AIPS1_IO_ADDRESS(x)  \
+        (((x) - AIPS1_BASE_ADDR) + AIPS1_BASE_ADDR_VIRT)
+
+#define AIPS2_IO_ADDRESS(x)  \
+        (((x) - AIPS2_BASE_ADDR) + AIPS2_BASE_ADDR_VIRT)
+
+#define NFC_BASE_ADDR_AXI_IO_ADDRESS(x) \
+        (((x) - NFC_BASE_ADDR_AXI) + NFC_BASE_ADDR_AXI_VIRT)
+
+/*
+ * DMA request assignments
+ */
+#define DMA_REQ_RESV47		47
+#define DMA_REQ_VPU		46
+#define DMA_REQ_SPDIF		45
+#define DMA_REQ_UART3_TX	44
+#define DMA_REQ_UART3_RX	43
+#define DMA_REQ_I2C2		42
+#define DMA_REQ_I2C1		41
+#define DMA_REQ_SDHC3		40
+#define DMA_REQ_CSPI3_TX	39
+#define DMA_REQ_CSPI3_RX	38
+#define DMA_REQ_RESV37		37
+#define DMA_REQ_IPU		36
+#define DMA_REQ_RESV35		35
+#define DMA_REQ_EPIT2		34
+#define DMA_REQ_RESV33		33
+#define DMA_REQ_RESV32		32
+#define DMA_REQ_ECT		31
+#define DMA_REQ_NFC		30
+#define DMA_REQ_SSI1_TX1	29
+#define DMA_REQ_SSI1_RX1	28
+#define DMA_REQ_SSI1_TX2	27
+#define DMA_REQ_SSI1_RX2	26
+#define DMA_REQ_SSI2_TX1	25
+#define DMA_REQ_SSI2_RX1	24
+#define DMA_REQ_SSI2_TX2	23
+#define DMA_REQ_SSI2_RX2	22
+#define DMA_REQ_SDHC2		21
+#define DMA_REQ_SDHC1		20
+#define DMA_REQ_UART1_TX	19
+#define DMA_REQ_UART1_RX	18
+#define DMA_REQ_UART2_TX	17
+#define DMA_REQ_UART2_RX	16
+#define DMA_REQ_GPIO1_0		15
+#define DMA_REQ_GPIO1_1		14
+#define DMA_REQ_RESV13		13
+#define DMA_REQ_RESV12		12
+#define DMA_REQ_RESV11		11
+#define DMA_REQ_RESV10		10
+#define DMA_REQ_CSPI1_TX	9
+#define DMA_REQ_CSPI1_RX	8
+#define DMA_REQ_CSPI2_TX	7
+#define DMA_REQ_CSPI2_RX	6
+#define DMA_REQ_RESV5		5
+#define DMA_REQ_ATA_TX_END	4
+#define DMA_REQ_ATA_TX		3
+#define DMA_REQ_ATA_RX		2
+#define DMA_REQ_GPC		1
+#define DMA_REQ_RESV0		0
+
+/*
+ * Interrupt numbers
+ */
+#define MXC_INT_BASE		0
+#define MXC_INT_RESV0		0
+#define MXC_INT_MMC_SDHC1	1
+#define MXC_INT_MMC_SDHC2	2
+#define MXC_INT_MMC_SDHC3	3
+#define MXC_INT_RESV4		4
+#define MXC_INT_RESV5		5
+#define MXC_INT_SDMA		6
+#define MXC_INT_IOMUX		7
+#define MXC_INT_RESV8		8
+#define MXC_INT_VPU		9
+#define MXC_INT_IPU_ERR		10
+#define MXC_INT_IPU_SYN		11
+#define MXC_INT_RESV12		12
+#define MXC_INT_RESV13		13
+#define MXC_INT_RNGC		14
+#define MXC_INT_EMI		15
+#define MXC_INT_RESV16		16
+#define MXC_INT_RESV17		17
+#define MXC_INT_USB_OTG		18
+#define MXC_INT_RESV19		19
+#define MXC_INT_RESV20		20
+#define MXC_INT_SCC_SMN		21
+#define MXC_INT_SCC_STZ		22
+#define MXC_INT_SCC_SCM		23
+#define MXC_INT_SRTC_NTZ	24
+#define MXC_INT_SRTC_TZ		25
+#define MXC_INT_RTIC		26
+#define MXC_INT_CSU		27
+#define MXC_INT_RESV28		28
+#define MXC_INT_SSI1		29
+#define MXC_INT_SSI2		30
+#define MXC_INT_UART1		31
+#define MXC_INT_UART2		32
+#define MXC_INT_UART3		33
+#define MXC_INT_RESV34		34
+#define MXC_INT_RESV35		35
+#define MXC_INT_CSPI1		36
+#define MXC_INT_CSPI2		37
+#define MXC_INT_CSPI3		38
+#define MXC_INT_GPT		39
+#define MXC_INT_EPIT1		40
+#define MXC_INT_EPIT2		41
+#define MXC_INT_GPIO1_INT7	42
+#define MXC_INT_GPIO1_INT6	43
+#define MXC_INT_GPIO1_INT5	44
+#define MXC_INT_GPIO1_INT4	45
+#define MXC_INT_GPIO1_INT3	46
+#define MXC_INT_GPIO1_INT2	47
+#define MXC_INT_GPIO1_INT1	48
+#define MXC_INT_GPIO1_INT0	49
+#define MXC_INT_GPIO1_LOW	50
+#define MXC_INT_GPIO1_HIGH	51
+#define MXC_INT_GPIO2_LOW	52
+#define MXC_INT_GPIO2_HIGH	53
+#define MXC_INT_GPIO3_LOW	54
+#define MXC_INT_GPIO3_HIGH	55
+#define MXC_INT_RESV56		56
+#define MXC_INT_RESV57		57
+#define MXC_INT_WDOG1		58
+#define MXC_INT_WDOG2		59
+#define MXC_INT_KPP		60
+#define MXC_INT_PWM		61
+#define MXC_INT_I2C		62
+#define MXC_INT_I2C2		63
+#define MXC_INT_I2C3		64
+#define MXC_INT_MSHC1		65
+#define MXC_INT_RESV66		66
+#define MXC_INT_RESV67		67
+#define MXC_INT_RESV68		68
+#define MXC_INT_IIM		69
+#define MXC_INT_ATA		70
+#define MXC_INT_CCM1		71
+#define MXC_INT_CCM2		72
+#define MXC_INT_GPC1		73
+#define MXC_INT_GPC2		74
+#define MXC_INT_SRC		75
+#define MXC_INT_EVTMON		76
+#define MXC_INT_PER_MEASURE	77
+#define MXC_INT_DECODE_ERR	78
+#define MXC_INT_EVT_COUNT	79
+#define MXC_INT_SLAVE_ERR	80
+#define MXC_INT_RESV81		81
+#define MXC_INT_RESV82		82
+#define MXC_INT_RESV83		83
+#define MXC_INT_RESV84		84
+#define MXC_INT_RESV85		85
+#define MXC_INT_RESV86		86
+#define MXC_INT_FEC		87
+#define MXC_INT_OWIRE		88
+#define MXC_INT_CTI0		89
+#define MXC_INT_CTM0		90
+#define MXC_INT_SPDIF		91
+#define MXC_INT_TVOUT		92
+
+#define MXC_MAX_INT_LINES       128
+
+/*!
+ * Interrupt Number for ARM11 PMU
+ */
+#define ARM11_PMU_IRQ		MXC_INT_EVTMON
+
+#define	MXC_GPIO_INT_BASE	(MXC_MAX_INT_LINES)
+
+/*!
+ * Number of GPIO port as defined in the IC Spec
+ */
+#define GPIO_PORT_NUM           3
+/*!
+ * Number of GPIO pins per port
+ */
+#define GPIO_NUM_PIN            32
+
+#define MXC_GPIO_SPLIT_IRQ_2
+
+#endif				/*  __ASM_ARCH_MXC_MX37_H__ */
diff --git a/include/asm-arm/arch-mxc/mx37_pins.h b/include/asm-arm/arch-mxc/mx37_pins.h
new file mode 100644
index 0000000..78e58f7
--- /dev/null
+++ b/include/asm-arm/arch-mxc/mx37_pins.h
@@ -0,0 +1,266 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX37_PINS_H__
+#define __ASM_ARCH_MXC_MX37_PINS_H__
+
+/*!
+ * @file arch-mxc/mx37_pins.h
+ *
+ * @brief MX37 I/O Pin List
+ *
+ * @ingroup GPIO_MX37
+ */
+
+#ifndef __ASSEMBLY__
+
+/*!
+ * @name IOMUX/PAD Bit field definitions
+ */
+
+/*! @{ */
+
+/*!
+ * In order to identify pins more effectively, each mux-controlled pin's
+ * enumerated value is constructed in the following way:
+ *
+ * -------------------------------------------------------------------
+ * 31-29 | 28 - 24 |  23  | 22 - 20 | 19  - 10| 9 - 0
+ * -------------------------------------------------------------------
+ * IO_P  |  IO_I  | RSVD_I |  GPIO_I | PAD_I  | MUX_I
+ * -------------------------------------------------------------------
+ *
+ * Bit 0 to 9 contains MUX_I used to identify the register
+ * offset (0-based. base is IOMUX_module_base) defined in the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. The
+ * similar field definitions are used for the pad control register.
+ * For example, the MX37_PIN_ETM_D0 is defined in the enumeration:
+ *    ( (0x28 - MUX_I_START) << MUX_I)|( (0x250 - PAD_I_START) << PAD_I)
+ * It means the mux control register is at register offset 0x28. The pad control
+ * register offset is: 0x250 and also occupy the least significant bits
+ * within the register.
+ */
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * MUX control register offset
+ */
+#define MUX_I			0
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * PAD control register offset
+ */
+#define PAD_I			10
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent which
+ * mux mode is for GPIO (0-based)
+ */
+#define GPIO_I			20
+/*!
+ * Starting bit position which is reserved.
+ */
+#define RSVD_I			23
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio offset bit (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 0's since they are don't cares. So for port 2 pin 21, bit 31-24
+ * will be (1 << MUX_IO_P) | (21 << MUX_IO_I).
+ */
+#define MUX_IO_I		24
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio port number (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 1's for error checking in the functions. (gpio port 7 is invalid)
+ */
+#define MUX_IO_P		29
+
+#define NON_GPIO_PORT		0x7
+#define PIN_TO_MUX_MASK		((1 << (PAD_I - MUX_I)) -1)
+#define PIN_TO_PAD_MASK		((1 << (GPIO_I - PAD_I)) - 1)
+#define PIN_TO_ALT_GPIO_MASK	((1 << (RSVD_I - GPIO_I)) - 1)
+
+#define NON_MUX_I		PIN_TO_MUX_MASK
+#define MUX_I_START		0x0008
+#define MUX_I_END		(PAD_I_START - 4)
+#define PAD_I_START		0x230
+#define PAD_I_END		(INPUT_CTL_START - 4)
+#define INPUT_CTL_START		0x508
+#define INPUT_CTL_END		0x614
+
+#define _MXC_BUILD_PIN(gp, gi, ga, mi, pi) \
+	(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | \
+	((mi - MUX_I_START) << MUX_I) | \
+	((pi - PAD_I_START) << PAD_I) | \
+	((ga) << GPIO_I))
+
+#define _MXC_BUILD_GPIO_PIN(gp, gi, ga, mi, pi) \
+    _MXC_BUILD_PIN(gp, gi, ga, mi, pi)
+
+#define _MXC_BUILD_NON_GPIO_PIN(mi, pi) \
+    _MXC_BUILD_PIN(NON_GPIO_PORT, 0, 0, mi, pi)
+
+#define PIN_TO_IOMUX_MUX(pin)	((pin >> MUX_I) & PIN_TO_MUX_MASK)
+#define PIN_TO_IOMUX_PAD(pin)	((pin >> PAD_I) & PIN_TO_PAD_MASK)
+#define PIN_TO_ALT_GPIO(pin)	((pin >> GPIO_I) & PIN_TO_ALT_GPIO_MASK)
+#define PIN_TO_IOMUX_INDEX(pin)	(PIN_TO_IOMUX_MUX(pin) >> 2)
+
+/*! @} End IOMUX/PAD Bit field definitions */
+
+/*!
+ * This enumeration is constructed based on the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the MX37 IC Spec. Each enumerated
+ * value is constructed based on the rules described above.
+ */
+typedef enum iomux_pins {
+	MX37_PIN_KEY_ROW0 = _MXC_BUILD_NON_GPIO_PIN(0x8, 0x230),
+	MX37_PIN_KEY_ROW1 = _MXC_BUILD_NON_GPIO_PIN(0xC, 0x234),
+	MX37_PIN_KEY_ROW2 = _MXC_BUILD_NON_GPIO_PIN(0x10, 0x238),
+	MX37_PIN_KEY_ROW3 = _MXC_BUILD_NON_GPIO_PIN(0x14, 0x23C),
+	MX37_PIN_KEY_ROW4 = _MXC_BUILD_NON_GPIO_PIN(0x18, 0x240),
+	MX37_PIN_KEY_ROW5 = _MXC_BUILD_NON_GPIO_PIN(0x1C, 0x244),
+	MX37_PIN_KEY_ROW6 = _MXC_BUILD_NON_GPIO_PIN(0x20, 0x248),
+	MX37_PIN_KEY_ROW7 = _MXC_BUILD_NON_GPIO_PIN(0x24, 0x24C),
+	MX37_PIN_ETM_D0 = _MXC_BUILD_NON_GPIO_PIN(0x28, 0x250),
+	MX37_PIN_ETM_D1 = _MXC_BUILD_NON_GPIO_PIN(0x2C, 0x254),
+	MX37_PIN_ETM_D2 = _MXC_BUILD_NON_GPIO_PIN(0x30, 0x258),
+	MX37_PIN_ETM_D3 = _MXC_BUILD_NON_GPIO_PIN(0x34, 0x25C),
+	MX37_PIN_ETM_D4 = _MXC_BUILD_NON_GPIO_PIN(0x38, 0x260),
+	MX37_PIN_ETM_D5 = _MXC_BUILD_NON_GPIO_PIN(0x3C, 0x264),
+	MX37_PIN_ETM_D6 = _MXC_BUILD_NON_GPIO_PIN(0x40, 0x268),
+	MX37_PIN_ETM_D7 = _MXC_BUILD_NON_GPIO_PIN(0x44, 0x26C),
+	MX37_PIN_EIM_EB0 = _MXC_BUILD_GPIO_PIN(0, 15, 3, 0x48, 0x2A8),
+	MX37_PIN_EIM_EB1 = _MXC_BUILD_GPIO_PIN(0, 14, 3, 0x4C, 0x2AC),
+	MX37_PIN_EIM_OE = _MXC_BUILD_GPIO_PIN(0, 13, 3, 0x50, 0x2B0),
+	MX37_PIN_EIM_CS0 = _MXC_BUILD_GPIO_PIN(1, 0, 1, 0x54, 0x2B4),
+	MX37_PIN_EIM_CS1 = _MXC_BUILD_GPIO_PIN(1, 1, 1, 0x58, 0x2B8),
+	MX37_PIN_EIM_ECB = _MXC_BUILD_GPIO_PIN(0, 12, 3, 0x5C, 0x2BC),
+	MX37_PIN_EIM_LBA = _MXC_BUILD_GPIO_PIN(0, 11, 3, 0x60, 0x2C0),
+	MX37_PIN_EIM_BCLK = _MXC_BUILD_GPIO_PIN(0, 10, 3, 0x64, 0x2C4),
+	MX37_PIN_EIM_RW = _MXC_BUILD_GPIO_PIN(0, 9, 3, 0x68, 0x2C8),
+	MX37_PIN_NANDF_WE_B = _MXC_BUILD_GPIO_PIN(1, 2, 4, 0x6C, 0x2CC),
+	MX37_PIN_NANDF_RE_B = _MXC_BUILD_GPIO_PIN(1, 3, 4, 0x70, 0x2D0),
+	MX37_PIN_NANDF_ALE = _MXC_BUILD_GPIO_PIN(1, 4, 4, 0x74, 0x2D4),
+	MX37_PIN_NANDF_CLE = _MXC_BUILD_GPIO_PIN(1, 5, 4, 0x78, 0x2D8),
+	MX37_PIN_NANDF_WP_B = _MXC_BUILD_GPIO_PIN(1, 6, 4, 0x7C, 0x2DC),
+	MX37_PIN_NANDF_RB = _MXC_BUILD_GPIO_PIN(1, 7, 4, 0x80, 0x2E0),
+	MX37_PIN_NANDF_CS0 = _MXC_BUILD_GPIO_PIN(1, 8, 4, 0x84, 0x2E4),
+	MX37_PIN_NANDF_CS1 = _MXC_BUILD_GPIO_PIN(1, 9, 4, 0x88, 0x2E8),
+	MX37_PIN_NANDF_CS2 = _MXC_BUILD_GPIO_PIN(1, 10, 4, 0x8C, 0x2EC),
+	MX37_PIN_NANDF_CS3 = _MXC_BUILD_GPIO_PIN(1, 11, 4, 0x90, 0x2F0),
+	MX37_PIN_EIM_D15 = _MXC_BUILD_NON_GPIO_PIN(0x94, 0x2F4),
+	MX37_PIN_EIM_D14 = _MXC_BUILD_NON_GPIO_PIN(0x98, 0x2F8),
+	MX37_PIN_EIM_D13 = _MXC_BUILD_NON_GPIO_PIN(0x9C, 0x2FC),
+	MX37_PIN_EIM_D12 = _MXC_BUILD_NON_GPIO_PIN(0xA0, 0x300),
+	MX37_PIN_EIM_D11 = _MXC_BUILD_NON_GPIO_PIN(0xA4, 0x304),
+	MX37_PIN_EIM_D10 = _MXC_BUILD_NON_GPIO_PIN(0xA8, 0x308),
+	MX37_PIN_EIM_D9 = _MXC_BUILD_NON_GPIO_PIN(0xAC, 0x30C),
+	MX37_PIN_EIM_D8 = _MXC_BUILD_GPIO_PIN(0, 8, 3, 0xB0, 0x310),
+	MX37_PIN_EIM_D7 = _MXC_BUILD_GPIO_PIN(2, 27, 3, 0xB4, 0x314),
+	MX37_PIN_EIM_D6 = _MXC_BUILD_GPIO_PIN(2, 26, 3, 0xB8, 0x318),
+	MX37_PIN_EIM_D5 = _MXC_BUILD_GPIO_PIN(2, 25, 3, 0xBC, 0x31C),
+	MX37_PIN_EIM_D4 = _MXC_BUILD_GPIO_PIN(2, 24, 3, 0xC0, 0x320),
+	MX37_PIN_EIM_D3 = _MXC_BUILD_GPIO_PIN(2, 23, 3, 0xC4, 0x324),
+	MX37_PIN_EIM_D2 = _MXC_BUILD_GPIO_PIN(2, 22, 3, 0xC8, 0x328),
+	MX37_PIN_EIM_D1 = _MXC_BUILD_GPIO_PIN(2, 21, 3, 0xCC, 0x32C),
+	MX37_PIN_EIM_D0 = _MXC_BUILD_GPIO_PIN(2, 20, 3, 0xD0, 0x330),
+	MX37_PIN_SD1_CMD = _MXC_BUILD_GPIO_PIN(0, 16, 3, 0xD4, 0x334),
+	MX37_PIN_SD1_CLK = _MXC_BUILD_GPIO_PIN(0, 17, 3, 0xD8, 0x338),
+	MX37_PIN_SD1_DATA0 = _MXC_BUILD_GPIO_PIN(0, 18, 3, 0xDC, 0x33C),
+	MX37_PIN_SD1_DATA1 = _MXC_BUILD_GPIO_PIN(0, 19, 3, 0xE0, 0x340),
+	MX37_PIN_SD1_DATA2 = _MXC_BUILD_GPIO_PIN(0, 20, 3, 0xE4, 0x344),
+	MX37_PIN_SD1_DATA3 = _MXC_BUILD_GPIO_PIN(0, 21, 3, 0xE8, 0x348),
+	MX37_PIN_SD2_CMD = _MXC_BUILD_GPIO_PIN(0, 22, 3, 0xEC, 0x34C),
+	MX37_PIN_SD2_CLK = _MXC_BUILD_GPIO_PIN(0, 23, 3, 0xF0, 0x350),
+	MX37_PIN_SD2_DATA0 = _MXC_BUILD_GPIO_PIN(0, 24, 3, 0xF4, 0x354),
+	MX37_PIN_SD2_DATA1 = _MXC_BUILD_GPIO_PIN(0, 25, 3, 0xF8, 0x358),
+	MX37_PIN_SD2_DATA2 = _MXC_BUILD_GPIO_PIN(0, 26, 3, 0xFC, 0x35C),
+	MX37_PIN_SD2_DATA3 = _MXC_BUILD_GPIO_PIN(0, 27, 3, 0x100, 0x360),
+	MX37_PIN_I2C1_CLK = _MXC_BUILD_GPIO_PIN(1, 12, 4, 0x104, 0x364),
+	MX37_PIN_I2C1_DAT = _MXC_BUILD_GPIO_PIN(1, 13, 4, 0x108, 0x368),
+	MX37_PIN_AUD3_BB_TXD = _MXC_BUILD_GPIO_PIN(1, 14, 4, 0x10C, 0x36C),
+	MX37_PIN_AUD3_BB_RXD = _MXC_BUILD_GPIO_PIN(1, 15, 4, 0x110, 0x370),
+	MX37_PIN_AUD3_BB_CK = _MXC_BUILD_GPIO_PIN(1, 16, 4, 0x114, 0x374),
+	MX37_PIN_AUD3_BB_FS = _MXC_BUILD_GPIO_PIN(1, 17, 4, 0x118, 0x378),
+	MX37_PIN_AUD5_RXFS = _MXC_BUILD_GPIO_PIN(1, 18, 4, 0x11C, 0x37C),
+	MX37_PIN_AUD5_RXC = _MXC_BUILD_GPIO_PIN(1, 19, 4, 0x120, 0x380),
+	MX37_PIN_AUD5_WB_TXD = _MXC_BUILD_GPIO_PIN(1, 20, 4, 0x124, 0x384),
+	MX37_PIN_AUD5_WB_RXD = _MXC_BUILD_GPIO_PIN(1, 21, 4, 0x128, 0x388),
+	MX37_PIN_AUD5_WB_CK = _MXC_BUILD_GPIO_PIN(1, 22, 4, 0x12C, 0x38C),
+	MX37_PIN_AUD5_WB_FS = _MXC_BUILD_GPIO_PIN(1, 23, 4, 0x130, 0x390),
+	MX37_PIN_CSPI1_MOSI = _MXC_BUILD_GPIO_PIN(2, 0, 4, 0x134, 0x394),
+	MX37_PIN_CSPI1_MISO = _MXC_BUILD_GPIO_PIN(2, 1, 4, 0x138, 0x398),
+	MX37_PIN_CSPI1_SS0 = _MXC_BUILD_GPIO_PIN(2, 2, 4, 0x13C, 0x39C),
+	MX37_PIN_CSPI1_SS1 = _MXC_BUILD_GPIO_PIN(2, 3, 4, 0x140, 0x3A0),
+	MX37_PIN_CSPI1_SCLK = _MXC_BUILD_GPIO_PIN(2, 4, 4, 0x144, 0x3A4),
+	MX37_PIN_CSPI2_MOSI = _MXC_BUILD_GPIO_PIN(2, 5, 4, 0x148, 0x3A8),
+	MX37_PIN_CSPI2_MISO = _MXC_BUILD_GPIO_PIN(2, 6, 4, 0x14C, 0x3AC),
+	MX37_PIN_CSPI2_SS0 = _MXC_BUILD_GPIO_PIN(2, 7, 4, 0x150, 0x3B0),
+	MX37_PIN_CSPI2_SS1 = _MXC_BUILD_GPIO_PIN(2, 8, 4, 0x154, 0x3B4),
+	MX37_PIN_CSPI2_SCLK = _MXC_BUILD_GPIO_PIN(2, 9, 4, 0x158, 0x3B8),
+	MX37_PIN_UART1_RXD = _MXC_BUILD_GPIO_PIN(1, 24, 4, 0x15C, 0x3BC),
+	MX37_PIN_UART1_TXD = _MXC_BUILD_GPIO_PIN(1, 25, 4, 0x160, 0x3C0),
+	MX37_PIN_UART1_RTS = _MXC_BUILD_GPIO_PIN(1, 26, 4, 0x164, 0x3C4),
+	MX37_PIN_UART1_CTS = _MXC_BUILD_GPIO_PIN(1, 27, 4, 0x168, 0x3C8),
+	MX37_PIN_UART1_DTR = _MXC_BUILD_GPIO_PIN(1, 28, 4, 0x16C, 0x3CC),
+	MX37_PIN_UART1_DSR = _MXC_BUILD_GPIO_PIN(1, 29, 4, 0x170, 0x3D0),
+	MX37_PIN_UART1_RI = _MXC_BUILD_GPIO_PIN(1, 30, 4, 0x174, 0x3D4),
+	MX37_PIN_UART1_DCD = _MXC_BUILD_GPIO_PIN(1, 31, 4, 0x178, 0x3D8),
+	MX37_PIN_OWIRE_LINE = _MXC_BUILD_GPIO_PIN(0, 31, 4, 0x17C, 0x3DC),
+	MX37_PIN_JTAG_DE_B = _MXC_BUILD_NON_GPIO_PIN(0x180, 0x3E0),
+	MX37_PIN_DI1_PIN11 = _MXC_BUILD_GPIO_PIN(2, 10, 4, 0x184, 0x3E4),
+	MX37_PIN_DI1_PIN12 = _MXC_BUILD_GPIO_PIN(2, 11, 4, 0x188, 0x3E8),
+	MX37_PIN_DI1_PIN13 = _MXC_BUILD_GPIO_PIN(2, 12, 4, 0x18C, 0x3EC),
+	MX37_PIN_DI1_D0_CS = _MXC_BUILD_GPIO_PIN(2, 13, 4, 0x190, 0x3F0),
+	MX37_PIN_DI1_PIN15 = _MXC_BUILD_GPIO_PIN(0, 30, 4, 0x194, 0),
+	MX37_PIN_DISP1_DAT0 = _MXC_BUILD_NON_GPIO_PIN(0x198, 0x3F4),
+	MX37_PIN_DISP1_DAT1 = _MXC_BUILD_NON_GPIO_PIN(0x19C, 0x3F8),
+	MX37_PIN_DISP1_DAT2 = _MXC_BUILD_NON_GPIO_PIN(0x1A0, 0x3FC),
+	MX37_PIN_DISP1_DAT3 = _MXC_BUILD_NON_GPIO_PIN(0x1A4, 0x400),
+	MX37_PIN_DISP1_DAT4 = _MXC_BUILD_NON_GPIO_PIN(0x1A8, 0x404),
+	MX37_PIN_DISP1_DAT5 = _MXC_BUILD_NON_GPIO_PIN(0x1AC, 0x408),
+	MX37_PIN_DISP1_DAT6 = _MXC_BUILD_NON_GPIO_PIN(0x1B0, 0x40C),
+	MX37_PIN_DISP1_DAT7 = _MXC_BUILD_NON_GPIO_PIN(0x1B4, 0x410),
+	MX37_PIN_DISP1_DAT8 = _MXC_BUILD_NON_GPIO_PIN(0x1B8, 0x414),
+	MX37_PIN_DISP1_DAT9 = _MXC_BUILD_NON_GPIO_PIN(0x1BC, 0x418),
+	MX37_PIN_DISP1_DAT10 = _MXC_BUILD_NON_GPIO_PIN(0x1C0, 0x41C),
+	MX37_PIN_DISP1_DAT11 = _MXC_BUILD_NON_GPIO_PIN(0x1C4, 0x420),
+	MX37_PIN_DISP1_DAT12 = _MXC_BUILD_NON_GPIO_PIN(0x1C8, 0x424),
+	MX37_PIN_DISP1_DAT13 = _MXC_BUILD_NON_GPIO_PIN(0x1CC, 0x428),
+	MX37_PIN_DISP1_DAT14 = _MXC_BUILD_NON_GPIO_PIN(0x1D0, 0x42C),
+	MX37_PIN_DISP1_DAT15 = _MXC_BUILD_NON_GPIO_PIN(0x1D4, 0x430),
+	MX37_PIN_DISP1_DAT16 = _MXC_BUILD_GPIO_PIN(0, 28, 4, 0x1D8, 0x434),
+	MX37_PIN_DISP1_DAT17 = _MXC_BUILD_GPIO_PIN(0, 29, 4, 0x1DC, 0x438),
+	MX37_PIN_DISP1_DAT18 = _MXC_BUILD_GPIO_PIN(2, 14, 4, 0x1E0, 0x43C),
+	MX37_PIN_DISP1_DAT19 = _MXC_BUILD_GPIO_PIN(2, 15, 4, 0x1E4, 0x440),
+	MX37_PIN_DISP1_DAT20 = _MXC_BUILD_GPIO_PIN(2, 16, 4, 0x1E8, 0x444),
+	MX37_PIN_DISP1_DAT21 = _MXC_BUILD_GPIO_PIN(2, 17, 4, 0x1EC, 0x448),
+	MX37_PIN_DISP1_DAT22 = _MXC_BUILD_GPIO_PIN(2, 18, 4, 0x1F0, 0x44C),
+	MX37_PIN_DISP1_DAT23 = _MXC_BUILD_GPIO_PIN(2, 18, 4, 0x1F4, 0x450),
+	MX37_PIN_PAD_DI1_PIN3 = _MXC_BUILD_GPIO_PIN(2, 29, 4, 0x1F8, 0),
+	MX37_PIN_DISP_CLK = _MXC_BUILD_GPIO_PIN(2, 30, 4, 0x1FC, 0),
+	MX37_PIN_DI1_PIN2 = _MXC_BUILD_GPIO_PIN(2, 31, 4, 0x200, 0),
+	MX37_PIN_BOOT_MODE1 = _MXC_BUILD_NON_GPIO_PIN(0x204, 0x454),
+	MX37_PIN_BOOT_MODE0 = _MXC_BUILD_NON_GPIO_PIN(0x208, 0x458),
+	MX37_PIN_WDOG_RST = _MXC_BUILD_GPIO_PIN(2, 28, 1, 0x20C, 0x464),
+	MX37_PIN_GPIO1_0 = _MXC_BUILD_GPIO_PIN(0, 0, 0, 0x210, 0x468),
+	MX37_PIN_GPIO1_1 = _MXC_BUILD_GPIO_PIN(0, 1, 0, 0x214, 0x46C),
+	MX37_PIN_GPIO1_2 = _MXC_BUILD_GPIO_PIN(0, 2, 1, 0x218, 0x470),
+	MX37_PIN_GPIO1_3 = _MXC_BUILD_GPIO_PIN(0, 3, 0, 0x21C, 0x474),
+	MX37_PIN_GPIO1_4 = _MXC_BUILD_GPIO_PIN(0, 4, 0, 0x220, 0x478),
+	MX37_PIN_GPIO1_5 = _MXC_BUILD_GPIO_PIN(0, 5, 0, 0x224, 0x47C),
+	MX37_PIN_GPIO1_6 = _MXC_BUILD_GPIO_PIN(0, 6, 0, 0x228, 0x480),
+	MX37_PIN_GPIO1_7 = _MXC_BUILD_GPIO_PIN(0, 7, 0, 0x22C, 0x484),
+	MX37_PIN_GRP_H5 = _MXC_BUILD_NON_GPIO_PIN(0x230, 0x4ec),
+} iomux_pin_name_t;
+
+#endif				/*  */
+#endif				/*  */
diff --git a/include/asm-arm/arch-mxc/mxc.h b/include/asm-arm/arch-mxc/mxc.h
index 4872b64..332dd32 100644
--- a/include/asm-arm/arch-mxc/mxc.h
+++ b/include/asm-arm/arch-mxc/mxc.h
@@ -96,33 +96,6 @@ int mxc_snoop_get_status(u32 num, u32 * statl, u32 * stath);
 #define GPIO_TO_PORT(n)		(n / GPIO_NUM_PIN)
 #define GPIO_TO_INDEX(n)	(n % GPIO_NUM_PIN)
 
-#ifdef CONFIG_MXC_TZIC
-/*
- *****************************************
- * TZIC Registers                        *
- *****************************************
- */
-
-#define TZIC_BASE               IO_ADDRESS(TZIC_BASE_ADDR)
-#define TZIC_INTCNTL            (TZIC_BASE + 0x0000)	/* control register */
-#define TZIC_INTTYPE            (TZIC_BASE + 0x0004)	/* Controller type register */
-#define TZIC_IMPID              (TZIC_BASE + 0x0008)	/* Distributor Implementer Identification Register */
-#define TZIC_PRIOMASK           (TZIC_BASE + 0x000C)	/* Priority Mask Reg */
-#define TZIC_SYNCCTRL           (TZIC_BASE + 0x0010)	/* Synchronizer Control register */
-#define TZIC_DSMINT             (TZIC_BASE + 0x0014)	/* DSM interrupt Holdoffregister */
-#define TZIC_INTSEC0            (TZIC_BASE + 0x0080)	/* interrupt security register 0 */
-#define TZIC_ENSET0             (TZIC_BASE + 0x0100)	/* Enable Set Register 0 */
-#define TZIC_ENCLEAR0           (TZIC_BASE + 0x0180)	/* Enable Clear Register 0 */
-#define TZIC_SRCSET0            (TZIC_BASE + 0x0200)	/* Source Set Register 0 */
-#define TZIC_SRCCLAR0           (TZIC_BASE + 0x0280)	/* Source Clear Register 0 */
-#define TZIC_PRIORITY0          (TZIC_BASE + 0x0400)	/* Priority Register 0 */
-#define TZIC_PND0               (TZIC_BASE + 0x0D00)	/* Pending Register 0 */
-#define TZIC_HIPND0             (TZIC_BASE + 0x0D80)	/* High Priority Pending Register */
-#define TZIC_WAKEUP0            (TZIC_BASE + 0x0E00)	/* Wakeup Config Register */
-#define TZIC_SWINT              (TZIC_BASE + 0x0F00)	/* Software Interrupt Rigger Register */
-#define TZIC_ID0                (TZIC_BASE + 0x0FD0)	/* Indentification Register 0 */
-
-#else
 /*
  *****************************************
  * AVIC Registers                        *
@@ -155,7 +128,6 @@ int mxc_snoop_get_status(u32 num, u32 * statl, u32 * stath);
 #define AVIC_NIPNDL		(AVIC_BASE + 0x5C)	/* norm int pending low */
 #define AVIC_FIPNDH		(AVIC_BASE + 0x60)	/* fast int pending high */
 #define AVIC_FIPNDL		(AVIC_BASE + 0x64)	/* fast int pending low */
-#endif				/* MXC_SUPPORT_TZIC */
 
 /*
  *****************************************
-- 
1.5.4.4

