From 606eda98bf0c118aabfcf9e8043c4b9c5844dd2b Mon Sep 17 00:00:00 2001
From: Rob Herring <r.herring@freescale.com>
Date: Tue, 12 Feb 2008 10:33:49 -0600
Subject: [PATCH] ENGR00065563 Driver and MSL updates for 2.6.24

---
 arch/arm/Kconfig                                   |   14 +-
 arch/arm/configs/imx27ads_defconfig                |    4 +-
 arch/arm/configs/imx31ads_defconfig                |    2 +-
 arch/arm/configs/mxc30030ads_defconfig             |    2 +-
 arch/arm/configs/mxc30030evb_defconfig             |    2 +-
 arch/arm/mach-mx27/Makefile                        |    3 +-
 arch/arm/mach-mx27/crm_regs.h                      |   10 +-
 arch/arm/mach-mx27/devices.c                       |   68 ++--
 arch/arm/mach-mx27/mx27ads.c                       |    6 +-
 arch/arm/mach-mx27/pm.c                            |   35 +-
 arch/arm/mach-mx27/serial.h                        |   12 +-
 arch/arm/mach-mx27/time.c                          |    4 +-
 arch/arm/mach-mx27/usb.c                           |    8 +-
 arch/arm/mach-mx3/devices.c                        |   91 +---
 arch/arm/mach-mx3/dvfs_v2.c                        |    4 +-
 arch/arm/mach-mx3/mx31ads.c                        |   49 +-
 arch/arm/mach-mx3/mxc_pm.c                         |    6 +-
 arch/arm/mach-mx3/pm.c                             |   42 +--
 arch/arm/mach-mx3/serial.h                         |   10 +-
 arch/arm/mach-mx3/time.c                           |  152 ------
 arch/arm/mach-mx3/usb.c                            |    8 +-
 arch/arm/mach-mxc91321/Makefile                    |    9 +-
 arch/arm/mach-mxc91321/board-mxc30030ads.h         |    4 +-
 arch/arm/mach-mxc91321/board-mxc30030evb.h         |    2 +-
 arch/arm/mach-mxc91321/devices.c                   |   56 +--
 arch/arm/mach-mxc91321/i30030ads.c                 |    6 +-
 arch/arm/mach-mxc91321/i30030evb.c                 |   10 +-
 arch/arm/mach-mxc91321/mm.c                        |    5 -
 arch/arm/mach-mxc91321/mxc30030ads.c               |    8 +-
 arch/arm/mach-mxc91321/mxc30030evb.c               |   24 +-
 arch/arm/mach-mxc91321/pm.c                        |   30 +-
 arch/arm/mach-mxc91321/serial.h                    |    8 +-
 arch/arm/oprofile/evtmon_regs.h                    |    2 +-
 arch/arm/plat-mxc/Makefile                         |   11 +-
 arch/arm/plat-mxc/dptc.c                           |    5 +-
 arch/arm/plat-mxc/irq.c                            |   16 +-
 arch/arm/plat-mxc/mc13783_xc.c                     |    4 +-
 arch/arm/plat-mxc/sdma/Makefile                    |    4 +-
 arch/arm/plat-mxc/sdma/iapi/src/Makefile           |   13 +
 arch/arm/plat-mxc/sdma/sdma.c                      |    6 +-
 arch/arm/plat-mxc/time.c                           |    4 +-
 drivers/char/watchdog/mxc_wdt.c                    |  385 ---------------
 drivers/char/watchdog/mxc_wdt.h                    |   37 --
 drivers/ide/arm/mxc_ide.c                          |    3 +-
 drivers/input/keyboard/mxc_keyb.c                  |   46 ++-
 drivers/input/keyboard/mxc_keyb.h                  |    2 +-
 drivers/input/touchscreen/mxc_ts.c                 |   15 +-
 drivers/media/video/mxc/capture/mx27_csi.c         |    4 +-
 drivers/media/video/mxc/capture/mx27_prpsw.c       |    8 +-
 .../media/video/mxc/capture/mx27_v4l2_capture.c    |    1 -
 drivers/media/video/mxc/capture/mxc_v4l2_capture.c |    1 -
 drivers/media/video/mxc/output/mx27_pp.c           |    8 +-
 drivers/media/video/mxc/output/mx27_v4l2_output.c  |    1 -
 drivers/media/video/mxc/output/mxc_v4l2_output.c   |    1 -
 drivers/mmc/host/mxc_mmc.c                         |   25 +-
 drivers/mtd/nand/mxc_nd.c                          |   24 +-
 drivers/mtd/nand/mxc_nd2.c                         |    4 +-
 drivers/mxc/hmp4e/mxc_hmp4e.c                      |    2 +-
 drivers/mxc/pm/dptc_mx27.c                         |    4 +-
 drivers/mxc/security/mxc_scc.c                     |   14 +-
 drivers/mxc/security/rng/rng_driver.c              |    6 +-
 drivers/mxc/security/sahara2/include/sah_kernel.h  |    2 +-
 drivers/mxc/vpu/mxc_vpu.c                          |   10 +-
 drivers/net/smc911x.h                              |    1 +
 drivers/otg/hardware/arc-dev.c                     |    6 -
 drivers/otg/hardware/arc-pcd.c                     |   24 +-
 drivers/otg/hardware/mxc-ocd.c                     |   12 +-
 drivers/otg/otg/otg-linux.h                        |    2 +-
 drivers/pcmcia/mx31ads-pcmcia.c                    |    2 +-
 drivers/serial/mxc_uart_early.c                    |    2 +-
 drivers/spi/mxc_spi.c                              |    4 +-
 drivers/usb/gadget/arcotg_udc.c                    |   50 +--
 drivers/usb/host/ehci-arc.c                        |   14 +-
 drivers/usb/usblan/usblan-compat.h                 |    2 +-
 drivers/video/backlight/mxc_ipu_bl.c               |    4 +-
 drivers/video/backlight/mxc_lcdc_bl.c              |    4 +-
 drivers/video/backlight/mxc_pmic_bl.c              |    4 +-
 drivers/video/mxc/mx2fb.c                          |    4 +-
 drivers/watchdog/mxc_wdt.c                         |  385 +++++++++++++++
 drivers/watchdog/mxc_wdt.h                         |   37 ++
 include/asm-arm/arch-mxc/arc_otg.h                 |   10 -
 include/asm-arm/arch-mxc/dma.h                     |  236 ++++++++++-
 include/asm-arm/arch-mxc/entry-macro.S             |    2 +
 include/asm-arm/arch-mxc/fsl_usb.h                 |   42 --
 include/asm-arm/arch-mxc/irqs.h                    |    4 +-
 include/asm-arm/arch-mxc/mx21.h                    |  110 +++---
 include/asm-arm/arch-mxc/mx27.h                    |  144 +++---
 include/asm-arm/arch-mxc/mx31.h                    |    4 +-
 include/asm-arm/arch-mxc/mxc.h                     |    2 +-
 include/asm-arm/arch-mxc/mxc91321.h                |  194 ++++-----
 include/asm-arm/arch-mxc/mxc_scc.h                 |    4 +-
 include/asm-arm/arch-mxc/pmic_external.h           |  494 --------------------
 include/asm-arm/arch-mxc/uncompress.h              |    2 +
 include/asm-arm/ide.h                              |    2 +-
 94 files changed, 1261 insertions(+), 1908 deletions(-)

Index: linux-2.6.24/arch/arm/Kconfig
===================================================================
--- linux-2.6.24.orig/arch/arm/Kconfig	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/Kconfig	2009-01-24 22:01:10.000000000 +0100
@@ -313,15 +313,6 @@
 	  If you have any questions or comments about the Linux kernel port
 	  to this board, send e-mail to <sjhill@cotw.com>.
 
-config ARCH_MXC
-	bool "Freescale MXC/iMX-based"
-	select ISA
-	select ARCH_MTD_XIP
-	select GENERIC_TIME
-	select GENERIC_CLOCKEVENTS
-	help
-	  Support for Freescale MXC/iMX-based family of processors
-
 config ARCH_KS8695
 	bool "Micrel/Kendin KS8695"
 	select GENERIC_GPIO
@@ -343,6 +334,9 @@
 config ARCH_MXC
 	bool "Freescale MXC/iMX-based"
 	select ARCH_MTD_XIP
+	select ISA
+	select GENERIC_TIME
+	select GENERIC_CLOCKEVENTS
 	help
 	  Support for Freescale MXC/iMX-based family of processors
 
@@ -1012,7 +1006,7 @@
 if PCMCIA || ARCH_CLPS7500 || ARCH_IOP32X || ARCH_IOP33X || ARCH_IXP4XX \
 	|| ARCH_L7200 || ARCH_LH7A40X || ARCH_PXA || ARCH_RPC \
 	|| ARCH_S3C2410 || ARCH_SA1100 || ARCH_SHARK || FOOTBRIDGE \
-	|| ARCH_IXP23XX || ARCH_MX3 || ARCH_MX27 || ARCH_MX33
+	|| ARCH_IXP23XX || ARCH_MX3 || ARCH_MX27
 source "drivers/ide/Kconfig"
 endif
 
Index: linux-2.6.24/arch/arm/configs/imx27ads_defconfig
===================================================================
--- linux-2.6.24.orig/arch/arm/configs/imx27ads_defconfig	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/configs/imx27ads_defconfig	2009-01-24 22:01:10.000000000 +0100
@@ -577,7 +577,7 @@
 CONFIG_IDE_GENERIC=y
 # CONFIG_IDEPCI_PCIBUS_ORDER is not set
 # CONFIG_IDE_ARM is not set
-CONFIG_BLK_DEV_IDE_MXC=y
+# CONFIG_BLK_DEV_IDE_MXC is not set
 # CONFIG_IDE_CHIPSETS is not set
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_BLK_DEV_HD is not set
@@ -1390,7 +1390,7 @@
 #
 # Advanced Power Management devices
 #
-CONFIG_MX27_DPTC=y
+# CONFIG_MX27_DPTC is not set
 
 #
 # MXC Security Drivers
Index: linux-2.6.24/arch/arm/configs/imx31ads_defconfig
===================================================================
--- linux-2.6.24.orig/arch/arm/configs/imx31ads_defconfig	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/configs/imx31ads_defconfig	2009-01-24 22:01:10.000000000 +0100
@@ -593,7 +593,7 @@
 CONFIG_IDE_GENERIC=m
 # CONFIG_IDEPCI_PCIBUS_ORDER is not set
 # CONFIG_IDE_ARM is not set
-CONFIG_BLK_DEV_IDE_MXC=m
+# CONFIG_BLK_DEV_IDE_MXC is not set
 # CONFIG_IDE_CHIPSETS is not set
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_BLK_DEV_HD is not set
Index: linux-2.6.24/arch/arm/configs/mxc30030ads_defconfig
===================================================================
--- linux-2.6.24.orig/arch/arm/configs/mxc30030ads_defconfig	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/configs/mxc30030ads_defconfig	2009-01-24 22:01:10.000000000 +0100
@@ -1047,7 +1047,7 @@
 #
 # Advanced Power Management devices
 #
-CONFIG_MXC_DPTC=y
+# CONFIG_MXC_DPTC is not set
 
 #
 # MXC Security Drivers
Index: linux-2.6.24/arch/arm/configs/mxc30030evb_defconfig
===================================================================
--- linux-2.6.24.orig/arch/arm/configs/mxc30030evb_defconfig	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/configs/mxc30030evb_defconfig	2009-01-24 22:01:10.000000000 +0100
@@ -1251,7 +1251,7 @@
 #
 # Advanced Power Management devices
 #
-CONFIG_MXC_DPTC=y
+# CONFIG_MXC_DPTC is not set
 
 #
 # MXC Security Drivers
Index: linux-2.6.24/arch/arm/mach-mx27/Makefile
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx27/Makefile	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx27/Makefile	2009-01-24 22:01:10.000000000 +0100
@@ -4,9 +4,8 @@
 
 # Object file lists.
 
-obj-y := mm.o time.o dma.o gpio_mux.o clock.o devices.o serial.o system.o usb.o cpu.o
+obj-y := mm.o time.o dma.o gpio_mux.o clock.o devices.o serial.o system.o usb.o cpu.o dptc.o
 obj-$(CONFIG_MACH_MX27ADS)	+= mx27ads.o mx27ads_gpio.o
 
 # power management
 obj-$(CONFIG_PM) 		+= pm.o mxc_pm.o
-obj-$(CONFIG_DPM)		+= dpm.o
Index: linux-2.6.24/arch/arm/mach-mx27/crm_regs.h
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx27/crm_regs.h	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx27/crm_regs.h	2009-01-24 22:01:10.000000000 +0100
@@ -33,11 +33,11 @@
 #define CCM_PMCTL               (IO_ADDRESS(CCM_BASE_ADDR) + 0x2c)
 #define CCM_PMCOUNT             (IO_ADDRESS(CCM_BASE_ADDR) + 0x30)
 #define CCM_WKGDCTL             (IO_ADDRESS(CCM_BASE_ADDR) + 0x34)
-#define MXC_CCM_PMCR0		SYSCTRL_BASE + 0x60
-#define MXC_CCM_DCVR0		SYSCTRL_BASE + 0x64)
-#define MXC_CCM_DCVR1		SYSCTRL_BASE + 0x68)
-#define MXC_CCM_DCVR2		SYSCTRL_BASE + 0x72)
-#define MXC_CCM_DCVR3		SYSCTRL_BASE + 0x76)
+#define MXC_CCM_PMCR0		(SYSCTRL_BASE + 0x60)
+#define MXC_CCM_DCVR0		(SYSCTRL_BASE + 0x64)
+#define MXC_CCM_DCVR1		(SYSCTRL_BASE + 0x68)
+#define MXC_CCM_DCVR2		(SYSCTRL_BASE + 0x72)
+#define MXC_CCM_DCVR3		(SYSCTRL_BASE + 0x76)
 #define MXC_CCM_PMCR0_DPTEN	0x00000001
 #define MXC_CCM_DIE		0x00000002
 #define MXC_CCM_DIM		0x0000000C
Index: linux-2.6.24/arch/arm/mach-mx27/devices.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx27/devices.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx27/devices.c	2009-01-24 22:01:10.000000000 +0100
@@ -71,7 +71,7 @@
 	 .flags = IORESOURCE_MEM,
 	 },
 	{
-	 .start = INT_RTC,
+	 .start = MXC_INT_RTC,
 	 .flags = IORESOURCE_IRQ,
 	 },
 };
@@ -165,8 +165,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_SDHC1,
-	       .end = INT_SDHC1,
+	       .start = MXC_INT_SDHC1,
+	       .end = MXC_INT_SDHC1,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[2] = {
@@ -174,11 +174,6 @@
 	       .end = 0,
 	       .flags = IORESOURCE_IRQ,
 	       },
-	[3] = {
-	       .start = MXC_SDIO1_CARD_IRQ,
-	       .end = MXC_SDIO1_CARD_IRQ,
-	       .flags = IORESOURCE_IRQ,
-	       },
 };
 
 /*!
@@ -191,8 +186,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_SDHC2,
-	       .end = INT_SDHC2,
+	       .start = MXC_INT_SDHC2,
+	       .end = MXC_INT_SDHC2,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[2] = {
@@ -200,11 +195,6 @@
 	       .end = 0,
 	       .flags = IORESOURCE_IRQ,
 	       },
-	[3] = {
-	       .start = MXC_SDIO2_CARD_IRQ,
-	       .end = MXC_SDIO2_CARD_IRQ,
-	       .flags = IORESOURCE_IRQ,
-	       },
 };
 
 /*! Device Definition for MXC SDHC1 */
@@ -242,8 +232,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_SDHC3,
-	       .end = INT_SDHC3,
+	       .start = MXC_INT_SDHC3,
+	       .end = MXC_INT_SDHC3,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[2] = {
@@ -312,8 +302,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_CSPI1,
-	       .end = INT_CSPI1,
+	       .start = MXC_INT_CSPI1,
+	       .end = MXC_INT_CSPI1,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
@@ -349,8 +339,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_CSPI2,
-	       .end = INT_CSPI2,
+	       .start = MXC_INT_CSPI2,
+	       .end = MXC_INT_CSPI2,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
@@ -385,8 +375,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_CSPI3,
-	       .end = INT_CSPI3,
+	       .start = MXC_INT_CSPI3,
+	       .end = MXC_INT_CSPI3,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
@@ -527,8 +517,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_I2C,
-	       .end = INT_I2C,
+	       .start = MXC_INT_I2C,
+	       .end = MXC_INT_I2C,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
@@ -550,8 +540,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_I2C2,
-	       .end = INT_I2C2,
+	       .start = MXC_INT_I2C2,
+	       .end = MXC_INT_I2C2,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
@@ -629,38 +619,38 @@
 	{
 	 .num = 0,
 	 .base = IO_ADDRESS(GPIO_BASE_ADDR),
-	 .irq = INT_GPIO,
-	 .virtual_irq_start = MXC_GPIO_BASE,
+	 .irq = MXC_INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE,
 	 },
 	{
 	 .num = 1,
 	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x100,
-	 .irq = INT_GPIO,
-	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN,
+	 .irq = MXC_INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN,
 	 },
 	{
 	 .num = 2,
 	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x200,
-	 .irq = INT_GPIO,
-	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN * 2,
+	 .irq = MXC_INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 2,
 	 },
 	{
 	 .num = 3,
 	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x300,
-	 .irq = INT_GPIO,
-	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN * 3,
+	 .irq = MXC_INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 3,
 	 },
 	{
 	 .num = 4,
 	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x400,
-	 .irq = INT_GPIO,
-	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN * 4,
+	 .irq = MXC_INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 4,
 	 },
 	{
 	 .num = 5,
 	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x500,
-	 .irq = INT_GPIO,
-	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN * 5,
+	 .irq = MXC_INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 5,
 	 },
 };
 
Index: linux-2.6.24/arch/arm/mach-mx27/mx27ads.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx27/mx27ads.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx27/mx27ads.c	2009-01-24 22:01:10.000000000 +0100
@@ -122,7 +122,7 @@
 static struct keypad_data evb_6_by_6_keypad = {
 	.rowmax = 6,
 	.colmax = 6,
-	.irq = INT_KPP,
+	.irq = MXC_INT_KPP,
 	.learning = 0,
 	.delay = 2,
 	.matrix = mxckpd_keycodes,
@@ -130,8 +130,8 @@
 
 static struct resource mxc_kpp_resources[] = {
 	[0] = {
-	       .start = INT_KPP,
-	       .end = INT_KPP,
+	       .start = MXC_INT_KPP,
+	       .end = MXC_INT_KPP,
 	       .flags = IORESOURCE_IRQ,
 	       }
 };
Index: linux-2.6.24/arch/arm/mach-mx27/pm.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx27/pm.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx27/pm.c	2009-01-24 22:01:10.000000000 +0100
@@ -38,34 +38,25 @@
  * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include <linux/pm.h>
-#include <linux/sched.h>
-#include <linux/proc_fs.h>
-#include <linux/pm.h>
+#include <linux/kernel.h>
+#include <linux/suspend.h>
 
-#include <asm/io.h>
 #include <asm/arch/mxc_pm.h>
 
 /*
  * TODO: whatta save?
  */
 
-static int mx27_pm_enter(suspend_state_t state)
+static int mx27_suspend_enter(suspend_state_t state)
 {
 	pr_debug("Hi, from mx27_pm_enter\n");
 	switch (state) {
-	case PM_SUSPEND_MEM:
-		mxc_pm_lowpower(STOP_MODE);
-		break;
-
 	case PM_SUSPEND_STANDBY:
-		mxc_pm_lowpower(WAIT_MODE);
+		mxc_pm_lowpower(STOP_MODE);
 		break;
-
-	case PM_SUSPEND_STOP:
+	case PM_SUSPEND_MEM:
 		mxc_pm_lowpower(DSM_MODE);
 		break;
-
 	default:
 		return -1;
 	}
@@ -75,7 +66,7 @@
 /*
  * Called after processes are frozen, but before we shut down devices.
  */
-static int mx27_pm_prepare(suspend_state_t state)
+static int mx27_suspend_prepare(void)
 {
 	return 0;
 }
@@ -83,21 +74,21 @@
 /*
  * Called after devices are re-setup, but before processes are thawed.
  */
-static int mx27_pm_finish(suspend_state_t state)
+static void mx27_suspend_finish(void)
 {
-	return 0;
+	return;
 }
 
-struct pm_ops mx27_pm_ops = {
-	.prepare = mx27_pm_prepare,
-	.enter = mx27_pm_enter,
-	.finish = mx27_pm_finish,
+struct platform_suspend_ops mx27_suspend_ops = {
+	.prepare = mx27_suspend_prepare,
+	.enter = mx27_suspend_enter,
+	.finish = mx27_suspend_finish,
 };
 
 static int __init mx27_pm_init(void)
 {
 	pr_debug("Power Management for Freescale MX27\n");
-	pm_set_ops(&mx27_pm_ops);
+	suspend_set_ops(&mx27_suspend_ops);
 
 	return 0;
 }
Index: linux-2.6.24/arch/arm/mach-mx27/serial.h
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx27/serial.h	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx27/serial.h	2009-01-24 22:01:10.000000000 +0100
@@ -117,7 +117,7 @@
  * number of the ANDed interrupt in case the interrupts are muxed. There exists
  * a define like this for each UART port.
  */
-#define UART1_INT1              INT_UART1
+#define UART1_INT1              MXC_INT_UART1
 /*!
  * This define specifies the receiver interrupt number. If the interrupts of
  * the UART are muxed, then we specify here a dummy value -1. There exists a
@@ -138,31 +138,31 @@
 #define UART1_SHARED_PERI       -1
 /* UART 2 configuration */
 #define UART2_MUX_INTS          INTS_MUXED
-#define UART2_INT1              INT_UART2
+#define UART2_INT1              MXC_INT_UART2
 #define UART2_INT2              -1
 #define UART2_INT3              -1
 #define UART2_SHARED_PERI       -1
 /* UART 3 configuration */
 #define UART3_MUX_INTS          INTS_MUXED
-#define UART3_INT1              INT_UART3
+#define UART3_INT1              MXC_INT_UART3
 #define UART3_INT2              -1
 #define UART3_INT3              -1
 #define UART3_SHARED_PERI       -1
 /* UART 4 configuration */
 #define UART4_MUX_INTS          INTS_MUXED
-#define UART4_INT1              INT_UART4
+#define UART4_INT1              MXC_INT_UART4
 #define UART4_INT2              -1
 #define UART4_INT3              -1
 #define UART4_SHARED_PERI       -1
 /* UART 5 configuration */
 #define UART5_MUX_INTS          INTS_MUXED
-#define UART5_INT1              INT_UART5
+#define UART5_INT1              MXC_INT_UART5
 #define UART5_INT2              -1
 #define UART5_INT3              -1
 #define UART5_SHARED_PERI       -1
 /* UART 6 configuration */
 #define UART6_MUX_INTS          INTS_MUXED
-#define UART6_INT1              INT_UART6
+#define UART6_INT1              MXC_INT_UART6
 #define UART6_INT2              -1
 #define UART6_INT3              -1
 #define UART6_SHARED_PERI       -1
Index: linux-2.6.24/arch/arm/mach-mx27/time.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx27/time.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx27/time.c	2009-01-24 22:01:10.000000000 +0100
@@ -107,6 +107,8 @@
 		reg &= ~GPTCR_COMPEN;
 		__raw_writel(reg, MXC_GPT_GPTCR);
 		break;
+	case CLOCK_EVT_MODE_RESUME:
+		break;
 	}
 }
 
@@ -224,7 +226,7 @@
 	gpt_clockevent.cpumask = cpumask_of_cpu(0);
 	clockevents_register_device(&gpt_clockevent);
 
-	ret = setup_irq(INT_GPT, &timer_irq);
+	ret = setup_irq(MXC_INT_GPT, &timer_irq);
 	if (ret < 0) {
 		goto err;
 	}
Index: linux-2.6.24/arch/arm/mach-mx27/usb.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx27/usb.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx27/usb.c	2009-01-24 22:01:10.000000000 +0100
@@ -85,7 +85,7 @@
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = INT_USB1,
+		.start = MXC_INT_USB1,
 		.flags = IORESOURCE_IRQ,
 	},
 };
@@ -116,7 +116,7 @@
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = INT_USB2,
+		.start = MXC_INT_USB2,
 		.flags = IORESOURCE_IRQ,
 	},
 };
@@ -179,7 +179,7 @@
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = INT_USB3,
+		.start = MXC_INT_USB3,
 		.flags = IORESOURCE_IRQ,
 	},
 };
@@ -258,7 +258,7 @@
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = INT_USB3,
+		.start = MXC_INT_USB3,
 		.flags = IORESOURCE_IRQ,
 	},
 };
Index: linux-2.6.24/arch/arm/mach-mx3/devices.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx3/devices.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx3/devices.c	2009-01-24 22:01:10.000000000 +0100
@@ -30,37 +30,6 @@
 #include "sdma_script_code.h"
 #include "sdma_script_code_pass2.h"
 
-#if 0
-int board_device_enable(u32 device_id);
-int board_device_disable(u32 device_id);
-
-int mxc_device_enable(u32 device_id)
-{
-	int ret = 0;
-
-	switch (device_id) {
-	default:
-		ret = board_device_enable(device_id);
-	}
-
-	return ret;
-}
-
-int mxc_device_disable(u32 device_id)
-{
-	int ret = 0;
-
-	switch (device_id) {
-	default:
-		ret = board_device_disable(device_id);
-	}
-	return ret;
-}
-
-EXPORT_SYMBOL(mxc_device_enable);
-EXPORT_SYMBOL(mxc_device_disable);
-#endif
-
 #ifndef CONFIG_MXC_DPTC
 extern struct dptc_wp dptc_wp_allfreq_26ckih[DPTC_WP_SUPPORTED];
 extern struct dptc_wp dptc_wp_allfreq_27ckih[DPTC_WP_SUPPORTED];
@@ -184,7 +153,7 @@
 	 .flags = IORESOURCE_MEM,
 	 },
 	{
-	 .start = INT_RTC,
+	 .start = MXC_INT_RTC,
 	 .flags = IORESOURCE_IRQ,
 	 },
 };
@@ -249,11 +218,11 @@
 	 .flags = IORESOURCE_MEM,
 	 },
 	{
-	 .start = INT_IPU_SYN,
+	 .start = MXC_INT_IPU_SYN,
 	 .flags = IORESOURCE_IRQ,
 	 },
 	{
-	 .start = INT_IPU_ERR,
+	 .start = MXC_INT_IPU_ERR,
 	 .flags = IORESOURCE_IRQ,
 	 },
 };
@@ -405,8 +374,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_MMC_SDHC1,
-	       .end = INT_MMC_SDHC1,
+	       .start = MXC_INT_MMC_SDHC1,
+	       .end = MXC_INT_MMC_SDHC1,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[2] = {
@@ -414,11 +383,6 @@
 	       .end = 0,
 	       .flags = IORESOURCE_IRQ,
 	       },
-	[3] = {
-	       .start = MXC_SDIO1_CARD_IRQ,
-	       .end = MXC_SDIO1_CARD_IRQ,
-	       .flags = IORESOURCE_IRQ,
-	       },
 };
 
 /*!
@@ -431,8 +395,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_MMC_SDHC2,
-	       .end = INT_MMC_SDHC2,
+	       .start = MXC_INT_MMC_SDHC2,
+	       .end = MXC_INT_MMC_SDHC2,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[2] = {
@@ -440,11 +404,6 @@
 	       .end = 0,
 	       .flags = IORESOURCE_IRQ,
 	       },
-	[3] = {
-	       .start = MXC_SDIO2_CARD_IRQ,
-	       .end = MXC_SDIO2_CARD_IRQ,
-	       .flags = IORESOURCE_IRQ,
-	       },
 };
 
 /*! Device Definition for MXC SDHC1 */
@@ -513,8 +472,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_CSPI1,
-	       .end = INT_CSPI1,
+	       .start = MXC_INT_CSPI1,
+	       .end = MXC_INT_CSPI1,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
@@ -550,8 +509,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_CSPI2,
-	       .end = INT_CSPI2,
+	       .start = MXC_INT_CSPI2,
+	       .end = MXC_INT_CSPI2,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
@@ -586,8 +545,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_CSPI3,
-	       .end = INT_CSPI3,
+	       .start = MXC_INT_CSPI3,
+	       .end = MXC_INT_CSPI3,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
@@ -648,8 +607,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_I2C,
-	       .end = INT_I2C,
+	       .start = MXC_INT_I2C,
+	       .end = MXC_INT_I2C,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
@@ -671,8 +630,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_I2C2,
-	       .end = INT_I2C2,
+	       .start = MXC_INT_I2C2,
+	       .end = MXC_INT_I2C2,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
@@ -694,8 +653,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_I2C3,
-	       .end = INT_I2C3,
+	       .start = MXC_INT_I2C3,
+	       .end = MXC_INT_I2C3,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
@@ -763,20 +722,20 @@
 	{
 	 .num = 0,
 	 .base = IO_ADDRESS(GPIO1_BASE_ADDR),
-	 .irq = INT_GPIO1,
-	 .virtual_irq_start = MXC_GPIO_BASE,
+	 .irq = MXC_INT_GPIO1,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE,
 	 },
 	{
 	 .num = 1,
 	 .base = IO_ADDRESS(GPIO2_BASE_ADDR),
-	 .irq = INT_GPIO2,
-	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN,
+	 .irq = MXC_INT_GPIO2,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN,
 	 },
 	{
 	 .num = 2,
 	 .base = IO_ADDRESS(GPIO3_BASE_ADDR),
-	 .irq = INT_GPIO3,
-	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN * 2,
+	 .irq = MXC_INT_GPIO3,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 2,
 	 },
 };
 
Index: linux-2.6.24/arch/arm/mach-mx3/dvfs_v2.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx3/dvfs_v2.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx3/dvfs_v2.c	2009-01-24 22:01:10.000000000 +0100
@@ -443,7 +443,7 @@
 	}
 
 	/* request the DVFS interrupt */
-	err = request_irq(INT_DVFS, dvfs_irq, IRQF_DISABLED, "dvfs", NULL);
+	err = request_irq(MXC_INT_DVFS, dvfs_irq, IRQF_DISABLED, "dvfs", NULL);
 	if (err) {
 		printk(KERN_ERR "DVFS: Unable to attach to DVFS interrupt");
 	}
@@ -463,7 +463,7 @@
 	stop_dvfs();
 
 	/* release the DVFS interrupt */
-	free_irq(INT_DVFS, NULL);
+	free_irq(MXC_INT_DVFS, NULL);
 
 	dvfs_sysdev_ctrl_exit();
 
Index: linux-2.6.24/arch/arm/mach-mx3/mx31ads.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx3/mx31ads.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx3/mx31ads.c	2009-01-24 22:01:10.000000000 +0100
@@ -122,8 +122,8 @@
 
 static struct resource mxc_kpp_resources[] = {
 	[0] = {
-	       .start = INT_KPP,
-	       .end = INT_KPP,
+	       .start = MXC_INT_KPP,
+	       .end = MXC_INT_KPP,
 	       .flags = IORESOURCE_IRQ,
 	       }
 };
@@ -131,7 +131,7 @@
 static struct keypad_data evb_8_by_8_keypad = {
 	.rowmax = 8,
 	.colmax = 8,
-	.irq = INT_KPP,
+	.irq = MXC_INT_KPP,
 	.learning = 0,
 	.delay = 2,
 	.matrix = keymapping,
@@ -165,22 +165,21 @@
  */
 static struct plat_serial8250_port serial_platform_data[] = {
 	{
-		.membase  = (void *)(PBC_BASE_ADDRESS + PBC_SC16C652_UARTA),
-		.mapbase  = (unsigned long)(CS4_BASE_ADDR + PBC_SC16C652_UARTA),
-		.irq      = EXPIO_INT_XUART_INTA,
-		.uartclk  = 14745600,
-		.regshift = 0,
-		.iotype   = UPIO_MEM,
-		.flags    = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_AUTO_IRQ,
-	}, {
-		.membase  = (void *)(PBC_BASE_ADDRESS + PBC_SC16C652_UARTB),
-		.mapbase  = (unsigned long)(CS4_BASE_ADDR + PBC_SC16C652_UARTB),
-		.irq      = EXPIO_INT_XUART_INTB,
-		.uartclk  = 14745600,
-		.regshift = 0,
-		.iotype   = UPIO_MEM,
-		.flags    = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_AUTO_IRQ,
-	},
+	 .membase = (void *)(PBC_BASE_ADDRESS + PBC_SC16C652_UARTA),
+	 .mapbase = (unsigned long)(CS4_BASE_ADDR + PBC_SC16C652_UARTA),
+	 .irq = EXPIO_INT_XUART_INTA,
+	 .uartclk = 14745600,
+	 .regshift = 0,
+	 .iotype = UPIO_MEM,
+	 .flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_AUTO_IRQ,},
+	{
+	 .membase = (void *)(PBC_BASE_ADDRESS + PBC_SC16C652_UARTB),
+	 .mapbase = (unsigned long)(CS4_BASE_ADDR + PBC_SC16C652_UARTB),
+	 .irq = EXPIO_INT_XUART_INTB,
+	 .uartclk = 14745600,
+	 .regshift = 0,
+	 .iotype = UPIO_MEM,
+	 .flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_AUTO_IRQ,},
 	{},
 };
 
@@ -429,8 +428,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_UART2,
-	       .end = INT_UART2,
+	       .start = MXC_INT_UART2,
+	       .end = MXC_INT_UART2,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[2] = {
@@ -439,13 +438,13 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[3] = {
-	       .start = INT_FIRI,
-	       .end = INT_FIRI,
+	       .start = MXC_INT_FIRI,
+	       .end = MXC_INT_FIRI,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[4] = {
-	       .start = INT_UART2,
-	       .end = INT_UART2,
+	       .start = MXC_INT_UART2,
+	       .end = MXC_INT_UART2,
 	       .flags = IORESOURCE_IRQ,
 	       }
 };
Index: linux-2.6.24/arch/arm/mach-mx3/mxc_pm.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx3/mxc_pm.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx3/mxc_pm.c	2009-01-24 22:01:10.000000000 +0100
@@ -301,7 +301,7 @@
 		/* State Retention mode */
 		lpm = 2;
 		/* Disable timer interrupt */
-		disable_irq(INT_GPT);
+		disable_irq(MXC_INT_GPT);
 		enable_flag = 1;
 		break;
 
@@ -309,7 +309,7 @@
 		/* Deep Sleep Mode */
 		lpm = 3;
 		/* Disable timer interrupt */
-		disable_irq(INT_GPT);
+		disable_irq(MXC_INT_GPT);
 		enable_flag = 1;
 		/* Enabled Well Bias
 		 * SBYCS = 0, MCU clock source is disabled*/
@@ -334,7 +334,7 @@
 
 	if (enable_flag) {
 		/* Enable timer interrupt */
-		enable_irq(INT_GPT);
+		enable_irq(MXC_INT_GPT);
 	}
 	local_irq_enable();
 }
Index: linux-2.6.24/arch/arm/mach-mx3/pm.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx3/pm.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx3/pm.c	2009-01-24 22:01:10.000000000 +0100
@@ -38,41 +38,25 @@
  * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include <linux/pm.h>
-#include <linux/sched.h>
-#include <linux/proc_fs.h>
-#include <linux/pm.h>
+#include <linux/kernel.h>
+#include <linux/suspend.h>
 
-#include <asm/io.h>
 #include <asm/arch/mxc_pm.h>
 
-#define HAC_GRP  5
-#define GEMK_GRP 5
-#define GPIO_GRP 4
-#define WDOG_GRP 4
-#define GPT_GRP  2
-#define UART_GRP 0
-
 /*
  * TODO: whatta save?
  */
 
-static int mx31_pm_enter(suspend_state_t state)
+static int mx31_suspend_enter(suspend_state_t state)
 {
 	printk(KERN_INFO "Hi, from mx31_pm_enter\n");
 	switch (state) {
 	case PM_SUSPEND_MEM:
-		mxc_pm_lowpower(STOP_MODE);
+		mxc_pm_lowpower(DSM_MODE);
 		break;
-
 	case PM_SUSPEND_STANDBY:
-		mxc_pm_lowpower(WAIT_MODE);
-		break;
-
-	case PM_SUSPEND_STOP:
-		mxc_pm_lowpower(DSM_MODE);
+		mxc_pm_lowpower(STOP_MODE);
 		break;
-
 	default:
 		return -1;
 	}
@@ -82,7 +66,7 @@
 /*
  * Called after processes are frozen, but before we shut down devices.
  */
-static int mx31_pm_prepare(suspend_state_t state)
+static int mx31_suspend_prepare(void)
 {
 	return 0;
 }
@@ -90,21 +74,21 @@
 /*
  * Called after devices are re-setup, but before processes are thawed.
  */
-static int mx31_pm_finish(suspend_state_t state)
+static void mx31_suspend_finish(void)
 {
-	return 0;
+	return;
 }
 
-struct pm_ops mx31_pm_ops = {
-	.prepare = mx31_pm_prepare,
-	.enter = mx31_pm_enter,
-	.finish = mx31_pm_finish,
+struct platform_suspend_ops mx31_suspend_ops = {
+	.prepare = mx31_suspend_prepare,
+	.enter = mx31_suspend_enter,
+	.finish = mx31_suspend_finish,
 };
 
 static int __init mx31_pm_init(void)
 {
 	printk(KERN_INFO "Power Management for Freescale MX31\n");
-	pm_set_ops(&mx31_pm_ops);
+	suspend_set_ops(&mx31_suspend_ops);
 
 	return 0;
 }
Index: linux-2.6.24/arch/arm/mach-mx3/serial.h
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx3/serial.h	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx3/serial.h	2009-01-24 22:01:10.000000000 +0100
@@ -110,7 +110,7 @@
  * number of the ANDed interrupt in case the interrupts are muxed. There exists
  * a define like this for each UART port.
  */
-#define UART1_INT1              INT_UART1
+#define UART1_INT1              MXC_INT_UART1
 /*!
  * This define specifies the receiver interrupt number. If the interrupts of
  * the UART are muxed, then we specify here a dummy value -1. There exists a
@@ -131,25 +131,25 @@
 #define UART1_SHARED_PERI       -1
 /* UART 2 configuration */
 #define UART2_MUX_INTS          INTS_MUXED
-#define UART2_INT1              INT_UART2
+#define UART2_INT1              MXC_INT_UART2
 #define UART2_INT2              -1
 #define UART2_INT3              -1
 #define UART2_SHARED_PERI       -1
 /* UART 3 configuration */
 #define UART3_MUX_INTS          INTS_MUXED
-#define UART3_INT1              INT_UART3
+#define UART3_INT1              MXC_INT_UART3
 #define UART3_INT2              -1
 #define UART3_INT3              -1
 #define UART3_SHARED_PERI       SPBA_UART3
 /* UART 4 configuration */
 #define UART4_MUX_INTS          INTS_MUXED
-#define UART4_INT1              INT_UART4
+#define UART4_INT1              MXC_INT_UART4
 #define UART4_INT2              -1
 #define UART4_INT3              -1
 #define UART4_SHARED_PERI       -1
 /* UART 5 configuration */
 #define UART5_MUX_INTS          INTS_MUXED
-#define UART5_INT1              INT_UART5
+#define UART5_INT1              MXC_INT_UART5
 #define UART5_INT2              -1
 #define UART5_INT3              -1
 #define UART5_SHARED_PERI       -1
Index: linux-2.6.24/arch/arm/mach-mx3/time.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx3/time.c	2009-01-24 21:59:18.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,152 +0,0 @@
-/*
- * System Timer Interrupt reconfigured to run in free-run mode.
- * Author: Vitaly Wool
- * Copyright 2004 MontaVista Software Inc.
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-/*!
- * @file time.c
- * @brief This file contains OS tick and wdog timer implementations.
- *
- * This file contains OS tick and wdog timer implementations.
- *
- * @ingroup Timers
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <asm/hardware.h>
-#include <asm/mach/time.h>
-#include <asm/io.h>
-#include <asm/arch/common.h>
-
-/*!
- * This is the timer interrupt service routine to do required tasks.
- * It also services the WDOG timer at the frequency of twice per WDOG
- * timeout value. For example, if the WDOG's timeout value is 4 (2
- * seconds since the WDOG runs at 0.5Hz), it will be serviced once
- * every 2/2=1 second.
- *
- * @param  irq          GPT interrupt source number (not used)
- * @param  dev_id       this parameter is not used
- * @return always returns \b IRQ_HANDLED as defined in
- *         include/linux/interrupt.h.
- */
-static irqreturn_t mxc_timer_interrupt(int irq, void *dev_id)
-{
-	unsigned int next_match;
-
-	write_seqlock(&xtime_lock);
-
-	if (__raw_readl(MXC_GPT_GPTSR) & GPTSR_OF1) {
-		do {
-			timer_tick();
-			next_match = __raw_readl(MXC_GPT_GPTOCR1) + LATCH;
-			__raw_writel(GPTSR_OF1, MXC_GPT_GPTSR);
-			__raw_writel(next_match, MXC_GPT_GPTOCR1);
-		} while ((signed long)(next_match -
-				       __raw_readl(MXC_GPT_GPTCNT)) <= 0);
-	}
-
-	write_sequnlock(&xtime_lock);
-
-	return IRQ_HANDLED;
-}
-
-/*!
- * This function is used to obtain the number of microseconds since the last
- * timer interrupt. Note that interrupts is disabled by do_gettimeofday().
- *
- * @return the number of microseconds since the last timer interrupt.
- */
-static unsigned long mxc_gettimeoffset(void)
-{
-	unsigned long ticks_to_match, elapsed, usec, tick_usec, i;
-
-	/* Get ticks before next timer match */
-	ticks_to_match =
-	    __raw_readl(MXC_GPT_GPTOCR1) - __raw_readl(MXC_GPT_GPTCNT);
-
-	/* We need elapsed ticks since last match */
-	elapsed = LATCH - ticks_to_match;
-
-	/* Now convert them to usec */
-	/* Insure no overflow when calculating the usec below */
-	for (i = 1, tick_usec = tick_nsec / 1000;; i *= 2) {
-		tick_usec /= i;
-		if ((0xFFFFFFFF / tick_usec) > elapsed)
-			break;
-	}
-	usec = (unsigned long)(elapsed * tick_usec) / (LATCH / i);
-
-	return usec;
-}
-
-/*!
- * The OS tick timer interrupt structure.
- */
-static struct irqaction timer_irq = {
-	.name = "MXC Timer Tick",
-	.flags = IRQF_DISABLED | IRQF_TIMER,
-	.handler = mxc_timer_interrupt
-};
-
-/*!
- * This function is used to initialize the GPT to produce an interrupt
- * based on HZ.  It is called by start_kernel() during system startup.
- */
-void __init mxc_init_time(void)
-{
-	u32 reg, v;
-	reg = __raw_readl(MXC_GPT_GPTCR);
-	reg &= ~GPTCR_ENABLE;
-	__raw_writel(reg, MXC_GPT_GPTCR);
-	reg |= GPTCR_SWR;
-	__raw_writel(reg, MXC_GPT_GPTCR);
-
-	while ((__raw_readl(MXC_GPT_GPTCR) & GPTCR_SWR) != 0)
-		cpu_relax();
-
-	reg = GPTCR_FRR | GPTCR_CLKSRC_HIGHFREQ;
-	__raw_writel(reg, MXC_GPT_GPTCR);
-
-	/* TODO: get timer rate from clk driver */
-	v = 66500000;
-
-	__raw_writel((v / CLOCK_TICK_RATE) - 1, MXC_GPT_GPTPR);
-
-	if ((v % CLOCK_TICK_RATE) != 0) {
-		pr_info("\nWARNING: Can't generate CLOCK_TICK_RATE at %d Hz\n",
-			CLOCK_TICK_RATE);
-	}
-	pr_info("Actual CLOCK_TICK_RATE is %d Hz\n",
-		v / ((__raw_readl(MXC_GPT_GPTPR) & 0xFFF) + 1));
-
-	reg = __raw_readl(MXC_GPT_GPTCNT);
-	reg += LATCH;
-	__raw_writel(reg, MXC_GPT_GPTOCR1);
-
-	setup_irq(MXC_INT_GPT, &timer_irq);
-
-	reg = __raw_readl(MXC_GPT_GPTCR);
-	reg =
-	    GPTCR_FRR | GPTCR_CLKSRC_HIGHFREQ | GPTCR_STOPEN | GPTCR_DOZEN |
-	    GPTCR_WAITEN | GPTCR_ENMOD | GPTCR_ENABLE;
-	__raw_writel(reg, MXC_GPT_GPTCR);
-
-	__raw_writel(GPTIR_OF1IE, MXC_GPT_GPTIR);
-}
-
-struct sys_timer mxc_timer = {
-	.init = mxc_init_time,
-	.offset = mxc_gettimeoffset,
-};
Index: linux-2.6.24/arch/arm/mach-mx3/usb.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mx3/usb.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mx3/usb.c	2009-01-24 22:01:10.000000000 +0100
@@ -85,7 +85,7 @@
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = INT_USB1,
+		.start = MXC_INT_USB1,
 		.flags = IORESOURCE_IRQ,
 	},
 };
@@ -116,7 +116,7 @@
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = INT_USB2,
+		.start = MXC_INT_USB2,
 		.flags = IORESOURCE_IRQ,
 	},
 };
@@ -179,7 +179,7 @@
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = INT_USB3,
+		.start = MXC_INT_USB3,
 		.flags = IORESOURCE_IRQ,
 	},
 };
@@ -258,7 +258,7 @@
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = INT_USB3,
+		.start = MXC_INT_USB3,
 		.flags = IORESOURCE_IRQ,
 	},
 };
Index: linux-2.6.24/arch/arm/mach-mxc91321/Makefile
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mxc91321/Makefile	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mxc91321/Makefile	2009-01-24 22:01:10.000000000 +0100
@@ -4,14 +4,9 @@
 
 # Object file lists.
 
-obj-y					:= devices.o iomux.o system.o cpu.o mm.o clock.o serial.o dma.o
-obj-$(CONFIG_MACH_I30030EVB)		+= i30030evb.o i30030evb_gpio.o
-obj-$(CONFIG_MACH_I30030ADS)	    += i30030ads.o i30030ads_gpio.o
+obj-y := devices.o iomux.o system.o cpu.o mm.o clock.o serial.o dma.o dptc.o
 obj-$(CONFIG_MACH_MXC30030EVB)		+= mxc30030evb.o mxc30030evb_gpio.o
 obj-$(CONFIG_MACH_MXC30030ADS)		+= mxc30030ads.o mxc30030ads_gpio.o
 
-obj-$(CONFIG_ARCH_MXC91321)		+= mxc_pm.o
-
 # Dynamic power management
-obj-$(CONFIG_PM)		+= pm.o
-obj-$(CONFIG_DPM)               += dpm.o
+obj-$(CONFIG_PM)		+= pm.o mxc_pm.o
\ No newline at end of file
Index: linux-2.6.24/arch/arm/mach-mxc91321/board-mxc30030ads.h
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mxc91321/board-mxc30030ads.h	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mxc91321/board-mxc30030ads.h	2009-01-24 22:01:10.000000000 +0100
@@ -77,12 +77,12 @@
  */
 /*! @{*/
 /*! This is System IRQ used by CS8900A for interrupt generation taken from platform.h */
-#define CS8900AIRQ              INT_EXT_INT5
+#define CS8900AIRQ              MXC_INT_EXT_INT5
 /*! This is I/O Base address used to access registers of CS8900A on MXC ADS */
 #define CS8900A_BASE_ADDRESS    (IO_ADDRESS(CS2_BASE_ADDR) + 0x300)
 /*! @} */
 
-#define MXC_PMIC_INT_LINE       INT_EXT_INT1
+#define MXC_PMIC_INT_LINE       MXC_INT_EXT_INT1
 
 /*
  * Board specific REF, AHB and IPG frequencies
Index: linux-2.6.24/arch/arm/mach-mxc91321/board-mxc30030evb.h
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mxc91321/board-mxc30030evb.h	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mxc91321/board-mxc30030evb.h	2009-01-24 22:01:10.000000000 +0100
@@ -184,7 +184,7 @@
  */
 /*! @{*/
 /*! This is System IRQ used by CS8900A for interrupt generation */
-#define CS8900AIRQ              INT_EXT_INT5
+#define CS8900AIRQ              MXC_INT_EXT_INT5
 /*! This is I/O Base address used to access registers of CS8900A on MXC ADS */
 #define CS8900A_BASE_ADDRESS    (PBC_BASE_ADDRESS + PBC_CS8900A_IOBASE + 0x300)
 /*! @} */
Index: linux-2.6.24/arch/arm/mach-mxc91321/devices.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mxc91321/devices.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mxc91321/devices.c	2009-01-24 22:01:10.000000000 +0100
@@ -175,7 +175,7 @@
 	 .flags = IORESOURCE_MEM,
 	 },
 	{
-	 .start = INT_RTC,
+	 .start = MXC_INT_RTC,
 	 .flags = IORESOURCE_IRQ,
 	 },
 };
@@ -212,7 +212,7 @@
 	 .flags = IORESOURCE_MEM,
 	 },
 	{
-	 .start = INT_WDOG2,
+	 .start = MXC_INT_WDOG2,
 	 .flags = IORESOURCE_IRQ,
 	 },
 };
@@ -249,7 +249,7 @@
 	 .flags = IORESOURCE_MEM,
 	 },
 	{
-	 .start = INT_IPU,
+	 .start = MXC_INT_IPU,
 	 .flags = IORESOURCE_IRQ,
 	 },
 };
@@ -300,8 +300,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_MMC_SDHC1,
-	       .end = INT_MMC_SDHC1,
+	       .start = MXC_INT_MMC_SDHC1,
+	       .end = MXC_INT_MMC_SDHC1,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[2] = {
@@ -309,11 +309,6 @@
 	       .end = 0,
 	       .flags = IORESOURCE_IRQ,
 	       },
-	[3] = {
-	       .start = MXC_SDIO1_CARD_IRQ,
-	       .end = MXC_SDIO1_CARD_IRQ,
-	       .flags = IORESOURCE_IRQ,
-	       },
 };
 
 /*!
@@ -326,8 +321,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_MMC_SDHC2,
-	       .end = INT_MMC_SDHC2,
+	       .start = MXC_INT_MMC_SDHC2,
+	       .end = MXC_INT_MMC_SDHC2,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[2] = {
@@ -335,11 +330,6 @@
 	       .end = 0,
 	       .flags = IORESOURCE_IRQ,
 	       },
-	[3] = {
-	       .start = MXC_SDIO2_CARD_IRQ,
-	       .end = MXC_SDIO2_CARD_IRQ,
-	       .flags = IORESOURCE_IRQ,
-	       },
 };
 
 /*! Device Definition for MXC SDHC1 */
@@ -498,14 +488,14 @@
 	{
 	 .num = 0,
 	 .base = IO_ADDRESS(GPIO1_BASE_ADDR),
-	 .irq = INT_GPIO1,
-	 .virtual_irq_start = MXC_GPIO_BASE,
+	 .irq = MXC_INT_GPIO1,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE,
 	 },
 	{
 	 .num = 1,
 	 .base = IO_ADDRESS(GPIO2_BASE_ADDR),
-	 .irq = INT_GPIO2,
-	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN,
+	 .irq = MXC_INT_GPIO2,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN,
 	 },
 };
 
@@ -516,27 +506,27 @@
 
 static struct resource mxc_mu_resources[] = {
 	[0] = {
-	       .start = INT_MU_RX_OR,
+	       .start = MXC_INT_MU_RX_OR,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[1] = {
-	       .start = INT_MU_TX_OR,
+	       .start = MXC_INT_MU_TX_OR,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[2] = {
-	       .start = INT_MU0,
+	       .start = MXC_INT_MU0,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[3] = {
-	       .start = INT_MU1,
+	       .start = MXC_INT_MU1,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[4] = {
-	       .start = INT_MU2,
+	       .start = MXC_INT_MU2,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[5] = {
-	       .start = INT_MU3,
+	       .start = MXC_INT_MU3,
 	       .flags = IORESOURCE_IRQ,
 	       }
 };
@@ -578,8 +568,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_CSPI1,
-	       .end = INT_CSPI1,
+	       .start = MXC_INT_CSPI1,
+	       .end = MXC_INT_CSPI1,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
@@ -615,8 +605,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_CSPI2,
-	       .end = INT_CSPI2,
+	       .start = MXC_INT_CSPI2,
+	       .end = MXC_INT_CSPI2,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
@@ -672,8 +662,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_I2C,
-	       .end = INT_I2C,
+	       .start = MXC_INT_I2C,
+	       .end = MXC_INT_I2C,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
Index: linux-2.6.24/arch/arm/mach-mxc91321/i30030ads.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mxc91321/i30030ads.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mxc91321/i30030ads.c	2009-01-24 22:01:10.000000000 +0100
@@ -85,7 +85,7 @@
 static struct keypad_data evb_8_by_4_keypad = {
 	.rowmax = 8,
 	.colmax = 4,
-	.irq = INT_KPP,
+	.irq = MXC_INT_KPP,
 	.learning = 1,
 	.delay = 2,
 	.matrix = mxckpd_keycodes,
@@ -93,8 +93,8 @@
 
 static struct resource mxc_kpp_resources[] = {
 	[0] = {
-	       .start = INT_KPP,
-	       .end = INT_KPP,
+	       .start = MXC_INT_KPP,
+	       .end = MXC_INT_KPP,
 	       .flags = IORESOURCE_IRQ,
 	       }
 };
Index: linux-2.6.24/arch/arm/mach-mxc91321/i30030evb.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mxc91321/i30030evb.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mxc91321/i30030evb.c	2009-01-24 22:01:10.000000000 +0100
@@ -96,8 +96,8 @@
 
 static struct resource mxc_kpp_resources[] = {
 	[0] = {
-	       .start = INT_KPP,
-	       .end = INT_KPP,
+	       .start = MXC_INT_KPP,
+	       .end = MXC_INT_KPP,
 	       .flags = IORESOURCE_IRQ,
 	       }
 };
@@ -105,7 +105,7 @@
 static struct keypad_data evb_8_by_8_keypad = {
 	.rowmax = 8,
 	.colmax = 8,
-	.irq = INT_KPP,
+	.irq = MXC_INT_KPP,
 	.learning = 0,
 	.delay = 2,
 	.matrix = keymapping
@@ -142,7 +142,7 @@
 	{
 	 .membase = (void __iomem *)(PBC_BASE_ADDRESS + PBC_SC16C652_UARTA),
 	 .mapbase = (unsigned long)(CS4_BASE_ADDR + PBC_SC16C652_UARTA),
-	 .irq = INT_EXT_INT6,
+	 .irq = MXC_INT_EXT_INT6,
 	 .uartclk = 14745600,
 	 .regshift = 1,
 	 .iotype = UPIO_MEM,
@@ -151,7 +151,7 @@
 	{
 	 .membase = (void __iomem *)(PBC_BASE_ADDRESS + PBC_SC16C652_UARTB),
 	 .mapbase = (unsigned long)(CS4_BASE_ADDR + PBC_SC16C652_UARTB),
-	 .irq = INT_EXT_INT7,
+	 .irq = MXC_INT_EXT_INT7,
 	 .uartclk = 14745600,
 	 .regshift = 1,
 	 .iotype = UPIO_MEM,
Index: linux-2.6.24/arch/arm/mach-mxc91321/mm.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mxc91321/mm.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mxc91321/mm.c	2009-01-24 22:01:10.000000000 +0100
@@ -74,11 +74,6 @@
 	 .length = AIPS2_SIZE,
 	 .type = MT_NONSHARED_DEVICE},
 	{
-	 .virtual = CS2_BASE_ADDR_VIRT,
-	 .pfn = __phys_to_pfn(CS2_BASE_ADDR),
-	 .length = CS2_SIZE,
-	 .type = MT_DEVICE},
-	{
 	 .virtual = CS4_BASE_ADDR_VIRT,
 	 .pfn = __phys_to_pfn(CS4_BASE_ADDR),
 	 .length = CS4_SIZE,
Index: linux-2.6.24/arch/arm/mach-mxc91321/mxc30030ads.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mxc91321/mxc30030ads.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mxc91321/mxc30030ads.c	2009-01-24 22:01:10.000000000 +0100
@@ -80,8 +80,8 @@
 
 static struct resource mxc_kpp_resources[] = {
 	[0] = {
-	       .start = INT_KPP,
-	       .end = INT_KPP,
+	       .start = MXC_INT_KPP,
+	       .end = MXC_INT_KPP,
 	       .flags = IORESOURCE_IRQ,
 	       }
 };
@@ -89,7 +89,7 @@
 static struct keypad_data evb_8_by_4_keypad = {
 	.rowmax = 8,
 	.colmax = 4,
-	.irq = INT_KPP,
+	.irq = MXC_INT_KPP,
 	.learning = 1,
 	.delay = 2,
 	.matrix = mxckpd_keycodes
@@ -273,7 +273,7 @@
 static struct spi_board_info mxc_spi_board_info[] __initdata = {
 	{
 	 .modalias = "pmic_spi",
-	 .irq = INT_EXT_INT1,
+	 .irq = MXC_INT_EXT_INT1,
 	 .max_speed_hz = 4000000,
 	 .bus_num = 2,
 	 .chip_select = 0,
Index: linux-2.6.24/arch/arm/mach-mxc91321/mxc30030evb.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mxc91321/mxc30030evb.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mxc91321/mxc30030evb.c	2009-01-24 22:01:10.000000000 +0100
@@ -104,8 +104,8 @@
 
 static struct resource mxc_kpp_resources[] = {
 	[0] = {
-	       .start = INT_KPP,
-	       .end = INT_KPP,
+	       .start = MXC_INT_KPP,
+	       .end = MXC_INT_KPP,
 	       .flags = IORESOURCE_IRQ,
 	       }
 };
@@ -113,7 +113,7 @@
 static struct keypad_data evb_8_by_8_keypad = {
 	.rowmax = 8,
 	.colmax = 8,
-	.irq = INT_KPP,
+	.irq = MXC_INT_KPP,
 	.learning = 0,
 	.delay = 2,
 	.matrix = keymapping
@@ -150,7 +150,7 @@
 	{
 	 .membase = (void __iomem *)(PBC_BASE_ADDRESS + PBC_SC16C652_UARTA),
 	 .mapbase = (unsigned long)(CS4_BASE_ADDR + PBC_SC16C652_UARTA),
-	 .irq = INT_EXT_INT6,
+	 .irq = MXC_INT_EXT_INT6,
 	 .uartclk = 14745600,
 	 .regshift = 1,
 	 .iotype = UPIO_MEM,
@@ -159,7 +159,7 @@
 	{
 	 .membase = (void __iomem *)(PBC_BASE_ADDRESS + PBC_SC16C652_UARTB),
 	 .mapbase = (unsigned long)(CS4_BASE_ADDR + PBC_SC16C652_UARTB),
-	 .irq = INT_EXT_INT7,
+	 .irq = MXC_INT_EXT_INT7,
 	 .uartclk = 14745600,
 	 .regshift = 1,
 	 .iotype = UPIO_MEM,
@@ -359,7 +359,7 @@
 static struct spi_board_info mxc_spi_board_info[] __initdata = {
 	{
 	 .modalias = "pmic_spi",
-	 .irq = INT_EXT_INT1,
+	 .irq = MXC_INT_EXT_INT1,
 	 .max_speed_hz = 4000000,
 	 .bus_num = 2,
 	 .chip_select = 0,
@@ -442,8 +442,8 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
-	       .start = INT_UART4_FIRI_OR,
-	       .end = INT_UART4_FIRI_OR,
+	       .start = MXC_INT_UART4_FIRI_OR,
+	       .end = MXC_INT_UART4_FIRI_OR,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[2] = {
@@ -452,13 +452,13 @@
 	       .flags = IORESOURCE_MEM,
 	       },
 	[3] = {
-	       .start = INT_UART4_FIRI_OR,
-	       .end = INT_UART4_FIRI_OR,
+	       .start = MXC_INT_UART4_FIRI_OR,
+	       .end = MXC_INT_UART4_FIRI_OR,
 	       .flags = IORESOURCE_IRQ,
 	       },
 	[4] = {
-	       .start = INT_UART4_FIRI_OR,
-	       .end = INT_UART4_FIRI_OR,
+	       .start = MXC_INT_UART4_FIRI_OR,
+	       .end = MXC_INT_UART4_FIRI_OR,
 	       .flags = IORESOURCE_IRQ,
 	       },
 };
Index: linux-2.6.24/arch/arm/mach-mxc91321/pm.c
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mxc91321/pm.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mxc91321/pm.c	2009-01-24 22:01:10.000000000 +0100
@@ -39,32 +39,24 @@
  * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include <linux/pm.h>
-#include <linux/sched.h>
-#include <linux/proc_fs.h>
+#include <linux/kernel.h>
+#include <linux/suspend.h>
 
-#include <asm/io.h>
 #include <asm/arch/mxc_pm.h>
 
 /*
  * TODO: whatta save?
  */
 
-static int mxc_pm_enter(suspend_state_t state)
+static int mxc_suspend_enter(suspend_state_t state)
 {
 	switch (state) {
 	case PM_SUSPEND_MEM:
 		mxc_pm_lowpower(DSM_MODE);
 		break;
-
 	case PM_SUSPEND_STANDBY:
-		mxc_pm_lowpower(WAIT_MODE);
-		break;
-
-	case PM_SUSPEND_STOP:
 		mxc_pm_lowpower(STOP_MODE);
 		break;
-
 	default:
 		return -1;
 	}
@@ -74,7 +66,7 @@
 /*
  * Called after processes are frozen, but before we shut down devices.
  */
-static int mxc_pm_prepare(suspend_state_t state)
+static int mxc_suspend_prepare(void)
 {
 	return 0;
 }
@@ -82,21 +74,21 @@
 /*
  * Called after devices are re-setup, but before processes are thawed.
  */
-static int mxc_pm_finish(suspend_state_t state)
+static void mxc_suspend_finish(void)
 {
-	return 0;
+	return;
 }
 
-struct pm_ops mxc_pm_ops = {
-	.prepare = mxc_pm_prepare,
-	.enter = mxc_pm_enter,
-	.finish = mxc_pm_finish,
+struct platform_suspend_ops mxc_suspend_ops = {
+	.prepare = mxc_suspend_prepare,
+	.enter = mxc_suspend_enter,
+	.finish = mxc_suspend_finish,
 };
 
 static int __init mxc_pm_init(void)
 {
 	printk(KERN_INFO "Power Management for Freescale MXC91321.\n");
-	pm_set_ops(&mxc_pm_ops);
+	suspend_set_ops(&mxc_suspend_ops);
 
 	return 0;
 }
Index: linux-2.6.24/arch/arm/mach-mxc91321/serial.h
===================================================================
--- linux-2.6.24.orig/arch/arm/mach-mxc91321/serial.h	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/mach-mxc91321/serial.h	2009-01-24 22:01:10.000000000 +0100
@@ -105,7 +105,7 @@
  * number of the ANDed interrupt in case the interrupts are muxed. There exists
  * a define like this for each UART port.
  */
-#define UART1_INT1              INT_UART1
+#define UART1_INT1              MXC_INT_UART1
 /*!
  * This define specifies the receiver interrupt number. If the interrupts of
  * the UART are muxed, then we specify here a dummy value -1. There exists a
@@ -126,19 +126,19 @@
 #define UART1_SHARED_PERI       -1
 /* UART 2 configuration */
 #define UART2_MUX_INTS          INTS_MUXED
-#define UART2_INT1              INT_UART2
+#define UART2_INT1              MXC_INT_UART2
 #define UART2_INT2              -1
 #define UART2_INT3              -1
 #define UART2_SHARED_PERI       -1
 /* UART 3 configuration */
 #define UART3_MUX_INTS          INTS_MUXED
-#define UART3_INT1              INT_UART3
+#define UART3_INT1              MXC_INT_UART3
 #define UART3_INT2              -1
 #define UART3_INT3              -1
 #define UART3_SHARED_PERI       SPBA_UART3
 /* UART 4 configuration */
 #define UART4_MUX_INTS          INTS_MUXED
-#define UART4_INT1              INT_UART4_FIRI_OR
+#define UART4_INT1              MXC_INT_UART4_FIRI_OR
 #define UART4_INT2              -1
 #define UART4_INT3              -1
 #define UART4_SHARED_PERI       SPBA_UART4
Index: linux-2.6.24/arch/arm/oprofile/evtmon_regs.h
===================================================================
--- linux-2.6.24.orig/arch/arm/oprofile/evtmon_regs.h	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/oprofile/evtmon_regs.h	2009-01-24 22:01:10.000000000 +0100
@@ -73,7 +73,7 @@
 #define ENABLE_ECT		0x1
 #define ACK_TRIG_OUT_2		0x4
 #define EM_SET_INT		L2EM_ENABLE_CNTINCRINT
-#define EVENT_OVERFLOW_INT	INT_ECT
+#define EVENT_OVERFLOW_INT	MXC_INT_ECT
 #else
 #define EVENT_OVERFLOW_INT	ARM11_PMU_IRQ
 #define EM_SET_INT		L2EM_ENABLE_OVERFLOWINT
Index: linux-2.6.24/arch/arm/plat-mxc/Makefile
===================================================================
--- linux-2.6.24.orig/arch/arm/plat-mxc/Makefile	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/plat-mxc/Makefile	2009-01-24 22:01:10.000000000 +0100
@@ -3,10 +3,10 @@
 #
 
 # Common support
-obj-y := gpio.o clock.o wdog.o snoop.o io.o
+obj-y := cpu_common.o gpio.o clock.o wdog.o snoop.o io.o
 
 ifneq ($(CONFIG_ARCH_MX21)$(CONFIG_ARCH_MX27),y)
-obj-y += time.o cpu_common.o  spba.o sdma/
+obj-y += time.o spba.o sdma/
 endif
 
 ifneq ($(CONFIG_ARCH_MX33),y)
@@ -14,12 +14,9 @@
 endif
 
 obj-$(CONFIG_ARCH_MX21) += dma_mx2.o
-obj-$(CONFIG_ARCH_MX27) += cpu_common.o dma_mx2.o usb_common.o
+obj-$(CONFIG_ARCH_MX27) += dma_mx2.o usb_common.o
 obj-$(CONFIG_ARCH_MX3) += dptc.o usb_common.o
-
-obj-m :=
-obj-n :=
-obj-  :=
+obj-$(CONFIG_ARCH_MXC91321) += dptc.o
 
 obj-$(CONFIG_MXC_DSP_BRINGUP) += dsp_bringup.o
 
Index: linux-2.6.24/arch/arm/plat-mxc/dptc.c
===================================================================
--- linux-2.6.24.orig/arch/arm/plat-mxc/dptc.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/plat-mxc/dptc.c	2009-01-24 22:01:10.000000000 +0100
@@ -283,7 +283,8 @@
 	INIT_DELAYED_WORK(&dptc_work, dptc_workqueue_handler);
 
 	/* request the DPTC interrupt */
-	res = request_irq(INT_CCM, dptc_irq, IRQF_DISABLED, "mxc-dptc", NULL);
+	res =
+	    request_irq(MXC_INT_CCM, dptc_irq, IRQF_DISABLED, "mxc-dptc", NULL);
 	if (res) {
 		printk(KERN_ERR "DPTC: Unable to attach to DPTC interrupt");
 		return res;
@@ -400,7 +401,7 @@
 	stop_dptc();
 
 	/* release the DPTC interrupt */
-	free_irq(INT_CCM, NULL);
+	free_irq(MXC_INT_CCM, NULL);
 
 	sysfs_remove_file(&dptc_dev->kobj, &dev_attr_enable.attr);
 
Index: linux-2.6.24/arch/arm/plat-mxc/irq.c
===================================================================
--- linux-2.6.24.orig/arch/arm/plat-mxc/irq.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/plat-mxc/irq.c	2009-01-24 22:01:10.000000000 +0100
@@ -41,14 +41,14 @@
 #ifdef EDIO_BASE_ADDR
 
 static const int mxc_edio_irq_map[] = {
-	INT_EXT_INT0,
-	INT_EXT_INT1,
-	INT_EXT_INT2,
-	INT_EXT_INT3,
-	INT_EXT_INT4,
-	INT_EXT_INT5,
-	INT_EXT_INT6,
-	INT_EXT_INT7,
+	MXC_INT_EXT_INT0,
+	MXC_INT_EXT_INT1,
+	MXC_INT_EXT_INT2,
+	MXC_INT_EXT_INT3,
+	MXC_INT_EXT_INT4,
+	MXC_INT_EXT_INT5,
+	MXC_INT_EXT_INT6,
+	MXC_INT_EXT_INT7,
 };
 
 static u32 edio_irq_type[MXC_MAX_EXT_LINES] = {
Index: linux-2.6.24/arch/arm/plat-mxc/mc13783_xc.c
===================================================================
--- linux-2.6.24.orig/arch/arm/plat-mxc/mc13783_xc.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/plat-mxc/mc13783_xc.c	2009-01-24 22:01:10.000000000 +0100
@@ -42,7 +42,7 @@
 PMIC_CONVITY_EVENTS g_event;
 PMIC_CONVITY_HANDLE pmic_handle = (PMIC_CONVITY_HANDLE) NULL;
 
-DECLARE_MUTEX_LOCKED(pmic_mx);
+DECLARE_MUTEX(pmic_mx);
 static struct task_struct *pmic_task;
 
 static void pmic_event_handler(const PMIC_CONVITY_EVENTS event)
@@ -103,6 +103,8 @@
 {
 	PMIC_STATUS rs = PMIC_ERROR;
 
+	init_MUTEX_LOCKED(&pmic_mx);
+
 	rs = pmic_convity_open(&pmic_handle, USB);
 	if (rs != PMIC_SUCCESS) {
 		printk(KERN_ERR "pmic_convity_open returned error %d\n", rs);
Index: linux-2.6.24/arch/arm/plat-mxc/sdma/Makefile
===================================================================
--- linux-2.6.24.orig/arch/arm/plat-mxc/sdma/Makefile	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/plat-mxc/sdma/Makefile	2009-01-24 22:01:10.000000000 +0100
@@ -1,11 +1,11 @@
 ifneq ($(KBUILD_SRC),)
-CFLAGS  += -I$(KBUILD_SRC)/arch/arm/plat-mxc/sdma/iapi/include \
+ccflags-y += -I$(KBUILD_SRC)/arch/arm/plat-mxc/sdma/iapi/include \
                 -I$(KBUILD_SRC)/include/linux \
                 -DMCU -DOS=LINUX \
                 -DL_I_T_T_L_E_ENDIAN=0 -DB_I_G_ENDIAN=1 \
                 -DENDIANNESS=L_I_T_T_L_E_ENDIAN
 else
-CFLAGS  += -Iarch/arm/plat-mxc/sdma/iapi/include \
+ccflags-y += -Iarch/arm/plat-mxc/sdma/iapi/include \
                 -Iinclude/linux \
                 -DMCU -DOS=LINUX \
                 -DL_I_T_T_L_E_ENDIAN=0 -DB_I_G_ENDIAN=1 \
Index: linux-2.6.24/arch/arm/plat-mxc/sdma/iapi/src/Makefile
===================================================================
--- linux-2.6.24.orig/arch/arm/plat-mxc/sdma/iapi/src/Makefile	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/plat-mxc/sdma/iapi/src/Makefile	2009-01-24 22:01:10.000000000 +0100
@@ -1,5 +1,18 @@
 #
 # Makefile for I.API sources.
 #
+ifneq ($(KBUILD_SRC),)
+ccflags-y += -I$(KBUILD_SRC)/arch/arm/plat-mxc/sdma/iapi/include \
+                -I$(KBUILD_SRC)/include/linux \
+                -DMCU -DOS=LINUX \
+                -DL_I_T_T_L_E_ENDIAN=0 -DB_I_G_ENDIAN=1 \
+                -DENDIANNESS=L_I_T_T_L_E_ENDIAN
+else
+ccflags-y += -Iarch/arm/plat-mxc/sdma/iapi/include \
+                -Iinclude/linux \
+                -DMCU -DOS=LINUX \
+                -DL_I_T_T_L_E_ENDIAN=0 -DB_I_G_ENDIAN=1 \
+                -DENDIANNESS=L_I_T_T_L_E_ENDIAN
+endif
 
 obj-y	+= iapiLow.o iapiLowMcu.o iapiMiddle.o iapiMiddleMcu.o iapiHigh.o iapiDefaults.o iapiOS.o
Index: linux-2.6.24/arch/arm/plat-mxc/sdma/sdma.c
===================================================================
--- linux-2.6.24.orig/arch/arm/plat-mxc/sdma/sdma.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/plat-mxc/sdma/sdma.c	2009-01-24 22:01:10.000000000 +0100
@@ -1251,7 +1251,7 @@
 
 	init_sdma_pool();
 
-	res = request_irq(INT_SDMA, sdma_int_handler, 0, "mxcsdma", 0);
+	res = request_irq(MXC_INT_SDMA, sdma_int_handler, 0, "mxcsdma", 0);
 
 	if (res < 0) {
 		goto sdma_init_fail;
@@ -1269,7 +1269,7 @@
 			sdma_script_addrs.mxc_sdma_ram_code_start_addr);
 
 	if (res < 0) {
-		free_irq(INT_SDMA, 0);
+		free_irq(MXC_INT_SDMA, 0);
 		goto sdma_init_fail;
 	}
 
@@ -1280,7 +1280,7 @@
 #if defined(CONFIG_MXC_SUPER_GEM)
 	res = init_super_gem();
 	if (res < 0) {
-		free_irq(INT_SDMA, 0);
+		free_irq(MXC_INT_SDMA, 0);
 		goto sdma_init_fail;
 	}
 #endif
Index: linux-2.6.24/arch/arm/plat-mxc/time.c
===================================================================
--- linux-2.6.24.orig/arch/arm/plat-mxc/time.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/arch/arm/plat-mxc/time.c	2009-01-24 22:01:10.000000000 +0100
@@ -131,6 +131,8 @@
 		reg &= ~GPTIR_OF1IE;
 		__raw_writel(reg, MXC_GPT_GPTIR);
 		break;
+	case CLOCK_EVT_MODE_RESUME:
+		break;
 	}
 }
 
@@ -249,7 +251,7 @@
 	gpt_clockevent.cpumask = cpumask_of_cpu(0);
 	clockevents_register_device(&gpt_clockevent);
 
-	ret = setup_irq(INT_GPT, &timer_irq);
+	ret = setup_irq(MXC_INT_GPT, &timer_irq);
 	if (ret < 0) {
 		goto err;
 	}
Index: linux-2.6.24/drivers/char/watchdog/mxc_wdt.c
===================================================================
--- linux-2.6.24.orig/drivers/char/watchdog/mxc_wdt.c	2009-01-24 22:01:08.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,385 +0,0 @@
-/*
- * linux/drivers/char/watchdog/mxc_wdt.c
- *
- * Watchdog driver for FSL MXC. It is based on omap1610_wdt.c
- *
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- * 2005 (c) MontaVista Software, Inc.  All Rights Reserved.
-
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- *
- * 20051207: <AKuster@mvista.com>
- *	     	Full rewrite based on
- *		linux-2.6.15-rc5/drivers/char/watchdog/omap_wdt.c
- *	     	Add platform resource support
- *
- */
-
-/*!
- * @defgroup WDOG Watchdog Timer (WDOG) Driver
- */
-/*!
- * @file mxc_wdt.c
- *
- * @brief Watchdog timer driver
- *
- * @ingroup WDOG
- */
-
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/miscdevice.h>
-#include <linux/watchdog.h>
-#include <linux/reboot.h>
-#include <linux/smp_lock.h>
-#include <linux/init.h>
-#include <linux/err.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/moduleparam.h>
-#include <linux/clk.h>
-
-#include <asm/io.h>
-#include <asm/uaccess.h>
-#include <asm/hardware.h>
-#include <asm/irq.h>
-#include <asm/bitops.h>
-
-#include <asm/hardware.h>
-#include "mxc_wdt.h"
-#define DVR_VER "2.0"
-
-#define WDOG_SEC_TO_COUNT(s)  ((s * 2) << 8)
-#define WDOG_COUNT_TO_SEC(c)  ((c >> 8) / 2)
-
-static u32 wdt_base_reg;
-static int mxc_wdt_users;
-static struct clk *mxc_wdt_clk;
-
-static unsigned timer_margin = TIMER_MARGIN_DEFAULT;
-module_param(timer_margin, uint, 0);
-MODULE_PARM_DESC(timer_margin, "initial watchdog timeout (in seconds)");
-
-static unsigned dev_num = 0;
-
-static void mxc_wdt_ping(u32 base)
-{
-	/* issue the service sequence instructions */
-	__raw_writew(WDT_MAGIC_1, base + MXC_WDT_WSR);
-	__raw_writew(WDT_MAGIC_2, base + MXC_WDT_WSR);
-}
-
-static void mxc_wdt_config(u32 base)
-{
-	u16 val;
-
-	val = __raw_readw(base + MXC_WDT_WCR);
-	val |= 0xFF00 | WCR_WOE_BIT | WCR_WDA_BIT | WCR_SRS_BIT;
-	/* enable suspend WDT */
-	val |= WCR_WDZST_BIT | WCR_WDBG_BIT;
-	/* generate reset if wdog times out */
-	val &= ~WCR_WRE_BIT;
-
-	__raw_writew(val, base + MXC_WDT_WCR);
-}
-
-static void mxc_wdt_enable(u32 base)
-{
-	u16 val;
-
-	val = __raw_readw(base + MXC_WDT_WCR);
-	val |= WCR_WDE_BIT;
-	__raw_writew(val, base + MXC_WDT_WCR);
-}
-
-static void mxc_wdt_disable(u32 base)
-{
-	/* disable not supported by this chip */
-}
-
-static void mxc_wdt_adjust_timeout(unsigned new_timeout)
-{
-	if (new_timeout < TIMER_MARGIN_MIN)
-		new_timeout = TIMER_MARGIN_DEFAULT;
-	if (new_timeout > TIMER_MARGIN_MAX)
-		new_timeout = TIMER_MARGIN_MAX;
-	timer_margin = new_timeout;
-}
-
-static u16 mxc_wdt_get_timeout(u32 base)
-{
-	u16 val;
-
-	val = __raw_readw(base + MXC_WDT_WCR);
-	return WDOG_COUNT_TO_SEC(val);
-}
-
-static u16 mxc_wdt_get_bootreason(u32 base)
-{
-	u16 val;
-
-	val = __raw_readw(base + MXC_WDT_WRSR);
-	return val;
-}
-
-static void mxc_wdt_set_timeout(u32 base)
-{
-	u16 val;
-	val = __raw_readw(base + MXC_WDT_WCR);
-	val = (val & 0x00FF) | WDOG_SEC_TO_COUNT(timer_margin);
-	__raw_writew(val, base + MXC_WDT_WCR);
-	val = __raw_readw(base + MXC_WDT_WCR);
-	timer_margin = WDOG_COUNT_TO_SEC(val);
-}
-
-/*
- *	Allow only one task to hold it open
- */
-
-static int mxc_wdt_open(struct inode *inode, struct file *file)
-{
-
-	if (test_and_set_bit(1, (unsigned long *)&mxc_wdt_users))
-		return -EBUSY;
-
-	mxc_wdt_config(wdt_base_reg);
-	mxc_wdt_set_timeout(wdt_base_reg);
-	mxc_wdt_enable(wdt_base_reg);
-	mxc_wdt_ping(wdt_base_reg);
-
-	return 0;
-}
-
-static int mxc_wdt_release(struct inode *inode, struct file *file)
-{
-	/*
-	 *      Shut off the timer unless NOWAYOUT is defined.
-	 */
-#ifndef CONFIG_WATCHDOG_NOWAYOUT
-	mxc_wdt_disable(wdt_base_reg);
-
-#else
-	printk(KERN_CRIT "mxc_wdt: Unexpected close, not stopping!\n");
-#endif
-	mxc_wdt_users = 0;
-	return 0;
-}
-
-static ssize_t
-mxc_wdt_write(struct file *file, const char __user * data,
-	      size_t len, loff_t * ppos)
-{
-	/* Refresh LOAD_TIME. */
-	if (len)
-		mxc_wdt_ping(wdt_base_reg);
-	return len;
-}
-
-static int
-mxc_wdt_ioctl(struct inode *inode, struct file *file,
-	      unsigned int cmd, unsigned long arg)
-{
-	int new_margin;
-	int bootr;
-
-	static struct watchdog_info ident = {
-		.identity = "MXC Watchdog",
-		.options = WDIOF_SETTIMEOUT,
-		.firmware_version = 0,
-	};
-
-	switch (cmd) {
-	default:
-		return -ENOIOCTLCMD;
-	case WDIOC_GETSUPPORT:
-		return copy_to_user((struct watchdog_info __user *)arg, &ident,
-				    sizeof(ident));
-	case WDIOC_GETSTATUS:
-		return put_user(0, (int __user *)arg);
-	case WDIOC_GETBOOTSTATUS:
-		bootr = mxc_wdt_get_bootreason(wdt_base_reg);
-		return put_user(bootr, (int __user *)arg);
-	case WDIOC_KEEPALIVE:
-		mxc_wdt_ping(wdt_base_reg);
-		return 0;
-	case WDIOC_SETTIMEOUT:
-		if (get_user(new_margin, (int __user *)arg))
-			return -EFAULT;
-
-		mxc_wdt_adjust_timeout(new_margin);
-		mxc_wdt_disable(wdt_base_reg);
-		mxc_wdt_set_timeout(wdt_base_reg);
-		mxc_wdt_enable(wdt_base_reg);
-		mxc_wdt_ping(wdt_base_reg);
-		return 0;
-
-	case WDIOC_GETTIMEOUT:
-		mxc_wdt_ping(wdt_base_reg);
-		new_margin = mxc_wdt_get_timeout(wdt_base_reg);
-		return put_user(new_margin, (int __user *)arg);
-	}
-}
-
-static struct file_operations mxc_wdt_fops = {
-	.owner = THIS_MODULE,
-	.write = mxc_wdt_write,
-	.ioctl = mxc_wdt_ioctl,
-	.open = mxc_wdt_open,
-	.release = mxc_wdt_release,
-};
-
-static struct miscdevice mxc_wdt_miscdev = {
-	.minor = WATCHDOG_MINOR,
-	.name = "watchdog",
-	.fops = &mxc_wdt_fops
-};
-
-static int __init mxc_wdt_probe(struct platform_device *pdev)
-{
-	struct resource *res, *mem;
-	int ret;
-
-	/* reserve static register mappings */
-	res = platform_get_resource(pdev, IORESOURCE_MEM, dev_num);
-	if (!res)
-		return -ENOENT;
-
-	mem = request_mem_region(res->start, res->end - res->start + 1,
-				 pdev->name);
-	if (mem == NULL)
-		return -EBUSY;
-
-	platform_set_drvdata(pdev, mem);
-
-	wdt_base_reg = IO_ADDRESS(res->start);
-	mxc_wdt_disable(wdt_base_reg);
-	mxc_wdt_adjust_timeout(timer_margin);
-
-	mxc_wdt_users = 0;
-
-	mxc_wdt_miscdev.this_device = &pdev->dev;
-
-	mxc_wdt_clk = clk_get(NULL, "wdog_clk");
-	clk_enable(mxc_wdt_clk);
-
-	ret = misc_register(&mxc_wdt_miscdev);
-	if (ret)
-		goto fail;
-
-	pr_info("MXC Watchdog # %d Timer: initial timeout %d sec\n", dev_num,
-		timer_margin);
-
-	return 0;
-
-      fail:
-	release_resource(mem);
-	pr_info("MXC Watchdog Probe failed\n");
-	return ret;
-}
-
-static void mxc_wdt_shutdown(struct platform_device *pdev)
-{
-	struct resource *res = platform_get_drvdata(pdev);
-	mxc_wdt_disable(res->start);
-	pr_info("MXC Watchdog # %d shutdown\n", dev_num);
-}
-
-static int __exit mxc_wdt_remove(struct platform_device *pdev)
-{
-	struct resource *mem = platform_get_drvdata(pdev);
-	misc_deregister(&mxc_wdt_miscdev);
-	release_resource(mem);
-	pr_info("MXC Watchdog # %d removed\n", dev_num);
-	return 0;
-}
-
-#ifdef	CONFIG_PM
-
-/* REVISIT ... not clear this is the best way to handle system suspend; and
- * it's very inappropriate for selective device suspend (e.g. suspending this
- * through sysfs rather than by stopping the watchdog daemon).  Also, this
- * may not play well enough with NOWAYOUT...
- */
-
-static int mxc_wdt_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct resource *res = platform_get_drvdata(pdev);
-
-	if (mxc_wdt_users) {
-		mxc_wdt_disable(res->start);
-	}
-	return 0;
-}
-
-static int mxc_wdt_resume(struct platform_device *pdev)
-{
-	struct resource *res = platform_get_drvdata(pdev);
-	if (mxc_wdt_users) {
-		mxc_wdt_enable(res->start);
-		mxc_wdt_ping(res->start);
-	}
-	return 0;
-}
-
-#else
-#define	mxc_wdt_suspend	NULL
-#define	mxc_wdt_resume		NULL
-#endif
-
-static struct platform_driver mxc_wdt_driver = {
-	.driver = {
-		   .owner = THIS_MODULE,
-		   .name = "mxc_wdt",
-		   },
-	.probe = mxc_wdt_probe,
-	.shutdown = mxc_wdt_shutdown,
-	.remove = __exit_p(mxc_wdt_remove),
-	.suspend = mxc_wdt_suspend,
-	.resume = mxc_wdt_resume,
-};
-
-static int __init mxc_wdt_init(void)
-{
-	pr_info("MXC WatchDog Driver %s\n", DVR_VER);
-
-	if ((timer_margin < TIMER_MARGIN_MIN) ||
-	    (timer_margin > TIMER_MARGIN_MAX)) {
-		pr_info("MXC watchdog error. wrong timer_margin %d\n",
-			timer_margin);
-		pr_info("    Range: %d to %d seconds\n", TIMER_MARGIN_MIN,
-			TIMER_MARGIN_MAX);
-		return -EINVAL;
-	}
-
-	return platform_driver_register(&mxc_wdt_driver);
-}
-
-static void __exit mxc_wdt_exit(void)
-{
-	platform_driver_unregister(&mxc_wdt_driver);
-	pr_info("MXC WatchDog Driver removed\n");
-}
-
-module_init(mxc_wdt_init);
-module_exit(mxc_wdt_exit);
-
-MODULE_AUTHOR("Freescale Semiconductor, Inc.");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
Index: linux-2.6.24/drivers/char/watchdog/mxc_wdt.h
===================================================================
--- linux-2.6.24.orig/drivers/char/watchdog/mxc_wdt.h	2009-01-24 22:01:08.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,37 +0,0 @@
-/*
- *  linux/drivers/char/watchdog/mxc_wdt.h
- *
- *  BRIEF MODULE DESCRIPTION
- *      MXC Watchdog timer register definitions
- *
- * Author: MontaVista Software, Inc.
- *       <AKuster@mvista.com> or <source@mvista.com>
- *
- * 2005 (c) MontaVista Software, Inc.
- * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
- * This file is licensed under the terms of the GNU General Public License
- * version 2. This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- */
-
-#ifndef __MXC_WDT_H__
-#define __MXC_WDT_H__
-
-#define MXC_WDT_WCR             0x00
-#define MXC_WDT_WSR             0x02
-#define MXC_WDT_WRSR            0x04
-#define WCR_WOE_BIT             (1 << 6)
-#define WCR_WDA_BIT             (1 << 5)
-#define WCR_SRS_BIT             (1 << 4)
-#define WCR_WRE_BIT             (1 << 3)
-#define WCR_WDE_BIT             (1 << 2)
-#define WCR_WDBG_BIT            (1 << 1)
-#define WCR_WDZST_BIT           (1 << 0)
-#define WDT_MAGIC_1             0x5555
-#define WDT_MAGIC_2             0xAAAA
-
-#define TIMER_MARGIN_MAX    	127
-#define TIMER_MARGIN_DEFAULT	60	/* 60 secs */
-#define TIMER_MARGIN_MIN	1
-
-#endif				/* __MXC_WDT_H__ */
Index: linux-2.6.24/drivers/ide/arm/mxc_ide.c
===================================================================
--- linux-2.6.24.orig/drivers/ide/arm/mxc_ide.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/ide/arm/mxc_ide.c	2009-01-24 22:01:10.000000000 +0100
@@ -858,7 +858,8 @@
 
 	hwif->dmatable_cpu = NULL;
 	hwif->dmatable_dma = 0;
-	hwif->speedproc = mxc_ide_set_speed;
+	hwif->set_dma_mode = mxc_ide_set_speed;
+	hwif->set_pio_mode = mxc_ide_set_speed;
 	hwif->resetproc = mxc_ide_resetproc;
 	hwif->autodma = 0;
 
Index: linux-2.6.24/drivers/input/keyboard/mxc_keyb.c
===================================================================
--- linux-2.6.24.orig/drivers/input/keyboard/mxc_keyb.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/input/keyboard/mxc_keyb.c	2009-01-24 22:01:10.000000000 +0100
@@ -783,9 +783,9 @@
 	keypad->irq = irq;
 	retval = request_irq(irq, mxc_kpp_interrupt, 0, MOD_NAME, MOD_NAME);
 	if (retval) {
-		pr_debug("KPP: request_irq(%d) returned error %d\n", INT_KPP,
-			 retval);
-		return -1;
+		pr_debug("KPP: request_irq(%d) returned error %d\n",
+			 MXC_INT_KPP, retval);
+		return retval;
 	}
 
 	/* Enable keypad clock */
@@ -835,16 +835,21 @@
 
 	if ((keypad->matrix == (void *)0)
 	    || (mxckpd_keycodes_size == 0)) {
-		free_irq(irq, MOD_NAME);
-		return -ENODEV;
+		retval = -ENODEV;
+		goto err1;
 	}
 
 	mxckbd_dev = input_allocate_device();
 	if (!mxckbd_dev) {
 		printk(KERN_ERR
 		       "mxckbd_dev: not enough memory for input device\n");
-		free_irq(irq, MOD_NAME);
-		return -ENOMEM;
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	retval = input_register_device(mxckbd_dev);
+	if (retval < 0) {
+		goto err2;
 	}
 
 	mxckbd_dev->keycode = &mxckpd_keycodes;
@@ -862,9 +867,8 @@
 	    kmalloc(kpp_dev.kpp_rows * sizeof(release_scancode[0]), GFP_KERNEL);
 
 	if (!press_scancode || !release_scancode) {
-		free_irq(irq, MOD_NAME);
-		mxc_kpp_free_allocated();
-		return -1;
+		retval = -ENOMEM;
+		goto err3;
 	}
 
 	for (i = 0; i < kpp_dev.kpp_rows; i++) {
@@ -876,9 +880,8 @@
 			    GFP_KERNEL);
 
 		if (!press_scancode[i] || !release_scancode[i]) {
-			free_irq(irq, MOD_NAME);
-			mxc_kpp_free_allocated();
-			return -1;
+			retval = -ENOMEM;
+			goto err3;
 		}
 	}
 
@@ -888,9 +891,8 @@
 	    kmalloc(kpp_dev.kpp_rows * sizeof(prev_rcmap[0]), GFP_KERNEL);
 
 	if (!cur_rcmap || !prev_rcmap) {
-		free_irq(irq, MOD_NAME);
-		mxc_kpp_free_allocated();
-		return -1;
+		retval = -ENOMEM;
+		goto err3;
 	}
 
 	__set_bit(EV_KEY, mxckbd_dev->evbit);
@@ -911,13 +913,21 @@
 	/* Initialize the polling timer */
 	init_timer(&kpp_dev.poll_timer);
 
-	input_register_device(mxckbd_dev);
-
 	/* By default, devices should wakeup if they can */
 	/* So keypad is set as "should wakeup" as it can */
 	device_init_wakeup(&pdev->dev, 1);
 
 	return 0;
+
+      err3:
+	mxc_kpp_free_allocated();
+      err2:
+	input_free_device(mxckbd_dev);
+      err1:
+	free_irq(irq, MOD_NAME);
+	clk_disable(kpp_clk);
+	clk_put(kpp_clk);
+	return retval;
 }
 
 /*!
Index: linux-2.6.24/drivers/input/keyboard/mxc_keyb.h
===================================================================
--- linux-2.6.24.orig/drivers/input/keyboard/mxc_keyb.h	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/input/keyboard/mxc_keyb.h	2009-01-24 22:01:10.000000000 +0100
@@ -33,7 +33,7 @@
 /*!
  * Keypad irq number
  */
-#define KPP_IRQ  INT_KPP
+#define KPP_IRQ  MXC_INT_KPP
 
 /*!
  * XLATE mode selection
Index: linux-2.6.24/drivers/input/touchscreen/mxc_ts.c
===================================================================
--- linux-2.6.24.orig/drivers/input/touchscreen/mxc_ts.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/input/touchscreen/mxc_ts.c	2009-01-24 22:01:10.000000000 +0100
@@ -66,6 +66,8 @@
 
 static int __init mxc_ts_init(void)
 {
+	int retval;
+
 	mxc_inputdev = input_allocate_device();
 	if (!mxc_inputdev) {
 		printk(KERN_ERR
@@ -74,10 +76,15 @@
 	}
 
 	mxc_inputdev->name = MXC_TS_NAME;
-	mxc_inputdev->evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
-	mxc_inputdev->keybit[LONG(BTN_TOUCH)] |= BIT(BTN_TOUCH);
-	mxc_inputdev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);
-	input_register_device(mxc_inputdev);
+	mxc_inputdev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	mxc_inputdev->keybit[BIT_WORD(BTN_TOUCH)] |= BIT_MASK(BTN_TOUCH);
+	mxc_inputdev->absbit[0] =
+	    BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) | BIT_MASK(ABS_PRESSURE);
+	retval = input_register_device(mxc_inputdev);
+	if (retval < 0) {
+		input_free_device(mxc_inputdev);
+		return retval;
+	}
 
 	input_ts_installed = 1;
 	kernel_thread(ts_thread, NULL, CLONE_VM | CLONE_FS);
Index: linux-2.6.24/drivers/media/video/mxc/capture/mx27_csi.c
===================================================================
--- linux-2.6.24.orig/drivers/media/video/mxc/capture/mx27_csi.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/media/video/mxc/capture/mx27_csi.c	2009-01-24 22:01:10.000000000 +0100
@@ -303,7 +303,7 @@
 	csihw_reset();
 
 	/* interrupt enable */
-	ret = request_irq(INT_CSI, csi_irq_handler, 0, "csi", 0);
+	ret = request_irq(MXC_INT_CSI, csi_irq_handler, 0, "csi", 0);
 	if (ret)
 		pr_debug("CSI error: irq request fail\n");
 
@@ -313,7 +313,7 @@
 void __exit csi_cleanup_module(void)
 {
 	/* free irq */
-	free_irq(INT_CSI, 0);
+	free_irq(MXC_INT_CSI, 0);
 
 	clk_disable(&csi_mclk);
 }
Index: linux-2.6.24/drivers/media/video/mxc/capture/mx27_prpsw.c
===================================================================
--- linux-2.6.24.orig/drivers/media/video/mxc/capture/mx27_prpsw.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/media/video/mxc/capture/mx27_prpsw.c	2009-01-24 22:01:10.000000000 +0100
@@ -331,8 +331,8 @@
  */
 int prp_init(void *dev_id)
 {
-	enable_irq(INT_EMMAPRP);
-	if (request_irq(INT_EMMAPRP, prp_isr, 0, prp_dev, dev_id))
+	enable_irq(MXC_INT_EMMAPRP);
+	if (request_irq(MXC_INT_EMMAPRP, prp_isr, 0, prp_dev, dev_id))
 		return -1;
 	prphw_init();
 
@@ -346,8 +346,8 @@
 void prp_exit(void *dev_id)
 {
 	prphw_exit();
-	disable_irq(INT_EMMAPRP);
-	free_irq(INT_EMMAPRP, dev_id);
+	disable_irq(MXC_INT_EMMAPRP);
+	free_irq(MXC_INT_EMMAPRP, dev_id);
 }
 
 /*!
Index: linux-2.6.24/drivers/media/video/mxc/capture/mx27_v4l2_capture.c
===================================================================
--- linux-2.6.24.orig/drivers/media/video/mxc/capture/mx27_v4l2_capture.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/media/video/mxc/capture/mx27_v4l2_capture.c	2009-01-24 22:01:10.000000000 +0100
@@ -1746,7 +1746,6 @@
 	.name = "Mxc Camera",
 	.type = 0,
 	.type2 = VID_TYPE_CAPTURE,
-	.hardware = 0,
 	.fops = &mxc_v4l_fops,
 	.release = video_device_release,
 };
Index: linux-2.6.24/drivers/media/video/mxc/capture/mxc_v4l2_capture.c
===================================================================
--- linux-2.6.24.orig/drivers/media/video/mxc/capture/mxc_v4l2_capture.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/media/video/mxc/capture/mxc_v4l2_capture.c	2009-01-24 22:01:10.000000000 +0100
@@ -1545,7 +1545,6 @@
 	.name = "Mxc Camera",
 	.type = 0,
 	.type2 = VID_TYPE_CAPTURE,
-	.hardware = 0,
 	.fops = &mxc_v4l_fops,
 	.release = video_device_release,
 };
Index: linux-2.6.24/drivers/media/video/mxc/output/mx27_pp.c
===================================================================
--- linux-2.6.24.orig/drivers/media/video/mxc/output/mx27_pp.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/media/video/mxc/output/mx27_pp.c	2009-01-24 22:01:10.000000000 +0100
@@ -125,8 +125,8 @@
 {
 	pphw_init();
 	pphw_enable(0);
-	enable_irq(INT_EMMAPP);
-	return request_irq(INT_EMMAPP, pp_isr, 0, pp_dev, vout);
+	enable_irq(MXC_INT_EMMAPP);
+	return request_irq(MXC_INT_EMMAPP, pp_isr, 0, pp_dev, vout);
 }
 
 /*!
@@ -135,8 +135,8 @@
  */
 void pp_exit(vout_data * vout)
 {
-	disable_irq(INT_EMMAPP);
-	free_irq(INT_EMMAPP, vout);
+	disable_irq(MXC_INT_EMMAPP);
+	free_irq(MXC_INT_EMMAPP, vout);
 	pphw_enable(0);
 	pphw_exit();
 }
Index: linux-2.6.24/drivers/media/video/mxc/output/mx27_v4l2_output.c
===================================================================
--- linux-2.6.24.orig/drivers/media/video/mxc/output/mx27_v4l2_output.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/media/video/mxc/output/mx27_v4l2_output.c	2009-01-24 22:01:10.000000000 +0100
@@ -1301,7 +1301,6 @@
 	.name = "MXC Video Output",
 	.type = 0,
 	.type2 = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING,
-	.hardware = 39,
 	.fops = &mxc_v4l2out_fops,
 	.release = video_device_release,
 };
Index: linux-2.6.24/drivers/media/video/mxc/output/mxc_v4l2_output.c
===================================================================
--- linux-2.6.24.orig/drivers/media/video/mxc/output/mxc_v4l2_output.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/media/video/mxc/output/mxc_v4l2_output.c	2009-01-24 22:01:10.000000000 +0100
@@ -1554,7 +1554,6 @@
 	.name = "MXC Video Output",
 	.type = 0,
 	.type2 = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING,
-	.hardware = 0,
 	.fops = &mxc_v4l2out_fops,
 	.release = video_device_release,
 };
Index: linux-2.6.24/drivers/mmc/host/mxc_mmc.c
===================================================================
--- linux-2.6.24.orig/drivers/mmc/host/mxc_mmc.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/mmc/host/mxc_mmc.c	2009-01-24 22:01:10.000000000 +0100
@@ -579,11 +579,11 @@
 	if (stat & STATUS_TIME_OUT_RESP) {
 		__raw_writel(STATUS_TIME_OUT_RESP, host->base + MMC_STATUS);
 		pr_debug("%s: CMD TIMEOUT\n", DRIVER_NAME);
-		cmd->error = MMC_ERR_TIMEOUT;
+		cmd->error = -ETIMEDOUT;
 	} else if (stat & STATUS_RESP_CRC_ERR && cmd->flags & MMC_RSP_CRC) {
 		__raw_writel(STATUS_RESP_CRC_ERR, host->base + MMC_STATUS);
 		printk(KERN_ERR "%s: cmd crc error\n", DRIVER_NAME);
-		cmd->error = MMC_ERR_BADCRC;
+		cmd->error = -EILSEQ;
 	}
 
 	/* Read response from the card */
@@ -614,7 +614,7 @@
 	pr_debug("%s: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n", DRIVER_NAME,
 		 cmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3]);
 
-	if (!host->data || cmd->error != MMC_ERR_NONE) {
+	if (!host->data || cmd->error) {
 		/* complete the command */
 		mxcmci_finish_request(host, host->req);
 		return 1;
@@ -629,8 +629,7 @@
 	}
 #endif
 	/* Use PIO tranfer of data */
-	buf =
-	    (unsigned long *)(page_address(data->sg->page) + data->sg->offset);
+	buf = (unsigned long *)sg_virt(data->sg);
 	buf8 = (u8 *) buf;
 
 	/* calculate the number of bytes requested for transfer */
@@ -665,12 +664,12 @@
 		status = __raw_readl(host->base + MMC_STATUS);
 		if (status & STATUS_TIME_OUT_READ) {
 			pr_debug("%s: Read time out occurred\n", DRIVER_NAME);
-			data->error = MMC_ERR_TIMEOUT;
+			data->error = -ETIMEDOUT;
 			__raw_writel(STATUS_TIME_OUT_READ,
 				     host->base + MMC_STATUS);
 		} else if (status & STATUS_READ_CRC_ERR) {
 			pr_debug("%s: Read CRC error occurred\n", DRIVER_NAME);
-			data->error = MMC_ERR_BADCRC;
+			data->error = -EILSEQ;
 			__raw_writel(STATUS_READ_CRC_ERR,
 				     host->base + MMC_STATUS);
 		}
@@ -700,7 +699,7 @@
 		status = __raw_readl(host->base + MMC_STATUS);
 		if (status & STATUS_WRITE_CRC_ERR) {
 			pr_debug("%s: Write CRC error occurred\n", DRIVER_NAME);
-			data->error = MMC_ERR_BADCRC;
+			data->error = -EILSEQ;
 			__raw_writel(STATUS_WRITE_CRC_ERR,
 				     host->base + MMC_STATUS);
 		}
@@ -747,7 +746,7 @@
 	host->data = NULL;
 	data->bytes_xfered = host->dma_size;
 
-	if (host->req->stop && data->error == MMC_ERR_NONE) {
+	if (host->req->stop && !(data->error)) {
 		mxcmci_start_cmd(host, host->req->stop, 0);
 	} else {
 		mxcmci_finish_request(host, host->req);
@@ -1072,13 +1071,13 @@
 			if (status & STATUS_TIME_OUT_READ) {
 				pr_debug("%s: Read time out occurred\n",
 					 DRIVER_NAME);
-				data->error = MMC_ERR_TIMEOUT;
+				data->error = -ETIMEDOUT;
 				__raw_writel(STATUS_TIME_OUT_READ,
 					     host->base + MMC_STATUS);
 			} else if (status & STATUS_READ_CRC_ERR) {
 				pr_debug("%s: Read CRC error occurred\n",
 					 DRIVER_NAME);
-				data->error = MMC_ERR_BADCRC;
+				data->error = -EILSEQ;
 				__raw_writel(STATUS_READ_CRC_ERR,
 					     host->base + MMC_STATUS);
 			}
@@ -1091,7 +1090,7 @@
 			if (status & STATUS_WRITE_CRC_ERR) {
 				pr_debug("%s: Write CRC error occurred\n",
 					 DRIVER_NAME);
-				data->error = MMC_ERR_BADCRC;
+				data->error = -EILSEQ;
 				__raw_writel(STATUS_WRITE_CRC_ERR,
 					     host->base + MMC_STATUS);
 			}
@@ -1099,7 +1098,7 @@
 				     host->base + MMC_STATUS);
 		}
 	} else {
-		data->error = MMC_ERR_FAILED;
+		data->error = -EIO;
 		pr_debug("%s:%d: MXC MMC DMA transfer failed.\n", __FUNCTION__,
 			 __LINE__);
 	}
Index: linux-2.6.24/drivers/mtd/nand/mxc_nd.c
===================================================================
--- linux-2.6.24.orig/drivers/mtd/nand/mxc_nd.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/mtd/nand/mxc_nd.c	2009-01-24 22:01:10.000000000 +0100
@@ -209,10 +209,6 @@
 	if (!is2k_Pagesize) {
 		if (bSpareOnly) {
 			NFC_CONFIG1 |= NFC_SP_EN;
-			/* Workaround ecc status register error for spare-only read */
-			if (cpu_is_mxc91131_rev(CHIP_REV_2_0) >= 1) {
-				NFC_CONFIG1 &= ~(NFC_SP_EN);
-			}
 		} else {
 			NFC_CONFIG1 &= ~(NFC_SP_EN);
 		}
@@ -366,10 +362,6 @@
 	if (!is2k_Pagesize) {
 		if (bSpareOnly) {
 			NFC_CONFIG1 |= NFC_SP_EN;
-			/* Workaround ecc status register error for spare-only read */
-			if (cpu_is_mxc91131_rev(CHIP_REV_2_0) >= 1) {
-				NFC_CONFIG1 &= ~(NFC_SP_EN);
-			}
 		} else {
 			NFC_CONFIG1 &= ~(NFC_SP_EN);
 		}
@@ -386,13 +378,7 @@
 	   NFC for the second page.
 	   Correct single bit error in driver */
 
-	/* Removed NFC workaround in MXC91231-P2.1 */
-	if (cpu_is_mxc91231_rev(CHIP_REV_2_1) < 0) {
-		mxc_nd_correct_ecc(buf_id, bSpareOnly);
-	} else {
-		mxc_nd_correct_ecc(buf_id, bSpareOnly);
-	}
-
+	mxc_nd_correct_ecc(buf_id, bSpareOnly);
 }
 
 /*!
@@ -1162,7 +1148,7 @@
 
 	NFC_CONFIG1 |= NFC_INT_MSK;
 	init_waitqueue_head(&irq_waitq);
-	err = request_irq(INT_NANDFC, mxc_nfc_irq, 0, "mxc_nd", NULL);
+	err = request_irq(MXC_INT_NANDFC, mxc_nfc_irq, 0, "mxc_nd", NULL);
 	if (err) {
 		goto out_1;
 	}
@@ -1191,10 +1177,6 @@
 	NFC_UNLOCKSTART_BLKADDR = 0x0;
 	NFC_UNLOCKEND_BLKADDR = 0x4000;
 
-	/* support for One Flash Clock cycle new in rev 2.0 */
-	if (cpu_is_mxc91131_rev(CHIP_REV_2_0) >= 1) {
-		NFC_CONFIG1 |= (NFC_ONE_CYCLE);
-	}
 	/* Unlock Block Command for given address range */
 	NFC_WRPROT = 0x4;
 
@@ -1262,7 +1244,7 @@
 
 	if (mxc_nand_data) {
 		nand_release(mtd);
-		free_irq(INT_NANDFC, NULL);
+		free_irq(MXC_INT_NANDFC, NULL);
 		kfree(mxc_nand_data);
 	}
 
Index: linux-2.6.24/drivers/mtd/nand/mxc_nd2.c
===================================================================
--- linux-2.6.24.orig/drivers/mtd/nand/mxc_nd2.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/mtd/nand/mxc_nd2.c	2009-01-24 22:01:10.000000000 +0100
@@ -1137,7 +1137,7 @@
 	raw_write((raw_read(REG_NFC_INTRRUPT) | NFC_INT_MSK), REG_NFC_INTRRUPT);
 
 	init_waitqueue_head(&irq_waitq);
-	err = request_irq(INT_NANDFC, mxc_nfc_irq, 0, "mxc_nd", NULL);
+	err = request_irq(MXC_INT_NANDFC, mxc_nfc_irq, 0, "mxc_nd", NULL);
 	if (err) {
 		goto out_1;
 	}
@@ -1244,7 +1244,7 @@
 
 	if (mxc_nand_data) {
 		nand_release(mtd);
-		free_irq(INT_NANDFC, NULL);
+		free_irq(MXC_INT_NANDFC, NULL);
 		kfree(mxc_nand_data);
 	}
 
Index: linux-2.6.24/drivers/mxc/hmp4e/mxc_hmp4e.c
===================================================================
--- linux-2.6.24.orig/drivers/mxc/hmp4e/mxc_hmp4e.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/mxc/hmp4e/mxc_hmp4e.c	2009-01-24 22:01:10.000000000 +0100
@@ -84,7 +84,7 @@
 static bool irq_enable = false;
 
 ulong base_port = MPEG4_ENC_BASE_ADDR;
-u32 irq = INT_MPEG4_ENC;
+u32 irq = MXC_INT_MPEG4_ENC;
 
 module_param(base_port, long, 000);
 module_param(irq, int, 000);
Index: linux-2.6.24/drivers/mxc/pm/dptc_mx27.c
===================================================================
--- linux-2.6.24.orig/drivers/mxc/pm/dptc_mx27.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/mxc/pm/dptc_mx27.c	2009-01-24 22:01:10.000000000 +0100
@@ -1348,7 +1348,7 @@
 	}
 
 	/* request the DPTC interrupt */
-	res = request_irq(INT_CCM, dptc_mx27_irq, 0, DEVICE_NAME, NULL);
+	res = request_irq(MXC_INT_CCM, dptc_mx27_irq, 0, DEVICE_NAME, NULL);
 
 	/*
 	 * If res is not 0, then where was an error
@@ -1398,7 +1398,7 @@
 	unregister_chrdev(major, DEVICE_NAME);
 
 	/* release the DPTC interrupt */
-	free_irq(INT_CCM, NULL);
+	free_irq(MXC_INT_CCM, NULL);
 
 	/* Unregister low power modes functions */
 	platform_driver_unregister(&mxc_dptc_driver);
Index: linux-2.6.24/drivers/mxc/security/mxc_scc.c
===================================================================
--- linux-2.6.24.orig/drivers/mxc/security/mxc_scc.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/mxc/security/mxc_scc.c	2009-01-24 22:01:10.000000000 +0100
@@ -423,13 +423,13 @@
 
 	/* Deregister SCM interrupt handler */
 	if (scm_irq_set) {
-		free_irq(INT_SCC_SCM, NULL);
+		free_irq(MXC_INT_SCC_SCM, NULL);
 	}
 
 	/* Deregister SMN interrupt handler */
 	if (smn_irq_set) {
 #ifdef USE_SMN_INTERRUPT
-		free_irq(INT_SCC_SMN, NULL);
+		free_irq(MXC_INT_SCC_SMN, NULL);
 #endif
 	}
 	pr_debug("SCC driver cleaned up.\n");
@@ -842,11 +842,11 @@
 	uint32_t scm_status;
 	int handled = 0;	/* assume interrupt isn't from SMN */
 #if defined(USE_SMN_INTERRUPT)
-	int smn_irq = INT_SCC_SMN;	/* SMN interrupt is on a line by itself */
+	int smn_irq = MXC_INT_SCC_SMN;	/* SMN interrupt is on a line by itself */
 #elif defined (NO_SMN_INTERRUPT)
 	int smn_irq = -1;	/* not wired to CPU at all */
 #else
-	int smn_irq = INT_SCC_SCM;	/* SMN interrupt shares a line with SCM */
+	int smn_irq = MXC_INT_SCC_SCM;	/* SMN interrupt shares a line with SCM */
 #endif
 
 	/* Update current state... This will perform callbacks... */
@@ -863,7 +863,7 @@
 	scm_status = SCC_READ_REGISTER(SCM_STATUS);
 
 	/* The driver masks interrupts, so this should never happen. */
-	if (irq == INT_SCC_SCM && scm_status & SCM_STATUS_INTERRUPT_STATUS) {
+	if (irq == MXC_INT_SCC_SCM && scm_status & SCM_STATUS_INTERRUPT_STATUS) {
 		/* but if it does, try to prevent it in the future */
 		SCC_WRITE_REGISTER(SCM_INTERRUPT_CTRL,
 				   SCM_INTERRUPT_CTRL_CLEAR_INTERRUPT
@@ -1345,7 +1345,7 @@
 
 #ifdef USE_SMN_INTERRUPT
 	/* Install interrupt service routine for SMN. */
-	smn_error_code = request_irq(INT_SCC_SMN, scc_irq, 0,
+	smn_error_code = request_irq(MXC_INT_SCC_SMN, scc_irq, 0,
 				     SCC_DRIVER_NAME, NULL);
 	if (smn_error_code != 0) {
 		pr_debug
@@ -1365,7 +1365,7 @@
 	/*
 	 * Install interrupt service routine for SCM (or both together).
 	 */
-	scm_error_code = request_irq(INT_SCC_SCM, scc_irq, 0,
+	scm_error_code = request_irq(MXC_INT_SCC_SCM, scc_irq, 0,
 				     SCC_DRIVER_NAME, NULL);
 	if (scm_error_code != 0) {
 #ifndef MXC
Index: linux-2.6.24/drivers/mxc/security/rng/rng_driver.c
===================================================================
--- linux-2.6.24.orig/drivers/mxc/security/rng/rng_driver.c	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/mxc/security/rng/rng_driver.c	2009-01-24 22:01:10.000000000 +0100
@@ -375,7 +375,7 @@
 
 		if (rng_irq_set) {
 			/* unmap the interrupts from the IRQ lines */
-			os_deregister_interrupt(INT_RNG);
+			os_deregister_interrupt(MXC_INT_RNG);
 			rng_irq_set = FALSE;
 		}
 		rng_availability = RNG_STATUS_FAILED;
@@ -799,7 +799,7 @@
 /* fn rng_setup_interrupt_handling()                                        */
 /*!***************************************************************************/
 /*!
- * Register #rng_irq() as the interrupt handler for #INT_RNG.
+ * Register #rng_irq() as the interrupt handler for #MXC_INT_RNG.
  *
  * @return OS_ERROR_OK_S on success, os_error_code on failure
  */
@@ -811,7 +811,7 @@
 	 * Install interrupt service routine for the RNG. Ignore the
 	 * assigned IRQ number.
 	 */
-	error_code = os_register_interrupt(RNG_DRIVER_NAME, INT_RNG,
+	error_code = os_register_interrupt(RNG_DRIVER_NAME, MXC_INT_RNG,
 					   OS_DEV_ISR_REF(rng_irq));
 	if (error_code != OS_ERROR_OK_S) {
 		pr_debug("RNG Driver: Error installing Interrupt Handler\n");
Index: linux-2.6.24/drivers/mxc/security/sahara2/include/sah_kernel.h
===================================================================
--- linux-2.6.24.orig/drivers/mxc/security/sahara2/include/sah_kernel.h	2009-01-24 22:01:08.000000000 +0100
+++ linux-2.6.24/drivers/mxc/security/sahara2/include/sah_kernel.h	2009-01-24 22:01:10.000000000 +0100
@@ -31,7 +31,7 @@
     || defined(CONFIG_ARCH_MXC92323)
 #include <asm/arch/hardware.h>
 #define SAHA_BASE_ADDR SAHARA_BASE_ADDR
-#define SAHARA_IRQ     INT_SAHARA
+#define SAHARA_IRQ     MXC_INT_SAHARA
 #else
 #include <asm/arch/mx2.h>
 #endif
Index: linux-2.6.24/drivers/mxc/vpu/mxc_vpu.c
===================================================================
--- linux-2.6.24.orig/drivers/mxc/vpu/mxc_vpu.c	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/mxc/vpu/mxc_vpu.c	2009-01-24 22:01:10.000000000 +0100
@@ -417,7 +417,7 @@
 		goto err_out_class;
 	}
 
-	err = request_irq(INT_VPU, vpu_irq_handler, 0, "VPU_CODEC_IRQ",
+	err = request_irq(MXC_INT_VPU, vpu_irq_handler, 0, "VPU_CODEC_IRQ",
 			  (void *)(&vpu_data));
 	if (err)
 		goto err_out_class;
@@ -459,15 +459,11 @@
 
 static void __exit vpu_exit(void)
 {
-	free_irq(INT_VPU, (void *)(&vpu_data));
+	free_irq(MXC_INT_VPU, (void *)(&vpu_data));
 	if (vpu_major > 0) {
 		class_device_destroy(vpu_class, MKDEV(vpu_major, 0));
 		class_destroy(vpu_class);
-		if (unregister_chrdev(vpu_major, "mxc_vpu") < 0) {
-			printk(KERN_ERR
-			       "Failed to unregister vpu from devfs\n");
-			return;
-		}
+		unregister_chrdev(vpu_major, "mxc_vpu");
 		vpu_major = 0;
 	}
 
Index: linux-2.6.24/drivers/net/smc911x.h
===================================================================
--- linux-2.6.24.orig/drivers/net/smc911x.h	2009-01-24 21:59:19.000000000 +0100
+++ linux-2.6.24/drivers/net/smc911x.h	2009-01-24 22:01:10.000000000 +0100
@@ -44,6 +44,7 @@
   #define SMC_IRQ_SENSE		IRQF_TRIGGER_LOW
 #endif
 
+  #define SMC_IRQ_SENSE		IRQF_TRIGGER_LOW
 
 /*
  * Define the bus width specific IO macros
Index: linux-2.6.24/drivers/otg/hardware/arc-dev.c
===================================================================
--- linux-2.6.24.orig/drivers/otg/hardware/arc-dev.c	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/otg/hardware/arc-dev.c	2009-01-24 22:01:10.000000000 +0100
@@ -64,11 +64,6 @@
 /* arc Proc FS
  */
 
-#define SHOW(s, r, c) seq_printf(s, "%20s [%8x] %08x %s\n", #r, &r, r, c)
-#define BITS(s, c) seq_printf(s, "%24s: ", c);
-#define BIT(s, r, m) seq_printf(s, "%s%s ", #m, (r & m) ? "" : "/");
-#define NL(s) seq_printf(s, "\n");
-
 /*! arc_dev_show - called to display information
  * @param s
  * @param unused
@@ -83,7 +78,6 @@
 
         seq_printf(s, "\nOTG Registers\n");
 
-        //SHOW(s, UOG_ID, "Host ID");
         seq_printf(s, "\n");
 
         return 0;
Index: linux-2.6.24/drivers/otg/hardware/arc-pcd.c
===================================================================
--- linux-2.6.24.orig/drivers/otg/hardware/arc-pcd.c	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/otg/hardware/arc-pcd.c	2009-01-24 22:01:10.000000000 +0100
@@ -64,7 +64,7 @@
         struct ep_queue_head    *qh = &udc_controller->ep_qh[0 * 2 + ARC_DIR_OUT];
         int                     timeout;
 
-        consistent_sync(qh, sizeof(struct ep_queue_head), DMA_FROM_DEVICE);
+        dma_cache_maint(qh, sizeof(struct ep_queue_head), DMA_FROM_DEVICE);
 
         /* C.f 39.16.3.2.1 Setup Phase - Setup Packet Handling (2.3 hardware and later)
          */
@@ -103,8 +103,8 @@
         struct usbd_urb         *rx_urb = endpoint->rcv_urb;
 
         /* sync qh and td structures, note that urb-buffer was invalidated in arc_add_buffer_to_dtd() */
-        consistent_sync(qh, sizeof(struct ep_queue_head), DMA_FROM_DEVICE);
-        consistent_sync(curr_td, sizeof(struct ep_td_struct), DMA_FROM_DEVICE);
+        dma_cache_maint(qh, sizeof(struct ep_queue_head), DMA_FROM_DEVICE);
+        dma_cache_maint(curr_td, sizeof(struct ep_td_struct), DMA_FROM_DEVICE);
 
         if (rx_urb) {
                 int length = rx_urb->buffer_length -
@@ -309,11 +309,11 @@
 
                 /* flush cache for IN */
                 if ((dir == ARC_DIR_IN) && urb->actual_length)
-                        consistent_sync(urb->buffer, urb->actual_length, DMA_TO_DEVICE);
+                        dma_cache_maint(urb->buffer, urb->actual_length, DMA_TO_DEVICE);
 
                 /* invalidate cache for OUT */
                 else if ((dir == ARC_DIR_OUT) && urb->buffer_length)
-                        consistent_sync(urb->buffer, urb->alloc_length, DMA_FROM_DEVICE);
+                        dma_cache_maint(urb->buffer, urb->alloc_length, DMA_FROM_DEVICE);
         }
 
         /* Set size and interrupt on each dtd, Clear reserved field,
@@ -325,7 +325,7 @@
         dtd->buff_ptr0 = cpu_to_le32(endpoint->active_urb ?  (u32) (virt_to_phys (endpoint->active_urb->buffer + offset)) : 0);
         dtd->next_td_ptr = cpu_to_le32(DTD_NEXT_TERMINATE);
         dtd->next_td_virt = NULL;
-        consistent_sync(dtd, sizeof(struct ep_td_struct), DMA_TO_DEVICE);
+        dma_cache_maint(dtd, sizeof(struct ep_td_struct), DMA_TO_DEVICE);
         privdata->cur_dqh = dQH;
 
         /* Case 1 - Step 1 - Write dQH next pointer and dQH terminate bit to 0 as single DWord */
@@ -334,7 +334,7 @@
         /* Case 1 - Step 2 - Clear active and halt bit */
         dQH->size_ioc_int_sts &= le32_to_cpu(~(EP_QUEUE_HEAD_STATUS_ACTIVE | EP_QUEUE_HEAD_STATUS_HALT));
 
-        consistent_sync(dQH, sizeof(struct ep_queue_head), DMA_TO_DEVICE);
+        dma_cache_maint(dQH, sizeof(struct ep_queue_head), DMA_TO_DEVICE);
 
         /* Case 1 - Step 3 - Prime endpoint by writing ENDPTPRIME */
         mask = (dir == ARC_DIR_OUT) ?  (1 << epnum) : (1 << (epnum + 16));
@@ -396,8 +396,8 @@
 static void arc_dtd_releases (struct pcd_instance *pcd, struct usbd_endpoint_instance *endpoint, int dir)
 {
         struct arc_private_struct *privdata = endpoint->privdata;
-        consistent_sync(privdata->cur_dtd, sizeof(struct ep_td_struct), (dir == ARC_DIR_OUT) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
-        consistent_sync(privdata->cur_dqh, sizeof(struct ep_queue_head), (dir == ARC_DIR_OUT) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+        dma_cache_maint(privdata->cur_dtd, sizeof(struct ep_td_struct), (dir == ARC_DIR_OUT) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+        dma_cache_maint(privdata->cur_dqh, sizeof(struct ep_queue_head), (dir == ARC_DIR_OUT) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 }
 
 
@@ -502,7 +502,7 @@
         }
         dQH->max_pkt_length = cpu_to_le32(tmp);
 
-        consistent_sync(dQH, sizeof(struct ep_queue_head), DMA_TO_DEVICE);
+        dma_cache_maint(dQH, sizeof(struct ep_queue_head), DMA_TO_DEVICE);
 
         /* Set the control register of endpoint */
         tmp = dir ?
@@ -525,7 +525,7 @@
                 dQH = &udc_controller->ep_qh[2 * epnum + dir];
                 tmp = (wMaxPacketSize << EP_QUEUE_HEAD_MAX_PKT_LEN_POS) | EP_QUEUE_HEAD_IOS;
                 dQH->max_pkt_length = le32_to_cpu(tmp);
-                consistent_sync(dQH, sizeof(struct ep_queue_head), DMA_FROM_DEVICE);
+                dma_cache_maint(dQH, sizeof(struct ep_queue_head), DMA_FROM_DEVICE);
                 tmp = USBOTG_REG32(0x1c0 + epnum*4);
                 tmp |= EPCTRL_TX_ENABLE;
                 tmp |= ((unsigned int)(type) << EPCTRL_TX_EP_TYPE_SHIFT);
@@ -843,7 +843,7 @@
                                         TRACE_MSG4(pcd->TAG, "[%2d:%2d] Current dtd is halted size_ioc_sts: %08x errors: %02x",
                                                         bit, ep, le32_to_cpu(cur_dtd->size_ioc_sts), errors);
                                         cur_dtd->size_ioc_sts &= cpu_to_le32(errors);
-                                        consistent_sync(cur_dtd, sizeof(struct ep_td_struct), DMA_TO_DEVICE);
+                                        dma_cache_maint(cur_dtd, sizeof(struct ep_td_struct), DMA_TO_DEVICE);
                                 }
 
                                 if ((pcd_rcv_complete_irq(endpoint, remain_len, 0))) {
Index: linux-2.6.24/drivers/otg/hardware/mxc-ocd.c
===================================================================
--- linux-2.6.24.orig/drivers/otg/hardware/mxc-ocd.c	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/otg/hardware/mxc-ocd.c	2009-01-24 22:01:10.000000000 +0100
@@ -485,7 +485,7 @@
  * @param dev_id
  * @param regs
  */
-irqreturn_t pcd_bwkup_int_hndlr_isr (int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t pcd_bwkup_int_hndlr_isr (int irq, void *dev_id)
 {
         //pcd_instance->otg->interrupts++;
         //TRACE_MSG0(OCD, "--");
@@ -499,7 +499,7 @@
  * @param dev_id
  * @param regs
  */
-irqreturn_t ocd_hnp_int_hndlr_isr (int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t ocd_hnp_int_hndlr_isr (int irq, void *dev_id)
 {
         //pcd_instance->otg->interrupts++;
         //TRACE_MSG0(OCD, "--");
@@ -513,7 +513,7 @@
  * @param dev_id
  * @param regs
  */
-irqreturn_t pcd_func_int_hndlr_isr (int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t pcd_func_int_hndlr_isr (int irq, void *dev_id)
 {
         //pcd_instance->otg->interrupts++;
         //TRACE_MSG0(OCD, "--");
@@ -529,7 +529,7 @@
  * @param dev_id
  * @param regs
  */
-irqreturn_t hcd_host_int_hndlr_isr (int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t hcd_host_int_hndlr_isr (int irq, void *dev_id)
 {
         //pcd_instance->otg->interrupts++;
         //TRACE_MSG0(OCD, "--");
@@ -543,7 +543,7 @@
  * @param dev_id
  * @param regs
  */
-irqreturn_t ocd_ctrl_int_hndlr_isr (int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t ocd_ctrl_int_hndlr_isr (int irq, void *dev_id)
 {
         //pcd_instance->otg->interrupts++;
         //TRACE_MSG0(OCD, "--");
@@ -557,7 +557,7 @@
  * @param dev_id
  * @param regs
  */
-irqreturn_t ocd_dma_int_hndlr_isr (int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t ocd_dma_int_hndlr_isr (int irq, void *dev_id)
 {
         //pcd_instance->otg->interrupts++;
         //TRACE_MSG0(OCD, "--");
Index: linux-2.6.24/drivers/otg/otg/otg-linux.h
===================================================================
--- linux-2.6.24.orig/drivers/otg/otg/otg-linux.h	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/otg/otg/otg-linux.h	2009-01-24 22:01:10.000000000 +0100
@@ -1091,7 +1091,7 @@
 #if defined(CONFIG_OTG_OLD_TX_CACHE)
 #define CACHE_SYNC_TX(buf, len) consistent_sync (NULL, buf, len, PCI_DMA_TODEVICE)
 #else
-#define CACHE_SYNC_TX(buf, len) consistent_sync (buf, len, PCI_DMA_TODEVICE)
+#define CACHE_SYNC_TX(buf, len) dma_cache_maint (buf, len, PCI_DMA_TODEVICE)
 #endif
 
 /*@}*/
Index: linux-2.6.24/drivers/pcmcia/mx31ads-pcmcia.c
===================================================================
--- linux-2.6.24.orig/drivers/pcmcia/mx31ads-pcmcia.c	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/pcmcia/mx31ads-pcmcia.c	2009-01-24 22:01:10.000000000 +0100
@@ -61,7 +61,7 @@
 #include "mx31ads-pcmcia.h"
 #include <linux/irq.h>
 
-#define	MX31ADS_PCMCIA_IRQ	INT_PCMCIA
+#define	MX31ADS_PCMCIA_IRQ	MXC_INT_PCMCIA
 
 /*
  * The mapping of window size to bank size value
Index: linux-2.6.24/drivers/serial/mxc_uart_early.c
===================================================================
--- linux-2.6.24.orig/drivers/serial/mxc_uart_early.c	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/serial/mxc_uart_early.c	2009-01-24 22:01:10.000000000 +0100
@@ -149,7 +149,7 @@
 			 device->baud);
 	}
 	printk(KERN_INFO
-	       "MXC_Early serial console at MMIO 0x%lx (options '%s')\n",
+	       "MXC_Early serial console at MMIO 0x%x (options '%s')\n",
 	       port->mapbase, device->options);
 	return 0;
 }
Index: linux-2.6.24/drivers/spi/mxc_spi.c
===================================================================
--- linux-2.6.24.orig/drivers/spi/mxc_spi.c	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/spi/mxc_spi.c	2009-01-24 22:01:10.000000000 +0100
@@ -786,13 +786,13 @@
 	while (!list_empty(&bitbang->queue) && limit--) {
 		spin_unlock_irqrestore(&bitbang->lock, flags);
 
-		dev_dbg(bitbang->master->cdev.dev, "wait for queue\n");
+		dev_dbg(&bitbang->master->dev, "wait for queue\n");
 		msleep(10);
 
 		spin_lock_irqsave(&bitbang->lock, flags);
 	}
 	if (!list_empty(&bitbang->queue)) {
-		dev_err(bitbang->master->cdev.dev, "queue didn't empty\n");
+		dev_err(&bitbang->master->dev, "queue didn't empty\n");
 		return -EBUSY;
 	}
 	spin_unlock_irqrestore(&bitbang->lock, flags);
Index: linux-2.6.24/drivers/usb/gadget/arcotg_udc.c
===================================================================
--- linux-2.6.24.orig/drivers/usb/gadget/arcotg_udc.c	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/usb/gadget/arcotg_udc.c	2009-01-24 22:01:10.000000000 +0100
@@ -42,11 +42,11 @@
 #include <linux/proc_fs.h>
 #include <linux/mm.h>
 #include <linux/platform_device.h>
-#include <linux/usb/ch9.h>
-#include <linux/usb_gadget.h>
 #include <linux/dma-mapping.h>
 #include <linux/dmapool.h>
 #include <linux/fsl_devices.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
 #include <linux/usb/fsl_xcvr.h>
 #include <linux/usb/otg.h>
 
@@ -824,49 +824,6 @@
 		kfree(req);
 }
 
-/*!
- * Allocate an I/O buffer for the ep->req->buf.
- * @param _ep    endpoint pointer
- * @param bytes  length of the desired buffer
- * @param dma   pointer to the buffer's DMA address; must be valid
- *       when gadget layer calls this function, ma is &req->dma
- * @param gfp_flags  GFP_* flags to use
- * @return Returns a new buffer, or null if one could not be allocated
- */
-static void *arcotg_alloc_buffer(struct usb_ep *_ep, unsigned bytes,
-				 dma_addr_t * dma, gfp_t gfp_flags)
-{
-	void *retval = NULL;
-
-	if (!bytes)
-		return 0;
-
-	retval = kmalloc(bytes, gfp_flags);
-
-	if (retval)
-		*dma = virt_to_phys(retval);
-
-	pr_debug("udc: ep=%s  buffer=0x%p  dma=0x%x  len=%d\n",
-		 _ep->name, retval, *dma, bytes);
-
-	return retval;
-}
-
-/*!
- * Free an I/O buffer for the ep->req->buf
- * @param _ep    endpoint pointer
- * @param buf    data buf pointer
- * @param dma    for 834x, we will not touch dma field
- * @param bytes  buffer size
- */
-static void arcotg_free_buffer(struct usb_ep *_ep, void *buf,
-			       dma_addr_t dma, unsigned bytes)
-{
-	pr_debug("udc: buf=0x%p  dma=0x%x\n", buf, dma);
-	if (buf)
-		kfree(buf);
-}
-
 /*-------------------------------------------------------------------------*/
 
 /*!
@@ -1332,9 +1289,6 @@
 	.alloc_request = arcotg_alloc_request,
 	.free_request = arcotg_free_request,
 
-	.alloc_buffer = arcotg_alloc_buffer,
-	.free_buffer = arcotg_free_buffer,
-
 	.queue = arcotg_ep_queue,
 	.dequeue = arcotg_ep_dequeue,
 
Index: linux-2.6.24/drivers/usb/host/ehci-arc.c
===================================================================
--- linux-2.6.24.orig/drivers/usb/host/ehci-arc.c	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/usb/host/ehci-arc.c	2009-01-24 22:01:10.000000000 +0100
@@ -32,7 +32,6 @@
 #include <linux/fsl_devices.h>
 #include <linux/usb/otg.h>
 #include <linux/usb/fsl_xcvr.h>
-#include <asm/arch/fsl_usb.h>
 
 #include "ehci-fsl.h"
 
@@ -87,10 +86,6 @@
 		return -ENODEV;
 	}
 
-	retval = fsl_platform_verify(pdev);
-	if (retval)
-		return retval;
-
 	/*
 	 * do platform specific init: check the clock, grab/config pins, etc.
 	 */
@@ -129,7 +124,11 @@
 	 * host port doesn't make it thru initializtion.
 	 * ehci_halt(), called by ehci_fsl_setup() returns -ETIMEDOUT
 	 */
-	fsl_platform_set_host_mode(hcd);
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_host)
+		pdata->xcvr_ops->set_host();
+
+	/* set host mode */
+	writel(readl(hcd->regs + 0x1a8) | USBMODE_CM_HC, hcd->regs + 0x1a8);
 
 	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
 	if (retval != 0) {
@@ -206,7 +205,6 @@
 /* called after powerup, by probe or system-pm "wakeup" */
 static int ehci_fsl_reinit(struct ehci_hcd *ehci)
 {
-	fsl_platform_usb_setup(ehci_to_hcd(ehci));
 	ehci_port_power(ehci, 0);
 
 	return 0;
@@ -261,7 +259,7 @@
 	 * generic hardware linkage
 	 */
 	.irq		= ehci_irq,
-	.flags		= FSL_PLATFORM_HC_FLAGS,
+	.flags		= HCD_USB2 | HCD_MEMORY,
 
 	/*
 	 * basic lifecycle operations
Index: linux-2.6.24/drivers/usb/usblan/usblan-compat.h
===================================================================
--- linux-2.6.24.orig/drivers/usb/usblan/usblan-compat.h	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/usb/usblan/usblan-compat.h	2009-01-24 22:01:10.000000000 +0100
@@ -277,7 +277,7 @@
  * @{
  */
 #define CACHE_SYNC_RCV(buf, len) pci_map_single (NULL, (void *) buf, len, PCI_DMA_FROMDEVICE)
-#define CACHE_SYNC_TX(buf, len) consistent_sync (buf, len, PCI_DMA_TODEVICE)
+#define CACHE_SYNC_TX(buf, len) dma_cache_maint (buf, len, PCI_DMA_TODEVICE)
 
 /* @} */
 
Index: linux-2.6.24/drivers/video/backlight/mxc_ipu_bl.c
===================================================================
--- linux-2.6.24.orig/drivers/video/backlight/mxc_ipu_bl.c	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/video/backlight/mxc_ipu_bl.c	2009-01-24 22:01:10.000000000 +0100
@@ -49,7 +49,7 @@
 static int mxcbl_send_intensity(struct backlight_device *bd)
 {
 	int intensity = bd->props.brightness;
-	struct mxcbl_dev_data *devdata = class_get_devdata(&bd->class_dev);
+	struct mxcbl_dev_data *devdata = dev_get_drvdata(&bd->dev);
 
 	if (bd->props.power != FB_BLANK_UNBLANK)
 		intensity = 0;
@@ -64,7 +64,7 @@
 
 static int mxcbl_get_intensity(struct backlight_device *bd)
 {
-	struct mxcbl_dev_data *devdata = class_get_devdata(&bd->class_dev);
+	struct mxcbl_dev_data *devdata = dev_get_drvdata(&bd->dev);
 	return devdata->intensity;
 }
 
Index: linux-2.6.24/drivers/video/backlight/mxc_lcdc_bl.c
===================================================================
--- linux-2.6.24.orig/drivers/video/backlight/mxc_lcdc_bl.c	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/video/backlight/mxc_lcdc_bl.c	2009-01-24 22:01:10.000000000 +0100
@@ -49,7 +49,7 @@
 static int mxcbl_send_intensity(struct backlight_device *bd)
 {
 	int intensity = bd->props.brightness;
-	struct mxcbl_dev_data *devdata = class_get_devdata(&bd->class_dev);
+	struct mxcbl_dev_data *devdata = dev_get_drvdata(&bd->dev);
 
 	if (bd->props.power != FB_BLANK_UNBLANK)
 		intensity = 0;
@@ -71,7 +71,7 @@
 
 static int mxcbl_get_intensity(struct backlight_device *bd)
 {
-	struct mxcbl_dev_data *devdata = class_get_devdata(&bd->class_dev);
+	struct mxcbl_dev_data *devdata = dev_get_drvdata(&bd->dev);
 	return devdata->intensity;
 }
 
Index: linux-2.6.24/drivers/video/backlight/mxc_pmic_bl.c
===================================================================
--- linux-2.6.24.orig/drivers/video/backlight/mxc_pmic_bl.c	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/video/backlight/mxc_pmic_bl.c	2009-01-24 22:01:10.000000000 +0100
@@ -54,7 +54,7 @@
 static int mxcbl_send_intensity(struct backlight_device *bd)
 {
 	int intensity = bd->props.brightness;
-	struct mxcbl_dev_data *devdata = class_get_devdata(&bd->class_dev);
+	struct mxcbl_dev_data *devdata = dev_get_drvdata(&bd->dev);
 
 	if (bd->props.power != FB_BLANK_UNBLANK)
 		intensity = 0;
@@ -70,7 +70,7 @@
 
 static int mxcbl_get_intensity(struct backlight_device *bd)
 {
-	struct mxcbl_dev_data *devdata = class_get_devdata(&bd->class_dev);
+	struct mxcbl_dev_data *devdata = dev_get_drvdata(&bd->dev);
 	return devdata->intensity;
 }
 
Index: linux-2.6.24/drivers/video/mxc/mx2fb.c
===================================================================
--- linux-2.6.24.orig/drivers/video/mxc/mx2fb.c	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/drivers/video/mxc/mx2fb.c	2009-01-24 22:01:10.000000000 +0100
@@ -1124,7 +1124,7 @@
 	/* Read to clear the status */
 	status = __raw_readl(LCDC_REG(LCDC_LISR));
 
-	if (request_irq(INT_LCDC, mx2fb_isr, 0, "LCDC", 0))
+	if (request_irq(MXC_INT_LCDC, mx2fb_isr, 0, "LCDC", 0))
 		pr_info("Request LCDC IRQ failed.\n");
 	else {
 		spin_lock_irqsave(&mx2fb_notifier_list.lock, flags);
@@ -1158,7 +1158,7 @@
 	/* Disable all LCDC interrupt */
 	__raw_writel(0x0, LCDC_REG(LCDC_LIER));
 
-	free_irq(INT_LCDC, 0);
+	free_irq(MXC_INT_LCDC, 0);
 }
 
 /*!
Index: linux-2.6.24/drivers/watchdog/mxc_wdt.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24/drivers/watchdog/mxc_wdt.c	2009-01-24 22:01:10.000000000 +0100
@@ -0,0 +1,385 @@
+/*
+ * linux/drivers/char/watchdog/mxc_wdt.c
+ *
+ * Watchdog driver for FSL MXC. It is based on omap1610_wdt.c
+ *
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * 2005 (c) MontaVista Software, Inc.  All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * History:
+ *
+ * 20051207: <AKuster@mvista.com>
+ *	     	Full rewrite based on
+ *		linux-2.6.15-rc5/drivers/char/watchdog/omap_wdt.c
+ *	     	Add platform resource support
+ *
+ */
+
+/*!
+ * @defgroup WDOG Watchdog Timer (WDOG) Driver
+ */
+/*!
+ * @file mxc_wdt.c
+ *
+ * @brief Watchdog timer driver
+ *
+ * @ingroup WDOG
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/reboot.h>
+#include <linux/smp_lock.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/moduleparam.h>
+#include <linux/clk.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+
+#include <asm/hardware.h>
+#include "mxc_wdt.h"
+#define DVR_VER "2.0"
+
+#define WDOG_SEC_TO_COUNT(s)  ((s * 2) << 8)
+#define WDOG_COUNT_TO_SEC(c)  ((c >> 8) / 2)
+
+static u32 wdt_base_reg;
+static int mxc_wdt_users;
+static struct clk *mxc_wdt_clk;
+
+static unsigned timer_margin = TIMER_MARGIN_DEFAULT;
+module_param(timer_margin, uint, 0);
+MODULE_PARM_DESC(timer_margin, "initial watchdog timeout (in seconds)");
+
+static unsigned dev_num = 0;
+
+static void mxc_wdt_ping(u32 base)
+{
+	/* issue the service sequence instructions */
+	__raw_writew(WDT_MAGIC_1, base + MXC_WDT_WSR);
+	__raw_writew(WDT_MAGIC_2, base + MXC_WDT_WSR);
+}
+
+static void mxc_wdt_config(u32 base)
+{
+	u16 val;
+
+	val = __raw_readw(base + MXC_WDT_WCR);
+	val |= 0xFF00 | WCR_WOE_BIT | WCR_WDA_BIT | WCR_SRS_BIT;
+	/* enable suspend WDT */
+	val |= WCR_WDZST_BIT | WCR_WDBG_BIT;
+	/* generate reset if wdog times out */
+	val &= ~WCR_WRE_BIT;
+
+	__raw_writew(val, base + MXC_WDT_WCR);
+}
+
+static void mxc_wdt_enable(u32 base)
+{
+	u16 val;
+
+	val = __raw_readw(base + MXC_WDT_WCR);
+	val |= WCR_WDE_BIT;
+	__raw_writew(val, base + MXC_WDT_WCR);
+}
+
+static void mxc_wdt_disable(u32 base)
+{
+	/* disable not supported by this chip */
+}
+
+static void mxc_wdt_adjust_timeout(unsigned new_timeout)
+{
+	if (new_timeout < TIMER_MARGIN_MIN)
+		new_timeout = TIMER_MARGIN_DEFAULT;
+	if (new_timeout > TIMER_MARGIN_MAX)
+		new_timeout = TIMER_MARGIN_MAX;
+	timer_margin = new_timeout;
+}
+
+static u16 mxc_wdt_get_timeout(u32 base)
+{
+	u16 val;
+
+	val = __raw_readw(base + MXC_WDT_WCR);
+	return WDOG_COUNT_TO_SEC(val);
+}
+
+static u16 mxc_wdt_get_bootreason(u32 base)
+{
+	u16 val;
+
+	val = __raw_readw(base + MXC_WDT_WRSR);
+	return val;
+}
+
+static void mxc_wdt_set_timeout(u32 base)
+{
+	u16 val;
+	val = __raw_readw(base + MXC_WDT_WCR);
+	val = (val & 0x00FF) | WDOG_SEC_TO_COUNT(timer_margin);
+	__raw_writew(val, base + MXC_WDT_WCR);
+	val = __raw_readw(base + MXC_WDT_WCR);
+	timer_margin = WDOG_COUNT_TO_SEC(val);
+}
+
+/*
+ *	Allow only one task to hold it open
+ */
+
+static int mxc_wdt_open(struct inode *inode, struct file *file)
+{
+
+	if (test_and_set_bit(1, (unsigned long *)&mxc_wdt_users))
+		return -EBUSY;
+
+	mxc_wdt_config(wdt_base_reg);
+	mxc_wdt_set_timeout(wdt_base_reg);
+	mxc_wdt_enable(wdt_base_reg);
+	mxc_wdt_ping(wdt_base_reg);
+
+	return 0;
+}
+
+static int mxc_wdt_release(struct inode *inode, struct file *file)
+{
+	/*
+	 *      Shut off the timer unless NOWAYOUT is defined.
+	 */
+#ifndef CONFIG_WATCHDOG_NOWAYOUT
+	mxc_wdt_disable(wdt_base_reg);
+
+#else
+	printk(KERN_CRIT "mxc_wdt: Unexpected close, not stopping!\n");
+#endif
+	mxc_wdt_users = 0;
+	return 0;
+}
+
+static ssize_t
+mxc_wdt_write(struct file *file, const char __user * data,
+	      size_t len, loff_t * ppos)
+{
+	/* Refresh LOAD_TIME. */
+	if (len)
+		mxc_wdt_ping(wdt_base_reg);
+	return len;
+}
+
+static int
+mxc_wdt_ioctl(struct inode *inode, struct file *file,
+	      unsigned int cmd, unsigned long arg)
+{
+	int new_margin;
+	int bootr;
+
+	static struct watchdog_info ident = {
+		.identity = "MXC Watchdog",
+		.options = WDIOF_SETTIMEOUT,
+		.firmware_version = 0,
+	};
+
+	switch (cmd) {
+	default:
+		return -ENOIOCTLCMD;
+	case WDIOC_GETSUPPORT:
+		return copy_to_user((struct watchdog_info __user *)arg, &ident,
+				    sizeof(ident));
+	case WDIOC_GETSTATUS:
+		return put_user(0, (int __user *)arg);
+	case WDIOC_GETBOOTSTATUS:
+		bootr = mxc_wdt_get_bootreason(wdt_base_reg);
+		return put_user(bootr, (int __user *)arg);
+	case WDIOC_KEEPALIVE:
+		mxc_wdt_ping(wdt_base_reg);
+		return 0;
+	case WDIOC_SETTIMEOUT:
+		if (get_user(new_margin, (int __user *)arg))
+			return -EFAULT;
+
+		mxc_wdt_adjust_timeout(new_margin);
+		mxc_wdt_disable(wdt_base_reg);
+		mxc_wdt_set_timeout(wdt_base_reg);
+		mxc_wdt_enable(wdt_base_reg);
+		mxc_wdt_ping(wdt_base_reg);
+		return 0;
+
+	case WDIOC_GETTIMEOUT:
+		mxc_wdt_ping(wdt_base_reg);
+		new_margin = mxc_wdt_get_timeout(wdt_base_reg);
+		return put_user(new_margin, (int __user *)arg);
+	}
+}
+
+static struct file_operations mxc_wdt_fops = {
+	.owner = THIS_MODULE,
+	.write = mxc_wdt_write,
+	.ioctl = mxc_wdt_ioctl,
+	.open = mxc_wdt_open,
+	.release = mxc_wdt_release,
+};
+
+static struct miscdevice mxc_wdt_miscdev = {
+	.minor = WATCHDOG_MINOR,
+	.name = "watchdog",
+	.fops = &mxc_wdt_fops
+};
+
+static int __init mxc_wdt_probe(struct platform_device *pdev)
+{
+	struct resource *res, *mem;
+	int ret;
+
+	/* reserve static register mappings */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, dev_num);
+	if (!res)
+		return -ENOENT;
+
+	mem = request_mem_region(res->start, res->end - res->start + 1,
+				 pdev->name);
+	if (mem == NULL)
+		return -EBUSY;
+
+	platform_set_drvdata(pdev, mem);
+
+	wdt_base_reg = IO_ADDRESS(res->start);
+	mxc_wdt_disable(wdt_base_reg);
+	mxc_wdt_adjust_timeout(timer_margin);
+
+	mxc_wdt_users = 0;
+
+	mxc_wdt_miscdev.this_device = &pdev->dev;
+
+	mxc_wdt_clk = clk_get(NULL, "wdog_clk");
+	clk_enable(mxc_wdt_clk);
+
+	ret = misc_register(&mxc_wdt_miscdev);
+	if (ret)
+		goto fail;
+
+	pr_info("MXC Watchdog # %d Timer: initial timeout %d sec\n", dev_num,
+		timer_margin);
+
+	return 0;
+
+      fail:
+	release_resource(mem);
+	pr_info("MXC Watchdog Probe failed\n");
+	return ret;
+}
+
+static void mxc_wdt_shutdown(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_drvdata(pdev);
+	mxc_wdt_disable(res->start);
+	pr_info("MXC Watchdog # %d shutdown\n", dev_num);
+}
+
+static int __exit mxc_wdt_remove(struct platform_device *pdev)
+{
+	struct resource *mem = platform_get_drvdata(pdev);
+	misc_deregister(&mxc_wdt_miscdev);
+	release_resource(mem);
+	pr_info("MXC Watchdog # %d removed\n", dev_num);
+	return 0;
+}
+
+#ifdef	CONFIG_PM
+
+/* REVISIT ... not clear this is the best way to handle system suspend; and
+ * it's very inappropriate for selective device suspend (e.g. suspending this
+ * through sysfs rather than by stopping the watchdog daemon).  Also, this
+ * may not play well enough with NOWAYOUT...
+ */
+
+static int mxc_wdt_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct resource *res = platform_get_drvdata(pdev);
+
+	if (mxc_wdt_users) {
+		mxc_wdt_disable(res->start);
+	}
+	return 0;
+}
+
+static int mxc_wdt_resume(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_drvdata(pdev);
+	if (mxc_wdt_users) {
+		mxc_wdt_enable(res->start);
+		mxc_wdt_ping(res->start);
+	}
+	return 0;
+}
+
+#else
+#define	mxc_wdt_suspend	NULL
+#define	mxc_wdt_resume		NULL
+#endif
+
+static struct platform_driver mxc_wdt_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "mxc_wdt",
+		   },
+	.probe = mxc_wdt_probe,
+	.shutdown = mxc_wdt_shutdown,
+	.remove = __exit_p(mxc_wdt_remove),
+	.suspend = mxc_wdt_suspend,
+	.resume = mxc_wdt_resume,
+};
+
+static int __init mxc_wdt_init(void)
+{
+	pr_info("MXC WatchDog Driver %s\n", DVR_VER);
+
+	if ((timer_margin < TIMER_MARGIN_MIN) ||
+	    (timer_margin > TIMER_MARGIN_MAX)) {
+		pr_info("MXC watchdog error. wrong timer_margin %d\n",
+			timer_margin);
+		pr_info("    Range: %d to %d seconds\n", TIMER_MARGIN_MIN,
+			TIMER_MARGIN_MAX);
+		return -EINVAL;
+	}
+
+	return platform_driver_register(&mxc_wdt_driver);
+}
+
+static void __exit mxc_wdt_exit(void)
+{
+	platform_driver_unregister(&mxc_wdt_driver);
+	pr_info("MXC WatchDog Driver removed\n");
+}
+
+module_init(mxc_wdt_init);
+module_exit(mxc_wdt_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
Index: linux-2.6.24/drivers/watchdog/mxc_wdt.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24/drivers/watchdog/mxc_wdt.h	2009-01-24 22:01:10.000000000 +0100
@@ -0,0 +1,37 @@
+/*
+ *  linux/drivers/char/watchdog/mxc_wdt.h
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *      MXC Watchdog timer register definitions
+ *
+ * Author: MontaVista Software, Inc.
+ *       <AKuster@mvista.com> or <source@mvista.com>
+ *
+ * 2005 (c) MontaVista Software, Inc.
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __MXC_WDT_H__
+#define __MXC_WDT_H__
+
+#define MXC_WDT_WCR             0x00
+#define MXC_WDT_WSR             0x02
+#define MXC_WDT_WRSR            0x04
+#define WCR_WOE_BIT             (1 << 6)
+#define WCR_WDA_BIT             (1 << 5)
+#define WCR_SRS_BIT             (1 << 4)
+#define WCR_WRE_BIT             (1 << 3)
+#define WCR_WDE_BIT             (1 << 2)
+#define WCR_WDBG_BIT            (1 << 1)
+#define WCR_WDZST_BIT           (1 << 0)
+#define WDT_MAGIC_1             0x5555
+#define WDT_MAGIC_2             0xAAAA
+
+#define TIMER_MARGIN_MAX    	127
+#define TIMER_MARGIN_DEFAULT	60	/* 60 secs */
+#define TIMER_MARGIN_MIN	1
+
+#endif				/* __MXC_WDT_H__ */
Index: linux-2.6.24/include/asm-arm/arch-mxc/arc_otg.h
===================================================================
--- linux-2.6.24.orig/include/asm-arm/arch-mxc/arc_otg.h	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/include/asm-arm/arch-mxc/arc_otg.h	2009-01-24 22:01:10.000000000 +0100
@@ -209,16 +209,6 @@
 #define  OTGSC_INTERRUPT_STATUS_BITS_MASK	OTGSC_IS_MASK
 #endif
 
-/* x_USBMODE */
-#define USBMODE_SDIS		(1 << 4)	/* stream disable mode */
-#define USBMODE_SLOM		(1 << 3)	/* setup lockout mode */
-#define USBMODE_ES		(1 << 2)	/* (big) endian select */
-#define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
-#define USBMODE_CM_HOST		(3 << 0)	/* host */
-#define USBMODE_CM_DEVICE	(2 << 0)	/* device */
-#define USBMODE_CM_reserved	(1 << 0)	/* reserved */
-#define USBMODE_CM_IDLE		(0 << 0)	/* idle */
-
 /* USBCTRL */
 #define UCTRL_OWIR		(1 << 31)	/* OTG wakeup intr request received */
 #define UCTRL_OSIC_MASK		(3 << 29)	/* OTG  Serial Interface Config: */
Index: linux-2.6.24/include/asm-arm/arch-mxc/dma.h
===================================================================
--- linux-2.6.24.orig/include/asm-arm/arch-mxc/dma.h	2009-01-24 21:59:19.000000000 +0100
+++ linux-2.6.24/include/asm-arm/arch-mxc/dma.h	2009-01-24 22:01:10.000000000 +0100
@@ -12,10 +12,244 @@
 #define __ASM_ARCH_MXC_DMA_H__
 
 /*!
- * @file dma.h
+ * @file arch-mxc/dma.h
  * @brief This file contains Unified DMA API for all MXC platforms.
  * The API is platform independent.
  *
  * @ingroup SDMA
  */
+#define MXC_DMA_DYNAMIC_CHANNEL   255
+
+#define MXC_DMA_DONE		  0x0
+#define MXC_DMA_REQUEST_TIMEOUT   0x1
+#define MXC_DMA_TRANSFER_ERROR    0x2
+
+/*! This defines the list of device ID's for DMA */
+typedef enum mxc_dma_device {
+	MXC_DMA_UART1_RX,
+	MXC_DMA_UART1_TX,
+	MXC_DMA_UART2_RX,
+	MXC_DMA_UART2_TX,
+	MXC_DMA_UART3_RX,
+	MXC_DMA_UART3_TX,
+	MXC_DMA_UART4_RX,
+	MXC_DMA_UART4_TX,
+	MXC_DMA_UART5_RX,
+	MXC_DMA_UART5_TX,
+	MXC_DMA_UART6_RX,
+	MXC_DMA_UART6_TX,
+	MXC_DMA_MMC1_WIDTH_1,
+	MXC_DMA_MMC1_WIDTH_4,
+	MXC_DMA_MMC2_WIDTH_1,
+	MXC_DMA_MMC2_WIDTH_4,
+	MXC_DMA_SSI1_8BIT_RX0,
+	MXC_DMA_SSI1_8BIT_TX0,
+	MXC_DMA_SSI1_16BIT_RX0,
+	MXC_DMA_SSI1_16BIT_TX0,
+	MXC_DMA_SSI1_24BIT_RX0,
+	MXC_DMA_SSI1_24BIT_TX0,
+	MXC_DMA_SSI1_8BIT_RX1,
+	MXC_DMA_SSI1_8BIT_TX1,
+	MXC_DMA_SSI1_16BIT_RX1,
+	MXC_DMA_SSI1_16BIT_TX1,
+	MXC_DMA_SSI1_24BIT_RX1,
+	MXC_DMA_SSI1_24BIT_TX1,
+	MXC_DMA_SSI2_8BIT_RX0,
+	MXC_DMA_SSI2_8BIT_TX0,
+	MXC_DMA_SSI2_16BIT_RX0,
+	MXC_DMA_SSI2_16BIT_TX0,
+	MXC_DMA_SSI2_24BIT_RX0,
+	MXC_DMA_SSI2_24BIT_TX0,
+	MXC_DMA_SSI2_8BIT_RX1,
+	MXC_DMA_SSI2_8BIT_TX1,
+	MXC_DMA_SSI2_16BIT_RX1,
+	MXC_DMA_SSI2_16BIT_TX1,
+	MXC_DMA_SSI2_24BIT_RX1,
+	MXC_DMA_SSI2_24BIT_TX1,
+	MXC_DMA_FIR_RX,
+	MXC_DMA_FIR_TX,
+	MXC_DMA_CSPI1_RX,
+	MXC_DMA_CSPI1_TX,
+	MXC_DMA_CSPI2_RX,
+	MXC_DMA_CSPI2_TX,
+	MXC_DMA_CSPI3_RX,
+	MXC_DMA_CSPI3_TX,
+	MXC_DMA_ATA_RX,
+	MXC_DMA_ATA_TX,
+	MXC_DMA_MEMORY,
+	MXC_DMA_DSP_PACKET_DATA0_RD,
+	MXC_DMA_DSP_PACKET_DATA0_WR,
+	MXC_DMA_DSP_PACKET_DATA1_RD,
+	MXC_DMA_DSP_PACKET_DATA1_WR,
+	MXC_DMA_DSP_LOG0_CHNL,
+	MXC_DMA_DSP_LOG1_CHNL,
+	MXC_DMA_DSP_LOG2_CHNL,
+	MXC_DMA_DSP_LOG3_CHNL,
+	MXC_DMA_CSI_RX,
+	MXC_DMA_TEST_RAM2D2RAM,
+	MXC_DMA_TEST_RAM2RAM2D,
+	MXC_DMA_TEST_RAM2D2RAM2D,
+	MXC_DMA_TEST_RAM2RAM,
+	MXC_DMA_TEST_HW_CHAINING,
+	MXC_DMA_TEST_SW_CHAINING
+} mxc_dma_device_t;
+
+/*! This defines the prototype of callback funtion registered by the drivers */
+typedef void (*mxc_dma_callback_t) (void *arg, int error_status,
+				    unsigned int count);
+
+/*! This defines the type of DMA transfer requested */
+typedef enum mxc_dma_mode {
+	MXC_DMA_MODE_READ,
+	MXC_DMA_MODE_WRITE,
+} mxc_dma_mode_t;
+
+/*! This defines the DMA channel parameters */
+typedef struct mxc_dma_channel {
+	unsigned int active:1;	/*!< When there has a active tranfer, it is set to 1 */
+	unsigned int lock;	/*!< Defines the channel is allocated or not */
+	int curr_buf;		/*!< Current buffer */
+	mxc_dma_mode_t mode;	/*!< Read or Write */
+	unsigned int channel;	/*!< Channel info */
+	unsigned int dynamic:1;	/*!< Channel not statically allocated when 1 */
+	char *dev_name;		/*!< Device name */
+	void *private;		/*!< Private structure for platform */
+	mxc_dma_callback_t cb_fn;	/*!< The callback function */
+	void *cb_args;		/*!< The argument of callback function */
+} mxc_dma_channel_t;
+
+/*! This structure contains the information about a dma transfer */
+typedef struct mxc_dma_requestbuf {
+	dma_addr_t src_addr;	/*!< source address */
+	dma_addr_t dst_addr;	/*!< destination address */
+	int num_of_bytes;	/*!< the length of this transfer : bytes */
+} mxc_dma_requestbuf_t;
+
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX21)
+#include <asm/arch/mx2_dma.h>
+#else
+#include <asm/arch/sdma.h>
+#endif
+
+/*!
+ * This function is generally called by the driver at open time.
+ * The DMA driver would do any initialization steps that is required
+ * to get the channel ready for data transfer.
+ *
+ * @param channel_id   a pre-defined id. The peripheral driver would specify
+ *                     the id associated with its peripheral. This would be
+ *                     used by the DMA driver to identify the peripheral
+ *                     requesting DMA and do the necessary setup on the
+ *                     channel associated with the particular peripheral.
+ *                     The DMA driver could use static or dynamic DMA channel
+ *                     allocation.
+ * @param dev_name     module name or device name
+ * @return returns a negative number on error if request for a DMA channel did not
+ *         succeed, returns the channel number to be used on success.
+ */
+extern int mxc_dma_request(mxc_dma_device_t channel_id, char *dev_name);
+
+/*!
+ * This function is generally called by the driver at close time. The DMA
+ * driver would do any cleanup associated with this channel.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_free(int channel_num);
+
+/*!
+ * This function would just configure the buffers specified by the user into
+ * dma channel. The caller must call mxc_dma_enable to start this transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param dma_buf      an array of physical addresses to the user defined
+ *                     buffers. The caller must guarantee the dma_buf is
+ *                     available until the transfer is completed.
+ * @param num_buf      number of buffers in the array
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could not be
+ *         added with DMA for transfer. On Success, it returns 0
+ */
+extern int mxc_dma_config(int channel_num, mxc_dma_requestbuf_t * dma_buf,
+			  int num_buf, mxc_dma_mode_t mode);
+
+/*!
+ * This function would just configure the scatterlist specified by the
+ * user into dma channel. This is a slight variation of mxc_dma_config(),
+ * it is provided for the convenience of drivers that have a scatterlist
+ * passed into them. It is the calling driver's responsibility to have the
+ * correct physical address filled in the "dma_address" field of the
+ * scatterlist.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param sg           a scatterlist of buffers. The caller must guarantee
+ *                     the dma_buf is available until the transfer is
+ *                     completed.
+ * @param num_buf      number of buffers in the array
+ * @param num_of_bytes total number of bytes to transfer. If set to 0, this
+ *                     would imply to use the length field of the scatterlist
+ *                     for each DMA transfer. Else it would calculate the size
+ *                     for each DMA transfer.
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could not
+ *         be added with DMA for transfer. On Success, it returns 0
+ */
+extern int mxc_dma_sg_config(int channel_num, struct scatterlist *sg,
+			     int num_buf, int num_of_bytes,
+			     mxc_dma_mode_t mode);
+
+/*!
+ * This function is provided if the driver would like to set/change its
+ * callback function.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param callback     a callback function to provide notification on transfer
+ *                     completion, user could specify NULL if he does not wish
+ *                     to be notified
+ * @param arg          an argument that gets passed in to the callback
+ *                     function, used by the user to do any driver specific
+ *                     operations.
+ * @return this function returns a negative number on error if the callback
+ *         could not be set for the channel or 0 on success
+ */
+extern int mxc_dma_callback_set(int channel_num, mxc_dma_callback_t callback,
+				void *arg);
+
+/*!
+ * This stops the DMA channel and any ongoing transfers. Subsequent use of
+ * mxc_dma_enable() will restart the channel and restart the transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_disable(int channel_num);
+
+/*!
+ * This starts DMA transfer. Or it restarts DMA on a stopped channel
+ * previously stopped with mxc_dma_disable().
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_enable(int channel_num);
+
 #endif
Index: linux-2.6.24/include/asm-arm/arch-mxc/entry-macro.S
===================================================================
--- linux-2.6.24.orig/include/asm-arm/arch-mxc/entry-macro.S	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/include/asm-arm/arch-mxc/entry-macro.S	2009-01-24 22:01:10.000000000 +0100
@@ -9,6 +9,8 @@
  * published by the Free Software Foundation.
  */
 
+#include <asm/hardware.h>
+
 	@ this macro disables fast irq (not implemented)
 	.macro	disable_fiq
 	.endm
Index: linux-2.6.24/include/asm-arm/arch-mxc/fsl_usb.h
===================================================================
--- linux-2.6.24.orig/include/asm-arm/arch-mxc/fsl_usb.h	2009-01-24 22:01:09.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,42 +0,0 @@
-/*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-#include <asm/arch/arc_otg.h>
-
-/* ehci_arc_hc_driver.flags value */
-#define FSL_PLATFORM_HC_FLAGS (HCD_USB2 | HCD_MEMORY)
-
-static inline int fsl_platform_verify(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static inline void fsl_platform_usb_setup(struct usb_hcd *hcd)
-{
-}
-
-static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
-{
-	unsigned int temp;
-	struct fsl_usb2_platform_data *pdata;
-
-	pdata =
-	    (struct fsl_usb2_platform_data *)hcd->self.controller->
-	    platform_data;
-
-	if (pdata->xcvr_ops && pdata->xcvr_ops->set_host)
-		pdata->xcvr_ops->set_host();
-
-	/* set host mode */
-	temp = readl(hcd->regs + 0x1a8);
-	writel(temp | USBMODE_CM_HOST, hcd->regs + 0x1a8);
-}
Index: linux-2.6.24/include/asm-arm/arch-mxc/irqs.h
===================================================================
--- linux-2.6.24.orig/include/asm-arm/arch-mxc/irqs.h	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/include/asm-arm/arch-mxc/irqs.h	2009-01-24 22:01:10.000000000 +0100
@@ -29,8 +29,8 @@
 
 #define MXC_IRQ_TO_EXPIO(irq)	(irq - MXC_EXP_IO_BASE)
 
-#define MXC_IRQ_TO_GPIO(irq)	(irq - MXC_GPIO_BASE)
-#define MXC_GPIO_TO_IRQ(x)	(MXC_GPIO_BASE + x)
+#define MXC_IRQ_TO_GPIO(irq)	(irq - MXC_GPIO_INT_BASE)
+#define MXC_GPIO_TO_IRQ(x)	(MXC_GPIO_INT_BASE + x)
 
 /*!
  * Number of normal interrupts
Index: linux-2.6.24/include/asm-arm/arch-mxc/mx21.h
===================================================================
--- linux-2.6.24.orig/include/asm-arm/arch-mxc/mx21.h	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/include/asm-arm/arch-mxc/mx21.h	2009-01-24 22:01:10.000000000 +0100
@@ -188,61 +188,61 @@
 /*
  *  MX21 ADS Interrupt numbers
  */
-#define INT_CSPI3 	            6
-#define INT_GPIO                    8
-#define INT_FIRI                    9
-#define INT_SDHC2                   10
-#define INT_SDHC1                   11
-#define INT_I2C                     12
-#define INT_SSI2                    13
-#define INT_SSI1                    14
-#define INT_CSPI2                   15
-#define INT_CSPI1              	    16
-#define INT_UART4                   17
-#define INT_UART3                   18
-#define INT_UART2                   19
-#define INT_UART1                   20
-#define INT_KPP                     21
-#define INT_RTC		            22
-#define INT_PWM                     23
-#define INT_GPT3                    24
-#define INT_GPT2                    25
-#define INT_GPT1                    26
-#define INT_GPT                     INT_GPT1
-#define INT_WDOG                    27
-#define INT_PCMCIA                  28
-#define INT_NANDFC                  29
-#define INT_BMI                     30
-#define INT_CSI                     31
-#define INT_DMACH0                  32
-#define INT_DMACH1                  33
-#define INT_DMACH2                  34
-#define INT_DMACH3                  35
-#define INT_DMACH4                  36
-#define INT_DMACH5                  37
-#define INT_DMACH6                  38
-#define INT_DMACH7                  39
-#define INT_DMACH8                  40
-#define INT_DMACH9                  41
-#define INT_DMACH10                 42
-#define INT_DMACH11                 43
-#define INT_DMACH12                 44
-#define INT_DMACH13                 45
-#define INT_DMACH14                 46
-#define INT_DMACH15                 47
-#define INT_EMMAENC                 49
-#define INT_EMMADEC                 50
-#define INT_EMMAPRP                 51
-#define INT_EMMAPP                  52
-#define INT_USBWKUP                 53
-#define INT_USBDMA                  54
-#define INT_USBHOST                 55
-#define INT_USBFUNC                 56
-#define INT_USBHNP                  57
-#define INT_USBCTRL                 58
-#define INT_SAHARA                  59
-#define INT_SLCDC                   60
-#define INT_LCDC                    61
+#define MXC_INT_CSPI3 	            6
+#define MXC_INT_GPIO                    8
+#define MXC_INT_FIRI                    9
+#define MXC_INT_SDHC2                   10
+#define MXC_INT_SDHC1                   11
+#define MXC_INT_I2C                     12
+#define MXC_INT_SSI2                    13
+#define MXC_INT_SSI1                    14
+#define MXC_INT_CSPI2                   15
+#define MXC_INT_CSPI1              	    16
+#define MXC_INT_UART4                   17
+#define MXC_INT_UART3                   18
+#define MXC_INT_UART2                   19
+#define MXC_INT_UART1                   20
+#define MXC_INT_KPP                     21
+#define MXC_INT_RTC		            22
+#define MXC_INT_PWM                     23
+#define MXC_INT_GPT3                    24
+#define MXC_INT_GPT2                    25
+#define MXC_INT_GPT1                    26
+#define MXC_INT_GPT                     INT_GPT1
+#define MXC_INT_WDOG                    27
+#define MXC_INT_PCMCIA                  28
+#define MXC_INT_NANDFC                  29
+#define MXC_INT_BMI                     30
+#define MXC_INT_CSI                     31
+#define MXC_INT_DMACH0                  32
+#define MXC_INT_DMACH1                  33
+#define MXC_INT_DMACH2                  34
+#define MXC_INT_DMACH3                  35
+#define MXC_INT_DMACH4                  36
+#define MXC_INT_DMACH5                  37
+#define MXC_INT_DMACH6                  38
+#define MXC_INT_DMACH7                  39
+#define MXC_INT_DMACH8                  40
+#define MXC_INT_DMACH9                  41
+#define MXC_INT_DMACH10                 42
+#define MXC_INT_DMACH11                 43
+#define MXC_INT_DMACH12                 44
+#define MXC_INT_DMACH13                 45
+#define MXC_INT_DMACH14                 46
+#define MXC_INT_DMACH15                 47
+#define MXC_INT_EMMAENC                 49
+#define MXC_INT_EMMADEC                 50
+#define MXC_INT_EMMAPRP                 51
+#define MXC_INT_EMMAPP                  52
+#define MXC_INT_USBWKUP                 53
+#define MXC_INT_USBDMA                  54
+#define MXC_INT_USBHOST                 55
+#define MXC_INT_USBFUNC                 56
+#define MXC_INT_USBHNP                  57
+#define MXC_INT_USBCTRL                 58
+#define MXC_INT_SAHARA                  59
+#define MXC_INT_SLCDC                   60
+#define MXC_INT_LCDC                    61
 
 #define MXC_MAX_INT_LINES       64
 #define MXC_MAX_EXT_LINES       0
Index: linux-2.6.24/include/asm-arm/arch-mxc/mx27.h
===================================================================
--- linux-2.6.24.orig/include/asm-arm/arch-mxc/mx27.h	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/include/asm-arm/arch-mxc/mx27.h	2009-01-24 22:01:10.000000000 +0100
@@ -65,7 +65,7 @@
  *  Register offests.
  */
 #define AIPI_BASE_ADDR          0x10000000
-#define AIPI_BASE_ADDR_VIRT     0xD4000000
+#define AIPI_BASE_ADDR_VIRT     0xFC000000
 #define AIPI_SIZE               SZ_1M
 
 #define DMA_BASE_ADDR           (AIPI_BASE_ADDR + 0x01000)
@@ -130,7 +130,7 @@
 #define AVIC_BASE_ADDR          0x10040000
 
 #define SAHB1_BASE_ADDR         0x80000000
-#define SAHB1_BASE_ADDR_VIRT    0xD4100000
+#define SAHB1_BASE_ADDR_VIRT    0xFC100000
 #define SAHB1_SIZE              SZ_1M
 
 #define CSI_BASE_ADDR           (SAHB1_BASE_ADDR + 0x0000)
@@ -140,7 +140,7 @@
  * NAND, SDRAM, WEIM, M3IF, EMI controllers
  */
 #define X_MEMC_BASE_ADDR        0xD8000000
-#define X_MEMC_BASE_ADDR_VIRT   0xD4200000
+#define X_MEMC_BASE_ADDR_VIRT   0xFC200000
 #define X_MEMC_SIZE             SZ_1M
 
 #define NFC_BASE_ADDR           (X_MEMC_BASE_ADDR)
@@ -160,7 +160,7 @@
 #define CS2_BASE_ADDR           0xD0000000
 #define CS3_BASE_ADDR           0xD2000000
 #define CS4_BASE_ADDR           0xD4000000
-#define CS4_BASE_ADDR_VIRT      0xEB000000
+#define CS4_BASE_ADDR_VIRT      0xF4000000
 #define CS4_SIZE                SZ_1M
 #define CS5_BASE_ADDR           0xD6000000
 #define PCMCIA_MEM_BASE_ADDR    0xDC000000
@@ -204,76 +204,76 @@
 /*
  *  MX27 ADS Interrupt numbers
  */
-#define INT_CCM                 63
-#define INT_IIM                 62
-#define INT_LCDC                61
-#define INT_SLCDC               60
-#define INT_SAHARA              59
-#define INT_SCC_SCM             58
-#define INT_SCC_SMN             57
-#define INT_USB3                56
-#define INT_USB2                55
-#define INT_USB1                54
-#define INT_VPU                53
-#define INT_EMMAPP              52
-#define INT_EMMAPRP             51
-#define INT_FEC                 50
-#define INT_UART5               49
-#define INT_UART6               48
-#define INT_DMACH15             47
-#define INT_DMACH14             46
-#define INT_DMACH13             45
-#define INT_DMACH12             44
-#define INT_DMACH11             43
-#define INT_DMACH10             42
-#define INT_DMACH9              41
-#define INT_DMACH8              40
-#define INT_DMACH7              39
-#define INT_DMACH6              38
-#define INT_DMACH5              37
-#define INT_DMACH4              36
-#define INT_DMACH3              35
-#define INT_DMACH2              34
-#define INT_DMACH1              33
-#define INT_DMACH0              32
-#define INT_CSI                 31
-#define INT_ATA                 30
-#define INT_NANDFC              29
-#define INT_PCMCIA              28
-#define INT_WDOG                27
-#define INT_GPT1                26
-#define INT_GPT2                25
-#define INT_GPT3                24
-#define INT_GPT                 INT_GPT1
-#define INT_PWM                 23
-#define INT_RTC                 22
-#define INT_KPP                 21
-#define INT_UART1               20
-#define INT_UART2               19
-#define INT_UART3               18
-#define INT_UART4               17
-#define INT_CSPI1               16
-#define INT_CSPI2               15
-#define INT_SSI1                14
-#define INT_SSI2                13
-#define INT_I2C                 12
-#define INT_SDHC1               11
-#define INT_SDHC2               10
-#define INT_SDHC3               9
-#define INT_GPIO                8
-#define INT_SDHC                7
-#define INT_CSPI3               6
-#define INT_RTIC                5
-#define INT_GPT4                4
-#define INT_GPT5                3
-#define INT_GPT6                2
-#define INT_I2C2                1
+#define MXC_INT_CCM                 63
+#define MXC_INT_IIM                 62
+#define MXC_INT_LCDC                61
+#define MXC_INT_SLCDC               60
+#define MXC_INT_SAHARA              59
+#define MXC_INT_SCC_SCM             58
+#define MXC_INT_SCC_SMN             57
+#define MXC_INT_USB3                56
+#define MXC_INT_USB2                55
+#define MXC_INT_USB1                54
+#define MXC_INT_VPU                53
+#define MXC_INT_EMMAPP              52
+#define MXC_INT_EMMAPRP             51
+#define MXC_INT_FEC                 50
+#define MXC_INT_UART5               49
+#define MXC_INT_UART6               48
+#define MXC_INT_DMACH15             47
+#define MXC_INT_DMACH14             46
+#define MXC_INT_DMACH13             45
+#define MXC_INT_DMACH12             44
+#define MXC_INT_DMACH11             43
+#define MXC_INT_DMACH10             42
+#define MXC_INT_DMACH9              41
+#define MXC_INT_DMACH8              40
+#define MXC_INT_DMACH7              39
+#define MXC_INT_DMACH6              38
+#define MXC_INT_DMACH5              37
+#define MXC_INT_DMACH4              36
+#define MXC_INT_DMACH3              35
+#define MXC_INT_DMACH2              34
+#define MXC_INT_DMACH1              33
+#define MXC_INT_DMACH0              32
+#define MXC_INT_CSI                 31
+#define MXC_INT_ATA                 30
+#define MXC_INT_NANDFC              29
+#define MXC_INT_PCMCIA              28
+#define MXC_INT_WDOG                27
+#define MXC_INT_GPT1                26
+#define MXC_INT_GPT2                25
+#define MXC_INT_GPT3                24
+#define MXC_INT_GPT                 MXC_INT_GPT1
+#define MXC_INT_PWM                 23
+#define MXC_INT_RTC                 22
+#define MXC_INT_KPP                 21
+#define MXC_INT_UART1               20
+#define MXC_INT_UART2               19
+#define MXC_INT_UART3               18
+#define MXC_INT_UART4               17
+#define MXC_INT_CSPI1               16
+#define MXC_INT_CSPI2               15
+#define MXC_INT_SSI1                14
+#define MXC_INT_SSI2                13
+#define MXC_INT_I2C                 12
+#define MXC_INT_SDHC1               11
+#define MXC_INT_SDHC2               10
+#define MXC_INT_SDHC3               9
+#define MXC_INT_GPIO                8
+#define MXC_INT_SDHC                7
+#define MXC_INT_CSPI3               6
+#define MXC_INT_RTIC                5
+#define MXC_INT_GPT4                4
+#define MXC_INT_GPT5                3
+#define MXC_INT_GPT6                2
+#define MXC_INT_I2C2                1
 
 #define MXC_MAX_INT_LINES       64
 #define MXC_MAX_EXT_LINES       0
 
 #define MXC_MUX_GPIO_INTERRUPTS 1
-#define MXC_GPIO_BASE           (MXC_MAX_INT_LINES)
+#define MXC_GPIO_INT_BASE	(MXC_MAX_INT_LINES)
 
 /*!
  * Number of GPIO port as defined in the IC Spec
@@ -335,10 +335,4 @@
 
 #define NFMS_BIT 5
 
-/*
- * GPT clock source mask and offset bit definition
- */
-#define GPT_CTRL_MASK           0xFFFFFFF1
-#define GPT_CTRL_OFFSET	    	1
-
 #endif				/* __ASM_ARCH_MXC_MX27_H__ */
Index: linux-2.6.24/include/asm-arm/arch-mxc/mx31.h
===================================================================
--- linux-2.6.24.orig/include/asm-arm/arch-mxc/mx31.h	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/include/asm-arm/arch-mxc/mx31.h	2009-01-24 22:01:10.000000000 +0100
@@ -377,7 +377,7 @@
 #define MXC_INT_IIM		19
 #define MXC_INT_SIM2		20
 #define MXC_INT_SIM1		21
-#define MXC_INT_RNGA		22
+#define MXC_INT_RNG		22
 #define MXC_INT_EVTMON		23
 #define MXC_INT_KPP		24
 #define MXC_INT_RTC		25
@@ -427,7 +427,7 @@
 /*!
  * Interrupt Number for ARM11 PMU
  */
-#define ARM11_PMU_IRQ		INT_EVTMON
+#define ARM11_PMU_IRQ		MXC_INT_EVTMON
 
 /*!
  * Number of GPIO port as defined in the IC Spec
Index: linux-2.6.24/include/asm-arm/arch-mxc/mxc.h
===================================================================
--- linux-2.6.24.orig/include/asm-arm/arch-mxc/mxc.h	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/include/asm-arm/arch-mxc/mxc.h	2009-01-24 22:01:10.000000000 +0100
@@ -92,7 +92,7 @@
 #endif				/* __ASSEMBLY__ */
 
 #define IOMUX_TO_GPIO(pin) 	((((unsigned int)pin >> MUX_IO_P) * GPIO_NUM_PIN) + ((pin >> MUX_IO_I) & ((1 << (MUX_IO_P - MUX_IO_I)) -1)))
-#define IOMUX_TO_IRQ(pin)	(MXC_GPIO_BASE + IOMUX_TO_GPIO(pin))
+#define IOMUX_TO_IRQ(pin)	(MXC_GPIO_INT_BASE + IOMUX_TO_GPIO(pin))
 #define GPIO_TO_PORT(n)		(n / GPIO_NUM_PIN)
 #define GPIO_TO_INDEX(n)	(n % GPIO_NUM_PIN)
 
Index: linux-2.6.24/include/asm-arm/arch-mxc/mxc91321.h
===================================================================
--- linux-2.6.24.orig/include/asm-arm/arch-mxc/mxc91321.h	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/include/asm-arm/arch-mxc/mxc91321.h	2009-01-24 22:01:10.000000000 +0100
@@ -26,7 +26,7 @@
  * @ingroup MSL_MXC91321
  */
 /*!
- * defines the OS clock tick rate
+ * defines the hardware clock tick rate
  */
 #define CLOCK_TICK_RATE         16625000
 
@@ -59,7 +59,7 @@
  * IRAM
  */
 #define IRAM_BASE_ADDR          0x1FFFC000
-#define IRAM_BASE_ADDR_VIRT     0xD0000000
+#define IRAM_BASE_ADDR_VIRT     0xF8000000
 #define IRAM_SIZE               SZ_16K
 
 /*
@@ -71,22 +71,23 @@
  * SMC
  */
 #define SMC_BASE_ADDR          0x40000000
-#define SMC_BASE_ADDR_VIRT     0xD2000000
+#define SMC_BASE_ADDR_VIRT     0xF5000000
 #define SMC_SIZE               SZ_16M
 
 /*
  * SiRF
  */
 #define SIRF_BASE_ADDR          0x42000000
-#define SIRF_BASE_ADDR_VIRT     0xD3000000
+#define SIRF_BASE_ADDR_VIRT     0xF6000000
 #define SIRF_SIZE               SZ_16M
 
 /*
  * AIPS 1
  */
 #define AIPS1_BASE_ADDR         0x43F00000
-#define AIPS1_BASE_ADDR_VIRT    0xD4000000
+#define AIPS1_BASE_ADDR_VIRT    0xFC000000
 #define AIPS1_SIZE              SZ_1M
+
 #define MAX_BASE_ADDR           0x43F04000
 #define EVTMON_BASE_ADDR        0x43F08000
 #define CLKCTL_BASE_ADDR        0x43F0C000
@@ -107,7 +108,7 @@
  * SPBA
  */
 #define SPBA0_BASE_ADDR         0x50000000
-#define SPBA0_BASE_ADDR_VIRT    0xD4100000
+#define SPBA0_BASE_ADDR_VIRT    0xFC100000
 #define SPBA0_SIZE              SZ_1M
 #define IOMUXC_BASE_ADDR        0x50000000
 #define MMC_SDHC1_BASE_ADDR     0x50004000
@@ -185,7 +186,7 @@
  * AIPS 2
  */
 #define AIPS2_BASE_ADDR         0x53F00000
-#define AIPS2_BASE_ADDR_VIRT    0xD4200000
+#define AIPS2_BASE_ADDR_VIRT    0xFC200000
 #define AIPS2_SIZE              SZ_1M
 #define CRM_MCU_BASE_ADDR       0x53F80000
 #define ECT_MCU_CTI_BASE_ADDR   0x53F84000
@@ -211,18 +212,18 @@
  * ROMP and AVIC
  */
 #define ROMP_BASE_ADDR          0x60000000
-#define ROMP_BASE_ADDR_VIRT     0xD4300000
+#define ROMP_BASE_ADDR_VIRT     0xFC500000
 #define ROMP_SIZE               SZ_1M
 
 #define AVIC_BASE_ADDR          0x68000000
-#define AVIC_BASE_ADDR_VIRT     0xD4400000
+#define AVIC_BASE_ADDR_VIRT     0xFC400000
 #define AVIC_SIZE               SZ_1M
 
 /*
  * NAND, SDRAM, WEIM, M3IF, EMI controllers
  */
 #define X_MEMC_BASE_ADDR        0xB8000000
-#define X_MEMC_BASE_ADDR_VIRT   0xD4500000
+#define X_MEMC_BASE_ADDR_VIRT   0xFC600000
 #define X_MEMC_SIZE             SZ_1M
 
 #define NFC_BASE_ADDR           X_MEMC_BASE_ADDR
@@ -239,11 +240,9 @@
 #define CS0_BASE_ADDR           0xA0000000
 #define CS1_BASE_ADDR           0xA8000000
 #define CS2_BASE_ADDR           0xB0000000
-#define CS2_BASE_ADDR_VIRT      0xEA000000
-#define CS2_SIZE                SZ_16M
 #define CS3_BASE_ADDR           0xB2000000
 #define CS4_BASE_ADDR           0xB4000000
-#define CS4_BASE_ADDR_VIRT      0xEB000000
+#define CS4_BASE_ADDR_VIRT      0xF4000000
 #define CS4_SIZE                SZ_16M
 #define CS5_BASE_ADDR           0xB6000000
 
@@ -262,7 +261,6 @@
         ((x >= AIPS2_BASE_ADDR) && (x < (AIPS2_BASE_ADDR + AIPS2_SIZE))) ? AIPS2_IO_ADDRESS(x):\
         ((x >= ROMP_BASE_ADDR) && (x < (ROMP_BASE_ADDR + ROMP_SIZE))) ? ROMP_IO_ADDRESS(x):\
         ((x >= AVIC_BASE_ADDR) && (x < (AVIC_BASE_ADDR + AVIC_SIZE))) ? AVIC_IO_ADDRESS(x):\
-        ((x >= CS2_BASE_ADDR) && (x < (CS2_BASE_ADDR + CS2_SIZE))) ? CS2_IO_ADDRESS(x):\
         ((x >= CS4_BASE_ADDR) && (x < (CS4_BASE_ADDR + CS4_SIZE))) ? CS4_IO_ADDRESS(x):\
         ((x >= X_MEMC_BASE_ADDR) && (x < (X_MEMC_BASE_ADDR + X_MEMC_SIZE))) ? X_MEMC_IO_ADDRESS(x):\
         0xDEADBEEF)
@@ -295,9 +293,6 @@
 #define AVIC_IO_ADDRESS(x)  \
         (((x) - AVIC_BASE_ADDR) + AVIC_BASE_ADDR_VIRT)
 
-#define CS2_IO_ADDRESS(x)   \
-        (((x) - CS2_BASE_ADDR) + CS2_BASE_ADDR_VIRT)
-
 #define CS4_IO_ADDRESS(x)   \
         (((x) - CS4_BASE_ADDR) + CS4_BASE_ADDR_VIRT)
 
@@ -345,77 +340,77 @@
 /*
  * Interrupt numbers
  */
-#define INT_RESV0               0
-#define INT_GEM                 1
-#define INT_HAC                 2
-#define INT_SAHARA              2
-#define INT_MU3                 3
-#define INT_MU2                 4
-#define INT_MU1                 5
-#define INT_MU0                 6
-#define INT_ELIT2               7
-#define INT_MMC_SDHC2           8
-#define INT_MMC_SDHC1           9
-#define INT_I2C                 10
-#define INT_SSI2                11
-#define INT_SSI1                12
-#define INT_CSPI2               13
-#define INT_CSPI1               14
-#define INT_EXT_INT7            15
-#define INT_UART3               16
-#define INT_RESV17              17
-#define INT_CCM_MCU_DVFS        17
-#define INT_RESV18              18
-#define INT_ECT                 19
-#define INT_SIM_DATA            20
-#define INT_SIM_GENERAL         21
-#define INT_RNGA                22
-#define INT_RTR                 23
-#define INT_KPP                 24
-#define INT_RTC                 25
-#define INT_PWM                 26
-#define INT_EPIT2               27
-#define INT_EPIT1               28
-#define INT_GPT                 29
-#define INT_UART2               30
-#define INT_DVFS                31
-#define INT_RESV32              32
-#define INT_NANDFC              33
-#define INT_SDMA                34
-#define INT_USBOTG_GRP_ASYNC    35
-#define INT_USBOTG_MNP          36
-#define INT_USBOTG_HOST         37
-#define INT_USBOTG_FUNC         38
-#define INT_USBOTG_DMA          39
-#define INT_USBOTG_CTRL         40
-#define INT_ELIT1               41
-#define INT_IPU                 42
-#define INT_UART1               43
-#define INT_RESV44              44
-#define INT_RESV45              45
-#define INT_IIM                 46
-#define INT_MU_RX_OR            47
-#define INT_MU_TX_OR            48
-#define INT_SCC_SCM             49
-#define INT_EXT_INT6            50
-#define INT_GPIOMCU             51
-#define INT_GPIO1               INT_GPIOMCU
-#define INT_GPIOSDMA            52
-#define INT_GPIO2               INT_GPIOSDMA
-#define INT_CCM                 53
-#define INT_UART4_FIRI_OR       54
-#define INT_WDOG2               55
-#define INT_SIRF_EXT_INT5_OR    56
-#define INT_EXT_INT5            56
-#define INT_SIRF_EXT_INT4_OR    57
-#define INT_EXT_INT4            57
-#define INT_EXT_INT3            58
-#define INT_RTIC                59
-#define INT_MPEG4_ENC           60
-#define INT_HANTRO              60
-#define INT_EXT_INT0            61
-#define INT_EXT_INT1            62
-#define INT_EXT_INT2            63
+#define MXC_INT_RESV0               0
+#define MXC_INT_GEM                 1
+#define MXC_INT_HAC                 2
+#define MXC_INT_SAHARA              2
+#define MXC_INT_MU3                 3
+#define MXC_INT_MU2                 4
+#define MXC_INT_MU1                 5
+#define MXC_INT_MU0                 6
+#define MXC_INT_ELIT2               7
+#define MXC_INT_MMC_SDHC2           8
+#define MXC_INT_MMC_SDHC1           9
+#define MXC_INT_I2C                 10
+#define MXC_INT_SSI2                11
+#define MXC_INT_SSI1                12
+#define MXC_INT_CSPI2               13
+#define MXC_INT_CSPI1               14
+#define MXC_INT_EXT_INT7            15
+#define MXC_INT_UART3               16
+#define MXC_INT_RESV17              17
+#define MXC_INT_CCM_MCU_DVFS        17
+#define MXC_INT_RESV18              18
+#define MXC_INT_ECT                 19
+#define MXC_INT_SIM_DATA            20
+#define MXC_INT_SIM_GENERAL         21
+#define MXC_INT_RNGA                22
+#define MXC_INT_RTR                 23
+#define MXC_INT_KPP                 24
+#define MXC_INT_RTC                 25
+#define MXC_INT_PWM                 26
+#define MXC_INT_EPIT2               27
+#define MXC_INT_EPIT1               28
+#define MXC_INT_GPT                 29
+#define MXC_INT_UART2               30
+#define MXC_INT_DVFS                31
+#define MXC_INT_RESV32              32
+#define MXC_INT_NANDFC              33
+#define MXC_INT_SDMA                34
+#define MXC_INT_USBOTG_GRP_ASYNC    35
+#define MXC_INT_USBOTG_MNP          36
+#define MXC_INT_USBOTG_HOST         37
+#define MXC_INT_USBOTG_FUNC         38
+#define MXC_INT_USBOTG_DMA          39
+#define MXC_INT_USBOTG_CTRL         40
+#define MXC_INT_ELIT1               41
+#define MXC_INT_IPU                 42
+#define MXC_INT_UART1               43
+#define MXC_INT_RESV44              44
+#define MXC_INT_RESV45              45
+#define MXC_INT_IIM                 46
+#define MXC_INT_MU_RX_OR            47
+#define MXC_INT_MU_TX_OR            48
+#define MXC_INT_SCC_SCM             49
+#define MXC_INT_EXT_INT6            50
+#define MXC_INT_GPIOMCU             51
+#define MXC_INT_GPIO1               MXC_INT_GPIOMCU
+#define MXC_INT_GPIOSDMA            52
+#define MXC_INT_GPIO2               MXC_INT_GPIOSDMA
+#define MXC_INT_CCM                 53
+#define MXC_INT_UART4_FIRI_OR       54
+#define MXC_INT_WDOG2               55
+#define MXC_INT_SIRF_EXT_INT5_OR    56
+#define MXC_INT_EXT_INT5            56
+#define MXC_INT_SIRF_EXT_INT4_OR    57
+#define MXC_INT_EXT_INT4            57
+#define MXC_INT_EXT_INT3            58
+#define MXC_INT_RTIC                59
+#define MXC_INT_MPEG4_ENC           60
+#define MXC_INT_HANTRO              60
+#define MXC_INT_EXT_INT0            61
+#define MXC_INT_EXT_INT1            62
+#define MXC_INT_EXT_INT2            63
 
 #define MXC_MAX_INT_LINES       64
 #define MXC_MAX_EXT_LINES       8
@@ -423,9 +418,9 @@
 /*!
  * Interrupt Number for ARM11 PMU
  */
-#define ARM11_PMU_IRQ           INT_RESV0
+#define ARM11_PMU_IRQ           MXC_INT_RESV0
 
-#define MXC_GPIO_BASE           (MXC_MAX_INT_LINES)
+#define MXC_GPIO_INT_BASE	(MXC_MAX_INT_LINES)
 
 /*!
  * Number of GPIO port as defined in the IC Spec
@@ -436,29 +431,10 @@
  */
 #define GPIO_NUM_PIN            32
 
-#define WEIM_CTRL_CS0           WEIM_BASE_ADDR
-#define CSCRU                   0x00
-#define CSCRL                   0x04
-#define CSCRA                   0x08
-
-/*
- * Used for 1-Wire
- */
-#define owire_read(a) (__raw_readb(a))
-#define owire_write(v,a) (__raw_writeb(v,a))
-
 /*!
  * NFMS bit in CSCR register for pagesize of nandflash
  */
 #define NFMS (*((volatile u32 *)IO_ADDRESS(CRM_MCU_BASE_ADDR+0xc)))
 #define NFMS_BIT 18
 
-/*
- * PWM control register used in clock API for
- * finding clock source for the module
- */
-#define MXC_PWM_PWMCTRL		IO_ADDRESS(PWM_BASE_ADDR)
-#define PWM_CTRL_MASK           0xFFFCFFFF
-#define PWM_CTRL_OFFSET	    	16
-
 #endif				/* __ASM_ARCH_MXC_MXC91321_H__ */
Index: linux-2.6.24/include/asm-arm/arch-mxc/mxc_scc.h
===================================================================
--- linux-2.6.24.orig/include/asm-arm/arch-mxc/mxc_scc.h	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/include/asm-arm/arch-mxc/mxc_scc.h	2009-01-24 22:01:10.000000000 +0100
@@ -34,12 +34,12 @@
 /*!
  *  This must be the interrupt line number of the SCM interrupt.
  */
-#define INT_SCM         INT_SCC_SCM
+#define INT_SCM         MXC_INT_SCC_SCM
 
 /*!
  *  if #USE_SMN_INTERRUPT is defined, this must be the interrupt line number of
  *  the SMN interrupt.
  */
-#define INT_SMN         INT_SCC_SMN
+#define INT_SMN         MXC_INT_SCC_SMN
 
 #endif
Index: linux-2.6.24/include/asm-arm/arch-mxc/pmic_external.h
===================================================================
--- linux-2.6.24.orig/include/asm-arm/arch-mxc/pmic_external.h	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/include/asm-arm/arch-mxc/pmic_external.h	2009-01-24 22:01:10.000000000 +0100
@@ -128,8 +128,6 @@
 #define PMIC_ALL_BITS           0xFFFFFF
 #define PMIC_MAX_EVENTS		48
 
-#ifdef CONFIG_MXC_PMIC_MC13783
-
 #define PMIC_ARBITRATION	"NULL"
 /*!
  * This is the enumeration of register names of MC13783
@@ -805,498 +803,6 @@
 	 */
 	bool sense_clks;
 } t_sensor_bits;
-#endif
-
-#ifdef CONFIG_MXC_PMIC_SC55112
-
-#define PMIC_ARBITRATION	"spi2.0"
-/*!
- * This is the enumeration of register names of SC55112
- */
-typedef enum {
-	/*!
-	 * REG_ISR
-	 */
-	REG_ISR = 0,
-	/*!
-	 * REG_IMR
-	 */
-	REG_IMR,
-	/*!
-	 * REG_PSTAT
-	 */
-	REG_PSTAT,
-	/*!
-	 * REG_INT_SEL
-	 */
-	REG_INT_SEL,
-	/*!
-	 * REG_SWCTRL
-	 */
-	REG_SWCTRL,
-	/*!
-	 * REG_VREG
-	 */
-	REG_VREG,
-	/*!
-	 * REG_IRQ_TEST
-	 */
-	REG_IRQ_TEST,
-	/*!
-	 * REG_TMOD_TRIM_3
-	 */
-	REG_TMOD_TRIM_3,
-	/*!
-	 * REG_BATT_DAC
-	 */
-	REG_BATT_DAC,
-	/*!
-	 * REG_ADC1
-	 */
-	REG_ADC1,
-	/*!
-	 * REG_ADC2
-	 */
-	REG_ADC2,
-	/*!
-	 * REG_AUD_CODEC
-	 */
-	REG_AUD_CODEC,
-	/*!
-	 * REG_RX_AUD_AMPS
-	 */
-	REG_RX_AUD_AMPS,
-	/*!
-	 * REG_ST_DAC
-	 */
-	REG_ST_DAC,
-	/*!
-	 * REG_RTC_TOD
-	 */
-	REG_RTC_TOD,
-	/*!
-	 * REG_RTC_TODA
-	 */
-	REG_RTC_TODA,
-	/*!
-	 * REG_RTC_DAY
-	 */
-	REG_RTC_DAY,
-	/*!
-	 * REG_RTC_DAYA
-	 */
-	REG_RTC_DAYA,
-	/*!
-	 * REG_RTC_CAL
-	 */
-	REG_RTC_CAL,
-	/*!
-	 * REG_PWRCTRL
-	 */
-	REG_PWRCTRL,
-	/*!
-	 * REG_BUSCTRL
-	 */
-	REG_BUSCTRL,
-	/*!
-	 * REG_BACKLIGHT_1
-	 */
-	REG_BACKLIGHT_1,
-	/*!
-	 * REG_BACKLIGHT_2
-	 */
-	REG_BACKLIGHT_2,
-	/*!
-	 * REG_TC_CONTROL1
-	 */
-	REG_TC_CONTROL1,
-	/*!
-	 * REG_TC_CONTROL2
-	 */
-	REG_TC_CONTROL2,
-	/*!
-	 * REG_ARB_REG
-	 */
-	REG_ARB_REG,
-	/*!
-	 * REG_TX_AUD_AMPS
-	 */
-	REG_TX_AUD_AMPS,
-	/*!
-	 * REG_GP_REG
-	 */
-	REG_GP_REG,
-	/*!
-	 * REG_TEST
-	 */
-	REG_TEST,
-	/*!
-	 * REG_TMOD_CTRL_1
-	 */
-	REG_TMOD_CTRL_1,
-	/*!
-	 * REG_TMOD_CTRL_2
-	 */
-	REG_TMOD_CTRL_2,
-	/*!
-	 * REG_TMOD_CTRL_3
-	 */
-	REG_TMOD_CTRL_3,
-	/*!
-	 * REG_RX_STATIC1
-	 */
-	REG_RX_STATIC1,
-	/*!
-	 * REG_RX_STATIC2
-	 */
-	REG_RX_STATIC2,
-	/*!
-	 * REG_RX_STATIC3
-	 */
-	REG_RX_STATIC3,
-	/*!
-	 * REG_RX_STATIC4
-	 */
-	REG_RX_STATIC4,
-	/*!
-	 * REG_RX_DYNAMIC
-	 */
-	REG_RX_DYNAMIC,
-	/*!
-	 * REG_TX_DYNAMIC
-	 */
-	REG_TX_DYNAMIC,
-	/*!
-	 * REG_TX_DYNAMIC2
-	 */
-	REG_TX_DYNAMIC2,
-	/*!
-	 * REG_TX_STATIC1
-	 */
-	REG_TX_STATIC1,
-	/*!
-	 * REG_TX_STATIC2
-	 */
-	REG_TX_STATIC2,
-	/*!
-	 * REG_TX_STATIC3
-	 */
-	REG_TX_STATIC3,
-	/*!
-	 * REG_TX_STATIC4
-	 */
-	REG_TX_STATIC4,
-	/*!
-	 * REG_TX_STATIC5
-	 */
-	REG_TX_STATIC5,
-	/*!
-	 * REG_TX_STATIC6
-	 */
-	REG_TX_STATIC6,
-	/*!
-	 * REG_TX_STATIC7
-	 */
-	REG_TX_STATIC7,
-	/*!
-	 * REG_TX_STATIC8
-	 */
-	REG_TX_STATIC8,
-	/*!
-	 * REG_TX_STATIC9
-	 */
-	REG_TX_STATIC9,
-	/*!
-	 * REG_TX_STATIC10
-	 */
-	REG_TX_STATIC10,
-	/*!
-	 * REG_TX_STATIC11
-	 */
-	REG_TX_STATIC11,
-	/*!
-	 * REG_TX_STATIC12
-	 */
-	REG_TX_STATIC12,
-	/*!
-	 * REG_TX_STATIC13
-	 */
-	REG_TX_STATIC13,
-	/*!
-	 * REG_TX_STATIC14
-	 */
-	REG_TX_STATIC14,
-	/*!
-	 * REG_TX_STATIC15
-	 */
-	REG_TX_STATIC15,
-	/*!
-	 * REG_TX_STATIC16
-	 */
-	REG_TX_STATIC16,
-	/*!
-	 * REG_TX_STATIC17
-	 */
-	REG_TX_STATIC17,
-	/*!
-	 * REG_TX_STATIC18
-	 */
-	REG_TX_STATIC18,
-	/*!
-	 * REG_TONE_GEN
-	 */
-	REG_TONE_GEN,
-	/*!
-	 * REG_GPS_REG
-	 */
-	REG_GPS_REG,
-	/*!
-	 * REG_TMODE_TRIM_1
-	 */
-	REG_TMODE_TRIM_1,
-	/*!
-	 * REG_TMODE_TRIM_2
-	 */
-	REG_TMODE_TRIM_2,
-	/*!
-	 * REG_T_RD_ERROR
-	 */
-	REG_T_RD_ERROR,
-	/*!
-	 * REG_T_RD_NPCOUNT
-	 */
-	REG_T_RD_NPCOUNT,
-	/*!
-	 * REG_ADC2_ALL
-	 */
-	REG_ADC2_ALL,
-	/*!
-	 * REG_NB
-	 */
-	REG_NB
-} pmic_reg;
-
-/*!
- * This is event list of sc55112 interrupt
- */
-
-typedef enum {
-	/*!
-	 * completion of the 7 programmed A/D conversions in standard
-	 * operation
-	 */
-	EVENT_ADCDONEI = 0,
-	/*!
-	 * touchscreen press
-	 */
-	EVENT_TSI = 1,
-	/*!
-	 * interrupt is from the 1Hz output.
-	 */
-	EVENT_1HZI = 2,
-	/*!
-	 * A/D word read in ADC digital comparison mode exceeding the
-	 * WHIGH[5:0] word.
-	 */
-	EVENT_WHI = 3,
-	/*!
-	 * A/D word read in ADC digital comparison mode reading below
-	 * the WLOW[5:0] word.
-	 */
-	EVENT_WLI = 4,
-	/*!
-	 * RTC_TOD = RTC_TODA; RTC_DAY = RTC_DAYA
-	 */
-	EVENT_TODAI = 5,
-	/*!
-	 * occurs on rising and falling debounced edges of USBDET_4.4V.
-	 */
-	EVENT_USB_44VI = 6,
-	/*!
-	 * ON/OFF button was pressed.
-	 */
-	EVENT_ONOFFI = 7,
-	/*!
-	 * ON/OFF2 button was pressed.
-	 */
-	EVENT_ONOFF2I = 8,
-	/*!
-	 * interrupt occurs on rising and falling edges of USBDET_0.8V
-	 */
-	EVENT_USB_08VI = 9,
-	/*!
-	 * interrupt occurs on rising and falling debounced edges of
-	 * MOBPORTB (EXT B+).
-	 */
-	EVENT_MOBPORTI = 10,
-	/*!
-	 * Interrupt linked to PTT_DET , to be debounced on both edges.
-	 */
-	EVENT_PTTI = 11,
-	/*!
-	 * Triggered on debounced transition of A1_INT
-	 */
-	EVENT_A1I = 12,
-	/*!
-	 * Power Cut transition occurred when PCEN=1 and B+ was
-	 * re-applied before the Power Cut timer expired
-	 */
-	EVENT_PCI = 14,
-	/*!
-	 * warm start to the MCU
-	 */
-	EVENT_WARMI = 15,
-	/*!
-	 * End of Life (low battery shut off)
-	 */
-	EVENT_EOLI = 16,
-	/*!
-	 * positive or negative edge of CLK_STAT
-	 */
-	EVENT_CLKI = 17,
-	/*!
-	 * interrupt occurs on rising and falling debounced edges of
-	 * USBDET_2.0V.
-	 */
-	EVENT_USB_20VI = 18,
-	/*!
-	 * Interrupt generated from the de-bounced output of the USB
-	 * ID-detect comparator.
-	 */
-	EVENT_AB_DETI = 19,
-	/*!
-	 * completion of the 7 programmed A/D conversions in standard
-	 * operation.
-	 */
-	EVENT_ADCDONE2I = 20,
-	/*!
-	 * Will be set (1) only if SYS_RST_MODE bits = 10 and (2) the
-	 * BATT_DET_IN/SYS_RESTART input was asserted for the minimum
-	 * debounce time.
-	 */
-	EVENT_SOFT_RESETI = 21,
-	/*!
-	 * Number of events.
-	 */
-	EVENT_NB,
-} type_event;
-
-/*!
- * This enumeration all senses of sc55112.
- */
-typedef enum {
-	/*!
-	 * Status of USB 4.4V Comparator
-	 */
-	SENSOR_USBDET_44V = 0,
-	/*!
-	 * The logic output of ONOFFSNS
-	 */
-	SENSOR_ONOFFSNS,
-	/*!
-	 * The logic output of ONOFFSNS2
-	 */
-	SENSOR_ONOFFSNS2,
-	/*!
-	 * Status of USB 0.8V Comparator
-	 */
-	SENSOR_USBDET_08V,
-	/*!
-	 * The power up state of the radio
-	 */
-	SENSOR_MOBSNSB,
-	/*!
-	 * Status of PTT_DET pin
-	 */
-	SENSOR_PTTSNS,
-	/*!
-	 * Status of A1_INT pin
-	 */
-	SENSOR_A1SNS,
-	/*!
-	 * Status of USB 2.0V Comparator
-	 */
-	SENSOR_USBDET_20V,
-	/*!
-	 * Current state of EOL comparator output
-	 */
-	SENSOR_EOL_STAT,
-	/*!
-	 * 32 kHz external oscillation
-	 */
-	SENSOR_CLK_STAT,
-	/*!
-	 * System reset
-	 */
-	SENSOR_SYS_RST,
-	/*!
-	 * Warm system reset
-	 */
-	SENSOR_WARM_SYS_RST,
-	/*!
-	 * State of the BATT_DET_IN/SYS_RST input
-	 */
-	SENSOR_BATT_DET_IN_SNS,
-} t_sensor;
-
-/*!
- * This structure is used to read all sense bits of sc55112.
- */
-typedef struct {
-	/*!
-	 * Status of USB 4.4V Comparator
-	 */
-	bool usbdet_44v;
-	/*!
-	 * The logic output of ONOFFSNS
-	 */
-	bool onoffsns;
-	/*!
-	 * The logic output of ONOFFSNS2
-	 */
-	bool onoffsns2;
-	/*!
-	 * Status of USB 0.8V Comparator
-	 */
-	bool usbdet_08v;
-	/*!
-	 * The power up state of the radio
-	 */
-	bool mobsnsb;
-	/*!
-	 * Status of PTT_DET pin
-	 */
-	bool pttsns;
-	/*!
-	 * Status of A1_INT pin
-	 */
-	bool a1sns;
-	/*!
-	 * Status of USB 2.0V Comparator
-	 */
-	bool usbdet_20v;
-	/*!
-	 * Current state of EOL comparator output
-	 */
-	bool eol_stat;
-	/*!
-	 * 32 kHz external oscillation
-	 */
-	bool clk_stat;
-	/*!
-	 * System reset
-	 */
-	bool sys_rst;
-	/*!
-	 * Warm system reset
-	 */
-	bool warm_sys_rst;
-	/*!
-	 * State of the BATT_DET_IN/SYS_RST input
-	 */
-	bool batt_det_in_sns;
-} t_sensor_bits;
-#endif
 
 /* EXPORTED FUNCTIONS */
 #ifdef __KERNEL__
Index: linux-2.6.24/include/asm-arm/arch-mxc/uncompress.h
===================================================================
--- linux-2.6.24.orig/include/asm-arm/arch-mxc/uncompress.h	2009-01-24 21:59:19.000000000 +0100
+++ linux-2.6.24/include/asm-arm/arch-mxc/uncompress.h	2009-01-24 22:01:10.000000000 +0100
@@ -27,6 +27,8 @@
 
 #include <asm/hardware.h>
 
+unsigned int system_rev;
+
 #define UART(x) (*(volatile unsigned long *)(serial_port + (x)))
 
 #define USR2 0x98
Index: linux-2.6.24/include/asm-arm/ide.h
===================================================================
--- linux-2.6.24.orig/include/asm-arm/ide.h	2009-01-24 22:01:09.000000000 +0100
+++ linux-2.6.24/include/asm-arm/ide.h	2009-01-24 22:01:10.000000000 +0100
@@ -32,7 +32,7 @@
 
 #ifdef CONFIG_ARCH_MXC
 #define IDE_ARCH_ACK_INTR
-#define ide_ack_intr(hwif)      ((hwif)->hw.ack_intr ? (hwif)->hw.ack_intr(hwif) : 1)
+#define ide_ack_intr(hwif)      ((hwif)->ack_intr ? (hwif)->ack_intr(hwif) : 1)
 #endif /* CONFIG_ARCH_MXC */
 
 #endif /* __KERNEL__ */
