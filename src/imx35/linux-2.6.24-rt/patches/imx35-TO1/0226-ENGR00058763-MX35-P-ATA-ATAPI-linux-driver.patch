From 897ef5ab71066a80d4f2fe5222105da072cc9865 Mon Sep 17 00:00:00 2001
From: Richard Zhu <r65037@freescale.com>
Date: Wed, 25 Jun 2008 16:07:37 +0800
Subject: [PATCH] ENGR00058763 MX35 P-ATA/ATAPI linux driver

Enable the P-ATA/ATAPI support on MX35 3DS board.
Now only the PIO mode is supported.

Signed-off-by: Richard Zhu <r65037@freescale.com>
---
 arch/arm/configs/imx35_3stack_defconfig |   16 +++-
 arch/arm/mach-mx3/mx31ads.c             |    5 +-
 arch/arm/mach-mx3/mx3_3stack.c          |    9 +-
 arch/arm/mach-mx35/mx35_3stack.c        |   69 ++++++++++++
 arch/arm/mach-mx35/mx35_3stack_gpio.c   |  172 +++++++++++++++++++++++++++++++
 arch/arm/mach-mx37/mx37_3stack.c        |    5 +-
 drivers/ata/Kconfig                     |    2 +-
 drivers/ata/pata_fsl.c                  |   20 +++-
 include/asm-arm/arch-mxc/mx35.h         |    2 +-
 include/linux/fsl_devices.h             |    3 +
 10 files changed, 288 insertions(+), 15 deletions(-)

diff --git a/arch/arm/configs/imx35_3stack_defconfig b/arch/arm/configs/imx35_3stack_defconfig
index f423250..0a55abf 100644
--- a/arch/arm/configs/imx35_3stack_defconfig
+++ b/arch/arm/configs/imx35_3stack_defconfig
@@ -517,7 +517,7 @@ CONFIG_SCSI_PROC_FS=y
 CONFIG_BLK_DEV_SD=y
 # CONFIG_CHR_DEV_ST is not set
 # CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
+CONFIG_BLK_DEV_SR=y
 # CONFIG_CHR_DEV_SG is not set
 # CONFIG_CHR_DEV_SCH is not set
 
@@ -555,7 +555,15 @@ CONFIG_SCSI_LOWLEVEL=y
 # CONFIG_SCSI_SYM53C416 is not set
 # CONFIG_SCSI_T128 is not set
 # CONFIG_SCSI_DEBUG is not set
-# CONFIG_ATA is not set
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+# CONFIG_PATA_LEGACY is not set
+# CONFIG_PATA_PCMCIA is not set
+# CONFIG_PATA_QDI is not set
+# CONFIG_PATA_WINBOND_VLB is not set
+# CONFIG_PATA_PLATFORM is not set
+CONFIG_PATA_FSL=m
 # CONFIG_MD is not set
 CONFIG_NETDEVICES=y
 # CONFIG_NETDEVICES_MULTIQUEUE is not set
@@ -1320,7 +1328,9 @@ CONFIG_AUTOFS4_FS=m
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
 # CONFIG_UDF_FS is not set
 
 #
diff --git a/arch/arm/mach-mx3/mx31ads.c b/arch/arm/mach-mx3/mx31ads.c
index b89a5bf..2925c22 100644
--- a/arch/arm/mach-mx3/mx31ads.c
+++ b/arch/arm/mach-mx3/mx31ads.c
@@ -29,6 +29,7 @@
 #include <linux/platform_device.h>
 #include <linux/fsl_devices.h>
 #include <linux/spi/spi.h>
+#include <linux/ata.h>
 #if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
@@ -813,7 +814,9 @@ static void ata_exit(void)
 }
 
 static struct fsl_ata_platform_data ata_data = {
-	.udma_mask = 0x0F,	/* board can handle up to UDMA3 */
+	.udma_mask = ATA_UDMA3,	/* board can handle up to UDMA3 */
+	.mwdma_mask = ATA_MWDMA2,
+	.pio_mask = ATA_PIO4,
 	.fifo_alarm = MXC_IDE_DMA_WATERMARK / 2,
 	.max_sg = MXC_IDE_DMA_BD_NR,
 	.init = ata_init,
diff --git a/arch/arm/mach-mx3/mx3_3stack.c b/arch/arm/mach-mx3/mx3_3stack.c
index 855db4e..8dface1 100644
--- a/arch/arm/mach-mx3/mx3_3stack.c
+++ b/arch/arm/mach-mx3/mx3_3stack.c
@@ -34,6 +34,7 @@
 #include <linux/i2c.h>
 #include <linux/regulator/regulator-platform.h>
 #include <linux/regulator/regulator.h>
+#include <linux/ata.h>
 #if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
@@ -775,7 +776,9 @@ static void ata_exit(void)
 }
 
 static struct fsl_ata_platform_data ata_data = {
-	.udma_mask = 0x0F,	/* board can handle up to UDMA3 */
+	.udma_mask = ATA_UDMA3,	/* board can handle up to UDMA3 */
+	.mwdma_mask = ATA_MWDMA2,
+	.pio_mask = ATA_PIO4,
 	.fifo_alarm = MXC_IDE_DMA_WATERMARK / 2,
 	.max_sg = MXC_IDE_DMA_BD_NR,
 	.init = ata_init,
@@ -812,11 +815,11 @@ static void __init mxc_init_pata(void)
 {
 	(void)platform_device_register(&pata_fsl_device);
 }
-#else /* CONFIG_PATA_FSL */
+#else				/* CONFIG_PATA_FSL */
 static void __init mxc_init_pata(void)
 {
 }
-#endif /* CONFIG_PATA_FSL */
+#endif				/* CONFIG_PATA_FSL */
 
 /*!
  * Board specific initialization.
diff --git a/arch/arm/mach-mx35/mx35_3stack.c b/arch/arm/mach-mx35/mx35_3stack.c
index ae98f26..5dae8c9 100644
--- a/arch/arm/mach-mx35/mx35_3stack.c
+++ b/arch/arm/mach-mx35/mx35_3stack.c
@@ -21,6 +21,8 @@
 #include <linux/spi/spi.h>
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/ata.h>
 #if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
@@ -475,6 +477,72 @@ static int __init mxc_init_power_key(void)
 
 late_initcall(mxc_init_power_key);
 #endif
+
+#if defined(CONFIG_PATA_FSL) || defined(CONFIG_PATA_FSL_MODULE)
+extern void gpio_ata_active(void);
+extern void gpio_ata_inactive(void);
+
+static int ata_init(struct platform_device *pdev)
+{
+	/* Configure the pins */
+	gpio_ata_active();
+
+	return 0;
+}
+
+static void ata_exit(void)
+{
+	/* Free the pins */
+	gpio_ata_inactive();
+}
+
+static struct fsl_ata_platform_data ata_data = {
+	.adma_flag = 1,
+	.udma_mask = 0x0,
+	.mwdma_mask = 0x0,
+	.pio_mask = ATA_PIO4,
+	.fifo_alarm = MXC_IDE_DMA_WATERMARK / 2,
+	.max_sg = MXC_IDE_DMA_BD_NR,
+	.init = ata_init,
+	.exit = ata_exit,
+	.core_reg = NULL,	/*"LDO2", */
+	.io_reg = NULL,		/*"LDO3", */
+};
+
+static struct resource pata_fsl_resources[] = {
+	[0] = {			/* I/O */
+	       .start = ATA_BASE_ADDR,
+	       .end = ATA_BASE_ADDR + 0x000000C8,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[2] = {			/* IRQ */
+	       .start = MXC_INT_ATA,
+	       .end = MXC_INT_ATA,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static struct platform_device pata_fsl_device = {
+	.name = "pata_fsl",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(pata_fsl_resources),
+	.resource = pata_fsl_resources,
+	.dev = {
+		.platform_data = &ata_data,
+		.coherent_dma_mask = ~0,
+		},
+};
+
+static void __init mxc_init_pata(void)
+{
+	(void)platform_device_register(&pata_fsl_device);
+}
+#else				/* CONFIG_PATA_FSL */
+static void __init mxc_init_pata(void)
+{
+}
+#endif				/* CONFIG_PATA_FSL */
+
 /*!
  * Board specific fixup function. It is called by \b setup_arch() in
  * setup.c file very early on during kernel starts. It allows the user to
@@ -523,6 +591,7 @@ static void __init mxc_board_init(void)
 	i2c_register_board_info(0, mxc_i2c_board_info,
 				ARRAY_SIZE(mxc_i2c_board_info));
 	mxc_init_mmc();
+	mxc_init_pata();
 }
 
 #define PLL_PCTL_REG(brmo, pd, mfd, mfi, mfn)		\
diff --git a/arch/arm/mach-mx35/mx35_3stack_gpio.c b/arch/arm/mach-mx35/mx35_3stack_gpio.c
index be9197d..f4593fc 100644
--- a/arch/arm/mach-mx35/mx35_3stack_gpio.c
+++ b/arch/arm/mach-mx35/mx35_3stack_gpio.c
@@ -755,3 +755,175 @@ void gpio_activate_audio_ports(void)
 }
 
 EXPORT_SYMBOL(gpio_activate_audio_ports);
+
+/*!
+ * Setup GPIO for ATA interface
+ *
+ */
+void gpio_ata_active(void)
+{
+	/*IOMUX Settings */
+	/*PATA_DIOR */
+	mxc_request_iomux(MX35_PIN_ATA_DIOR, MUX_CONFIG_FUNC);
+	/*PATA_DIOW */
+	mxc_request_iomux(MX35_PIN_ATA_DIOW, MUX_CONFIG_FUNC);
+	/*PATA_DMARQ_B */
+	mxc_request_iomux(MX35_PIN_ATA_DMARQ, MUX_CONFIG_FUNC);
+	/*PATA_DMACK */
+	mxc_request_iomux(MX35_PIN_ATA_DMACK, MUX_CONFIG_FUNC);
+	/*PATA_RESET_B */
+	mxc_request_iomux(MX35_PIN_ATA_RESET_B, MUX_CONFIG_FUNC);
+	/*PATA_IORDY */
+	mxc_request_iomux(MX35_PIN_ATA_IORDY, MUX_CONFIG_FUNC);
+	/*PATA_INTRQ_B */
+	mxc_request_iomux(MX35_PIN_ATA_INTRQ, MUX_CONFIG_FUNC);
+	/*PATA_CS_0 */
+	mxc_request_iomux(MX35_PIN_ATA_CS0, MUX_CONFIG_FUNC);
+	/*PATA_CS_1 */
+	mxc_request_iomux(MX35_PIN_ATA_CS1, MUX_CONFIG_FUNC);
+	/*PATA_DA0 */
+	mxc_request_iomux(MX35_PIN_ATA_DA0, MUX_CONFIG_FUNC);
+	/*PATA_DA1 */
+	mxc_request_iomux(MX35_PIN_ATA_DA1, MUX_CONFIG_FUNC);
+	/*PATA_DA2 */
+	mxc_request_iomux(MX35_PIN_ATA_DA2, MUX_CONFIG_FUNC);
+	/* BUFFER_ENABLE - HDD_ENABLE_B  */
+	mxc_request_iomux(MX35_PIN_ATA_BUFF_EN, MUX_CONFIG_FUNC);
+
+	/*PATA_D0 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA0, MUX_CONFIG_FUNC);
+	/*PATA_D1 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA1, MUX_CONFIG_FUNC);
+	/*PATA_D2 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA2, MUX_CONFIG_FUNC);
+	/*PATA_D3 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA3, MUX_CONFIG_FUNC);
+	/*PATA_D4 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA4, MUX_CONFIG_FUNC);
+	/*PATA_D5 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA5, MUX_CONFIG_FUNC);
+	/*PATA_D6 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA6, MUX_CONFIG_FUNC);
+	/*PATA_D7 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA7, MUX_CONFIG_FUNC);
+	/*PATA_D8 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA8, MUX_CONFIG_FUNC);
+	/*PATA_D9 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA9, MUX_CONFIG_FUNC);
+	/*PATA_D10 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA10, MUX_CONFIG_FUNC);
+	/*PATA_D11 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA11, MUX_CONFIG_FUNC);
+	/*PATA_D12 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA12, MUX_CONFIG_FUNC);
+	/*PATA_D13 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA13, MUX_CONFIG_FUNC);
+	/*PATA_D14 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA14, MUX_CONFIG_FUNC);
+	/*PATA_D15 */
+	mxc_request_iomux(MX35_PIN_ATA_DATA15, MUX_CONFIG_FUNC);
+
+	/* IOMUX Pad Settings */
+#define ATA_CTL_PAD_CFG (PAD_CTL_SRE_SLOW | PAD_CTL_DRV_NORMAL | \
+			 PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE | \
+			 PAD_CTL_PUE_PUD | PAD_CTL_100K_PD | \
+			 PAD_CTL_HYS_CMOS | PAD_CTL_DRV_3_3V)
+
+#define ATA_DAT_PAD_CFG (PAD_CTL_SRE_FAST | PAD_CTL_DRV_MAX | \
+			 PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE | \
+			 PAD_CTL_PUE_PUD | PAD_CTL_100K_PD | \
+			 PAD_CTL_HYS_SCHMITZ | PAD_CTL_DRV_3_3V)
+
+	mxc_iomux_set_pad(MX35_PIN_ATA_DMARQ, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DIOR, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DIOW, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DMACK, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_RESET_B, PAD_CTL_SRE_SLOW |
+			  PAD_CTL_DRV_NORMAL | PAD_CTL_ODE_CMOS |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD |
+			  PAD_CTL_100K_PU | PAD_CTL_HYS_CMOS |
+			  PAD_CTL_DRV_3_3V);
+	mxc_iomux_set_pad(MX35_PIN_ATA_IORDY, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_INTRQ, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_CS0, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_CS1, ATA_CTL_PAD_CFG);
+
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA0, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA1, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA2, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA3, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA4, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA5, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA6, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA7, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA8, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA9, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA10, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA11, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA12, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA13, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA14, ATA_DAT_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DATA15, ATA_DAT_PAD_CFG);
+
+	mxc_iomux_set_pad(MX35_PIN_ATA_DA0, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DA1, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_DA2, ATA_CTL_PAD_CFG);
+	mxc_iomux_set_pad(MX35_PIN_ATA_BUFF_EN, ATA_CTL_PAD_CFG);
+#undef ATA_CTL_PAD_CFG
+#undef ATA_DAT_PAD_CFG
+
+	/* HDD_ENBALE */
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_GPIO_CONTROL_1, 3, 0);
+	/* Power On the HDD */
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_GPIO_CONTROL_1, 4, 1);
+	msleep(300);
+}
+
+EXPORT_SYMBOL(gpio_ata_active);
+
+/*!
+ * Restore ATA interface pins to reset values
+ *
+ */
+void gpio_ata_inactive(void)
+{
+	/*Turn off the IOMUX for ATA group B signals */
+	mxc_free_iomux(MX35_PIN_ATA_DATA0, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA1, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA2, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA3, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA4, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA5, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA6, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA7, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA8, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA9, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA10, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA11, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA12, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA13, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA14, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DATA15, MUX_CONFIG_FUNC);
+
+	/* Config the multiplex pin of ATA interface DIR, DA0-2, INTRQ, DMARQ */
+	mxc_free_iomux(MX35_PIN_ATA_DMARQ, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DIOR, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DIOW, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DMACK, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_RESET_B, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_IORDY, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_INTRQ, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_CS0, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_CS1, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DA0, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DA1, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_DA2, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX35_PIN_ATA_BUFF_EN, MUX_CONFIG_FUNC);
+
+	/* Power Off the HDD */
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_GPIO_CONTROL_1, 4, 0);
+	/* HDD_ENBALE */
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_GPIO_CONTROL_1, 3, 1);
+}
+
+EXPORT_SYMBOL(gpio_ata_inactive);
diff --git a/arch/arm/mach-mx37/mx37_3stack.c b/arch/arm/mach-mx37/mx37_3stack.c
index 0eacd63..beeda64 100644
--- a/arch/arm/mach-mx37/mx37_3stack.c
+++ b/arch/arm/mach-mx37/mx37_3stack.c
@@ -24,6 +24,7 @@
 #include <linux/fsl_devices.h>
 #include <linux/spi/spi.h>
 #include <linux/i2c.h>
+#include <linux/ata.h>
 #if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
@@ -327,7 +328,9 @@ static void ata_exit(void)
 }
 
 static struct fsl_ata_platform_data ata_data = {
-	.udma_mask = 0x0F,	/* board can handle up to UDMA3 */
+	.udma_mask = ATA_UDMA3,	/* board can handle up to UDMA3 */
+	.mwdma_mask = ATA_MWDMA2,
+	.pio_mask = ATA_PIO4,
 	.fifo_alarm = MXC_IDE_DMA_WATERMARK / 2,
 	.max_sg = MXC_IDE_DMA_BD_NR,
 	.init = ata_init,
diff --git a/drivers/ata/Kconfig b/drivers/ata/Kconfig
index 7753593..a1a3546 100644
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -652,7 +652,7 @@ config PATA_BF54X
 
 config PATA_FSL
        tristate "Freescale on-chip PATA support"
-       depends on (ARCH_MX37 || ARCH_MX3 || ARCH_MX27)
+       depends on (ARCH_MX37 || ARCH_MX35 || ARCH_MX3 || ARCH_MX27)
        help
          On Freescale processors, say Y here if you wish to use the on-chip
          ATA interface.
diff --git a/drivers/ata/pata_fsl.c b/drivers/ata/pata_fsl.c
index 3cab80c..2f5fd2a 100644
--- a/drivers/ata/pata_fsl.c
+++ b/drivers/ata/pata_fsl.c
@@ -55,6 +55,12 @@ enum {
 	FSL_ATA_INT_EN = 0x2C,
 	FSL_ATA_INT_CLEAR = 0x30,
 	FSL_ATA_FIFO_ALARM = 0x34,
+	FSL_ATA_ADMA_ERROR_STATUS = 0x38,
+	FSL_ATA_SYS_DMA_BADDR = 0x3C,
+	FSL_ATA_ADMA_SYS_ADDR = 0x40,
+	FSL_ATA_BLOCK_COUNT = 0x48,
+	FSL_ATA_BURST_LENGTH = 0x4C,
+	FSL_ATA_SECTOR_SIZE = 0x50,
 	FSL_ATA_DRIVE_DATA = 0xA0,
 	FSL_ATA_DRIVE_CONTROL = 0xD8,
 
@@ -575,8 +581,8 @@ static int __devinit pata_fsl_probe(struct platform_device *pdev)
 	ap->ioaddr.ctl_addr = (void *)(ata_regs + FSL_ATA_DRIVE_CONTROL);
 	ap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;
 	ap->ops = &pata_fsl_port_ops;
-	ap->pio_mask = 0x7F;
-	ap->mwdma_mask = 0x7F;
+	ap->pio_mask = plat->pio_mask;	/* support pio 0~4 */
+	ap->mwdma_mask = plat->mwdma_mask;	/* support mdma 0~2 */
 	ap->udma_mask = plat->udma_mask;
 	pata_fsl_sht.sg_tablesize = plat->max_sg;
 
@@ -604,6 +610,7 @@ static int __devinit pata_fsl_probe(struct platform_device *pdev)
 		core_reg = regulator_get(&pdev->dev, plat->core_reg);
 		if (regulator_enable(core_reg))
 			printk(KERN_INFO "enable core regulator error.\n");
+		msleep(100);
 
 	} else
 		core_reg = NULL;
@@ -612,14 +619,17 @@ static int __devinit pata_fsl_probe(struct platform_device *pdev)
 		io_reg = regulator_get(&pdev->dev, plat->io_reg);
 		if (regulator_enable(io_reg))
 			printk(KERN_INFO "enable io regulator error.\n");
+		msleep(100);
 
 	} else
 		io_reg = NULL;
 
 	/* Set initial timing and mode */
 	set_ata_bus_timing(XFER_PIO_4, pdev);
-    /* get DMA ready */
-	pata_fsl_dma_init(ap);
+
+	/* get DMA ready */
+	if (plat->adma_flag == 0)
+		pata_fsl_dma_init(ap);
 
 	/*
 	 * Enable the ATA INTRQ interrupt from the bus, but
@@ -630,7 +640,7 @@ static int __devinit pata_fsl_probe(struct platform_device *pdev)
 
 	/* activate */
 	ret = ata_host_activate(host, platform_get_irq(pdev, 0), ata_interrupt,
-				 0, &pata_fsl_sht);
+				0, &pata_fsl_sht);
 
 	if (ret < 0)
 		goto err2;
diff --git a/include/asm-arm/arch-mxc/mx35.h b/include/asm-arm/arch-mxc/mx35.h
index 4770e8f..228dc1f 100644
--- a/include/asm-arm/arch-mxc/mx35.h
+++ b/include/asm-arm/arch-mxc/mx35.h
@@ -101,7 +101,6 @@
 #define ECT_CTIO_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00018000)
 #define I2C_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00080000)
 #define I2C3_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00084000)
-#define ATA_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0008C000)
 #define UART1_BASE_ADDR 	(AIPS1_BASE_ADDR + 0x00090000)
 #define UART2_BASE_ADDR 	(AIPS1_BASE_ADDR + 0x00094000)
 #define I2C2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00098000)
@@ -123,6 +122,7 @@
 #define UART3_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x0000C000)
 #define CSPI2_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x00010000)
 #define SSI2_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00014000)
+#define ATA_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00020000)
 #define ATA_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00020000)
 #define MSHC1_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00024000)
 #define SPDIF_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00028000)
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index 8c185a5..69acfec 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -144,7 +144,10 @@ struct fsl_spi_platform_data {
 };
 
 struct fsl_ata_platform_data {
+       int     adma_flag;      /* AMDA mode is used or not, 1:used.*/
        int     udma_mask;      /* UDMA modes h/w can handle */
+       int     mwdma_mask;      /* MDMA modes h/w can handle */
+       int     pio_mask;      /* PIO modes h/w can handle */
        int     fifo_alarm;     /* value for fifo_alarm reg */
        int     max_sg;         /* longest sglist h/w can handle */
        int     (*init)(struct platform_device *pdev);
-- 
1.5.4.4

