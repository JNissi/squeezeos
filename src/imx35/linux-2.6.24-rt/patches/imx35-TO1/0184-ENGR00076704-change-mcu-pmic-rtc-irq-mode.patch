From de4c8af407ca8081a8b91021475f54e8e1df9395 Mon Sep 17 00:00:00 2001
From: Jingyu Zhou <b02241@freescale.com>
Date: Tue, 20 May 2008 17:18:20 +0800
Subject: [PATCH] ENGR00076704 change mcu pmic rtc irq mode

change mcu pmic rtc irq mode

Signed-off-by: Zhou Jingyu <Jingyu.Zhou@freescale.com>
---
 arch/arm/mach-mx35/devices.c             |   27 ++++++++++
 drivers/mxc/pmic/core/mcu_pmic_core.c    |    6 --
 drivers/mxc/pmic/mc9sdz60/mcu_pmic_rtc.c |   81 ++++++++++++++++++++++++++---
 3 files changed, 99 insertions(+), 15 deletions(-)

diff --git a/arch/arm/mach-mx35/devices.c b/arch/arm/mach-mx35/devices.c
index e66e6d7..073a24b 100644
--- a/arch/arm/mach-mx35/devices.c
+++ b/arch/arm/mach-mx35/devices.c
@@ -110,6 +110,32 @@ static inline void mxc_init_rtc(void)
 }
 #endif
 
+#if defined(CONFIG_MXC_MC9SDZ60_RTC) || defined(CONFIG_MXC_MC9SDZ60_RTC_MODULE)
+static struct resource pmic_rtc_resources[] = {
+	{
+	 .start = MXC_PSEUDO_IRQ_RTC,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+static struct platform_device pmic_rtc_device = {
+	.name = "pmic_rtc",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(pmic_rtc_resources),
+	.resource = pmic_rtc_resources,
+};
+static void pmic_init_rtc(void)
+{
+	platform_device_register(&pmic_rtc_device);
+}
+#else
+static void pmic_init_rtc(void)
+{
+}
+#endif
+
 #if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
 static struct resource wdt_resources[] = {
 	{
@@ -528,6 +554,7 @@ static int __init mxc_init_devices(void)
 	mxc_init_ipu();
 	mxc_init_spi();
 	mxc_init_i2c();
+	pmic_init_rtc();
 	mxc_init_rtc();
 	mxc_init_dma();
 	mxc_init_spdif();
diff --git a/drivers/mxc/pmic/core/mcu_pmic_core.c b/drivers/mxc/pmic/core/mcu_pmic_core.c
index 228d8db..3ac177a 100644
--- a/drivers/mxc/pmic/core/mcu_pmic_core.c
+++ b/drivers/mxc/pmic/core/mcu_pmic_core.c
@@ -59,10 +59,6 @@ static struct platform_device power_ldm = {
 	.name = "pmic_power",
 	.id = 1,
 };
-static struct platform_device rtc_ldm = {
-	.name = "pmic_rtc",
-	.id = 1,
-};
 
 /* map reg names (enum pmic_reg in pmic_external.h) to real addr*/
 const static u8 mcu_pmic_reg_addr_table[] = {
@@ -371,7 +367,6 @@ extern void gpio_pmic_active(void);
  */
 static void pmic_pdev_register(void)
 {
-	platform_device_register(&rtc_ldm);
 	platform_device_register(&power_ldm);
 	reg_max8660_probe();
 }
@@ -382,7 +377,6 @@ static void pmic_pdev_register(void)
  */
 static void pmic_pdev_unregister(void)
 {
-	platform_device_unregister(&rtc_ldm);
 }
 
 /*!
diff --git a/drivers/mxc/pmic/mc9sdz60/mcu_pmic_rtc.c b/drivers/mxc/pmic/mc9sdz60/mcu_pmic_rtc.c
index 2f61e64..5719b60 100644
--- a/drivers/mxc/pmic/mc9sdz60/mcu_pmic_rtc.c
+++ b/drivers/mxc/pmic/mc9sdz60/mcu_pmic_rtc.c
@@ -36,11 +36,14 @@
  * Global variables
  */
 static int pmic_rtc_major;
+static void rtc_alarm_handler(struct work_struct *work);
+static DECLARE_WORK(rtc_alarm_event, rtc_alarm_handler);
 static void callback_alarm_asynchronous(void *);
 static void callback_alarm_synchronous(void *);
 static unsigned int pmic_rtc_poll(struct file *file, poll_table *wait);
 static DECLARE_WAIT_QUEUE_HEAD(queue_alarm);
 static DECLARE_WAIT_QUEUE_HEAD(pmic_rtc_wait);
+static pmic_event_callback_t rtc_event_callback;
 static pmic_event_callback_t alarm_callback;
 static pmic_event_callback_t rtc_callback;
 static int pmic_rtc_detected;
@@ -49,10 +52,43 @@ static struct class *pmic_rtc_class;
 struct rtc_time alarm_greg_time;
 static DECLARE_MUTEX(mutex);
 
+static DECLARE_MUTEX(event_mutex);
+struct pmic_rtc_data {
+	int irq;
+	int rtc_event_subscribed;
+};
+static struct pmic_rtc_data mcu_pmic_rtc_data;
+
 /*
  * Real Time Clock Pmic API
  */
 
+static int mcu_pmic_rtc_event_subscribe(int event,
+					pmic_event_callback_t callback)
+{
+	down_interruptible(&event_mutex);
+	rtc_event_callback.func = callback.func;
+	up(&event_mutex);
+	return 0;
+}
+
+static int mcu_pmic_rtc_event_unsubscribe(int event,
+					  pmic_event_callback_t callback)
+{
+	down_interruptible(&event_mutex);
+	rtc_event_callback.func = NULL;
+	up(&event_mutex);
+	return 0;
+}
+
+static void rtc_alarm_handler(struct work_struct *work)
+{
+	down_interruptible(&event_mutex);
+	if (NULL != rtc_event_callback.func)
+		rtc_event_callback.func(rtc_event_callback.param);
+	up(&event_mutex);
+}
+
 /*!
  * This is the callback function called on TSI Pmic event, used in asynchronous
  * call.
@@ -92,13 +128,14 @@ PMIC_STATUS pmic_rtc_wait_alarm(void)
 	DEFINE_WAIT(wait);
 	alarm_callback.func = callback_alarm_synchronous;
 	alarm_callback.param = NULL;
-	CHECK_ERROR(pmic_event_subscribe(EVENT_RTC, alarm_callback));
+	CHECK_ERROR(mcu_pmic_rtc_event_subscribe(EVENT_RTC, alarm_callback));
 	prepare_to_wait(&queue_alarm, &wait, TASK_UNINTERRUPTIBLE);
 	schedule();
 	finish_wait(&queue_alarm, &wait);
-	CHECK_ERROR(pmic_event_unsubscribe(EVENT_RTC, alarm_callback));
+	CHECK_ERROR(mcu_pmic_rtc_event_unsubscribe(EVENT_RTC, alarm_callback));
 	return PMIC_SUCCESS;
 }
+
 EXPORT_SYMBOL(pmic_rtc_wait_alarm);
 
 /*!
@@ -144,6 +181,7 @@ PMIC_STATUS pmic_rtc_set_time(struct timeval *pmic_time)
 
 	return PMIC_SUCCESS;
 }
+
 EXPORT_SYMBOL(pmic_rtc_set_time);
 
 /*!
@@ -178,13 +216,14 @@ PMIC_STATUS pmic_rtc_get_time(struct timeval *pmic_time)
 	greg_time.tm_mon = BCD2BIN(reg_val);
 
 	CHECK_ERROR(pmic_read_reg(REG_MCU_YEAR, &reg_val, 0xff));
-	greg_time.tm_year = BCD2BIN(reg_val);
+	greg_time.tm_year = BCD2BIN(reg_val) + 70;
 
 	rtc_tm_to_time(&greg_time, &time);
 	pmic_time->tv_sec = time;
 
 	return PMIC_SUCCESS;
 }
+
 EXPORT_SYMBOL(pmic_rtc_get_time);
 
 /*!
@@ -222,6 +261,7 @@ PMIC_STATUS pmic_rtc_set_time_alarm(struct timeval *pmic_time)
 
 	return PMIC_SUCCESS;
 }
+
 EXPORT_SYMBOL(pmic_rtc_set_time_alarm);
 
 /*!
@@ -253,6 +293,7 @@ PMIC_STATUS pmic_rtc_get_time_alarm(struct timeval *pmic_time)
 	pmic_time->tv_sec = time;
 	return PMIC_SUCCESS;
 }
+
 EXPORT_SYMBOL(pmic_rtc_get_time_alarm);
 
 /*!
@@ -281,9 +322,11 @@ PMIC_STATUS pmic_rtc_event(t_rtc_int event, void *callback, bool sub)
 		return PMIC_PARAMETER_ERROR;
 	}
 	if (sub)
-		CHECK_ERROR(pmic_event_subscribe(rtc_event, rtc_callback));
+		CHECK_ERROR(mcu_pmic_rtc_event_subscribe
+			    (rtc_event, rtc_callback));
 	else
-		CHECK_ERROR(pmic_event_unsubscribe(rtc_event, rtc_callback));
+		CHECK_ERROR(mcu_pmic_rtc_event_unsubscribe
+			    (rtc_event, rtc_callback));
 
 	return PMIC_SUCCESS;
 }
@@ -301,6 +344,7 @@ PMIC_STATUS pmic_rtc_event_sub(t_rtc_int event, void *callback)
 	CHECK_ERROR(pmic_rtc_event(event, callback, true));
 	return PMIC_SUCCESS;
 }
+
 EXPORT_SYMBOL(pmic_rtc_event_sub);
 
 /*!
@@ -316,6 +360,7 @@ PMIC_STATUS pmic_rtc_event_unsub(t_rtc_int event, void *callback)
 	CHECK_ERROR(pmic_rtc_event(event, callback, false));
 	return PMIC_SUCCESS;
 }
+
 EXPORT_SYMBOL(pmic_rtc_event_unsub);
 
 /* Called without the kernel lock - fine */
@@ -397,12 +442,14 @@ static int pmic_rtc_ioctl(struct inode *inode, struct file *file,
 	case PMIC_RTC_ALARM_REGISTER:
 		alarm_callback.func = callback_alarm_asynchronous;
 		alarm_callback.param = NULL;
-		CHECK_ERROR(pmic_event_subscribe(EVENT_RTC, alarm_callback));
+		CHECK_ERROR(mcu_pmic_rtc_event_subscribe
+			    (EVENT_RTC, alarm_callback));
 		break;
 	case PMIC_RTC_ALARM_UNREGISTER:
 		alarm_callback.func = callback_alarm_asynchronous;
 		alarm_callback.param = NULL;
-		CHECK_ERROR(pmic_event_unsubscribe(EVENT_RTC, alarm_callback));
+		CHECK_ERROR(mcu_pmic_rtc_event_unsubscribe
+			    (EVENT_RTC, alarm_callback));
 		pmic_rtc_done = false;
 		break;
 	default:
@@ -492,15 +539,22 @@ int pmic_rtc_loaded(void)
 }
 EXPORT_SYMBOL(pmic_rtc_loaded);
 
-
 static int pmic_rtc_remove(struct platform_device *pdev)
 {
 	class_device_destroy(pmic_rtc_class, MKDEV(pmic_rtc_major, 0));
 	class_destroy(pmic_rtc_class);
 	unregister_chrdev(pmic_rtc_major, MCU_PMIC_RTC_NAME);
+	free_irq(mcu_pmic_rtc_data.irq, pdev);
 	return 0;
 }
 
+static irqreturn_t mcu_pmic_rtc_alarm_handler(int irq, void *dev_id)
+{
+	schedule_work(&rtc_alarm_event);
+	return IRQ_HANDLED;
+
+}
+
 static int pmic_rtc_probe(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -524,6 +578,15 @@ static int pmic_rtc_probe(struct platform_device *pdev)
 		ret = PTR_ERR(temp_class);
 		goto err_out2;
 	}
+	mcu_pmic_rtc_data.irq = platform_get_irq(pdev, 0);
+	if (mcu_pmic_rtc_data.irq >= 0) {
+		if (request_irq(mcu_pmic_rtc_data.irq,
+				mcu_pmic_rtc_alarm_handler, IRQF_SHARED,
+				pdev->name, pdev) < 0) {
+			dev_warn(&pdev->dev, "interrupt not available.\n");
+			mcu_pmic_rtc_data.irq = -1;
+		}
+	}
 
 	pmic_rtc_detected = 1;
 
@@ -564,7 +627,7 @@ static void __exit pmic_rtc_exit(void)
  * Module entry points
  */
 
-subsys_initcall(pmic_rtc_init);
+module_init(pmic_rtc_init);
 module_exit(pmic_rtc_exit);
 
 MODULE_DESCRIPTION("Pmic_rtc driver");
-- 
1.5.4.4

