From 9cdb554cee47342d6f6199c6c489e176d0dc8021 Mon Sep 17 00:00:00 2001
From: Raj Rajasekaran <b10872@freescale.com>
Date: Tue, 8 Jul 2008 12:38:22 -0500
Subject: [PATCH]     ENGR00081856: Add SCC2 and RNGC support for i.MX37.

    Integrated SCC2 & RNGC driver changes, delivered by PISA,for i.MX37.

    Signed-off-by: Raj Rajasekaran <b10872@freescale.com>

    Acked-by: Rob Herring <r.herring@freecale.com>
---
 arch/arm/mach-mx37/clock.c                         |   10 +
 arch/arm/mach-mx37/devices.c                       |   14 +
 drivers/mxc/security/Kconfig                       |    2 +-
 drivers/mxc/security/mxc_scc.c                     |  396 ++--
 drivers/mxc/security/mxc_scc_internals.h           |   78 +-
 drivers/mxc/security/rng/Makefile                  |    5 +-
 drivers/mxc/security/rng/include/rng_driver.h      |    4 +-
 drivers/mxc/security/rng/include/rng_internals.h   |  114 +-
 drivers/mxc/security/rng/include/rng_rngc.h        |  179 +-
 drivers/mxc/security/rng/include/shw_driver.h      | 2111 +++++++----
 drivers/mxc/security/rng/include/shw_internals.h   |   16 +-
 drivers/mxc/security/rng/rng_driver.c              |  342 ++-
 drivers/mxc/security/rng/shw_driver.c              | 1382 +++++++-
 drivers/mxc/security/rng/shw_memory_mapper.c       |  213 ++
 drivers/mxc/security/sahara2/fsl_shw_keystore.c    |  765 ++++
 .../mxc/security/sahara2/include/fsl_platform.h    |    8 +-
 drivers/mxc/security/sahara2/include/fsl_shw.h     | 3698 +++++++++++---------
 .../security/sahara2/include/fsl_shw_keystore.h    |  470 +++
 drivers/mxc/security/sahara2/include/linux_port.h  |  848 +++--
 drivers/mxc/security/sahara2/include/portable_os.h |  505 ++-
 drivers/mxc/security/scc2_driver.c                 | 1945 ++++-------
 drivers/mxc/security/scc2_internals.h              |   73 +-
 include/asm-arm/arch-mxc/mx37.h                    |   34 +-
 include/asm-arm/arch-mxc/mxc_scc.h                 |    6 +-
 include/asm-arm/arch-mxc/mxc_scc2_driver.h         | 1072 +++---
 include/asm-arm/arch-mxc/mxc_scc_driver.h          |   90 +-
 26 files changed, 8940 insertions(+), 5440 deletions(-)

diff --git a/arch/arm/mach-mx37/clock.c b/arch/arm/mach-mx37/clock.c
index 57820e8..4649fa0 100644
--- a/arch/arm/mach-mx37/clock.c
+++ b/arch/arm/mach-mx37/clock.c
@@ -1762,6 +1762,15 @@ static struct clk ata_clk = {
 	.disable = _clk_disable,
 };
 
+static struct clk rng_clk = {
+    .name = "rng_clk",
+    .parent = &ipg_clk,
+    .enable = _clk_enable,
+    .enable_reg = MXC_CCM_CCGR3,
+    .enable_shift = MXC_CCM_CCGR3_CG5_OFFSET,
+    .disable = _clk_disable,
+};
+
 static struct clk *mxc_clks[] = {
 	&osc_clk,
 	&ckih_clk,
@@ -1845,6 +1854,7 @@ static struct clk *mxc_clks[] = {
 	&pgc_clk,
 	&rtc_clk,
 	&ata_clk,
+	&rng_clk,
 };
 
 static void clk_tree_init(void)
diff --git a/arch/arm/mach-mx37/devices.c b/arch/arm/mach-mx37/devices.c
index e11d45a..9c55d52 100644
--- a/arch/arm/mach-mx37/devices.c
+++ b/arch/arm/mach-mx37/devices.c
@@ -216,6 +216,7 @@ static inline void mxc_init_scc(void)
 	uint32_t *MAP_base;
 	uint8_t i;
 	uint32_t partition_no;
+	uint32_t scc_partno;
 	void *scm_ram_base;
 	void *scc_base;
 
@@ -261,6 +262,19 @@ static inline void mxc_init_scc(void)
 		    SCM_PERM_TH_READ | SCM_PERM_TH_WRITE;
 
 	}
+
+	/*Freeing 2 partitions for SCC2*/
+	scc_partno = 9 - (SCC_IRAM_SIZE / SZ_8K);
+	for (partition_no = scc_partno; partition_no < 9; partition_no++) {
+		reg_value = ((partition_no << SCM_ZCMD_PART_SHIFT) &
+			     SCM_ZCMD_PART_MASK) | ((0x03 <<
+						     SCM_ZCMD_CCMD_SHIFT)
+						    & SCM_ZCMD_CCMD_MASK);
+		__raw_writel(reg_value, scc_base + SCM_ZCMD_REG);
+
+			 while ((__raw_readl(scc_base + SCM_STATUS_REG) &
+				 SCM_STATUS_SRS_READY) != SCM_STATUS_SRS_READY);
+	}
 	iounmap(scm_ram_base);
 	iounmap(scc_base);
 	printk(KERN_INFO "IRAM READY\n");
diff --git a/drivers/mxc/security/Kconfig b/drivers/mxc/security/Kconfig
index f41a84a..7e29459 100644
--- a/drivers/mxc/security/Kconfig
+++ b/drivers/mxc/security/Kconfig
@@ -15,7 +15,7 @@ config SCC_DEBUG
 
 config MXC_SECURITY_SCC2
         tristate "MXC SCC2 Driver"
-        depends on ARCH_MXC92323
+        depends on ARCH_MX37
         default n
         ---help---
           This module contains the core API's for accessing the SCC2 module.
diff --git a/drivers/mxc/security/mxc_scc.c b/drivers/mxc/security/mxc_scc.c
index 3e0efcb..7387a52 100644
--- a/drivers/mxc/security/mxc_scc.c
+++ b/drivers/mxc/security/mxc_scc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -48,11 +48,35 @@
  * @ingroup MXCSCC
  */
 
-#include <linux/platform_device.h>
+#include "sahara2/include/portable_os.h"
+#include "mxc_scc_internals.h"
+
 #include <linux/delay.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
+
+#include <linux/device.h>
+#include <asm/arch/clock.h>
+#include <linux/device.h>
+
+#else
+
+#include <linux/platform_device.h>
 #include <linux/clk.h>
-#include "mxc_scc_internals.h"
+#include <linux/err.h>
+
+#endif
 
+/*!
+ * This is the set of errors which signal that access to the SCM RAM has
+ * failed or will fail.
+ */
+#define SCM_ACCESS_ERRORS                                                  \
+       (SCM_ERR_USER_ACCESS | SCM_ERR_ILLEGAL_ADDRESS |                    \
+        SCM_ERR_ILLEGAL_MASTER | SCM_ERR_CACHEABLE_ACCESS |                \
+        SCM_ERR_UNALIGNED_ACCESS | SCM_ERR_BYTE_ACCESS |                   \
+        SCM_ERR_INTERNAL_ERROR | SCM_ERR_SMN_BLOCKING_ACCESS |             \
+        SCM_ERR_CIPHERING | SCM_ERR_ZEROIZING | SCM_ERR_BUSY)
 
 /******************************************************************************
  *
@@ -77,9 +101,7 @@
  * #SCC_WRITE_REGISTER macros and their ilk.  All dereferences must be
  * 32 bits wide.
  */
-//#define static
-static void *scc_base;
-static struct clk *scc_clk;
+static volatile void *scc_base;
 
 /*! Array to hold function pointers registered by
     #scc_monitor_security_failure() and processed by
@@ -89,7 +111,7 @@ static void (*scc_callbacks[SCC_CALLBACK_SIZE]) (void);
 /*! Structure returned by #scc_get_configuration() */
 static scc_config_t scc_configuration = {
 	.driver_major_version = SCC_DRIVER_MAJOR_VERSION_1,
-	.driver_minor_version = SCC_DRIVER_MINOR_VERSION_5,
+	.driver_minor_version = SCC_DRIVER_MINOR_VERSION_6,
 	.scm_version = -1,
 	.smn_version = -1,
 	.block_size_bytes = -1,
@@ -135,91 +157,20 @@ static uint32_t scc_memory_size_bytes;
 /*! Calculated once for quick reference to size of SCM address space */
 static uint32_t scm_highest_memory_address;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18))
+/*! Pointer to SCC's clock information.  Initialized during scc_init(). */
+static struct clk *scc_clk = NULL;
+#endif
+
 /*! The lookup table for an 8-bit value.  Calculated once
  * by #scc_init_ccitt_crc().
  */
 static uint16_t scc_crc_lookup_table[256];
-uint8_t make_vpu_partition(void);
 
 /*! Fixed padding for appending to plaintext to fill out a block */
 static uint8_t scc_block_padding[8] =
     { SCC_DRIVER_PAD_CHAR, 0, 0, 0, 0, 0, 0, 0 };
 
-
-/*!
- * This is the set of errors which signal that access to the SCM RAM has
- * failed or will fail.
- */
-#define SCM_ACCESS_ERRORS                                                  \
-       (SCM_ERR_USER_ACCESS | SCM_ERR_ILLEGAL_ADDRESS |                    \
-        SCM_ERR_ILLEGAL_MASTER | SCM_ERR_CACHEABLE_ACCESS |                \
-        SCM_ERR_UNALIGNED_ACCESS | SCM_ERR_BYTE_ACCESS |                   \
-        SCM_ERR_INTERNAL_ERROR | SCM_ERR_SMN_BLOCKING_ACCESS |             \
-        SCM_ERR_CIPHERING | SCM_ERR_ZEROIZING | SCM_ERR_BUSY)
-
-/*!
- * This function is called to put the SCC in a low power state.
- *
- * @param   pdev  the device structure used to give information on which SCC
- *                device (0 through 3 channels) to suspend
- * @param   state the power state the device is entering
- *
- * @return  The function always returns 0.
- */
-static int mxc_scc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	pr_debug(" MXC SCC driver suspend function\n");
-	/* Turn off clock */
-	clk_disable(scc_clk);
-	return 0;
-}
-
-/*!
- * This function is called to resume the SCC from a low power state.
- *
- * @param   pdev  the device structure used to give information on which SCC
- *                device (0 through 3 channels) to suspend
- *
- * @return  The function always returns 0.
- */
-static int mxc_scc_resume(struct platform_device *pdev)
-{
-	pr_debug("MXC SCC driver resume function\n");
-	/* Turn on clock */
-	clk_enable(scc_clk);
-
-	return 0;
-}
-
-static int mxc_scc_probe(struct platform_device *pdev);
-static int mxc_scc_remove(struct platform_device *pdev);
-/*!
- * This structure contains pointers to the power management callback functions.
- */
-static struct platform_driver mxc_scc_driver = {
-	.driver = {
-		   .name = "mxc_scc",
-		   .bus = &platform_bus_type,
-                   .owner = THIS_MODULE,
-		   },
-	.probe = mxc_scc_probe,
-        .remove = mxc_scc_remove,
-	.suspend = mxc_scc_suspend,
-	.resume = mxc_scc_resume,
-};
-
-#undef static
-/*!
- * Registering the SCC driver
- *
- */
-static int scc_init(void)
-{
-	int ret;
-	ret =  platform_driver_register(&mxc_scc_driver);
-	return ret;
-}
-
 /******************************************************************************
  *
  *  Function Implementations - Externally Accessible
@@ -227,7 +178,7 @@ static int scc_init(void)
  *****************************************************************************/
 
 /*****************************************************************************/
-/* fn mxc_scc_probe()                                                             */
+/* fn scc_init()                                                             */
 /*****************************************************************************/
 /*!
  *  Initialize the driver at boot time or module load time.
@@ -245,15 +196,12 @@ static int scc_init(void)
  *
  *  The availability fuse may be checked, depending on platform.
  */
-static int mxc_scc_probe(struct platform_device *pdev)
+static int scc_init(void)
 {
 	uint32_t smn_status;
 	int i;
 	int return_value = -EIO;	/* assume error */
-	/* Enable the SCC clocks  */
-	pr_debug(KERN_ALERT "SCC: Enabling the SCC CLK ... \n");
-	scc_clk = clk_get(NULL, "scc_clk");
-	clk_enable(scc_clk);
+
 	if (scc_availability == SCC_STATUS_INITIAL) {
 
 		/* Set this until we get an initial reading */
@@ -266,27 +214,43 @@ static int mxc_scc_probe(struct platform_device *pdev)
 		for (i = 0; i < SCC_CALLBACK_SIZE; i++) {
 			scc_callbacks[i] = 0;
 		}
-
 		/* Initialize key slots */
 		for (i = 0; i < SCC_KEY_SLOTS; i++) {
 			scc_key_info[i].offset = i * SCC_KEY_SLOT_SIZE;
 			scc_key_info[i].status = 0;	/* unassigned */
 		}
 
+		/* Enable the SCC clock on platforms where it is gated */
+#ifndef SCC_CLOCK_NOT_GATED
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
+		mxc_clks_enable(SCC_CLK);
+#else
+
+		scc_clk = clk_get(NULL, "scc_clk");
+		if (scc_clk != ERR_PTR(ENOENT)) {
+			clk_enable(scc_clk);
+		}
+#endif				/* LINUX_VERSION_CODE */
+
+#else
+#warning SCC clock initialization skipped, not gated on this archetecture.
+
+#endif				/* SCC_CLOCK_NOT_GATED */
+
 		/* See whether there is an SCC available */
 		if (0 && !SCC_ENABLED()) {
-			printk
-			    ("SCC: Fuse for SCC is set to disabled.  Exiting.\n");
+			os_printk(KERN_ERR
+				  "SCC: Fuse for SCC is set to disabled.  Exiting.\n");
 		} else {
 			/* Map the SCC (SCM and SMN) memory on the internal bus into
 			   kernel address space */
-
-			scc_base = ioremap_nocache(SCC_BASE, SCC_ADDRESS_RANGE);
+			scc_base = (void *)IO_ADDRESS(SCC_BASE);
 
 			/* If that worked, we can try to use the SCC */
 			if (scc_base == NULL) {
-				pr_debug
-				    ("SCC: Register mapping failed.  Exiting.\n");
+				os_printk(KERN_ERR
+					  "SCC: Register mapping failed.  Exiting.\n");
 			} else {
 				/* Get SCM into 'clean' condition w/interrupts cleared &
 				   disabled */
@@ -307,30 +271,31 @@ static int mxc_scc_probe(struct platform_device *pdev)
 				/* Try to set up interrupt handler(s) */
 				if (scc_availability == SCC_STATUS_OK) {
 					if (setup_interrupt_handling() != 0) {
-			/**
-                         * The error could be only that the SCM interrupt was
-                         * not set up.  This interrupt is always masked, so
-                         * that is not an issue.
-                         *
-                         * The SMN's interrupt may be shared on that line, it
-                         * may be separate, or it may not be wired.  Do what
-                         * is necessary to check its status.
-                         *
-                         * Although the driver is coded for possibility of not
-                         * having SMN interrupt, the fact that there is one
-                         * means it should be available and used.
-                         */
+						unsigned condition;
+
+						/*!
+						 * The error could be only that the SCM interrupt was
+						 * not set up.  This interrupt is always masked, so
+						 * that is not an issue.
+						 *
+						 * The SMN's interrupt may be shared on that line, it
+						 * may be separate, or it may not be wired.  Do what
+						 * is necessary to check its status.
+						 *
+						 * Although the driver is coded for possibility of not
+						 * having SMN interrupt, the fact that there is one
+						 * means it should be available and used.
+						 */
 #ifdef USE_SMN_INTERRUPT
-						if (!smn_irq_set) {	/* Separate. Check SMN binding */
+						condition = !smn_irq_set;	/* Separate. Check SMN binding */
 #elif !defined(NO_SMN_INTERRUPT)
-						if (!scm_irq_set) {	/* Shared. Check SCM binding */
+						condition = !scm_irq_set;	/* Shared. Check SCM binding */
 #else
-						if (FALSE) {	/*  SMN not wired at all.  Ignore. */
+						condition = FALSE;	/*  SMN not wired at all.  Ignore. */
 #endif
-							/* setup was not able to set up SMN interrupt */
-							scc_availability =
-							    SCC_STATUS_UNIMPLEMENTED;
-						}
+						/* setup was not able to set up SMN interrupt */
+						scc_availability =
+						    SCC_STATUS_UNIMPLEMENTED;
 					}	/* interrupt handling returned non-zero */
 				}	/* availability is OK */
 				if (scc_availability == SCC_STATUS_OK) {
@@ -354,27 +319,27 @@ static int mxc_scc_probe(struct platform_device *pdev)
 		 */
 		if (scc_availability == SCC_STATUS_CHECKING ||
 		    scc_availability == SCC_STATUS_UNIMPLEMENTED) {
-			mxc_scc_remove(pdev);
+			scc_cleanup();
 		} else {
 			return_value = 0;	/* All is well */
 		}
 	}
 	/* ! STATUS_INITIAL */
 	pr_debug("SCC: Driver Status is %s\n",
-	       (scc_availability == SCC_STATUS_INITIAL) ? "INITIAL" :
-	       (scc_availability == SCC_STATUS_CHECKING) ? "CHECKING" :
-	       (scc_availability ==
-		SCC_STATUS_UNIMPLEMENTED) ? "UNIMPLEMENTED" : (scc_availability
-							       ==
-							       SCC_STATUS_OK) ?
-	       "OK" : (scc_availability ==
-		       SCC_STATUS_FAILED) ? "FAILED" : "UNKNOWN");
+		 (scc_availability == SCC_STATUS_INITIAL) ? "INITIAL" :
+		 (scc_availability == SCC_STATUS_CHECKING) ? "CHECKING" :
+		 (scc_availability ==
+		  SCC_STATUS_UNIMPLEMENTED) ? "UNIMPLEMENTED"
+		 : (scc_availability ==
+		    SCC_STATUS_OK) ? "OK" : (scc_availability ==
+					     SCC_STATUS_FAILED) ? "FAILED" :
+		 "UNKNOWN");
 
 	return return_value;
-}				/* mxc_scc_probe */
+}				/* scc_init */
 
 /*****************************************************************************/
-/* fn mxc_scc_remove()                                                          */
+/* fn scc_cleanup()                                                          */
 /*****************************************************************************/
 /*!
  * Perform cleanup before driver/module is unloaded by setting the machine
@@ -390,7 +355,7 @@ static int mxc_scc_probe(struct platform_device *pdev)
  * pointers).  Deregister the interrupt handler(s).  Unmap SCC registers.
  *
  */
-static int mxc_scc_remove(struct platform_device *pdev)
+static void scc_cleanup(void)
 {
 	int i;
 
@@ -423,35 +388,37 @@ static int mxc_scc_remove(struct platform_device *pdev)
 
 	/* Deregister SCM interrupt handler */
 	if (scm_irq_set) {
-		free_irq(MXC_INT_SCC_SCM, NULL);
+		free_irq(INT_SCC_SCM, NULL);
 	}
 
 	/* Deregister SMN interrupt handler */
 	if (smn_irq_set) {
 #ifdef USE_SMN_INTERRUPT
-		free_irq(MXC_INT_SCC_SMN, NULL);
+		free_irq(INT_SCC_SMN, NULL);
 #endif
 	}
-	pr_debug("SCC driver cleaned up.\n");
-	return 0;
 
-}				/* mxc_scc_remove */
+	pr_debug("SCC driver cleaned up.\n");
 
-static void scc_cleanup(void)
-{
-	 platform_driver_unregister(&mxc_scc_driver);
-}
+}				/* scc_cleanup */
 
 /*****************************************************************************/
 /* fn scc_get_configuration()                                                */
 /*****************************************************************************/
 scc_config_t *scc_get_configuration(void)
 {
+	/*
+	 * If some other driver calls scc before the kernel does, make sure that
+	 * this driver's initialization is performed.
+	 */
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
 
-    /**
-     * If there is no SCC, yet the driver exists, the value -1 will be in
-     * the #scc_config_t fields for other than the driver versions.
-     */
+	/*!
+	 * If there is no SCC, yet the driver exists, the value -1 will be in
+	 * the #scc_config_t fields for other than the driver versions.
+	 */
 	return &scc_configuration;
 }				/* scc_get_configuration */
 
@@ -463,6 +430,9 @@ scc_return_t scc_zeroize_memories(void)
 	scc_return_t return_status = SCC_RET_FAIL;
 	uint32_t status;
 
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
 
 	if (scc_availability == SCC_STATUS_OK) {
 		unsigned long irq_flags;	/* for IRQ save/restore */
@@ -486,8 +456,7 @@ scc_return_t scc_zeroize_memories(void)
 
 		if (!(status & SCM_ERR_ZEROIZE_FAILED)) {
 			return_status = SCC_RET_OK;
-		}
-		else {
+		} else {
 			pr_debug
 			    ("SCC: Zeroize failed.  SCM Error Status is 0x%08x\n",
 			     status);
@@ -516,6 +485,9 @@ scc_crypt(unsigned long count_in_bytes, uint8_t * data_in,
 {
 	scc_return_t return_code = SCC_RET_FAIL;
 
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
 
 	(void)scc_update_state();	/* in case no interrupt line from SMN */
 
@@ -644,6 +616,9 @@ scc_crypt(unsigned long count_in_bytes, uint8_t * data_in,
 void scc_set_sw_alarm(void)
 {
 
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
 
 	/* Update scc_availability based on current SMN status.  This might
 	 * perform callbacks.
@@ -675,6 +650,9 @@ scc_return_t scc_monitor_security_failure(void callback_func(void))
 	scc_return_t return_status = SCC_RET_TOO_MANY_FUNCTIONS;
 	int function_stored = FALSE;
 
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
 
 	/* Acquire lock of callbacks table.  Could be spin_lock_irq() if this
 	 * routine were just called from base (not interrupt) level
@@ -713,6 +691,9 @@ void scc_stop_monitoring_security_failure(void callback_func(void))
 	unsigned long irq_flags;	/* for IRQ save/restore */
 	int i;
 
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
 
 	/* Acquire lock of callbacks table.  Could be spin_lock_irq() if this
 	 * routine were just called from base (not interrupt) level
@@ -742,6 +723,9 @@ scc_return_t scc_read_register(int register_offset, uint32_t * value)
 	uint32_t smn_status;
 	uint32_t scm_status;
 
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
 
 	/* First layer of protection -- completely unaccessible SCC */
 	if (scc_availability != SCC_STATUS_UNIMPLEMENTED) {
@@ -780,6 +764,9 @@ scc_return_t scc_write_register(int register_offset, uint32_t value)
 	uint32_t smn_status;
 	uint32_t scm_status;
 
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
 
 	/* First layer of protection -- completely unaccessible SCC */
 	if (scc_availability != SCC_STATUS_UNIMPLEMENTED) {
@@ -835,18 +822,20 @@ scc_return_t scc_write_register(int register_offset, uint32_t value)
  *
  * @param irq Channel number for the IRQ. (@c SCC_INT_SMN or @c SCC_INT_SCM).
  * @param dev_id Pointer to the identification of the device.  Ignored.
+ * @param regs Holds the snapshot of the processor's context before the
+ *        processor entered the interrupt.  Ignored.
  */
-static irqreturn_t scc_irq(int irq, void *dev_id)
+static irqreturn_t scc_irq(int irq, void *dev_id, struct pt_regs *regs)
 {
 	uint32_t smn_status;
 	uint32_t scm_status;
 	int handled = 0;	/* assume interrupt isn't from SMN */
 #if defined(USE_SMN_INTERRUPT)
-	int smn_irq = MXC_INT_SCC_SMN;	/* SMN interrupt is on a line by itself */
+	int smn_irq = INT_SCC_SMN;	/* SMN interrupt is on a line by itself */
 #elif defined (NO_SMN_INTERRUPT)
 	int smn_irq = -1;	/* not wired to CPU at all */
 #else
-	int smn_irq = MXC_INT_SCC_SCM;	/* SMN interrupt shares a line with SCM */
+	int smn_irq = INT_SCC_SCM;	/* SMN interrupt shares a line with SCM */
 #endif
 
 	/* Update current state... This will perform callbacks... */
@@ -863,7 +852,7 @@ static irqreturn_t scc_irq(int irq, void *dev_id)
 	scm_status = SCC_READ_REGISTER(SCM_STATUS);
 
 	/* The driver masks interrupts, so this should never happen. */
-	if (irq == MXC_INT_SCC_SCM && scm_status & SCM_STATUS_INTERRUPT_STATUS) {
+	if (irq == INT_SCC_SCM && scm_status & SCM_STATUS_INTERRUPT_STATUS) {
 		/* but if it does, try to prevent it in the future */
 		SCC_WRITE_REGISTER(SCM_INTERRUPT_CTRL,
 				   SCM_INTERRUPT_CTRL_CLEAR_INTERRUPT
@@ -946,8 +935,9 @@ copy_to_scc(const uint8_t * from, uint32_t to, unsigned long count_bytes,
 
 	status = SCC_READ_REGISTER(SCM_ERROR_STATUS) & SCM_ACCESS_ERRORS;
 	if (status != 0) {
-		pr_debug("SCC copy_to_scc(): Error status detected (before copy):"
-		       " %08x\n", status);
+		pr_debug
+		    ("SCC copy_to_scc(): Error status detected (before copy):"
+		     " %08x\n", status);
 		/* clear out errors left behind by somebody else */
 		SCC_WRITE_REGISTER(SCM_ERROR_STATUS, status);
 	}
@@ -1001,7 +991,7 @@ copy_to_scc(const uint8_t * from, uint32_t to, unsigned long count_bytes,
 	status = SCC_READ_REGISTER(SCM_ERROR_STATUS) & SCM_ACCESS_ERRORS;
 	if (status != 0) {
 		pr_debug("SCC copy_to_scc(): Error status detected: %08x\n",
-		       status);
+			 status);
 		/* Clear any/all bits. */
 		SCC_WRITE_REGISTER(SCM_ERROR_STATUS, status);
 	}
@@ -1037,7 +1027,9 @@ copy_from_scc(const uint32_t from, uint8_t * to, unsigned long count_bytes,
 	uint32_t scm_word;
 	uint16_t current_crc = 0;	/* local copy for fast access */
 	uint32_t status;
+
 	pr_debug("SCC: copying %ld bytes from 0x%x.\n", count_bytes, from);
+
 	status = SCC_READ_REGISTER(SCM_ERROR_STATUS) & SCM_ACCESS_ERRORS;
 	if (status != 0) {
 		pr_debug
@@ -1096,7 +1088,7 @@ copy_from_scc(const uint32_t from, uint8_t * to, unsigned long count_bytes,
 	status = SCC_READ_REGISTER(SCM_ERROR_STATUS) & SCM_ACCESS_ERRORS;
 	if (status != 0) {
 		pr_debug("SCC copy_from_scc(): Error status detected: %08x\n",
-		       status);
+			 status);
 		/* Clear any/all bits. */
 		SCC_WRITE_REGISTER(SCM_ERROR_STATUS, status);
 	}
@@ -1137,7 +1129,7 @@ scc_strip_padding(uint8_t * from, unsigned *count_bytes_stripped)
 			break;
 		} else if (*from != 0) {	/* if not marker, check for 0 */
 			pr_debug("SCC: Found non-zero interim pad: 0x%x\n",
-			       *from);
+				 *from);
 			break;
 		}
 	}
@@ -1197,11 +1189,11 @@ static uint32_t scc_update_state(void)
 		} else if (smn_state == SMN_STATE_FAIL) {
 			scc_availability = SCC_STATUS_FAILED;	/* uh oh - unhealthy */
 			scc_perform_callbacks();
-			pr_debug("SCC: SCC went into FAILED mode\n");
+			os_printk(KERN_ERR "SCC: SCC went into FAILED mode\n");
 		} else {
 			/* START, ZEROIZE RAM, HEALTH CHECK, or unknown */
 			scc_availability = SCC_STATUS_UNIMPLEMENTED;	/* unuseable */
-			pr_debug("SCC: SCC declared UNIMPLEMENTED\n");
+			os_printk(KERN_ERR "SCC: SCC declared UNIMPLEMENTED\n");
 		}
 	}
 	/* if availability is initial or ok */
@@ -1217,7 +1209,7 @@ static uint32_t scc_update_state(void)
  * @return   none
  *
  */
-void scc_init_ccitt_crc(void)
+static void scc_init_ccitt_crc(void)
 {
 	int dividend;		/* index for lookup table */
 	uint16_t remainder;	/* partial value for a given dividend */
@@ -1276,7 +1268,7 @@ static uint32_t scc_grab_config_values(void)
 		/* Get SMN status and update scc_availability */
 		smn_status_register = scc_update_state();
 		pr_debug("SCC Driver: SMN status is 0x%08x\n",
-		       smn_status_register);
+			 smn_status_register);
 
 		/* save sizes and versions information for later use */
 		scc_configuration.block_size_bytes = (config_register &
@@ -1286,16 +1278,10 @@ static uint32_t scc_grab_config_values(void)
 		scc_configuration.red_ram_size_blocks = (config_register &
 							 SCM_CFG_RED_SIZE_MASK)
 		    >> SCM_CFG_RED_SIZE_SHIFT;
-#ifdef CONFIG_VIRTIO_SUPPORT
-		scc_configuration.red_ram_size_blocks = 128;
-#endif
 
 		scc_configuration.black_ram_size_blocks = (config_register &
 							   SCM_CFG_BLACK_SIZE_MASK)
 		    >> SCM_CFG_BLACK_SIZE_SHIFT;
-#ifdef CONFIG_VIRTIO_SUPPORT
-		scc_configuration.black_ram_size_blocks = 128;
-#endif
 
 		scc_configuration.scm_version = (config_register
 						 & SCM_CFG_VERSION_ID_MASK)
@@ -1345,10 +1331,10 @@ static int setup_interrupt_handling(void)
 
 #ifdef USE_SMN_INTERRUPT
 	/* Install interrupt service routine for SMN. */
-	smn_error_code = request_irq(MXC_INT_SCC_SMN, scc_irq, 0,
+	smn_error_code = request_irq(INT_SCC_SMN, scc_irq, 0,
 				     SCC_DRIVER_NAME, NULL);
 	if (smn_error_code != 0) {
-		pr_debug
+		os_printk
 		    ("SCC Driver: Error installing SMN Interrupt Handler: %d\n",
 		     smn_error_code);
 	} else {
@@ -1365,15 +1351,15 @@ static int setup_interrupt_handling(void)
 	/*
 	 * Install interrupt service routine for SCM (or both together).
 	 */
-	scm_error_code = request_irq(MXC_INT_SCC_SCM, scc_irq, 0,
+	scm_error_code = request_irq(INT_SCC_SCM, scc_irq, 0,
 				     SCC_DRIVER_NAME, NULL);
 	if (scm_error_code != 0) {
 #ifndef MXC
-		pr_debug
+		os_printk
 		    ("SCC Driver: Error installing SCM Interrupt Handler: %d\n",
 		     scm_error_code);
 #else
-		pr_debug
+		os_printk
 		    ("SCC Driver: Error installing SCC Interrupt Handler: %d\n",
 		     scm_error_code);
 #endif
@@ -1479,7 +1465,8 @@ scc_encrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
 	uint32_t bytes_to_process;	/* multi-purpose byte counter */
 	uint16_t crc = CRC_CCITT_START;	/* running CRC value */
 	crc_t *crc_ptr = NULL;	/* Reset if CRC required */
-	uint32_t scm_location = SCM_RED_MEMORY + SCM_NON_RESERVED_OFFSET;	/* byte address  into SCM RAM */
+	/* byte address into SCM RAM */
+	uint32_t scm_location = SCM_RED_MEMORY + SCM_NON_RESERVED_OFFSET;
 	uint32_t scm_bytes_remaining = scc_memory_size_bytes;	/* free RED RAM */
 	uint8_t padding_buffer[PADDING_BUFFER_MAX_BYTES];	/* CRC+padding holder */
 	unsigned padding_byte_count = 0;	/* Reset if padding required */
@@ -1540,10 +1527,11 @@ scc_encrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
 			    ("SCC: too many ciphertext bytes for space available\n");
 			break;
 		}
+
 		pr_debug("SCC: Starting encryption. %x for %d bytes (%p/%p)\n",
-		       scm_control, bytes_to_process,
-		       (void *)SCC_READ_REGISTER(SCM_RED_START),
-		       (void *)SCC_READ_REGISTER(SCM_BLACK_START));
+			 scm_control, bytes_to_process,
+			 (void *)SCC_READ_REGISTER(SCM_RED_START),
+			 (void *)SCC_READ_REGISTER(SCM_BLACK_START));
 		scm_error_status = scc_do_crypto(bytes_to_process, scm_control);
 		if (scm_error_status != 0) {
 			break;
@@ -1595,7 +1583,8 @@ scc_decrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
 	uint32_t bytes_copied = 0;	/* running total of bytes going to user */
 	uint32_t bytes_to_copy = 0;	/* Number in this encryption 'chunk' */
 	uint16_t crc = CRC_CCITT_START;	/* running CRC value */
-	uint32_t scm_location = SCM_BLACK_MEMORY + SCM_NON_RESERVED_OFFSET;	/* next target for  ctext */
+	/* next target for  ctext */
+	uint32_t scm_location = SCM_BLACK_MEMORY + SCM_NON_RESERVED_OFFSET;
 	unsigned padding_byte_count;	/* number of bytes of padding stripped */
 	uint8_t last_two_blocks[2 * SCC_BLOCK_SIZE_BYTES()];	/* temp */
 	uint32_t scm_error_status = 0;	/* register value */
@@ -1629,7 +1618,7 @@ scc_decrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
 		data_in += bytes_to_copy;	/* move pointer */
 
 		pr_debug("SCC: Starting decryption of %d bytes.\n",
-		       bytes_to_copy);
+			 bytes_to_copy);
 
 		/*  Do the work, wait for completion */
 		scm_error_status = scc_do_crypto(bytes_to_copy, scm_control);
@@ -1665,7 +1654,7 @@ scc_decrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
 			data_in += bytes_to_copy;	/* move pointer */
 
 			pr_debug("SCC: Finishing decryption (%d bytes).\n",
-			       bytes_to_copy);
+				 bytes_to_copy);
 
 			/*  Do the work, wait for completion */
 			scm_error_status =
@@ -1759,11 +1748,15 @@ scc_alloc_slot(uint32_t value_size_bytes, uint64_t owner_id, uint32_t * slot)
 	scc_return_t status = SCC_RET_FAIL;
 	unsigned long irq_flags;
 
+	if (scc_availability != SCC_STATUS_OK) {
+		goto out;
+	}
+
 	/* ACQUIRE LOCK to prevent others from using SCC crypto */
 	spin_lock_irqsave(&scc_crypto_lock, irq_flags);
 
-	pr_debug("SCC: Allocating %d-byte slot for 0x%Lx\n", value_size_bytes,
-	       owner_id);
+	pr_debug("SCC: Allocating %d-byte slot for 0x%Lx\n",
+		 value_size_bytes, owner_id);
 
 	if ((value_size_bytes != 0) && (value_size_bytes <= SCC_MAX_KEY_SIZE)) {
 		int i;
@@ -1782,22 +1775,28 @@ scc_alloc_slot(uint32_t value_size_bytes, uint64_t owner_id, uint32_t * slot)
 		if (status != SCC_RET_OK) {
 			status = SCC_RET_INSUFFICIENT_SPACE;
 		} else {
-			pr_debug("SCC: Allocated slot %d (0x%Lx)\n", i, owner_id);
+			pr_debug("SCC: Allocated slot %d (0x%Lx)\n", i,
+				 owner_id);
 		}
 	}
 
 	spin_unlock_irqrestore(&scc_crypto_lock, irq_flags);
 
+      out:
 	return status;
 }
 
 /*****************************************************************************/
 /* fn verify_slot_access()                                                   */
 /*****************************************************************************/
-static inline scc_return_t verify_slot_access(uint64_t owner_id, uint32_t slot,
-					      uint32_t access_len)
+inline static scc_return_t
+verify_slot_access(uint64_t owner_id, uint32_t slot, uint32_t access_len)
 {
-	register scc_return_t status;
+	scc_return_t status = SCC_RET_FAIL;
+
+	if (scc_availability != SCC_STATUS_OK) {
+		goto out;
+	}
 
 	if ((slot < SCC_KEY_SLOTS) && scc_key_info[slot].status
 	    && (scc_key_info[slot].owner_id == owner_id)
@@ -1809,17 +1808,24 @@ static inline scc_return_t verify_slot_access(uint64_t owner_id, uint32_t slot,
 			pr_debug("SCC: Verify on bad slot (%d) failed\n", slot);
 		} else if (scc_key_info[slot].status) {
 			pr_debug("SCC: Verify on slot %d failed (%Lx) \n", slot,
-			       owner_id);
+				 owner_id);
 		} else {
-			pr_debug("SCC: Verify on slot %d failed: not allocated\n",
-			       slot);
+			pr_debug
+			    ("SCC: Verify on slot %d failed: not allocated\n",
+			     slot);
 		}
-		status = SCC_RET_FAIL;
 	}
 
+      out:
 	return status;
 }
 
+scc_return_t
+scc_verify_slot_access(uint64_t owner_id, uint32_t slot, uint32_t access_len)
+{
+	return verify_slot_access(owner_id, slot, access_len);
+}
+
 /*****************************************************************************/
 /* fn scc_dealloc_slot()                                                     */
 /*****************************************************************************/
@@ -1892,8 +1898,8 @@ scc_load_slot(uint64_t owner_id, uint32_t slot, uint8_t * key_data,
 					SCM_RED_MEMORY +
 					scc_key_info[slot].offset, key_length,
 					NULL)) {
-				pr_debug
-				    ("SCC: RED copy_to_scc() failed for scc_load_slot()\n");
+				pr_debug("SCC: RED copy_to_scc() failed for"
+					 " scc_load_slot()\n");
 			} else {
 				status = SCC_RET_OK;
 			}
@@ -1948,7 +1954,7 @@ scc_return_t scc_encrypt_slot(uint64_t owner_id, uint32_t slot,
 
 		if (crypto_status != 0) {
 			pr_debug("SCM encrypt red crypto failure: 0x%x\n",
-			       crypto_status);
+				 crypto_status);
 		} else {
 
 			/* Give blob back to caller */
@@ -2017,7 +2023,7 @@ scc_return_t scc_decrypt_slot(uint64_t owner_id, uint32_t slot,
 
 		if (crypto_status != 0) {
 			pr_debug("SCM decrypt black crypto failure: 0x%x\n",
-			       crypto_status);
+				 crypto_status);
 		} else {
 			status = SCC_RET_OK;
 		}
@@ -2063,10 +2069,6 @@ scc_get_slot_info(uint64_t owner_id, uint32_t slot, uint32_t * address,
 
 	return status;
 }
-uint8_t make_vpu_partition() {
-	printk(KERN_INFO"No VPU partition allocated\n");
-	return 0;
-}
 
 /*****************************************************************************/
 /* fn scc_wait_completion()                                                  */
@@ -2077,7 +2079,7 @@ uint8_t make_vpu_partition() {
  *
  * @internal
  *
- * Crypto under 230 or so bytes is done after the first loop, all
+ * On a Tahiti, crypto under 230 or so bytes is done after the first loop, all
  * the way up to five sets of spins for 1024 bytes.  (8- and 16-byte functions
  * are done when we first look.  Zeroizing takes one pass around.
  */
@@ -2087,8 +2089,7 @@ static void scc_wait_completion(void)
 
 	/* check for completion by polling */
 	while (!is_cipher_done() && (i++ < SCC_CIPHER_MAX_POLL_COUNT)) {
-		/* kill time if loop not optimized away */
-		udelay(1000);
+		udelay(10);
 	}
 	pr_debug("SCC: Polled DONE %d times\n", i);
 }				/* scc_wait_completion() */
@@ -2258,7 +2259,7 @@ static uint32_t dbg_scc_read_register(uint32_t offset)
 {
 	uint32_t value;
 
-	value = __raw_readl(scc_base + offset);
+	value = readl(scc_base + offset);
 
 #ifndef SCC_RAM_DEBUG		/* print no RAM references */
 	if ((offset < SCM_RED_MEMORY) || (offset >= scm_highest_memory_address)) {
@@ -2291,7 +2292,8 @@ static void dbg_scc_write_register(uint32_t offset, uint32_t value)
 	}
 #endif
 
-	(void)__raw_writel(value, scc_base + offset);
+	(void)writel(value, scc_base + offset);
 }
 
 #endif				/* SCC_REGISTER_DEBUG */
+
diff --git a/drivers/mxc/security/mxc_scc_internals.h b/drivers/mxc/security/mxc_scc_internals.h
index e19cbd4..d097a9a 100644
--- a/drivers/mxc/security/mxc_scc_internals.h
+++ b/drivers/mxc/security/mxc_scc_internals.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -49,13 +49,27 @@
 #include <asm/arch/iim.h>
 #include <asm/arch/mxc_scc.h>
 
+/* TODO: The define for SCC_FUSE seems to be missing from some archetectures.
+ *       As a workaround, assume that the SCC has not been disabled. On at
+ *       least one it is defined as:
+ *
+ *       #define SCC_FUSE IO_ADDRESS(IIM_BASE_ADDR + MXC_IIMHWV1)
+ */
+
+#if 1
+
+#define SCC_ENABLED() (1)
+
+#else
+
 /*!
  * This macro is used to determine whether the SCC is enabled/available
  * on the platform.  This macro may need to be ported.
  */
-#define SCC_FUSE IO_ADDRESS(IIM_BASE_ADDR + MXC_IIMHWV1)
 #define SCC_ENABLED() ((SCC_FUSE & MXC_IIMHWV1_SCC_DISABLE) == 0)
 
+#endif
+
 /*!
  * Turn on generation of run-time operational, debug, and error messages
  */
@@ -144,7 +158,7 @@
 /*!
  * @def SCC_READ_REGISTER
  * Read a 32-bit value from an SCC register.  Macro which depends upon
- * #scc_base.  Linux __raw_readl()/__raw_writel() macros operate on 32-bit quantities, as
+ * #scc_base.  Linux readl()/writel() macros operate on 32-bit quantities, as
  * do SCC register reads/writes.
  *
  * @param     offset  Register offset within SCC.
@@ -159,7 +173,7 @@
 
 /*!
  * Write a 32-bit value to an SCC register.  Macro depends upon #scc_base.
- * Linux __raw_readl()/__raw_writel() macros operate on 32-bit quantities, as do SCC
+ * Linux readl()/writel() macros operate on 32-bit quantities, as do SCC
  * register reads/writes.
  *
  * @param   offset  Register offset within SCC.
@@ -230,6 +244,23 @@
 /*! Name of the driver.  Used (on Linux, anyway) when registering interrupts */
 #define SCC_DRIVER_NAME "scc"
 
+/* Port -- these symbols are defined in Linux 2.6 and later.  They are defined
+ * here for backwards compatibility because this started life as a 2.4
+ * driver, and as a guide to portation to other platforms.
+ */
+
+#if !defined(LINUX_VERSION_CODE) || LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+
+#define irqreturn_t void	/* Return type of an interrupt handler */
+
+#define IRQ_HANDLED		/* Would be '1' for handled -- as in return IRQ_HANDLED; */
+
+#define IRQ_NONE		/* would be '0' for not handled -- as in return IRQ_NONE; */
+
+#define IRQ_RETVAL(x)		/* Return x==0 (not handled) or non-zero (handled) */
+
+#endif				/* LINUX earlier than 2.5 */
+
 /* These are nice to have around */
 #ifndef FALSE
 #define FALSE 0
@@ -265,7 +296,15 @@ static int scc_init(void);
 static void scc_cleanup(void);
 
 /* Forward defines of internal functions */
-static irqreturn_t scc_irq(int irq, void *dev_id);
+static irqreturn_t scc_irq(int irq, void *dev_id, struct pt_regs *regs);
+/*! Perform callbacks registered by #scc_monitor_security_failure().
+ *
+ *  Make sure callbacks only happen once...  Since there may be some reason why
+ *  the interrupt isn't generated, this routine could be called from base(task)
+ *  level.
+ *
+ *  One at a time, go through #scc_callbacks[] and call any non-null pointers.
+ */
 static void scc_perform_callbacks(void);
 static uint32_t copy_to_scc(const uint8_t * from, uint32_t to,
 			    unsigned long count_bytes, uint16_t * crc);
@@ -277,9 +316,34 @@ static uint32_t scc_update_state(void);
 static void scc_init_ccitt_crc(void);
 static uint32_t scc_grab_config_values(void);
 static int setup_interrupt_handling(void);
+/*!
+ * Perform an encryption on the input.  If @c verify_crc is true, a CRC must be
+ * calculated on the plaintext, and appended, with padding, before computing
+ * the ciphertext.
+ *
+ * @param[in]     count_in_bytes  Count of bytes of plaintext
+ * @param[in]     data_in         Pointer to the plaintext
+ * @param[in]     scm_control     Bit values for the SCM_CONTROL register
+ * @param[in,out] data_out        Pointer for storing ciphertext
+ * @param[in]     add_crc         Flag for computing CRC - 0 no, else yes
+ * @param[in,out] count_out_bytes Number of bytes available at @c data_out
+ */
 static scc_return_t scc_encrypt(uint32_t count_in_bytes, uint8_t * data_in,
 				uint32_t scm_control, uint8_t * data_out,
 				int add_crc, unsigned long *count_out_bytes);
+/*!
+ * Perform a decryption on the input.  If @c verify_crc is true, the last block
+ * (maybe the two last blocks) is special - it should contain a CRC and
+ * padding.  These must be stripped and verified.
+ *
+ * @param[in]     count_in_bytes  Count of bytes of ciphertext
+ * @param[in]     data_in         Pointer to the ciphertext
+ * @param[in]     scm_control     Bit values for the SCM_CONTROL register
+ * @param[in,out] data_out        Pointer for storing plaintext
+ * @param[in]     verify_crc      Flag for running CRC - 0 no, else yes
+ * @param[in,out] count_out_bytes Number of bytes available at @c data_out
+
+ */
 static scc_return_t scc_decrypt(uint32_t count_in_bytes, uint8_t * data_in,
 				uint32_t scm_control, uint8_t * data_out,
 				int verify_crc, unsigned long *count_out_bytes);
@@ -289,7 +353,7 @@ static scc_return_t check_register_accessible(uint32_t offset,
 					      uint32_t smn_status,
 					      uint32_t scm_status);
 static scc_return_t check_register_offset(uint32_t offset);
-uint8_t make_vpu_partition(void);
+/*uint8_t make_vpu_partition(void);*/
 
 #ifdef SCC_REGISTER_DEBUG
 static uint32_t dbg_scc_read_register(uint32_t offset);
@@ -311,7 +375,7 @@ EXPORT_SYMBOL(scc_load_slot);
 EXPORT_SYMBOL(scc_encrypt_slot);
 EXPORT_SYMBOL(scc_decrypt_slot);
 EXPORT_SYMBOL(scc_get_slot_info);
-EXPORT_SYMBOL(make_vpu_partition);
+/*EXPORT_SYMBOL(make_vpu_partition);*/
 
 /* Tell Linux where to invoke driver at boot/module load time */
 module_init(scc_init);
diff --git a/drivers/mxc/security/rng/Makefile b/drivers/mxc/security/rng/Makefile
index 7365e7d..9f54a92 100644
--- a/drivers/mxc/security/rng/Makefile
+++ b/drivers/mxc/security/rng/Makefile
@@ -25,5 +25,8 @@ endif
 
 EXTRA_CFLAGS += -Idrivers/mxc/security/rng/include -Idrivers/mxc/security/sahara2/include
 
+obj-$(CONFIG_MXC_SECURITY_RNG)	+= shw.o
+shw-objs := shw_driver.o shw_memory_mapper.o ../sahara2/fsl_shw_keystore.o
+
 obj-$(CONFIG_MXC_SECURITY_RNG)	+= rng.o
-rng-objs :=	rng_driver.o shw_driver.o
+rng-objs :=	rng_driver.o
diff --git a/drivers/mxc/security/rng/include/rng_driver.h b/drivers/mxc/security/rng/include/rng_driver.h
index 5089a08..01e2b55 100644
--- a/drivers/mxc/security/rng/include/rng_driver.h
+++ b/drivers/mxc/security/rng/include/rng_driver.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -82,7 +82,7 @@ typedef enum rng_return {
  * data_local to data_user) will get made if status was good.
  */
 typedef struct rng_work_entry {
-	struct shw_queue_entry hdr;	/*!< Standards SHW queue info.  */
+	struct shw_queue_entry_t hdr;	/*!< Standards SHW queue info.  */
 	uint32_t length;	/*!< Number of bytes still needed to satisfy request. */
 	uint32_t *data_local;	/*!< Where data from RNG FIFO gets placed. */
 	uint8_t *data_user;	/*!< Ultimate target of data.  */
diff --git a/drivers/mxc/security/rng/include/rng_internals.h b/drivers/mxc/security/rng/include/rng_internals.h
index 73251e9..7704458 100644
--- a/drivers/mxc/security/rng/include/rng_internals.h
+++ b/drivers/mxc/security/rng/include/rng_internals.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007777777 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -31,8 +31,6 @@
 #include "shw_driver.h"
 #include "rng_driver.h"
 
-#include <asm/arch/mxc_scc_driver.h>
-
 /*! @defgroup rngcompileflags RNG Compile Flags
  *
  * These are flags which are used to configure the RNG driver at compilation
@@ -257,12 +255,12 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
  */
 #define RNG_CHECK_WRITE 1
 
+/*! Interrupt number for driver. */
+#define INT_RNG MXC_INT_RNG
+
 /* Define different helper symbols based on RNG type */
 #ifdef FSL_HAVE_RNGA
 
-/*! Interrupt number for driver. */
-#define INT_RNG INT_RNGA
-
 /*! Base (bus?) address of RNG component. */
 #define RNG_BASE_ADDR RNGA_BASE_ADDR
 
@@ -314,35 +312,35 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
 #define RNG_READ_FIFO()                                                  \
     RNG_READ_REGISTER(RNGA_OUTPUT_FIFO)
 
-/*! Put entropy into the RNG's algorithm.
+/** Put entropy into the RNG's algorithm.
  *  @param value  32-bit value to add to RNG's entropy.
  **/
 #define RNG_ADD_ENTROPY(value)                                           \
     RNG_WRITE_REGISTER(RNGA_ENTROPY, (value))
-/*! Return non-zero in case of Error during Self Test */
+/** Return non-zero in case of Error during Self Test */
 #define RNG_CHECK_SELF_ERR() 0
-/*! Return non-zero in case of Error during Seed Generation */
+/** Return non-zero in case of Error during Seed Generation */
 #define RNG_CHECK_SEED_ERR() 0
-/*! Get the RNG started at generating output. */
+/** Get the RNG started at generating output. */
 #define RNG_GO()                                                         \
 {                                                                        \
     register uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);         \
     RNG_WRITE_REGISTER(RNGA_CONTROL, control | RNGA_CONTROL_GO);         \
 }
-/*! To clear all Error Bits in Error Status Register */
+/** To clear all Error Bits in Error Status Register */
 #define RNG_CLEAR_ERR()
-/*! Put RNG into High Assurance mode */
+/** Put RNG into High Assurance mode */
 #define RNG_SET_HIGH_ASSURANCE()                                              \
 {                                                                             \
     register uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);              \
     RNG_WRITE_REGISTER(RNGA_CONTROL, control | RNGA_CONTROL_HIGH_ASSURANCE);  \
 }
 
-/*! Return non-zero if the RNG is in High Assurance mode. */
+/** Return non-zero if the RNG is in High Assurance mode. */
 #define RNG_GET_HIGH_ASSURANCE()                                              \
     (RNG_READ_REGISTER(RNGA_CONTROL) & RNGA_CONTROL_HIGH_ASSURANCE)
 
-/*! Clear all status, error and otherwise. */
+/** Clear all status, error and otherwise. */
 #define RNG_CLEAR_ALL_STATUS()                                                \
 {                                                                             \
     register uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);              \
@@ -352,45 +350,45 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
 #define RNG_RESEED() 1
 
 
-/*! Return non-zero if Seeding is done */
+/** Return non-zero if Seeding is done */
 #define RNG_SEED_DONE()  1
 
-/*! Return non-zero if everything seems OK with the RNG. */
+/** Return non-zero if everything seems OK with the RNG. */
 #define RNG_WORKING()                                                    \
     ((RNG_READ_REGISTER(RNGA_STATUS)                                     \
       & (RNGA_STATUS_SLEEP | RNGA_STATUS_SECURITY_VIOLATION              \
          | RNGA_STATUS_ERROR_INTERRUPT | RNGA_STATUS_FIFO_UNDERFLOW      \
          | RNGA_STATUS_LAST_READ_STATUS )) == 0)
 
-/*! Put the RNG into sleep (low-power) mode. */
+/** Put the RNG into sleep (low-power) mode. */
 #define RNG_SLEEP()                                                      \
 {                                                                        \
     register uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);         \
     RNG_WRITE_REGISTER(RNGA_CONTROL, control | RNGA_CONTROL_SLEEP);      \
 }
 
-/*! Wake the RNG from sleep (low-power) mode. */
+/** Wake the RNG from sleep (low-power) mode. */
 #define RNG_WAKE()                                                       \
 {                                                                        \
     uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);                  \
      RNG_WRITE_REGISTER(RNGA_CONTROL, control & ~RNGA_CONTROL_SLEEP);    \
 }
 
-/*! Mask interrupts so that the driver/OS will not see them. */
+/** Mask interrupts so that the driver/OS will not see them. */
 #define RNG_MASK_ALL_INTERRUPTS()                                             \
 {                                                                             \
     register uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);              \
     RNG_WRITE_REGISTER(RNGA_CONTROL, control | RNGA_CONTROL_MASK_INTERRUPTS); \
 }
 
-/*! Unmask interrupts so that the driver/OS will see them. */
+/** Unmask interrupts so that the driver/OS will see them. */
 #define RNG_UNMASK_ALL_INTERRUPTS()                                           \
 {                                                                             \
     register uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);              \
     RNG_WRITE_REGISTER(RNGA_CONTROL, control & ~RNGA_CONTROL_MASK_INTERRUPTS);\
 }
 
-/*!
+/**
  * @def RNG_PUT_RNG_TO_SLEEP()
  *
  * If compiled with #RNG_USE_LOW_POWER_MODE, this routine will put the RNG
@@ -398,7 +396,7 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
  *
  * @return none
  */
-/*!
+/**
  * @def RNG_WAKE_RNG_FROM_SLEEP()
  *
  * If compiled with #RNG_USE_LOW_POWER_MODE, this routine will wake the RNG
@@ -424,23 +422,21 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
 
 #else				/* FSL_HAVE_RNGC */
 
-/*! Interrupt number for driver. */
-#define INT_RNG INT_RNGC
-/*! Base (bus?) address of RNG component. */
+/** Base (bus?) address of RNG component. */
 #define RNG_BASE_ADDR RNGC_BASE_ADDR
 
-/*! Read and return the status register. */
+/** Read and return the status register. */
 #define RNG_GET_STATUS()                                                 \
     RNG_READ_REGISTER(RNGC_ERROR)
 
-/*!
+/**
  * Return RNG Type value.  Should be RNG_TYPE_RNGA or RNG_TYPE_RNGC.
  */
 #define RNG_GET_RNG_TYPE()                                                \
-    ((RNG_READ_REGISTER(RNGC_VERSION_ID) & RNGC_VERID_RNG_TYPE_MASK)          \
+    ((RNG_READ_REGISTER(RNGC_VERSION_ID) & RNGC_VERID_RNG_TYPE_MASK)      \
      >> RNGC_VERID_RNG_TYPE_SHIFT)
 
-/*!
+/**
  * Verify Type value of RNG.
  *
  * Returns true of OK, false if not.
@@ -448,55 +444,55 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
 #define RNG_VERIFY_TYPE(type)                                             \
     ((type) == RNG_TYPE_RNGC)
 
-/*! Returns non-zero if RNG device is reporting an error. */
+/** Returns non-zero if RNG device is reporting an error. */
 #define RNG_HAS_ERROR()                                                   \
     (RNG_READ_REGISTER(RNGC_STATUS) & RNGC_STATUS_ERROR)
-/*! Returns non-zero if Bad Key is selected */
+/** Returns non-zero if Bad Key is selected */
 #define RNG_HAS_BAD_KEY()                                                 \
      (RNG_READ_REGISTER(RNGC_ERROR) & RNGC_ERROR_STATUS_BAD_KEY)
-/*! Returns non-zero if RNG ring oscillators have failed. */
+/** Returns non-zero if RNG ring oscillators have failed. */
 #define RNG_OSCILLATOR_FAILED()                                           \
     (RNG_READ_REGISTER(RNGC_ERROR) & RNGC_ERROR_STATUS_OSC_ERR)
 
-/*! Returns maximum number of 32-bit words in the RNG's output fifo. */
+/** Returns maximum number of 32-bit words in the RNG's output fifo. */
 #define RNG_GET_FIFO_SIZE()                                               \
     ((RNG_READ_REGISTER(RNGC_STATUS) & RNGC_STATUS_FIFO_SIZE_MASK)        \
      >> RNGC_STATUS_FIFO_SIZE_SHIFT)
 
-/*! Returns number of 32-bit words currently in the RNG's output fifo. */
+/** Returns number of 32-bit words currently in the RNG's output fifo. */
 #define RNG_GET_WORDS_IN_FIFO()                                           \
     ((RNG_READ_REGISTER(RNGC_STATUS) & RNGC_STATUS_FIFO_LEVEL_MASK)       \
      >> RNGC_STATUS_FIFO_LEVEL_SHIFT)
 
-/*! Get a random value from the RNG's output FIFO. */
+/** Get a random value from the RNG's output FIFO. */
 #define RNG_READ_FIFO()                                                   \
     RNG_READ_REGISTER(RNGC_FIFO)
 
-/*! Put entropy into the RNG's algorithm.
+/** Put entropy into the RNG's algorithm.
  *  @param value  32-bit value to add to RNG's entropy.
  **/
 #define RNG_ADD_ENTROPY(value)
-/*! Wake the RNG from sleep (low-power) mode. */
+/** Wake the RNG from sleep (low-power) mode. */
 #define RNG_WAKE()  1
-/*! Get the RNG started at generating output. */
+/** Get the RNG started at generating output. */
 #define RNG_GO()
-/*! Put RNG into High Assurance mode. */
+/** Put RNG into High Assurance mode. */
 #define RNG_SET_HIGH_ASSURANCE()
-/*! Returns non-zero in case of Error during Self Test       */
+/** Returns non-zero in case of Error during Self Test       */
 #define RNG_CHECK_SELF_ERR()                                                 \
 	(RNG_READ_REGISTER(RNGC_ERROR) & RNGC_ERROR_STATUS_ST_ERR)
-/*! Return non-zero in case of Error during Seed Generation */
+/** Return non-zero in case of Error during Seed Generation */
 #define RNG_CHECK_SEED_ERR()                                                 \
         (RNG_READ_REGISTER(RNGC_ERROR) & RNGC_ERROR_STATUS_STAT_ERR)
 
-/*! Configure RNG for Self Test */
+/** Configure RNG for Self Test */
 #define RNG_SELF_TEST()                                                       \
 {                                                                             \
     register uint32_t command = RNG_READ_REGISTER(RNGC_COMMAND);              \
     RNG_WRITE_REGISTER(RNGC_COMMAND, command                                  \
                                     | RNGC_COMMAND_SELF_TEST);                \
 }
-/*! Clearing the Error bits in Error Status Register */
+/** Clearing the Error bits in Error Status Register */
 #define RNG_CLEAR_ERR()                                                       \
 {                                                                             \
     register uint32_t command = RNG_READ_REGISTER(RNGC_COMMAND);              \
@@ -505,7 +501,7 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
 }
 
 
-/*! Return non-zero if Self Test Done */
+/** Return non-zero if Self Test Done */
 #define RNG_SELF_TEST_DONE()                                                  \
          (RNG_READ_REGISTER(RNGC_STATUS) & RNGC_STATUS_ST_DONE)
 /* Put RNG for SEED Generation */
@@ -519,31 +515,31 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
 #define RNG_RESEED()                                                          \
     (RNG_READ_REGISTER(RNGC_STATUS) & RNGC_STATUS_RESEED)
 
-/*! Return non-zero if the RNG is in High Assurance mode. */
+/** Return non-zero if the RNG is in High Assurance mode. */
 #define RNG_GET_HIGH_ASSURANCE()   1
 
-/*! Clear all status, error and otherwise. */
+/** Clear all status, error and otherwise. */
 #define RNG_CLEAR_ALL_STATUS()                                                \
     RNG_WRITE_REGISTER(RNGC_COMMAND,                                          \
                        RNGC_COMMAND_CLEAR_INTERRUPT                           \
                        | RNGC_COMMAND_CLEAR_ERROR)
 
-/*! Return non-zero if everything seems OK with the RNG. */
+/** Return non-zero if everything seems OK with the RNG. */
 #define RNG_WORKING()                                                         \
     ((RNG_READ_REGISTER(RNGC_ERROR)                                           \
       & (RNGC_ERROR_STATUS_STAT_ERR | RNGC_ERROR_STATUS_RAND_ERR              \
        | RNGC_ERROR_STATUS_FIFO_ERR | RNGC_ERROR_STATUS_ST_ERR |              \
          RNGC_ERROR_STATUS_OSC_ERR  | RNGC_ERROR_STATUS_LFSR_ERR )) == 0)
-/*! Return Non zero if SEEDING is DONE */
+/** Return Non zero if SEEDING is DONE */
 #define RNG_SEED_DONE()                                                       \
      ((RNG_READ_REGISTER(RNGC_STATUS) & RNGC_STATUS_SEED_DONE) != 0)
 
-/*! Put the RNG into sleep (low-power) mode. */
+/** Put the RNG into sleep (low-power) mode. */
 #define RNG_SLEEP()
 
-/*! Wake the RNG from sleep (low-power) mode. */
+/** Wake the RNG from sleep (low-power) mode. */
 
-/*! Mask interrupts so that the driver/OS will not see them. */
+/** Mask interrupts so that the driver/OS will not see them. */
 #define RNG_MASK_ALL_INTERRUPTS()                                             \
 {                                                                             \
     register uint32_t control = RNG_READ_REGISTER(RNGC_CONTROL);              \
@@ -551,7 +547,7 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
                                     | RNGC_CONTROL_MASK_DONE                  \
                                     | RNGC_CONTROL_MASK_ERROR);               \
 }
-/*! Configuring RNGC for self Test. */
+/** Configuring RNGC for self Test. */
 
 #define RNG_AUTO_SEED()                                                       \
 {                                                                             \
@@ -560,18 +556,18 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
                                     | RNGC_CONTROL_AUTO_SEED);                \
 }
 
-
-/*! Unmask interrupts so that the driver/OS will see them. */
+/** Unmask interrupts so that the driver/OS will see them. */
 #define RNG_UNMASK_ALL_INTERRUPTS()                                           \
 {                                                                             \
     register uint32_t control = RNG_READ_REGISTER(RNGC_CONTROL);              \
-    RNG_WRITE_REGISTER(RNGC_CONTROL, control & ~(RNGC_CONTROL_MASK_DONE|RNGC_CONTROL_MASK_ERROR));\
+    RNG_WRITE_REGISTER(RNGC_CONTROL,                                          \
+                control & ~(RNGC_CONTROL_MASK_DONE|RNGC_CONTROL_MASK_ERROR)); \
 }
 
-/*! Put RNG to sleep if appropriate. */
+/** Put RNG to sleep if appropriate. */
 #define RNG_PUT_RNG_TO_SLEEP()
 
-/*! Wake RNG from sleep if necessary. */
+/** Wake RNG from sleep if necessary. */
 #define RNG_WAKE_FROM_SLEEP()
 
 #endif				/* RNG TYPE */
@@ -587,7 +583,10 @@ inline static int rng_check_register_accessible(uint32_t offset,
 static fsl_shw_return_t rng_drain_fifo(uint32_t * random_p, int count_words);
 static os_error_code rng_grab_config_values(void);
 static void rng_cleanup(void);
+
+#ifdef FSL_HAVE_RNGA
 static void rng_sec_failure(void);
+#endif
 
 #ifdef RNG_REGISTER_DEBUG
 static uint32_t dbg_rng_read_register(uint32_t offset);
@@ -605,6 +604,7 @@ EXPORT_SYMBOL(rng_read_register);
 EXPORT_SYMBOL(rng_write_register);
 #endif				/* DEBUG_RNG_REGISTERS */
 
+
 MODULE_AUTHOR("Freescale Semiconductor");
 MODULE_DESCRIPTION("Device Driver for RNG");
 
diff --git a/drivers/mxc/security/rng/include/rng_rngc.h b/drivers/mxc/security/rng/include/rng_rngc.h
index 0aa36d0..12ead80 100644
--- a/drivers/mxc/security/rng/include/rng_rngc.h
+++ b/drivers/mxc/security/rng/include/rng_rngc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -16,188 +16,193 @@
 
 #define RNGC_VERSION_MAJOR3 3
 
-/*! RNGC Version ID Register R/W */
+/** RNGC Version ID Register R/W */
 #define RNGC_VERSION_ID 0x0000
-/*! RNGC Command Register R/W */
+/** RNGC Command Register R/W */
 #define RNGC_COMMAND 0x0004
-/*! RNGC Control Register R/W */
+/** RNGC Control Register R/W */
 #define RNGC_CONTROL 0x0008
-/*! RNGC Status Register R */
+/** RNGC Status Register R */
 #define RNGC_STATUS 0x000C
-/*! RNGC Error Status Register R */
+/** RNGC Error Status Register R */
 #define RNGC_ERROR 0x0010
-/*! RNGC FIFO Register W */
+/** RNGC FIFO Register W */
 #define RNGC_FIFO 0x0014
-/*! RNGC Verification Control Register1 R/W */
+/** RNGC Verification Control Register1 R/W */
 #define RNGC_VERIFICATION_CONTROL 0x0020
-/*! RNGC Oscillator Counter Control Register1 R/W */
+/** RNGC Oscillator Counter Control Register1 R/W */
 #define RNGC_OSCILLATOR_CONTROL_COUNTER 0x0028
-/*! RNGC Oscillator Counter Register1 R */
+/** RNGC Oscillator Counter Register1 R */
 #define RNGC_OSC_COUNTER 0x002C
-/*! RNGC Oscillator Counter Status Register1 R */
+/** RNGC Oscillator Counter Status Register1 R */
 #define RNGC_OSC_COUNTER_STATUS 0x0030
-/*! @} */
+/** @} */
 
-/*! @defgroup rngcveridreg RNGC Version ID Register Definitions
+/** @defgroup rngcveridreg RNGC Version ID Register Definitions
  *  @ingroup RNG
  */
-/*! @addtogroup rngcveridreg */
-/*! @{ */
-/*! These bits are unimplemented or reserved */
+/** @addtogroup rngcveridreg */
+/** @{ */
+/** These bits are unimplemented or reserved */
 #define RNGC_VERID_ZEROS_MASK          0x0f000000
-/*! Mask for RNG TYPE */
+/** Mask for RNG TYPE */
 #define RNGC_VERID_RNG_TYPE_MASK       0xf0000000
-/*! Shift to make RNG TYPE be LSB */
+/** Shift to make RNG TYPE be LSB */
 #define RNGC_VERID_RNG_TYPE_SHIFT      28
-/*! Mask for RNG Chip Version */
+/** Mask for RNG Chip Version */
 #define RNGC_VERID_CHIP_VERSION_MASK   0x00ff0000
-/*! Shift to make RNG Chip version be LSB */
+/** Shift to make RNG Chip version be LSB */
 #define RNGC_VERID_CHIP_VERSION_SHIFT  16
-/*! Mask for RNG Major Version */
+/** Mask for RNG Major Version */
 #define RNGC_VERID_VERSION_MAJOR_MASK  0x0000ff00
-/*! Shift to make RNG Major version be LSB */
+/** Shift to make RNG Major version be LSB */
 #define RNGC_VERID_VERSION_MAJOR_SHIFT 8
-/*! Mask for RNG Minor Version */
+/** Mask for RNG Minor Version */
 #define RNGC_VERID_VERSION_MINOR_MASK  0x000000ff
-/*! Shift to make RNG Minor version be LSB */
+/** Shift to make RNG Minor version be LSB */
 #define RNGC_VERID_VERSION_MINOR_SHIFT 0
-/*! @} */
+/** @} */
 
-/*! @defgroup rngccommandreg RNGC Command Register Definitions
+/** @defgroup rngccommandreg RNGC Command Register Definitions
  *  @ingroup RNG
  */
-/*! @addtogroup rngccommandreg */
-/*! @{ */
-/*! These bits are unimplemented or reserved. */
+/** @addtogroup rngccommandreg */
+/** @{ */
+/** These bits are unimplemented or reserved. */
 #define RNGC_COMMAND_ZEROS_MASK      0xffffff8c
-/*! Perform a software reset of the RNGC. */
+/** Perform a software reset of the RNGC. */
 #define RNGC_COMMAND_SOFTWARE_RESET          0x00000040
-/*! Clear error from Error Status register (and interrupt). */
+/** Clear error from Error Status register (and interrupt). */
 #define RNGC_COMMAND_CLEAR_ERROR             0x00000020
-/*! Clear interrupt & status. */
+/** Clear interrupt & status. */
 #define RNGC_COMMAND_CLEAR_INTERRUPT         0x00000010
-/*! Start RNGC seed generation. */
+/** Start RNGC seed generation. */
 #define RNGC_COMMAND_SEED                    0x00000002
-/*! Perform a self test of (and reset) the RNGC. */
+/** Perform a self test of (and reset) the RNGC. */
 #define RNGC_COMMAND_SELF_TEST               0x00000001
-/*! @} */
+/** @} */
 
-/*! @defgroup rngccontrolreg RNGC Control Register Definitions
+/** @defgroup rngccontrolreg RNGC Control Register Definitions
  *  @ingroup RNG
  */
-/*! @addtogroup rngccontrolreg */
-/*! @{ */
-/*! These bits are unimplemented or reserved */
+/** @addtogroup rngccontrolreg */
+/** @{ */
+/** These bits are unimplemented or reserved */
 #define RNGC_CONTROL_ZEROS_MASK       0xfffffc8c
-/*! Allow access to verification registers. */
+/** Allow access to verification registers. */
 #define RNGC_CONTROL_CTL_ACC          0x00000200
-/*! Put RNGC into deterministic verifcation mode. */
+/** Put RNGC into deterministic verifcation mode. */
 #define RNGC_CONTROL_VERIF_MODE       0x00000100
-/*! Prevent RNGC from generating interrupts caused by errors. */
+/** Prevent RNGC from generating interrupts caused by errors. */
 #define RNGC_CONTROL_MASK_ERROR       0x00000040
 
-/*!
+/**
  * Prevent RNGC from generating interrupts after Seed Done or Self Test Mode
  * completion.
  */
 #define RNGC_CONTROL_MASK_DONE        0x00000020
-/*! Allow RNGC to generate a new seed whenever it is needed. */
+/** Allow RNGC to generate a new seed whenever it is needed. */
 #define RNGC_CONTROL_AUTO_SEED        0x00000010
-/*! Set FIFO Underflow Response.*/
+/** Set FIFO Underflow Response.*/
 #define RNGC_CONTROL_FIFO_UFLOW_MASK  0x00000003
-/*! Shift value to make FIFO Underflow Response be LSB. */
+/** Shift value to make FIFO Underflow Response be LSB. */
 #define RNGC_CONTROL_FIFO_UFLOW_SHIFT 0
 
-/*! @} */
+/** @} */
 
-/*! @{  */
-/*! FIFO Underflow should cause ... */
+/** @{  */
+/** FIFO Underflow should cause ... */
 #define RNGC_CONTROL_FIFO_UFLOW_ZEROS_ERROR 0
-/*! FIFO Underflow should cause ... */
+/** FIFO Underflow should cause ... */
 #define RNGC_CONTROL_FIFO_UFLOW_ZEROS_ERROR2 1
-/*! FIFO Underflow should cause ... */
+/** FIFO Underflow should cause ... */
 #define RNGC_CONTROL_FIFO_UFLOW_BUS_XFR     2
-/*! FIFO Underflow should cause ... */
+/** FIFO Underflow should cause ... */
 #define RNGC_CONTROL_FIFO_UFLOW_ZEROS_INTR  3
-/*! @} */
+/** @} */
 
-/*! @defgroup rngcstatusreg RNGC Status Register Definitions
+/** @defgroup rngcstatusreg RNGC Status Register Definitions
  *  @ingroup RNG
  */
-/*! @addtogroup rngcstatusreg */
-/*! @{ */
-/*! Unused or MBZ.  */
+/** @addtogroup rngcstatusreg */
+/** @{ */
+/** Unused or MBZ.  */
 #define RNGC_STATUS_ZEROS_MASK              0x003e0080
-/*!
+/**
  * Statistical tests pass-fail.  Individual bits on indicate failure of a
  * particular test.
  */
 #define RNGC_STATUS_STAT_TEST_PF_MASK       0xff000000
-/*! Mask to get Statistical PF to be LSB. */
+/** Mask to get Statistical PF to be LSB. */
 #define RNGC_STATUS_STAT_TEST_PF_SHIFT      24
-/*!
+/**
  * Self tests pass-fail.  Individual bits on indicate failure of a
  * particular test.
  */
 #define RNGC_STATUS_ST_PF_MASK              0x00c00000
-/*! Shift value to get Self Test PF field to be LSB. */
+/** Shift value to get Self Test PF field to be LSB. */
 #define RNGC_STATUS_ST_PF_SHIFT             22
-/*! Error detected in RNGC.  See Error Status register. */
+/* TRNG Self test pass-fail */
+#define RNGC_STATUS_ST_PF_TRNG              0x00800000
+/* PRNG Self test pass-fail */
+#define RNGC_STATUS_ST_PF_PRNG              0x00400000
+/** Error detected in RNGC.  See Error Status register. */
 #define RNGC_STATUS_ERROR                   0x00010000
-/*! Size of the internal FIFO in 32-bit words. */
+/** Size of the internal FIFO in 32-bit words. */
 #define RNGC_STATUS_FIFO_SIZE_MASK          0x0000f000
-/*! Shift value to get FIFO Size to be LSB. */
+/** Shift value to get FIFO Size to be LSB. */
 #define RNGC_STATUS_FIFO_SIZE_SHIFT         12
-/*! The level (available data) of the internal FIFO in 32-bit words. */
+/** The level (available data) of the internal FIFO in 32-bit words. */
 #define RNGC_STATUS_FIFO_LEVEL_MASK         0x00000f00
-/*! Shift value to get FIFO Level to be LSB. */
+/** Shift value to get FIFO Level to be LSB. */
 #define RNGC_STATUS_FIFO_LEVEL_SHIFT        8
-/*! A new seed is ready for use. */
+/** A new seed is ready for use. */
 #define RNGC_STATUS_NEXT_SEED_DONE          0x00000040
-/*! The first seed has been generated. */
+/** The first seed has been generated. */
 #define RNGC_STATUS_SEED_DONE               0x00000020
-/*! Self Test has been completed. */
+/** Self Test has been completed. */
 #define RNGC_STATUS_ST_DONE                 0x00000010
-/*! Reseed is necessary. */
+/** Reseed is necessary. */
 #define RNGC_STATUS_RESEED                  0x00000008
-/*! RNGC is sleeping. */
+/** RNGC is sleeping. */
 #define RNGC_STATUS_SLEEP                   0x00000004
-/*! RNGC is currently generating numbers, seeding, generating next seed, or
+/** RNGC is currently generating numbers, seeding, generating next seed, or
     performing a self test. */
 #define RNGC_STATUS_BUSY                    0x00000002
-/*! RNGC is in secure state. */
+/** RNGC is in secure state. */
 #define RNGC_STATUS_SEC_STATE               0x00000001
 
-/*! @} */
+/** @} */
 
-/*! @defgroup rngcerrstatusreg RNGC Error Status Register Definitions
+/** @defgroup rngcerrstatusreg RNGC Error Status Register Definitions
  *  @ingroup RNG
  */
-/*! @addtogroup rngcerrstatusreg */
-/*! @{ */
-/*! Unused or MBZ. */
+/** @addtogroup rngcerrstatusreg */
+/** @{ */
+/** Unused or MBZ. */
 #define RNGC_ERROR_STATUS_ZEROS_MASK        0xffffffc0
-/*! Bad Key Error Status */
+/** Bad Key Error Status */
 #define RNGC_ERROR_STATUS_BAD_KEY          0x00000040
-/*! Random Compare Error.  Previous number matched the current number. */
+/** Random Compare Error.  Previous number matched the current number. */
 #define RNGC_ERROR_STATUS_RAND_ERR          0x00000020
-/*! FIFO Underflow.  FIFO was read while empty. */
+/** FIFO Underflow.  FIFO was read while empty. */
 #define RNGC_ERROR_STATUS_FIFO_ERR          0x00000010
-/*! Statistic Error Statistic Test failed for the last seed. */
+/** Statistic Error Statistic Test failed for the last seed. */
 #define RNGC_ERROR_STATUS_STAT_ERR          0x00000008
-/*! Self-test error.  Some self test has failed. */
+/** Self-test error.  Some self test has failed. */
 #define RNGC_ERROR_STATUS_ST_ERR            0x00000004
-/*!
+/**
  * Oscillator Error.  The oscillator may be broken.  Clear by hard or soft
  * reset.
  */
 #define RNGC_ERROR_STATUS_OSC_ERR           0x00000002
-/*! LFSR Error.  Clear by hard or soft reset. */
+/** LFSR Error.  Clear by hard or soft reset. */
 #define RNGC_ERROR_STATUS_LFSR_ERR          0x00000001
 
-/*! @} */
+/** @} */
 
-/*! Total address space of the RNGC, in bytes */
+/** Total address space of the RNGC, in bytes */
 #define RNG_ADDRESS_RANGE 0x34
 
+
 #endif
diff --git a/drivers/mxc/security/rng/include/shw_driver.h b/drivers/mxc/security/rng/include/shw_driver.h
index 06f3f18..7c29909 100644
--- a/drivers/mxc/security/rng/include/shw_driver.h
+++ b/drivers/mxc/security/rng/include/shw_driver.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -44,112 +44,209 @@
 /*! Perform a security function.  */
 #define SHW_IOCTL_REQUEST 21
 
-/*!
+/* This definition may need a new name, and needs to go somewhere which
+ * can determine platform, kernel vs. user, os, etc.
+ */
+#define copy_bytes(out, in, len) memcpy(out, in, len)
+
+
+/**
  * This is part of the IOCTL request type passed between kernel and user space.
  * It is added to #SHW_IOCTL_REQUEST to generate the actual value.
  */
-typedef enum shw_user_request_type {
-	SHW_USER_REQ_REGISTER_USER,	/*!< Initialize user-kernel discussion. */
-	SHW_USER_REQ_DEREGISTER_USER,	/*!< Terminate user-kernel discussion. */
-	SHW_USER_REQ_GET_RESULTS,	/*!< Get information on outstanding
-					   results. */
-	SHW_USER_REQ_GET_CAPABILITIES,	/*!< Get information on hardware support. */
-	SHW_USER_REQ_GET_RANDOM,	/*!< Get random data from RNG. */
-	SHW_USER_REQ_ADD_ENTROPY,	/*!< Add entropy to hardware RNG. */
+typedef enum shw_user_request_t {
+    SHW_USER_REQ_REGISTER_USER,    /**< Initialize user-kernel discussion. */
+    SHW_USER_REQ_DEREGISTER_USER,  /**< Terminate user-kernel discussion. */
+    SHW_USER_REQ_GET_RESULTS,      /**< Get information on outstanding
+                                      results. */
+    SHW_USER_REQ_GET_CAPABILITIES, /**< Get information on hardware support. */
+    SHW_USER_REQ_GET_RANDOM,       /**< Get random data from RNG. */
+    SHW_USER_REQ_ADD_ENTROPY,      /**< Add entropy to hardware RNG. */
+    SHW_USER_REQ_DROP_PERMS,       /**< Diminish the permissions of a block of
+                                      secure memory */
+    SHW_USER_REQ_SSTATUS,          /**< Check the status of a block of secure 
+                                      memory */
+    SHW_USER_REQ_SFREE,            /**< Free a block of secure memory */
+    SHW_USER_REQ_SCC_ENCRYPT,      /**< Encrypt a region of user-owned secure
+                                     memory */
+    SHW_USER_REQ_SCC_DECRYPT,     /**< Decrypt a region of user-owned secure
+                                     memory */
 } shw_user_request_t;
 
-/*!****************************************************************************
+
+/**
+ * @typedef scc_partition_status_t
+ */
+/** Partition status information. */
+typedef enum fsl_shw_partition_status_t {
+    FSL_PART_S_UNUSABLE,          /**< Partition not implemented */
+    FSL_PART_S_UNAVAILABLE,       /**< Partition owned by other host */
+    FSL_PART_S_AVAILABLE,         /**< Partition available */
+    FSL_PART_S_ALLOCATED,         /**< Partition owned by host but not engaged
+                                   */
+    FSL_PART_S_ENGAGED,           /**< Partition owned by host and engaged */
+} fsl_shw_partition_status_t;
+
+
+/*
+ * Structure passed during user ioctl() calls to manage secure partitions.
+ */
+typedef struct scc_partition_info_t {
+    uint32_t user_base;            /**< Userspace pointer to base of partition */
+    uint32_t permissions;          /**< Permissions to give the partition (only
+                                        used in call to _DROP_PERMS) */
+    fsl_shw_partition_status_t status;  /**< Status of the partition */
+} scc_partition_info_t;
+
+
+/******************************************************************************
  * Enumerations
  *****************************************************************************/
-/*!
+/**
  * Flags for the state of the User Context Object (#fsl_shw_uco_t).
  */
-typedef enum fsl_shw_user_ctx_flags {
-	FSL_UCO_BLOCKING_MODE = 0x01,	/*!< API will block the caller until operation
-					   completes.  The result will be available in the
-					   return code.  If this is not set, user will have
-					   to get results using #fsl_shw_get_results(). */
-	FSL_UCO_CALLBACK_MODE = 0x02,	/*!< User wants callback (at the function
-					   specified with #fsl_shw_uco_set_callback()) when
-					   the operation completes.  This flag is valid
-					   only if #FSL_UCO_BLOCKING_MODE is not set. */
-	FSL_UCO_SAVE_DESC_CHAIN = 0x04,	/*!< Do not free descriptor chain after
-					   driver (adaptor) finishes */
-	FSL_UCO_CALLBACK_SETUP_COMPLETE = 0x08,	/*!< User has made at least one
-						   request with callbacks requested, so
-						   API is ready to handle others. */
-
-	FSL_UCO_CHAIN_PREPHYSICALIZED = 0x10,	/*!< (virtual) pointer to descriptor
-						   chain is completely linked with physical
-						   (DMA) addresses, ready for the hardware.
-						   This flag should not be used by FSL SHW API
-						   programs. */
-	FSL_UCO_CONTEXT_CHANGED = 0x20,	/*!< The user has changed the context but
-					   the changes have not been copied to the
-					   kernel driver. */
-	FSL_UCO_USERMODE_USER = 0x40,	/*!< Internal use.  This context belongs to a
-					   user-mode API user. */
+typedef enum fsl_shw_user_ctx_flags_t
+{
+    /**
+     * API will block the caller until operation completes.  The result will be
+     * available in the return code.  If this is not set, user will have to get
+     * results using #fsl_shw_get_results().
+     */
+    FSL_UCO_BLOCKING_MODE = 0x01,
+    /**
+     * User wants callback (at the function specified with
+     * #fsl_shw_uco_set_callback()) when the operation completes.  This flag is
+     * valid only if #FSL_UCO_BLOCKING_MODE is not set.
+     */
+    FSL_UCO_CALLBACK_MODE = 0x02,
+    /** Do not free descriptor chain after driver (adaptor) finishes */
+    FSL_UCO_SAVE_DESC_CHAIN = 0x04,
+    /**
+     * User has made at least one request with callbacks requested, so API is
+     * ready to handle others.
+     */
+    FSL_UCO_CALLBACK_SETUP_COMPLETE = 0x08,
+    /**
+     * (virtual) pointer to descriptor chain is completely linked with physical
+     * (DMA) addresses, ready for the hardware.  This flag should not be used
+     * by FSL SHW API programs.
+     */
+    FSL_UCO_CHAIN_PREPHYSICALIZED = 0x10,
+    /**
+     * The user has changed the context but the changes have not been copied to
+     * the kernel driver.
+     */
+    FSL_UCO_CONTEXT_CHANGED = 0x20,
+    /** Internal Use.  This context belongs to a user-mode API user. */
+    FSL_UCO_USERMODE_USER = 0x40,
 } fsl_shw_user_ctx_flags_t;
 
-/*!
+
+/**
  * Return code for FSL_SHW library.
  *
  * These codes may be returned from a function call.  In non-blocking mode,
  * they will appear as the status in a Result Object.
  */
 /* REQ-FSLSHW-ERR-001 */
-typedef enum fsl_shw_return_t {
-	FSL_RETURN_OK_S = 0,	/*!< No error.  As a function return code in
-				   Non-blocking mode, this may simply mean that
-				   the operation was accepted for eventual
-				   execution. */
-	FSL_RETURN_ERROR_S,	/*!< Failure for non-specific reason. */
-	FSL_RETURN_NO_RESOURCE_S,	/*!< Operation failed because some resource was
-					   not able to be allocated. */
-	FSL_RETURN_BAD_ALGORITHM_S,	/*!< Crypto algorithm unrecognized or
-					   improper. */
-	FSL_RETURN_BAD_MODE_S,	/*!< Crypto mode unrecognized or improper. */
-	FSL_RETURN_BAD_FLAG_S,	/*!< Flag setting unrecognized or
-				   inconsistent. */
-	FSL_RETURN_BAD_KEY_LENGTH_S,	/*!< Improper or unsupported key length for
-					   algorithm. */
-	FSL_RETURN_BAD_KEY_PARITY_S,	/*!< Improper parity in a (DES, TDES) key. */
-	FSL_RETURN_BAD_DATA_LENGTH_S,	/*!< Improper or unsupported data length for
-					   algorithm or internal buffer. */
-	FSL_RETURN_AUTH_FAILED_S,	/*!< Authentication failed in
-					   authenticate-decrypt operation. */
-	FSL_RETURN_MEMORY_ERROR_S,	/*!< A memory error occurred. */
-	FSL_RETURN_INTERNAL_ERROR_S	/*!< An error internal to the hardware
-					   occurred. */
+typedef enum fsl_shw_return_t
+{
+    /**
+     * No error.  As a function return code in Non-blocking mode, this may
+     * simply mean that the operation was accepted for eventual execution.
+     */
+    FSL_RETURN_OK_S = 0,
+    /** Failure for non-specific reason. */
+    FSL_RETURN_ERROR_S,
+   /**
+    * Operation failed because some resource was not able to be allocated.
+    */
+    FSL_RETURN_NO_RESOURCE_S,
+    /** Crypto algorithm unrecognized or improper. */
+    FSL_RETURN_BAD_ALGORITHM_S,
+    /** Crypto mode unrecognized or improper. */
+    FSL_RETURN_BAD_MODE_S,
+    /** Flag setting unrecognized or inconsistent. */
+    FSL_RETURN_BAD_FLAG_S,
+    /** Improper or unsupported key length for algorithm. */
+    FSL_RETURN_BAD_KEY_LENGTH_S,
+    /** Improper parity in a (DES, TDES) key. */
+    FSL_RETURN_BAD_KEY_PARITY_S,
+    /**
+     * Improper or unsupported data length for algorithm or internal buffer.
+     */
+    FSL_RETURN_BAD_DATA_LENGTH_S,
+    /** Authentication / Integrity Check code check failed. */
+    FSL_RETURN_AUTH_FAILED_S,
+    /** A memory error occurred. */
+    FSL_RETURN_MEMORY_ERROR_S,
+    /** An error internal to the hardware occurred. */
+    FSL_RETURN_INTERNAL_ERROR_S,
+    /** ECC detected Point at Infinity */
+    FSL_RETURN_POINT_AT_INFINITY_S,
+    /** ECC detected No Point at Infinity */
+    FSL_RETURN_POINT_NOT_AT_INFINITY_S,
+    /** GCD is One */
+    FSL_RETURN_GCD_IS_ONE_S,
+    /** GCD is not One */
+    FSL_RETURN_GCD_IS_NOT_ONE_S,
+    /** Candidate is Prime */
+    FSL_RETURN_PRIME_S,
+    /** Candidate is not Prime */
+    FSL_RETURN_NOT_PRIME_S,
+    /** N register loaded improperly with even value */
+    FSL_RETURN_EVEN_MODULUS_ERROR_S,
+    /** Divisor is zero. */
+    FSL_RETURN_DIVIDE_BY_ZERO_ERROR_S,
+    /** Bad Exponent or Scalar value for Point Multiply */
+    FSL_RETURN_BAD_EXPONENT_ERROR_S,
+    /** RNG hardware problem. */
+    FSL_RETURN_OSCILLATOR_ERROR_S,
+    /** RNG hardware problem. */
+    FSL_RETURN_STATISTICS_ERROR_S,
 } fsl_shw_return_t;
 
-/*!
+
+/**
  * Algorithm Identifier.
  *
  * Selection of algorithm will determine how large the block size of the
  * algorithm is.   Context size is the same length unless otherwise specified.
  * Selection of algorithm also affects the allowable key length.
  */
-typedef enum fsl_shw_key_alg_t {
-	FSL_KEY_ALG_HMAC,	/*!< Key will be used to perform an HMAC.  Key
-				   size is 1 to 64 octets.  Block size is 64
-				   octets. */
-	FSL_KEY_ALG_AES,	/*!< Advanced Encryption Standard (Rijndael).
-				   Block size is 16 octets.  Key size is 16
-				   octets.  (The single choice of key size is a
-				   Sahara platform limitation.) */
-	FSL_KEY_ALG_DES,	/*!< Data Encryption Standard.  Block size is
-				   8 octets.  Key size is 8 octets. */
-	FSL_KEY_ALG_TDES,	/*!< 2- or 3-key Triple DES.  Block size is 8
-				   octets.  Key size is 16 octets for 2-key
-				   Triple DES, and 24 octets for 3-key. */
-	FSL_KEY_ALG_ARC4	/*!< ARC4.  No block size.  Context size is 259
-				   octets.  Allowed key size is 1-16 octets.
-				   (The choices for key size are a Sahara
-				   platform limitation.) */
+typedef enum fsl_shw_key_alg_t
+{
+    /**
+     * Key will be used to perform an HMAC.  Key size is 1 to 64 octets.  Block
+     * size is 64 octets.
+     */
+    FSL_KEY_ALG_HMAC,
+    /**
+     * Advanced Encryption Standard (Rijndael).  Block size is 16 octets.  Key
+     * size is 16 octets.  (The single choice of key size is a Sahara platform
+     * limitation.)
+     */
+    FSL_KEY_ALG_AES,
+    /**
+     * Data Encryption Standard.  Block size is 8 octets.  Key size is 8
+     * octets.
+     */
+    FSL_KEY_ALG_DES,
+    /**
+     * 2- or 3-key Triple DES.  Block size is 8 octets.  Key size is 16 octets
+     * for 2-key Triple DES, and 24 octets for 3-key.
+     */
+    FSL_KEY_ALG_TDES,
+    /**
+     * ARC4.  No block size.  Context size is 259 octets.  Allowed key size is
+     * 1-16 octets.  (The choices for key size are a Sahara platform
+     * limitation.)
+     */
+    FSL_KEY_ALG_ARC4,
 } fsl_shw_key_alg_t;
 
-/*!
+
+/**
  * Mode selector for Symmetric Ciphers.
  *
  * The selection of mode determines how a cryptographic algorithm will be
@@ -166,476 +263,636 @@ typedef enum fsl_shw_key_alg_t {
  * has a total number of octets which are not a multiple of the block size, the
  * user must perform any necessary padding to get to the correct data length.
  */
-typedef enum fsl_shw_sym_mode_t {
-	/*!
-	 * Stream.  There is no associated block size.  Any request to process data
-	 * may be of any length.  This mode is only for ARC4 operations, and is
-	 * also the only mode used for ARC4.
-	 */
-	FSL_SYM_MODE_STREAM,
-
-	/*!
-	 * Electronic Codebook.  Each block of data is encrypted/decrypted.  The
-	 * length of the data stream must be a multiple of the block size.  This
-	 * mode may be used for DES, 3DES, and AES.  The block size is determined
-	 * by the algorithm.
-	 */
-	FSL_SYM_MODE_ECB,
-	/*!
-	 * Cipher-Block Chaining.  Each block of data is encrypted/decrypted and
-	 * then "chained" with the previous block by an XOR function.  Requires
-	 * context to start the XOR (previous block).  This mode may be used for
-	 * DES, 3DES, and AES.  The block size is determined by the algorithm.
-	 */
-	FSL_SYM_MODE_CBC,
-	/*!
-	 * Counter.  The counter is encrypted, then XORed with a block of data.
-	 * The counter is then incremented (using modulus arithmetic) for the next
-	 * block. The final operation may be non-multiple of block size.  This mode
-	 * may be used for AES.  The block size is determined by the algorithm.
-	 */
-	FSL_SYM_MODE_CTR,
+typedef enum fsl_shw_sym_mode_t
+{
+    /**
+     * Stream.  There is no associated block size.  Any request to process data
+     * may be of any length.  This mode is only for ARC4 operations, and is
+     * also the only mode used for ARC4.
+     */
+    FSL_SYM_MODE_STREAM,
+
+    /**
+     * Electronic Codebook.  Each block of data is encrypted/decrypted.  The
+     * length of the data stream must be a multiple of the block size.  This
+     * mode may be used for DES, 3DES, and AES.  The block size is determined
+     * by the algorithm.
+     */
+    FSL_SYM_MODE_ECB,
+    /**
+     * Cipher-Block Chaining.  Each block of data is encrypted/decrypted and
+     * then "chained" with the previous block by an XOR function.  Requires
+     * context to start the XOR (previous block).  This mode may be used for
+     * DES, 3DES, and AES.  The block size is determined by the algorithm.
+     */
+    FSL_SYM_MODE_CBC,
+    /**
+     * Counter.  The counter is encrypted, then XORed with a block of data.
+     * The counter is then incremented (using modulus arithmetic) for the next
+     * block. The final operation may be non-multiple of block size.  This mode
+     * may be used for AES.  The block size is determined by the algorithm.
+     */
+    FSL_SYM_MODE_CTR,
 } fsl_shw_sym_mode_t;
 
-/*!
+
+/**
  * Algorithm selector for Cryptographic Hash functions.
  *
  * Selection of algorithm determines how large the context and digest will be.
  * Context is the same size as the digest (resulting hash), unless otherwise
  * specified.
  */
-typedef enum fsl_shw_hash_alg {
-	FSL_HASH_ALG_MD5,	/*!< MD5 algorithm.  Digest is 16 octets. */
-	FSL_HASH_ALG_SHA1,	/*!< SHA-1 (aka SHA or SHA-160) algorithm.
-				   Digest is 20 octets. */
-	FSL_HASH_ALG_SHA224,	/*!< SHA-224 algorithm.  Digest is 28 octets,
-				   though context is 32 octets. */
-	FSL_HASH_ALG_SHA256	/*!< SHA-256 algorithm.  Digest is 32
-				   octets. */
+typedef enum fsl_shw_hash_alg_t
+{
+    FSL_HASH_ALG_MD5,           /**< MD5 algorithm.  Digest is 16 octets. */
+    FSL_HASH_ALG_SHA1,          /**< SHA-1 (aka SHA or SHA-160) algorithm.
+                                   Digest is 20 octets. */
+    FSL_HASH_ALG_SHA224,        /**< SHA-224 algorithm.  Digest is 28 octets,
+                                   though context is 32 octets. */
+    FSL_HASH_ALG_SHA256         /**< SHA-256 algorithm.  Digest is 32
+                                   octets. */
 } fsl_shw_hash_alg_t;
 
-/*!
+
+/**
  * The type of Authentication-Cipher function which will be performed.
  */
-typedef enum fsl_shw_acc_mode_t {
-	/*!
-	 * CBC-MAC for Counter.  Requires context and modulus.  Final operation may
-	 * be non-multiple of block size.  This mode may be used for AES.
-	 */
-	FSL_ACC_MODE_CCM,
-	/*!
-	 * SSL mode.  Not supported.  Combines HMAC and encrypt (or decrypt).
-	 * Needs one key object for encryption, another for the HMAC.  The usual
-	 * hashing and symmetric encryption algorithms are supported.
-	 */
-	FSL_ACC_MODE_SSL
+typedef enum fsl_shw_acc_mode_t
+{
+    /**
+     * CBC-MAC for Counter.  Requires context and modulus.  Final operation may
+     * be non-multiple of block size.  This mode may be used for AES.
+     */
+    FSL_ACC_MODE_CCM,
+    /**
+     * SSL mode.  Not supported.  Combines HMAC and encrypt (or decrypt).
+     * Needs one key object for encryption, another for the HMAC.  The usual
+     * hashing and symmetric encryption algorithms are supported.
+     */
+    FSL_ACC_MODE_SSL
 } fsl_shw_acc_mode_t;
 
+
 /* REQ-FSLSHW-PINTFC-COA-HCO-001 */
-/*!
+/**
  * Flags which control a Hash operation.
  */
-typedef enum fsl_shw_hash_ctx_flags {
-	FSL_HASH_FLAGS_INIT = 1,	/*!< Context is empty.  Hash is started
-					   from scratch, with a message-processed
-					   count of zero. */
-	FSL_HASH_FLAGS_SAVE = 2,	/*!< Retrieve context from hardware after
-					   hashing.  If used with the
-					   #FSL_HASH_FLAGS_FINALIZE flag, the final
-					   digest value will be saved in the
-					   object. */
-	FSL_HASH_FLAGS_LOAD = 4,	/*!< Place context into hardware before
-					   hashing. */
-	FSL_HASH_FLAGS_FINALIZE = 8,	/*!< PAD message and perform final digest
-					   operation.  If user message is
-					   pre-padded, this flag should not be
-					   used. */
+typedef enum fsl_shw_hash_ctx_flags_t
+{
+    FSL_HASH_FLAGS_INIT = 0x01,     /**< Context is empty.  Hash is started
+                                       from scratch, with a message-processed
+                                       count of zero. */
+    FSL_HASH_FLAGS_SAVE = 0x02,     /**< Retrieve context from hardware after
+                                       hashing.  If used with the
+                                       #FSL_HASH_FLAGS_FINALIZE flag, the final
+                                       digest value will be saved in the
+                                       object. */
+    FSL_HASH_FLAGS_LOAD = 0x04,     /**< Place context into hardware before
+                                       hashing. */
+    FSL_HASH_FLAGS_FINALIZE = 0x08, /**< PAD message and perform final digest
+                                       operation.  If user message is
+                                       pre-padded, this flag should not be
+                                       used. */
 } fsl_shw_hash_ctx_flags_t;
 
-/*!
+
+/**
  * Flags which control an HMAC operation.
  *
  * These may be combined by ORing them together.  See #fsl_shw_hmco_set_flags()
  * and #fsl_shw_hmco_clear_flags().
  */
-typedef enum fsl_shw_hmac_ctx_flags_t {
-	FSL_HMAC_FLAGS_INIT = 1,	/*!< Message context is empty.  HMAC is
-					   started from scratch (with key) or from
-					   precompute of inner hash, depending on
-					   whether
-					   #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT is
-					   set. */
-	FSL_HMAC_FLAGS_SAVE = 2,	/*!< Retrieve ongoing context from hardware
-					   after hashing.  If used with the
-					   #FSL_HMAC_FLAGS_FINALIZE flag, the final
-					   digest value (HMAC) will be saved in the
-					   object. */
-	FSL_HMAC_FLAGS_LOAD = 4,	/*!< Place ongoing context into hardware
-					   before hashing. */
-	FSL_HMAC_FLAGS_FINALIZE = 8,	/*!< PAD message and perform final HMAC
-					   operations of inner and outer hashes. */
-	FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT = 16	/*!< This means that the context
-						   contains precomputed inner and outer
-						   hash values. */
+typedef enum fsl_shw_hmac_ctx_flags_t
+{
+    FSL_HMAC_FLAGS_INIT = 1,        /**< Message context is empty.  HMAC is
+                                       started from scratch (with key) or from
+                                       precompute of inner hash, depending on
+                                       whether
+                                       #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT is
+                                       set. */
+    FSL_HMAC_FLAGS_SAVE = 2,        /**< Retrieve ongoing context from hardware
+                                       after hashing.  If used with the
+                                       #FSL_HMAC_FLAGS_FINALIZE flag, the final
+                                       digest value (HMAC) will be saved in the
+                                       object. */
+    FSL_HMAC_FLAGS_LOAD = 4,        /**< Place ongoing context into hardware
+                                       before hashing. */
+    FSL_HMAC_FLAGS_FINALIZE = 8,    /**< PAD message and perform final HMAC
+                                       operations of inner and outer hashes. */
+    FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT = 16 /**< This means that the context
+                                        contains precomputed inner and outer
+                                        hash values. */
 } fsl_shw_hmac_ctx_flags_t;
 
-/*!
+
+/**
  * Flags to control use of the #fsl_shw_scco_t.
  *
  * These may be ORed together to get the desired effect.
  * See #fsl_shw_scco_set_flags() and #fsl_shw_scco_clear_flags()
  */
-typedef enum fsl_shw_sym_ctx_flags_t {
-	/*!
-	 * Context is empty.  In ARC4, this means that the S-Box needs to be
-	 * generated from the key.  In #FSL_SYM_MODE_CBC mode, this allows an IV of
-	 * zero to be specified.  In #FSL_SYM_MODE_CTR mode, it means that an
-	 * initial CTR value of zero is desired.
-	 */
-	FSL_SYM_CTX_INIT = 1,
-	/*!
-	 * Load context from object into hardware before running cipher.  In
-	 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
-	 */
-	FSL_SYM_CTX_LOAD = 2,
-	/*!
-	 * Save context from hardware into object after running cipher.  In
-	 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
-	 */
-	FSL_SYM_CTX_SAVE = 4,
-	/*!
-	 * Context (SBox) is to be unwrapped and wrapped on each use.
-	 * This flag is unsupported.
-	 * */
-	FSL_SYM_CTX_PROTECT = 8,
+typedef enum fsl_shw_sym_ctx_flags_t
+{
+    /**
+     * Context is empty.  In ARC4, this means that the S-Box needs to be
+     * generated from the key.  In #FSL_SYM_MODE_CBC mode, this allows an IV of
+     * zero to be specified.  In #FSL_SYM_MODE_CTR mode, it means that an
+     * initial CTR value of zero is desired.
+     */
+    FSL_SYM_CTX_INIT = 1,
+    /**
+     * Load context from object into hardware before running cipher.  In
+     * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+     */
+    FSL_SYM_CTX_LOAD = 2,
+    /**
+     * Save context from hardware into object after running cipher.  In
+     * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+     */
+    FSL_SYM_CTX_SAVE = 4,
+    /**
+     * Context (SBox) is to be unwrapped and wrapped on each use.
+     * This flag is unsupported.
+     * */
+    FSL_SYM_CTX_PROTECT = 8,
 } fsl_shw_sym_ctx_flags_t;
 
-/*!
+
+/**
  * Flags which describe the state of the #fsl_shw_sko_t.
  *
  * These may be ORed together to get the desired effect.
  * See #fsl_shw_sko_set_flags() and #fsl_shw_sko_clear_flags()
  */
-typedef enum fsl_shw_key_flags_t {
-	FSL_SKO_KEY_IGNORE_PARITY = 1,	/*!< If algorithm is DES or 3DES, do not
-					   validate the key parity bits. */
-	FSL_SKO_KEY_PRESENT = 2,	/*!< Clear key is present in the object. */
-	FSL_SKO_KEY_ESTABLISHED = 4,	/*!< Key has been established for use.  This
-					   feature is not available for all
-					   platforms, nor for all algorithms and
-					   modes. */
-	FSL_SKO_USE_SECRET_KEY = 8,	/*!< Use device-unique key.  Not always
-					   available. */
+typedef enum fsl_shw_key_flags_t
+{
+    FSL_SKO_KEY_IGNORE_PARITY = 1, /**< If algorithm is DES or 3DES, do not
+                                      validate the key parity bits. */
+    FSL_SKO_KEY_PRESENT = 2,       /**< Clear key is present in the object. */
+    FSL_SKO_KEY_ESTABLISHED = 4,   /**< Key has been established for use.  This
+                                       feature is not available for all
+                                       platforms, nor for all algorithms and
+                                       modes.*/
+    FSL_SKO_USE_SECRET_KEY = 8,    /**< Use device-unique key.  Not always
+                                       available. */
 } fsl_shw_key_flags_t;
 
-/*!
+
+/**
  * Type of value which is associated with an established key.
  */
 typedef uint64_t key_userid_t;
 
-/*!
+
+/**
  * Flags which describe the state of the #fsl_shw_acco_t.
  *
  * The @a FSL_ACCO_CTX_INIT and @a FSL_ACCO_CTX_FINALIZE flags, when used
  * together, provide for a one-shot operation.
  */
-typedef enum fsl_shw_auth_ctx_flags_t {
-	FSL_ACCO_CTX_INIT = 1,	/*!< Initialize Context(s) */
-	FSL_ACCO_CTX_LOAD = 2,	/*!< Load intermediate context(s).
-				   This flag is unsupported. */
-	FSL_ACCO_CTX_SAVE = 4,	/*!< Save intermediate context(s).
-				   This flag is unsupported. */
-	FSL_ACCO_CTX_FINALIZE = 8,	/*!< Create MAC during this operation. */
-	FSL_ACCO_NIST_CCM = 0x10,	/*!< Formatting of CCM input data is
-					   performed by calls to
-					   #fsl_shw_ccm_nist_format_ctr_and_iv() and
-					   #fsl_shw_ccm_nist_update_ctr_and_iv().  */
-} fsl_shw_auth_ctx_flags_t;
-
-/*!
+typedef enum fsl_shw_auth_ctx_flags_t
+{
+    FSL_ACCO_CTX_INIT = 1,      /**< Initialize Context(s) */
+    FSL_ACCO_CTX_LOAD = 2,      /**< Load intermediate context(s).
+                                   This flag is unsupported. */
+    FSL_ACCO_CTX_SAVE = 4,      /**< Save intermediate context(s).
+                                   This flag is unsupported. */
+    FSL_ACCO_CTX_FINALIZE = 8,  /**< Create MAC during this operation. */
+    FSL_ACCO_NIST_CCM = 0x10,   /**< Formatting of CCM input data is
+                                    performed by calls to
+                                    #fsl_shw_ccm_nist_format_ctr_and_iv() and
+                                    #fsl_shw_ccm_nist_update_ctr_and_iv().  */
+}  fsl_shw_auth_ctx_flags_t;
+
+
+/**
  * The operation which controls the behavior of #fsl_shw_establish_key().
  *
  * These values are passed to #fsl_shw_establish_key().
  */
-typedef enum fsl_shw_key_wrap_t {
-	FSL_KEY_WRAP_CREATE,	/*!< Generate a key from random values. */
-	FSL_KEY_WRAP_ACCEPT,	/*!< Use the provided clear key. */
-	FSL_KEY_WRAP_UNWRAP	/*!< Unwrap a previously wrapped key. */
+typedef enum fsl_shw_key_wrap_t
+{
+    FSL_KEY_WRAP_CREATE,        /**< Generate a key from random values. */
+    FSL_KEY_WRAP_ACCEPT,        /**< Use the provided clear key. */
+    FSL_KEY_WRAP_UNWRAP         /**< Unwrap a previously wrapped key. */
 } fsl_shw_key_wrap_t;
 
-/*!
+
+/**
  *  Modulus Selector for CTR modes.
  *
  * The incrementing of the Counter value may be modified by a modulus.  If no
  * modulus is needed or desired for AES, use #FSL_CTR_MOD_128.
  */
-typedef enum fsl_shw_ctr_mod {
-	FSL_CTR_MOD_8,		/*!< Run counter with modulus of 2^8. */
-	FSL_CTR_MOD_16,		/*!< Run counter with modulus of 2^16. */
-	FSL_CTR_MOD_24,		/*!< Run counter with modulus of 2^24. */
-	FSL_CTR_MOD_32,		/*!< Run counter with modulus of 2^32. */
-	FSL_CTR_MOD_40,		/*!< Run counter with modulus of 2^40. */
-	FSL_CTR_MOD_48,		/*!< Run counter with modulus of 2^48. */
-	FSL_CTR_MOD_56,		/*!< Run counter with modulus of 2^56. */
-	FSL_CTR_MOD_64,		/*!< Run counter with modulus of 2^64. */
-	FSL_CTR_MOD_72,		/*!< Run counter with modulus of 2^72. */
-	FSL_CTR_MOD_80,		/*!< Run counter with modulus of 2^80. */
-	FSL_CTR_MOD_88,		/*!< Run counter with modulus of 2^88. */
-	FSL_CTR_MOD_96,		/*!< Run counter with modulus of 2^96. */
-	FSL_CTR_MOD_104,	/*!< Run counter with modulus of 2^104. */
-	FSL_CTR_MOD_112,	/*!< Run counter with modulus of 2^112. */
-	FSL_CTR_MOD_120,	/*!< Run counter with modulus of 2^120. */
-	FSL_CTR_MOD_128		/*!< Run counter with modulus of 2^128. */
+typedef enum fsl_shw_ctr_mod_t
+{
+    FSL_CTR_MOD_8,              /**< Run counter with modulus of 2^8. */
+    FSL_CTR_MOD_16,             /**< Run counter with modulus of 2^16. */
+    FSL_CTR_MOD_24,             /**< Run counter with modulus of 2^24. */
+    FSL_CTR_MOD_32,             /**< Run counter with modulus of 2^32. */
+    FSL_CTR_MOD_40,             /**< Run counter with modulus of 2^40. */
+    FSL_CTR_MOD_48,             /**< Run counter with modulus of 2^48. */
+    FSL_CTR_MOD_56,             /**< Run counter with modulus of 2^56. */
+    FSL_CTR_MOD_64,             /**< Run counter with modulus of 2^64. */
+    FSL_CTR_MOD_72,             /**< Run counter with modulus of 2^72. */
+    FSL_CTR_MOD_80,             /**< Run counter with modulus of 2^80. */
+    FSL_CTR_MOD_88,             /**< Run counter with modulus of 2^88. */
+    FSL_CTR_MOD_96,             /**< Run counter with modulus of 2^96. */
+    FSL_CTR_MOD_104,            /**< Run counter with modulus of 2^104. */
+    FSL_CTR_MOD_112,            /**< Run counter with modulus of 2^112. */
+    FSL_CTR_MOD_120,            /**< Run counter with modulus of 2^120. */
+    FSL_CTR_MOD_128             /**< Run counter with modulus of 2^128. */
 } fsl_shw_ctr_mod_t;
 
-/*!
+
+/**
  * A work type associated with a work/result queue request.
  */
-typedef enum shw_work_type {
-	SHW_WORK_GET_RANDOM = 1,	/*!< fsl_shw_get_random() request.  */
-	SHW_WORK_ADD_RANDOM,	/*!< fsl_shw_add_entropy() request.  */
+typedef enum shw_work_type_t
+{
+    SHW_WORK_GET_RANDOM = 1,    /**< fsl_shw_get_random() request.  */
+    SHW_WORK_ADD_RANDOM,        /**< fsl_shw_add_entropy() request.  */
 } shw_work_type_t;
 
-/*!****************************************************************************
+
+/**
+ * Permissions flags for Secure Partitions
+ */
+typedef enum fsl_shw_permission_t
+{
+/** SCM Access Permission: Do not zeroize/deallocate partition on SMN Fail state */
+    FSL_PERM_NO_ZEROIZE =       0x80000000,
+/** SCM Access Permission: Enforce trusted key read in  */
+    FSL_PERM_TRUSTED_KEY_READ = 0x40000000,
+/** SCM Access Permission: Ignore Supervisor/User mode in permission determination */
+    FSL_PERM_HD_S =             0x00000800,
+/** SCM Access Permission: Allow Read Access to  Host Domain */
+    FSL_PERM_HD_R =             0x00000400,
+/** SCM Access Permission: Allow Write Access to  Host Domain */
+    FSL_PERM_HD_W =             0x00000200,
+/** SCM Access Permission: Allow Execute Access to  Host Domain */
+    FSL_PERM_HD_X =             0x00000100,
+/** SCM Access Permission: Allow Read Access to Trusted Host Domain */
+    FSL_PERM_TH_R =             0x00000040,
+/** SCM Access Permission: Allow Write Access to Trusted Host Domain */
+    FSL_PERM_TH_W =             0x00000020,
+/** SCM Access Permission: Allow Read Access to Other/World Domain */
+    FSL_PERM_OT_R =             0x00000004,
+/** SCM Access Permission: Allow Write Access to Other/World Domain */
+    FSL_PERM_OT_W =             0x00000002,
+/** SCM Access Permission: Allow Execute Access to Other/World Domain */
+    FSL_PERM_OT_X =             0x00000001,
+} fsl_shw_permission_t;
+
+
+typedef enum fsl_shw_cypher_mode_t
+{
+    FSL_SHW_CYPHER_MODE_ECB = 1,       /**< ECB mode */
+    FSL_SHW_CYPHER_MODE_CBC = 2,       /**< CBC mode */
+} fsl_shw_cypher_mode_t;
+
+
+/*
+ * Structure passed during user ioctl() calls to manage data stored in secure
+ * partitions.
+ */
+typedef struct scc_region_t {
+    uint32_t            partition_base;
+    uint32_t            offset;
+    uint32_t            length;
+    uint8_t*            black_data;
+    uint64_t            owner_id;
+    fsl_shw_cypher_mode_t   cypher_mode;
+    uint32_t            IV[4];
+} scc_region_t;
+
+/******************************************************************************
  * Data Structures
  *****************************************************************************/
 
-/*!
+/**
  * Initialization Object
  */
-typedef struct fsl_sho_ibo {
+typedef struct fsl_sho_ibo
+{
 } fsl_sho_ibo_t;
 
-/*!
+
+/**
  * Common Entry structure for work queues, results queues.
  */
-typedef struct shw_queue_entry {
-	struct shw_queue_entry *next;	/*!< Next entry in queue. */
-	struct fsl_shw_uco_t *user_ctx;	/*!< Associated user context. */
-	uint32_t flags;		/*!< User context flags at time of request. */
-	void (*callback) (struct fsl_shw_uco_t * uco);	/*!< Any callback request. */
-	uint32_t user_ref;	/*!< User's reference for this request. */
-	fsl_shw_return_t code;	/*!< FSL SHW result of this operation. */
-	uint32_t detail1;	/*!< Any extra error info.  */
-	uint32_t detail2;	/*!< More any extra error info.  */
-	void *user_mode_req;	/*!<  Pointer into user space.  */
-	 uint32_t(*postprocess) (struct shw_queue_entry * q);	/*!< (internal)
-								   function to call
-								   when this operation
-								   completes.
-								 */
+typedef struct shw_queue_entry_t {
+    struct shw_queue_entry_t* next; /**< Next entry in queue. */
+    struct fsl_shw_uco_t*  user_ctx; /**< Associated user context. */
+    uint32_t         flags;     /**< User context flags at time of request. */
+    void (*callback)(struct fsl_shw_uco_t* uco); /**< Any callback request. */
+    uint32_t         user_ref;  /**< User's reference for this request. */
+    fsl_shw_return_t code;      /**< FSL SHW result of this operation. */
+    uint32_t         detail1;   /**< Any extra error info.  */
+    uint32_t         detail2;   /**< More any extra error info.  */
+    void*            user_mode_req; /**<  Pointer into user space.  */
+    uint32_t (*postprocess)(struct shw_queue_entry_t* q); /**< (internal)
+                                                           function to call
+                                                           when this operation
+                                                           completes.
+  */
 } shw_queue_entry_t;
 
-/*!
+
+/**
  * A queue.  Fields must be initialized to NULL before use.
  */
-typedef struct shw_queue {
-	struct shw_queue_entry *head;	/*!< First entry in queue. */
-	struct shw_queue_entry *tail;	/*!< Last entry. */
+typedef struct shw_queue_t
+{
+    struct shw_queue_entry_t* head; /**< First entry in queue. */
+    struct shw_queue_entry_t* tail; /**< Last entry. */
 } shw_queue_t;
 
+
+/**
+ * Secure Partition information
+ */
+typedef struct fsl_shw_spo_t
+{
+    uint32_t                user_base;
+    void*                   kernel_base;
+    struct fsl_shw_spo_t*   next;
+} fsl_shw_spo_t;
+
+
 /* REQ-FSLSHW-PINTFC-COA-UCO-001 */
-/*!
+/**
  * User Context Object
  */
-typedef struct fsl_shw_uco_t {
-	int openfd;		/*!< user-mode file descriptor */
-	uint32_t user_ref;	/*!< User's reference */
-	void (*callback) (struct fsl_shw_uco_t * uco);	/*!< User's callback fn  */
-	uint32_t flags;		/*!< from fsl_shw_user_ctx_flags_t */
-	unsigned pool_size;	/*!< maximum size of user result pool */
+typedef struct fsl_shw_uco_t
+{
+    int           openfd;       /**< user-mode file descriptor */
+    uint32_t      user_ref;     /**< User's reference */
+    void (*callback)(struct fsl_shw_uco_t* uco); /**< User's callback fn  */
+    uint32_t      flags;             /**< from fsl_shw_user_ctx_flags_t */
+    unsigned      pool_size;    /**< maximum size of user result pool */
 #ifdef __KERNEL__
-	shw_queue_t result_pool;	/*!< where non-blocking results go */
-	os_process_handle_t process;	/*!< remember for signalling User mode */
+    shw_queue_t   result_pool;  /**< where non-blocking results go */
+    os_process_handle_t  process; /**< remember for signalling User mode */
+    fsl_shw_spo_t* partition;    /**< chain of secure partitions owned by
+                                          the user */
 #endif
-	struct fsl_shw_uco_t *next;	/*!< To allow user-mode chaining of contexts,
-					   for signalling and in kernel, to link user
-					   contexts.  */
+    struct fsl_shw_uco_t* next; /**< To allow user-mode chaining of contexts,
+                                 for signalling and in kernel, to link user
+                                 contexts.  */
 } fsl_shw_uco_t;
 
+
 /* REQ-FSLSHW-PINTFC-API-GEN-006  ??  */
-/*!
+/**
  * Result object
  */
-typedef struct fsl_shw_result_t {
-	uint32_t user_ref;	/*!< User's reference at time of request. */
-	fsl_shw_return_t code;	/*!< Return code from request. */
-	uint32_t detail1;	/*!< Extra error info. Unused in SHW driver. */
-	uint32_t detail2;	/*!< Extra error info. Unused in SHW driver. */
-	void *user_req;		/*!< Pointer to original user request. */
+typedef struct fsl_shw_result_t
+{
+    uint32_t         user_ref;  /**< User's reference at time of request. */
+    fsl_shw_return_t code;      /**< Return code from request. */
+    uint32_t         detail1;   /**< Extra error info. Unused in SHW driver. */
+    uint32_t         detail2;   /**< Extra error info. Unused in SHW driver. */
+    void*            user_req;  /**< Pointer to original user request. */
 } fsl_shw_result_t;
 
+
+/**
+ * Keystore Object
+ */
+typedef struct fsl_shw_kso_t
+{
+#ifdef __KERNEL__
+    os_lock_t       lock;           /**< Pointer to lock that controls access to
+                                      the keystore. */
+#endif
+    void*           user_data;      /**< Pointer to user structure that handles
+                                      the internals of the keystore. */
+    fsl_shw_return_t (*data_init)        (fsl_shw_uco_t* user_ctx,
+                                          void** user_data);
+    void             (*data_cleanup)     (fsl_shw_uco_t* user_ctx,
+                                          void** user_data);
+    fsl_shw_return_t (*slot_verify_access)(void* user_data, uint64_t owner_id,
+                                          uint32_t slot);
+    fsl_shw_return_t (*slot_alloc)       (void* user_data, uint32_t size_bytes,
+                                          uint64_t owner_id, uint32_t* slot);
+    fsl_shw_return_t (*slot_dealloc)     (void* user_data,
+                                          uint64_t owner_id, uint32_t slot);
+    void*            (*slot_get_address) (void* user_data, uint32_t slot);
+    uint32_t         (*slot_get_base)    (void* user_data, uint32_t slot);
+    uint32_t         (*slot_get_offset)  (void* user_data, uint32_t slot);
+    uint32_t         (*slot_get_slot_size)  (void* user_data, uint32_t slot);
+} fsl_shw_kso_t;
+
+
 /* REQ-FSLSHW-PINTFC-COA-SKO-001 */
-/*!
+/**
  * Secret Key Context Object
  */
-typedef struct fsl_shw_sko_t {
-	uint32_t flags;		/*!<  Flags from #fsl_shw_sym_ctx_flags_t. */
-	fsl_shw_key_alg_t algorithm;	/*!< Algorithm for this key. */
-	key_userid_t userid;	/*!< User's identifying value for Black key. */
-	uint32_t handle;	/*!< Reference in SCC driver for Red key. */
-	uint16_t key_length;	/*!< Length of stored key, in bytes. */
-	uint8_t key[64];	/*!< Bytes of stored key. */
+typedef struct fsl_shw_sko_t
+{
+    uint32_t          flags;    /**<  Flags from #fsl_shw_sym_ctx_flags_t. */
+    fsl_shw_key_alg_t algorithm; /**< Algorithm for this key. */
+    key_userid_t      userid;   /**< User's identifying value for Black key. */
+    uint32_t          handle;   /**< Reference in SCC driver for Red key. */
+    uint16_t          key_length;  /**< Length of stored key, in bytes. */
+    uint8_t           key[64];  /**< Bytes of stored key. */
+    struct fsl_shw_kso_t*   keystore;   /**< If present, key is in keystore */
 } fsl_shw_sko_t;
 
+
 /* REQ-FSLSHW-PINTFC-COA-CO-001 */
-/*!
+/**
  * Platform Capability Object
  *
  * Pointer to this structure is returned by fsl_shw_get_capabilities() and
  * queried with the various fsl_shw_pco_() functions.
  */
-typedef struct fsl_shw_pco_t {
-	int api_major;		/*!< Major version number for API. */
-	int api_minor;		/*!< Minor version number for API. */
-	int driver_major;	/*!< Major version of some driver. */
-	int driver_minor;	/*!< Minor version of some driver. */
-	unsigned sym_algorithm_count;	/*!< Number of sym_algorithms. */
-	fsl_shw_key_alg_t *sym_algorithms;	/*!< Pointer to array. */
-	unsigned sym_mode_count;	/*!< Number of sym_modes. */
-	fsl_shw_sym_mode_t *sym_modes;	/*!< Pointer to array. */
-	unsigned hash_algorithm_count;	/*!< Number of hash_algorithms. */
-	fsl_shw_hash_alg_t *hash_algorithms;	/*!< Pointer to array */
-	uint8_t sym_support[5][4];	/*!< indexed by key alg then mode */
+typedef struct fsl_shw_pco_t
+{
+    int api_major;              /**< Major version number for API. */
+    int api_minor;              /**< Minor version number for API. */
+    int driver_major;           /**< Major version of some driver. */
+    int driver_minor;           /**< Minor version of some driver. */
+    unsigned sym_algorithm_count;           /**< Number of sym_algorithms. */
+    fsl_shw_key_alg_t*  sym_algorithms; /**< Pointer to array. */
+    unsigned sym_mode_count;    /**< Number of sym_modes. */
+    fsl_shw_sym_mode_t* sym_modes; /**< Pointer to array. */
+    unsigned hash_algorithm_count; /**< Number of hash_algorithms. */
+    fsl_shw_hash_alg_t* hash_algorithms; /**< Pointer to array */
+    uint8_t sym_support[5][4];  /**< indexed by key alg then mode */
+
+    int scc_driver_major;
+    int scc_driver_minor;
+    int scm_version;            /**< Version from SCM Configuration register */
+    int smn_version;            /**< Version from SMN Status register */
+    int block_size_bytes;       /**< Number of bytes per block of RAM; also
+                                   block size of the crypto algorithm. */
+    union {
+        struct scc_info {
+            int black_ram_size_blocks;  /**< Number of blocks of Black RAM */
+            int red_ram_size_blocks;    /**< Number of blocks of Red RAM */
+        } scc_info;
+        struct scc2_info {
+            int partition_size_bytes;   /**< Number of bytes in each partition */
+            int partition_count;        /**< Number of partitions on this platform */
+        } scc2_info;
+    };
 } fsl_shw_pco_t;
 
+
 /* REQ-FSLSHW-PINTFC-COA-HCO-001 */
-/*!
+/**
  * Hash Context Object
  */
-typedef struct fsl_shw_hco_t {	/* fsl_shw_hash_context_object */
-	fsl_shw_hash_alg_t algorithm;	/*!< Algorithm for this context. */
-	uint32_t flags;		/*!< Flags from
-				   #fsl_shw_hash_ctx_flags_t. */
-	uint8_t digest_length;	/*!< hash result length in bytes */
-	uint8_t context_length;	/*!< Context length in bytes */
-	uint8_t context_register_length;	/*!< in bytes */
-	uint32_t context[9];	/*!< largest digest + msg size */
+typedef struct fsl_shw_hco_t /* fsl_shw_hash_context_object */
+{
+    fsl_shw_hash_alg_t       algorithm; /**< Algorithm for this context. */
+    uint32_t                 flags; /**< Flags from
+                                       #fsl_shw_hash_ctx_flags_t. */
+    uint8_t                  digest_length; /**< hash result length in bytes */
+    uint8_t                  context_length; /**< Context length in bytes */
+    uint8_t                  context_register_length; /**< in bytes */
+    uint32_t                 context[9]; /**< largest digest + msg size */
 } fsl_shw_hco_t;
 
+
 /* REQ-FSLSHW-PINTFC-COA-HCO-001 */
-/*!
+/**
  * HMAC Context Object
  */
-typedef struct fsl_shw_hmco_t {	/* fsl_shw_hmac_context_object */
-	fsl_shw_hash_alg_t algorithm;	/*!< Hash algorithm for the HMAC. */
-	uint32_t flags;		/*!< Flags from
-				   #fsl_shw_hmac_ctx_flags_t. */
-	uint8_t digest_length;	/*!< in bytes */
-	uint8_t context_length;	/*!< in bytes */
-	uint8_t context_register_length;	/*!< in bytes */
-	uint32_t ongoing_context[9];	/*!< largest digest + msg
-					   size */
-	uint32_t inner_precompute[9];	/*!< largest digest + msg
-					   size */
-	uint32_t outer_precompute[9];	/*!< largest digest + msg
-					   size */
+typedef struct fsl_shw_hmco_t /* fsl_shw_hmac_context_object */
+{
+    fsl_shw_hash_alg_t       algorithm; /**< Hash algorithm for the HMAC. */
+    uint32_t                 flags; /**< Flags from
+                                       #fsl_shw_hmac_ctx_flags_t. */
+    uint8_t                  digest_length; /**< in bytes */
+    uint8_t                  context_length; /**< in bytes */
+    uint8_t                  context_register_length; /**< in bytes */
+    uint32_t                 ongoing_context[9]; /**< largest digest + msg
+                                                    size */
+    uint32_t                 inner_precompute[9]; /**< largest digest + msg
+                                                      size */
+    uint32_t                 outer_precompute[9]; /**< largest digest + msg
+                                                      size */
 } fsl_shw_hmco_t;
 
+
 /* REQ-FSLSHW-PINTFC-COA-SCCO-001 */
-/*!
+/**
  * Symmetric Crypto Context Object Context Object
  */
-typedef struct fsl_shw_scco_t {
-	uint32_t flags;		/*!< Flags from #fsl_shw_sym_ctx_flags_t. */
-	unsigned block_size_bytes;	/*!< Both block and ctx size */
-	fsl_shw_sym_mode_t mode;	/*!< Symmetric mode for this context. */
-	/* Could put modulus plus 16-octet context in union with arc4
-	   sbox+ptrs... */
-	fsl_shw_ctr_mod_t modulus_exp;	/*!< Exponent value for CTR modulus */
-	uint8_t context[259];	/*!< Stored context.  Large enough
-				   for ARC4.  */
+typedef struct fsl_shw_scco_t
+{
+    uint32_t                flags; /**< Flags from #fsl_shw_sym_ctx_flags_t. */
+    unsigned                block_size_bytes; /**< Both block and ctx size */
+    fsl_shw_sym_mode_t      mode; /**< Symmetric mode for this context. */
+    /* Could put modulus plus 16-octet context in union with arc4
+       sbox+ptrs... */
+    fsl_shw_ctr_mod_t       modulus_exp; /**< Exponent value for CTR modulus */
+    uint8_t                 context[259]; /**< Stored context.  Large enough
+                                             for ARC4.  */
 } fsl_shw_scco_t;
 
-/*!
+
+/**
  * Authenticate-Cipher Context Object
 
  * An object for controlling the function of, and holding information about,
  * data for the authenticate-cipher functions, #fsl_shw_gen_encrypt() and
  * #fsl_shw_auth_decrypt().
  */
-typedef struct fsl_shw_acco_t {
-	uint32_t flags;		/*!< See #fsl_shw_auth_ctx_flags_t for
-				   meanings */
-	fsl_shw_acc_mode_t mode;	/*!< CCM only */
-	uint8_t mac_length;	/*!< User's value for length  */
-	unsigned q_length;	/*!< NIST parameter - */
-	fsl_shw_scco_t cipher_ctx_info;	/*!< For running
-					   encrypt/decrypt. */
-	union {
-		fsl_shw_scco_t CCM_ctx_info;	/*!< For running the CBC in
-						   AES-CCM.  */
-		fsl_shw_hco_t hash_ctx_info;	/*!< For running the hash */
-	} auth_info;		/*!< "auth" info struct  */
-	uint8_t unencrypted_mac[16];	/*!< max block size... */
+typedef struct fsl_shw_acco_t
+{
+    uint32_t                 flags; /**< See #fsl_shw_auth_ctx_flags_t for
+                                       meanings */
+    fsl_shw_acc_mode_t       mode; /**< CCM only */
+    uint8_t                  mac_length; /**< User's value for length  */
+    unsigned                 q_length; /**< NIST parameter - */
+    fsl_shw_scco_t           cipher_ctx_info; /**< For running
+                                                 encrypt/decrypt. */
+    union {
+        fsl_shw_scco_t       CCM_ctx_info; /**< For running the CBC in
+                                              AES-CCM.  */
+        fsl_shw_hco_t        hash_ctx_info; /**< For running the hash */
+    } auth_info;                /**< "auth" info struct  */
+    uint8_t                  unencrypted_mac[16]; /**< max block size... */
 } fsl_shw_acco_t;
 
-/*!
+
+/**
  * Common header in request structures between User-mode API and SHW driver.
  */
 struct shw_req_header {
-	uint32_t flags;		/*!< Flags - from user-mode context. */
-	uint32_t user_ref;	/*!< Reference - from user-mode context. */
-	fsl_shw_return_t code;	/*!< Result code for operation. */
+    uint32_t           flags;   /**< Flags - from user-mode context. */
+    uint32_t           user_ref; /**< Reference - from user-mode context. */
+    fsl_shw_return_t   code;    /**< Result code for operation. */
 };
 
-/*!
+/**
  *  Used by user-mode API to retrieve completed non-blocking results in
  *  SHW_USER_REQ_GET_RESULTS ioctl().
  */
 struct results_req {
-	struct shw_req_header hdr;	/*!< Boilerplate. */
-	unsigned requested;	/*!< number of results requested, */
-	unsigned actual;	/*!< number of results obtained. */
-	fsl_shw_result_t *results;	/*!< pointer to memory to hold results. */
+    struct shw_req_header hdr;  /**< Boilerplate. */
+    unsigned         requested; /**< number of results requested, */
+    unsigned         actual;    /**< number of results obtained. */
+    fsl_shw_result_t *results;  /**< pointer to memory to hold results. */
 };
 
-/*!
+
+/**
  * Used by user-mode API to retrieve hardware capabilities in
  * SHW_USER_REQ_GET_CAPABILITIES ioctl().
  */
 struct capabilities_req {
-	struct shw_req_header hdr;	/*!< Boilerplate. */
-	unsigned size;		/*!< Size, in bytes, capabilities. */
-	fsl_shw_pco_t *capabilities;	/*!< Place to copy out the info. */
+    struct shw_req_header hdr;  /**< Boilerplate. */
+    unsigned         size;      /**< Size, in bytes, capabilities. */
+    fsl_shw_pco_t*   capabilities; /**< Place to copy out the info. */
 };
 
-/*!
+
+/**
  * Used by user-mode API to get a random number
  */
 struct get_random_req {
-	struct shw_req_header hdr;	/*!< Boilerplate. */
-	unsigned size;		/*!< Size, in bytes, of random. */
-	uint8_t *random;	/*!< Place to copy out the random number. */
+    struct shw_req_header hdr;  /**< Boilerplate. */
+    unsigned         size;      /**< Size, in bytes, of random. */
+    uint8_t*         random;    /**< Place to copy out the random number. */
 };
 
-/*!
+
+/**
  * Used by API to add entropy to a random number generator
  */
 struct add_entropy_req {
-	struct shw_req_header hdr;	/*!< Boilerplate. */
-	unsigned size;		/*!< Size, in bytes, of entropy. */
-	uint8_t *entropy;	/*!< Location of the entropy to be added. */
+    struct shw_req_header hdr;  /**< Boilerplate. */
+    unsigned         size;      /**< Size, in bytes, of entropy. */
+    uint8_t*         entropy;   /**< Location of the entropy to be added. */
 };
 
-/*!****************************************************************************
+
+/******************************************************************************
  * External variables
  *****************************************************************************/
 #ifdef __KERNEL__
 extern os_lock_t shw_queue_lock;
 
+extern fsl_shw_uco_t* user_list;
 #endif
 
-/*!****************************************************************************
+
+/******************************************************************************
  * Access Macros for Objects
  *****************************************************************************/
-/*!
+/**
  * Get FSL SHW API version
  *
  * @param      pcobject  The Platform Capababilities Object to query.
- * @param pcmajor   A pointer to where the major version
+ * @param[out] pcmajor   A pointer to where the major version
  *                       of the API is to be stored.
- * @param pcminor   A pointer to where the minor version
+ * @param[out] pcminor   A pointer to where the minor version
  *                       of the API is to be stored.
  */
 #define fsl_shw_pco_get_version(pcobject, pcmajor, pcminor)                   \
@@ -644,13 +901,14 @@ do {                                                                          \
     *(pcminor) = (pcobject)->api_minor;                                       \
 } while (0)
 
-/*!
+
+/**
  * Get underlying driver version.
  *
  * @param      pcobject  The Platform Capababilities Object to query.
- * @param      pcmajor   A pointer to where the major version
+ * @param[out] pcmajor   A pointer to where the major version
  *                       of the driver is to be stored.
- * @param      pcminor   A pointer to where the minor version
+ * @param[out] pcminor   A pointer to where the minor version
  *                       of the driver is to be stored.
  */
 #define fsl_shw_pco_get_driver_version(pcobject, pcmajor, pcminor)            \
@@ -659,13 +917,14 @@ do {                                                                          \
     *(pcminor) = (pcobject)->driver_minor;                                    \
 } while (0)
 
-/*!
+
+/**
  * Get list of symmetric algorithms supported.
  *
  * @param pcobject           The Platform Capababilities Object to query.
- * @param  pcalgorithms  A pointer to where to store the location of
+ * @param[out] pcalgorithms  A pointer to where to store the location of
  *                           the list of algorithms.
- * @param  pcacount      A pointer to where to store the number of
+ * @param[out] pcacount      A pointer to where to store the number of
  *                           algorithms in the list at @a algorithms.
  */
 #define fsl_shw_pco_get_sym_algorithms(pcobject, pcalgorithms, pcacount)      \
@@ -674,13 +933,14 @@ do {                                                                          \
     *(pcacount) = (pcobject)->sym_algorithm_count;                            \
 } while (0)
 
-/*!
+
+/**
  * Get list of symmetric modes supported.
  *
  * @param pcobject        The Platform Capababilities Object to query.
- * @param gsmodes    A pointer to where to store the location of
+ * @param[out] gsmodes    A pointer to where to store the location of
  *                        the list of modes.
- * @param gsacount   A pointer to where to store the number of
+ * @param[out] gsacount   A pointer to where to store the number of
  *                        algorithms in the list at @a modes.
  */
 #define fsl_shw_pco_get_sym_modes(pcobject, gsmodes, gsacount)                \
@@ -689,13 +949,14 @@ do {                                                                          \
     *(gsacount) = (pcobject)->sym_mode_count;                                 \
 } while (0)
 
-/*!
+
+/**
  * Get list of hash algorithms supported.
  *
- * @param    pcobject        The Platform Capababilities Object to query.
- * @param    gsalgorithms    A pointer which will be set to the list of
+ * @param pcobject           The Platform Capababilities Object to query.
+ * @param[out] gsalgorithms  A pointer which will be set to the list of
  *                           algorithms.
- * @param    gsacount        The number of algorithms in the list at @a
+ * @param[out] gsacount      The number of algorithms in the list at @a
  *                           algorithms.
  */
 #define fsl_shw_pco_get_hash_algorithms(pcobject, gsalgorithms, gsacount)     \
@@ -704,7 +965,8 @@ do {                                                                          \
     *(gsacount) = (pcobject)->hash_algorithm_count;                           \
 } while (0)
 
-/*!
+
+/**
  * Determine whether the combination of a given symmetric algorithm and a given
  * mode is supported.
  *
@@ -717,7 +979,8 @@ do {                                                                          \
 #define fsl_shw_pco_check_sym_supported(pcobject, pcalg, pcmode)              \
     0
 
-/*!
+
+/**
  * Determine whether a given Encryption-Authentication mode is supported.
  *
  * @param pcobject  The Platform Capababilities Object to query.
@@ -728,7 +991,8 @@ do {                                                                          \
 #define fsl_shw_pco_check_auth_supported(pcobject, pcmode)                    \
     0
 
-/*!
+
+/**
  * Determine whether Black Keys (key establishment / wrapping) is supported.
  *
  * @param pcobject  The Platform Capababilities Object to query.
@@ -738,113 +1002,112 @@ do {                                                                          \
 #define fsl_shw_pco_check_black_key_supported(pcobject)                       \
     0
 
-/*!
- * Initialize a User Context Object.
- *
- * This function must be called before performing any other operation with the
- * Object.  It sets the User Context Object to initial values, and set the size
- * of the results pool.  The mode will be set to a default of
- * #FSL_UCO_BLOCKING_MODE.
- *
- * When using non-blocking operations, this sets the maximum number of
- * operations which can be outstanding.  This number includes the counts of
- * operations waiting to start, operation(s) being performed, and results which
- * have not been retrieved.
- *
- * Changes to this value are ignored once user registration has completed.  It
- * should be set to 1 if only blocking operations will ever be performed.
+
+/**
+ * Get FSL SHW SCC driver version
  *
- * @param ucontext     The User Context object to operate on.
- * @param usize        The maximum number of operations which can be
- *                     outstanding.
- */
-#define fsl_shw_uco_init(ucontext, usize)                                     \
-do {                                                                          \
-    fsl_shw_uco_t* uco = ucontext;                                            \
-                                                                              \
-    (uco)->pool_size = usize;                                                 \
-    (uco)->flags = FSL_UCO_BLOCKING_MODE | FSL_UCO_CONTEXT_CHANGED;           \
-    (uco)->openfd = -1;                                                       \
-    (uco)->callback = NULL;                                                   \
-} while (0)
+ * @param      pcobject  The Platform Capababilities Object to query.
+ * @param[out] pcmajor   A pointer to where the major version
+ *                       of the SCC driver is to be stored.
+ * @param[out] pcminor   A pointer to where the minor version
+ *                       of the SCC driver is to be stored.
+ */
+#define fsl_shw_pco_get_scc_driver_version(pcobject, pcmajor, pcminor)        \
+{                                                                             \
+    *(pcmajor) = (pcobject)->scc_driver_major;                                \
+    *(pcminor) = (pcobject)->scc_driver_minor;                                \
+}
 
-/*!
- * Set the User Reference for the User Context.
+
+/**
+ * Get SCM hardware version
  *
- * @param ucontext     The User Context object to operate on.
- * @param uref         A value which will be passed back with a result.
+ * @param      pcobject  The Platform Capababilities Object to query.
+ * @return               The SCM hardware version
  */
-#define fsl_shw_uco_set_reference(ucontext, uref)                             \
-do {                                                                          \
-    fsl_shw_uco_t* uco = ucontext;                                            \
-                                                                              \
-    (uco)->user_ref = uref;                                                   \
-    (uco)->flags |= FSL_UCO_CONTEXT_CHANGED;                                  \
-} while (0)
+#define fsl_shw_pco_get_scm_version(pcobject)                                 \
+    ((pcobject)->scm_version)
 
-/*!
- * Set the User Reference for the User Context.
+
+/**
+ * Get SMN hardware version
  *
- * @param ucontext     The User Context object to operate on.
- * @param ucallback    The function the API will invoke when an operation
- *                     completes.
+ * @param      pcobject  The Platform Capababilities Object to query.
+ * @return               The SMN hardware version
  */
-#define fsl_shw_uco_set_callback(ucontext, ucallback)                         \
-do {                                                                          \
-    fsl_shw_uco_t* uco = ucontext;                                            \
-                                                                              \
-    (uco)->callback = ucallback;                                              \
-    (uco)->flags |= FSL_UCO_CONTEXT_CHANGED;                                  \
-} while (0)
+#define fsl_shw_pco_get_smn_version(pcobject)                                 \
+    ((pcobject)->smn_version)
 
-/*!
- * Set flags in the User Context.
- *
- * Turns on the flags specified in @a flags.  Other flags are untouched.
+
+/**
+ * Get the size of an SCM block, in bytes
  *
- * @param ucontext     The User Context object to operate on.
- * @param uflags       ORed values from #fsl_shw_user_ctx_flags_t.
- */
-#define fsl_shw_uco_set_flags(ucontext, uflags)                               \
-      (ucontext)->flags |= (uflags) | FSL_UCO_CONTEXT_CHANGED
+ * @param      pcobject  The Platform Capababilities Object to query.
+ * @return               The size of an SCM block, in bytes.
+ */
+#define fsl_shw_pco_get_scm_block_size(pcobject)                              \
+    ((pcobject)->block_size_bytes)
+
+
+/**
+ * Get size of Black and Red RAM memory
+ *
+ * @param      pcobject    The Platform Capababilities Object to query.
+ * @param[out] black_size  A pointer to where the size of the Black RAM, in
+ *                         blocks, is to be placed.
+ * @param[out] red_size    A pointer to where the size of the Red RAM, in 
+ *                         blocks, is to be placed.
+ */
+#define fsl_shw_pco_get_smn_size(pcobject, black_size, red_size)              \
+{                                                                             \
+    if ((pcobject)->scm_version == 1) {                                       \
+        *(black_size) = (pcobject)->scc_info.black_ram_size_blocks;           \
+        *(red_size)   = (pcobject)->scc_info.red_ram_size_blocks;             \
+    } else {                                                                  \
+        *(black_size) = 0;                                                    \
+        *(red_size)   = 0;                                                    \
+    }                                                                         \
+}
 
-/*!
- * Clear flags in the User Context.
+
+/**
+ * Determine whether Secure Partitions are supported
  *
- * Turns off the flags specified in @a flags.  Other flags are untouched.
+ * @param pcobject   The Platform Capababilities Object to query.
  *
- * @param ucontext     The User Context object to operate on.
- * @param uflags       ORed values from #fsl_shw_user_ctx_flags_t.
+ * @return 0 if secure partitions are not supported, non-zero if supported.
  */
-#define fsl_shw_uco_clear_flags(ucontext, uflags)                             \
-do {                                                                          \
-    fsl_shw_uco_t* uco = ucontext;                                            \
-                                                                              \
-    (uco)->flags &= ~(uflags);                                                \
-    (uco)->flags |= FSL_UCO_CONTEXT_CHANGED;                                  \
-} while (0)
+#define fsl_shw_pco_check_spo_supported(pcobject)                           \
+    ((pcobject)->scm_version == 2)
 
-/*!
- * Retrieve the reference value from a Result Object.
- *
- * @param robject  The result object to query.
+
+/**
+ * Get the size of a Secure Partitions
  *
- * @return The reference associated with the request.
+ * @param pcobject   The Platform Capababilities Object to query.
+ * 
+ * @return Partition size, in bytes.  0 if Secure Partitions not supported.
  */
-#define fsl_shw_ro_get_reference(robject)                                    \
-       (robject)->user_ref
+#define fsl_shw_pco_get_spo_size_bytes(pcobject)                            \
+    (((pcobject)->scm_version == 2) ?                                       \
+        ((pcobject)->scc2_info.partition_size_bytes) : 0 )                  \
 
-/*!
- * Retrieve the status code from a Result Object.
- *
- * @param robject  The result object to query.
+
+/**
+ * Get the number of Secure Partitions on this platform
  *
- * @return The status of the request.
+ * @param pcobject   The Platform Capababilities Object to query.
+ * 
+ * @return Number of partitions. 0 if Secure Paritions not supported.  Note
+ *         that this returns the total number of partitions, not all may be
+ *         available to the user.
  */
-#define fsl_shw_ro_get_status(robject)                                       \
-       (robject)->code
+#define fsl_shw_pco_get_spo_count(pcobject)                                 \
+    (((pcobject)->scm_version == 2) ?                                       \
+        ((pcobject)->scc2_info.partition_count) : 0 )                       \
+
 
-/*!
+/**
  * Initialize a Secret Key Object.
  *
  * This function must be called before performing any other operation with
@@ -855,12 +1118,14 @@ do {                                                                          \
  *
  */
 #define fsl_shw_sko_init(skobject,skalgorithm)                               \
-do {                                                                         \
+{                                                                            \
        (skobject)->algorithm = skalgorithm;                                  \
        (skobject)->flags = 0;                                                \
-} while (0)
+       (skobject)->keystore = NULL;                                          \
+}
 
-/*!
+
+/**
  * Store a cleartext key in the key object.
  *
  * This has the side effect of setting the #FSL_SKO_KEY_PRESENT flag and
@@ -874,14 +1139,14 @@ do {                                                                         \
  *                     call.
  */
 #define fsl_shw_sko_set_key(skobject, skkey, skkeylen)                       \
-do {                                                                         \
+{                                                                            \
        (skobject)->key_length = skkeylen;                                    \
-       memcpy((skobject)->key, skkey, skkeylen);                             \
+       copy_bytes((skobject)->key, skkey, skkeylen);                         \
        (skobject)->flags |= FSL_SKO_KEY_PRESENT;                             \
        (skobject)->flags &= ~FSL_SKO_KEY_ESTABLISHED;                        \
-} while (0)
+}
 
-/*!
+/**
  * Set a size for the key.
  *
  * This function would normally be used when the user wants the key to be
@@ -896,7 +1161,8 @@ do {                                                                         \
 #define fsl_shw_sko_set_key_length(skobject, skkeylen)                       \
        (skobject)->key_length = skkeylen;
 
-/*!
+
+/**
  * Set the User ID associated with the key.
  *
  * @param skobject   A variable of type #fsl_shw_sko_t.
@@ -905,7 +1171,15 @@ do {                                                                         \
 #define fsl_shw_sko_set_user_id(skobject, skuserid)                           \
        (skobject)->userid = (skuserid)
 
-/*!
+/**
+ * Establish a user Keystore to hold the key.
+ */
+#define fsl_shw_sko_set_keystore(skobject, user_keystore)                     \
+       (skobject)->keystore = (user_keystore)
+
+
+
+/**
  * Set the establish key handle into a key object.
  *
  * The @a userid field will be used to validate the access to the unwrapped
@@ -921,15 +1195,16 @@ do {                                                                         \
  * @param skhandle   A @a handle from #fsl_shw_sko_get_established_info.
  */
 #define fsl_shw_sko_set_established_info(skobject, skuserid, skhandle)        \
-do {                                                                          \
+{                                                                             \
        (skobject)->userid = (skuserid);                                       \
        (skobject)->handle = (skhandle);                                       \
        (skobject)->flags |= FSL_SKO_KEY_ESTABLISHED;                          \
        (skobject)->flags &=                                                   \
                        ~(FSL_SKO_KEY_PRESENT);   \
-} while (0)
+}
 
-/*!
+
+/**
  * Retrieve the established-key handle from a key object.
  *
  * @param skobject   A variable of type #fsl_shw_sko_t.
@@ -939,16 +1214,38 @@ do {                                                                          \
 #define fsl_shw_sko_get_established_info(skobject, skhandle)                  \
        *(skhandle) = (skobject)->handle
 
-/*!
+
+/**
  * Extract the algorithm from a key object.
  *
  * @param      skobject     The Key Object to be queried.
- * @param skalgorithm  A pointer to the location to store the algorithm.
+ * @param[out] skalgorithm  A pointer to the location to store the algorithm.
  */
 #define fsl_shw_sko_get_algorithm(skobject, skalgorithm)                      \
        *(skalgorithm) = (skobject)->algorithm
 
-/*!
+
+/**
+ * Retrieve the cleartext key from a key object that is stored in a user
+ * keystore.
+ *
+ * @param      skobject     The Key Object to be queried.
+ * @param[out] skkey        A pointer to the location to store the key.  NULL
+ *                          if the key is not stored in a user keystore.
+ */
+#define fsl_shw_sko_get_key(skobject, skkey)                                  \
+{                                                                             \
+    fsl_shw_kso_t* keystore = (skobject)->keystore;                           \
+    if (keystore != NULL) {                                                   \
+        *(skkey) = keystore->slot_get_address(keystore->user_data,            \
+                                              (skobject)->handle);            \
+    } else {                                                                  \
+        *(skkey) = NULL;                                                      \
+    }                                                                         \
+}
+
+
+/**
  * Determine the size of a wrapped key based upon the cleartext key's length.
  *
  * This function can be used to calculate the number of octets that
@@ -962,15 +1259,16 @@ do {                                                                          \
  *                              version of the key in @a key_info.
  */
 #define fsl_shw_sko_calculate_wrapped_size(wkeyinfo, wkeylen)                 \
-do {                                                                          \
+{                                                                             \
      if ((wkeyinfo)->key_length > 32) {                                       \
          *(wkeylen) = 0;                                                      \
      } else {                                                                 \
          *(wkeylen) = 66;                                                     \
      }                                                                        \
-} while (0)
+}
+
 
-/*!
+/**
  * Set some flags in the key object.
  *
  * Turns on the flags specified in @a flags.  Other flags are untouched.
@@ -982,7 +1280,8 @@ do {                                                                          \
 #define fsl_shw_sko_set_flags(skobject, skflags)                              \
       (skobject)->flags |= (skflags)
 
-/*!
+
+/**
  * Clear some flags in the key object.
  *
  * Turns off the flags specified in @a flags.  Other flags are untouched.
@@ -994,8 +1293,138 @@ do {                                                                          \
 #define fsl_shw_sko_clear_flags(skobject, skflags)                            \
       (skobject)->flags &= ~(skflags)
 
+/**
+ * Initialize a User Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the User Context Object to initial values, and set the size
+ * of the results pool.  The mode will be set to a default of
+ * #FSL_UCO_BLOCKING_MODE.
+ *
+ * When using non-blocking operations, this sets the maximum number of
+ * operations which can be outstanding.  This number includes the counts of
+ * operations waiting to start, operation(s) being performed, and results which
+ * have not been retrieved.
+ *
+ * Changes to this value are ignored once user registration has completed.  It
+ * should be set to 1 if only blocking operations will ever be performed.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param usize        The maximum number of operations which can be
+ *                     outstanding.
+ */
+#ifdef __KERNEL__
+
+#define fsl_shw_uco_init(ucontext, usize)                                     \
+do {                                                                          \
+    fsl_shw_uco_t* uco = ucontext;                                            \
+                                                                              \
+    (uco)->pool_size = usize;                                                 \
+    (uco)->flags = FSL_UCO_BLOCKING_MODE | FSL_UCO_CONTEXT_CHANGED;           \
+    (uco)->openfd = -1;                                                       \
+    (uco)->callback = NULL;                                                   \
+    (uco)->partition = NULL;                                                  \
+} while (0)
+
+#else /* __KERNEL__ */
+
+#define fsl_shw_uco_init(ucontext, usize)                                     \
+do {                                                                          \
+    fsl_shw_uco_t* uco = ucontext;                                            \
+                                                                              \
+    (uco)->pool_size = usize;                                                 \
+    (uco)->flags = FSL_UCO_BLOCKING_MODE | FSL_UCO_CONTEXT_CHANGED;           \
+    (uco)->openfd = -1;                                                       \
+    (uco)->callback = NULL;                                                   \
+} while (0)
+
+#endif /* __KERNEL__ */
+
+
+/**
+ * Set the User Reference for the User Context.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param uref         A value which will be passed back with a result.
+ */
+#define fsl_shw_uco_set_reference(ucontext, uref)                             \
+do {                                                                          \
+    fsl_shw_uco_t* uco = ucontext;                                            \
+                                                                              \
+    (uco)->user_ref = uref;                                                   \
+    (uco)->flags |= FSL_UCO_CONTEXT_CHANGED;                                  \
+} while (0)
+
+
+/**
+ * Set the User Reference for the User Context.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param ucallback    The function the API will invoke when an operation
+ *                     completes.
+ */
+#define fsl_shw_uco_set_callback(ucontext, ucallback)                         \
+do {                                                                          \
+    fsl_shw_uco_t* uco = ucontext;                                            \
+                                                                              \
+    (uco)->callback = ucallback;                                              \
+    (uco)->flags |= FSL_UCO_CONTEXT_CHANGED;                                  \
+} while (0)
+
+/**
+ * Set flags in the User Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param uflags       ORed values from #fsl_shw_user_ctx_flags_t.
+ */
+#define fsl_shw_uco_set_flags(ucontext, uflags)                               \
+      (ucontext)->flags |= (uflags) | FSL_UCO_CONTEXT_CHANGED
+
+
+/**
+ * Clear flags in the User Context.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param uflags       ORed values from #fsl_shw_user_ctx_flags_t.
+ */
+#define fsl_shw_uco_clear_flags(ucontext, uflags)                             \
+do {                                                                          \
+    fsl_shw_uco_t* uco = ucontext;                                            \
+                                                                              \
+    (uco)->flags &= ~(uflags);                                                \
+    (uco)->flags |= FSL_UCO_CONTEXT_CHANGED;                                  \
+} while (0)
+
+
+/**
+ * Retrieve the reference value from a Result Object.
+ *
+ * @param robject  The result object to query.
+ *
+ * @return The reference associated with the request.
+ */
+#define fsl_shw_ro_get_reference(robject)                                    \
+       (robject)->user_ref
+
+
+/**
+ * Retrieve the status code from a Result Object.
+ *
+ * @param robject  The result object to query.
+ *
+ * @return The status of the request.
+ */
+#define fsl_shw_ro_get_status(robject)                                       \
+       (robject)->code
+
+
+
 /* REQ-FSL-SHW-PINTFC-API-BASIC-HASH-004 */
-/*!
+/**
  * Initialize a Hash Context Object.
  *
  * This function must be called before performing any other operation with the
@@ -1041,17 +1470,18 @@ do {                                                                          \
      }                                                                        \
 } while (0)
 
+
 /* REQ-FSL-SHW-PINTFC-API-BASIC-HASH-001 */
-/*!
+/**
  * Get the current hash value and message length from the hash context object.
  *
  * The algorithm must have already been specified.  See #fsl_shw_hco_init().
  *
- * @param hcobject   The hash context to query.
- * @param hccontext  Pointer to the location of @a length octets where to
+ * @param      hcobject   The hash context to query.
+ * @param[out] hccontext  Pointer to the location of @a length octets where to
  *                        store a copy of the current value of the digest.
- * @param hcclength  Number of octets of hash value to copy.
- * @param hcmsglen   Pointer to the location to store the number of octets
+ * @param      hcclength  Number of octets of hash value to copy.
+ * @param[out] hcmsglen   Pointer to the location to store the number of octets
  *                        already hashed.
  */
 #define fsl_shw_hco_get_digest(hcobject, hccontext, hcclength, hcmsglen)      \
@@ -1065,21 +1495,23 @@ do {                                                                          \
          }                                                                    \
 } while (0)
 
+
 /* REQ-FSL-SHW-PINTFC-API-BASIC-HASH-002 */
-/*!
+/**
  * Get the hash algorithm from the hash context object.
  *
  * @param      hcobject    The hash context to query.
- * @param hcalgorithm Pointer to where the algorithm is to be stored.
+ * @param[out] hcalgorithm Pointer to where the algorithm is to be stored.
  */
 #define fsl_shw_hco_get_info(hcobject, hcalgorithm)                           \
 do {                                                                          \
      *(hcalgorithm) = (hcobject)->algorithm;                                  \
 } while (0)
 
+
 /* REQ-FSL-SHW-PINTFC-API-BASIC-HASH-003 */
 /* REQ-FSL-SHW-PINTFC-API-BASIC-HASH-004 */
-/*!
+/**
  * Set the current hash value and message length in the hash context object.
  *
  * The algorithm must have already been specified.  See #fsl_shw_hco_init().
@@ -1102,7 +1534,8 @@ do {                                                                          \
      }                                                                        \
 } while (0)
 
-/*!
+
+/**
  * Set flags in a Hash Context Object.
  *
  * Turns on the flags specified in @a flags.  Other flags are untouched.
@@ -1114,7 +1547,8 @@ do {                                                                          \
 #define fsl_shw_hco_set_flags(hcobject, hcflags)                              \
       (hcobject)->flags |= (hcflags)
 
-/*!
+
+/**
  * Clear flags in a Hash Context Object.
  *
  * Turns off the flags specified in @a flags.  Other flags are untouched.
@@ -1126,7 +1560,8 @@ do {                                                                          \
 #define fsl_shw_hco_clear_flags(hcobject, hcflags)                            \
       (hcobject)->flags &= ~(hcflags)
 
-/*!
+
+/**
  * Initialize an HMAC Context Object.
  *
  * This function must be called before performing any other operation with the
@@ -1141,7 +1576,8 @@ do {                                                                          \
 #define fsl_shw_hmco_init(hcobject, hcalgorithm)                              \
     fsl_shw_hco_init(hcobject, hcalgorithm)
 
-/*!
+
+/**
  * Set flags in an HMAC Context Object.
  *
  * Turns on the flags specified in @a flags.  Other flags are untouched.
@@ -1153,7 +1589,8 @@ do {                                                                          \
 #define fsl_shw_hmco_set_flags(hcobject, hcflags)                             \
       (hcobject)->flags |= (hcflags)
 
-/*!
+
+/**
  * Clear flags in an HMAC Context Object.
  *
  * Turns off the flags specified in @a flags.  Other flags are untouched.
@@ -1165,7 +1602,8 @@ do {                                                                          \
 #define fsl_shw_hmco_clear_flags(hcobject, hcflags)                           \
       (hcobject)->flags &= ~(hcflags)
 
-/*!
+
+/**
  * Initialize a Symmetric Cipher Context Object.
  *
  * This function must be called before performing any other operation with the
@@ -1204,7 +1642,8 @@ do {                                                                          \
       (scobject)->flags = 0;                                                  \
 } while (0)
 
-/*!
+
+/**
  * Set the flags for a Symmetric Cipher Context.
  *
  * Turns on the flags specified in @a flags.  Other flags are untouched.
@@ -1217,7 +1656,8 @@ do {                                                                          \
 #define fsl_shw_scco_set_flags(scobject, scflags)                             \
        (scobject)->flags |= (scflags)
 
-/*!
+
+/**
  * Clear some flags in a Symmetric Cipher Context Object.
  *
  * Turns off the flags specified in @a flags.  Other flags are untouched.
@@ -1230,7 +1670,8 @@ do {                                                                          \
 #define fsl_shw_scco_clear_flags(scobject, scflags)                           \
        (scobject)->flags &= ~(scflags)
 
-/*!
+
+/**
  * Set the Context (IV) for a Symmetric Cipher Context.
  *
  * This is to set the context/IV for #FSL_SYM_MODE_CBC mode, or to set the
@@ -1245,7 +1686,8 @@ do {                                                                          \
        memcpy((scobject)->context, sccontext,                                 \
                   (scobject)->block_size_bytes)
 
-/*!
+
+/**
  * Get the Context for a Symmetric Cipher Context.
  *
  * This is to retrieve the context/IV for #FSL_SYM_MODE_CBC mode, or to
@@ -1253,12 +1695,13 @@ do {                                                                          \
  * will be copied.
  *
  * @param      scobject  The context object to operate on.
- * @param sccontext Pointer to location where context will be stored.
+ * @param[out] sccontext Pointer to location where context will be stored.
  */
 #define fsl_shw_scco_get_context(scobject, sccontext)                         \
        memcpy(sccontext, (scobject)->context, (scobject)->block_size_bytes)
 
-/*!
+
+/**
  * Set the Counter Value for a Symmetric Cipher Context.
  *
  * This will set the Counter Value for CTR mode.
@@ -1279,16 +1722,17 @@ do {                                                                         \
            (scobject)->modulus_exp = scmodulus;                              \
 } while (0)
 
-/*!
+
+/**
  * Get the Counter Value for a Symmetric Cipher Context.
  *
  * This will retrieve the Counter Value is for CTR mode.
  *
  * @param     scobject    The context object to query.
- * @param sccounter  Pointer to location to store the current counter
+ * @param[out] sccounter  Pointer to location to store the current counter
  *                        value.  The number of octets copied will be the
  *                        block size for the algorithm.
- * @param scmodulus  Pointer to location to store the modulus.
+ * @param[out] scmodulus  Pointer to location to store the modulus.
  *
  */
 #define fsl_shw_scco_get_counter_info(scobject, sccounter, scmodulus)        \
@@ -1302,7 +1746,8 @@ do {                                                                         \
            }                                                                 \
 } while (0)
 
-/*!
+
+/**
  * Initialize a Authentication-Cipher Context.
  *
  * @param acobject  Pointer to object to operate on.
@@ -1315,7 +1760,8 @@ do {                                                                          \
        (acobject)->mode = (acmode);                                           \
 } while (0)
 
-/*!
+
+/**
  * Set the flags for a Authentication-Cipher Context.
  *
  * Turns on the flags specified in @a flags.  Other flags are untouched.
@@ -1328,7 +1774,8 @@ do {                                                                          \
 #define fsl_shw_acco_set_flags(acobject, acflags)                             \
        (acobject)->flags |= (acflags)
 
-/*!
+
+/**
  * Clear some flags in a Authentication-Cipher Context Object.
  *
  * Turns off the flags specified in @a flags.  Other flags are untouched.
@@ -1341,7 +1788,8 @@ do {                                                                          \
 #define fsl_shw_acco_clear_flags(acobject, acflags)                           \
        (acobject)->flags &= ~(acflags)
 
-/*!
+
+/**
  * Set up the Authentication-Cipher Object for CCM mode.
  *
  * This will set the @a auth_object for CCM mode and save the @a ctr,
@@ -1369,7 +1817,8 @@ do {                                                                          \
             FSL_CTR_MOD_128);                                                 \
 } while (0)
 
-/*!
+
+/**
  * Format the First Block (IV) & Initial Counter Value per NIST CCM.
  *
  * This function will also set the IV and CTR values per Appendix A of NIST
@@ -1424,7 +1873,8 @@ do {                                                                          \
         memset((acobject)->cipher_ctx_info.context+16-(acq), 0, (acq)+1);     \
    } while (0)
 
-/*!
+
+/**
  * Update the First Block (IV) & Initial Counter Value per NIST CCM.
  *
  * This function will set the IV and CTR values per Appendix A of NIST Special
@@ -1459,12 +1909,13 @@ do {                                                                          \
                15 - (acobject)->q_length);                                    \
    } while (0)
 
-/*!****************************************************************************
+
+/******************************************************************************
  * Library functions
  *****************************************************************************/
 /* REQ-FSL-SHW-PINTFC-COA-UCO */
 /* REQ-FSLSHW-PINTFC-API-GEN-003 */
-/*!
+/**
  * Determine the hardware security capabilities of this platform.
  *
  * Though a user context object is passed into this function, it will always
@@ -1474,48 +1925,53 @@ do {                                                                          \
  *
  * @return  A pointer to the capabilities object.
  */
-extern fsl_shw_pco_t *fsl_shw_get_capabilities(fsl_shw_uco_t * user_ctx);
+extern fsl_shw_pco_t* fsl_shw_get_capabilities(fsl_shw_uco_t* user_ctx);
+
 
 /* REQ-FSL-SHW-PINTFC-COA-UCO */
 /* REQ-FSLSHW-PINTFC-API-GEN-004 */
-/*!
+/**
  * Create an association between the the user and the provider of the API.
  *
  * @param  user_ctx   The user context which will be used for this association.
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t * user_ctx);
+extern fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t* user_ctx);
+
 
 /* REQ-FSL-SHW-PINTFC-COA-UCO */
-/* REQ-FSLSHW-PINTFC-API-GEN-006 */
-/*!
+/* REQ-FSLSHW-PINTFC-API-GEN-005 */
+/**
  * Destroy the association between the the user and the provider of the API.
  *
  * @param  user_ctx   The user context which is no longer needed.
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t * user_ctx);
+extern fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t* user_ctx);
 
-/*!
+
+/* REQ-FSL-SHW-PINTFC-COA-UCO */
+/* REQ-FSLSHW-PINTFC-API-GEN-006 */
+/**
  * Retrieve results from earlier operations.
  *
  * @param         user_ctx     The user's context.
  * @param         result_size  The number of array elements of @a results.
- * @param results      Pointer to first of the (array of) locations to
+ * @param[in,out] results      Pointer to first of the (array of) locations to
  *                             store results.
- * @param    result_count Pointer to store the number of results which
+ * @param[out]    result_count Pointer to store the number of results which
  *                             were returned.
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t * user_ctx,
-					    unsigned result_size,
-					    fsl_shw_result_t results[],
-					    unsigned *result_count);
+extern fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t* user_ctx,
+                                            unsigned result_size,
+                                            fsl_shw_result_t results[],
+                                            unsigned* result_count);
 
-/*!
+/**
  * Place a key into a protected location for use only by cryptographic
  * algorithms.
  *
@@ -1537,24 +1993,26 @@ extern fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t * user_ctx,
  * modes.
  *
  * @param      user_ctx         A user context from #fsl_shw_register_user().
- * @param      key_info         The information about the key to be which will
+ * @param[in,out] key_info      The information about the key to be which will
  *                              be established.  In the create case, the key
  *                              length must be set.
  * @param      establish_type   How @a key will be interpreted to establish a
  *                              key for use.
- * @param      key              If @a establish_type is #FSL_KEY_WRAP_UNWRAP,
+ * @param key                   If @a establish_type is #FSL_KEY_WRAP_UNWRAP,
  *                              this is the location of a wrapped key.  If
  *                              @a establish_type is #FSL_KEY_WRAP_CREATE, this
  *                              parameter can be @a NULL.  If @a establish_type
  *                              is #FSL_KEY_WRAP_ACCEPT, this is the location
  *                              of a plaintext key.
  */
-extern fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
-					      fsl_shw_sko_t * key_info,
-					      fsl_shw_key_wrap_t establish_type,
-					      const uint8_t * key);
+extern fsl_shw_return_t fsl_shw_establish_key(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info,
+                                fsl_shw_key_wrap_t establish_type,
+                                const uint8_t* key);
 
-/*!
+
+/**
  * Wrap a key and retrieve the wrapped value.
  *
  * A wrapped key is a key that has been cryptographically obscured.  It is
@@ -1568,17 +2026,18 @@ extern fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
  *
  * @param      user_ctx         A user context from #fsl_shw_register_user().
  * @param      key_info         The information about the key to be deleted.
- * @param covered_key      The location to store the wrapped key.
+ * @param[out] covered_key      The location to store the wrapped key.
  *                              (This size is based upon the maximum key size
  *                              of 32 octets).
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
-					    fsl_shw_sko_t * key_info,
-					    uint8_t * covered_key);
+extern fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info,
+                                uint8_t* covered_key);
+
 
-/*!
+/**
  * De-establish a key so that it can no longer be accessed.
  *
  * The key will need to be re-established before it can again be used.
@@ -1591,8 +2050,123 @@ extern fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
-					    fsl_shw_sko_t * key_info);
+extern fsl_shw_return_t fsl_shw_release_key(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info);
+
+
+/*
+ * In userspace, partition assignments will be tracked using the user context.
+ * In kernel mode, partition assignments are based on address only.
+ */
+
+/**
+ * Allocate a block of secure memory
+ *
+ * @param       user_ctx        User context
+ * @param       size            Memory size (octets).  Note: currently only
+ *                              supports only single-partition sized blocks.
+ * @param       UMID            User Mode ID to use when registering the
+ *                              partition.
+ * @param       permissions     Permissions to initialize the partition with.
+ *                              Can be made by ORing flags from the
+ *                              #fsl_shw_permission_t.
+ *
+ * @return                      Address of the allocated memory.  NULL if the
+ *                              call was not successful.
+ */
+extern void *fsl_shw_smalloc(fsl_shw_uco_t* user_ctx,
+                             uint32_t size,
+                             const uint8_t* UMID,
+                             uint32_t permissions);
+
+
+/** 
+ * Free a block of secure memory that was allocated with #fsl_shw_smalloc
+ *
+ * @param       user_ctx        User context
+ * @param       address         Address of the block of secure memory to be
+ *                              released.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_sfree(
+                                fsl_shw_uco_t* user_ctx,
+                                void* address);
+
+
+/** 
+ * Check the status of a block of a secure memory that was allocated with
+ * #fsl_shw_smalloc
+ *
+ * @param       user_ctx        User context
+ * @param       address         Address of the block of secure memory to be
+ *                              released.
+ * @param       status          Status of the partition, of type
+ *                              #fsl_partition_status_t
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_sstatus(fsl_shw_uco_t* user_ctx,
+                                        void* address,
+                                        fsl_shw_partition_status_t* status);
+
+
+/**
+ * Diminish the permissions of a block of secure memory.  Note that permissions
+ * can only be revoked.
+ *
+ * @param       user_ctx        User context
+ * @param       address         Base address of the secure memory to work with
+ * @param       permissions     Permissions to initialize the partition with.
+ *                              Can be made by ORing flags from the
+ *                              #fsl_shw_permission_t.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_diminish_perms(
+        fsl_shw_uco_t* user_ctx,
+        void* address,
+        uint32_t permissions);
+
+extern fsl_shw_return_t do_scc_engage_partition(
+        fsl_shw_uco_t* user_ctx,
+        void* address,
+        const uint8_t* UMID,
+        uint32_t permissions);
+
+extern fsl_shw_return_t do_system_keystore_slot_alloc(
+        fsl_shw_uco_t* user_ctx,
+        uint32_t key_lenth,
+        uint64_t ownerid,
+        uint32_t *slot);
+
+extern fsl_shw_return_t do_system_keystore_slot_dealloc(
+        fsl_shw_uco_t* user_ctx,
+        uint64_t ownerid,
+        uint32_t slot);
+
+extern fsl_shw_return_t do_system_keystore_slot_load(
+        fsl_shw_uco_t* user_ctx,
+        uint64_t ownerid,
+        uint32_t slot,
+        const uint8_t *key,
+        uint32_t key_length);
+
+extern fsl_shw_return_t do_system_keystore_slot_encrypt(
+        fsl_shw_uco_t* user_ctx,
+        uint64_t ownerid,
+        uint32_t slot,
+        uint32_t key_length,
+        uint8_t* black_data);
+
+extern fsl_shw_return_t do_system_keystore_slot_decrypt(
+        fsl_shw_uco_t* user_ctx,
+        uint64_t ownerid,
+        uint32_t slot,
+        uint32_t key_length,
+        const uint8_t* black_data);
+
 
 /* REQ-FSL-SHW-PINTFC-COA-UCO */
 /* REQ-FSL-SHW-PINTFC-COA-SKO */
@@ -1600,7 +2174,7 @@ extern fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
 /* REQ-FSLSHW-PINTFC-API-BASIC-SYM-001 */
 /* PINTFC-API-BASIC-SYM-ARC4-001 */
 /* PINTFC-API-BASIC-SYM-ARC4-002 */
-/*!
+/**
  * Encrypt a stream of data with a symmetric-key algorithm.
  *
  * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
@@ -1632,20 +2206,22 @@ extern fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
  *
  * @param         user_ctx  A user context from #fsl_shw_register_user().
  * @param         key_info  Key and algorithm  being used for this operation.
- * @param sym_ctx   Info on cipher mode, state of the cipher.
+ * @param[in,out] sym_ctx   Info on cipher mode, state of the cipher.
  * @param         length   Length, in octets, of the pt (and ct).
  * @param         pt       pointer to plaintext to be encrypted.
- * @param    ct       pointer to where to store the resulting ciphertext.
+ * @param[out]    ct       pointer to where to store the resulting ciphertext.
  *
  * @return    A return code of type #fsl_shw_return_t.
  *
  */
-extern fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
-						  fsl_shw_sko_t * key_info,
-						  fsl_shw_scco_t * sym_ctx,
-						  uint32_t length,
-						  const uint8_t * pt,
-						  uint8_t * ct);
+extern fsl_shw_return_t fsl_shw_symmetric_encrypt(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info,
+                                fsl_shw_scco_t* sym_ctx,
+                                uint32_t length,
+                                const uint8_t* pt,
+                                uint8_t* ct);
+
 
 /* REQ-FSL-SHW-PINTFC-COA-UCO */
 /* REQ-FSL-SHW-PINTFC-COA-SKO */
@@ -1653,7 +2229,7 @@ extern fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
 /* PINTFC-API-BASIC-SYM-002 */
 /* PINTFC-API-BASIC-SYM-ARC4-001 */
 /* PINTFC-API-BASIC-SYM-ARC4-002 */
-/*!
+/**
  * Decrypt a stream of data with a symmetric-key algorithm.
  *
  * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
@@ -1686,25 +2262,26 @@ extern fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
  *
  * @param      user_ctx  A user context from #fsl_shw_register_user().
  * @param      key_info The key and algorithm being used in this operation.
- * @param sym_ctx Info on cipher mode, state of the cipher.
+ * @param[in,out] sym_ctx Info on cipher mode, state of the cipher.
  * @param      length   Length, in octets, of the ct (and pt).
  * @param      ct       pointer to ciphertext to be decrypted.
- * @param pt       pointer to where to store the resulting plaintext.
+ * @param[out] pt       pointer to where to store the resulting plaintext.
  *
  * @return    A return code of type #fsl_shw_return_t
  *
  */
-extern fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t * user_ctx,
-						  fsl_shw_sko_t * key_info,
-						  fsl_shw_scco_t * sym_ctx,
-						  uint32_t length,
-						  const uint8_t * ct,
-						  uint8_t * pt);
+extern fsl_shw_return_t fsl_shw_symmetric_decrypt(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info,
+                                fsl_shw_scco_t* sym_ctx,
+                                uint32_t length,
+                                const uint8_t* ct,
+                                uint8_t* pt);
 
 /* REQ-FSL-SHW-PINTFC-COA-UCO */
 /* REQ-FSL-SHW-PINTFC-COA-HCO */
 /* REQ-FSLSHW-PINTFC-API-BASIC-HASH-005 */
-/*!
+/**
  * Hash a stream of data with a cryptographic hash algorithm.
  *
  * The flags in the @a hash_ctx control the operation of this function.
@@ -1737,24 +2314,27 @@ extern fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t * user_ctx,
  * 64 octets.
  *
  * @param      user_ctx  A user context from #fsl_shw_register_user().
- * @param hash_ctx Hashing algorithm and state of the cipher.
+ * @param[in,out] hash_ctx Hashing algorithm and state of the cipher.
  * @param      msg       Pointer to the data to be hashed.
  * @param      length    Length, in octets, of the @a msg.
- * @param result    If not null, pointer to where to store the hash
+ * @param[out] result    If not null, pointer to where to store the hash
  *                       digest.
  * @param      result_len Number of octets to store in @a result.
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t * user_ctx,
-				     fsl_shw_hco_t * hash_ctx,
-				     const uint8_t * msg,
-				     uint32_t length,
-				     uint8_t * result, uint32_t result_len);
+extern fsl_shw_return_t fsl_shw_hash(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_hco_t* hash_ctx,
+                                const uint8_t* msg,
+                                uint32_t length,
+                                uint8_t* result,
+                                uint32_t result_len);
+
 
 /* REQ-FSL-SHW-PINTFC-COA-UCO */
 /* REQ-FSL-SHW-PINTFC-API-BASIC-HMAC-001 */
-/*!
+/**
  * Precompute the Key hashes for an HMAC operation.
  *
  * This function may be used to calculate the inner and outer precomputes,
@@ -1770,17 +2350,19 @@ extern fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t * user_ctx,
  * @param      user_ctx  A user context from #fsl_shw_register_user().
  * @param      key_info  The key being used in this operation.  Key must be
  *                       1 to 64 octets long.
- * @param hmac_ctx The context which controls, by its flags and
+ * @param[in,out] hmac_ctx The context which controls, by its flags and
  *                         algorithm, the operation of this function.
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t * user_ctx,
-						fsl_shw_sko_t * key_info,
-						fsl_shw_hmco_t * hmac_ctx);
+extern fsl_shw_return_t fsl_shw_hmac_precompute(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info,
+                                fsl_shw_hmco_t* hmac_ctx);
+
 
 /* REQ-FSL-SHW-PINTFC-COA-UCO */
 /* REQ-FSLSHW-PINTFC-API-BASIC-HMAC-002 */
-/*!
+/**
  * Continue, finalize, or one-shot an HMAC operation.
  *
  * There are a number of ways to use this function.  The flags in the
@@ -1810,41 +2392,47 @@ extern fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t * user_ctx,
  *                       contexts.  If #FSL_HMAC_FLAGS_INIT is not set, this
  *                       parameter is ignored.
 
- * @param hmac_ctx The context which controls, by its flags and
+ * @param[in,out] hmac_ctx The context which controls, by its flags and
  *                       algorithm, the operation of this function.
  * @param      msg               Pointer to the message to be hashed.
  * @param      length            Length, in octets, of the @a msg.
- * @param result            Pointer, of @a result_len octets, to where to
+ * @param[out] result            Pointer, of @a result_len octets, to where to
  *                               store the HMAC.
  * @param      result_len        Length of @a result buffer.
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t * user_ctx,
-				     fsl_shw_sko_t * key_info,
-				     fsl_shw_hmco_t * hmac_ctx,
-				     const uint8_t * msg,
-				     uint32_t length,
-				     uint8_t * result, uint32_t result_len);
+extern fsl_shw_return_t fsl_shw_hmac(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info,
+                                fsl_shw_hmco_t* hmac_ctx,
+                                const uint8_t* msg,
+                                uint32_t length,
+                                uint8_t* result,
+                                uint32_t result_len);
+
 
 /* REQ-FSL-SHW-PINTFC-COA-UCO */
 /* REQ-FSLSHW-PINTFC-API-BASIC-RNG-002 */
-/*!
+/**
  * Get random data.
  *
  * @param      user_ctx  A user context from #fsl_shw_register_user().
  * @param      length    The number of octets of @a data being requested.
- * @param data      A pointer to a location of @a length octets to where
+ * @param[out] data      A pointer to a location of @a length octets to where
  *                       random data will be returned.
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx,
-					   uint32_t length, uint8_t * data);
+extern fsl_shw_return_t fsl_shw_get_random(
+                                fsl_shw_uco_t* user_ctx,
+                                uint32_t length,
+                                uint8_t* data);
+
 
 /* REQ-FSL-SHW-PINTFC-COA-UCO */
 /* REQ-FSLSHW-PINTFC-API-BASIC-RNG-003 */
-/*!
+/**
  * Add entropy to random number generator.
  *
  * @param      user_ctx  A user context from #fsl_shw_register_user().
@@ -1853,12 +2441,14 @@ extern fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx,
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx,
-					    uint32_t length, uint8_t * data);
+extern fsl_shw_return_t fsl_shw_add_entropy(
+                                fsl_shw_uco_t* user_ctx,
+                                uint32_t length,
+                                uint8_t* data);
 
 /* REQ-FSL-SHW-PINTFC-COA-UCO */
 /* REQ-FSL-SHW-PINTFC-COA-SKO */
-/*!
+/**
  * Perform Generation-Encryption by doing a Cipher and a Hash.
  *
  * Generate the authentication value @a auth_value as well as encrypt the @a
@@ -1879,27 +2469,29 @@ extern fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx,
  * @param      auth_data        Data to be authenticated but not encrypted.
  * @param      payload_length   Length, in octets, of @a payload.
  * @param      payload          Pointer to the plaintext to be encrypted.
- * @param ct               Pointer to the where the encrypted @a payload
+ * @param[out] ct               Pointer to the where the encrypted @a payload
  *                              will be stored.  Must be @a payload_length
  *                              octets long.
- * @param auth_value       Pointer to where the generated authentication
+ * @param[out] auth_value       Pointer to where the generated authentication
  *                              field will be stored. Must be as many octets as
  *                              indicated by MAC length in the @a function_ctx.
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
-					    fsl_shw_acco_t * auth_ctx,
-					    fsl_shw_sko_t * cipher_key_info,
-					    fsl_shw_sko_t * auth_key_info,
-					    uint32_t auth_data_length,
-					    const uint8_t * auth_data,
-					    uint32_t payload_length,
-					    const uint8_t * payload,
-					    uint8_t * ct, uint8_t * auth_value);
+extern fsl_shw_return_t fsl_shw_gen_encrypt(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_acco_t* auth_ctx,
+                                fsl_shw_sko_t* cipher_key_info,
+                                fsl_shw_sko_t* auth_key_info,
+                                uint32_t auth_data_length,
+                                const uint8_t* auth_data,
+                                uint32_t payload_length,
+                                const uint8_t* payload,
+                                uint8_t* ct,
+                                uint8_t* auth_value);
 
 /* REQ-FSL-SHW-PINTFC-COA-UCO */
 /* REQ-FSL-SHW-PINTFC-COA-SKO */
-/*!
+/**
  * Perform Authentication-Decryption in Cipher + Hash.
  *
  * This function will perform a one-shot decryption of a data stream as well as
@@ -1924,30 +2516,44 @@ extern fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
  *                              be authenticated.  This is the same data as the
  *                              (output) @a auth_value argument to
  *                              #fsl_shw_gen_encrypt().
- * @param payload          Pointer to where the plaintext resulting from
+ * @param[out] payload          Pointer to where the plaintext resulting from
  *                              the decryption will be stored.
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
-					     fsl_shw_acco_t * auth_ctx,
-					     fsl_shw_sko_t * cipher_key_info,
-					     fsl_shw_sko_t * auth_key_info,
-					     uint32_t auth_data_length,
-					     const uint8_t * auth_data,
-					     uint32_t payload_length,
-					     const uint8_t * ct,
-					     const uint8_t * auth_value,
-					     uint8_t * payload);
-
-/*!***************************************************************************
+extern fsl_shw_return_t fsl_shw_auth_decrypt(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_acco_t* auth_ctx,
+                                fsl_shw_sko_t* cipher_key_info,
+                                fsl_shw_sko_t* auth_key_info,
+                                uint32_t auth_data_length,
+                                const uint8_t* auth_data,
+                                uint32_t payload_length,
+                                const uint8_t* ct,
+                                const uint8_t* auth_value,
+                                uint8_t* payload);
+
+
+fsl_shw_return_t 
+do_scc_encrypt_region(fsl_shw_uco_t* user_ctx,
+                      void* partition_base, uint32_t offset_bytes,
+                      uint32_t byte_count, uint8_t* black_data,
+                      uint32_t* IV, fsl_shw_cypher_mode_t cypher_mode);
+
+fsl_shw_return_t 
+do_scc_decrypt_region(fsl_shw_uco_t* user_ctx,
+                      void* partition_base, uint32_t offset_bytes,
+                      uint32_t byte_count, const uint8_t* black_data,
+                      uint32_t* IV, fsl_shw_cypher_mode_t cypher_mode);
+
+/*****************************************************************************
  *
  * Functions available to other SHW-family drivers.
  *
 *****************************************************************************/
 
 #ifdef __KERNEL__
-/*!
+/**
  * Add an entry to a work/result queue.
  *
  * @param pool  Pointer to list structure
@@ -1955,57 +2561,61 @@ extern fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
  *
  * @return void
  */
-inline static void SHW_ADD_QUEUE_ENTRY(shw_queue_t * pool,
-				       shw_queue_entry_t * entry)
+inline static void SHW_ADD_QUEUE_ENTRY(shw_queue_t* pool,
+                                       shw_queue_entry_t* entry)
 {
-	os_lock_context_t lock_context;
+    os_lock_context_t lock_context;
+
+    entry->next = NULL;
+    os_lock_save_context(shw_queue_lock, lock_context);
 
-	entry->next = NULL;
-	os_lock_save_context(shw_queue_lock, lock_context);
+    if (pool->tail != NULL) {
+        pool->tail->next = entry;
+    } else {
+        /* Queue was empty, so this is also the head. */
+        pool->head = entry;
+    }
+    pool->tail = entry;
 
-	if (pool->tail != NULL) {
-		pool->tail->next = entry;
-	} else {
-		/* Queue was empty, so this is also the head. */
-		pool->head = entry;
-	}
-	pool->tail = entry;
+    os_unlock_restore_context(shw_queue_lock, lock_context);
 
-	os_unlock_restore_context(shw_queue_lock, lock_context);
+    return;
 
-	return;
 
 }
 
-/*!
+
+/**
  * Get first entry on the queue and remove it from the queue.
  *
  * @return Pointer to first entry, or NULL if none.
  */
-inline static shw_queue_entry_t *SHW_POP_FIRST_ENTRY(shw_queue_t * queue)
+inline static shw_queue_entry_t* SHW_POP_FIRST_ENTRY(shw_queue_t* queue)
 {
-	shw_queue_entry_t *entry;
-	os_lock_context_t lock_context;
+    shw_queue_entry_t* entry;
+    os_lock_context_t lock_context;
 
-	os_lock_save_context(shw_queue_lock, lock_context);
+    os_lock_save_context(shw_queue_lock, lock_context);
 
-	entry = queue->head;
+    entry = queue->head;
 
-	if (entry != NULL) {
-		queue->head = entry->next;
-		entry->next = NULL;
-		/* If this was only entry, clear the tail. */
-		if (queue->tail == entry) {
-			queue->tail = NULL;
-		}
-	}
+    if (entry != NULL) {
+        queue->head = entry->next;
+        entry->next = NULL;
+        /* If this was only entry, clear the tail. */
+        if (queue->tail == entry) {
+            queue->tail = NULL;
+        }
+    }
 
-	os_unlock_restore_context(shw_queue_lock, lock_context);
+    os_unlock_restore_context(shw_queue_lock, lock_context);
 
-	return entry;
+    return entry;
 }
 
-/*!
+
+
+/**
  * Remove an entry from the list.
  *
  * If the entry not on the queue, no error will be returned.
@@ -2016,67 +2626,70 @@ inline static shw_queue_entry_t *SHW_POP_FIRST_ENTRY(shw_queue_t * queue)
  * @return void
  *
  */
-inline static void SHW_QUEUE_REMOVE_ENTRY(shw_queue_t * pool,
-					  shw_queue_entry_t * entry)
+inline static void SHW_QUEUE_REMOVE_ENTRY(shw_queue_t* pool,
+                                   shw_queue_entry_t* entry)
 {
-	os_lock_context_t lock_context;
-
-	os_lock_save_context(shw_queue_lock, lock_context);
-
-	/* Check for quick case. */
-	if (pool->head == entry) {
-		pool->head = entry->next;
-		entry->next = NULL;
-		if (pool->tail == entry) {
-			pool->tail = NULL;
-		}
-	} else {
-		register shw_queue_entry_t *prev = pool->head;
-
-		/* We know it is not the head, so start looking at entry after head. */
-		while (prev->next) {
-			if (prev->next != entry) {
-				prev = prev->next;	/* Try another */
-				continue;
-			} else {
-				/* Unlink from chain. */
-				prev->next = entry->next;
-				entry->next = NULL;
-				/* If last in chain, update tail. */
-				if (pool->tail == entry) {
-					pool->tail = prev;
-				}
-				break;
-			}
-		}		/* while */
-	}
-
-	os_unlock_restore_context(shw_queue_lock, lock_context);
-
-	return;
+    os_lock_context_t lock_context;
+
+    os_lock_save_context(shw_queue_lock, lock_context);
+
+    /* Check for quick case.*/
+    if (pool->head == entry) {
+        pool->head = entry->next;
+        entry->next = NULL;
+        if (pool->tail == entry) {
+            pool->tail = NULL;
+        }
+    } else {
+        register shw_queue_entry_t* prev = pool->head;
+
+        /* We know it is not the head, so start looking at entry after head. */
+        while (prev->next) {
+            if (prev->next != entry) {
+                prev = prev->next; /* Try another */
+                continue;
+            } else {
+                /* Unlink from chain. */
+                prev->next = entry->next;
+                entry->next = NULL;
+                /* If last in chain, update tail. */
+                if (pool->tail == entry) {
+                    pool->tail = prev;
+                }
+                break;
+            }
+        } /* while */
+    }
+
+    os_unlock_restore_context(shw_queue_lock, lock_context);
+
+    return;
 }
-#endif				/* __KERNEL__ */
+#endif /* __KERNEL__ */
+
 
-/*!***************************************************************************
+/*****************************************************************************
  *
  * Functions available to User-Mode API functions
  *
  ****************************************************************************/
 #ifndef __KERNEL__
 
- /*!
-  * Sanity checks the user context object fields to ensure that they make some
-  * sense before passing the uco as a parameter.
-  *
-  * @brief Verify the user context object
-  *
-  * @param  uco  user context object
-  *
-  * @return    A return code of type #fsl_shw_return_t.
-  */
-fsl_shw_return_t validate_uco(fsl_shw_uco_t * uco);
 
-/*!
+ /**
+ * Sanity checks the user context object fields to ensure that they make some
+ * sense before passing the uco as a parameter.
+ *
+ * @brief Verify the user context object
+ *
+ * @param  uco  user context object
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t validate_uco(fsl_shw_uco_t *uco);
+
+
+/**
  * Initialize a request block to go to the driver.
  *
  * @param hdr      Pointer to request block header
@@ -2084,17 +2697,18 @@ fsl_shw_return_t validate_uco(fsl_shw_uco_t * uco);
  *
  * @return void
  */
-inline static void init_req(struct shw_req_header *hdr,
-			    fsl_shw_uco_t * user_ctx)
+inline static void init_req(struct shw_req_header* hdr,
+                            fsl_shw_uco_t* user_ctx)
 {
-	hdr->flags = user_ctx->flags;
-	hdr->user_ref = user_ctx->user_ref;
-	hdr->code = FSL_RETURN_ERROR_S;
+    hdr->flags = user_ctx->flags;
+    hdr->user_ref = user_ctx->user_ref;
+    hdr->code = FSL_RETURN_ERROR_S;
 
-	return;
+    return;
 }
 
-/*!
+
+/**
  * Send a request block off to the driver.
  *
  * If this is a non-blocking request, then req will be freed.
@@ -2107,35 +2721,36 @@ inline static void init_req(struct shw_req_header *hdr,
  *              FSL_RETURN_INTERNAL_ERROR_S.
  */
 inline static fsl_shw_return_t send_req(shw_user_request_t type,
-					struct shw_req_header *req,
-					fsl_shw_uco_t * ctx)
+                                        struct shw_req_header* req,
+                                        fsl_shw_uco_t* ctx)
 {
-	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
-	unsigned blocking = ctx->flags & FSL_UCO_BLOCKING_MODE;
-	int code;
-
-	code = ioctl(ctx->openfd, SHW_IOCTL_REQUEST + type, req);
-
-	if (code == 0) {
-		if (blocking) {
-			ret = req->code;
-		} else {
-			ret = FSL_RETURN_OK_S;
-		}
-	} else {
+    fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
+    unsigned blocking = ctx->flags & FSL_UCO_BLOCKING_MODE;
+    int code;
+
+    code = ioctl(ctx->openfd, SHW_IOCTL_REQUEST + type, req);
+
+    if (code == 0) {
+        if (blocking) {
+            ret = req->code;
+        } else {
+            ret = FSL_RETURN_OK_S;
+        }
+    } else {
 #ifdef FSL_DEBUG
-		fprintf(stderr, "SHW: send_req failed with (%d), %s\n", code,
-			strerror(code));
+        fprintf(stderr, "SHW: send_req failed with (%d), %s\n", errno,
+                strerror(errno));
 #endif
-	}
+    }
 
-	if (blocking) {
-		free(req);
-	}
+    if (blocking) {
+        free(req);
+    }
 
-	return ret;
+    return ret;
 }
 
+
 #endif				/* no __KERNEL__ */
 
 #endif				/* SHW_DRIVER_H */
diff --git a/drivers/mxc/security/rng/include/shw_internals.h b/drivers/mxc/security/rng/include/shw_internals.h
index 630ceb1..c815b3d 100644
--- a/drivers/mxc/security/rng/include/shw_internals.h
+++ b/drivers/mxc/security/rng/include/shw_internals.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -30,7 +30,7 @@
 #include "portable_os.h"
 #include "shw_driver.h"
 
-#include <asm/arch/mxc_scc_driver.h>
+//#include <asm/arch/mxc_scc_driver.h>
 
 /*! @defgroup shwcompileflags SHW Compile Flags
  *
@@ -68,6 +68,8 @@
  * This flag is undefined by default.
  */
 /* REQ-FSLSHW-DEBUG-001 */
+#define SHW_DEBUG
+#undef SHW_DEBUG
 
 /*! @} */
 #endif				/* end DOXYGEN_HACK */
@@ -80,9 +82,7 @@
 #define SHW_DRIVER_NAME "fsl_shw"
 /*! @} */
 #endif
-#ifdef __KERNEL__
-static fsl_shw_uco_t *user_list;
-#endif
+
 /*!
  * Add a user context onto the list of registered users.
  *
@@ -148,6 +148,12 @@ static os_error_code get_random(fsl_shw_uco_t * user_ctx,
 static os_error_code add_entropy(fsl_shw_uco_t * user_ctx,
 				 void *user_mode_add_entropy_req);
 
+void* wire_user_memory(void* address, uint32_t length, void** page_ctx);
+void unwire_user_memory(void** page_ctx);
+os_error_code map_user_memory(struct vm_area_struct* vma, 
+                              uint32_t physical_addr, uint32_t size);
+os_error_code unmap_user_memory(uint32_t user_addr, uint32_t size);
+
 #if defined(LINUX_VERSION_CODE)
 
 MODULE_AUTHOR("Freescale Semiconductor");
diff --git a/drivers/mxc/security/rng/rng_driver.c b/drivers/mxc/security/rng/rng_driver.c
index 633cea6..8ed2da9 100644
--- a/drivers/mxc/security/rng/rng_driver.c
+++ b/drivers/mxc/security/rng/rng_driver.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -52,23 +52,34 @@
 #include "fsl_shw.h"
 #include "rng_internals.h"
 
+#ifdef FSL_HAVE_SCC2
+#include <asm/arch/mxc_scc2_driver.h>
+#else
+#include <asm/arch/mxc_scc_driver.h>
+#endif
+
+#if defined(RNG_DEBUG) || defined(RNG_ENTROPY_DEBUG) ||                     \
+    defined(RNG_REGISTER_DEBUG)
+#include <diagnostic.h>
+#endif
+
 /* These are often handy */
 #ifndef FALSE
-/*! Non-true value for arguments, return values. */
+/** Non-true value for arguments, return values. */
 #define FALSE 0
 #endif
 #ifndef TRUE
-/*! True value for arguments, return values. */
+/** True value for arguments, return values. */
 #define TRUE 1
 #endif
 
-/*!****************************************************************************
+/******************************************************************************
  *
  *  Global / Static Variables
  *
  *****************************************************************************/
 
-/*!
+/**
  * This is type void* so that a) it cannot directly be dereferenced, and b)
  * pointer arithmetic on it will function for the byte offsets in rng_rnga.h
  * and rng_rngc.h
@@ -87,65 +98,65 @@
  */
 static volatile void *rng_base;
 
-/*!
+/**
  * Flag to say whether interrupt handler has been registered for RNG
  * interrupt */
 static int rng_irq_set = FALSE;
 
-/*!
+/**
  * Size of the RNG's OUTPUT_FIFO, in words.  Retrieved with
  * #RNG_GET_FIFO_SIZE() during driver initialization.
  */
 static int rng_output_fifo_size;
 
-/*! Major number for device driver. */
+/** Major number for device driver. */
 static int rng_major;
 
-/*! Registration handle for registering driver with OS. */
+/** Registration handle for registering driver with OS. */
 os_driver_reg_t rng_reg_handle;
 
-/*!
+/**
  * Internal flag to know whether RNG is in Failed state (and thus many
  * registers are unavailable).  If the value ever goes to #RNG_STATUS_FAILED,
  * it will never change.
  */
 static volatile rng_status_t rng_availability = RNG_STATUS_INITIAL;
 
-/*!
+/**
  * Global lock for the RNG driver.  Mainly used for entries on the RNG work
  * queue.
  */
 static os_lock_t rng_queue_lock = NULL;
 
-/*!
+/**
  * Queue for the RNG task to process.
  */
 static shw_queue_t rng_work_queue;
 
-/*!
+/**
  * Flag to say whether task initialization succeeded.
  */
 static unsigned task_started = FALSE;
-/*!
+/**
  * Waiting queue for RNG SELF TESTING
  */
 static DECLARE_COMPLETION(rng_self_testing);
 static DECLARE_COMPLETION(rng_seed_done);
-/*!
+/**
  *  Object for blocking-mode callers of RNG driver to sleep.
  */
 OS_WAIT_OBJECT(rng_wait_queue);
 
-/*!****************************************************************************
+/******************************************************************************
  *
  *  Function Implementations - Externally Accessible
  *
  *****************************************************************************/
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn rng_init()                                                             */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Initialize the driver.
  *
  * Set up the driver to have access to RNG device registers and verify that
@@ -178,40 +189,72 @@ OS_DEV_INIT(rng_init)
 #endif
 	rng_work_queue.head = NULL;
 	rng_work_queue.tail = NULL;
+
 	clk = clk_get(NULL, "rng_clk");
+
+	/* Check that the clock was found*/
+	if (IS_ERR(clk)) {
+#ifdef RNG_DEBUG
+		LOG_KDIAG("RNG: Failed to find rng_clock.");
+#endif
+		return_code = OS_ERROR_FAIL_S;
+		goto check_err;
+	}
+
 	clk_enable(clk);
 
 	printk(KERN_INFO "RNG Driver: Loading\n");
 	return_code = rng_map_RNG_memory();
 	if (return_code != OS_ERROR_OK_S) {
 		rng_availability = RNG_STATUS_UNIMPLEMENTED;
-		pr_debug("RNG: Driver failed to map RNG registers. %d\n",
-			 return_code);
+#ifdef RNG_DEBUG
+		LOG_KDIAG_ARGS("RNG: Driver failed to map RNG registers. %d",
+			       return_code);
+#endif
 		goto check_err;
 	}
-	pr_debug("RNG Driver: rng_base is 0x%08x\n", (uint32_t) rng_base);
+#ifdef RNG_DEBUG
+	LOG_KDIAG_ARGS("RNG Driver: rng_base is 0x%08x", (uint32_t) rng_base);
+#endif
 	/*Check SCC keys are fused */
 	if (RNG_HAS_ERROR()) {
 		if (RNG_HAS_BAD_KEY()) {
-			printk(KERN_INFO "ERROR: BAD KEYS SELECTED\n");
+#ifdef RNG_DEBUG
+			LOG_KDIAG("ERROR: BAD KEYS SELECTED");
+			{
+				uint32_t rngc_status =
+				    RNG_READ_REGISTER(RNGC_STATUS);
+				uint32_t rngc_error =
+				    RNG_READ_REGISTER(RNGC_ERROR);
+				LOG_KDIAG_ARGS
+				    ("status register: %08x, error status: %08x",
+				     rngc_status, rngc_error);
+			}
+#endif
 			rng_availability = RNG_STATUS_FAILED;
 			return_code = OS_ERROR_FAIL_S;
 			goto check_err;
 		}
 	}
+
 	/* Check RNG configuration and status */
 	return_code = rng_grab_config_values();
 	if (return_code != OS_ERROR_OK_S) {
 		rng_availability = RNG_STATUS_UNIMPLEMENTED;
 		goto check_err;
 	}
+
 	/* Masking All Interrupts */
+	/* They are unmasked later in rng_setup_interrupt_handling() */
 	RNG_MASK_ALL_INTERRUPTS();
+
 	RNG_WAKE();
 
 	/* Determine status of RNG */
 	if (RNG_OSCILLATOR_FAILED()) {
-		pr_debug("RNG Driver: RNG Oscillator is dead\n");
+#ifdef RNG_DEBUG
+		LOG_KDIAG("RNG Driver: RNG Oscillator is dead");
+#endif
 		rng_availability = RNG_STATUS_FAILED;
 		goto check_err;
 	}
@@ -223,9 +266,11 @@ OS_DEV_INIT(rng_init)
 #endif
 
 		RNG_GO();
+
 		/* Self Testing For RNG */
 		do {
 			RNG_CLEAR_ERR();
+			RNG_UNMASK_ALL_INTERRUPTS();
 			RNG_SELF_TEST();
 #if defined(FSL_HAVE_RNGC)
 			wait_for_completion(&rng_self_testing);
@@ -245,20 +290,27 @@ OS_DEV_INIT(rng_init)
 		RNG_SET_HIGH_ASSURANCE();
 #endif
 		if (RNG_GET_HIGH_ASSURANCE()) {
-			pr_debug("RNG Driver: RNG is in High Assurance mode\n");
+#ifdef RNG_DEBUG
+			LOG_KDIAG("RNG Driver: RNG is in High Assurance mode");
+#endif
 		} else {
 #ifndef RNG_NO_FORCE_HIGH_ASSURANCE
-			pr_debug("RNG Driver: RNG could not be put in "
-				 "High Assurance mode\n");
+#ifdef RNG_DEBUG
+			LOG_KDIAG
+		    ("RNG Driver: RNG could not be put in High Assurance mode");
 #endif
+#endif				/* RNG_NO_FORCE_HIGH_ASSURANCE */
 			rng_availability = RNG_STATUS_FAILED;
 			goto check_err;
 		}
 
 		/* Check that RNG is OK */
 		if (!RNG_WORKING()) {
-			pr_debug("RNG determined to be inoperable."
-				 "  Status %08x\n", RNG_GET_STATUS());
+#ifdef RNG_DEBUG
+			LOG_KDIAG_ARGS
+			    ("RNG determined to be inoperable.  Status %08x",
+			     RNG_GET_STATUS());
+#endif
 			/* Couldn't wake it up or other problem */
 			rng_availability = RNG_STATUS_FAILED;
 			goto check_err;
@@ -266,31 +318,36 @@ OS_DEV_INIT(rng_init)
 
 		rng_queue_lock = os_lock_alloc_init();
 		if (rng_queue_lock == NULL) {
-			pr_debug("RNG: lock initialization failed\n");
+#ifdef RNG_DEBUG
+			LOG_KDIAG("RNG: lock initialization failed");
+#endif
 			rng_availability = RNG_STATUS_FAILED;
 			goto check_err;
 		}
 
 		return_code = os_create_task(rng_entropy_task);
 		if (return_code != OS_ERROR_OK_S) {
-			pr_debug("RNG: task initialization failed\n");
+#ifdef RNG_DEBUG
+			LOG_KDIAG("RNG: task initialization failed");
+#endif
 			rng_availability = RNG_STATUS_FAILED;
 			goto check_err;
 		} else {
 			task_started = TRUE;
 		}
-#if defined(FSL_HAVE_RNGA)
+#ifdef FSL_HAVE_RNGA
 		scc_code = scc_monitor_security_failure(rng_sec_failure);
 		if (scc_code != SCC_RET_OK) {
-			pr_debug
-			    ("RNG Driver: Failed to register SCC callback: %d\n",
-			     scc_code);
+#ifdef RNG_DEBUG
+			LOG_KDIAG_ARGS("Failed to register SCC callback: %d",
+				       scc_code);
+#endif
 #ifndef RNG_NO_FORCE_HIGH_ASSURANCE
 			return_code = OS_ERROR_FAIL_S;
 			goto check_err;
 #endif
 		}
-#endif
+#endif				/* FSL_HAVE_RNGA */
 		return_code = os_driver_init_registration(rng_reg_handle);
 		if (return_code != OS_ERROR_OK_S) {
 			goto check_err;
@@ -302,7 +359,9 @@ OS_DEV_INIT(rng_init)
 						    rng_major, RNG_DRIVER_NAME);
 	}
 	/* RNG is working */
+
       check_err:
+
 	/* If FIFO underflow or other error occurred during drain, this will fail,
 	 * as system will have been put into fail mode by SCC. */
 	if ((return_code == OS_ERROR_OK_S)
@@ -310,8 +369,9 @@ OS_DEV_INIT(rng_init)
 		RNG_PUT_RNG_TO_SLEEP();
 		rng_availability = RNG_STATUS_OK;	/* RNG & driver are ready */
 	} else if (return_code != OS_ERROR_OK_S) {
-		pr_debug("RNG: Driver initialization failed. %d\n",
-			 return_code);
+#ifdef RNG_DEBUG
+		LOG_KDIAG_ARGS("Driver initialization failed. %d", return_code);
+#endif
 		rng_cleanup();
 	}
 
@@ -319,10 +379,10 @@ OS_DEV_INIT(rng_init)
 
 }				/* rng_init */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn rng_shutdown()                                                         */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Prepare driver for exit.
  *
  * This is called during @c rmmod when the driver is unloading.
@@ -334,7 +394,10 @@ OS_DEV_INIT(rng_init)
 OS_DEV_SHUTDOWN(rng_shutdown)
 {
 
-	pr_debug("RNG: shutdown called\n");
+#ifdef RNG_DEBUG
+	LOG_KDIAG("shutdown called");
+#endif
+
 	rng_cleanup();
 
 	os_driver_remove_registration(rng_reg_handle);
@@ -347,10 +410,10 @@ OS_DEV_SHUTDOWN(rng_shutdown)
 	os_dev_shutdown_return(OS_ERROR_OK_S);
 }				/* rng_shutdown */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn rng_cleanup()                                                          */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Undo everything done by rng_init() and place driver in fail mode.
  *
  * Deregister from SCC, stop tasklet, shutdown the RNG.  Leave the register
@@ -361,7 +424,11 @@ OS_DEV_SHUTDOWN(rng_shutdown)
 static void rng_cleanup(void)
 {
 	struct clk *clk;
+
+#ifdef FSL_HAVE_RNGA
 	scc_stop_monitoring_security_failure(rng_sec_failure);
+#endif
+
 	clk = clk_get(NULL, "rng_clk");
 	clk_disable(clk);
 	if (task_started) {
@@ -375,19 +442,20 @@ static void rng_cleanup(void)
 
 		if (rng_irq_set) {
 			/* unmap the interrupts from the IRQ lines */
-			os_deregister_interrupt(MXC_INT_RNG);
+			os_deregister_interrupt(INT_RNG);
 			rng_irq_set = FALSE;
 		}
 		rng_availability = RNG_STATUS_FAILED;
 	} else {
 		rng_availability = RNG_STATUS_UNIMPLEMENTED;
 	}
-
-	pr_debug("RNG Driver: Cleaned up\n");
+#ifdef RNG_DEBUG
+	LOG_KDIAG("Cleaned up");
+#endif
 
 }				/* rng_cleanup */
 
-/*!
+/**
  * Post-process routine for fsl_shw_get_random().
  *
  * This function will copy the random data generated by the background task
@@ -415,10 +483,10 @@ static uint32_t finish_random(shw_queue_entry_t * gen_entry)
 }
 
 /* REQ-FSLSHW-PINTFC-API-BASIC-RNG-002 */
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn fsl_shw_get_random()                                                   */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Get random data.
  *
  * @param      user_ctx  A user context from #fsl_shw_register_user().
@@ -474,10 +542,10 @@ fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx, uint32_t length,
 	return return_code;
 }				/* fsl_shw_get_entropy */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn fsl_shw_add_entropy()                                                  */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Add entropy to random number generator.
  *
  * @param      user_ctx  A user context from #fsl_shw_register_user().
@@ -523,9 +591,9 @@ fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx, uint32_t length,
 }				/* fsl_shw_add_entropy */
 
 #ifdef RNG_REGISTER_PEEK_POKE
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn rng_read_register()                                                   */
-/*!***************************************************************************/
+/*****************************************************************************/
 /*
  * Debug routines to allow reading of RNG registers.
  *
@@ -554,9 +622,9 @@ rng_return_t rng_read_register(uint32_t register_offset, uint32_t * value)
 	return return_code;
 }				/* rng_read_register */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn rng_write_register()                                                  */
-/*!***************************************************************************/
+/*****************************************************************************/
 /*
  * Debug routines to allow writing of RNG registers.
  *
@@ -585,17 +653,17 @@ rng_return_t rng_write_register(uint32_t register_offset, uint32_t value)
 }				/* rng_write_register */
 #endif				/*  RNG_REGISTER_PEEK_POKE */
 
-/*!****************************************************************************
+/******************************************************************************
  *
  *  Function Implementations - Internal
  *
  *****************************************************************************/
 
 #ifdef RNG_REGISTER_PEEK_POKE
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn check_register_offset()                                                */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Verify that the @c offset is appropriate for the RNG's register set.
  *
  * @param[in]  offset  The (byte) offset within the RNG block
@@ -623,10 +691,10 @@ inline int rng_check_register_offset(uint32_t offset)
 
 }				/* rng_check_register */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn check_register_accessible()                                            */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Make sure that register access is legal.
  *
  * Verify that, if in secure mode, only safe registers are used.
@@ -708,25 +776,28 @@ static int rng_check_register_accessible(uint32_t offset, int access_write)
 			    ) {
 				return_code = TRUE;	/* can be written */
 			} else {
-				pr_debug
-				    ("RNG: Offset %04x denied write access\n",
-				     offset);
+#ifdef RNG_DEBUG
+				LOG_KDIAG_ARGS
+				    ("Offset %04x denied write access", offset);
+#endif
 			}
 		}		/* write */
 	} /* not high assurance and inaccessible register... */
 	else {
-		pr_debug("RNG: Offset %04x denied high-assurance access\n",
-			 offset);
+#ifdef RNG_DEBUG
+		LOG_KDIAG_ARGS("Offset %04x denied high-assurance access",
+			       offset);
+#endif
 	}
 
 	return return_code;
 }				/* rng_check_register_accessible */
 #endif				/*  RNG_REGISTER_PEEK_POKE */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn rng_irq()                                                             */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * This is the interrupt handler for the RNG.  It is only ever invoked if the
  * RNG detects a FIFO Underflow error.
  *
@@ -743,7 +814,10 @@ OS_DEV_ISR(rng_irq)
 {
 	int handled = FALSE;	/* assume interrupt isn't from RNG */
 
-	pr_debug("RNG Driver: Inside the RNG Interrupt Handler\n");
+#ifdef RNG_DEBUG
+	LOG_KDIAG("rng irq!");
+#endif
+
 	if (RNG_SEED_DONE()) {
 		complete(&rng_seed_done);
 		RNG_CLEAR_ALL_STATUS();
@@ -770,10 +844,10 @@ OS_DEV_ISR(rng_irq)
 	os_dev_isr_return(handled);
 }				/* rng_irq */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn map_RNG_memory()                                                      */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Place the RNG's memory into kernel virtual space.
  *
  * @return OS_ERROR_OK_S on success, os_error_code on failure
@@ -782,12 +856,12 @@ static os_error_code rng_map_RNG_memory(void)
 {
 	os_error_code error_code = OS_ERROR_FAIL_S;
 
-	/* Map the RNG memory on the internal bus into kernel address
-	   space */
 	rng_base = os_map_device(RNG_BASE_ADDR, RNG_ADDRESS_RANGE);
 	if (rng_base == NULL) {
 		/* failure ! */
-		pr_debug("RNG Driver: ioremap failed.\n");
+#ifdef RNG_DEBUG
+		LOG_KDIAG("RNG Driver: ioremap failed.");
+#endif
 	} else {
 		error_code = OS_ERROR_OK_S;
 	}
@@ -795,11 +869,11 @@ static os_error_code rng_map_RNG_memory(void)
 	return error_code;
 }				/* rng_map_RNG_memory */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn rng_setup_interrupt_handling()                                        */
-/*!***************************************************************************/
-/*!
- * Register #rng_irq() as the interrupt handler for #MXC_INT_RNG.
+/*****************************************************************************/
+/**
+ * Register #rng_irq() as the interrupt handler for #INT_RNG.
  *
  * @return OS_ERROR_OK_S on success, os_error_code on failure
  */
@@ -811,10 +885,12 @@ static os_error_code rng_setup_interrupt_handling(void)
 	 * Install interrupt service routine for the RNG. Ignore the
 	 * assigned IRQ number.
 	 */
-	error_code = os_register_interrupt(RNG_DRIVER_NAME, MXC_INT_RNG,
+	error_code = os_register_interrupt(RNG_DRIVER_NAME, INT_RNG,
 					   OS_DEV_ISR_REF(rng_irq));
 	if (error_code != OS_ERROR_OK_S) {
-		pr_debug("RNG Driver: Error installing Interrupt Handler\n");
+#ifdef RNG_DEBUG
+		LOG_KDIAG("RNG Driver: Error installing Interrupt Handler");
+#endif
 	} else {
 		RNG_UNMASK_ALL_INTERRUPTS();
 	}
@@ -822,10 +898,10 @@ static os_error_code rng_setup_interrupt_handling(void)
 	return error_code;
 }				/* rng_setup_interrupt_handling */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn rng_grab_config_values()                                               */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Read configuration information from the RNG.
  *
  * Sets #rng_output_fifo_size.
@@ -848,10 +924,12 @@ static os_error_code rng_grab_config_values(void)
 		}
 	}
 	if (ret != OS_ERROR_OK_S) {
-		pr_debug
-		    ("RNG: Unknown or unexpected RNG type %d (FIFO size %d)."
-		     "  Failing driver initialization\n", type,
+#ifdef RNG_DEBUG
+		LOG_KDIAG_ARGS
+		    ("Unknown or unexpected RNG type %d (FIFO size %d)."
+		     "  Failing driver initialization", type,
 		     rng_output_fifo_size);
+#endif
 	}
 
 	return ret;
@@ -859,10 +937,10 @@ static os_error_code rng_grab_config_values(void)
 
  /* rng_grab_config_values */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn rng_drain_fifo()                                                       */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * This function copies words from the RNG FIFO into the caller's buffer.
  *
  *
@@ -890,8 +968,8 @@ static fsl_shw_return_t rng_drain_fifo(uint32_t * random_p, int count_words)
 			RNG_SEED_GEN();
 			wait_for_completion(&rng_seed_done);
 			if (count_for_reseed == 3) {
-				os_printk
-				    ("Device could not able to enter RESEED Mode\n");
+				os_printk(KERN_ALERT
+				  "Device was not able to enter RESEED Mode\n");
 				code = FSL_RETURN_INTERNAL_ERROR_S;
 			}
 			count_for_reseed++;
@@ -909,8 +987,10 @@ static fsl_shw_return_t rng_drain_fifo(uint32_t * random_p, int count_words)
 				max_sequential = sequential_count;
 			}
 			if (sequential_count >= RNG_MAX_TRIES) {
-				pr_debug("RNG: FIFO staying empty (%d)\n",
-					 words_in_rng);
+#ifdef RNG_DEBUG
+				LOG_KDIAG_ARGS("FIFO staying empty (%d)",
+					       words_in_rng);
+#endif
 				code = FSL_RETURN_NO_RESOURCE_S;
 				break;
 			}
@@ -941,17 +1021,19 @@ static fsl_shw_return_t rng_drain_fifo(uint32_t * random_p, int count_words)
 		code = FSL_RETURN_OK_S;
 	}
 	if (fifo_empty_count != 0) {
-		pr_debug("RNG: FIFO empty %d times, max loop count %d\n",
-			 fifo_empty_count, max_sequential);
+#ifdef RNG_DEBUG
+		LOG_KDIAG_ARGS("FIFO empty %d times, max loop count %d",
+			       fifo_empty_count, max_sequential);
+#endif
 	}
 
 	return code;
 }				/* rng_drain_fifo */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn rng_entropy_task()                                                     */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * This is the background task of the driver.  It is scheduled by
  * RNG_ADD_WORK_ENTRY().
  *
@@ -965,17 +1047,23 @@ OS_DEV_TASK(rng_entropy_task)
 
 	os_dev_task_begin();
 
-	pr_debug("RNG: entropy task starting\n");
+#ifdef RNG_ENTROPY_DEBUG
+	LOG_KDIAG("entropy task starting");
+#endif
 
 	while ((work = RNG_GET_WORK_ENTRY()) != NULL) {
-		pr_debug("RNG: found %d bytes of work at %p (%p)\n",
-			 work->length, work, work->data_local);
+#ifdef RNG_ENTROPY_DEBUG
+		LOG_KDIAG_ARGS("found %d bytes of work at %p (%p)",
+			       work->length, work, work->data_local);
+#endif
 		work->hdr.code = rng_drain_fifo(work->data_local,
 						BYTES_TO_WORDS(work->length));
 		work->completed = TRUE;
 
 		if (work->hdr.flags & FSL_UCO_BLOCKING_MODE) {
-			pr_debug("RNG: Waking queued processes\n");
+#ifdef RNG_ENTROPY_DEBUG
+			LOG_KDIAG("Waking queued processes");
+#endif
 			os_wake_sleepers(rng_wait_queue);
 		} else {
 			os_lock_context_t lock_context;
@@ -989,23 +1077,28 @@ OS_DEV_TASK(rng_entropy_task)
 				if (work->hdr.callback != NULL) {
 					work->hdr.callback(work->hdr.user_ctx);
 				} else {
-					pr_debug
-					    ("RNG: Callback ptr for %p is NULL\n",
+#ifdef RNG_ENTROPY_DEBUG
+					LOG_KDIAG_ARGS
+					    ("Callback ptr for %p is NULL",
 					     work);
+#endif
 				}
 			}
 		}
 	}			/* while */
 
-	pr_debug("RNG: entropy task ending\n");
+#ifdef RNG_ENTROPY_DEBUG
+	LOG_KDIAG("entropy task ending");
+#endif
 
 	os_dev_task_return(OS_ERROR_OK_S);
 }				/* rng_entropy_task */
 
-/*!***************************************************************************/
+#ifdef FSL_HAVE_RNGA
+/*****************************************************************************/
 /* fn rng_sec_failure()                                                      */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Function to handle "Security Alarm" indication from SCC.
  *
  * This function is registered with the Security Monitor ans the callback
@@ -1016,18 +1109,19 @@ OS_DEV_TASK(rng_entropy_task)
  */
 static void rng_sec_failure(void)
 {
-	pr_debug("RNG Driver: Security Failure Alarm received.\n");
+	os_printk(KERN_ALERT "RNG Driver: Security Failure Alarm received.\n");
 
 	rng_cleanup();
 
 	return;
 }
+#endif
 
 #ifdef RNG_REGISTER_DEBUG
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn dbg_rng_read_register()                                                */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Noisily read a 32-bit value to an RNG register.
  * @param offset        The address of the register to read.
  *
@@ -1048,10 +1142,10 @@ static uint32_t dbg_rng_read_register(uint32_t offset)
 	return value;
 }
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn dbg_rng_write_register()                                               */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Noisily write a 32-bit value to an RNG register.
  * @param offset        The address of the register to written.
  *
@@ -1059,7 +1153,9 @@ static uint32_t dbg_rng_read_register(uint32_t offset)
  */
 static void dbg_rng_write_register(uint32_t offset, uint32_t value)
 {
-	pr_debug("RNG WR: 0x%4x : 0x%08x\n", offset, value);
+#ifdef RNG_DEBUG
+	LOG_KDIAG_ARGS("WR: 0x%4x : 0x%08x", offset, value);
+#endif
 	os_write32(value, rng_base + offset);
 	return;
 }
diff --git a/drivers/mxc/security/rng/shw_driver.c b/drivers/mxc/security/rng/shw_driver.c
index 8619f45..d5e7358 100644
--- a/drivers/mxc/security/rng/shw_driver.c
+++ b/drivers/mxc/security/rng/shw_driver.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -60,10 +60,21 @@
 
 #include "portable_os.h"
 #include "fsl_shw.h"
+#include "fsl_shw_keystore.h"
 
 #include "shw_internals.h"
 
-/*!****************************************************************************
+#ifdef FSL_HAVE_SCC2
+#include <asm/arch/mxc_scc2_driver.h>
+#else
+#include <asm/arch/mxc_scc_driver.h>
+#endif
+
+#ifdef SHW_DEBUG
+#include <diagnostic.h>
+#endif
+
+/******************************************************************************
  *
  *  Function Declarations
  *
@@ -73,57 +84,87 @@
 OS_DEV_INIT_DCL(shw_init);
 OS_DEV_SHUTDOWN_DCL(shw_shutdown);
 OS_DEV_IOCTL_DCL(shw_ioctl);
+OS_DEV_MMAP_DCL(shw_mmap);
+
+static os_error_code
+shw_handle_scc_sfree(fsl_shw_uco_t *user_ctx, uint32_t info);
+
+static os_error_code
+shw_handle_scc_sstatus(fsl_shw_uco_t *user_ctx, uint32_t info);
+
+static os_error_code
+shw_handle_scc_drop_perms(fsl_shw_uco_t *user_ctx, uint32_t info);
 
-/*!****************************************************************************
+static os_error_code
+shw_handle_scc_encrypt(fsl_shw_uco_t *user_ctx, uint32_t info);
+
+static os_error_code
+shw_handle_scc_decrypt(fsl_shw_uco_t *user_ctx, uint32_t info);
+
+#ifdef FSL_HAVE_SCC2
+static fsl_shw_return_t register_user_partition(fsl_shw_uco_t *user_ctx,
+						uint32_t user_base,
+						void *kernel_base);
+static fsl_shw_return_t deregister_user_partition(fsl_shw_uco_t *user_ctx,
+						  uint32_t user_base);
+void *lookup_user_partition(fsl_shw_uco_t *user_ctx, uint32_t user_base);
+
+#endif				/* FSL_HAVE_SCC2 */
+
+/******************************************************************************
  *
  *  Global / Static Variables
  *
  *****************************************************************************/
 
-/*!
+/**
  *  Major node (user/device interaction value) of this driver.
  */
 static int shw_major_node = SHW_MAJOR_NODE;
 
-/*!
+/**
  *  Flag to know whether the driver has been associated with its user device
  *  node (e.g. /dev/shw).
  */
 static int shw_device_registered = 0;
 
-/*!
+/**
  * OS-dependent handle used for registering user interface of a driver.
  */
 static os_driver_reg_t reg_handle;
 
-/*!
+/**
  * Linked List of registered users of the API
  */
+fsl_shw_uco_t *user_list;
 
-/*!
+/**
  * This is the lock for all user request pools.  H/W component drivers may also
  * use it for their own work queues.
  */
 os_lock_t shw_queue_lock = NULL;
 
+/* This is the system keystore object */
+fsl_shw_kso_t system_keystore;
+
 #ifndef FSL_HAVE_SAHARA
-/*! Empty list of supported symmetric algorithms. */
+/** Empty list of supported symmetric algorithms. */
 static fsl_shw_key_alg_t pf_syms[] = {
 };
 
-/*! Empty list of supported symmetric modes. */
+/** Empty list of supported symmetric modes. */
 static fsl_shw_sym_mode_t pf_modes[] = {
 };
 
-/*! Empty list of supported hash algorithms. */
+/** Empty list of supported hash algorithms. */
 static fsl_shw_hash_alg_t pf_hashes[] = {
 };
 #endif				/* no Sahara */
 
-/*! This matches SHW capabilities... */
+/** This matches SHW capabilities... */
 static fsl_shw_pco_t cap = {
-	1, 1,			/* api version number - major & minor */
-	1, 0,			/* driver version number - major & minor */
+	1, 2,			/* api version number - major & minor */
+	1, 1,			/* driver version number - major & minor */
 	sizeof(pf_syms) / sizeof(fsl_shw_key_alg_t),	/* key alg count */
 	pf_syms,		/* key alg list ptr */
 	sizeof(pf_modes) / sizeof(fsl_shw_sym_mode_t),	/* sym mode count */
@@ -146,28 +187,33 @@ static fsl_shw_pco_t cap = {
 	 {0, 0, 0, 0}		/* ARC4 */
 	 }
 	,
+	0, 0,			/* SCC driver version */
+	0, 0, 0,		/* SCC version/capabilities */
+	{{0, 0}
+	 }
+	,			/* (filled in during OS_INIT) */
 };
 
 /* These are often handy */
 #ifndef FALSE
-/*! Not true.  Guaranteed to be zero. */
+/** Not true.  Guaranteed to be zero. */
 #define FALSE 0
 #endif
 #ifndef TRUE
-/*! True.  Guaranteed to be non-zero. */
+/** True.  Guaranteed to be non-zero. */
 #define TRUE 1
 #endif
 
-/*!****************************************************************************
+/******************************************************************************
  *
  *  Function Implementations - Externally Accessible
  *
  *****************************************************************************/
 
-/*!***************************************************************************/
-/* fn shw_init()                                                            */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/* fn shw_init()                                                             */
+/*****************************************************************************/
+/**
  * Initialize the driver.
  *
  * This routine is called during kernel init or module load (insmod).
@@ -177,8 +223,11 @@ static fsl_shw_pco_t cap = {
 OS_DEV_INIT(shw_init)
 {
 	os_error_code error_code = OS_ERROR_NO_MEMORY_S;	/* assume failure */
+	scc_config_t *shw_capabilities;
 
-	pr_debug("SHW Driver: Loading\n");
+#ifdef SHW_DEBUG
+	LOG_KDIAG("SHW Driver: Loading");
+#endif
 
 	user_list = NULL;
 	shw_queue_lock = os_lock_alloc_init();
@@ -186,25 +235,75 @@ OS_DEV_INIT(shw_init)
 	if (shw_queue_lock != NULL) {
 		error_code = shw_setup_user_driver_interaction();
 		if (error_code != OS_ERROR_OK_S) {
-			pr_debug("SHW Driver: Failed to setup user"
-				 " i/f: %d\n", error_code);
+#ifdef SHW_DEBUG
+			LOG_KDIAG_ARGS
+			    ("SHW Driver: Failed to setup user i/f: %d",
+			     error_code);
+#endif
 		}
 	}
+
 	/* queue_lock not NULL */
+	/* Fill in the SCC portion of the capabilities object */
+	shw_capabilities = scc_get_configuration();
+	cap.scc_driver_major = shw_capabilities->driver_major_version;
+	cap.scc_driver_minor = shw_capabilities->driver_minor_version;
+	cap.scm_version = shw_capabilities->scm_version;
+	cap.smn_version = shw_capabilities->smn_version;
+	cap.block_size_bytes = shw_capabilities->block_size_bytes;
+
+#ifdef FSL_HAVE_SCC
+	cap.scc_info.black_ram_size_blocks =
+	    shw_capabilities->black_ram_size_blocks;
+	cap.scc_info.red_ram_size_blocks =
+	    shw_capabilities->red_ram_size_blocks;
+#elif defined(FSL_HAVE_SCC2)
+	cap.scc2_info.partition_size_bytes =
+	    shw_capabilities->partition_size_bytes;
+	cap.scc2_info.partition_count = shw_capabilities->partition_count;
+#endif
+
+#ifdef FSL_HAVE_SCC2
+	if (error_code == OS_ERROR_OK_S) {
+/* set up the system keystore, using the default keystore handler */
+		fsl_shw_init_keystore_default(&system_keystore);
+
+		if (fsl_shw_establish_keystore(NULL, &system_keystore)
+		    == FSL_RETURN_OK_S) {
+			error_code = OS_ERROR_OK_S;
+		} else {
+			error_code = OS_ERROR_FAIL_S;
+		}
+
+		if (error_code < OS_ERROR_OK_S) {
+#ifdef SHW_DEBUG
+			LOG_KDIAG_ARGS
+			    ("Registering the system keystore failed with error"
+			     " code: %d\n", error_code);
+#endif
+		}
+	}
+#endif				/* FSL_HAVE_SCC2 */
+
 	if (error_code != OS_ERROR_OK_S) {
-		pr_debug("SHW: Driver initialization failed. %d\n", error_code);
+#ifdef SHW_DEBUG
+		LOG_KDIAG_ARGS("SHW: Driver initialization failed. %d",
+			       error_code);
+#endif
 		shw_cleanup();
 	} else {
-		pr_debug("SHW: Driver initialization complete.\n");
+#ifdef SHW_DEBUG
+		LOG_KDIAG("SHW: Driver initialization complete.");
+#endif
 	}
 
 	os_dev_init_return(error_code);
 }				/* shw_init */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn shw_shutdown()                                                         */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Prepare driver for exit.
  *
  * This is called during @c rmmod when the driver is unloading or when the
@@ -216,16 +315,18 @@ OS_DEV_INIT(shw_init)
 OS_DEV_SHUTDOWN(shw_shutdown)
 {
 
-	pr_debug("SHW: shutdown called\n");
+#ifdef SHW_DEBUG
+	LOG_KDIAG("SHW: shutdown called");
+#endif
 	shw_cleanup();
 
 	os_dev_shutdown_return(OS_ERROR_OK_S);
 }				/* shw_shutdown */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn shw_cleanup()                                                          */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Prepare driver for shutdown.
  *
  * Remove the driver registration.
@@ -243,13 +344,15 @@ static void shw_cleanup(void)
 	if (shw_queue_lock != NULL) {
 		os_lock_deallocate(shw_queue_lock);
 	}
-	pr_debug("SHW Driver: Cleaned up\n");
+#ifdef SHW_DEBUG
+	LOG_KDIAG("SHW Driver: Cleaned up");
+#endif
 }				/* shw_cleanup */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn shw_open()                                                             */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Handle @c open() call from user.
  *
  * @return OS_ERROR_OK_S on success (always!)
@@ -263,10 +366,10 @@ OS_DEV_OPEN(shw_open)
 	os_dev_open_return(status);
 }				/* shw_open */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn shw_ioctl()                                                            */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Process an ioctl() request from user-mode API.
  *
  * This code determines which of the API requests the user has made and then
@@ -280,10 +383,15 @@ OS_DEV_IOCTL(shw_ioctl)
 
 	fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
 
-	pr_debug("SHW: IOCTL %d received\n", os_dev_get_ioctl_op());
+#ifdef SHW_DEBUG
+	LOG_KDIAG_ARGS("SHW: IOCTL %d received", os_dev_get_ioctl_op());
+#endif
 	switch (os_dev_get_ioctl_op()) {
 
 	case SHW_IOCTL_REQUEST + SHW_USER_REQ_REGISTER_USER:
+#ifdef SHW_DEBUG
+		LOG_KDIAG("SHW: register_user ioctl received");
+#endif
 		{
 			fsl_shw_uco_t *user_ctx =
 			    os_alloc_memory(sizeof(*user_ctx), 0);
@@ -303,42 +411,324 @@ OS_DEV_IOCTL(shw_ioctl)
 		break;
 
 	case SHW_IOCTL_REQUEST + SHW_USER_REQ_DEREGISTER_USER:
+#ifdef SHW_DEBUG
+		LOG_KDIAG("SHW: deregister_user ioctl received");
+#endif
+		{
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+			SHW_REMOVE_USER(user_ctx);
+		}
 		break;
 
 	case SHW_IOCTL_REQUEST + SHW_USER_REQ_GET_RESULTS:
+#ifdef SHW_DEBUG
+		LOG_KDIAG("SHW: get_results ioctl received");
+#endif
 		code = get_results(user_ctx, (struct results_req *)
 				   os_dev_get_ioctl_arg());
 		break;
 
 	case SHW_IOCTL_REQUEST + SHW_USER_REQ_GET_CAPABILITIES:
+#ifdef SHW_DEBUG
+		LOG_KDIAG("SHW: get_capabilities ioctl received");
+#endif
 		code = get_capabilities(user_ctx, (fsl_shw_pco_t *)
 					os_dev_get_ioctl_arg());
 		break;
 
 	case SHW_IOCTL_REQUEST + SHW_USER_REQ_GET_RANDOM:
-		pr_debug("SHW: get_random ioctl received\n");
+#ifdef SHW_DEBUG
+		LOG_KDIAG("SHW: get_random ioctl received");
+#endif
 		code = get_random(user_ctx, (struct get_random_req *)
 				  os_dev_get_ioctl_arg());
 		break;
 
 	case SHW_IOCTL_REQUEST + SHW_USER_REQ_ADD_ENTROPY:
-		pr_debug("SHW: add_entropy ioctl received\n");
+#ifdef SHW_DEBUG
+		LOG_KDIAG("SHW: add_entropy ioctl received");
+#endif
 		code = add_entropy(user_ctx, (struct add_entropy_req *)
 				   os_dev_get_ioctl_arg());
 		break;
 
+	case SHW_IOCTL_REQUEST + SHW_USER_REQ_DROP_PERMS:
+#ifdef SHW_DEBUG
+		LOG_KDIAG("SHW: drop permissions ioctl received");
+#endif
+		code =
+		    shw_handle_scc_drop_perms(user_ctx, os_dev_get_ioctl_arg());
+		break;
+
+	case SHW_IOCTL_REQUEST + SHW_USER_REQ_SSTATUS:
+#ifdef SHW_DEBUG
+		LOG_KDIAG("SHW: sstatus ioctl received");
+#endif
+		code = shw_handle_scc_sstatus(user_ctx, os_dev_get_ioctl_arg());
+		break;
+
+	case SHW_IOCTL_REQUEST + SHW_USER_REQ_SFREE:
+#ifdef SHW_DEBUG
+		LOG_KDIAG("SHW: sfree ioctl received");
+#endif
+		code = shw_handle_scc_sfree(user_ctx, os_dev_get_ioctl_arg());
+		break;
+
+	case SHW_IOCTL_REQUEST + SHW_USER_REQ_SCC_ENCRYPT:
+#ifdef SHW_DEBUG
+		LOG_KDIAG("SHW: scc encrypt ioctl received");
+#endif
+		code = shw_handle_scc_encrypt(user_ctx, os_dev_get_ioctl_arg());
+		break;
+
+	case SHW_IOCTL_REQUEST + SHW_USER_REQ_SCC_DECRYPT:
+#ifdef SHW_DEBUG
+		LOG_KDIAG("SHW: scc decrypt ioctl received");
+#endif
+		code = shw_handle_scc_decrypt(user_ctx, os_dev_get_ioctl_arg());
+		break;
+
 	default:
-		pr_debug("SHW: Unexpected ioctl %d\n", os_dev_get_ioctl_op());
+#ifdef SHW_DEBUG
+		LOG_KDIAG_ARGS("SHW: Unexpected ioctl %d",
+			       os_dev_get_ioctl_op());
+#endif
 		break;
 	}
 
 	os_dev_ioctl_return(code);
 }
 
-/*!***************************************************************************/
+#ifdef FSL_HAVE_SCC2
+
+/*****************************************************************************/
+/* fn get_user_smid()                                                        */
+/*****************************************************************************/
+uint32_t get_user_smid(void *proc)
+{
+/*
+ * A real implementation would have some way to handle signed applications
+ * which wouild be assigned distinct SMIDs.  For the reference
+ * implementation, we show where this would be determined (here), but
+ * always provide a fixed answer, thus not separating users at all.
+ */
+
+	return 0x42eaae42;
+}
+
+/* user_base: userspace base address of the partition
+ * kernel_base: kernel mode base address of the partition
+ */
+static fsl_shw_return_t register_user_partition(fsl_shw_uco_t *user_ctx,
+						uint32_t user_base,
+						void *kernel_base)
+{
+	fsl_shw_spo_t *partition_info;
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+
+	if (user_ctx == NULL)
+		goto out;
+
+	partition_info = os_alloc_memory(sizeof(fsl_shw_spo_t), GFP_KERNEL);
+
+	if (partition_info == NULL)
+		goto out;
+
+
+	/* stuff the partition info, then put it at the front of the chain */
+	partition_info->user_base = user_base;
+	partition_info->kernel_base = kernel_base;
+	partition_info->next = user_ctx->partition;
+
+	user_ctx->partition = (struct fsl_shw_spo_t *)partition_info;
+
+#ifdef SHW_DEBUG
+	LOG_KDIAG_ARGS
+	    ("partition with user_base=%p, kernel_base=%p registered.",
+	     (void *)user_base, kernel_base);
+#endif
+
+	ret = FSL_RETURN_OK_S;
+
+out:
+
+	return ret;
+}
+
+/* if the partition is in the users list, remove it */
+static fsl_shw_return_t deregister_user_partition(fsl_shw_uco_t *user_ctx,
+						  uint32_t user_base)
+{
+	fsl_shw_spo_t *curr = (fsl_shw_spo_t *) user_ctx->partition;
+	fsl_shw_spo_t *last = (fsl_shw_spo_t *) user_ctx->partition;
+
+	while (curr != NULL) {
+		if (curr->user_base == user_base) {
+
+#ifdef SHW_DEBUG
+			LOG_KDIAG_ARGS
+			    ("deregister_user_partition: partition with "
+			     "user_base=%p, kernel_base=%p deregistered.\n",
+			     (void *)curr->user_base, curr->kernel_base);
+#endif
+
+			if (last == curr) {
+				user_ctx->partition = curr->next;
+				os_free_memory(curr);
+				return FSL_RETURN_OK_S;
+			} else {
+				last->next = curr->next;
+				os_free_memory(curr);
+				return FSL_RETURN_OK_S;
+			}
+		}
+		last = curr;
+		curr = (fsl_shw_spo_t *) curr->next;
+	}
+
+	return FSL_RETURN_ERROR_S;
+}
+
+/* Find the kernel-mode address of the partition.
+ * This can then be passed to the SCC functions.
+ */
+void *lookup_user_partition(fsl_shw_uco_t *user_ctx, uint32_t user_base)
+{
+/* search through the partition chain to find one that matches the user base
+ * address.
+ */
+	fsl_shw_spo_t *curr = (fsl_shw_spo_t *) user_ctx->partition;
+
+	while (curr != NULL) {
+		if (curr->user_base == user_base)
+			return curr->kernel_base;
+		curr = (fsl_shw_spo_t *) curr->next;
+	}
+	return NULL;
+}
+
+#endif				/* FSL_HAVE_SCC2 */
+
+/**
+*******************************************************************************
+* This function implements the smalloc() function for userspace programs, by
+* making a call to the SCC2 mmap() function that acquires a region of secure
+* memory on behalf of the user, and then maps it into the users memory space.
+* Currently, the only memory size supported is that of a single SCC2 partition.
+* Requests for other sized memory regions will fail.
+*/
+OS_DEV_MMAP(shw_mmap)
+{
+	os_error_code status = OS_ERROR_NO_MEMORY_S;
+
+#ifdef FSL_HAVE_SCC2
+	{
+		scc_return_t scc_ret;
+		fsl_shw_return_t fsl_ret;
+		uint32_t partition_registered = FALSE;
+
+		uint32_t user_base;
+		void *partition_base;
+		uint32_t smid;
+		scc_config_t *scc_configuration;
+
+		int part_no = -1;
+		uint32_t part_phys;
+
+		fsl_shw_uco_t *user_ctx =
+		    (fsl_shw_uco_t *) os_dev_get_user_private();
+
+		/* Make sure that the user context is valid */
+		if (user_ctx == NULL) {
+			user_ctx =
+			    os_alloc_memory(sizeof(*user_ctx), GFP_KERNEL);
+
+			if (user_ctx == NULL) {
+				status = OS_ERROR_NO_MEMORY_S;
+				goto out;
+			}
+			fsl_shw_register_user(user_ctx);
+			os_dev_set_user_private(user_ctx);
+		}
+
+		/* Determine the size of a secure partition */
+		scc_configuration = scc_get_configuration();
+
+	/* Check that the memory size requested is equal to the partition
+	 * size, and that the requested destination is on a page boundary.
+	 */
+		if (((os_mmap_user_base() % PAGE_SIZE) != 0) ||
+		    (os_mmap_memory_size() !=
+		     scc_configuration->partition_size_bytes)) {
+			status = OS_ERROR_BAD_ARG_S;
+			goto out;
+		}
+
+		/* Retrieve the SMID associated with the user */
+		smid = get_user_smid(user_ctx->process);
+
+		/* Attempt to allocate a secure partition */
+		scc_ret =
+		    scc_allocate_partition(smid, &part_no, &partition_base,
+					   &part_phys);
+		if (scc_ret != SCC_RET_OK) {
+			pr_debug
+			    ("SCC mmap() request failed to allocate partition;"
+			     " error %d\n", status);
+			status = OS_ERROR_FAIL_S;
+			goto out;
+		}
+
+		pr_debug("scc_mmap() acquired partition %d at %08x\n",
+			 part_no, part_phys);
+
+		/* Record partition info in the user context */
+		user_base = os_mmap_user_base();
+		fsl_ret =
+		    register_user_partition(user_ctx, user_base,
+					    partition_base);
+
+		if (fsl_ret != FSL_RETURN_OK_S) {
+			pr_debug
+		    ("SCC mmap() request failed to register partition with user"
+		     " context, error: %d\n", fsl_ret);
+			status = OS_ERROR_FAIL_S;
+		}
+
+		partition_registered = TRUE;
+
+		status = map_user_memory(os_mmap_memory_ctx(), part_phys,
+					 os_mmap_memory_size());
+
+#ifdef SHW_DEBUG
+		if (status == OS_ERROR_OK_S) {
+			LOG_KDIAG_ARGS
+		    ("Partition allocated: user_base=%p, partition_base=%p.",
+		     (void *)user_base, partition_base);
+		}
+#endif
+
+out:
+		/* If there is an error it has to be handled here */
+		if (status != OS_ERROR_OK_S) {
+		/* if the partition was registered with the user, unregister it. */
+			if (partition_registered == TRUE)
+				deregister_user_partition(user_ctx, user_base);
+
+			/* if the partition was allocated, deallocate it */
+			if (partition_base != NULL)
+				scc_release_partition(partition_base);
+		}
+	}
+#endif				/* FSL_HAVE_SCC2 */
+
+	return status;
+}
+
+/*****************************************************************************/
 /* fn shw_release()                                                         */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Handle @c close() call from user.
  * This is a Linux device driver interface routine.
  *
@@ -354,15 +744,16 @@ OS_DEV_CLOSE(shw_release)
 		fsl_shw_deregister_user(user_ctx);
 		os_free_memory(user_ctx);
 		os_dev_set_user_private(NULL);
+
 	}
 
 	os_dev_close_return(code);
 }				/* shw_release */
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn shw_user_callback()                                                    */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * FSL SHW User callback function.
  *
  * This function is set in the kernel version of the user context as the
@@ -371,20 +762,23 @@ OS_DEV_CLOSE(shw_release)
  * sending a SIGUSR2 signal which is then caught by the user-mode FSL SHW
  * library.
  *
- * @param uco          Kernel version of uco associated with the request.
+ * @param user_ctx        Kernel version of uco associated with the request.
  *
  * @return void
  */
-static void shw_user_callback(fsl_shw_uco_t * uco)
+static void shw_user_callback(fsl_shw_uco_t *user_ctx)
 {
-	pr_debug("SHW: Signalling callback user process for context %p\n", uco);
-	os_send_signal(uco->process, SIGUSR2);
+#ifdef SHW_DEBUG
+	LOG_KDIAG_ARGS("SHW: Signalling callback user process for context %p\n",
+		       user_ctx);
+#endif
+	os_send_signal(user_ctx->process, SIGUSR2);
 }
 
-/*!***************************************************************************/
+/*****************************************************************************/
 /* fn setup_user_driver_interaction()                                        */
-/*!***************************************************************************/
-/*!
+/*****************************************************************************/
+/**
  * Register the driver with the kernel as the driver for shw_major_node.  Note
  * that this value may be zero, in which case the major number will be assigned
  * by the OS.  shw_major_node is never modified.
@@ -405,27 +799,33 @@ static os_error_code shw_setup_user_driver_interaction(void)
 				   OS_DEV_IOCTL_REF(shw_ioctl));
 	os_driver_add_registration(reg_handle, OS_FN_CLOSE,
 				   OS_DEV_CLOSE_REF(shw_release));
+	os_driver_add_registration(reg_handle, OS_FN_MMAP,
+				   OS_DEV_MMAP_REF(shw_mmap));
 	error_code = os_driver_complete_registration(reg_handle, shw_major_node,
 						     SHW_DRIVER_NAME);
 
 	if (error_code != OS_ERROR_OK_S) {
 		/* failure ! */
-		pr_debug("SHW Driver: register device driver failed: %d\n",
-			 error_code);
+#ifdef SHW_DEBUG
+		LOG_KDIAG_ARGS("SHW Driver: register device driver failed: %d",
+			       error_code);
+#endif
 	} else {		/* success */
 		shw_device_registered = TRUE;
-		pr_debug("SHW Driver:  Major node is %d\n",
-			 os_driver_get_major(reg_handle));
+#ifdef SHW_DEBUG
+		LOG_KDIAG_ARGS("SHW Driver:  Major node is %d\n",
+			       os_driver_get_major(reg_handle));
+#endif
 	}
 
 	return error_code;
 }				/* shw_setup_user_driver_interaction */
 
-/*!****************************************************************/
+/******************************************************************/
 /* User Mode Support                                              */
-/*!****************************************************************/
+/******************************************************************/
 
-/*!
+/**
  * Initialze kernel User Context Object from User-space version.
  *
  * Copy user UCO into kernel UCO, set flags and fields for operation
@@ -449,13 +849,15 @@ static os_error_code init_uco(fsl_shw_uco_t * user_ctx, void *user_mode_uco)
 		user_ctx->callback = shw_user_callback;
 		SHW_ADD_USER(user_ctx);
 	}
-	pr_debug("SHW: init uco returning %d (flags %x)\n", code,
-		 user_ctx->flags);
+#ifdef SHW_DEBUG
+	LOG_KDIAG_ARGS("SHW: init uco returning %d (flags %x)",
+		       code, user_ctx->flags);
+#endif
 
 	return code;
 }
 
-/*!
+/**
  * Copy array from kernel to user space.
  *
  * This routine will check bounds before trying to copy, and return failure
@@ -485,7 +887,7 @@ inline static void *copy_array(void *userloc, void *userend, void *data_start,
 	return userloc;
 }
 
-/*!
+/**
  * Send an FSL SHW API return code up into the user-space request structure.
  *
  * @param user_header   User address of request block / request header
@@ -504,7 +906,346 @@ inline static os_error_code copy_fsl_code(void *user_header,
 			       &result_code, sizeof(result_code));
 }
 
-/*!
+static os_error_code shw_handle_scc_drop_perms(fsl_shw_uco_t *user_ctx,
+					       uint32_t info)
+{
+	os_error_code status = OS_ERROR_NO_MEMORY_S;
+#ifdef FSL_HAVE_SCC2
+	scc_return_t scc_ret;
+	scc_partition_info_t partition_info;
+	void *kernel_base;
+
+	status =
+	    os_copy_from_user(&partition_info, (void *)info,
+			      sizeof(partition_info));
+
+	if (status != OS_ERROR_OK_S)
+		goto out;
+
+	/* validate that the user owns this partition, and look up its handle */
+	kernel_base = lookup_user_partition(user_ctx, partition_info.user_base);
+
+	if (kernel_base == NULL) {
+		status = OS_ERROR_FAIL_S;
+#ifdef SHW_DEBUG
+		LOG_KDIAG("_scc_drop_perms(): failed to find partition\n");
+#endif
+		goto out;
+	}
+
+	/* call scc driver to perform the drop */
+	scc_ret = scc_diminish_permissions(kernel_base,
+					   partition_info.permissions);
+	if (scc_ret == SCC_RET_OK) {
+		status = OS_ERROR_OK_S;
+	} else {
+		status = OS_ERROR_FAIL_S;
+	}
+
+out:
+#endif				/* FSL_HAVE_SCC2 */
+	return status;
+}
+
+static os_error_code shw_handle_scc_sstatus(fsl_shw_uco_t *user_ctx,
+					    uint32_t info)
+{
+	os_error_code status = OS_ERROR_NO_MEMORY_S;
+#ifdef FSL_HAVE_SCC2
+	scc_partition_info_t partition_info;
+	void *kernel_base;
+
+	status = os_copy_from_user(&partition_info,
+				   (void *)info, sizeof(partition_info));
+
+	if (status != OS_ERROR_OK_S)
+		goto out;
+
+	/* validate that the user owns this partition, and look up its handle */
+	kernel_base = lookup_user_partition(user_ctx, partition_info.user_base);
+
+	if (kernel_base == NULL) {
+		status = OS_ERROR_FAIL_S;
+#ifdef SHW_DEBUG
+		LOG_KDIAG("Failed to find partition\n");
+#endif
+		goto out;
+	}
+
+	/* Call the SCC driver to ask about the partition status */
+	partition_info.status = scc_partition_status(kernel_base);
+
+	/* and copy the structure out */
+	status = os_copy_to_user((void *)info,
+				 &partition_info, sizeof(partition_info));
+
+out:
+#endif				/* FSL_HAVE_SCC2 */
+	return status;
+}
+
+static os_error_code shw_handle_scc_sfree(fsl_shw_uco_t *user_ctx,
+					  uint32_t info)
+{
+	os_error_code status = OS_ERROR_NO_MEMORY_S;
+#ifdef FSL_HAVE_SCC2
+	{
+		scc_partition_info_t partition_info;
+		void *kernel_base;
+		int ret;
+
+		status = os_copy_from_user(&partition_info,
+					   (void *)info,
+					   sizeof(partition_info));
+
+		/* check that the copy was successful */
+		if (status != OS_ERROR_OK_S)
+			goto out;
+
+	/* validate that the user owns this partition, and look up its handle */
+		kernel_base =
+		    lookup_user_partition(user_ctx, partition_info.user_base);
+
+		if (kernel_base == NULL) {
+			status = OS_ERROR_FAIL_S;
+#ifdef SHW_DEBUG
+			LOG_KDIAG("failed to find partition\n");
+#endif				/*SHW_DEBUG */
+			goto out;
+		}
+
+		/* Unmap the memory region (see sys_munmap in mmap.c) */
+		ret = unmap_user_memory(partition_info.user_base, 8192);
+
+		/* If the memory was successfully released */
+		if (ret == OS_ERROR_OK_S) {
+
+			/* release the partition */
+			scc_release_partition(kernel_base);
+
+			/* and remove it from the users context */
+			deregister_user_partition(user_ctx,
+						  partition_info.user_base);
+
+			status = OS_ERROR_OK_S;
+
+		} else {
+#ifdef SHW_DEBUG
+			LOG_KDIAG("do_munmap not successful!");
+#endif
+		}
+
+	}
+out:
+#endif				/* FSL_HAVE_SCC2 */
+	return status;
+}
+
+static os_error_code shw_handle_scc_encrypt(fsl_shw_uco_t *user_ctx,
+					    uint32_t info)
+{
+	os_error_code status = OS_ERROR_FAIL_S;
+#ifdef FSL_HAVE_SCC2
+	{
+		fsl_shw_return_t retval;
+		scc_region_t region_info;
+		void *page_ctx = NULL;
+		void *black_addr = NULL;
+		void *partition_base = NULL;
+		scc_config_t *scc_configuration;
+
+		status =
+		    os_copy_from_user(&region_info, (void *)info,
+				      sizeof(region_info));
+
+		if (status != OS_ERROR_OK_S)
+			goto out;
+
+	/* validate that the user owns this partition, and look up its handle */
+		partition_base = lookup_user_partition(user_ctx,
+						       region_info.
+						       partition_base);
+
+		if (partition_base == NULL) {
+			status = OS_ERROR_FAIL_S;
+#ifdef SHW_DEBUG
+			LOG_KDIAG("failed to find secure partition\n");
+#endif
+			goto out;
+		}
+
+		/* Check that the memory size requested is correct */
+		scc_configuration = scc_get_configuration();
+		if (region_info.offset + region_info.length >
+		    scc_configuration->partition_size_bytes) {
+			status = OS_ERROR_FAIL_S;
+			goto out;
+		}
+
+		/* wire down black_data */
+		black_addr = wire_user_memory(region_info.black_data,
+					      region_info.length, &page_ctx);
+
+		if (black_addr == NULL) {
+			status = OS_ERROR_FAIL_S;
+			goto out;
+		}
+
+		retval =
+		    do_scc_encrypt_region(NULL, partition_base,
+					  region_info.offset,
+					  region_info.length, black_addr,
+					  region_info.IV,
+					  region_info.cypher_mode);
+
+		if (retval == FSL_RETURN_OK_S)
+			status = OS_ERROR_OK_S;
+		else
+			status = OS_ERROR_FAIL_S;
+
+		/* release black data */
+		unwire_user_memory(&page_ctx);
+	}
+out:
+
+#endif				/* FSL_HAVE_SCC2 */
+	return status;
+}
+
+static os_error_code shw_handle_scc_decrypt(fsl_shw_uco_t *user_ctx,
+					    uint32_t info)
+{
+	os_error_code status = OS_ERROR_FAIL_S;
+#ifdef FSL_HAVE_SCC2
+	{
+		fsl_shw_return_t retval;
+		scc_region_t region_info;
+		void *page_ctx = NULL;
+		void *black_addr;
+		void *partition_base;
+		scc_config_t *scc_configuration;
+
+		status =
+		    os_copy_from_user(&region_info, (void *)info,
+				      sizeof(region_info));
+
+#ifdef SHW_DEBUG
+		LOG_KDIAG_ARGS
+		    ("partition_base: %p, offset: %i, length: %i, black data: %p",
+		     (void *)region_info.partition_base, region_info.offset,
+		     region_info.length, (void *)region_info.black_data);
+#endif
+
+		if (status != OS_ERROR_OK_S)
+			goto out;
+
+	/* validate that the user owns this partition, and look up its handle */
+		partition_base = lookup_user_partition(user_ctx,
+						       region_info.
+						       partition_base);
+
+		if (partition_base == NULL) {
+			status = OS_ERROR_FAIL_S;
+#ifdef SHW_DEBUG
+			LOG_KDIAG("failed to find partition\n");
+#endif
+			goto out;
+		}
+
+		/* Check that the memory size requested is correct */
+		scc_configuration = scc_get_configuration();
+		if (region_info.offset + region_info.length >
+		    scc_configuration->partition_size_bytes) {
+			status = OS_ERROR_FAIL_S;
+			goto out;
+		}
+
+		/* wire down black_data */
+		black_addr = wire_user_memory(region_info.black_data,
+					      region_info.length, &page_ctx);
+
+		if (black_addr == NULL) {
+			status = OS_ERROR_FAIL_S;
+			goto out;
+		}
+
+		retval =
+		    do_scc_decrypt_region(NULL, partition_base,
+					  region_info.offset,
+					  region_info.length, black_addr,
+					  region_info.IV,
+					  region_info.cypher_mode);
+
+		if (retval == FSL_RETURN_OK_S)
+			status = OS_ERROR_OK_S;
+		else
+			status = OS_ERROR_FAIL_S;
+
+		/* release black data */
+		unwire_user_memory(&page_ctx);
+	}
+out:
+
+#endif				/* FSL_HAVE_SCC2 */
+	return status;
+}
+
+fsl_shw_return_t do_system_keystore_slot_alloc(fsl_shw_uco_t *user_ctx,
+					       uint32_t key_length,
+					       uint64_t ownerid,
+					       uint32_t *slot)
+{
+	(void)user_ctx;
+	return keystore_slot_alloc(&system_keystore, key_length, ownerid, slot);
+}
+EXPORT_SYMBOL(do_system_keystore_slot_alloc);
+
+fsl_shw_return_t do_system_keystore_slot_dealloc(fsl_shw_uco_t *user_ctx,
+						 uint64_t ownerid,
+						 uint32_t slot)
+{
+	(void)user_ctx;
+	return keystore_slot_dealloc(&system_keystore, ownerid, slot);
+}
+EXPORT_SYMBOL(do_system_keystore_slot_dealloc);
+
+fsl_shw_return_t do_system_keystore_slot_load(fsl_shw_uco_t *user_ctx,
+					      uint64_t ownerid,
+					      uint32_t slot,
+					      const uint8_t *key,
+					      uint32_t key_length)
+{
+	(void)user_ctx;
+	return keystore_load_slot(&system_keystore, ownerid, slot,
+				  (void *)key, key_length);
+}
+EXPORT_SYMBOL(do_system_keystore_slot_load);
+
+fsl_shw_return_t do_system_keystore_slot_encrypt(fsl_shw_uco_t *user_ctx,
+						 uint64_t ownerid,
+						 uint32_t slot,
+						 uint32_t key_length,
+						 uint8_t *black_data)
+{
+	(void)user_ctx;
+	return keystore_slot_encrypt(NULL, &system_keystore, ownerid,
+				     slot, key_length, black_data);
+}
+EXPORT_SYMBOL(do_system_keystore_slot_encrypt);
+
+fsl_shw_return_t do_system_keystore_slot_decrypt(fsl_shw_uco_t *user_ctx,
+						 uint64_t ownerid,
+						 uint32_t slot,
+						 uint32_t key_length,
+						 const uint8_t *black_data)
+{
+	(void)user_ctx;
+	return keystore_slot_decrypt(NULL, &system_keystore, ownerid,
+				     slot, key_length, black_data);
+}
+EXPORT_SYMBOL(do_system_keystore_slot_decrypt);
+
+/**
  * Handle user-mode Get Capabilities request
  *
  * Right now, this function can only have a failure if the user has failed to
@@ -518,7 +1259,7 @@ inline static os_error_code copy_fsl_code(void *user_header,
  *
  * @return an os_error_code
  */
-static os_error_code get_capabilities(fsl_shw_uco_t * user_ctx,
+static os_error_code get_capabilities(fsl_shw_uco_t *user_ctx,
 				      void *user_mode_pco_request)
 {
 	os_error_code code;
@@ -535,12 +1276,14 @@ static os_error_code get_capabilities(fsl_shw_uco_t * user_ctx,
 	if (code == OS_ERROR_OK_S) {
 		void *endcap;
 		void *user_bounds;
-		pr_debug("SHE: Received get_cap request: 0x%p/%u/0x%x\n",
-			 req.capabilities, req.size, sizeof(fsl_shw_pco_t));
+#ifdef SHW_DEBUG
+		LOG_KDIAG_ARGS("SHE: Received get_cap request: 0x%p/%u/0x%x",
+			       req.capabilities, req.size,
+			       sizeof(fsl_shw_pco_t));
+#endif
 		endcap = req.capabilities + 1;	/* point to end of structure */
 		user_bounds = (void *)req.capabilities + req.size;	/* end of area */
 
-		printk(KERN_INFO "next: %p, end: %p\n", endcap, user_bounds);	//
 		/* First verify that request is big enough for the main structure */
 		if (endcap >= user_bounds) {
 			endcap = NULL;	/* No! */
@@ -580,7 +1323,7 @@ static os_error_code get_capabilities(fsl_shw_uco_t * user_ctx,
 		}
 
 		if (endcap == NULL) {
-			code = OS_ERROR_BAD_ADDRESS;
+			code = OS_ERROR_BAD_ADDRESS_S;
 		}
 
 		/* And return the FSL SHW code in the request structure. */
@@ -593,12 +1336,14 @@ static os_error_code get_capabilities(fsl_shw_uco_t * user_ctx,
 
 	/* code may already be set to an error.  This is another error case.  */
 
-	pr_debug("SHW: get capabilities returning %d\n", code);
+#ifdef SHW_DEBUG
+	LOG_KDIAG_ARGS("SHW: get capabilities returning %d", code);
+#endif
 
 	return code;
 }
 
-/*!
+/**
  * Handle user-mode Get Results request
  *
  * Get arguments from user space into kernel space, then call
@@ -610,7 +1355,7 @@ static os_error_code get_capabilities(fsl_shw_uco_t * user_ctx,
  *
  * @return an os_error_code
  */
-static os_error_code get_results(fsl_shw_uco_t * user_ctx,
+static os_error_code get_results(fsl_shw_uco_t *user_ctx,
 				 void *user_mode_results_req)
 {
 	os_error_code code;
@@ -658,7 +1403,7 @@ static os_error_code get_results(fsl_shw_uco_t * user_ctx,
 	return code;
 }
 
-/*!
+/**
  * Process header of user-mode request.
  *
  * Mark header as User Mode request.  Update UCO's flags and reference fields
@@ -669,7 +1414,7 @@ static os_error_code get_results(fsl_shw_uco_t * user_ctx,
  *
  * @return void
  */
-inline static void process_hdr(fsl_shw_uco_t * user_ctx,
+static inline void process_hdr(fsl_shw_uco_t *user_ctx,
 			       struct shw_req_header *hdr)
 {
 	hdr->flags |= FSL_UCO_USERMODE_USER;
@@ -679,7 +1424,7 @@ inline static void process_hdr(fsl_shw_uco_t * user_ctx,
 	return;
 }
 
-/*!
+/**
  * Handle user-mode Get Random request
  *
  * @param user_ctx    The kernel version of user's context
@@ -687,7 +1432,7 @@ inline static void process_hdr(fsl_shw_uco_t * user_ctx,
  *
  * @return an os_error_code
  */
-static os_error_code get_random(fsl_shw_uco_t * user_ctx,
+static os_error_code get_random(fsl_shw_uco_t *user_ctx,
 				void *user_mode_get_random_req)
 {
 	os_error_code code;
@@ -696,13 +1441,18 @@ static os_error_code get_random(fsl_shw_uco_t * user_ctx,
 	code = os_copy_from_user(&req, user_mode_get_random_req, sizeof(req));
 	if (code == OS_ERROR_OK_S) {
 		process_hdr(user_ctx, &req.hdr);
-		pr_debug("SHW: get_random() for %d bytes in %sblocking mode\n",
-			 req.size, (req.hdr.flags & FSL_UCO_BLOCKING_MODE) ?
-			 "" : "non-");
+#ifdef SHW_DEBUG
+		LOG_KDIAG_ARGS
+		    ("SHW: get_random() for %d bytes in %sblocking mode",
+		     req.size,
+		     (req.hdr.flags & FSL_UCO_BLOCKING_MODE) ? "" : "non-");
+#endif
 		req.hdr.code =
 		    fsl_shw_get_random(user_ctx, req.size, req.random);
 
-		pr_debug("SHW: get_random() returning %d\n", req.hdr.code);
+#ifdef SHW_DEBUG
+		LOG_KDIAG_ARGS("SHW: get_random() returning %d", req.hdr.code);
+#endif
 
 		/* Copy FSL function status back to user */
 		code = copy_fsl_code(user_mode_get_random_req, req.hdr.code);
@@ -711,7 +1461,7 @@ static os_error_code get_random(fsl_shw_uco_t * user_ctx,
 	return code;
 }
 
-/*!
+/**
  * Handle user-mode Add Entropy request
  *
  * @param user_ctx    Pointer to the kernel version of user's context
@@ -719,7 +1469,7 @@ static os_error_code get_random(fsl_shw_uco_t * user_ctx,
  *
  * @return an os_error_code
  */
-static os_error_code add_entropy(fsl_shw_uco_t * user_ctx,
+static os_error_code add_entropy(fsl_shw_uco_t *user_ctx,
 				 void *user_mode_add_entropy_req)
 {
 	os_error_code code;
@@ -751,20 +1501,19 @@ static os_error_code add_entropy(fsl_shw_uco_t * user_ctx,
 	return code;
 }
 
-/*!****************************************************************/
+/******************************************************************/
 /* End User Mode Support                                          */
-/*!****************************************************************/
+/******************************************************************/
 
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_register_user);
-#endif
 /* REQ-S2LRD-PINTFC-API-GEN-004 */
 /*
  * Handle user registration.
  *
  * @param  user_ctx   The user context for the registration.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
  */
-fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t * user_ctx)
+fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t *user_ctx)
 {
 	fsl_shw_return_t code = FSL_RETURN_INTERNAL_ERROR_S;
 
@@ -785,21 +1534,20 @@ fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t * user_ctx)
       error_exit:
 	return code;
 }
+EXPORT_SYMBOL(fsl_shw_register_user);
 
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_deregister_user);
-#endif
 /* REQ-S2LRD-PINTFC-API-GEN-005 */
-/*!
+/**
  * Destroy the association between the the user and the provider of the API.
  *
  * @param  user_ctx   The user context which is no longer needed.
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t * user_ctx)
+fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t *user_ctx)
 {
 	shw_queue_entry_t *finished_request;
+	fsl_shw_return_t ret = FSL_RETURN_OK_S;
 
 	/* Clean up what we find in result pool. */
 	do {
@@ -817,16 +1565,68 @@ fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t * user_ctx)
 		}
 	} while (finished_request != NULL);
 
+#ifdef FSL_HAVE_SCC2
+	{
+		fsl_shw_spo_t *partition;
+		struct mm_struct *mm = current->mm;
+
+		while ((user_ctx->partition != NULL)
+		       && (ret == FSL_RETURN_OK_S)) {
+
+			partition = user_ctx->partition;
+
+#ifdef SHW_DEBUG
+			LOG_KDIAG_ARGS
+			    ("Found an abandoned secure partition at %p, releasing",
+			     partition);
+#endif
+
+		/* It appears that current->mm is not valid if this is called from a
+		 * close routine (perhaps only if the program raised an exception that
+		 * caused it to close?)  If that is the case, then still free the
+		 * partition, but do not remove it from the memory space (dangerous?)
+		 */
+
+			if (mm == NULL) {
+#ifdef SHW_DEBUG
+				LOG_KDIAG
+				    ("Warning: no mm structure found, not unmapping "
+				     "partition from user memory\n");
+#endif
+			} else {
+			/* Unmap the memory region (see sys_munmap in mmap.c) */
+			/* Note that this assumes a single memory partition */
+				unmap_user_memory(partition->user_base, 8192);
+			}
+
+			/* If the memory was successfully released */
+			if (ret == OS_ERROR_OK_S) {
+				/* release the partition */
+				scc_release_partition(partition->kernel_base);
+
+				/* and remove it from the users context */
+				deregister_user_partition(user_ctx,
+							  partition->user_base);
+
+				ret = FSL_RETURN_OK_S;
+			} else {
+				ret = FSL_RETURN_ERROR_S;
+
+				goto out;
+			}
+		}
+	}
+out:
+#endif				/* FSL_HAVE_SCC2 */
+
 	SHW_REMOVE_USER(user_ctx);
 
-	return FSL_RETURN_OK_S;
+	return ret;
 }
+EXPORT_SYMBOL(fsl_shw_deregister_user);
 
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_get_results);
-#endif
 /* REQ-S2LRD-PINTFC-API-GEN-006 */
-fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t * user_ctx,
+fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t *user_ctx,
 				     unsigned result_size,
 				     fsl_shw_result_t results[],
 				     unsigned *result_count)
@@ -877,11 +1677,9 @@ fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t * user_ctx,
 
 	return FSL_RETURN_OK_S;
 }
+EXPORT_SYMBOL(fsl_shw_get_results);
 
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_get_capabilities);
-#endif
-fsl_shw_pco_t *fsl_shw_get_capabilities(fsl_shw_uco_t * user_ctx)
+fsl_shw_pco_t *fsl_shw_get_capabilities(fsl_shw_uco_t *user_ctx)
 {
 
 	/* Unused */
@@ -889,6 +1687,7 @@ fsl_shw_pco_t *fsl_shw_get_capabilities(fsl_shw_uco_t * user_ctx)
 
 	return &cap;
 }
+EXPORT_SYMBOL(fsl_shw_get_capabilities);
 
 #if !(defined(FSL_HAVE_SAHARA) || defined(FSL_HAVE_RNGA)                    \
       || defined(FSL_HAVE_RNGC))
@@ -904,9 +1703,10 @@ fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx,
 
 	return FSL_RETURN_ERROR_S;
 }
+EXPORT_SYMBOL(fsl_shw_get_random);
 
-fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx,
-				     uint32_t length, uint8_t * data)
+fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t *user_ctx,
+				     uint32_t length, uint8_t *data)
 {
 
 	/* Unused */
@@ -916,21 +1716,17 @@ fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx,
 
 	return FSL_RETURN_ERROR_S;
 }
-
 EXPORT_SYMBOL(fsl_shw_add_entropy);
-EXPORT_SYMBOL(fsl_shw_get_random);
 
 #endif
 
 #ifndef FSL_HAVE_SAHARA
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_symmetric_decrypt);
-#endif
-fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t * user_ctx,
-					   fsl_shw_sko_t * key_info,
-					   fsl_shw_scco_t * sym_ctx,
+
+fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t *user_ctx,
+					   fsl_shw_sko_t *key_info,
+					   fsl_shw_scco_t *sym_ctx,
 					   uint32_t length,
-					   const uint8_t * ct, uint8_t * pt)
+					   const uint8_t *ct, uint8_t *pt)
 {
 
 	/* Unused */
@@ -944,14 +1740,13 @@ fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t * user_ctx,
 	return FSL_RETURN_ERROR_S;
 }
 
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_symmetric_encrypt);
-#endif
-fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
-					   fsl_shw_sko_t * key_info,
-					   fsl_shw_scco_t * sym_ctx,
+EXPORT_SYMBOL(fsl_shw_symmetric_decrypt);
+
+fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t *user_ctx,
+					   fsl_shw_sko_t *key_info,
+					   fsl_shw_scco_t *sym_ctx,
 					   uint32_t length,
-					   const uint8_t * pt, uint8_t * ct)
+					   const uint8_t *pt, uint8_t *ct)
 {
 
 	/* Unused */
@@ -964,14 +1759,12 @@ fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
 
 	return FSL_RETURN_ERROR_S;
 }
+EXPORT_SYMBOL(fsl_shw_symmetric_encrypt);
 
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_establish_key);
-#endif
-fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
-				       fsl_shw_sko_t * key_info,
+fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t *user_ctx,
+				       fsl_shw_sko_t *key_info,
 				       fsl_shw_key_wrap_t establish_type,
-				       const uint8_t * key)
+				       const uint8_t *key)
 {
 
 	/* Unused */
@@ -982,13 +1775,11 @@ fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
 
 	return FSL_RETURN_ERROR_S;
 }
+EXPORT_SYMBOL(fsl_shw_establish_key);
 
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_extract_key);
-#endif
-fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
-				     fsl_shw_sko_t * key_info,
-				     uint8_t * covered_key)
+fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t *user_ctx,
+				     fsl_shw_sko_t *key_info,
+				     uint8_t *covered_key)
 {
 
 	/* Unused */
@@ -998,12 +1789,10 @@ fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
 
 	return FSL_RETURN_ERROR_S;
 }
+EXPORT_SYMBOL(fsl_shw_extract_key);
 
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_release_key);
-#endif
-fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
-				     fsl_shw_sko_t * key_info)
+fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t *user_ctx,
+				     fsl_shw_sko_t *key_info)
 {
 
 	/* Unused */
@@ -1012,17 +1801,16 @@ fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
 
 	return FSL_RETURN_ERROR_S;
 }
-#endif
+EXPORT_SYMBOL(fsl_shw_release_key);
 
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_hash);
 #endif
+
 #if !defined(FSL_HAVE_SAHARA)
-fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t * user_ctx,
-			      fsl_shw_hco_t * hash_ctx,
-			      const uint8_t * msg,
+fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t *user_ctx,
+			      fsl_shw_hco_t *hash_ctx,
+			      const uint8_t *msg,
 			      uint32_t length,
-			      uint8_t * result, uint32_t result_len)
+			      uint8_t *result, uint32_t result_len)
 {
 	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
 
@@ -1036,16 +1824,16 @@ fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t * user_ctx,
 
 	return ret;
 }
+EXPORT_SYMBOL(fsl_shw_hash);
+
 #endif
 
 #ifndef FSL_HAVE_SAHARA
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_hmac_precompute);
-#endif
 
-fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t * user_ctx,
-					 fsl_shw_sko_t * key_info,
-					 fsl_shw_hmco_t * hmac_ctx)
+
+fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t *user_ctx,
+					 fsl_shw_sko_t *key_info,
+					 fsl_shw_hmco_t *hmac_ctx)
 {
 	fsl_shw_return_t status = FSL_RETURN_ERROR_S;
 
@@ -1057,16 +1845,14 @@ fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t * user_ctx,
 	return status;
 }
 
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_hmac);
-#endif
+EXPORT_SYMBOL(fsl_shw_hmac_precompute);
 
-fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t * user_ctx,
-			      fsl_shw_sko_t * key_info,
-			      fsl_shw_hmco_t * hmac_ctx,
-			      const uint8_t * msg,
+fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t *user_ctx,
+			      fsl_shw_sko_t *key_info,
+			      fsl_shw_hmco_t *hmac_ctx,
+			      const uint8_t *msg,
 			      uint32_t length,
-			      uint8_t * result, uint32_t result_len)
+			      uint8_t *result, uint32_t result_len)
 {
 	fsl_shw_return_t status = FSL_RETURN_ERROR_S;
 
@@ -1081,22 +1867,245 @@ fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t * user_ctx,
 
 	return status;
 }
+
+EXPORT_SYMBOL(fsl_shw_hmac);
+
 #endif
 
-#ifndef FSL_HAVE_SAHARA
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_gen_encrypt);
+/**
+ * Call the proper function to encrypt a region of encrypted secure memory
+ *
+ * @brief
+ *
+ * @param   user_ctx        User context of the partition owner (NULL in kernel)
+ * @param   partition_base  Base address (physical) of the partition
+ * @param   offset_bytes    Offset from base address of the data to be encrypted
+ * @param   byte_count      Length of the message (bytes)
+ * @param   black_data      Pointer to where the encrypted data is stored
+ * @param   IV              IV to use for encryption
+ * @param   cypher_mode     Cyphering mode to use, specified by type
+ *                          #fsl_shw_cypher_mode_t
+ *
+ * @return  status
+ */
+fsl_shw_return_t
+do_scc_encrypt_region(fsl_shw_uco_t *user_ctx,
+		      void *partition_base, uint32_t offset_bytes,
+		      uint32_t byte_count, uint8_t *black_data,
+		      uint32_t *IV, fsl_shw_cypher_mode_t cypher_mode)
+{
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+#ifdef FSL_HAVE_SCC2
+
+	scc_return_t scc_ret;
+
+#ifdef SHW_DEBUG
+	uint32_t *owner_32 = (uint32_t *) &(owner_id);
+
+	LOG_KDIAG_ARGS
+	    ("partition base: %p, offset: %i, count: %i, black data: %p\n",
+	     partition_base, offset_bytes, byte_count, (void *)black_data);
+
+	LOG_KDIAG_ARGS("Owner ID: %08x%08x\n", owner_32[1], owner_32[0]);
+#endif				/* SHW_DEBUG */
+	(void)user_ctx;
+
+	os_cache_flush_range(black_data, byte_count);
+
+	scc_ret =
+	    scc_encrypt_region((uint32_t) partition_base, offset_bytes,
+			       byte_count, __virt_to_phys(black_data), IV,
+			       cypher_mode);
+
+	if (scc_ret == SCC_RET_OK)
+		retval = FSL_RETURN_OK_S;
+	else
+		retval = FSL_RETURN_ERROR_S;
+
+	/* The SCC2 DMA engine should have written to the black ram,
+	 * so we need to invalidate that region of memory.  Note that the
+	 * red ram is not an because it is mapped with the cache disabled.
+	 */
+	os_cache_inv_range(black_data, byte_count);
+
+#endif				/* FSL_HAVE_SCC2 */
+	return retval;
+}
+EXPORT_SYMBOL(do_scc_encrypt_region);
+
+/**
+ * Call the proper function to decrypt a region of encrypted secure memory
+ *
+ * @brief
+ *
+ * @param   user_ctx        User context of the partition owner (NULL in kernel)
+ * @param   partition_base  Base address (physical) of the partition
+ * @param   offset_bytes    Offset from base address that the decrypted data
+ *                          shall be placed
+ * @param   byte_count      Length of the message (bytes)
+ * @param   black_data      Pointer to where the encrypted data is stored
+ * @param   IV              IV to use for decryption
+ * @param   cypher_mode     Cyphering mode to use, specified by type
+ *                          #fsl_shw_cypher_mode_t
+ *
+ * @return  status
+ */
+fsl_shw_return_t
+do_scc_decrypt_region(fsl_shw_uco_t *user_ctx,
+		      void *partition_base, uint32_t offset_bytes,
+		      uint32_t byte_count, const uint8_t *black_data,
+		      uint32_t *IV, fsl_shw_cypher_mode_t cypher_mode)
+{
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+
+#ifdef FSL_HAVE_SCC2
+
+	scc_return_t scc_ret;
+
+#ifdef SHW_DEBUG
+	uint32_t *owner_32 = (uint32_t *) &(owner_id);
+
+	LOG_KDIAG_ARGS
+	    ("partition base: %p, offset: %i, count: %i, black data: %p\n",
+	     partition_base, offset_bytes, byte_count, (void *)black_data);
+
+	LOG_KDIAG_ARGS("Owner ID: %08x%08x\n", owner_32[1], owner_32[0]);
+#endif				/* SHW_DEBUG */
+
+	(void)user_ctx;
+
+	/* The SCC2 DMA engine will be reading from the black ram, so we need to
+	 * make sure that the data is pushed out of the cache.  Note that the red
+	 * ram is not an issue because it is mapped with the cache disabled.
+	 */
+	os_cache_flush_range(black_data, byte_count);
+
+	scc_ret =
+	    scc_decrypt_region((uint32_t) partition_base, offset_bytes,
+			       byte_count,
+			       (uint8_t *) __virt_to_phys(black_data), IV,
+			       cypher_mode);
+
+	if (scc_ret == SCC_RET_OK)
+		retval = FSL_RETURN_OK_S;
+	else
+		retval = FSL_RETURN_ERROR_S;
+
+#endif				/* FSL_HAVE_SCC2 */
+
+	return retval;
+}
+EXPORT_SYMBOL(do_scc_decrypt_region);
+
+void *fsl_shw_smalloc(fsl_shw_uco_t *user_ctx,
+		      uint32_t size, const uint8_t *UMID, uint32_t permissions)
+{
+#ifdef FSL_HAVE_SCC2
+	int part_no;
+	void *part_base;
+	uint32_t part_phys;
+	scc_config_t *scc_configuration;
+
+	/* Check that the memory size requested is correct */
+	scc_configuration = scc_get_configuration();
+	if (size != scc_configuration->partition_size_bytes)
+		return NULL;
+
+	/* attempt to grab a partition. */
+	if (scc_allocate_partition(0, &part_no, &part_base, &part_phys)
+	    != SCC_RET_OK)
+		return NULL;
+
+#ifdef SHW_DEBUG
+	LOG_KDIAG_ARGS("Partition_base:%p, partition_base_phys: %p\n",
+		       part_base, (void *)part_phys);
+#endif
+
+	if (scc_engage_partition(part_base, UMID, permissions)
+	    != SCC_RET_OK) {
+/* Engagement failed, so the partition needs to be de-allocated */
+
+#ifdef SHW_DEBUG
+		LOG_KDIAG_ARGS("Failed to engage partition %p, de-allocating",
+			       part_base);
+#endif
+		scc_release_partition(part_base);
+
+		return NULL;
+	}
+
+	return part_base;
+
+#else				/* FSL_HAVE_SCC2 */
+
+	(void)user_ctx;
+	(void)size;
+	(void)UMID;
+	(void)permissions;
+	return NULL;
+
+#endif				/* FSL_HAVE_SCC2 */
+}
+EXPORT_SYMBOL(fsl_shw_smalloc);
+
+/* Release a block of secure memory */
+fsl_shw_return_t fsl_shw_sfree(fsl_shw_uco_t *user_ctx, void *address)
+{
+	(void)user_ctx;
+
+#ifdef FSL_HAVE_SCC2
+	if (scc_release_partition(address) == SCC_RET_OK) {
+		return FSL_RETURN_OK_S;
+	}
+#endif
+
+	return FSL_RETURN_ERROR_S;
+}
+EXPORT_SYMBOL(fsl_shw_sfree);
+
+/* Check the status of a block of secure memory */
+fsl_shw_return_t fsl_shw_sstatus(fsl_shw_uco_t *user_ctx,
+				 void *address,
+				 fsl_shw_partition_status_t *part_status)
+{
+	(void)user_ctx;
+
+#ifdef FSL_HAVE_SCC2
+	*part_status = scc_partition_status(address);
+
+	return FSL_RETURN_OK_S;
+#endif
+
+	return FSL_RETURN_ERROR_S;
+}
+EXPORT_SYMBOL(fsl_shw_sstatus);
+
+/* Diminish permissions on some secure memory */
+fsl_shw_return_t fsl_shw_diminish_perms(fsl_shw_uco_t *user_ctx,
+					void *address, uint32_t permissions)
+{
+
+	(void)user_ctx;		/* unused parameter warning */
+
+#ifdef FSL_HAVE_SCC2
+	if (scc_diminish_permissions(address, permissions) == SCC_RET_OK)
+		return FSL_RETURN_OK_S;
 #endif
+	return FSL_RETURN_ERROR_S;
+}
+EXPORT_SYMBOL(fsl_shw_diminish_perms);
+
+#ifndef FSL_HAVE_SAHARA
 
-fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
-				     fsl_shw_acco_t * auth_ctx,
-				     fsl_shw_sko_t * cipher_key_info,
-				     fsl_shw_sko_t * auth_key_info,
+fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t *user_ctx,
+				     fsl_shw_acco_t *auth_ctx,
+				     fsl_shw_sko_t *cipher_key_info,
+				     fsl_shw_sko_t *auth_key_info,
 				     uint32_t auth_data_length,
-				     const uint8_t * auth_data,
+				     const uint8_t *auth_data,
 				     uint32_t payload_length,
-				     const uint8_t * payload,
-				     uint8_t * ct, uint8_t * auth_value)
+				     const uint8_t *payload,
+				     uint8_t *ct, uint8_t *auth_value)
 {
 	volatile fsl_shw_return_t status = FSL_RETURN_ERROR_S;
 
@@ -1115,10 +2124,10 @@ fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
 	return status;
 }
 
-#ifdef LINUX_VERSION_CODE
-EXPORT_SYMBOL(fsl_shw_auth_decrypt);
-#endif
-/*!
+EXPORT_SYMBOL(fsl_shw_gen_encrypt);
+
+
+/**
  * @brief Authenticate and decrypt a (CCM) stream.
  *
  * @param user_ctx         The user's context
@@ -1130,19 +2139,19 @@ EXPORT_SYMBOL(fsl_shw_auth_decrypt);
  * @param payload_length   Length in bytes of @a payload
  * @param ct               The encrypted data
  * @param auth_value       The authentication code to validate
- * @param payload     The location to store decrypted data
+ * @param[out] payload     The location to store decrypted data
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
-				      fsl_shw_acco_t * auth_ctx,
-				      fsl_shw_sko_t * cipher_key_info,
-				      fsl_shw_sko_t * auth_key_info,
+fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t *user_ctx,
+				      fsl_shw_acco_t *auth_ctx,
+				      fsl_shw_sko_t *cipher_key_info,
+				      fsl_shw_sko_t *auth_key_info,
 				      uint32_t auth_data_length,
-				      const uint8_t * auth_data,
+				      const uint8_t *auth_data,
 				      uint32_t payload_length,
-				      const uint8_t * ct,
-				      const uint8_t * auth_value,
+				      const uint8_t *ct,
+				      const uint8_t *auth_value,
 				      uint8_t * payload)
 {
 	volatile fsl_shw_return_t status = FSL_RETURN_ERROR_S;
@@ -1161,4 +2170,7 @@ fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
 
 	return status;
 }
+
+EXPORT_SYMBOL(fsl_shw_auth_decrypt);
+
 #endif
diff --git a/drivers/mxc/security/rng/shw_memory_mapper.c b/drivers/mxc/security/rng/shw_memory_mapper.c
new file mode 100644
index 0000000..71f1d30
--- /dev/null
+++ b/drivers/mxc/security/rng/shw_memory_mapper.c
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+
+/**
+ * Memory management functions, from Sahara Crypto API
+ *
+ * This is a subset of the memory management functions from the Sahara Crypto
+ * API, and is intended to support user secure partitions.
+ */
+
+#include "portable_os.h"
+#include "fsl_shw.h"
+
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+
+#ifdef SHW_DEBUG
+#include <diagnostic.h>
+#endif
+
+/* Page context structure.  Used by wire_user_memory and unwire_user_memory */
+typedef struct page_ctx_t {
+    uint32_t        count;
+    struct page   **local_pages;
+} page_ctx_t;
+
+/**
+*******************************************************************************
+* Map and wire down a region of user memory.
+*
+*
+* @param    address     Userspace address of the memory to wire
+* @param    length      Length of the memory region to wire
+* @param    page_ctx    Page context, to be passed to unwire_user_memory
+*
+* @return   (if successful) Kernel virtual address of the wired pages
+*/
+void* wire_user_memory(void* address, uint32_t length, void **page_ctx)
+{
+    void* kernel_black_addr = NULL;
+    int result = -1;
+    int page_index = 0;
+    page_ctx_t *page_context;
+    int nr_pages = 0;
+    unsigned long start_page;
+    fsl_shw_return_t status;
+
+    /* Determine the number of pages being used for this link */
+    nr_pages = (((unsigned long)(address) & ~PAGE_MASK)
+                + length + ~PAGE_MASK) >> PAGE_SHIFT;
+
+    start_page = (unsigned long)(address) & PAGE_MASK;
+
+    /* Allocate some memory to keep track of the wired user pages, so that
+     * they can be deallocated later.  The block of memory will contain both
+     * the structure and the array of pages.
+     */
+    page_context = kmalloc(sizeof(page_ctx_t)
+                           + nr_pages * sizeof(struct page *), GFP_KERNEL);
+
+    if (page_context == NULL) {
+        status = FSL_RETURN_NO_RESOURCE_S; /* no memory! */
+#ifdef DIAG_DRV_IF
+        LOG_KDIAG("kmalloc() failed.");
+#endif
+        return NULL;
+    }
+
+    /* Set the page pointer to point to the allocated region of memory */
+    page_context->local_pages = (void*)page_context + sizeof(page_ctx_t);
+
+#ifdef DIAG_DRV_IF
+    LOG_KDIAG_ARGS("page_context at: %p, local_pages at: %p",
+                   (void *)page_context,
+                   (void *)(page_context->local_pages));
+#endif
+
+    /* Wire down the pages from user space */
+    down_read(&current->mm->mmap_sem);
+    result = get_user_pages(current, current->mm,
+                            start_page, nr_pages,
+                            WRITE, 0 /* noforce */,
+                            (page_context->local_pages), NULL);
+    up_read(&current->mm->mmap_sem);
+
+    if (result < nr_pages) {
+#ifdef DIAG_DRV_IF
+        LOG_KDIAG("get_user_pages() failed.");
+#endif
+        if (result > 0) {
+            for (page_index = 0; page_index < result; page_index++)
+                page_cache_release((page_context->local_pages[page_index]));
+
+            kfree(page_context);
+        }
+        return NULL;
+    }
+
+    kernel_black_addr = page_address(page_context->local_pages[0]) +
+                        ((unsigned long)address & ~PAGE_MASK);
+
+    page_context->count = nr_pages;
+    *page_ctx = page_context;
+
+    return kernel_black_addr;
+}
+
+
+/**
+*******************************************************************************
+* Release and unmap a region of user memory.
+*
+* @param    page_ctx    Page context from wire_user_memory
+*/
+void unwire_user_memory(void** page_ctx)
+{
+    int page_index = 0;
+    struct page_ctx_t *page_context = *page_ctx;
+
+#ifdef DIAG_DRV_IF
+    LOG_KDIAG_ARGS("page_context at: %p, first page at:%p, count: %i",
+                   (void *)page_context,
+                   (void *)(page_context->local_pages),
+                   page_context->count);
+#endif
+
+    if ((page_context != NULL) && (page_context->local_pages != NULL)) {
+        for (page_index = 0; page_index < page_context->count; page_index++)
+            page_cache_release(page_context->local_pages[page_index]);
+
+        kfree(page_context);
+        *page_ctx = NULL;
+    }
+}
+
+
+/**
+*******************************************************************************
+* Map some physical memory into a users memory space
+*
+* @param    vma             Memory structure to map to
+* @param    physical_addr   Physical address of the memory to be mapped in
+* @param    size            Size of the memory to map (bytes)
+*
+* @return
+*/
+os_error_code
+map_user_memory(struct vm_area_struct *vma, uint32_t physical_addr, uint32_t size)
+{
+    os_error_code retval;
+
+    /* Map the acquired partition into the user's memory space */
+    vma->vm_end = vma->vm_start + size;
+
+    /* set cache policy to uncached so that each write of the UMID and
+     * permissions get directly to the SCC2 in order to engage it
+     * properly.  Once the permissions have been written, it may be
+     * useful to provide a service for the user to request a different
+     * cache policy
+     */
+    vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+    /* Make sure that the user cannot fork() a child which will inherit
+     * this mapping, as it creates a security hole.  Likewise, do not
+     * allow the user to 'expand' his mapping beyond this partition.
+     */
+    vma->vm_flags |= VM_IO | VM_RESERVED | VM_DONTCOPY | VM_DONTEXPAND;
+
+    retval = remap_pfn_range(vma,
+                             vma->vm_start,
+                             __phys_to_pfn(physical_addr),
+                             size,
+                             vma->vm_page_prot);
+
+    return retval;
+}
+
+
+/**
+*******************************************************************************
+* Remove some memory from a user's memory space
+*
+* @param    user_addr       Userspace address of the memory to be unmapped
+* @param    size            Size of the memory to map (bytes)
+*
+* @return
+*/
+os_error_code
+unmap_user_memory(uint32_t user_addr, uint32_t size)
+{
+    os_error_code retval;
+    struct mm_struct *mm = current->mm;
+
+    /* Unmap the memory region (see sys_munmap in mmap.c) */
+    down_write(&mm->mmap_sem);
+    retval = do_munmap(mm, (unsigned long)user_addr, size);
+    up_write(&mm->mmap_sem);
+
+    return retval;
+}
diff --git a/drivers/mxc/security/sahara2/fsl_shw_keystore.c b/drivers/mxc/security/sahara2/fsl_shw_keystore.c
new file mode 100644
index 0000000..8b3c325
--- /dev/null
+++ b/drivers/mxc/security/sahara2/fsl_shw_keystore.c
@@ -0,0 +1,765 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/**
+ * @file fsl_shw_keystore.c
+ *
+ * File which implements a default keystore policy, for use as the system
+ * keystore.
+ */
+#include "fsl_platform.h"
+#include "fsl_shw.h"
+#include "fsl_shw_keystore.h"
+
+#if defined(DIAG_DRV_IF)
+#include <diagnostic.h>
+#endif
+
+#if !defined(FSL_HAVE_SCC2) && defined(__KERNEL__)
+#include <asm/arch/mxc_scc_driver.h>
+#endif
+
+/* Define a semaphore to protect the keystore data */
+#ifdef __KERNEL__
+#define LOCK_INCLUDES os_lock_context_t context
+#define ACQUIRE_LOCK os_lock_save_context(keystore->lock, context)
+#define RELEASE_LOCK os_unlock_restore_context(keystore->lock, context);
+#else
+#define LOCK_INCLUDES
+#define ACQUIRE_LOCK
+#define RELEASE_LOCK
+#endif	/* __KERNEL__ */
+
+/**
+ * Calculates the byte offset into a word
+ *  @param   bp  The byte (char*) pointer
+ *  @return      The offset (0, 1, 2, or 3)
+ */
+#define SCC_BYTE_OFFSET(bp) ((uint32_t)(bp) % sizeof(uint32_t))
+
+/**
+ * Converts (by rounding down) a byte pointer into a word pointer
+ *  @param  bp  The byte (char*) pointer
+ *  @return     The word (uint32_t) as though it were an aligned (uint32_t*)
+ */
+#define SCC_WORD_PTR(bp) (((uint32_t)(bp)) & ~(sizeof(uint32_t)-1))
+
+/* Depending on the architecture, these functions should be defined
+ * differently.  On Platforms with SCC2, the functions use the secure
+ * partition interface and should be available in both user and kernel space.
+ * On platforms with SCC, they use the SCC keystore interface.  This is only
+ * available in kernel mode, so they should be stubbed out in user mode.
+ */
+#if defined(FSL_HAVE_SCC2) || (defined(FSL_HAVE_SCC) && defined(__KERNEL__))
+void fsl_shw_init_keystore(
+			    fsl_shw_kso_t *keystore,
+			    fsl_shw_return_t(*data_init) (fsl_shw_uco_t *user_ctx,
+							   void **user_data),
+			    void (*data_cleanup) (fsl_shw_uco_t *user_ctx,
+						   void **user_data),
+			    fsl_shw_return_t(*slot_alloc) (void *user_data,
+							    uint32_t size,
+							    uint64_t owner_id,
+							    uint32_t *slot),
+			    fsl_shw_return_t(*slot_dealloc) (void *user_data,
+							      uint64_t
+							      owner_id,
+							      uint32_t slot),
+			    fsl_shw_return_t(*slot_verify_access) (void
+								    *user_data,
+								    uint64_t
+								    owner_id,
+								    uint32_t
+								    slot),
+			    void *(*slot_get_address) (void *user_data,
+							uint32_t handle),
+			    uint32_t(*slot_get_base) (void *user_data,
+						       uint32_t handle),
+			    uint32_t(*slot_get_offset) (void *user_data,
+							 uint32_t handle),
+			    uint32_t(*slot_get_slot_size) (void *user_data,
+							    uint32_t handle))
+{
+	keystore->data_init = data_init;
+	keystore->data_cleanup = data_cleanup;
+	keystore->slot_alloc = slot_alloc;
+	keystore->slot_dealloc = slot_dealloc;
+	keystore->slot_verify_access = slot_verify_access;
+	keystore->slot_get_address = slot_get_address;
+	keystore->slot_get_base = slot_get_base;
+	keystore->slot_get_offset = slot_get_offset;
+	keystore->slot_get_slot_size = slot_get_slot_size;
+}
+void fsl_shw_init_keystore_default(fsl_shw_kso_t *keystore)
+{
+	keystore->data_init = shw_kso_init_data;
+	keystore->data_cleanup = shw_kso_cleanup_data;
+	keystore->slot_alloc = shw_slot_alloc;
+	keystore->slot_dealloc = shw_slot_dealloc;
+	keystore->slot_verify_access = shw_slot_verify_access;
+	keystore->slot_get_address = shw_slot_get_address;
+	keystore->slot_get_base = shw_slot_get_base;
+	keystore->slot_get_offset = shw_slot_get_offset;
+	keystore->slot_get_slot_size = shw_slot_get_slot_size;
+}
+
+/**
+ * Do any keystore specific initializations
+ */
+fsl_shw_return_t fsl_shw_establish_keystore(fsl_shw_uco_t *user_ctx,
+						fsl_shw_kso_t *keystore)
+{
+	if (keystore->data_init == NULL) {
+		return FSL_RETURN_ERROR_S;
+	}
+
+    /* Call the data_init function for any user setup */
+    return keystore->data_init(user_ctx, &(keystore->user_data));
+}
+void fsl_shw_release_keystore(fsl_shw_uco_t *user_ctx,
+				 fsl_shw_kso_t *keystore)
+{
+
+    /* Call the data_cleanup function for any keystore cleanup.
+	  * NOTE: The keystore doesn't have any way of telling which keys are using
+	  * it, so it is up to the user program to manage their key objects
+	  * correctly.
+	  */
+	 if ((keystore != NULL) && (keystore->data_cleanup != NULL)) {
+		keystore->data_cleanup(user_ctx, &(keystore->user_data));
+	}
+	return;
+}
+
+fsl_shw_return_t keystore_slot_alloc(fsl_shw_kso_t *keystore, uint32_t size,
+				       uint64_t owner_id, uint32_t *slot)
+{
+	LOCK_INCLUDES;
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+
+#ifdef DIAG_DRV_IF
+	    LOG_DIAG("In keystore_slot_alloc.");
+
+#endif
+	ACQUIRE_LOCK;
+	if ((keystore->slot_alloc == NULL) || (keystore->user_data == NULL)) {
+		goto out;
+	}
+
+#ifdef DIAG_DRV_IF
+	    LOG_DIAG_ARGS("key length: %i, handle: %i\n", size, *slot);
+
+#endif
+retval = keystore->slot_alloc(keystore->user_data, size, owner_id, slot);
+out:RELEASE_LOCK;
+	return retval;
+}
+
+fsl_shw_return_t keystore_slot_dealloc(fsl_shw_kso_t *keystore,
+					 uint64_t owner_id, uint32_t slot)
+{
+	LOCK_INCLUDES;
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+	ACQUIRE_LOCK;
+	if ((keystore->slot_alloc == NULL) || (keystore->user_data == NULL)) {
+		goto out;
+	}
+	retval =
+	    keystore->slot_dealloc(keystore->user_data, owner_id, slot);
+out:RELEASE_LOCK;
+	return retval;
+}
+
+fsl_shw_return_t
+keystore_load_slot(fsl_shw_kso_t * keystore, uint64_t owner_id, uint32_t slot,
+		   const uint8_t * key_data, uint32_t key_length)
+{
+
+#ifdef FSL_HAVE_SCC2
+	    LOCK_INCLUDES;
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+	uint32_t slot_size;
+	uint32_t i;
+	uint8_t * slot_location;
+	ACQUIRE_LOCK;
+	if ((keystore->slot_verify_access == NULL) ||
+	      (keystore->user_data == NULL))
+		goto out;
+	if (keystore->
+	      slot_verify_access(keystore->user_data, owner_id,
+				 slot) !=FSL_RETURN_OK_S) {
+		retval = FSL_RETURN_AUTH_FAILED_S;
+		goto out;
+	}
+	slot_size = keystore->slot_get_slot_size(keystore->user_data, slot);
+	if (key_length > slot_size) {
+		retval = FSL_RETURN_BAD_DATA_LENGTH_S;
+		goto out;
+	}
+	slot_location = keystore->slot_get_address(keystore->user_data, slot);
+	for (i = 0; i < key_length; i++) {
+		slot_location[i] = key_data[i];
+	}
+	retval = FSL_RETURN_OK_S;
+out:RELEASE_LOCK;
+	return retval;
+
+#else	/* FSL_HAVE_SCC2 */
+	fsl_shw_return_t retval;
+	scc_return_t scc_ret;
+	scc_ret =
+	    scc_load_slot(owner_id, slot, (uint8_t *) key_data, key_length);
+	switch (scc_ret) {
+	case SCC_RET_OK:
+		retval = FSL_RETURN_OK_S;
+		break;
+	case SCC_RET_VERIFICATION_FAILED:
+		retval = FSL_RETURN_AUTH_FAILED_S;
+		break;
+	case SCC_RET_INSUFFICIENT_SPACE:
+		retval = FSL_RETURN_BAD_DATA_LENGTH_S;
+		break;
+	default:
+		retval = FSL_RETURN_ERROR_S;
+	}
+	return retval;
+
+#endif	/* FSL_HAVE_SCC2 */
+}
+
+fsl_shw_return_t
+keystore_slot_encrypt(fsl_shw_uco_t *user_ctx, fsl_shw_kso_t *keystore,
+		      uint64_t owner_id, uint32_t slot, uint32_t length,
+		      uint8_t *destination)
+{
+
+#ifdef FSL_HAVE_SCC2
+	LOCK_INCLUDES;
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+	uint32_t slot_length;
+	uint32_t IV[4];
+	uint32_t * iv_ptr = (uint32_t *) & (owner_id);
+
+	/* Build the IV */
+	IV[0] = iv_ptr[0];
+	IV[1] = iv_ptr[1];
+	IV[2] = 0;
+	IV[3] = 0;
+	ACQUIRE_LOCK;
+
+	/* Ensure that the data will fit in the key slot */
+	slot_length =
+	    keystore->slot_get_slot_size(keystore->user_data, slot);
+	if (length > slot_length) {
+		goto out;
+	}
+
+	  /* Call scc encrypt function to encrypt the data. */
+	    retval = do_scc_encrypt_region(user_ctx,
+					   (void *)keystore->
+					   slot_get_base(keystore->user_data,
+							 slot),
+					   keystore->slot_get_offset(keystore->
+								      user_data,
+								      slot),
+					   length, destination, IV,
+					   FSL_SHW_CYPHER_MODE_CBC);
+	goto out;
+out:RELEASE_LOCK;
+	return retval;
+
+#else
+	scc_return_t retval;
+	retval = scc_encrypt_slot(owner_id, slot, length, destination);
+	if (retval == SCC_RET_OK)
+		return FSL_RETURN_OK_S;
+	return FSL_RETURN_ERROR_S;
+
+#endif	/* FSL_HAVE_SCC2 */
+}
+
+fsl_shw_return_t
+keystore_slot_decrypt(fsl_shw_uco_t *user_ctx, fsl_shw_kso_t *keystore,
+		      uint64_t owner_id, uint32_t slot, uint32_t length,
+		      const uint8_t *source)
+{
+
+#ifdef FSL_HAVE_SCC2
+	LOCK_INCLUDES;
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+	uint32_t slot_length;
+	uint32_t IV[4];
+	uint32_t *iv_ptr = (uint32_t *) & (owner_id);
+
+    /* Build the IV */
+    IV[0] = iv_ptr[0];
+	IV[1] = iv_ptr[1];
+	IV[2] = 0;
+	IV[3] = 0;
+	ACQUIRE_LOCK;
+
+	/* Call scc decrypt function to decrypt the data. */
+
+	/* Ensure that the data will fit in the key slot */
+	    slot_length =
+	    keystore->slot_get_slot_size(keystore->user_data, slot);
+	if (length > slot_length)
+		goto out;
+
+	/* Call scc decrypt function to encrypt the data. */
+	    retval = do_scc_decrypt_region(user_ctx,
+					   (void *)keystore->
+					   slot_get_base(keystore->user_data,
+							 slot),
+					   keystore->slot_get_offset(keystore->
+								      user_data,
+								      slot),
+					   length, source, IV,
+					   FSL_SHW_CYPHER_MODE_CBC);
+	goto out;
+out:RELEASE_LOCK;
+	return retval;
+
+#else
+	scc_return_t retval;
+	retval = scc_decrypt_slot(owner_id, slot, length, source);
+	if (retval == SCC_RET_OK)
+		return FSL_RETURN_OK_S;
+	return FSL_RETURN_ERROR_S;
+
+#endif	/* FSL_HAVE_SCC2 */
+}
+
+#else	/* SCC in userspace */
+void fsl_shw_init_keystore(
+			    fsl_shw_kso_t *keystore,
+			    fsl_shw_return_t(*data_init) (fsl_shw_uco_t *user_ctx,
+							   void **user_data),
+			    void (*data_cleanup) (fsl_shw_uco_t *user_ctx,
+						   void **user_data),
+			    fsl_shw_return_t(*slot_alloc) (void *user_data,
+							    uint32_t size,
+							    uint64_t owner_id,
+							    uint32_t *slot),
+			    fsl_shw_return_t(*slot_dealloc) (void *user_data,
+							      uint64_t
+							      owner_id,
+							      uint32_t slot),
+			    fsl_shw_return_t(*slot_verify_access) (void
+								    *user_data,
+								    uint64_t
+								    owner_id,
+								    uint32_t
+								    slot),
+			    void *(*slot_get_address) (void *user_data,
+							uint32_t handle),
+			    uint32_t(*slot_get_base) (void *user_data,
+						       uint32_t handle),
+			    uint32_t(*slot_get_offset) (void *user_data,
+							 uint32_t handle),
+			    uint32_t(*slot_get_slot_size) (void *user_data,
+							    uint32_t handle))
+{
+	(void)keystore;
+	(void)data_init;
+	(void)data_cleanup;
+	(void)slot_alloc;
+	(void)slot_dealloc;
+	(void)slot_verify_access;
+	(void)slot_get_address;
+	(void)slot_get_base;
+	(void)slot_get_offset;
+	(void)slot_get_slot_size;
+}
+
+void fsl_shw_init_keystore_default(fsl_shw_kso_t * keystore)
+{
+	(void)keystore;
+}
+fsl_shw_return_t fsl_shw_establish_keystore(fsl_shw_uco_t *user_ctx,
+						 fsl_shw_kso_t *keystore)
+{
+	(void)user_ctx;
+	(void)keystore;
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+void fsl_shw_release_keystore(fsl_shw_uco_t *user_ctx,
+				fsl_shw_kso_t *keystore)
+{
+	(void)user_ctx;
+	(void)keystore;
+	return;
+}
+
+fsl_shw_return_t keystore_slot_alloc(fsl_shw_kso_t *keystore, uint32_t size,
+					uint64_t owner_id, uint32_t *slot)
+{
+	(void)keystore;
+	(void)size;
+	(void)owner_id;
+	(void)slot;
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t keystore_slot_dealloc(fsl_shw_kso_t *keystore,
+					 uint64_t owner_id, uint32_t slot)
+{
+	(void)keystore;
+	(void)owner_id;
+	(void)slot;
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t
+keystore_load_slot(fsl_shw_kso_t *keystore, uint64_t owner_id, uint32_t slot,
+		   const uint8_t *key_data, uint32_t key_length)
+{
+	(void)keystore;
+	(void)owner_id;
+	(void)slot;
+	(void)key_data;
+	(void)key_length;
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t
+keystore_slot_decrypt(fsl_shw_uco_t *user_ctx, fsl_shw_kso_t *keystore,
+		      uint64_t owner_id, uint32_t slot, uint32_t length,
+		      const uint8_t *source)
+{
+	(void)user_ctx;
+	(void)keystore;
+	(void)owner_id;
+	(void)slot;
+	(void)length;
+	(void)source;
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t
+keystore_slot_encrypt(fsl_shw_uco_t *user_ctx, fsl_shw_kso_t *keystore,
+		      uint64_t owner_id, uint32_t slot, uint32_t length,
+		      uint8_t *destination)
+{
+	(void)user_ctx;
+	(void)keystore;
+	(void)owner_id;
+	(void)slot;
+	(void)length;
+	(void)destination;
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+
+#endif	/* FSL_HAVE_SCC2 */
+
+/***** Default keystore implementation **************************************/
+
+#ifdef FSL_HAVE_SCC2
+    fsl_shw_return_t shw_kso_init_data(fsl_shw_uco_t *user_ctx,
+					void **user_data)
+{
+	int retval = FSL_RETURN_ERROR_S;
+	keystore_data_t *keystore_data = NULL;
+	fsl_shw_pco_t *capabilities = fsl_shw_get_capabilities(user_ctx);
+	uint32_t partition_size;
+	uint32_t slot_count;
+	uint32_t keystore_data_size;
+	uint8_t UMID[16] = {
+	0x42, 0, 0, 0, 0x43, 0, 0, 0, 0x19, 0, 0, 0, 0x59, 0, 0, 0};
+	uint32_t permissions =
+	    FSL_PERM_TH_R | FSL_PERM_TH_W | FSL_PERM_HD_R | FSL_PERM_HD_W |
+	    FSL_PERM_HD_X;
+
+	/* Look up the size of a partition to see how big to make the keystore */
+	partition_size = fsl_shw_pco_get_spo_size_bytes(capabilities);
+
+	/* Calculate the required size of the keystore data structure, based on the
+	  * number of keys that can fit in the partition.
+	  */
+	slot_count = partition_size / KEYSTORE_SLOT_SIZE;
+	keystore_data_size =
+	    sizeof(keystore_data_t) +
+	    slot_count * sizeof(keystore_data_slot_info_t);
+
+#ifdef __KERNEL__
+	keystore_data = os_alloc_memory(keystore_data_size, GFP_KERNEL);
+
+#else
+	keystore_data = malloc(keystore_data_size);
+
+#endif
+	if (keystore_data == NULL) {
+		retval = FSL_RETURN_NO_RESOURCE_S;
+		goto out;
+	}
+
+    /* Clear the memory (effectively clear all key assignments) */
+    memset(keystore_data, 0, keystore_data_size);
+
+   /* Place the slot information structure directly after the keystore data
+   	* structure.
+	*/
+	    keystore_data->slot =
+	    (keystore_data_slot_info_t *) (keystore_data + 1);
+	keystore_data->slot_count = slot_count;
+
+	/* Retrieve a secure partition to put the keystore in. */
+	keystore_data->base_address =
+	    fsl_shw_smalloc(user_ctx, partition_size, UMID, permissions);
+	if (keystore_data->base_address == NULL) {
+		retval = FSL_RETURN_NO_RESOURCE_S;
+		goto out;
+	}
+	*user_data = keystore_data;
+	retval = FSL_RETURN_OK_S;
+out:if (retval != FSL_RETURN_OK_S) {
+		if (keystore_data != NULL) {
+			if (keystore_data->base_address != NULL)
+				fsl_shw_sfree(NULL,
+					       keystore_data->base_address);
+
+#ifdef __KERNEL__
+			    os_free_memory(keystore_data);
+
+#else
+			    free(keystore_data);
+
+#endif
+		}
+	}
+	return retval;
+}
+void shw_kso_cleanup_data(fsl_shw_uco_t *user_ctx, void **user_data)
+{
+	if (user_data != NULL) {
+		keystore_data_t * keystore_data =
+		    (keystore_data_t *) (*user_data);
+		fsl_shw_sfree(user_ctx, keystore_data->base_address);
+
+#ifdef __KERNEL__
+		    os_free_memory(*user_data);
+
+#else
+		    free(*user_data);
+
+#endif
+	}
+	return;
+}
+
+fsl_shw_return_t shw_slot_verify_access(void *user_data, uint64_t owner_id,
+					  uint32_t slot)
+{
+	keystore_data_t * data = user_data;
+	if (data->slot[slot].owner == owner_id) {
+		return FSL_RETURN_OK_S;
+	} else {
+
+#ifdef DIAG_DRV_IF
+		    LOG_DIAG_ARGS("Access to slot %i fails.\n", slot);
+
+#endif
+		    return FSL_RETURN_AUTH_FAILED_S;
+	}
+}
+
+fsl_shw_return_t shw_slot_alloc(void *user_data, uint32_t size,
+				   uint64_t owner_id, uint32_t *slot)
+{
+	keystore_data_t *data = user_data;
+	uint32_t i;
+	if (size > KEYSTORE_SLOT_SIZE)
+		return FSL_RETURN_BAD_KEY_LENGTH_S;
+	for (i = 0; i < data->slot_count; i++) {
+		if (data->slot[i].allocated == 0) {
+			data->slot[i].allocated = 1;
+			data->slot[i].owner = owner_id;
+			(*slot) = i;
+
+#ifdef DIAG_DRV_IF
+			    LOG_DIAG_ARGS("Keystore: allocated slot %i. Slot "
+					  "address: %p\n",
+					  (*slot),
+					  data->base_address +
+					  (*slot) * KEYSTORE_SLOT_SIZE);
+
+#endif
+			    return FSL_RETURN_OK_S;
+		}
+	}
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t shw_slot_dealloc(void *user_data, uint64_t owner_id,
+				    uint32_t slot)
+{
+	keystore_data_t * data = user_data;
+	(void)owner_id;
+	(void)slot;
+	if (slot >= data->slot_count)
+		return FSL_RETURN_ERROR_S;
+	if (data->slot[slot].allocated == 1) {
+		data->slot[slot].allocated = 0;
+		return FSL_RETURN_OK_S;
+	}
+	return FSL_RETURN_ERROR_S;
+}
+
+void *shw_slot_get_address(void *user_data, uint32_t slot)
+{
+	keystore_data_t * data = user_data;
+	if (slot >= data->slot_count)
+		return NULL;
+	return data->base_address + slot * KEYSTORE_SLOT_SIZE;
+}
+
+uint32_t shw_slot_get_base(void *user_data, uint32_t slot)
+{
+	keystore_data_t * data = user_data;
+
+	/* There could potentially be more than one secure partition object
+	  * associated with this keystore.  For now, there is just one.
+	  */
+	(void)slot;
+	return (uint32_t) (data->base_address);
+}
+
+uint32_t shw_slot_get_offset(void *user_data, uint32_t slot)
+{
+	keystore_data_t *data = user_data;
+	if (slot >= data->slot_count)
+		return FSL_RETURN_ERROR_S;
+	return (slot * KEYSTORE_SLOT_SIZE);
+}
+
+uint32_t shw_slot_get_slot_size(void *user_data, uint32_t slot)
+{
+	(void)user_data;
+	(void)slot;
+
+	/* All slots are the same size in the default implementation */
+	return KEYSTORE_SLOT_SIZE;
+}
+
+#else	/* FSL_HAVE_SCC2 */
+
+#ifdef __KERNEL__
+    fsl_shw_return_t shw_kso_init_data(fsl_shw_uco_t *user_ctx,
+					void **user_data)
+{
+
+   /* The SCC does its own initialization.  All that needs to be done here is
+   	* make sure an SCC exists.
+	*/
+	*user_data = (void *)0xFEEDFEED;
+	return FSL_RETURN_OK_S;
+}
+void shw_kso_cleanup_data(fsl_shw_uco_t *user_ctx, void **user_data)
+{
+
+    /* The SCC does its own cleanup. */
+	*user_data = NULL;
+	return;
+}
+
+fsl_shw_return_t shw_slot_verify_access(void *user_data, uint64_t owner_id,
+					  uint32_t slot)
+{
+
+	/* Zero is used for the size because the newer interface does bounds
+	  * checking later.
+	  */
+	scc_return_t retval;
+	retval = scc_verify_slot_access(owner_id, slot, 0);
+	if (retval == SCC_RET_OK) {
+		return FSL_RETURN_OK_S;
+	}
+	return FSL_RETURN_AUTH_FAILED_S;
+}
+
+fsl_shw_return_t shw_slot_alloc(void *user_data, uint32_t size,
+				   uint64_t owner_id, uint32_t *slot)
+{
+	scc_return_t retval;
+
+#ifdef DIAG_DRV_IF
+	    LOG_DIAG_ARGS("key length: %i, handle: %i\n", size, *slot);
+
+#endif
+	retval = scc_alloc_slot(size, owner_id, slot);
+	if (retval == SCC_RET_OK)
+		return FSL_RETURN_OK_S;
+
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t shw_slot_dealloc(void *user_data, uint64_t owner_id,
+				    uint32_t slot)
+{
+	scc_return_t retval;
+	retval = scc_dealloc_slot(owner_id, slot);
+	if (retval == SCC_RET_OK)
+		return FSL_RETURN_OK_S;
+
+	return FSL_RETURN_ERROR_S;
+}
+void *shw_slot_get_address(void *user_data, uint32_t slot)
+{
+	uint64_t owner_id = *((uint64_t *) user_data);
+	uint32_t address;
+	uint32_t value_size_bytes;
+	uint32_t slot_size_bytes;
+	scc_return_t scc_ret;
+	scc_ret =
+	    scc_get_slot_info(owner_id, slot, &address, &value_size_bytes,
+			      &slot_size_bytes);
+	if (scc_ret == SCC_RET_OK) {
+		return (void *)address;
+	}
+	return NULL;
+}
+
+uint32_t shw_slot_get_base(void *user_data, uint32_t slot)
+{
+	return 0;
+}
+
+uint32_t shw_slot_get_offset(void *user_data, uint32_t slot)
+{
+	return 0;
+}
+
+
+/* Return the size of the key slot, in octets */
+uint32_t shw_slot_get_slot_size(void *user_data, uint32_t slot)
+{
+	uint64_t owner_id = *((uint64_t *) user_data);
+	uint32_t address;
+	uint32_t value_size_bytes;
+	uint32_t slot_size_bytes;
+	scc_return_t scc_ret;
+	scc_ret =
+	    scc_get_slot_info(owner_id, slot, &address, &value_size_bytes,
+			      &slot_size_bytes);
+	if (scc_ret == SCC_RET_OK)
+		return slot_size_bytes;
+	return 0;
+}
+
+
+#endif	/* __KERNEL__ */
+
+#endif	/* FSL_HAVE_SCC2 */
+
+/*****************************************************************************/
diff --git a/drivers/mxc/security/sahara2/include/fsl_platform.h b/drivers/mxc/security/sahara2/include/fsl_platform.h
index 1673b8c..d474edb 100644
--- a/drivers/mxc/security/sahara2/include/fsl_platform.h
+++ b/drivers/mxc/security/sahara2/include/fsl_platform.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -48,6 +48,12 @@
 #define FSL_HAVE_SCC
 #define USE_OLD_PTRS
 
+#elif defined(CONFIG_ARCH_MX37)
+
+#define FSL_HAVE_SCC2
+#define FSL_HAVE_RNGC
+#define FSL_HAVE_RTIC2
+
 #elif defined(CONFIG_ARCH_MXC91131)
 
 #define FSL_HAVE_SCC
diff --git a/drivers/mxc/security/sahara2/include/fsl_shw.h b/drivers/mxc/security/sahara2/include/fsl_shw.h
index ef3311d..4802571 100644
--- a/drivers/mxc/security/sahara2/include/fsl_shw.h
+++ b/drivers/mxc/security/sahara2/include/fsl_shw.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -340,1625 +340,2091 @@
  *
  * These flags describe how the @ref opfuns will operate.
  */
-typedef enum fsl_shw_user_ctx_flags {
-	FSL_UCO_BLOCKING_MODE,	/*!< API will block the caller until operation
-				   completes.  The result will be available in the
-				   return code.  If this is not set, user will have
-				   to get results using #fsl_shw_get_results(). */
-	FSL_UCO_CALLBACK_MODE,	/*!< User wants callback (at the function specified
-				   with #fsl_shw_uco_set_callback()) when the
-				   operation completes.  This flag is valid only if
-				   #FSL_UCO_BLOCKING_MODE is not set. */
-} fsl_shw_user_ctx_flags_t;
-
-/*!
- * Return code for FSL_SHW library.
- *
- * These codes may be returned from a function call.  In non-blocking mode,
- * they will appear as the status in a Result Object.
- */
-typedef enum fsl_shw_return {
-	FSL_RETURN_OK_S = 0,	/*!< No error.  As a function return code in
-				   Non-blocking mode, this may simply mean that
-				   the operation was accepted for eventual
-				   execution. */
-	FSL_RETURN_ERROR_S,	/*!< Failure for non-specific reason. */
-	FSL_RETURN_NO_RESOURCE_S,	/*!< Operation failed because some resource was
-					   not able to be allocated. */
-	FSL_RETURN_BAD_ALGORITHM_S,	/*!< Crypto algorithm unrecognized or
-					   improper. */
-	FSL_RETURN_BAD_MODE_S,	/*!< Crypto mode unrecognized or improper. */
-	FSL_RETURN_BAD_FLAG_S,	/*!< Flag setting unrecognized or
-				   inconsistent. */
-	FSL_RETURN_BAD_KEY_LENGTH_S,	/*!< Improper or unsupported key length for
-					   algorithm. */
-	FSL_RETURN_BAD_KEY_PARITY_S,	/*!< Improper parity in a (DES, TDES) key. */
-	FSL_RETURN_BAD_DATA_LENGTH_S,	/*!< Improper or unsupported data length for
-					   algorithm or internal buffer. */
-	FSL_RETURN_AUTH_FAILED_S,	/*!< Authentication failed in
-					   authenticate-decrypt operation. */
-	FSL_RETURN_MEMORY_ERROR_S,	/*!< A memory error occurred. */
-	FSL_RETURN_INTERNAL_ERROR_S	/*!< An error internal to the hardware
-					   occurred. */
-} fsl_shw_return_t;
-
-/*!
- * Algorithm Identifier.
- *
- * Selection of algorithm will determine how large the block size of the
- * algorithm is.   Context size is the same length unless otherwise specified.
- * Selection of algorithm also affects the allowable key length.
- */
-typedef enum fsl_shw_key_alg {
-	FSL_KEY_ALG_HMAC,	/*!< Key will be used to perform an HMAC.  Key
-				   size is 1 to 64 octets.  Block size is 64
-				   octets. */
-	FSL_KEY_ALG_AES,	/*!< Advanced Encryption Standard (Rijndael).
-				   Block size is 16 octets.  Key size is 16
-				   octets.  (The single choice of key size is a
-				   Sahara platform limitation.) */
-	FSL_KEY_ALG_DES,	/*!< Data Encryption Standard.  Block size is
-				   8 octets.  Key size is 8 octets. */
-	FSL_KEY_ALG_TDES,	/*!< 2- or 3-key Triple DES.  Block size is 8
-				   octets.  Key size is 16 octets for 2-key
-				   Triple DES, and 24 octets for 3-key. */
-	FSL_KEY_ALG_ARC4	/*!< ARC4.  No block size.  Context size is 259
-				   octets.  Allowed key size is 1-16 octets.
-				   (The choices for key size are a Sahara
-				   platform limitation.) */
-} fsl_shw_key_alg_t;
-
-/*!
- * Mode selector for Symmetric Ciphers.
- *
- * The selection of mode determines how a cryptographic algorithm will be
- * used to process the plaintext or ciphertext.
- *
- * For all modes which are run block-by-block (that is, all but
- * #FSL_SYM_MODE_STREAM), any partial operations must be performed on a text
- * length which is multiple of the block size.  Except for #FSL_SYM_MODE_CTR,
- * these block-by-block algorithms must also be passed a total number of octets
- * which is a multiple of the block size.
- *
- * In modes which require that the total number of octets of data be a multiple
- * of the block size (#FSL_SYM_MODE_ECB and #FSL_SYM_MODE_CBC), and the user
- * has a total number of octets which are not a multiple of the block size, the
- * user must perform any necessary padding to get to the correct data length.
- */
-typedef enum fsl_shw_sym_mode {
-	/*!
-	 * Stream.  There is no associated block size.  Any request to process data
-	 * may be of any length.  This mode is only for ARC4 operations, and is
-	 * also the only mode used for ARC4.
+	typedef enum fsl_shw_user_ctx_flags_t
+	{
+		/**
+		 * API will block the caller until operation completes.  The result will be
+		 * available in the return code.  If this is not set, user will have to get
+		 * results using #fsl_shw_get_results().
+		 */
+		FSL_UCO_BLOCKING_MODE,
+		/**
+		 * User wants callback (at the function specified with
+		 * #fsl_shw_uco_set_callback()) when the operation completes.  This flag is
+		 * valid only if #FSL_UCO_BLOCKING_MODE is not set.
+		 */
+		FSL_UCO_CALLBACK_MODE,
+		/** Do not free descriptor chain after driver (adaptor) finishes */
+		FSL_UCO_SAVE_DESC_CHAIN,
+		/**
+		 * User has made at least one request with callbacks requested, so API is
+		 * ready to handle others.
+		 */
+		FSL_UCO_CALLBACK_SETUP_COMPLETE,
+		/**
+		 * (virtual) pointer to descriptor chain is completely linked with physical
+		 * (DMA) addresses, ready for the hardware.  This flag should not be used
+		 * by FSL SHW API programs.
+		 */
+		FSL_UCO_CHAIN_PREPHYSICALIZED,
+		/**
+		 * The user has changed the context but the changes have not been copied to
+		 * the kernel driver.
+		 */
+		FSL_UCO_CONTEXT_CHANGED,
+		/** Internal Use.  This context belongs to a user-mode API user. */
+		FSL_UCO_USERMODE_USER,
+	} fsl_shw_user_ctx_flags_t;
+	
+	
+	/**
+	 * Return code for FSL_SHW library.
+	 *
+	 * These codes may be returned from a function call.  In non-blocking mode,
+	 * they will appear as the status in a Result Object.
 	 */
-	FSL_SYM_MODE_STREAM,
-
-	/*!
-	 * Electronic Codebook.  Each block of data is encrypted/decrypted.  The
-	 * length of the data stream must be a multiple of the block size.  This
-	 * mode may be used for DES, 3DES, and AES.  The block size is determined
-	 * by the algorithm.
-	 */
-	FSL_SYM_MODE_ECB,
-	/*!
-	 * Cipher-Block Chaining.  Each block of data is encrypted/decrypted and
-	 * then "chained" with the previous block by an XOR function.  Requires
-	 * context to start the XOR (previous block).  This mode may be used for
-	 * DES, 3DES, and AES.  The block size is determined by the algorithm.
-	 */
-	FSL_SYM_MODE_CBC,
-	/*!
-	 * Counter.  The counter is encrypted, then XORed with a block of data.
-	 * The counter is then incremented (using modulus arithmetic) for the next
-	 * block. The final operation may be non-multiple of block size.  This mode
-	 * may be used for AES.  The block size is determined by the algorithm.
-	 */
-	FSL_SYM_MODE_CTR,
-} fsl_shw_sym_mode_t;
-
-/*!
- * Algorithm selector for Cryptographic Hash functions.
- *
- * Selection of algorithm determines how large the context and digest will be.
- * Context is the same size as the digest (resulting hash), unless otherwise
- * specified.
- */
-typedef enum fsl_shw_hash_alg {
-	FSL_HASH_ALG_MD5,	/*!< MD5 algorithm.  Digest is 16 octets. */
-	FSL_HASH_ALG_SHA1,	/*!< SHA-1 (aka SHA or SHA-160) algorithm.
-				   Digest is 20 octets. */
-	FSL_HASH_ALG_SHA224,	/*!< SHA-224 algorithm.  Digest is 28 octets,
-				   though context is 32 octets. */
-	FSL_HASH_ALG_SHA256	/*!< SHA-256 algorithm.  Digest is 32
-				   octets. */
-} fsl_shw_hash_alg_t;
-
-/*!
- * The type of Authentication-Cipher function which will be performed.
- */
-typedef enum fsl_shw_acc_mode {
-	/*!
-	 * CBC-MAC for Counter.  Requires context and modulus.  Final operation may
-	 * be non-multiple of block size.  This mode may be used for AES.
+	typedef enum fsl_shw_return_t
+	{
+		/**
+		 * No error.  As a function return code in Non-blocking mode, this may
+		 * simply mean that the operation was accepted for eventual execution.
+		 */
+		FSL_RETURN_OK_S = 0,
+		/** Failure for non-specific reason. */
+		FSL_RETURN_ERROR_S,
+	   /**
+		* Operation failed because some resource was not able to be allocated.
+		*/
+		FSL_RETURN_NO_RESOURCE_S,
+		/** Crypto algorithm unrecognized or improper. */
+		FSL_RETURN_BAD_ALGORITHM_S,
+		/** Crypto mode unrecognized or improper. */
+		FSL_RETURN_BAD_MODE_S,
+		/** Flag setting unrecognized or inconsistent. */
+		FSL_RETURN_BAD_FLAG_S,
+		/** Improper or unsupported key length for algorithm. */
+		FSL_RETURN_BAD_KEY_LENGTH_S,
+		/** Improper parity in a (DES, TDES) key. */
+		FSL_RETURN_BAD_KEY_PARITY_S,
+		/**
+		 * Improper or unsupported data length for algorithm or internal buffer.
+		 */
+		FSL_RETURN_BAD_DATA_LENGTH_S,
+		/** Authentication / Integrity Check code check failed. */
+		FSL_RETURN_AUTH_FAILED_S,
+		/** A memory error occurred. */
+		FSL_RETURN_MEMORY_ERROR_S,
+		/** An error internal to the hardware occurred. */
+		FSL_RETURN_INTERNAL_ERROR_S,
+		/** ECC detected Point at Infinity */
+		FSL_RETURN_POINT_AT_INFINITY_S,
+		/** ECC detected No Point at Infinity */
+		FSL_RETURN_POINT_NOT_AT_INFINITY_S,
+		/** GCD is One */
+		FSL_RETURN_GCD_IS_ONE_S,
+		/** GCD is not One */
+		FSL_RETURN_GCD_IS_NOT_ONE_S,
+		/** Candidate is Prime */
+		FSL_RETURN_PRIME_S,
+		/** Candidate is not Prime */
+		FSL_RETURN_NOT_PRIME_S,
+		/** N register loaded improperly with even value */
+		FSL_RETURN_EVEN_MODULUS_ERROR_S,
+		/** Divisor is zero. */
+		FSL_RETURN_DIVIDE_BY_ZERO_ERROR_S,
+		/** Bad Exponent or Scalar value for Point Multiply */
+		FSL_RETURN_BAD_EXPONENT_ERROR_S,
+		/** RNG hardware problem. */
+		FSL_RETURN_OSCILLATOR_ERROR_S,
+		/** RNG hardware problem. */
+		FSL_RETURN_STATISTICS_ERROR_S,
+	} fsl_shw_return_t;
+	
+	
+	/**
+	 * Algorithm Identifier.
+	 *
+	 * Selection of algorithm will determine how large the block size of the
+	 * algorithm is.   Context size is the same length unless otherwise specified.
+	 * Selection of algorithm also affects the allowable key length.
+	 */
+	typedef enum fsl_shw_key_alg_t
+	{
+		FSL_KEY_ALG_HMAC,			/**< Key will be used to perform an HMAC.  Key
+									   size is 1 to 64 octets.	Block size is 64
+									   octets. */
+		FSL_KEY_ALG_AES,			/**< Advanced Encryption Standard (Rijndael).
+									   Block size is 16 octets.  Key size is 16
+									   octets.	(The single choice of key size is a
+									   Sahara platform limitation.) */
+		FSL_KEY_ALG_DES,			/**< Data Encryption Standard.	Block size is
+									   8 octets.  Key size is 8 octets. */
+		FSL_KEY_ALG_TDES,			/**< 2- or 3-key Triple DES.  Block size is 8
+									   octets.	Key size is 16 octets for 2-key
+									   Triple DES, and 24 octets for 3-key. */
+		FSL_KEY_ALG_ARC4			/**< ARC4.	No block size.	Context size is 259
+									   octets.	Allowed key size is 1-16 octets.
+									   (The choices for key size are a Sahara
+									   platform limitation.) */
+	} fsl_shw_key_alg_t;
+	
+	
+	/**
+	 * Mode selector for Symmetric Ciphers.
+	 *
+	 * The selection of mode determines how a cryptographic algorithm will be
+	 * used to process the plaintext or ciphertext.
+	 *
+	 * For all modes which are run block-by-block (that is, all but
+	 * #FSL_SYM_MODE_STREAM), any partial operations must be performed on a text
+	 * length which is multiple of the block size.	Except for #FSL_SYM_MODE_CTR,
+	 * these block-by-block algorithms must also be passed a total number of octets
+	 * which is a multiple of the block size.
+	 *
+	 * In modes which require that the total number of octets of data be a multiple
+	 * of the block size (#FSL_SYM_MODE_ECB and #FSL_SYM_MODE_CBC), and the user
+	 * has a total number of octets which are not a multiple of the block size, the
+	 * user must perform any necessary padding to get to the correct data length.
+	 */
+	typedef enum fsl_shw_sym_mode_t
+	{
+		/**
+		 * Stream.	There is no associated block size.	Any request to process data
+		 * may be of any length.  This mode is only for ARC4 operations, and is
+		 * also the only mode used for ARC4.
+		 */
+		FSL_SYM_MODE_STREAM,
+	
+		/**
+		 * Electronic Codebook.  Each block of data is encrypted/decrypted.  The
+		 * length of the data stream must be a multiple of the block size.	This
+		 * mode may be used for DES, 3DES, and AES.  The block size is determined
+		 * by the algorithm.
+		 */
+		FSL_SYM_MODE_ECB,
+		/**
+		 * Cipher-Block Chaining.  Each block of data is encrypted/decrypted and
+		 * then "chained" with the previous block by an XOR function.  Requires
+		 * context to start the XOR (previous block).  This mode may be used for
+		 * DES, 3DES, and AES.	The block size is determined by the algorithm.
+		 */
+		FSL_SYM_MODE_CBC,
+		/**
+		 * Counter.  The counter is encrypted, then XORed with a block of data.
+		 * The counter is then incremented (using modulus arithmetic) for the next
+		 * block. The final operation may be non-multiple of block size.  This mode
+		 * may be used for AES.  The block size is determined by the algorithm.
+		 */
+		FSL_SYM_MODE_CTR,
+	} fsl_shw_sym_mode_t;
+	
+	
+	/**
+	 * Algorithm selector for Cryptographic Hash functions.
+	 *
+	 * Selection of algorithm determines how large the context and digest will be.
+	 * Context is the same size as the digest (resulting hash), unless otherwise
+	 * specified.
+	 */
+	typedef enum fsl_shw_hash_alg_t
+	{
+		FSL_HASH_ALG_MD5,			/**< MD5 algorithm.  Digest is 16 octets. */
+		FSL_HASH_ALG_SHA1,			/**< SHA-1 (aka SHA or SHA-160) algorithm.
+									   Digest is 20 octets. */
+		FSL_HASH_ALG_SHA224,		/**< SHA-224 algorithm.  Digest is 28 octets,
+									   though context is 32 octets. */
+		FSL_HASH_ALG_SHA256 		/**< SHA-256 algorithm.  Digest is 32
+									   octets. */
+	} fsl_shw_hash_alg_t;
+	
+	
+	/**
+	 * The type of Authentication-Cipher function which will be performed.
+	 */
+	typedef enum fsl_shw_acc_mode_t
+	{
+		/**
+		 * CBC-MAC for Counter.  Requires context and modulus.	Final operation may
+		 * be non-multiple of block size.  This mode may be used for AES.
+		 */
+		FSL_ACC_MODE_CCM,
+		/**
+		 * SSL mode.  Not supported.  Combines HMAC and encrypt (or decrypt).
+		 * Needs one key object for encryption, another for the HMAC.  The usual
+		 * hashing and symmetric encryption algorithms are supported.
+		 */
+		FSL_ACC_MODE_SSL,
+	} fsl_shw_acc_mode_t;
+	
+	
+	/**
+	 * The operation which controls the behavior of #fsl_shw_establish_key().
+	 *
+	 * These values are passed to #fsl_shw_establish_key().
+	 */
+	typedef enum fsl_shw_key_wrap_t
+	{
+		FSL_KEY_WRAP_CREATE,		/**< Generate a key from random values. */
+		FSL_KEY_WRAP_ACCEPT,		/**< Use the provided clear key. */
+		FSL_KEY_WRAP_UNWRAP 		/**< Unwrap a previously wrapped key. */
+	} fsl_shw_key_wrap_t;
+	
+	
+	/* REQ-S2LRD-PINTFC-COA-HCO-001 */
+	/**
+	 * Flags which control a Hash operation.
+	 *
+	 *	These may be combined by ORing them together.  See #fsl_shw_hco_set_flags()
+	 * and #fsl_shw_hco_clear_flags().
+	 */
+	typedef enum fsl_shw_hash_ctx_flags_t
+	{
+		FSL_HASH_FLAGS_INIT = 1,		/**< Context is empty.	Hash is started
+										   from scratch, with a message-processed
+										   count of zero. */
+		FSL_HASH_FLAGS_SAVE = 2,		/**< Retrieve context from hardware after
+										   hashing.  If used with the
+                                       #FSL_HASH_FLAGS_FINALIZE flag, the final
+										   digest value will be saved in the
+										   object. */
+		FSL_HASH_FLAGS_LOAD = 4,		/**< Place context into hardware before
+										   hashing. */
+		FSL_HASH_FLAGS_FINALIZE = 8,	/**< PAD message and perform final digest
+										   operation.  If user message is
+										   pre-padded, this flag should not be
+										   used. */
+	} fsl_shw_hash_ctx_flags_t;
+	
+	
+	/**
+	 * Flags which control an HMAC operation.
+	 *
+	 * These may be combined by ORing them together.  See #fsl_shw_hmco_set_flags()
+	 * and #fsl_shw_hmco_clear_flags().
+	 */
+	typedef enum fsl_shw_hmac_ctx_flags_t
+	{
+		FSL_HMAC_FLAGS_INIT = 1,		/**< Message context is empty.	HMAC is
+										   started from scratch (with key) or from
+										   precompute of inner hash, depending on
+										   whether
+                                       #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT is
+										   set. */
+		FSL_HMAC_FLAGS_SAVE = 2,		/**< Retrieve ongoing context from hardware
+										   after hashing.  If used with the
+                                       #FSL_HMAC_FLAGS_FINALIZE flag, the final
+										   digest value (HMAC) will be saved in the
+										   object. */
+		FSL_HMAC_FLAGS_LOAD = 4,		/**< Place ongoing context into hardware
+										   before hashing. */
+		FSL_HMAC_FLAGS_FINALIZE = 8,	/**< PAD message and perform final HMAC
+										   operations of inner and outer hashes. */
+		FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT = 16 /**< This means that the context
+											contains precomputed inner and outer
+											hash values. */
+	} fsl_shw_hmac_ctx_flags_t;
+	
+	
+	/**
+	 * Flags to control use of the #fsl_shw_scco_t.
+	 *
+	 * These may be ORed together to get the desired effect.
+	 * See #fsl_shw_scco_set_flags() and #fsl_shw_scco_clear_flags()
+	 */
+	typedef enum fsl_shw_sym_ctx_flags_t
+	{
+		/**
+		 * Context is empty.  In ARC4, this means that the S-Box needs to be
+		 * generated from the key.	In #FSL_SYM_MODE_CBC mode, this allows an IV of
+		 * zero to be specified.  In #FSL_SYM_MODE_CTR mode, it means that an
+		 * initial CTR value of zero is desired.
+		 */
+		FSL_SYM_CTX_INIT = 1,
+		/**
+		 * Load context from object into hardware before running cipher.  In
+		 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+		 */
+		FSL_SYM_CTX_LOAD = 2,
+		/**
+		 * Save context from hardware into object after running cipher.  In
+		 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+		 */
+		FSL_SYM_CTX_SAVE = 4,
+		/**
+		 * Context (SBox) is to be unwrapped and wrapped on each use.
+		 * This flag is unsupported.
+		 * */
+		FSL_SYM_CTX_PROTECT = 8,
+	} fsl_shw_sym_ctx_flags_t;
+	
+	
+	/**
+	 * Flags which describe the state of the #fsl_shw_sko_t.
+	 *
+	 * These may be ORed together to get the desired effect.
+	 * See #fsl_shw_sko_set_flags() and #fsl_shw_sko_clear_flags()
+	 */
+	typedef enum fsl_shw_key_flags_t
+	{
+		FSL_SKO_KEY_IGNORE_PARITY = 1, /**< If algorithm is DES or 3DES, do not
+										  validate the key parity bits. */
+		FSL_SKO_KEY_PRESENT = 2,	   /**< Clear key is present in the object. */
+		FSL_SKO_KEY_ESTABLISHED = 4,   /**< Key has been established for use.  This
+										   feature is not available for all
+										   platforms, nor for all algorithms and
+										   modes.*/
+	} fsl_shw_key_flags_t;
+	
+	
+	/**
+	 * Type of value which is associated with an established key.
+	 */
+	typedef uint64_t key_userid_t;
+	
+	
+	/**
+	 * Flags which describe the state of the #fsl_shw_acco_t.
+	 *
+	 * The @a FSL_ACCO_CTX_INIT and @a FSL_ACCO_CTX_FINALIZE flags, when used
+	 * together, provide for a one-shot operation.
+	 */
+	typedef enum fsl_shw_auth_ctx_flags_t
+	{
+		FSL_ACCO_CTX_INIT = 1,		/**< Initialize Context(s) */
+		FSL_ACCO_CTX_LOAD = 2,		/**< Load intermediate context(s).
+									   This flag is unsupported. */
+		FSL_ACCO_CTX_SAVE = 4,		/**< Save intermediate context(s).
+									   This flag is unsupported. */
+		FSL_ACCO_CTX_FINALIZE = 8,	/**< Create MAC during this operation. */
+		FSL_ACCO_NIST_CCM = 16, 	/**< Formatting of CCM input data is
+										performed by calls to
+                                    #fsl_shw_ccm_nist_format_ctr_and_iv() and
+                                    #fsl_shw_ccm_nist_update_ctr_and_iv().  */
+	}  fsl_shw_auth_ctx_flags_t;
+	
+	
+	/**
+	 *	Modulus Selector for CTR modes.
+	 *
+	 * The incrementing of the Counter value may be modified by a modulus.	If no
+	 * modulus is needed or desired for AES, use #FSL_CTR_MOD_128.
+	 */
+	typedef enum fsl_shw_ctr_mod_t
+	{
+		FSL_CTR_MOD_8,				/**< Run counter with modulus of 2^8. */
+		FSL_CTR_MOD_16, 			/**< Run counter with modulus of 2^16. */
+		FSL_CTR_MOD_24, 			/**< Run counter with modulus of 2^24. */
+		FSL_CTR_MOD_32, 			/**< Run counter with modulus of 2^32. */
+		FSL_CTR_MOD_40, 			/**< Run counter with modulus of 2^40. */
+		FSL_CTR_MOD_48, 			/**< Run counter with modulus of 2^48. */
+		FSL_CTR_MOD_56, 			/**< Run counter with modulus of 2^56. */
+		FSL_CTR_MOD_64, 			/**< Run counter with modulus of 2^64. */
+		FSL_CTR_MOD_72, 			/**< Run counter with modulus of 2^72. */
+		FSL_CTR_MOD_80, 			/**< Run counter with modulus of 2^80. */
+		FSL_CTR_MOD_88, 			/**< Run counter with modulus of 2^88. */
+		FSL_CTR_MOD_96, 			/**< Run counter with modulus of 2^96. */
+		FSL_CTR_MOD_104,			/**< Run counter with modulus of 2^104. */
+		FSL_CTR_MOD_112,			/**< Run counter with modulus of 2^112. */
+		FSL_CTR_MOD_120,			/**< Run counter with modulus of 2^120. */
+		FSL_CTR_MOD_128 			/**< Run counter with modulus of 2^128. */
+	} fsl_shw_ctr_mod_t;
+	
+	
+	/**
+	 * Permissions flags for Secure Partitions
+	 *
+	 * They currently map directly to the SCC2 hardware values, but this is not
+	 * guarinteed behavior.
+	 */
+	typedef enum fsl_shw_permission_t
+	{
+	/** SCM Access Permission: Do not zeroize/deallocate partition on SMN Fail state */
+		FSL_PERM_NO_ZEROIZE,
+	/** SCM Access Permission: Enforce trusted key read in	*/
+		FSL_PERM_TRUSTED_KEY_READ,
+	/** SCM Access Permission: Ignore Supervisor/User mode in permission determination */
+		FSL_PERM_HD_S,
+	/** SCM Access Permission: Allow Read Access to  Host Domain */
+		FSL_PERM_HD_R,
+	/** SCM Access Permission: Allow Write Access to  Host Domain */
+		FSL_PERM_HD_W,
+	/** SCM Access Permission: Allow Execute Access to	Host Domain */
+		FSL_PERM_HD_X,
+	/** SCM Access Permission: Allow Read Access to Trusted Host Domain */
+		FSL_PERM_TH_R,
+	/** SCM Access Permission: Allow Write Access to Trusted Host Domain */
+		FSL_PERM_TH_W,
+	/** SCM Access Permission: Allow Read Access to Other/World Domain */
+		FSL_PERM_OT_R,
+	/** SCM Access Permission: Allow Write Access to Other/World Domain */
+		FSL_PERM_OT_W,
+	/** SCM Access Permission: Allow Execute Access to Other/World Domain */
+		FSL_PERM_OT_X,
+	} fsl_shw_permission_t;
+	
+	/**
+	 * Select the cypher mode to use for partition cover/uncover operations.
+	 *
+	 * They currently map directly to the values used in the SCC2 driver, but this
+	 * is not guarinteed behavior.
+	 */
+	typedef enum fsl_shw_cypher_mode_t
+	{
+		FSL_SHW_CYPHER_MODE_ECB,		  /**< ECB mode */
+		FSL_SHW_CYPHER_MODE_CBC,		  /**< CBC mode */
+	} fsl_shw_cypher_mode_t;
+	/** @} */ /* consgrp */
+	
+	
+	/******************************************************************************
+	 * Data Structures
+	 *****************************************************************************/
+	/** @addtogroup strgrp
+		@{ */
+	
+	/* REQ-S2LRD-PINTFC-COA-IBO-001 */
+	/**
+	 * Application Initialization Object
+	 *
+	 * This object, the operations on it, and its interaction with the driver are
+	 * TBD.
+	 */
+	typedef struct fsl_sho_ibo_t
+	{
+	} fsl_sho_ibo_t;
+	
+	
+	/* REQ-S2LRD-PINTFC-COA-UCO-001 */
+	/**
+	 * User Context Object
+	 *
+	 * This object must be initialized by a call to #fsl_shw_uco_init().  It must
+	 * then be passed to #fsl_shw_register_user() before it can be used in any
+	 * calls besides those in @ref ucoops.
+	 *
+	 * It contains the user's configuration for the API, for instance whether an
+	 * operation should block, or instead should call back the user upon completion
+	 * of the operation.
+	 *
+	 * See @ref ucoops for further information.
+	 */
+	typedef struct fsl_shw_uco_t	/* fsl_shw_user_context_object */
+	{
+	} fsl_shw_uco_t;
+	
+	
+	/* REQ-S2LRD-PINTFC-API-GEN-006  ??  */
+	/**
+	 * Result Object
+	 *
+	 * This object will contain success and failure information about a specific
+	 * cryptographic request which has been made.
+	 *
+	 * No direct access to its members should be made by programs.	Instead, the
+	 * object should be manipulated using the provided functions.  See @ref rops.
+	 */
+	typedef struct fsl_shw_result_t /* fsl_shw_result */
+	{
+	} fsl_shw_result_t;
+	
+	
+	/**
+	 * Keystore Object
+	 *
+	 * This object holds the context of a user keystore, including the functions
+	 * that define the interface and pointers to where the key data is stored.	The
+	 * user must supply a set of functions to handle keystore management, including
+	 * slot allocation, deallocation, etc.	A default keystore manager is provided
+	 * as part of the API.
+	 * 
+	 * No direct access to its members should be made by programs.	Instead, the
+	 * object should be manipulated using the provided functions.  See @ref ksoops.
+	 */
+	typedef struct fsl_shw_kso_t /* fsl_shw_keystore_object */
+	{
+	} fsl_shw_kso_t;
+	
+	
+	/* REQ-S2LRD-PINTFC-COA-SKO-001 */
+	/**
+	 * Secret Key Object
+	 *
+	 * This object contains a key for a cryptographic operation, and information
+	 * about its current state, its intended usage, etc.  It may instead contain
+	 * information about a protected key, or an indication to use a platform-
+	 * specific secret key.
+	 *
+	 * No direct access to its members should be made by programs.	Instead, the
+	 * object should be manipulated using the provided functions.  See @ref skoops.
+	 */
+	typedef struct fsl_shw_sko_t /* fsl_shw_secret_key_object */
+	{
+	} fsl_shw_sko_t;
+	
+	
+	/* REQ-S2LRD-PINTFC-COA-CO-001 */
+	/**
+	 * Platform Capabilities Object
+	 *
+	 * This object will contain information about the cryptographic features of the
+	 * platform which the program is running on.
+	 *
+	 * No direct access to its members should be made by programs.	Instead, the
+	 * object should be manipulated using the provided functions.
+	 *
+	 * See @ref pcoops.
+	 */
+	typedef struct fsl_shw_pco_t /* fsl_shw_platform_capabilities_object */
+	{
+	} fsl_shw_pco_t;
+	
+	
+	/* REQ-S2LRD-PINTFC-COA-HCO-001 */
+	/**
+	 * Hash Context Object
+	 *
+	 * This object contains information to control hashing functions.
+	
+	 * No direct access to its members should be made by programs.	Instead, the
+	 * object should be manipulated using the provided functions.  See @ref hcops.
+	 */
+	typedef struct fsl_shw_hco_t /* fsl_shw_hash_context_object */
+	{
+	} fsl_shw_hco_t;
+	
+	/**
+	 * HMAC Context Object
+	 *
+	 * This object contains information to control HMAC functions.
+	
+	 * No direct access to its members should be made by programs.	Instead, the
+	 * object should be manipulated using the provided functions.  See @ref hmcops.
+	 */
+	typedef struct fsl_shw_hmco_t /* fsl_shw_hmac_context_object */
+	{
+	} fsl_shw_hmco_t;
+	
+	
+	/* REQ-S2LRD-PINTFC-COA-SCCO-001 */
+	/**
+	 * Symmetric Cipher Context Object
+	 *
+	 * This object contains information to control Symmetric Ciphering encrypt and
+	 * decrypt functions in #FSL_SYM_MODE_STREAM (ARC4), #FSL_SYM_MODE_ECB,
+	 * #FSL_SYM_MODE_CBC, and #FSL_SYM_MODE_CTR modes and the
+	 * #fsl_shw_symmetric_encrypt() and #fsl_shw_symmetric_decrypt() functions.
+	 * CCM mode is controlled with the #fsl_shw_acco_t object.
+	 *
+	 * No direct access to its members should be made by programs.	Instead, the
+	 * object should be manipulated using the provided functions.  See @ref sccops.
+	 */
+	typedef struct fsl_shw_scco_t /* fsl_shw_symmetric_cipher_context_object */
+	{
+	} fsl_shw_scco_t;
+	
+	
+	/**
+	 * Authenticate-Cipher Context Object
+	
+	 * An object for controlling the function of, and holding information about,
+	 * data for the authenticate-cipher functions, #fsl_shw_gen_encrypt() and
+	 * #fsl_shw_auth_decrypt().
+	 *
+	 * No direct access to its members should be made by programs.	Instead, the
+	 * object should be manipulated using the provided functions.  See @ref
+	 * accoops.
+	 */
+	typedef struct fsl_shw_acco_t /* fsl_shw_authenticate_cipher_context_object */
+	{
+	} fsl_shw_acco_t;
+	/** @} */ /* strgrp */
+	
+	
+	/******************************************************************************
+	 * Access Macros for Objects
+	 *****************************************************************************/
+	/** @addtogroup pcoops
+		@{ */
+	
+	/**
+	 * Get FSL SHW API version
+	 *
+	 * @param	   pc_info	 The Platform Capabilities Object to query.
+	 * @param[out] major	 A pointer to where the major version
+	 *						 of the API is to be stored.
+	 * @param[out] minor	 A pointer to where the minor version
+	 *						 of the API is to be stored.
+	 */
+	void fsl_shw_pco_get_version(const fsl_shw_pco_t* pc_info,
+								 uint32_t* major, uint32_t* minor);
+	
+	
+	/**
+	 * Get underlying driver version.
+	 *
+	 * @param	   pc_info	 The Platform Capabilities Object to query.
+	 * @param[out] major	 A pointer to where the major version
+	 *						 of the driver is to be stored.
+	 * @param[out] minor	 A pointer to where the minor version
+	 *						 of the driver is to be stored.
+	 */
+	void fsl_shw_pco_get_driver_version(const fsl_shw_pco_t* pc_info,
+										uint32_t* major, uint32_t* minor);
+	
+	
+	/**
+	 * Get list of symmetric algorithms supported.
+	 *
+	 * @param pc_info	The Platform Capabilities Object to query.
+	 * @param[out] algorithms A pointer to where to store the location of
+	 *						  the list of algorithms.
+	 * @param[out] algorithm_count A pointer to where to store the number of
+	 *							   algorithms in the list at @a algorithms.
+	 */
+	void fsl_shw_pco_get_sym_algorithms(const fsl_shw_pco_t* pc_info,
+										fsl_shw_key_alg_t* algorithms[],
+										uint8_t* algorithm_count);
+	
+	
+	/**
+	 * Get list of symmetric modes supported.
+	 *
+	 * @param pc_info		  The Platform Capabilities Object to query.
+	 * @param[out] modes	  A pointer to where to store the location of
+	 *						  the list of modes.
+	 * @param[out] mode_count A pointer to where to store the number of
+	 *						  algorithms in the list at @a modes.
+	 */
+	void fsl_shw_pco_get_sym_modes(const fsl_shw_pco_t* pc_info,
+								   fsl_shw_sym_mode_t* modes[],
+								   uint8_t* mode_count);
+	
+	
+	/**
+	 * Get list of hash algorithms supported.
+	 *
+	 * @param pc_info		  The Platform Capabilities Object to query.
+	 * @param[out] algorithms A pointer which will be set to the list of
+	 *						  algorithms.
+	 * @param[out] algorithm_count The number of algorithms in the list at @a
+	 *							   algorithms.
+	 */
+	void fsl_shw_pco_get_hash_algorithms(const fsl_shw_pco_t* pc_info,
+										fsl_shw_hash_alg_t* algorithms[],
+										uint8_t* algorithm_count);
+	
+	
+	/**
+	 * Determine whether the combination of a given symmetric algorithm and a given
+	 * mode is supported.
+	 *
+	 * @param pc_info	 The Platform Capabilities Object to query.
+	 * @param algorithm  A Symmetric Cipher algorithm.
+	 * @param mode		 A Symmetric Cipher mode.
+	 *
+	 * @return 0 if combination is not supported, non-zero if supported.
+	 */
+	int fsl_shw_pco_check_sym_supported(const fsl_shw_pco_t* pc_info,
+										fsl_shw_key_alg_t algorithm,
+										fsl_shw_sym_mode_t mode);
+	
+	
+	/**
+	 * Determine whether a given Encryption-Authentication mode is supported.
+	 *
+	 * @param pc_info	The Platform Capabilities Object to query.
+	 * @param mode		 The Authentication mode.
+	 *
+	 * @return 0 if mode is not supported, non-zero if supported.
+	 */
+	int fsl_shw_pco_check_auth_supported(const fsl_shw_pco_t* pc_info,
+										 fsl_shw_acc_mode_t mode);
+	
+	
+	/**
+	 * Determine whether Black Keys (key establishment / wrapping) is supported.
+	 *
+	 * @param pc_info  The Platform Capabilities Object to query.
+	 *
+	 * @return 0 if wrapping is not supported, non-zero if supported.
+	 */
+	int fsl_shw_pco_check_black_key_supported(const fsl_shw_pco_t* pc_info);
+	
+	
+	/**
+	 * Get FSL SHW SCC driver version
+	 *
+	 * @param	   pc_info	 The Platform Capabilities Object to query.
+	 * @param[out] major	 A pointer to where the major version
+	 *						 of the SCC driver is to be stored.
+	 * @param[out] minor	 A pointer to where the minor version
+	 *						 of the SCC driver is to be stored.
+	 */
+	void fsl_shw_pco_get_scc_driver_version(const fsl_shw_pco_t* pc_info,
+											uint32_t* major, uint32_t* minor);
+	
+	
+	/**
+	 * Get SCM hardware version
+	 *
+	 * @param	   pc_info	 The Platform Capabilities Object to query.
+	 * @return				 The SCM hardware version
+	 */
+	uint32_t fsl_shw_pco_get_scm_version(const fsl_shw_pco_t* pc_info);
+	
+	
+	/**
+	 * Get SMN hardware version
+	 *
+	 * @param	   pc_info	 The Platform Capabilities Object to query.
+	 * @return				 The SMN hardware version
+	 */
+	uint32_t fsl_shw_pco_get_smn_version(const fsl_shw_pco_t* pc_info);
+	
+	
+	/**
+	 * Get the size of an SCM block, in bytes
+	 *
+	 * @param	   pc_info	 The Platform Capabilities Object to query.
+	 * @return				 The size of an SCM block, in bytes.
+	 */
+	uint32_t fsl_shw_pco_get_scm_block_size(const fsl_shw_pco_t* pc_info);
+	
+	
+	/**
+	 * Get size of Black and Red RAM memory
+	 *
+	 * @param	   pc_info	   The Platform Capabilities Object to query.
+	 * @param[out] black_size  A pointer to where the size of the Black RAM, in
+	 *						   blocks, is to be placed.
+	 * @param[out] red_size    A pointer to where the size of the Red RAM, in 
+	 *						   blocks, is to be placed.
+	 */
+	void fsl_shw_pco_get_smn_size(const fsl_shw_pco_t* pc_info,
+								  uint32_t* black_size, uint32_t* red_size);
+	
+	
+	/**
+	 * Determine whether Secure Partitions are supported
+	 *
+	 * @param pc_info		   The Platform Capabilities Object to query.
+	 *
+	 * @return 0 if secure partitions are not supported, non-zero if supported.
+	 */
+	int fsl_shw_pco_check_spo_supported(const fsl_shw_pco_t* pc_info);
+	
+	
+	/**
+	 * Get the size of a Secure Partitions
+	 *
+	 * @param pc_info		   The Platform Capabilities Object to query.
+	 * 
+	 * @return Partition size, in bytes.  0 if Secure Partitions not supported.
+	 */
+	uint32_t fsl_shw_pco_get_spo_size_bytes(const fsl_shw_pco_t* pc_info);
+	
+	
+	/**
+	 * Get the number of Secure Partitions on this platform
+	 *
+	 * @param pc_info		   The Platform Capabilities Object to query.
+	 * 
+	 * @return Number of partitions. 0 if Secure Partitions not supported.	Note
+	 *		   that this returns the total number of partitions, not all may be
+	 *		   available to the user.
+	 */
+	uint32_t fsl_shw_pco_get_spo_count(const fsl_shw_pco_t* pc_info);
+	
+	
+	/** @} */ /* pcoops */
+	
+	
+	/** @addtogroup ucoops
+		@{ */
+	
+	/**
+	 * Initialize a User Context Object.
+	 *
+	 * This function must be called before performing any other operation with the
+	 * Object.	It sets the User Context Object to initial values, and set the size
+	 * of the results pool.  The mode will be set to a default of
+	 * #FSL_UCO_BLOCKING_MODE.
+	 *
+	 * When using non-blocking operations, this sets the maximum number of
+	 * operations which can be outstanding.  This number includes the counts of
+	 * operations waiting to start, operation(s) being performed, and results which
+	 * have not been retrieved.
+	 *
+	 * Changes to this value are ignored once user registration has completed.	It
+	 * should be set to 1 if only blocking operations will ever be performed.
+	 *
+	 * @param user_ctx	   The User Context object to operate on.
+	 * @param pool_size    The maximum number of operations which can be
+	 *					   outstanding.
+	 */
+	void fsl_shw_uco_init(fsl_shw_uco_t* user_ctx, uint16_t pool_size);
+	
+	/**
+	 * Set the User Reference for the User Context.
+	 *
+	 * @param user_ctx	   The User Context object to operate on.
+	 * @param reference    A value which will be passed back with a result.
+	 */
+	void fsl_shw_uco_set_reference(fsl_shw_uco_t* user_ctx, uint32_t reference);
+	
+	
+	/**
+	 * Set the callback routine for the User Context.
+	 *
+	 * Note that the callback routine may be called when no results are available,
+	 * and possibly even when no requests are outstanding.
+	 *
+	 *
+	 * @param user_ctx	   The User Context object to operate on.
+	 * @param callback_fn  The function the API will invoke when an operation
+	 *					   completes.
+	 */
+	void fsl_shw_uco_set_callback(fsl_shw_uco_t* user_ctx,
+								  void (*callback_fn)(fsl_shw_uco_t* uco));
+	
+	/**
+	 * Set flags in the User Context.
+	 *
+	 * Turns on the flags specified in @a flags.  Other flags are untouched.
+	 *
+	 * @param user_ctx	   The User Context object to operate on.
+	 * @param flags 	   ORed values from #fsl_shw_user_ctx_flags_t.
+	 */
+	void fsl_shw_uco_set_flags(fsl_shw_uco_t* user_ctx, uint32_t flags);
+	
+	
+	/**
+	 * Clear flags in the User Context.
+	 *
+	 * Turns off the flags specified in @a flags.  Other flags are untouched.
+	 *
+	 * @param user_ctx	   The User Context object to operate on.
+	 * @param flags 	   ORed values from #fsl_shw_user_ctx_flags_t.
+	 */
+	void fsl_shw_uco_clear_flags(fsl_shw_uco_t* user_ctx, uint32_t flags);
+	
+	/** @} */ /* ucoops */
+	
+	
+	/** @addtogroup rops
+		@{ */
+	
+	/**
+	 * Retrieve the status code from a Result Object.
+	 *
+	 * @param result   The result object to query.
+	 *
+	 * @return The status of the request.
+	 */
+	fsl_shw_return_t fsl_shw_ro_get_status(fsl_shw_result_t* result);
+	
+	/**
+	 * Retrieve the reference value from a Result Object.
+	 *
+	 * @param result   The result object to query.
+	 *
+	 * @return The reference associated with the request.
+	 */
+	uint32_t fsl_shw_ro_get_reference(fsl_shw_result_t* result);
+	
+	
+	/* @} */ /* rops */
+	
+	
+	/** @addtogroup skoops
+		@{ */
+	
+	/**
+	 * Initialize a Secret Key Object.
+	 *
+	 * This function must be called before performing any other operation with
+	 * the Object.
+	 *
+	 * @param key_info	The Secret Key Object to be initialized.
+	 * @param algorithm DES, AES, etc.
+	 *
+	 */
+	void fsl_shw_sko_init(fsl_shw_sko_t* key_info, fsl_shw_key_alg_t algorithm);
+	
+	
+	/**
+	 * Store a cleartext key in the key object.
+	 *
+	 * This has the side effect of setting the #FSL_SKO_KEY_PRESENT flag and
+	 * resetting the #FSL_SKO_KEY_ESTABLISHED flag.
+	 *
+	 * @param key_object   A variable of type #fsl_shw_sko_t.
+	 * @param key		   A pointer to the beginning of the key.
+	 * @param key_length   The length, in octets, of the key.  The value should be
+	 *					   appropriate to the key size supported by the algorithm.
+	 *					   64 octets is the absolute maximum value allowed for this
+	 *					   call.
+	 */
+	void fsl_shw_sko_set_key(fsl_shw_sko_t* key_object,
+							 const uint8_t* key, uint16_t key_length);
+	
+	/**
+	 * Set a size for the key.
+	 *
+	 * This function would normally be used when the user wants the key to be
+	 * generated from a random source.
+	 *
+	 * @param key_object   A variable of type #fsl_shw_sko_t.
+	 * @param key_length   The length, in octets, of the key.  The value should be
+	 *					   appropriate to the key size supported by the algorithm.
+	 *					   64 octets is the absolute maximum value allowed for this
+	 *					   call.
+	 */
+	void fsl_shw_sko_set_key_length(fsl_shw_sko_t* key_object,
+									uint16_t key_length);
+	
+	
+	/**
+	 * Set the User ID associated with the key.
+	 *
+	 * @param key_object   A variable of type #fsl_shw_sko_t.
+	 * @param userid	   The User ID to identify authorized users of the key.
+	 */
+	void fsl_shw_sko_set_user_id(fsl_shw_sko_t* key_object, key_userid_t userid);
+	
+	
+	/**
+	 * Set the keystore that the key will be stored in.
+	 *
+	 * @param key_object	A variable of type #fsl_shw_sko_t.
+	 * @param keystore		The keystore to place the key in.  This is a variable of
+	 *						type #fsl_shw_kso_t.
+	 */
+	 void fsl_shw_sko_set_keystore(fsl_shw_sko_t* key_object, 
+								   fsl_shw_kso_t* keystore);
+	
+	
+	
+	/**
+	 * Set the establish key handle into a key object.
+	 *
+	 * The @a userid field will be used to validate the access to the unwrapped
+	 * key.  This feature is not available for all platforms, nor for all
+	 * algorithms and modes.
+	 *
+	 * The #FSL_SKO_KEY_ESTABLISHED will be set (and the #FSL_SKO_KEY_PRESENT
+	 * flag will be cleared).
+	 *
+	 * @param key_object   A variable of type #fsl_shw_sko_t.
+	 * @param userid	   The User ID to verify this user is an authorized user of
+	 *					   the key.
+	 * @param handle	   A @a handle from #fsl_shw_sko_get_established_info.
+	 */
+	void fsl_shw_sko_set_established_info(fsl_shw_sko_t* key_object,
+										  key_userid_t userid, uint32_t handle);
+	
+	
+	/**
+	 * Extract the algorithm from a key object.
+	 *
+	 * @param	   key_info  The Key Object to be queried.
+	 * @param[out] algorithm A pointer to the location to store the algorithm.
+	 */
+	void fsl_shw_sko_get_algorithm(const fsl_shw_sko_t* key_info,
+								   fsl_shw_key_alg_t* algorithm);
+	
+	/**
+	 * Retrieve the cleartext key from a key object that is stored in a user
+	 * keystore.
+	 *
+	 * @param	   skobject 	The Key Object to be queried.
+	 * @param[out] skkey		A pointer to the location to store the key.  NULL
+	 *							if the key is not stored in a user keystore.
+	 */
+	void fsl_shw_sko_get_key(const fsl_shw_sko_t* skobject,
+							 void* skkey);
+	
+	/**
+	 * Retrieve the established-key handle from a key object.
+	 *
+	 * @param key_object   A variable of type #fsl_shw_sko_t.
+	 * @param handle	   The location to store the @a handle of the unwrapped
+	 *					   key.
+	 */
+	void fsl_shw_sko_get_established_info(fsl_shw_sko_t* key_object,
+										  uint32_t* handle);
+	
+	
+	/**
+	 * Determine the size of a wrapped key based upon the cleartext key's length.
+	 *
+	 * This function can be used to calculate the number of octets that
+	 * #fsl_shw_extract_key() will write into the location at @a covered_key.
+	 *
+	 * If zero is returned at @a length, this means that the key length in
+	 * @a key_info is not supported.
+	 *
+	 * @param	   key_info 		Information about a key to be wrapped.
+	 * @param	   length			Location to store the length of a wrapped
+	 *								version of the key in @a key_info.
+	 */
+	void fsl_shw_sko_calculate_wrapped_size(const fsl_shw_sko_t* key_info,
+											uint32_t* length);
+	
+	
+	/**
+	 * Set some flags in the key object.
+	 *
+	 * Turns on the flags specified in @a flags.  Other flags are untouched.
+	 *
+	 * @param key_object   A variable of type #fsl_shw_sko_t.
+	 * @param flags 	   (One or more) ORed members of #fsl_shw_key_flags_t which
+	 *					   are to be set.
+	 */
+	void fsl_shw_sko_set_flags(fsl_shw_sko_t* key_object, uint32_t flags);
+	
+	
+	/**
+	 * Clear some flags in the key object.
+	 *
+	 * Turns off the flags specified in @a flags.  Other flags are untouched.
+	 *
+	 * @param key_object   A variable of type #fsl_shw_sko_t.
+	 * @param flags 	   (One or more) ORed members of #fsl_shw_key_flags_t which
+	 *						are to be reset.
+	 */
+	void fsl_shw_sko_clear_flags(fsl_shw_sko_t* key_object, uint32_t flags);
+	
+	/** @} */ /* end skoops */
+	
+	
+	/*****************************************************************************/
+	
+	/** @addtogroup hcops
+		@{ */
+	
+	/*****************************************************************************/
+	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-004 - partially */
+	/**
+	 * Initialize a Hash Context Object.
+	 *
+	 * This function must be called before performing any other operation with the
+	 * Object.	It sets the current message length and hash algorithm in the hash
+	 * context object.
+	 *
+	 * @param	   hash_ctx  The hash context to operate upon.
+	 * @param	   algorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
+	 *						 #FSL_HASH_ALG_SHA256, etc).
+	 *
+	 */
+	void fsl_shw_hco_init(fsl_shw_hco_t* hash_ctx, fsl_shw_hash_alg_t algorithm);
+	
+	
+	/*****************************************************************************/
+	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-001 */
+	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-002 */
+	/**
+	 * Get the current hash value and message length from the hash context object.
+	 *
+	 * The algorithm must have already been specified.	See #fsl_shw_hco_init().
+	 *
+	 * @param	   hash_ctx  The hash context to query.
+	 * @param[out] digest	 Pointer to the location of @a length octets where to
+	 *						 store a copy of the current value of the digest.
+	 * @param	   length	 Number of octets of hash value to copy.
+	 * @param[out] msg_length Pointer to the location to store the number of octets
+	 *						  already hashed.
+	 */
+	void fsl_shw_hco_get_digest(const fsl_shw_hco_t* hash_ctx, uint8_t* digest,
+								uint8_t length, uint32_t* msg_length);
+	
+	
+	/*****************************************************************************/
+	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-002 - partially */
+	/**
+	 * Get the hash algorithm from the hash context object.
+	 *
+	 * @param	   hash_ctx  The hash context to query.
+	 * @param[out] algorithm Pointer to where the algorithm is to be stored.
+	 */
+	void fsl_shw_hco_get_info(const fsl_shw_hco_t* hash_ctx,
+							  fsl_shw_hash_alg_t* algorithm);
+	
+	
+	/*****************************************************************************/
+	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-003 */
+	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-004 */
+	/**
+	 * Set the current hash value and message length in the hash context object.
+	 *
+	 * The algorithm must have already been specified.	See #fsl_shw_hco_init().
+	 *
+	 * @param	   hash_ctx  The hash context to operate upon.
+	 * @param	   context	 Pointer to buffer of appropriate length to copy into
+	 *						 the hash context object.
+	 * @param	   msg_length The number of octets of the message which have
+	 *						  already been hashed.
+	 *
+	 */
+	void fsl_shw_hco_set_digest(fsl_shw_hco_t* hash_ctx, const uint8_t* context,
+								uint32_t msg_length);
+	
+	
+	/**
+	 * Set flags in a Hash Context Object.
+	 *
+	 * Turns on the flags specified in @a flags.  Other flags are untouched.
+	 *
+	 * @param hash_ctx	 The hash context to be operated on.
+	 * @param flags 	 The flags to be set in the context.  These can be ORed
+	 *					 members of #fsl_shw_hash_ctx_flags_t.
+	 */
+	void fsl_shw_hco_set_flags(fsl_shw_hco_t* hash_ctx, uint32_t flags);
+	
+	
+	/**
+	 * Clear flags in a Hash Context Object.
+	 *
+	 * Turns off the flags specified in @a flags.  Other flags are untouched.
+	 *
+	 * @param hash_ctx	 The hash context to be operated on.
+	 * @param flags 	 The flags to be reset in the context.	These can be ORed
+	 *					 members of #fsl_shw_hash_ctx_flags_t.
+	 */
+	void fsl_shw_hco_clear_flags(fsl_shw_hco_t* hash_ctx, uint32_t flags);
+	
+	/** @} */ /* end hcops */
+	
+	
+	/*****************************************************************************/
+	
+	/** @addtogroup hmcops
+		@{ */
+	
+	/**
+	 * Initialize an HMAC Context Object.
+	 *
+	 * This function must be called before performing any other operation with the
+	 * Object.	It sets the current message length and hash algorithm in the HMAC
+	 * context object.
+	 *
+	 * @param	   hmac_ctx  The HMAC context to operate upon.
+	 * @param	   algorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
+	 *						 #FSL_HASH_ALG_SHA256, etc).
+	 *
+	 */
+	void fsl_shw_hmco_init(fsl_shw_hmco_t* hmac_ctx, fsl_shw_hash_alg_t algorithm);
+	
+	/**
+	 * Set flags in an HMAC Context Object.
+	 *
+	 * Turns on the flags specified in @a flags.  Other flags are untouched.
+	 *
+	 * @param hmac_ctx	 The HMAC context to be operated on.
+	 * @param flags 	 The flags to be set in the context.  These can be ORed
+	 *					 members of #fsl_shw_hmac_ctx_flags_t.
+	 */
+	void fsl_shw_hmco_set_flags(fsl_shw_hmco_t* hmac_ctx, uint32_t flags);
+	
+	
+	/**
+	 * Clear flags in an HMAC Context Object.
+	 *
+	 * Turns off the flags specified in @a flags.  Other flags are untouched.
+	 *
+	 * @param hmac_ctx	 The HMAC context to be operated on.
+	 * @param flags 	 The flags to be reset in the context.	These can be ORed
+	 *					 members of #fsl_shw_hmac_ctx_flags_t.
+	 */
+	void fsl_shw_hmco_clear_flags(fsl_shw_hmco_t* hmac_ctx, uint32_t flags);
+	
+	
+	/** @} */
+	
+	/*****************************************************************************/
+	
+	/** @addtogroup sccops
+		@{ */
+	
+	/**
+	 * Initialize a Symmetric Cipher Context Object.
+	 *
+	 * This function must be called before performing any other operation with the
+	 * Object.	This will set the @a mode and @a algorithm and initialize the
+	 * Object.
+	 *
+	 * @param sym_ctx	The context object to operate on.
+	 * @param algorithm The cipher algorithm this context will be used with.
+	 * @param mode		#FSL_SYM_MODE_CBC, #FSL_SYM_MODE_ECB, etc.
+	 *
+	 */
+	void fsl_shw_scco_init(fsl_shw_scco_t* sym_ctx,
+						   fsl_shw_key_alg_t algorithm,
+						   fsl_shw_sym_mode_t mode);
+	
+	
+	/**
+	 * Set the flags for a Symmetric Cipher Context.
+	 *
+	 * Turns on the flags specified in @a flags.  Other flags are untouched.
+	 *
+	 * @param sym_ctx  The context object to operate on.
+	 * @param flags    The flags to reset (one or more values from
+	 *				   #fsl_shw_sym_ctx_flags_t ORed together).
+	 *
+	 */
+	void fsl_shw_scco_set_flags(fsl_shw_scco_t* sym_ctx, uint32_t flags);
+	
+	
+	/**
+	 * Clear some flags in a Symmetric Cipher Context Object.
+	 *
+	 * Turns off the flags specified in @a flags.  Other flags are untouched.
+	 *
+	 * @param sym_ctx  The context object to operate on.
+	 * @param flags    The flags to reset (one or more values from
+	 *				   #fsl_shw_sym_ctx_flags_t ORed together).
+	 *
+	 */
+	void fsl_shw_scco_clear_flags(fsl_shw_scco_t* sym_ctx, uint32_t flags);
+	
+	
+	/**
+	 * Set the Context (IV) for a Symmetric Cipher Context.
+	 *
+	 * This is to set the context/IV for #FSL_SYM_MODE_CBC mode, or to set the
+	 * context (the S-Box and pointers) for ARC4.  The full context size will
+	 * be copied.
+	 *
+	 * @param sym_ctx  The context object to operate on.
+	 * @param context  A pointer to the buffer which contains the context.
+	 *
+	 */
+	void fsl_shw_scco_set_context(fsl_shw_scco_t* sym_ctx, uint8_t* context);
+	
+	
+	
+	/**
+	 * Get the Context for a Symmetric Cipher Context.
+	 *
+	 * This is to retrieve the context/IV for #FSL_SYM_MODE_CBC mode, or to
+	 * retrieve context (the S-Box and pointers) for ARC4.	The full context
+	 * will be copied.
+	 *
+	 * @param	   sym_ctx	The context object to operate on.
+	 * @param[out] context	Pointer to location where context will be stored.
+	 */
+	void fsl_shw_scco_get_context(const fsl_shw_scco_t* sym_ctx, uint8_t* context);
+	
+	
+	/**
+	 * Set the Counter Value for a Symmetric Cipher Context.
+	 *
+	 * This will set the Counter Value for CTR mode.
+	 *
+	 * @param sym_ctx  The context object to operate on.
+	 * @param counter  The starting counter value.	The number of octets.
+	 *				   copied will be the block size for the algorithm.
+	 * @param modulus  The modulus for controlling the incrementing of the counter.
+	 *
+	 */
+	void fsl_shw_scco_set_counter_info(fsl_shw_scco_t* sym_ctx,
+									   const uint8_t* counter,
+									   fsl_shw_ctr_mod_t modulus);
+	
+	
+	/**
+	 * Get the Counter Value for a Symmetric Cipher Context.
+	 *
+	 * This will retrieve the Counter Value is for CTR mode.
+	 *
+	 * @param sym_ctx		  The context object to query.
+	 * @param[out] counter	  Pointer to location to store the current counter
+	 *						  value.  The number of octets copied will be the
+	 *						  block size for the algorithm.
+	 * @param[out] modulus	  Pointer to location to store the modulus.
+	 *
+	 */
+	void fsl_shw_scco_get_counter_info(const fsl_shw_scco_t* sym_ctx,
+									   uint8_t* counter,
+									   fsl_shw_ctr_mod_t* modulus);
+	
+	/** @} */ /* end sccops */
+	
+	
+	/*****************************************************************************/
+	
+	/** @addtogroup accoops
+		@{ */
+	
+	/**
+	 * Initialize a Authentication-Cipher Context.
+	 *
+	 * @param auth_object  Pointer to object to operate on.
+	 * @param mode		   The mode for this object (only #FSL_ACC_MODE_CCM
+	 *					   supported).
+	 */
+	void fsl_shw_acco_init(fsl_shw_acco_t* auth_object, fsl_shw_acc_mode_t mode);
+	
+	
+	/**
+	 * Set the flags for a Authentication-Cipher Context.
+	 *
+	 * Turns on the flags specified in @a flags.  Other flags are untouched.
+	 *
+	 * @param auth_object  Pointer to object to operate on.
+	 * @param flags 	   The flags to set (one or more from
+	 *					   #fsl_shw_auth_ctx_flags_t ORed together).
+	 *
+	 */
+	void fsl_shw_acco_set_flags(fsl_shw_acco_t* auth_object, uint32_t flags);
+	
+	
+	/**
+	 * Clear some flags in a Authentication-Cipher Context Object.
+	 *
+	 * Turns off the flags specified in @a flags.  Other flags are untouched.
+	 *
+	 * @param auth_object  Pointer to object to operate on.
+	 * @param flags 	   The flags to reset (one or more from
+	 *					   #fsl_shw_auth_ctx_flags_t ORed together).
+	 *
+	 */
+	void fsl_shw_acco_clear_flags(fsl_shw_acco_t* auth_object, uint32_t flags);
+	
+	
+	/**
+	 * Set up the Authentication-Cipher Object for CCM mode.
+	 *
+	 * This will set the @a auth_object for CCM mode and save the @a ctr,
+	 * and @a mac_length.  This function can be called instead of
+	 * #fsl_shw_acco_init().
+	 *
+	 * The parameter @a ctr is Counter Block 0, (counter value 0), which is for the
+	 * MAC.
+	 *
+	 * @param auth_object  Pointer to object to operate on.
+	 * @param algorithm    Cipher algorithm.  Only AES is supported.
+	 * @param ctr		   The initial counter value.
+	 * @param mac_length   The number of octets used for the MAC.  Valid values are
+	 *					   4, 6, 8, 10, 12, 14, and 16.
+	 */
+	void fsl_shw_acco_set_ccm(fsl_shw_acco_t* auth_object,
+							  fsl_shw_key_alg_t algorithm,
+							  const uint8_t* ctr,
+							  uint8_t mac_length);
+	
+	
+	/**
+	 * Format the First Block (IV) & Initial Counter Value per NIST CCM.
+	 *
+	 * This function will also set the IV and CTR values per Appendix A of NIST
+	 * Special Publication 800-38C (May 2004).	It will also perform the
+	 * #fsl_shw_acco_set_ccm() operation with information derived from this set of
+	 * parameters.
+	 *
+	 * Note this function assumes the algorithm is AES.  It initializes the
+	 * @a auth_object by setting the mode to #FSL_ACC_MODE_CCM and setting the
+	 * flags to be #FSL_ACCO_NIST_CCM.
+	 *
+	 * @param auth_object  Pointer to object to operate on.
+	 * @param t_length	   The number of octets used for the MAC.  Valid values are
+	 *					   4, 6, 8, 10, 12, 14, and 16.
+	 * @param ad_length    Number of octets of Associated Data (may be zero).
+	 * @param q_length	   A value for the size of the length of @a q field.  Valid
+	 *					   values are 1-8.
+	 * @param n 		   The Nonce (packet number or other changing value). Must
+	 *					   be (15 - @a q_length) octets long.
+	 * @param q 		   The value of Q (size of the payload in octets).
+	 *
+	 */
+	void fsl_shw_ccm_nist_format_ctr_and_iv(fsl_shw_acco_t* auth_object,
+											uint8_t t_length,
+											uint32_t ad_length,
+											uint8_t q_length,
+											const uint8_t* n, uint32_t q);
+	
+	
+	/**
+	 * Update the First Block (IV) & Initial Counter Value per NIST CCM.
+	 *
+	 * This function will set the IV and CTR values per Appendix A of NIST Special
+	 * Publication 800-38C (May 2004).
+	 *
+	 * Note this function assumes that #fsl_shw_ccm_nist_format_ctr_and_iv() has
+	 * previously been called on the @a auth_object.
+	 *
+	 * @param auth_object  Pointer to object to operate on.
+	 * @param n 			The Nonce (packet number or other changing value). Must
+	 *						be (15 - @a q_length) octets long.
+	 * @param q 			The value of Q (size of the payload in octets).
+	 *
+	 */
+	void fsl_shw_ccm_nist_update_ctr_and_iv(fsl_shw_acco_t* auth_object,
+											const uint8_t* n, uint32_t q);
+	
+	
+	/* @} */ /* accoops */
+	
+	
+	/******************************************************************************
+	 * Library functions
+	 *****************************************************************************/
+	
+	/** @addtogroup miscfuns
+		@{ */
+	
+	/* REQ-S2LRD-PINTFC-API-GEN-003 */
+	/**
+	 * Determine the hardware security capabilities of this platform.
+	 *
+	 * Though a user context object is passed into this function, it will always
+	 * act in a non-blocking manner.
+	 *
+	 * @param  user_ctx   The user context which will be used for the query.
+	 *
+	 * @return	A pointer to the capabilities object.
+	 */
+	extern fsl_shw_pco_t* fsl_shw_get_capabilities(fsl_shw_uco_t* user_ctx);
+	
+	
+	/* REQ-S2LRD-PINTFC-API-GEN-004 */
+	/**
+	 * Create an association between the user and the provider of the API.
+	 *
+	 * @param  user_ctx   The user context which will be used for this association.
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t* user_ctx);
+	
+	
+	/* REQ-S2LRD-PINTFC-API-GEN-005 */
+	/**
+	 * Destroy the association between the user and the provider of the API.
+	 *
+	 * @param  user_ctx   The user context which is no longer needed.
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t* user_ctx);
+	
+	
+	/* REQ-S2LRD-PINTFC-API-GEN-006 */
+	/**
+	 * Retrieve results from earlier operations.
+	 *
+	 * @param		  user_ctx	   The user's context.
+	 * @param		  result_size  The number of array elements of @a results.
+	 * @param[in,out] results	   Pointer to first of the (array of) locations to
+	 *							   store results.
+	 * @param[out]	  result_count Pointer to store the number of results which
+	 *							   were returned.
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t* user_ctx,
+												uint16_t result_size,
+												fsl_shw_result_t results[],
+												uint16_t* result_count);
+	
+	
+	/**
+	 * Allocate a block of secure memory
+	 *
+	 * @param		user_ctx		User context
+	 * @param		size			Memory size (octets).  Note: currently only
+	 *								supports only single-partition sized blocks.
+	 * @param		UMID			User Mode ID to use when registering the
+	 *								partition.
+	 * @param		permissions 	Permissions to initialize the partition with.
+	 *								Can be made by ORing flags from the
+	 *								#fsl_shw_permission_t.
+	 *
+	 * @return						Address of the allocated memory.  NULL if the
+	 *								call was not successful.
+	 */
+	extern void* fsl_shw_smalloc(fsl_shw_uco_t* user_ctx,
+								 uint32_t size,
+								 const uint8_t *UMID,
+								 uint32_t permissions);
+	
+	
+	/**
+	 * Free a block of secure memory that was allocated with #fsl_shw_smalloc
+	 *
+	 * @param		user_ctx		User context
+	 * @param		address 		Address of the block of secure memory to be
+	 *								released.
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_sfree(
+									fsl_shw_uco_t* user_ctx,
+									void *address);
+	
+	
+	/**
+	 * Diminish the permissions of a block of secure memory.  Note that permissions
+	 * can only be revoked.
+	 *
+	 * @param		user_ctx		User context
+	 * @param		address 		Base address of the secure memory to work with
+	 * @param		permissions 	Permissions to initialize the partition with.
+	 *								Can be made by ORing flags from the
+	 *								#fsl_shw_permission_t.
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_diminish_perms(
+									fsl_shw_uco_t* user_ctx,
+									void *address,
+									uint32_t permissions);
+	
+	
+	/**
+	 * @brief	Encrypt a region of secure memory using the hardware secret key
+	 *
+	 * @param		user_ctx		User context
+	 * @param		partition_base	Base address of the partition
+	 * @param		offset_bytes	Offset of data from the partition base
+	 * @param		byte_count		Length of the data to encrypt
+	 * @param		black_data		Location to store the encrypted data
+	 * @param		IV				IV to use for the encryption routine
+	 * @param		cypher_mode 	Cyphering mode to use, specified by type
+	 *								#fsl_shw_cypher_mode_t
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t 
+	do_scc_encrypt_region(fsl_shw_uco_t* user_ctx,
+						  void* partition_base, uint32_t offset_bytes,
+						  uint32_t byte_count, uint8_t* black_data,
+						  uint32_t* IV, fsl_shw_cypher_mode_t cypher_mode);
+	
+	
+	/**
+	 * @brief	Decrypt a region of secure memory using the hardware secret key
+	 *
+	 * @param		user_ctx		User context
+	 * @param		partition_base	Base address of the partition
+	 * @param		offset_bytes	Offset of data from the partition base
+	 * @param		byte_count		Length of the data to encrypt
+	 * @param		black_data		Location to store the encrypted data
+	 * @param		IV				IV to use for the encryption routine
+	 * @param		cypher_mode 	Cyphering mode to use, specified by type
+	 *								#fsl_shw_cypher_mode_t
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t 
+	do_scc_decrypt_region(fsl_shw_uco_t* user_ctx,
+						  void* partition_base, uint32_t offset_bytes,
+						  uint32_t byte_count, const uint8_t* black_data,
+						  uint32_t* IV, fsl_shw_cypher_mode_t cypher_mode);
+	
+	
+	/** @} */ /* miscfuns */
+	
+	
+	/** @addtogroup opfuns
+		@{ */
+	
+	/* REQ-S2LRD-PINTFC-API-BASIC-SYM-002 */
+	/* PINTFC-API-BASIC-SYM-ARC4-001 */
+	/* PINTFC-API-BASIC-SYM-ARC4-002 */
+	/**
+	 * Encrypt a stream of data with a symmetric-key algorithm.
+	 *
+	 * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
+	 * flags of the @a sym_ctx object will control part of the operation of this
+	 * function.  The #FSL_SYM_CTX_INIT flag means that there is no context info in
+	 * the object.	The #FSL_SYM_CTX_LOAD means to use information in the
+	 * @a sym_ctx at the start of the operation, and the #FSL_SYM_CTX_SAVE flag
+	 * means to update the object's context information after the operation has
+	 * been performed.
+	 *
+	 * All of the data for an operation can be run through at once using the
+	 * #FSL_SYM_CTX_INIT or #FSL_SYM_CTX_LOAD flags, as appropriate, and then using
+	 * a @a length for the whole of the data.
+	 *
+	 * If a #FSL_SYM_CTX_SAVE flag were added, an additional call to the function
+	 * would "pick up" where the previous call left off, allowing the user to
+	 * perform the larger function in smaller steps.
+	 *
+	 * In #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_ECB modes, the @a length must always
+	 * be a multiple of the block size for the algorithm being used.  For proper
+	 * operation in #FSL_SYM_MODE_CTR mode, the @a length must be a multiple of the
+	 * block size until the last operation on the total octet stream.
+	 *
+	 * Some users of ARC4 may want to compute the context (S-Box and pointers) from
+	 * the key before any data is available.  This may be done by running this
+	 * function with a @a length of zero, with the init & save flags flags on in
+	 * the @a sym_ctx.	Subsequent operations would then run as normal with the
+	 * load and save flags.  Note that they key object is still required.
+	 *
+	 * @param		  user_ctx	A user context from #fsl_shw_register_user().
+	 * @param		  key_info	Key and algorithm  being used for this operation.
+	 * @param[in,out] sym_ctx	Info on cipher mode, state of the cipher.
+	 * @param		  length   Length, in octets, of the pt (and ct).
+	 * @param		  pt	   pointer to plaintext to be encrypted.
+	 * @param[out]	  ct	   pointer to where to store the resulting ciphertext.
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 *
+	 */
+	extern fsl_shw_return_t fsl_shw_symmetric_encrypt(
+									fsl_shw_uco_t* user_ctx,
+									fsl_shw_sko_t* key_info,
+									fsl_shw_scco_t* sym_ctx,
+									uint32_t length,
+									const uint8_t* pt,
+									uint8_t* ct);
+	
+	/* PINTFC-API-BASIC-SYM-002 */
+	/* PINTFC-API-BASIC-SYM-ARC4-001 */
+	/* PINTFC-API-BASIC-SYM-ARC4-002 */
+	/**
+	 * Decrypt a stream of data with a symmetric-key algorithm.
+	 *
+	 * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
+	 * flags of the @a sym_ctx object will control part of the operation of this
+	 * function.  The #FSL_SYM_CTX_INIT flag means that there is no context info in
+	 * the object.	The #FSL_SYM_CTX_LOAD means to use information in the
+	 * @a sym_ctx at the start of the operation, and the #FSL_SYM_CTX_SAVE flag
+	 * means to update the object's context information after the operation has
+	 * been performed.
+	 *
+	 * All of the data for an operation can be run through at once using the
+	 * #FSL_SYM_CTX_INIT or #FSL_SYM_CTX_LOAD flags, as appropriate, and then using
+	 * a @a length for the whole of the data.
+	 *
+	 * If a #FSL_SYM_CTX_SAVE flag were added, an additional call to the function
+	 * would "pick up" where the previous call left off, allowing the user to
+	 * perform the larger function in smaller steps.
+	 *
+	 * In #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_ECB modes, the @a length must always
+	 * be a multiple of the block size for the algorithm being used.  For proper
+	 * operation in #FSL_SYM_MODE_CTR mode, the @a length must be a multiple of the
+	 * block size until the last operation on the total octet stream.
+	 *
+	 * Some users of ARC4 may want to compute the context (S-Box and pointers) from
+	 * the key before any data is available.  This may be done by running this
+	 * function with a @a length of zero, with the #FSL_SYM_CTX_INIT &
+	 * #FSL_SYM_CTX_SAVE flags on in the @a sym_ctx.  Subsequent operations would
+	 * then run as normal with the load & save flags.  Note that they key object is
+	 * still required.
+	 *
+	 * @param	   user_ctx  A user context from #fsl_shw_register_user().
+	 * @param	   key_info The key and algorithm being used in this operation.
+	 * @param[in,out] sym_ctx Info on cipher mode, state of the cipher.
+	 * @param	   length	Length, in octets, of the ct (and pt).
+	 * @param	   ct		pointer to ciphertext to be decrypted.
+	 * @param[out] pt		pointer to where to store the resulting plaintext.
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t
+	 *
+	 */
+	extern fsl_shw_return_t fsl_shw_symmetric_decrypt(
+									fsl_shw_uco_t* user_ctx,
+									fsl_shw_sko_t* key_info,
+									fsl_shw_scco_t* sym_ctx,
+									uint32_t length,
+									const uint8_t* ct,
+									uint8_t* pt);
+	
+	
+	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-005 */
+	/**
+	 * Hash a stream of data with a cryptographic hash algorithm.
+	 *
+	 * The flags in the @a hash_ctx control the operation of this function.
+	 *
+	 * Hashing functions work on 64 octets of message at a time.  Therefore, when
+	 * any partial hashing of a long message is performed, the message @a length of
+	 * each segment must be a multiple of 64.  When ready to
+	 * #FSL_HASH_FLAGS_FINALIZE the hash, the @a length may be any value.
+	 *
+	 * With the #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_FINALIZE flags on, a
+	 * one-shot complete hash, including padding, will be performed.  The @a length
+	 * may be any value.
+	 *
+	 * The first octets of a data stream can be hashed by setting the
+	 * #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_SAVE flags.  The @a length must be
+	 * a multiple of 64.
+	 *
+	 * The flag #FSL_HASH_FLAGS_LOAD is used to load a context previously saved by
+	 * #FSL_HASH_FLAGS_SAVE.  The two in combination will allow a (multiple-of-64
+	 * octets) 'middle sequence' of the data stream to be hashed with the
+	 * beginning.  The @a length must again be a multiple of 64.
+	 *
+	 * Since the flag #FSL_HASH_FLAGS_LOAD is used to load a context previously
+	 * saved by #FSL_HASH_FLAGS_SAVE, the #FSL_HASH_FLAGS_LOAD and
+	 * #FSL_HASH_FLAGS_FINALIZE flags, used together, can be used to finish the
+	 * stream.	The @a length may be any value.
+	 *
+	 * If the user program wants to do the padding for the hash, it can leave off
+	 * the #FSL_HASH_FLAGS_FINALIZE flag.  The @a length must then be a multiple of
+	 * 64 octets.
+	 *
+	 * @param	   user_ctx  A user context from #fsl_shw_register_user().
+	 * @param[in,out] hash_ctx Hashing algorithm and state of the cipher.
+	 * @param	   msg		 Pointer to the data to be hashed.
+	 * @param	   length	 Length, in octets, of the @a msg.
+	 * @param[out] result	 If not null, pointer to where to store the hash
+	 *						 digest.
+	 * @param	   result_len Number of octets to store in @a result.
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_hash(
+									fsl_shw_uco_t* user_ctx,
+									fsl_shw_hco_t* hash_ctx,
+									const uint8_t* msg,
+									uint32_t length,
+									uint8_t* result,
+									uint32_t result_len);
+	
+	
+	/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-001 */
+	/**
+	 * Precompute the Key hashes for an HMAC operation.
+	 *
+	 * This function may be used to calculate the inner and outer precomputes,
+	 * which are the hash contexts resulting from hashing the XORed key for the
+	 * 'inner hash' and the 'outer hash', respectively, of the HMAC function.
+	 *
+	 * After execution of this function, the @a hmac_ctx will contain the
+	 * precomputed inner and outer contexts, so that they may be used by
+	 * #fsl_shw_hmac().  The flags of @a hmac_ctx will be updated with
+	 * #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT to mark their presence.	In addition, the
+	 * #FSL_HMAC_FLAGS_INIT flag will be set.
+	 *
+	 * @param	   user_ctx  A user context from #fsl_shw_register_user().
+	 * @param	   key_info  The key being used in this operation.	Key must be
+	 *						 1 to 64 octets long.
+	 * @param[in,out] hmac_ctx The context which controls, by its flags and
+	 *						   algorithm, the operation of this function.
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_hmac_precompute(
+									fsl_shw_uco_t* user_ctx,
+									fsl_shw_sko_t* key_info,
+									fsl_shw_hmco_t* hmac_ctx);
+	
+	
+	/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-002 */
+	/**
+	 * Continue, finalize, or one-shot an HMAC operation.
+	 *
+	 * There are a number of ways to use this function.  The flags in the
+	 * @a hmac_ctx object will determine what operations occur.
+	 *
+	 * If #FSL_HMAC_FLAGS_INIT is set, then the hash will be started either from
+	 * the @a key_info, or from the precomputed inner hash value in the
+	 * @a hmac_ctx, depending on the value of #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT.
+	 *
+	 * If, instead, #FSL_HMAC_FLAGS_LOAD is set, then the hash will be continued
+	 * from the ongoing inner hash computation in the @a hmac_ctx.
+	 *
+	 * If #FSL_HMAC_FLAGS_FINALIZE are set, then the @a msg will be padded, hashed,
+	 * the outer hash will be performed, and the @a result will be generated.
+	 *
+	 * If the #FSL_HMAC_FLAGS_SAVE flag is set, then the (ongoing or final) digest
+	 * value will be stored in the ongoing inner hash computation field of the @a
+	 * hmac_ctx.
+	 *
+	 * @param	   user_ctx  A user context from #fsl_shw_register_user().
+	 * @param key_info		 If #FSL_HMAC_FLAGS_INIT is set in the @a hmac_ctx,
+	 *						 this is the key being used in this operation, and the
+	 *						 IPAD.	If #FSL_HMAC_FLAGS_INIT is set in the @a
+	 *						 hmac_ctx and @a key_info is NULL, then
+	 *						 #fsl_shw_hmac_precompute() has been used to populate
+	 *						 the @a inner_precompute and @a outer_precompute
+	 *						 contexts.	If #FSL_HMAC_FLAGS_INIT is not set, this
+	 *						 parameter is ignored.
+	
+	 * @param[in,out] hmac_ctx The context which controls, by its flags and
+	 *						 algorithm, the operation of this function.
+	 * @param	   msg				 Pointer to the message to be hashed.
+	 * @param	   length			 Length, in octets, of the @a msg.
+	 * @param[out] result			 Pointer, of @a result_len octets, to where to
+	 *								 store the HMAC.
+	 * @param	   result_len		 Length of @a result buffer.
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_hmac(
+									fsl_shw_uco_t* user_ctx,
+									fsl_shw_sko_t* key_info,
+									fsl_shw_hmco_t* hmac_ctx,
+									const uint8_t* msg,
+									uint32_t length,
+									uint8_t* result,
+									uint32_t result_len);
+	
+	
+	/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
+	/**
+	 * Get random data.
+	 *
+	 * @param	   user_ctx  A user context from #fsl_shw_register_user().
+	 * @param	   length	 The number of octets of @a data being requested.
+	 * @param[out] data 	 A pointer to a location of @a length octets to where
+	 *						 random data will be returned.
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_get_random(
+									fsl_shw_uco_t* user_ctx,
+									uint32_t length,
+									uint8_t* data);
+	
+	
+	/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
+	/**
+	 * Add entropy to random number generator.
+	 *
+	 * @param	   user_ctx  A user context from #fsl_shw_register_user().
+	 * @param	   length	 Number of bytes at @a data.
+	 * @param	   data 	 Entropy to add to random number generator.
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_add_entropy(
+									fsl_shw_uco_t* user_ctx,
+									uint32_t length,
+									uint8_t* data);
+	
+	
+	/**
+	 * Perform Generation-Encryption by doing a Cipher and a Hash.
+	 *
+	 * Generate the authentication value @a auth_value as well as encrypt the @a
+	 * payload into @a ct (the ciphertext).  This is a one-shot function, so all of
+	 * the @a auth_data and the total message @a payload must passed in one call.
+	 * This also means that the flags in the @a auth_ctx must be #FSL_ACCO_CTX_INIT
+	 * and #FSL_ACCO_CTX_FINALIZE.
+	 *
+	 * @param	   user_ctx 		A user context from #fsl_shw_register_user().
+	 * @param	   auth_ctx 		Controlling object for Authenticate-decrypt.
+	 * @param	   cipher_key_info	The key being used for the cipher part of this
+	 *								operation.	In CCM mode, this key is used for
+	 *								both parts.
+	 * @param	   auth_key_info	The key being used for the authentication part
+	 *								of this operation.	In CCM mode, this key is
+	 *								ignored and may be NULL.
+	 * @param	   auth_data_length Length, in octets, of @a auth_data.
+	 * @param	   auth_data		Data to be authenticated but not encrypted.
+	 * @param	   payload_length	Length, in octets, of @a payload.
+	 * @param	   payload			Pointer to the plaintext to be encrypted.
+	 * @param[out] ct				Pointer to the where the encrypted @a payload
+	 *								will be stored.  Must be @a payload_length
+	 *								octets long.
+	 * @param[out] auth_value		Pointer to where the generated authentication
+	 *								field will be stored. Must be as many octets as
+	 *								indicated by MAC length in the @a function_ctx.
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_gen_encrypt(
+									fsl_shw_uco_t* user_ctx,
+									fsl_shw_acco_t* auth_ctx,
+									fsl_shw_sko_t* cipher_key_info,
+									fsl_shw_sko_t* auth_key_info,
+									uint32_t auth_data_length,
+									const uint8_t* auth_data,
+									uint32_t payload_length,
+									const uint8_t* payload,
+									uint8_t* ct,
+									uint8_t* auth_value);
+	
+	
+	/**
+	 * Perform Authentication-Decryption in Cipher + Hash.
+	 *
+	 * This function will perform a one-shot decryption of a data stream as well as
+	 * authenticate the authentication value.  This is a one-shot function, so all
+	 * of the @a auth_data and the total message @a payload must passed in one
+	 * call.  This also means that the flags in the @a auth_ctx must be
+	 * #FSL_ACCO_CTX_INIT and #FSL_ACCO_CTX_FINALIZE.
+	 *
+	 * @param	   user_ctx 		A user context from #fsl_shw_register_user().
+	 * @param	   auth_ctx 		Controlling object for Authenticate-decrypt.
+	 * @param	   cipher_key_info	The key being used for the cipher part of this
+	 *								operation.	In CCM mode, this key is used for
+	 *								both parts.
+	 * @param	   auth_key_info	The key being used for the authentication part
+	 *								of this operation.	In CCM mode, this key is
+	 *								ignored and may be NULL.
+	 * @param	   auth_data_length Length, in octets, of @a auth_data.
+	 * @param	   auth_data		Data to be authenticated but not decrypted.
+	 * @param	   payload_length	Length, in octets, of @a ct and @a pt.
+	 * @param	   ct				Pointer to the encrypted input stream.
+	 * @param	   auth_value		The (encrypted) authentication value which will
+	 *								be authenticated.  This is the same data as the
+	 *								(output) @a auth_value argument to
+	 *								#fsl_shw_gen_encrypt().
+	 * @param[out] payload			Pointer to where the plaintext resulting from
+	 *								the decryption will be stored.
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_auth_decrypt(
+									fsl_shw_uco_t* user_ctx,
+									fsl_shw_acco_t* auth_ctx,
+									fsl_shw_sko_t* cipher_key_info,
+									fsl_shw_sko_t* auth_key_info,
+									uint32_t auth_data_length,
+									const uint8_t* auth_data,
+									uint32_t payload_length,
+									const uint8_t* ct,
+									const uint8_t* auth_value,
+									uint8_t* payload);
+	
+	
+	/**
+	 * Establish the key in a protected location, either in the system keystore or
+	 * a user keystore.
+	 *
+	 * If the key is established in the system keystore, it can only be used for
+	 * hardware encrypt or decrypt operations.	If a user keystore is used, then
+	 * the user is responsible for setting the correct access permissions on their
+	 * secure partition.  The key will be placed in the system	keystore by
+	 * default, unless the user has called #fsl_shw_sko_set_keystore() to specify a
+	 * user keystore.
+	 *
+	 * This only needs to be used to a) unwrap a key, or b) set up a key which
+	 * could be wrapped with a later call to #fsl_shw_extract_key().  Normal
+	 * cleartext keys can simply be placed into #fsl_shw_sko_t key objects with
+	 * #fsl_shw_sko_set_key() and used directly.
+	 *
+	 * The maximum key size supported for wrapped/unwrapped keys is 32 octets.
+	 * (This is the maximum reasonable key length on Sahara - 32 octets for an HMAC
+	 * key based on SHA-256.)  The key size is determined by the @a key_info.  The
+	 * expected length of @a key can be determined by
+	 * #fsl_shw_sko_calculate_wrapped_size()
+	 *
+	 * The protected key will not be available for use until this operation
+	 * successfully completes.
+	 *
+	 * This feature is not available for all platforms, nor for all algorithms and
+	 * modes.
+	 *
+	 * @param	   user_ctx 		A user context from #fsl_shw_register_user().
+	 * @param[in,out] key_info		The information about the key to be which will
+	 *								be established.  In the create case, the key
+	 *								length must be set.
+	 * @param	   establish_type	How @a key will be interpreted to establish a
+	 *								key for use.
+	 * @param key					If @a establish_type is #FSL_KEY_WRAP_UNWRAP,
+	 *								this is the location of a wrapped key.	If
+	 *								@a establish_type is #FSL_KEY_WRAP_CREATE, this
+	 *								parameter can be @a NULL.  If @a establish_type
+	 *								is #FSL_KEY_WRAP_ACCEPT, this is the location
+	 *								of a plaintext key.
+	 */
+	extern fsl_shw_return_t fsl_shw_establish_key(
+									fsl_shw_uco_t* user_ctx,
+									fsl_shw_sko_t* key_info,
+									fsl_shw_key_wrap_t establish_type,
+									const uint8_t* key);
+	
+	
+	/**
+	 * Wrap a key and retrieve the wrapped value.
+	 *
+	 * A wrapped key is a key that has been cryptographically obscured.  It is
+	 * only able to be used with #fsl_shw_establish_key().
+	 *
+	 * This function will also release the key (see #fsl_shw_release_key()) so
+	 * that it must be re-established before reuse.
+	 *
+	 * This feature is not available for all platforms, nor for all algorithms and
+	 * modes.
+	 *
+	 * @param	   user_ctx 		A user context from #fsl_shw_register_user().
+	 * @param	   key_info 		The information about the key to be deleted.
+	 * @param[out] covered_key		The location to store the wrapped key.
+	 *								(This size is based upon the maximum key size
+	 *								of 32 octets).
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t* user_ctx,
+												fsl_shw_sko_t* key_info,
+												uint8_t* covered_key);
+	
+	
+	/**
+	 * De-establish a key so that it can no longer be accessed.
+	 *
+	 * The key will need to be re-established before it can again be used.
+	 *
+	 * This feature is not available for all platforms, nor for all algorithms and
+	 * modes.
+	 *
+	 * @param	   user_ctx 		A user context from #fsl_shw_register_user().
+	 * @param	   key_info 		The information about the key to be deleted.
+	 *
+	 * @return	  A return code of type #fsl_shw_return_t.
+	 */
+	extern fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t* user_ctx,
+												fsl_shw_sko_t* key_info);
+	
+	/** @} */ /* opfuns */
+	
+	
+	
+	
+	
+	/* Insert example code into the API documentation. */
+	
+	/**
+	 * @example apitest.c
+	 */
+	
+	/**
+	 * @example sym.c
+	 */
+	
+	/**
+	 * @example rand.c
+	 */
+	
+	/**
+	 * @example hash.c
+	 */
+	
+	/**
+	 * @example hmac1.c
+	 */
+	
+	/**
+	 * @example hmac2.c
+	 */
+	
+	/**
+	 * @example gen_encrypt.c
+	 */
+	
+	/**
+	 * @example auth_decrypt.c
+	 */
+	
+	/**
+	 * @example wrapped_key.c
+	 */
+	
+	/**
+	 * @example smalloc.c
+	 */
+	
+	/**
+	 * @example user_keystore.c
 	 */
-	FSL_ACC_MODE_CCM
-} fsl_shw_acc_mode_t;
-
-/*!
- * The operation which controls the behavior of #fsl_shw_establish_key().
- *
- * These values are passed to #fsl_shw_establish_key().
- */
-typedef enum fsl_shw_key_wrap {
-	FSL_KEY_WRAP_CREATE,	/*!< Generate a key from random values. */
-	FSL_KEY_WRAP_ACCEPT,	/*!< Use the provided clear key. */
-	FSL_KEY_WRAP_UNWRAP	/*!< Unwrap a previously wrapped key. */
-} fsl_shw_key_wrap_t;
-
-/* REQ-S2LRD-PINTFC-COA-HCO-001 */
-/*!
- * Flags which control a Hash operation.
- *
- *  These may be combined by ORing them together.  See #fsl_shw_hco_set_flags()
- * and #fsl_shw_hco_clear_flags().
- */
-typedef enum fsl_shw_hash_ctx_flags {
-	FSL_HASH_FLAGS_INIT = 1,	/*!< Context is empty.  Hash is started
-					   from scratch, with a message-processed
-					   count of zero. */
-	FSL_HASH_FLAGS_SAVE = 2,	/*!< Retrieve context from hardware after
-					   hashing.  If used with the
-					   #FSL_HASH_FLAGS_FINALIZE flag, the final
-					   digest value will be saved in the
-					   object. */
-	FSL_HASH_FLAGS_LOAD = 4,	/*!< Place context into hardware before
-					   hashing. */
-	FSL_HASH_FLAGS_FINALIZE = 8,	/*!< PAD message and perform final digest
-					   operation.  If user message is
-					   pre-padded, this flag should not be
-					   used. */
-} fsl_shw_hash_ctx_flags_t;
-
-/*!
- * Flags which control an HMAC operation.
- *
- * These may be combined by ORing them together.  See #fsl_shw_hmco_set_flags()
- * and #fsl_shw_hmco_clear_flags().
- */
-typedef enum fsl_shw_hmac_ctx_flags {
-	FSL_HMAC_FLAGS_INIT = 1,	/*!< Message context is empty.  HMAC is
-					   started from scratch (with key) or from
-					   precompute of inner hash, depending on
-					   whether
-					   #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT is
-					   set. */
-	FSL_HMAC_FLAGS_SAVE = 2,	/*!< Retrieve ongoing context from hardware
-					   after hashing.  If used with the
-					   #FSL_HMAC_FLAGS_FINALIZE flag, the final
-					   digest value (HMAC) will be saved in the
-					   object. */
-	FSL_HMAC_FLAGS_LOAD = 4,	/*!< Place ongoing context into hardware
-					   before hashing. */
-	FSL_HMAC_FLAGS_FINALIZE = 8,	/*!< PAD message and perform final HMAC
-					   operations of inner and outer hashes. */
-	FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT = 16	/*!< This means that the context
-						   contains precomputed inner and outer
-						   hash values. */
-} fsl_shw_hmac_ctx_flags_t;
-
-/*!
- * Flags to control use of the #fsl_shw_scco_t.
- *
- * These may be ORed together to get the desired effect.
- * See #fsl_shw_scco_set_flags() and #fsl_shw_scco_clear_flags()
- */
-typedef enum fsl_shw_sym_ctx_flags {
-	/*!
-	 * Context is empty.  In ARC4, this means that the S-Box needs to be
-	 * generated from the key.  In #FSL_SYM_MODE_CBC mode, this allows an IV of
-	 * zero to be specified.  In #FSL_SYM_MODE_CTR mode, it means that an
-	 * initial CTR value of zero is desired.
-	 */
-	FSL_SYM_CTX_INIT = 1,
-	/*!
-	 * Load context from object into hardware before running cipher.  In
-	 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
-	 */
-	FSL_SYM_CTX_LOAD = 2,
-	/*!
-	 * Save context from hardware into object after running cipher.  In
-	 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
-	 */
-	FSL_SYM_CTX_SAVE = 4,
-	/*!
-	 * Context (SBox) is to be unwrapped and wrapped on each use.
-	 * This flag is unsupported.
-	 * */
-	FSL_SYM_CTX_PROTECT = 8,
-} fsl_shw_sym_ctx_flags_t;
-
-/*!
- * Flags which describe the state of the #fsl_shw_sko_t.
- *
- * These may be ORed together to get the desired effect.
- * See #fsl_shw_sko_set_flags() and #fsl_shw_sko_clear_flags()
- */
-typedef enum fsl_shw_key_flags {
-	FSL_SKO_KEY_IGNORE_PARITY = 1,	/*!< If algorithm is DES or 3DES, do not
-					   validate the key parity bits. */
-	FSL_SKO_KEY_PRESENT = 2,	/*!< Clear key is present in the object. */
-	FSL_SKO_KEY_ESTABLISHED = 4,	/*!< Key has been established for use.  This
-					   feature is not available for all
-					   platforms, nor for all algorithms and
-					   modes. */
-} fsl_shw_key_flags_t;
-
-/*!
- * Type of value which is associated with an established key.
- */
-typedef uint64_t key_userid_t;
-
-/*!
- * Flags which describe the state of the #fsl_shw_acco_t.
- *
- * The @a FSL_ACCO_CTX_INIT and @a FSL_ACCO_CTX_FINALIZE flags, when used
- * together, provide for a one-shot operation.
- */
-typedef enum fsl_shw_auth_ctx_flags {
-	FSL_ACCO_CTX_INIT = 1,	/*!< Initialize Context(s) */
-	FSL_ACCO_CTX_LOAD = 2,	/*!< Load intermediate context(s).
-				   This flag is unsupported. */
-	FSL_ACCO_CTX_SAVE = 4,	/*!< Save intermediate context(s).
-				   This flag is unsupported. */
-	FSL_ACCO_CTX_FINALIZE = 8,	/*!< Create MAC during this operation. */
-	FSL_ACCO_NIST_CCM = 0x10,	/*!< Formatting of CCM input data is
-					   performed by calls to
-					   #fsl_shw_ccm_nist_format_ctr_and_iv() and
-					   #fsl_shw_ccm_nist_update_ctr_and_iv().  */
-} fsl_shw_auth_ctx_flags_t;
-
-/*!
- *  Modulus Selector for CTR modes.
- *
- * The incrementing of the Counter value may be modified by a modulus.  If no
- * modulus is needed or desired for AES, use #FSL_CTR_MOD_128.
- */
-typedef enum fsl_shw_ctr_mod {
-	FSL_CTR_MOD_8,		/*!< Run counter with modulus of 2^8. */
-	FSL_CTR_MOD_16,		/*!< Run counter with modulus of 2^16. */
-	FSL_CTR_MOD_24,		/*!< Run counter with modulus of 2^24. */
-	FSL_CTR_MOD_32,		/*!< Run counter with modulus of 2^32. */
-	FSL_CTR_MOD_40,		/*!< Run counter with modulus of 2^40. */
-	FSL_CTR_MOD_48,		/*!< Run counter with modulus of 2^48. */
-	FSL_CTR_MOD_56,		/*!< Run counter with modulus of 2^56. */
-	FSL_CTR_MOD_64,		/*!< Run counter with modulus of 2^64. */
-	FSL_CTR_MOD_72,		/*!< Run counter with modulus of 2^72. */
-	FSL_CTR_MOD_80,		/*!< Run counter with modulus of 2^80. */
-	FSL_CTR_MOD_88,		/*!< Run counter with modulus of 2^88. */
-	FSL_CTR_MOD_96,		/*!< Run counter with modulus of 2^96. */
-	FSL_CTR_MOD_104,	/*!< Run counter with modulus of 2^104. */
-	FSL_CTR_MOD_112,	/*!< Run counter with modulus of 2^112. */
-	FSL_CTR_MOD_120,	/*!< Run counter with modulus of 2^120. */
-	FSL_CTR_MOD_128		/*!< Run counter with modulus of 2^128. */
-} fsl_shw_ctr_mod_t;
-
-	  /*! @} *//* consgrp */
-
-/******************************************************************************
- * Data Structures
- *****************************************************************************/
-/*! @addtogroup strgrp
-    @{ */
-
-/* REQ-S2LRD-PINTFC-COA-IBO-001 */
-/*!
- * Application Initialization Object
- *
- * This object, the operations on it, and its interaction with the driver are
- * TBD.
- */
-typedef struct fsl_sho_ibo {
-} fsl_sho_ibo_t;
-
-/* REQ-S2LRD-PINTFC-COA-UCO-001 */
-/*!
- * User Context Object
- *
- * This object must be initialized by a call to #fsl_shw_uco_init().  It must
- * then be passed to #fsl_shw_register_user() before it can be used in any
- * calls besides those in @ref ucoops.
- *
- * It contains the user's configuration for the API, for instance whether an
- * operation should block, or instead should call back the user upon completion
- * of the operation.
- *
- * See @ref ucoops for further information.
- */
-typedef struct fsl_shw_uco {	/* fsl_shw_user_context_object */
-} fsl_shw_uco_t;
-
-/* REQ-S2LRD-PINTFC-API-GEN-006  ??  */
-/*!
- * Result Object
- *
- * This object will contain success and failure information about a specific
- * cryptographic request which has been made.
- *
- * No direct access to its members should be made by programs.  Instead, the
- * object should be manipulated using the provided functions.  See @ref rops.
- */
-typedef struct fsl_shw_result {	/* fsl_shw_result */
-} fsl_shw_result_t;
-
-/* REQ-S2LRD-PINTFC-COA-SKO-001 */
-/*!
- * Secret Key Object
- *
- * This object contains a key for a cryptographic operation, and information
- * about its current state, its intended usage, etc.  It may instead contain
- * information about a protected key, or an indication to use a platform-
- * specific secret key.
- *
- * No direct access to its members should be made by programs.  Instead, the
- * object should be manipulated using the provided functions.  See @ref skoops.
- */
-typedef struct fsl_shw_sko {	/* fsl_shw_secret_key_object */
-} fsl_shw_sko_t;
-
-/* REQ-S2LRD-PINTFC-COA-CO-001 */
-/*!
- * Platform Capabilities Object
- *
- * This object will contain information about the cryptographic features of the
- * platform which the program is running on.
- *
- * No direct access to its members should be made by programs.  Instead, the
- * object should be manipulated using the provided functions.
- *
- * See @ref pcoops.
- */
-typedef struct fsl_shw_pco {	/* fsl_shw_platform_capabilities_object */
-} fsl_shw_pco_t;
-
-/* REQ-S2LRD-PINTFC-COA-HCO-001 */
-/*!
- * Hash Context Object
- *
- * This object contains information to control hashing functions.
-
- * No direct access to its members should be made by programs.  Instead, the
- * object should be manipulated using the provided functions.  See @ref hcops.
- */
-typedef struct fsl_shw_hco {	/* fsl_shw_hash_context_object */
-} fsl_shw_hco_t;
-
-/*!
- * HMAC Context Object
- *
- * This object contains information to control HMAC functions.
-
- * No direct access to its members should be made by programs.  Instead, the
- * object should be manipulated using the provided functions.  See @ref hmcops.
- */
-typedef struct fsl_shw_hmco {	/* fsl_shw_hmac_context_object */
-} fsl_shw_hmco_t;
-
-/* REQ-S2LRD-PINTFC-COA-SCCO-001 */
-/*!
- * Symmetric Cipher Context Object
- *
- * This object contains information to control Symmetric Ciphering encrypt and
- * decrypt functions in #FSL_SYM_MODE_STREAM (ARC4), #FSL_SYM_MODE_ECB,
- * #FSL_SYM_MODE_CBC, and #FSL_SYM_MODE_CTR modes and the
- * #fsl_shw_symmetric_encrypt() and #fsl_shw_symmetric_decrypt() functions.
- * CCM mode is controlled with the #fsl_shw_acco_t object.
- *
- * No direct access to its members should be made by programs.  Instead, the
- * object should be manipulated using the provided functions.  See @ref sccops.
- */
-typedef struct fsl_shw_scco {	/* fsl_shw_symmetric_cipher_context_object */
-} fsl_shw_scco_t;
-
-/*!
- * Authenticate-Cipher Context Object
-
- * An object for controlling the function of, and holding information about,
- * data for the authenticate-cipher functions, #fsl_shw_gen_encrypt() and
- * #fsl_shw_auth_decrypt().
- *
- * No direct access to its members should be made by programs.  Instead, the
- * object should be manipulated using the provided functions.  See @ref
- * accoops.
- */
-typedef struct fsl_shw_acco {	/* fsl_shw_authenticate_cipher_context_object */
-} fsl_shw_acco_t;
-	  /*! @} *//* strgrp */
-
-/******************************************************************************
- * Access Macros for Objects
- *****************************************************************************/
-/*! @addtogroup pcoops
-    @{ */
-
-/*!
- * Get FSL SHW API version
- *
- * @param      pc_info   The Platform Capababilities Object to query.
- * @param[out] major     A pointer to where the major version
- *                       of the API is to be stored.
- * @param[out] minor     A pointer to where the minor version
- *                       of the API is to be stored.
- */
-void fsl_shw_pco_get_version(const fsl_shw_pco_t * pc_info,
-			     uint32_t * major, uint32_t * minor);
-
-/*!
- * Get underlying driver version.
- *
- * @param      pc_info   The Platform Capababilities Object to query.
- * @param[out] major     A pointer to where the major version
- *                       of the driver is to be stored.
- * @param[out] minor     A pointer to where the minor version
- *                       of the driver is to be stored.
- */
-void fsl_shw_pco_get_driver_version(const fsl_shw_pco_t * pc_info,
-				    uint32_t * major, uint32_t * minor);
-
-/*!
- * Get list of symmetric algorithms supported.
- *
- * @param pc_info   The Platform Capababilities Object to query.
- * @param[out] algorithms A pointer to where to store the location of
- *                        the list of algorithms.
- * @param[out] algorithm_count A pointer to where to store the number of
- *                             algorithms in the list at @a algorithms.
- */
-void fsl_shw_pco_get_sym_algorithms(const fsl_shw_pco_t * pc_info,
-				    fsl_shw_key_alg_t * algorithms[],
-				    uint8_t * algorithm_count);
-
-/*!
- * Get list of symmetric modes supported.
- *
- * @param pc_info         The Platform Capababilities Object to query.
- * @param[out] modes      A pointer to where to store the location of
- *                        the list of modes.
- * @param[out] mode_count A pointer to where to store the number of
- *                        algorithms in the list at @a modes.
- */
-void fsl_shw_pco_get_sym_modes(const fsl_shw_pco_t * pc_info,
-			       fsl_shw_sym_mode_t * modes[],
-			       uint8_t * mode_count);
-
-/*!
- * Get list of hash algorithms supported.
- *
- * @param pc_info         The Platform Capababilities Object to query.
- * @param[out] algorithms A pointer which will be set to the list of
- *                        algorithms.
- * @param[out] algorithm_count The number of algorithms in the list at @a
- *                             algorithms.
- */
-void fsl_shw_pco_get_hash_algorithms(const fsl_shw_pco_t * pc_info,
-				     fsl_shw_hash_alg_t * algorithms[],
-				     uint8_t * algorithm_count);
-
-/*!
- * Determine whether the combination of a given symmetric algorithm and a given
- * mode is supported.
- *
- * @param pc_info    The Platform Capababilities Object to query.
- * @param algorithm  A Symmetric Cipher algorithm.
- * @param mode       A Symmetric Cipher mode.
- *
- * @return 0 if combination is not supported, non-zero if supported.
- */
-int fsl_shw_pco_check_sym_supported(const fsl_shw_pco_t * pc_info,
-				    fsl_shw_key_alg_t algorithm,
-				    fsl_shw_sym_mode_t mode);
-
-/*!
- * Determine whether a given Encryption-Authentication mode is supported.
- *
- * @param pc_info   The Platform Capababilities Object to query.
- * @param mode       The Authentication mode.
- *
- * @return 0 if mode is not supported, non-zero if supported.
- */
-int fsl_shw_pco_check_auth_supported(const fsl_shw_pco_t * pc_info,
-				     fsl_shw_acc_mode_t mode);
-
-/*!
- * Determine whether Black Keys (key establishment / wrapping) is supported.
- *
- * @param pc_info  The Platform Capababilities Object to query.
- *
- * @return 0 if wrapping is not supported, non-zero if supported.
- */
-int fsl_shw_pco_check_black_key_supported(const fsl_shw_pco_t * pc_info);
-
-	  /*! @} *//* pcoops */
-
-/*! @addtogroup ucoops
-    @{ */
-
-/*!
- * Initialize a User Context Object.
- *
- * This function must be called before performing any other operation with the
- * Object.  It sets the User Context Object to initial values, and set the size
- * of the results pool.  The mode will be set to a default of
- * #FSL_UCO_BLOCKING_MODE.
- *
- * When using non-blocking operations, this sets the maximum number of
- * operations which can be outstanding.  This number includes the counts of
- * operations waiting to start, operation(s) being performed, and results which
- * have not been retrieved.
- *
- * Changes to this value are ignored once user registration has completed.  It
- * should be set to 1 if only blocking operations will ever be performed.
- *
- * @param user_ctx     The User Context object to operate on.
- * @param pool_size    The maximum number of operations which can be
- *                     outstanding.
- */
-void fsl_shw_uco_init(fsl_shw_uco_t * user_ctx, uint16_t pool_size);
-
-/*!
- * Set the User Reference for the User Context.
- *
- * @param user_ctx     The User Context object to operate on.
- * @param reference    A value which will be passed back with a result.
- */
-void fsl_shw_uco_set_reference(fsl_shw_uco_t * user_ctx, uint32_t reference);
-
-/*!
- * Set the callback routine for the User Context.
- *
- * Note that the callback routine may be called when no results are available,
- * and possibly even when no requests are oustanding.
- *
- *
- * @param user_ctx     The User Context object to operate on.
- * @param callback_fn  The function the API will invoke when an operation
- *                     completes.
- */
-void fsl_shw_uco_set_callback(fsl_shw_uco_t * user_ctx,
-			      void (*callback_fn) (fsl_shw_uco_t * uco));
-
-/*!
- * Set flags in the User Context.
- *
- * Turns on the flags specified in @a flags.  Other flags are untouched.
- *
- * @param user_ctx     The User Context object to operate on.
- * @param flags        ORed values from #fsl_shw_user_ctx_flags_t.
- */
-void fsl_shw_uco_set_flags(fsl_shw_uco_t * user_ctx, uint32_t flags);
-
-/*!
- * Clear flags in the User Context.
- *
- * Turns off the flags specified in @a flags.  Other flags are untouched.
- *
- * @param user_ctx     The User Context object to operate on.
- * @param flags        ORed values from #fsl_shw_user_ctx_flags_t.
- */
-void fsl_shw_uco_clear_flags(fsl_shw_uco_t * user_ctx, uint32_t flags);
-
-	  /*! @} *//* ucoops */
-
-/*! @addtogroup rops
-    @{ */
-
-/*!
- * Retrieve the status code from a Result Object.
- *
- * @param result   The result object to query.
- *
- * @return The status of the request.
- */
-fsl_shw_return_t fsl_shw_ro_get_status(fsl_shw_result_t * result);
-
-/*!
- * Retrieve the reference value from a Result Object.
- *
- * @param result   The result object to query.
- *
- * @return The reference associated with the request.
- */
-uint32_t fsl_shw_ro_get_reference(fsl_shw_result_t * result);
-
-	 /* @} *//* rops */
-
-/*! @addtogroup skoops
-    @{ */
-
-/*!
- * Initialize a Secret Key Object.
- *
- * This function must be called before performing any other operation with
- * the Object.
- *
- * @param key_info  The Secret Key Object to be initialized.
- * @param algorithm DES, AES, etc.
- *
- */
-void fsl_shw_sko_init(fsl_shw_sko_t * key_info, fsl_shw_key_alg_t algorithm);
-
-/*!
- * Store a cleartext key in the key object.
- *
- * This has the side effect of setting the #FSL_SKO_KEY_PRESENT flag and
- * resetting the #FSL_SKO_KEY_ESTABLISHED flag.
- *
- * @param key_object   A variable of type #fsl_shw_sko_t.
- * @param key          A pointer to the beginning of the key.
- * @param key_length   The length, in octets, of the key.  The value should be
- *                     appropriate to the key size supported by the algorithm.
- *                     64 octets is the absolute maximum value allowed for this
- *                     call.
- */
-void fsl_shw_sko_set_key(fsl_shw_sko_t * key_object,
-			 const uint8_t * key, uint16_t key_length);
-
-/*!
- * Set a size for the key.
- *
- * This function would normally be used when the user wants the key to be
- * generated from a random source.
- *
- * @param key_object   A variable of type #fsl_shw_sko_t.
- * @param key_length   The length, in octets, of the key.  The value should be
- *                     appropriate to the key size supported by the algorithm.
- *                     64 octets is the absolute maximum value allowed for this
- *                     call.
- */
-void fsl_shw_sko_set_key_length(fsl_shw_sko_t * key_object,
-				uint16_t key_length);
-
-/*!
- * Set the User ID associated with the key.
- *
- * @param key_object   A variable of type #fsl_shw_sko_t.
- * @param userid       The User ID to identify authorized users of the key.
- */
-void fsl_shw_sko_set_user_id(fsl_shw_sko_t * key_object, key_userid_t userid);
-
-/*!
- * Set the establish key handle into a key object.
- *
- * The @a userid field will be used to validate the access to the unwrapped
- * key.  This feature is not available for all platforms, nor for all
- * algorithms and modes.
- *
- * The #FSL_SKO_KEY_ESTABLISHED will be set (and the #FSL_SKO_KEY_PRESENT
- * flag will be cleared).
- *
- * @param key_object   A variable of type #fsl_shw_sko_t.
- * @param userid       The User ID to verify this user is an authorized user of
- *                     the key.
- * @param handle       A @a handle from #fsl_shw_sko_get_established_info.
- */
-void fsl_shw_sko_set_established_info(fsl_shw_sko_t * key_object,
-				      key_userid_t userid, uint32_t handle);
-
-/*!
- * Extract the algorithm from a key object.
- *
- * @param      key_info  The Key Object to be queried.
- * @param[out] algorithm A pointer to the location to store the algorithm.
- */
-void fsl_shw_sko_get_algorithm(const fsl_shw_sko_t * key_info,
-			       fsl_shw_key_alg_t * algorithm);
-
-/*!
- * Retrieve the established-key handle from a key object.
- *
- * @param key_object   A variable of type #fsl_shw_sko_t.
- * @param handle       The location to store the @a handle of the unwrapped
- *                     key.
- */
-void fsl_shw_sko_get_established_info(fsl_shw_sko_t * key_object,
-				      uint32_t * handle);
-
-/*!
- * Determine the size of a wrapped key based upon the cleartext key's length.
- *
- * This function can be used to calculate the number of octets that
- * #fsl_shw_extract_key() will write into the location at @a covered_key.
- *
- * If zero is returned at @a length, this means that the key length in
- * @a key_info is not supported.
- *
- * @param      key_info         Information about a key to be wrapped.
- * @param      length           Location to store the length of a wrapped
- *                              version of the key in @a key_info.
- */
-void fsl_shw_sko_calculate_wrapped_size(const fsl_shw_sko_t * key_info,
-					uint32_t * length);
-
-/*!
- * Set some flags in the key object.
- *
- * Turns on the flags specified in @a flags.  Other flags are untouched.
- *
- * @param key_object   A variable of type #fsl_shw_sko_t.
- * @param flags        (One or more) ORed members of #fsl_shw_key_flags_t which
- *                     are to be set.
- */
-void fsl_shw_sko_set_flags(fsl_shw_sko_t * key_object, uint32_t flags);
-
-/*!
- * Clear some flags in the key object.
- *
- * Turns off the flags specified in @a flags.  Other flags are untouched.
- *
- * @param key_object   A variable of type #fsl_shw_sko_t.
- * @param flags        (One or more) ORed members of #fsl_shw_key_flags_t which
- *                      are to be reset.
- */
-void fsl_shw_sko_clear_flags(fsl_shw_sko_t * key_object, uint32_t flags);
-
-	  /*! @} *//* end skoops */
-
-/*****************************************************************************/
-
-/*! @addtogroup hcops
-    @{ */
-
-/*****************************************************************************/
-/* REQ-S2LRD-PINTFC-API-BASIC-HASH-004 - partially */
-/*!
- * Initialize a Hash Context Object.
- *
- * This function must be called before performing any other operation with the
- * Object.  It sets the current message length and hash algorithm in the hash
- * context object.
- *
- * @param      hash_ctx  The hash context to operate upon.
- * @param      algorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
- *                       #FSL_HASH_ALG_SHA256, etc).
- *
- */
-void fsl_shw_hco_init(fsl_shw_hco_t * hash_ctx, fsl_shw_hash_alg_t algorithm);
-
-/*****************************************************************************/
-/* REQ-S2LRD-PINTFC-API-BASIC-HASH-001 */
-/* REQ-S2LRD-PINTFC-API-BASIC-HASH-002 */
-/*!
- * Get the current hash value and message length from the hash context object.
- *
- * The algorithm must have already been specified.  See #fsl_shw_hco_init().
- *
- * @param      hash_ctx  The hash context to query.
- * @param[out] digest    Pointer to the location of @a length octets where to
- *                       store a copy of the current value of the digest.
- * @param      length    Number of octets of hash value to copy.
- * @param[out] msg_length Pointer to the location to store the number of octets
- *                        already hashed.
- */
-void fsl_shw_hco_get_digest(const fsl_shw_hco_t * hash_ctx, uint8_t * digest,
-			    uint8_t length, uint32_t * msg_length);
-
-/*****************************************************************************/
-/* REQ-S2LRD-PINTFC-API-BASIC-HASH-002 - partially */
-/*!
- * Get the hash algorithm from the hash context object.
- *
- * @param      hash_ctx  The hash context to query.
- * @param[out] algorithm Pointer to where the algorithm is to be stored.
- */
-void fsl_shw_hco_get_info(const fsl_shw_hco_t * hash_ctx,
-			  fsl_shw_hash_alg_t * algorithm);
-
-/*****************************************************************************/
-/* REQ-S2LRD-PINTFC-API-BASIC-HASH-003 */
-/* REQ-S2LRD-PINTFC-API-BASIC-HASH-004 */
-/*!
- * Set the current hash value and message length in the hash context object.
- *
- * The algorithm must have already been specified.  See #fsl_shw_hco_init().
- *
- * @param      hash_ctx  The hash context to operate upon.
- * @param      context   Pointer to buffer of appropriate length to copy into
- *                       the hash context object.
- * @param      msg_length The number of octets of the message which have
- *                        already been hashed.
- *
- */
-void fsl_shw_hco_set_digest(fsl_shw_hco_t * hash_ctx, const uint8_t * context,
-			    uint32_t msg_length);
-
-/*!
- * Set flags in a Hash Context Object.
- *
- * Turns on the flags specified in @a flags.  Other flags are untouched.
- *
- * @param hash_ctx   The hash context to be operated on.
- * @param flags      The flags to be set in the context.  These can be ORed
- *                   members of #fsl_shw_hash_ctx_flags_t.
- */
-void fsl_shw_hco_set_flags(fsl_shw_hco_t * hash_ctx, uint32_t flags);
-
-/*!
- * Clear flags in a Hash Context Object.
- *
- * Turns off the flags specified in @a flags.  Other flags are untouched.
- *
- * @param hash_ctx   The hash context to be operated on.
- * @param flags      The flags to be reset in the context.  These can be ORed
- *                   members of #fsl_shw_hash_ctx_flags_t.
- */
-void fsl_shw_hco_clear_flags(fsl_shw_hco_t * hash_ctx, uint32_t flags);
-
-	  /*! @} *//* end hcops */
-
-/*****************************************************************************/
-
-/*! @addtogroup hmcops
-    @{ */
-
-/*!
- * Initialize an HMAC Context Object.
- *
- * This function must be called before performing any other operation with the
- * Object.  It sets the current message length and hash algorithm in the HMAC
- * context object.
- *
- * @param      hmac_ctx  The HMAC context to operate upon.
- * @param      algorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
- *                       #FSL_HASH_ALG_SHA256, etc).
- *
- */
-void fsl_shw_hmco_init(fsl_shw_hmco_t * hmac_ctx, fsl_shw_hash_alg_t algorithm);
-
-/*!
- * Set flags in an HMAC Context Object.
- *
- * Turns on the flags specified in @a flags.  Other flags are untouched.
- *
- * @param hmac_ctx   The HMAC context to be operated on.
- * @param flags      The flags to be set in the context.  These can be ORed
- *                   members of #fsl_shw_hmac_ctx_flags_t.
- */
-void fsl_shw_hmco_set_flags(fsl_shw_hmco_t * hmac_ctx, uint32_t flags);
-
-/*!
- * Clear flags in an HMAC Context Object.
- *
- * Turns off the flags specified in @a flags.  Other flags are untouched.
- *
- * @param hmac_ctx   The HMAC context to be operated on.
- * @param flags      The flags to be reset in the context.  These can be ORed
- *                   members of #fsl_shw_hmac_ctx_flags_t.
- */
-void fsl_shw_hmco_clear_flags(fsl_shw_hmco_t * hmac_ctx, uint32_t flags);
-
-/*! @} */
-
-/*****************************************************************************/
-
-/*! @addtogroup sccops
-    @{ */
-
-/*!
- * Initialize a Symmetric Cipher Context Object.
- *
- * This function must be called before performing any other operation with the
- * Object.  This will set the @a mode and @a algorithm and initialize the
- * Object.
- *
- * @param sym_ctx   The context object to operate on.
- * @param algorithm The cipher algorithm this context will be used with.
- * @param mode      #FSL_SYM_MODE_CBC, #FSL_SYM_MODE_ECB, etc.
- *
- */
-void fsl_shw_scco_init(fsl_shw_scco_t * sym_ctx,
-		       fsl_shw_key_alg_t algorithm, fsl_shw_sym_mode_t mode);
-
-/*!
- * Set the flags for a Symmetric Cipher Context.
- *
- * Turns on the flags specified in @a flags.  Other flags are untouched.
- *
- * @param sym_ctx  The context object to operate on.
- * @param flags    The flags to reset (one or more values from
- *                 #fsl_shw_sym_ctx_flags_t ORed together).
- *
- */
-void fsl_shw_scco_set_flags(fsl_shw_scco_t * sym_ctx, uint32_t flags);
-
-/*!
- * Clear some flags in a Symmetric Cipher Context Object.
- *
- * Turns off the flags specified in @a flags.  Other flags are untouched.
- *
- * @param sym_ctx  The context object to operate on.
- * @param flags    The flags to reset (one or more values from
- *                 #fsl_shw_sym_ctx_flags_t ORed together).
- *
- */
-void fsl_shw_scco_clear_flags(fsl_shw_scco_t * sym_ctx, uint32_t flags);
-
-/*!
- * Set the Context (IV) for a Symmetric Cipher Context.
- *
- * This is to set the context/IV for #FSL_SYM_MODE_CBC mode, or to set the
- * context (the S-Box and pointers) for ARC4.  The full context size will
- * be copied.
- *
- * @param sym_ctx  The context object to operate on.
- * @param context  A pointer to the buffer which contains the context.
- *
- */
-void fsl_shw_scco_set_context(fsl_shw_scco_t * sym_ctx, uint8_t * context);
-
-/*!
- * Get the Context for a Symmetric Cipher Context.
- *
- * This is to retrieve the context/IV for #FSL_SYM_MODE_CBC mode, or to
- * retrieve context (the S-Box and pointers) for ARC4.  The full context
- * will be copied.
- *
- * @param      sym_ctx  The context object to operate on.
- * @param[out] context  Pointer to location where context will be stored.
- */
-void fsl_shw_scco_get_context(const fsl_shw_scco_t * sym_ctx,
-			      uint8_t * context);
-
-/*!
- * Set the Counter Value for a Symmetric Cipher Context.
- *
- * This will set the Counter Value for CTR mode.
- *
- * @param sym_ctx  The context object to operate on.
- * @param counter  The starting counter value.  The number of octets.
- *                 copied will be the block size for the algorithm.
- * @param modulus  The modulus for controlling the incrementing of the counter.
- *
- */
-void fsl_shw_scco_set_counter_info(fsl_shw_scco_t * sym_ctx,
-				   const uint8_t * counter,
-				   fsl_shw_ctr_mod_t modulus);
-
-/*!
- * Get the Counter Value for a Symmetric Cipher Context.
- *
- * This will retrieve the Counter Value is for CTR mode.
- *
- * @param sym_ctx         The context object to query.
- * @param[out] counter    Pointer to location to store the current counter
- *                        value.  The number of octets copied will be the
- *                        block size for the algorithm.
- * @param[out] modulus    Pointer to location to store the modulus.
- *
- */
-void fsl_shw_scco_get_counter_info(const fsl_shw_scco_t * sym_ctx,
-				   uint8_t * counter,
-				   fsl_shw_ctr_mod_t * modulus);
-
-	  /*! @} *//* end sccops */
-
-/*****************************************************************************/
-
-/*! @addtogroup accoops
-    @{ */
-
-/*!
- * Initialize a Authentication-Cipher Context.
- *
- * @param auth_object  Pointer to object to operate on.
- * @param mode         The mode for this object (only #FSL_ACC_MODE_CCM
- *                     supported).
- */
-void fsl_shw_acco_init(fsl_shw_acco_t * auth_object, fsl_shw_acc_mode_t mode);
-
-/*!
- * Set the flags for a Authentication-Cipher Context.
- *
- * Turns on the flags specified in @a flags.  Other flags are untouched.
- *
- * @param auth_object  Pointer to object to operate on.
- * @param flags        The flags to set (one or more from
- *                     #fsl_shw_auth_ctx_flags_t ORed together).
- *
- */
-void fsl_shw_acco_set_flags(fsl_shw_acco_t * auth_object, uint32_t flags);
-
-/*!
- * Clear some flags in a Authentication-Cipher Context Object.
- *
- * Turns off the flags specified in @a flags.  Other flags are untouched.
- *
- * @param auth_object  Pointer to object to operate on.
- * @param flags        The flags to reset (one or more from
- *                     #fsl_shw_auth_ctx_flags_t ORed together).
- *
- */
-void fsl_shw_acco_clear_flags(fsl_shw_acco_t * auth_object, uint32_t flags);
-
-/*!
- * Set up the Authentication-Cipher Object for CCM mode.
- *
- * This will set the @a auth_object for CCM mode and save the @a ctr,
- * and @a mac_length.  This function can be called instead of
- * #fsl_shw_acco_init().
- *
- * The paramater @a ctr is Counter Block 0, (counter value 0), which is for the
- * MAC.
- *
- * @param auth_object  Pointer to object to operate on.
- * @param algorithm    Cipher algorithm.  Only AES is supported.
- * @param ctr          The initial counter value.
- * @param mac_length   The number of octets used for the MAC.  Valid values are
- *                     4, 6, 8, 10, 12, 14, and 16.
- */
-void fsl_shw_acco_set_ccm(fsl_shw_acco_t * auth_object,
-			  fsl_shw_key_alg_t algorithm,
-			  const uint8_t * ctr, uint8_t mac_length);
-
-/*!
- * Format the First Block (IV) & Initial Counter Value per NIST CCM.
- *
- * This function will also set the IV and CTR values per Appendix A of NIST
- * Special Publication 800-38C (May 2004).  It will also perform the
- * #fsl_shw_acco_set_ccm() operation with information derived from this set of
- * parameters.
- *
- * Note this function assumes the algorithm is AES.  It initializes the
- * @a auth_object by setting the mode to #FSL_ACC_MODE_CCM and setting the
- * flags to be #FSL_ACCO_NIST_CCM.
- *
- * @param auth_object  Pointer to object to operate on.
- * @param t_length     The number of octets used for the MAC.  Valid values are
- *                     4, 6, 8, 10, 12, 14, and 16.
- * @param ad_length    Number of octets of Associated Data (may be zero).
- * @param q_length     A value for the size of the length of @a q field.  Valid
- *                     values are 1-8.
- * @param n            The Nonce (packet number or other changing value). Must
- *                     be (15 - @a q_length) octets long.
- * @param q            The value of Q (size of the payload in octets).
- *
- */
-void fsl_shw_ccm_nist_format_ctr_and_iv(fsl_shw_acco_t * auth_object,
-					uint8_t t_length,
-					uint32_t ad_length,
-					uint8_t q_length,
-					const uint8_t * n, uint32_t q);
-
-/*!
- * Update the First Block (IV) & Initial Counter Value per NIST CCM.
- *
- * This function will set the IV and CTR values per Appendix A of NIST Special
- * Publication 800-38C (May 2004).
- *
- * Note this function assumes that #fsl_shw_ccm_nist_format_ctr_and_iv() has
- * previously been called on the @a auth_object.
- *
- * @param auth_object  Pointer to object to operate on.
- * @param n             The Nonce (packet number or other changing value). Must
- *                      be (15 - @a q_length) octets long.
- * @param q             The value of Q (size of the payload in octets).
- *
- */
-void fsl_shw_ccm_nist_update_ctr_and_iv(fsl_shw_acco_t * auth_object,
-					const uint8_t * n, uint32_t q);
-
-	 /* @} *//* accoops */
-
-/******************************************************************************
- * Library functions
- *****************************************************************************/
-
-/*! @addtogroup miscfuns
-    @{ */
-
-/* REQ-S2LRD-PINTFC-API-GEN-003 */
-/*!
- * Determine the hardware security capabilities of this platform.
- *
- * Though a user context object is passed into this function, it will always
- * act in a non-blocking manner.
- *
- * @param  user_ctx   The user context which will be used for the query.
- *
- * @return  A pointer to the capabilities object.
- */
-extern fsl_shw_pco_t *fsl_shw_get_capabilities(fsl_shw_uco_t * user_ctx);
-
-/* REQ-S2LRD-PINTFC-API-GEN-004 */
-/*!
- * Create an association between the the user and the provider of the API.
- *
- * @param  user_ctx   The user context which will be used for this association.
- *
- * @return    A return code of type #fsl_shw_return_t.
- */
-extern fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t * user_ctx);
-
-/* REQ-S2LRD-PINTFC-API-GEN-005 */
-/*!
- * Destroy the association between the the user and the provider of the API.
- *
- * @param  user_ctx   The user context which is no longer needed.
- *
- * @return    A return code of type #fsl_shw_return_t.
- */
-extern fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t * user_ctx);
-
-/* REQ-S2LRD-PINTFC-API-GEN-006 */
-/*!
- * Retrieve results from earlier operations.
- *
- * @param         user_ctx     The user's context.
- * @param         result_size  The number of array elements of @a results.
- * @param[in,out] results      Pointer to first of the (array of) locations to
- *                             store results.
- * @param[out]    result_count Pointer to store the number of results which
- *                             were returned.
- *
- * @return    A return code of type #fsl_shw_return_t.
- */
-extern fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t * user_ctx,
-					    uint16_t result_size,
-					    fsl_shw_result_t results[],
-					    uint16_t * result_count);
-
-	  /*! @} *//* miscfuns */
-
-/*! @addtogroup opfuns
-    @{ */
-
-/* REQ-S2LRD-PINTFC-API-BASIC-SYM-002 */
-/* PINTFC-API-BASIC-SYM-ARC4-001 */
-/* PINTFC-API-BASIC-SYM-ARC4-002 */
-/*!
- * Encrypt a stream of data with a symmetric-key algorithm.
- *
- * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
- * flags of the @a sym_ctx object will control part of the operation of this
- * function.  The #FSL_SYM_CTX_INIT flag means that there is no context info in
- * the object.  The #FSL_SYM_CTX_LOAD means to use information in the
- * @a sym_ctx at the start of the operation, and the #FSL_SYM_CTX_SAVE flag
- * means to update the object's context information after the operation has
- * been performed.
- *
- * All of the data for an operation can be run through at once using the
- * #FSL_SYM_CTX_INIT or #FSL_SYM_CTX_LOAD flags, as appropriate, and then using
- * a @a length for the whole of the data.
- *
- * If a #FSL_SYM_CTX_SAVE flag were added, an additional call to the function
- * would "pick up" where the previous call left off, allowing the user to
- * perform the larger function in smaller steps.
- *
- * In #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_ECB modes, the @a length must always
- * be a multiple of the block size for the algorithm being used.  For proper
- * operation in #FSL_SYM_MODE_CTR mode, the @a length must be a multiple of the
- * block size until the last operation on the total octet stream.
- *
- * Some users of ARC4 may want to compute the context (S-Box and pointers) from
- * the key before any data is available.  This may be done by running this
- * function with a @a length of zero, with the init & save flags flags on in
- * the @a sym_ctx.  Subsequent operations would then run as normal with the
- * load and save flags.  Note that they key object is still required.
- *
- * @param         user_ctx  A user context from #fsl_shw_register_user().
- * @param         key_info  Key and algorithm  being used for this operation.
- * @param[in,out] sym_ctx   Info on cipher mode, state of the cipher.
- * @param         length   Length, in octets, of the pt (and ct).
- * @param         pt       pointer to plaintext to be encrypted.
- * @param[out]    ct       pointer to where to store the resulting ciphertext.
- *
- * @return    A return code of type #fsl_shw_return_t.
- *
- */
-extern fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
-						  fsl_shw_sko_t * key_info,
-						  fsl_shw_scco_t * sym_ctx,
-						  uint32_t length,
-						  const uint8_t * pt,
-						  uint8_t * ct);
-
-/* PINTFC-API-BASIC-SYM-002 */
-/* PINTFC-API-BASIC-SYM-ARC4-001 */
-/* PINTFC-API-BASIC-SYM-ARC4-002 */
-/*!
- * Decrypt a stream of data with a symmetric-key algorithm.
- *
- * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
- * flags of the @a sym_ctx object will control part of the operation of this
- * function.  The #FSL_SYM_CTX_INIT flag means that there is no context info in
- * the object.  The #FSL_SYM_CTX_LOAD means to use information in the
- * @a sym_ctx at the start of the operation, and the #FSL_SYM_CTX_SAVE flag
- * means to update the object's context information after the operation has
- * been performed.
- *
- * All of the data for an operation can be run through at once using the
- * #FSL_SYM_CTX_INIT or #FSL_SYM_CTX_LOAD flags, as appropriate, and then using
- * a @a length for the whole of the data.
- *
- * If a #FSL_SYM_CTX_SAVE flag were added, an additional call to the function
- * would "pick up" where the previous call left off, allowing the user to
- * perform the larger function in smaller steps.
- *
- * In #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_ECB modes, the @a length must always
- * be a multiple of the block size for the algorithm being used.  For proper
- * operation in #FSL_SYM_MODE_CTR mode, the @a length must be a multiple of the
- * block size until the last operation on the total octet stream.
- *
- * Some users of ARC4 may want to compute the context (S-Box and pointers) from
- * the key before any data is available.  This may be done by running this
- * function with a @a length of zero, with the #FSL_SYM_CTX_INIT &
- * #FSL_SYM_CTX_SAVE flags on in the @a sym_ctx.  Subsequent operations would
- * then run as normal with the load & save flags.  Note that they key object is
- * still required.
- *
- * @param      user_ctx  A user context from #fsl_shw_register_user().
- * @param      key_info The key and algorithm being used in this operation.
- * @param[in,out] sym_ctx Info on cipher mode, state of the cipher.
- * @param      length   Length, in octets, of the ct (and pt).
- * @param      ct       pointer to ciphertext to be decrypted.
- * @param[out] pt       pointer to where to store the resulting plaintext.
- *
- * @return    A return code of type #fsl_shw_return_t
- *
- */
-extern fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t * user_ctx,
-						  fsl_shw_sko_t * key_info,
-						  fsl_shw_scco_t * sym_ctx,
-						  uint32_t length,
-						  const uint8_t * ct,
-						  uint8_t * pt);
-
-/* REQ-S2LRD-PINTFC-API-BASIC-HASH-005 */
-/*!
- * Hash a stream of data with a cryptographic hash algorithm.
- *
- * The flags in the @a hash_ctx control the operation of this function.
- *
- * Hashing functions work on 64 octets of message at a time.  Therefore, when
- * any partial hashing of a long message is performed, the message @a length of
- * each segment must be a multiple of 64.  When ready to
- * #FSL_HASH_FLAGS_FINALIZE the hash, the @a length may be any value.
- *
- * With the #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_FINALIZE flags on, a
- * one-shot complete hash, including padding, will be performed.  The @a length
- * may be any value.
- *
- * The first octets of a data stream can be hashed by setting the
- * #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_SAVE flags.  The @a length must be
- * a multiple of 64.
- *
- * The flag #FSL_HASH_FLAGS_LOAD is used to load a context previously saved by
- * #FSL_HASH_FLAGS_SAVE.  The two in combination will allow a (multiple-of-64
- * octets) 'middle sequence' of the data stream to be hashed with the
- * beginning.  The @a length must again be a multiple of 64.
- *
- * Since the flag #FSL_HASH_FLAGS_LOAD is used to load a context previously
- * saved by #FSL_HASH_FLAGS_SAVE, the #FSL_HASH_FLAGS_LOAD and
- * #FSL_HASH_FLAGS_FINALIZE flags, used together, can be used to finish the
- * stream.  The @a length may be any value.
- *
- * If the user program wants to do the padding for the hash, it can leave off
- * the #FSL_HASH_FLAGS_FINALIZE flag.  The @a length must then be a multiple of
- * 64 octets.
- *
- * @param      user_ctx  A user context from #fsl_shw_register_user().
- * @param[in,out] hash_ctx Hashing algorithm and state of the cipher.
- * @param      msg       Pointer to the data to be hashed.
- * @param      length    Length, in octets, of the @a msg.
- * @param[out] result    If not null, pointer to where to store the hash
- *                       digest.
- * @param      result_len Number of octets to store in @a result.
- *
- * @return    A return code of type #fsl_shw_return_t.
- */
-extern fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t * user_ctx,
-				     fsl_shw_hco_t * hash_ctx,
-				     const uint8_t * msg,
-				     uint32_t length,
-				     uint8_t * result, uint32_t result_len);
-
-/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-001 */
-/*!
- * Precompute the Key hashes for an HMAC operation.
- *
- * This function may be used to calculate the inner and outer precomputes,
- * which are the hash contexts resulting from hashing the XORed key for the
- * 'inner hash' and the 'outer hash', respectively, of the HMAC function.
- *
- * After execution of this function, the @a hmac_ctx will contain the
- * precomputed inner and outer contexts, so that they may be used by
- * #fsl_shw_hmac().  The flags of @a hmac_ctx will be updated with
- * #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT to mark their presence.  In addtion, the
- * #FSL_HMAC_FLAGS_INIT flag will be set.
- *
- * @param      user_ctx  A user context from #fsl_shw_register_user().
- * @param      key_info  The key being used in this operation.  Key must be
- *                       1 to 64 octets long.
- * @param[in,out] hmac_ctx The context which controls, by its flags and
- *                         algorithm, the operation of this function.
- * @return    A return code of type #fsl_shw_return_t.
- */
-extern fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t * user_ctx,
-						fsl_shw_sko_t * key_info,
-						fsl_shw_hmco_t * hmac_ctx);
-
-/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-002 */
-/*!
- * Continue, finalize, or one-shot an HMAC operation.
- *
- * There are a number of ways to use this function.  The flags in the
- * @a hmac_ctx object will determine what operations occur.
- *
- * If #FSL_HMAC_FLAGS_INIT is set, then the hash will be started either from
- * the @a key_info, or from the precomputed inner hash value in the
- * @a hmac_ctx, depending on the value of #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT.
- *
- * If, instead, #FSL_HMAC_FLAGS_LOAD is set, then the hash will be continued
- * from the ongoing inner hash computation in the @a hmac_ctx.
- *
- * If #FSL_HMAC_FLAGS_FINALIZE are set, then the @a msg will be padded, hashed,
- * the outer hash will be performed, and the @a result will be generated.
- *
- * If the #FSL_HMAC_FLAGS_SAVE flag is set, then the (ongoing or final) digest
- * value will be stored in the ongoing inner hash computation field of the @a
- * hmac_ctx.
- *
- * @param      user_ctx  A user context from #fsl_shw_register_user().
- * @param key_info       If #FSL_HMAC_FLAGS_INIT is set in the @a hmac_ctx,
- *                       this is the key being used in this operation, and the
- *                       IPAD.  If #FSL_HMAC_FLAGS_INIT is set in the @a
- *                       hmac_ctx and @a key_info is NULL, then
- *                       #fsl_shw_hmac_precompute() has been used to populate
- *                       the @a inner_precompute and @a outer_precompute
- *                       contexts.  If #FSL_HMAC_FLAGS_INIT is not set, this
- *                       parameter is ignored.
-
- * @param[in,out] hmac_ctx The context which controls, by its flags and
- *                       algorithm, the operation of this function.
- * @param      msg               Pointer to the message to be hashed.
- * @param      length            Length, in octets, of the @a msg.
- * @param[out] result            Pointer, of @a result_len octets, to where to
- *                               store the HMAC.
- * @param      result_len        Length of @a result buffer.
- *
- * @return    A return code of type #fsl_shw_return_t.
- */
-extern fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t * user_ctx,
-				     fsl_shw_sko_t * key_info,
-				     fsl_shw_hmco_t * hmac_ctx,
-				     const uint8_t * msg,
-				     uint32_t length,
-				     uint8_t * result, uint32_t result_len);
-
-/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
-/*!
- * Get random data.
- *
- * @param      user_ctx  A user context from #fsl_shw_register_user().
- * @param      length    The number of octets of @a data being requested.
- * @param[out] data      A pointer to a location of @a length octets to where
- *                       random data will be returned.
- *
- * @return    A return code of type #fsl_shw_return_t.
- */
-extern fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx,
-					   uint32_t length, uint8_t * data);
-
-/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
-/*!
- * Add entropy to random number generator.
- *
- * @param      user_ctx  A user context from #fsl_shw_register_user().
- * @param      length    Number of bytes at @a data.
- * @param      data      Entropy to add to random number generator.
- *
- * @return    A return code of type #fsl_shw_return_t.
- */
-extern fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx,
-					    uint32_t length, uint8_t * data);
-
-/*!
- * Perform Generation-Encryption by doing a Cipher and a Hash.
- *
- * Generate the authentication value @a auth_value as well as encrypt the @a
- * payload into @a ct (the ciphertext).  This is a one-shot function, so all of
- * the @a auth_data and the total message @a payload must passed in one call.
- * This also means that the flags in the @a auth_ctx must be #FSL_ACCO_CTX_INIT
- * and #FSL_ACCO_CTX_FINALIZE.
- *
- * @param      user_ctx         A user context from #fsl_shw_register_user().
- * @param      auth_ctx         Controlling object for Authenticate-decrypt.
- * @param      cipher_key_info  The key being used for the cipher part of this
- *                              operation.  In CCM mode, this key is used for
- *                              both parts.
- * @param      auth_key_info    The key being used for the authentication part
- *                              of this operation.  In CCM mode, this key is
- *                              ignored and may be NULL.
- * @param      auth_data_length Length, in octets, of @a auth_data.
- * @param      auth_data        Data to be authenticated but not encrypted.
- * @param      payload_length   Length, in octets, of @a payload.
- * @param      payload          Pointer to the plaintext to be encrypted.
- * @param[out] ct               Pointer to the where the encrypted @a payload
- *                              will be stored.  Must be @a payload_length
- *                              octets long.
- * @param[out] auth_value       Pointer to where the generated authentication
- *                              field will be stored. Must be as many octets as
- *                              indicated by MAC length in the @a function_ctx.
- * @return    A return code of type #fsl_shw_return_t.
- */
-extern fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
-					    fsl_shw_acco_t * auth_ctx,
-					    fsl_shw_sko_t * cipher_key_info,
-					    fsl_shw_sko_t * auth_key_info,
-					    uint32_t auth_data_length,
-					    const uint8_t * auth_data,
-					    uint32_t payload_length,
-					    const uint8_t * payload,
-					    uint8_t * ct, uint8_t * auth_value);
-
-/*!
- * Perform Authentication-Decryption in Cipher + Hash.
- *
- * This function will perform a one-shot decryption of a data stream as well as
- * authenticate the authentication value.  This is a one-shot function, so all
- * of the @a auth_data and the total message @a payload must passed in one
- * call.  This also means that the flags in the @a auth_ctx must be
- * #FSL_ACCO_CTX_INIT and #FSL_ACCO_CTX_FINALIZE.
- *
- * @param      user_ctx         A user context from #fsl_shw_register_user().
- * @param      auth_ctx         Controlling object for Authenticate-decrypt.
- * @param      cipher_key_info  The key being used for the cipher part of this
- *                              operation.  In CCM mode, this key is used for
- *                              both parts.
- * @param      auth_key_info    The key being used for the authentication part
- *                              of this operation.  In CCM mode, this key is
- *                              ignored and may be NULL.
- * @param      auth_data_length Length, in octets, of @a auth_data.
- * @param      auth_data        Data to be authenticated but not decrypted.
- * @param      payload_length   Length, in octets, of @a ct and @a pt.
- * @param      ct               Pointer to the encrypted input stream.
- * @param      auth_value       The (encrypted) authentication value which will
- *                              be authenticated.  This is the same data as the
- *                              (output) @a auth_value argument to
- *                              #fsl_shw_gen_encrypt().
- * @param[out] payload          Pointer to where the plaintext resulting from
- *                              the decryption will be stored.
- *
- * @return    A return code of type #fsl_shw_return_t.
- */
-extern fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
-					     fsl_shw_acco_t * auth_ctx,
-					     fsl_shw_sko_t * cipher_key_info,
-					     fsl_shw_sko_t * auth_key_info,
-					     uint32_t auth_data_length,
-					     const uint8_t * auth_data,
-					     uint32_t payload_length,
-					     const uint8_t * ct,
-					     const uint8_t * auth_value,
-					     uint8_t * payload);
-
-/*!
- * Place a key into a protected location for use only by cryptographic
- * algorithms.
- *
- * This only needs to be used to a) unwrap a key, or b) set up a key which
- * could be wrapped with a later call to #fsl_shw_extract_key().  Normal
- * cleartext keys can simply be placed into #fsl_shw_sko_t key objects with
- * #fsl_shw_sko_set_key() and used directly.
- *
- * The maximum key size supported for wrapped/unwrapped keys is 32 octets.
- * (This is the maximum reasonable key length on Sahara - 32 octets for an HMAC
- * key based on SHA-256.)  The key size is determined by the @a key_info.  The
- * expected length of @a key can be determined by
- * #fsl_shw_sko_calculate_wrapped_size()
- *
- * The protected key will not be available for use until this operation
- * successfully completes.
- *
- * This feature is not available for all platforms, nor for all algorithms and
- * modes.
- *
- * @param      user_ctx         A user context from #fsl_shw_register_user().
- * @param[in,out] key_info      The information about the key to be which will
- *                              be established.  In the create case, the key
- *                              length must be set.
- * @param      establish_type   How @a key will be interpreted to establish a
- *                              key for use.
- * @param key                   If @a establish_type is #FSL_KEY_WRAP_UNWRAP,
- *                              this is the location of a wrapped key.  If
- *                              @a establish_type is #FSL_KEY_WRAP_CREATE, this
- *                              parameter can be @a NULL.  If @a establish_type
- *                              is #FSL_KEY_WRAP_ACCEPT, this is the location
- *                              of a plaintext key.
- */
-extern fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
-					      fsl_shw_sko_t * key_info,
-					      fsl_shw_key_wrap_t establish_type,
-					      const uint8_t * key);
-
-/*!
- * Wrap a key and retrieve the wrapped value.
- *
- * A wrapped key is a key that has been cryptographically obscured.  It is
- * only able to be used with #fsl_shw_establish_key().
- *
- * This function will also release the key (see #fsl_shw_release_key()) so
- * that it must be re-established before reuse.
- *
- * This feature is not available for all platforms, nor for all algorithms and
- * modes.
- *
- * @param      user_ctx         A user context from #fsl_shw_register_user().
- * @param      key_info         The information about the key to be deleted.
- * @param[out] covered_key      The location to store the wrapped key.
- *                              (This size is based upon the maximum key size
- *                              of 32 octets).
- *
- * @return    A return code of type #fsl_shw_return_t.
- */
-extern fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
-					    fsl_shw_sko_t * key_info,
-					    uint8_t * covered_key);
-
-/*!
- * De-establish a key so that it can no longer be accessed.
- *
- * The key will need to be re-established before it can again be used.
- *
- * This feature is not available for all platforms, nor for all algorithms and
- * modes.
- *
- * @param      user_ctx         A user context from #fsl_shw_register_user().
- * @param      key_info         The information about the key to be deleted.
- *
- * @return    A return code of type #fsl_shw_return_t.
- */
-extern fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
-					    fsl_shw_sko_t * key_info);
-
-	  /*! @} *//* opfuns */
-
-/* Insert example code into the API documentation. */
-
-/*!
- * @example apitest.c
- */
-
-/*!
- * @example sym.c
- */
-
-/*!
- * @example rand.c
- */
-
-/*!
- * @example hash.c
- */
-
-/*!
- * @example hmac1.c
- */
-
-/*!
- * @example hmac2.c
- */
-
-/*!
- * @example gen_encrypt.c
- */
-
-/*!
- * @example auth_decrypt.c
- */
 
-/*!
- * @example wrapped_key.c
- */
 
 #endif				/* API_DOC */
 
+
 #endif				/* FSL_SHW_H */
diff --git a/drivers/mxc/security/sahara2/include/fsl_shw_keystore.h b/drivers/mxc/security/sahara2/include/fsl_shw_keystore.h
new file mode 100644
index 0000000..d182a80
--- /dev/null
+++ b/drivers/mxc/security/sahara2/include/fsl_shw_keystore.h
@@ -0,0 +1,470 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+#ifndef FSL_SHW_KEYSTORE_H
+#define FSL_SHW_KEYSTORE_H
+
+
+/**
+ * @file fsl_shw_keystore.h
+ *
+ * @brief Definition of the User Keystore API.
+ *
+ */
+
+/** \page user_keystore User Keystore API
+ *
+ * Definition of the User Keystore API.
+ *
+ * On platforms with multiple partitions of Secure Memory, the Keystore Object 
+ * (#fsl_shw_kso_t) is provided to allow users to manage a private keystore for
+ * use in software cryptographic routines.  The user can define a custom set of
+ * methods for managing their keystore, or use a default keystore handler.  The
+ * keystore is established by #fsl_shw_establish_keystore(), and released by
+ * #fsl_shw_release_keystore().  The intent of this design is to make the
+ * keystore implementation as flexible as possible.
+ *
+ * See @ref keystore_api for the generic keystore API, and @ref
+ * default_keystore for the default keystore implementation.
+ *
+ */
+
+/**
+ * @defgroup keystore_api User Keystore API
+ *
+ * Keystore API
+ *
+ * These functions define the generic keystore API, which can be used in 
+ * conjunction with a keystore implementation backend to support a user
+ * keystore.
+ */
+
+/**
+ * @defgroup default_keystore Default Keystore Implementation
+ *
+ * Default Keystore Implementation
+ *
+ * These functions define the default keystore implementation, which is used
+ * for the system keystore and for user keystores initialized by 
+ * #fsl_shw_init_keystore_default().  They can be used as-is or as a reference
+ * for creating a custom keystore handler.  It uses an entire Secure Memory
+ * partition, divided in to equal slots of length #KEYSTORE_SLOT_SIZE.  These
+ * functions are not intended to be used directly-  all user interaction with
+ * the keystore should be through the @ref keystore_api and the Wrapped Key
+ * interface.
+ *
+ * The current implementation is designed to work with both SCC and SCC2.
+ * Differences between the two versions are noted below.
+ */
+
+
+
+/** @addtogroup keystore_api
+    @{ */
+
+#ifndef KEYSTORE_SLOT_SIZE
+/** Size of each key slot, in octets.  This sets an upper bound on the size
+ * of a key that can placed in the keystore.
+ */
+#define KEYSTORE_SLOT_SIZE 32
+#endif
+
+
+/**
+ * Initialize a Keystore Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object. It allows the user to associate a custom keystore interface by
+ * specifying the correct set of functions that will be used to perform actions
+ * on the keystore object.  To use the default keystore handler, the function
+ * #fsl_shw_init_keystore_default() can be used instead.
+ *
+ * @param keystore      The Keystore object to operate on.
+ * @param data_init     Keystore initialization function.  This function is
+ *                      responsible for initializing the keystore.  A
+ *                      user-defined object can be assigned to the user_data
+ *                      pointer, and will be passed to any function acting on
+ *                      that keystore.  It is called during
+ *                      #fsl_shw_establish_keystore().
+ * @param data_cleanup  Keystore cleanup function.  This function cleans up
+ *                      any data structures associated with the keyboard.  It
+ *                      is called by #fsl_shw_release_keystore().
+ * @param slot_alloc    Slot allocation function.  This function allocates a
+ *                      key slot, potentially based on size and owner id.  It
+ *                      is called by #fsl_shw_establish_key().
+ * @param slot_dealloc  Slot deallocation function.
+ * @param slot_verify_access Function to verify that a given Owner ID
+ *                           credential matches the given slot.
+ * @param slot_get_address   For SCC2: Get the virtual address (kernel or
+ *                           userspace) of the data stored in the slot.
+ *                           For SCC: Get the physical address of the data
+ *                           stored in the slot.
+ * @param slot_get_base      For SCC2: Get the (virtual) base address of the
+ *                           partition that the slot is located on.
+ *                           For SCC: Not implemented.
+ * @param slot_get_offset    For SCC2: Get the offset from the start of the
+ *                           partition that the slot data is located at (in
+ *                           octets)
+ *                           For SCC: Not implemented.
+ * @param slot_get_slot_size Get the size of the key slot, in octets.
+ */
+extern void fsl_shw_init_keystore(
+    fsl_shw_kso_t *keystore,
+    fsl_shw_return_t (*data_init)        (fsl_shw_uco_t *user_ctx,
+                                          void **user_data),
+    void             (*data_cleanup)     (fsl_shw_uco_t *user_ctx,
+                                          void **user_data),
+    fsl_shw_return_t (*slot_alloc)       (void *user_data, uint32_t size,
+                                          uint64_t owner_id, uint32_t *slot),
+    fsl_shw_return_t (*slot_dealloc)     (void *user_data,
+                                          uint64_t owner_id, uint32_t slot),
+    fsl_shw_return_t (*slot_verify_access)(void *user_data,
+                                          uint64_t owner_id, uint32_t slot),
+    void*            (*slot_get_address) (void *user_data, uint32_t handle),
+    uint32_t         (*slot_get_base)    (void *user_data, uint32_t handle),
+    uint32_t         (*slot_get_offset)  (void *user_data, uint32_t handle),
+    uint32_t         (*slot_get_slot_size) (void *user_data, uint32_t handle));
+
+
+/**
+ * Initialize a Keystore Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object. It sets the user keystore object up to use the default keystore
+ * handler.  If a custom keystore handler is desired, the function
+ * #fsl_shw_init_keystore() can be used instead.
+ *
+ * @param keystore      The Keystore object to operate on.
+ */
+extern void fsl_shw_init_keystore_default(fsl_shw_kso_t *keystore);
+
+
+/**
+ * Establish a Keystore Object.
+ *
+ * This function establishes a keystore object that has been set up by a call
+ * to #fsl_shw_init_keystore().  It is a wrapper for the user-defined
+ * data_init() function, which is specified during keystore initialization.
+ *
+ * @param user_ctx      The user context that this keystore should be attached
+ *                      to
+ * @param keystore      The Keystore object to operate on.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_establish_keystore(fsl_shw_uco_t *user_ctx,
+                        fsl_shw_kso_t* keystore);
+
+
+/**
+ * Release a Keystore Object.
+ *
+ * This function releases an established keystore object.  It is a wrapper for
+ * the user-defined data_cleanup() function, which is specified during keystore
+ * initialization.
+ *
+ * @param user_ctx      The user context that this keystore should be attached
+ *                      to.
+ * @param keystore      The Keystore object to operate on.
+ */
+extern void fsl_shw_release_keystore(fsl_shw_uco_t *user_ctx,
+                                     fsl_shw_kso_t *keystore);
+
+
+/**
+ * Allocate a slot in the Keystore.
+ *
+ * This function attempts to allocate a slot to hold a key in the keystore.  It
+ * is called by #fsl_shw_establish_key() when establishing a Secure Key Object,
+ * if the key has been flagged to be stored in a user keystore by the
+ * #fsl_shw_sko_set_keystore() function.  It is a wrapper for the
+ * implementation-specific function slot_alloc().
+ *
+ * @param keystore      The Keystore object to operate on.
+ * @param[in] size      Size of the key to be stored (octets).
+ * @param[in] owner_id  ID of the key owner.
+ * @param[out] slot     If successful, assigned slot ID
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t keystore_slot_alloc(fsl_shw_kso_t *keystore,
+                                            uint32_t size,
+                                            uint64_t owner_id,
+                                            uint32_t *slot);
+
+
+/**
+ * Deallocate a slot in the Keystore.
+ *
+ * This function attempts to allocate a slot to hold a key in the keystore.
+ * It is called by #fsl_shw_extract_key() and #fsl_shw_release_key() when the
+ * key that it contains is to be released.  It is a wrapper for the
+ * implmentation-specific function slot_dealloc().
+ 
+ * @param keystore      The Keystore object to operate on.
+ * @param[in] owner_id  ID of the key owner.
+ * @param[in] slot     If successful, assigned slot ID.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t keystore_slot_dealloc(fsl_shw_kso_t *keystore,
+                                              uint64_t owner_id,
+                                              uint32_t slot);
+
+
+/**
+ * Load cleartext key data into a key slot
+ *
+ * This function loads a key slot with cleartext data.
+ *
+ * @param keystore      The Keystore object to operate on.
+ * @param[in] owner_id  ID of the key owner.
+ * @param[in] slot      If successful, assigned slot ID.
+ * @param[in] key_data  Pointer to the location of the cleartext key data.
+ * @param[in] key_length Length of the key data (octets).
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t 
+keystore_load_slot(fsl_shw_kso_t *keystore, uint64_t owner_id, uint32_t slot,
+                   const uint8_t *key_data, uint32_t key_length);
+
+
+/**
+ * Encrypt a keyslot
+ *
+ * This function encrypts a key using the hardware secret key.
+ dler. It uses an entire Secure Memory partition, divided in to equal slots of length KEYSTORE_SLOT_SIZE.
+
+
+*
+ * @param user_ctx      User context
+ * @param keystore      The Keystore object to operate on.
+ * @param[in] owner_id  ID of the key owner.
+ * @param[in] slot      Slot ID of the key to encrypt.
+ * @param[in] length    Length of the key
+ * @param[out] destination  Pointer to the location where the encrypted data
+ *                          is to be stored.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t
+keystore_slot_encrypt(fsl_shw_uco_t *user_ctx,
+                      fsl_shw_kso_t *keystore, uint64_t owner_id,
+                      uint32_t slot, uint32_t length,
+                      uint8_t *destination);
+
+
+/**
+ * Encrypt a keyslot
+ *
+ * This function decrypts a key using the hardware secret key.
+ *
+ * @param user_ctx      User context
+ * @param keystore      The Keystore object to operate on.
+ * @param[in] owner_id  ID of the key owner.
+ * @param[in] slot      Slot ID of the key to encrypt.
+ * @param[in] length    Length of the key
+ * @param[in] source    Pointer to the location where the encrypted data
+ *                      is stored.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t
+keystore_slot_decrypt(fsl_shw_uco_t *user_ctx,
+                      fsl_shw_kso_t *keystore, uint64_t owner_id,
+                      uint32_t slot, uint32_t length,
+                      const uint8_t *source);
+
+/* @} */
+
+/** @addtogroup default_keystore
+    @{ */
+
+
+/**
+ * Data structure to hold per-slot information
+ */
+typedef struct keystore_data_slot_info_t {
+    uint8_t     allocated;              /**< Track slot assignments */
+    uint64_t    owner;                  /**< Owner IDs */
+    uint32_t    key_length;             /**< Size of the key */
+} keystore_data_slot_info_t;
+
+
+/**
+ * Data structure to hold keystore information.
+ */
+typedef struct keystore_data_t {
+    void*       base_address;           /**< Base of the Secure Partition */
+    uint32_t    slot_count;             /**< Number of slots in the keystore */
+    struct keystore_data_slot_info_t* slot; /**< Per-slot information */
+} keystore_data_t;
+
+
+/**
+ * Default keystore initialization routine.
+ *
+ * This function acquires a Secure Partition Object to store the keystore,
+ * divides it into slots of length #KEYSTORE_SLOT_SIZE, and builds a data
+ * structure to hold key information.
+ *
+ * @param user_ctx       User context
+ * @param[out] user_data Pointer to the location where the keystore data
+ *                       structure is to be stored.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t shw_kso_init_data     (fsl_shw_uco_t *user_ctx,
+                                        void **user_data);
+
+
+/**
+ * Default keystore cleanup routine.
+ *
+ * This function releases the Secure Partition Object and the memory holding
+ * the keystore data structure, that obtained by the shw_kso_init_data
+ * function. 
+ *
+ * @param user_ctx          User context
+ * @param[in,out] user_data Pointer to the location where the keystore data
+ *                          structure is stored.
+ */
+void             shw_kso_cleanup_data  (fsl_shw_uco_t *user_ctx,
+                                        void **user_data);
+
+
+/**
+ * Default keystore slot access verification
+ *
+ * This function compares the supplied Owner ID to the registered owner of
+ * the key slot, to see if the supplied ID is correct.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] owner_id  Owner ID supplied as a credential.
+ * @param[in] slot      Requested slot
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t shw_slot_verify_access(void *user_data, uint64_t owner_id,
+                                        uint32_t slot);
+
+
+/**
+ * Default keystore slot allocation
+ *
+ * This function first checks that the requested size is equal to or less than
+ * the maximum keystore slot size.  If so, it searches the keystore for a free
+ * key slot, and if found, marks it as used and returns a slot reference to the
+ * user.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] size      Size of the key data that will be stored in this slot
+ *                      (octets)
+ * @param[in] owner_id  Owner ID supplied as a credential.
+ * @param[out] slot     Requested slot
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t shw_slot_alloc        (void *user_data, uint32_t size,
+                                        uint64_t owner_id, uint32_t *slot);
+
+
+/**
+ * Default keystore slot deallocation
+ *
+ * This function releases the given key slot in the keystore, making it
+ * available to store a new key.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] owner_id  Owner ID supplied as a credential.
+ * @param[in] slot      Requested slot
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t shw_slot_dealloc      (void *user_data,
+                                        uint64_t owner_id, uint32_t slot);
+
+
+/**
+ * Default keystore slot address lookup
+ *
+ * This function calculates the address where the key data is stored.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] slot      Requested slot
+ *
+ * @return    SCC2: Virtual address (kernel or userspace) of the key data.
+ *            SCC: Physical address of the key data.
+ */
+void*            shw_slot_get_address  (void *user_data, uint32_t slot);
+
+
+/**
+ * Default keystore slot base address lookup
+ *
+ * This function calculates the base address of the Secure Partition on which
+ * the key data is located.  For the reference design, only one Secure
+ * Partition is used per Keystore, however in general, any number may be used.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] slot      Requested slot
+ *
+ * @return    SCC2: Secure Partition virtual (kernel or userspace) base address.
+ *            SCC: Secure Partition physical base address.
+ */
+uint32_t         shw_slot_get_base     (void *user_data, uint32_t slot);
+
+
+/**
+ * Default keystore slot offset lookup
+ *
+ * This function calculates the offset from the base of the Secure Partition
+ * where the key data is located.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] slot      Requested slot
+ *
+ * @return    SCC2: Key data offset (octets)
+ *            SCC: Not implemented
+ */
+uint32_t         shw_slot_get_offset   (void *user_data, uint32_t slot);
+
+
+/**
+ * Default keystore slot offset lookup
+ *
+ * This function returns the size of the given key slot.  In the reference
+ * implementation, all key slots are of the same size, however in general,
+ * the keystore slot sizes can be made variable.
+ *
+ * @param[in] user_data Pointer to the location where the keystore data
+ *                      structure stored.
+ * @param[in] slot      Requested slot
+ *
+ * @return    SCC2: Keystore slot size.
+ *            SCC: Not implemented
+ */
+uint32_t         shw_slot_get_slot_size (void *user_data, uint32_t slot);
+
+/* @} */
+
+
+#endif /* FSL_SHW_KEYSTORE_H */
diff --git a/drivers/mxc/security/sahara2/include/linux_port.h b/drivers/mxc/security/sahara2/include/linux_port.h
index 66b5d9e..aff25e6 100644
--- a/drivers/mxc/security/sahara2/include/linux_port.h
+++ b/drivers/mxc/security/sahara2/include/linux_port.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -77,41 +77,44 @@
 #include <linux/dmapool.h>
 #include <linux/dma-mapping.h>
 
-#include <asm/io.h>		/* ioremap() */
+#include <asm/uaccess.h>            /* copy_to_user(), copy_from_user() */
+#include <asm/io.h>                 /* ioremap() */
 #include <asm/irq.h>
-#include <asm/uaccess.h>	/* copy_to_user(), copy_from_user() */
 #include <asm/cacheflush.h>
 
 #ifndef TRUE
-/*! Useful symbol for unsigned values used as flags. */
+/** Useful symbol for unsigned values used as flags. */
 #define TRUE 1
 #endif
 
 #ifndef FALSE
-/*! Useful symbol for unsigned values used as flags. */
+/** Useful symbol for unsigned values used as flags. */
 #define FALSE 0
 #endif
 
+
 /* These symbols are defined in Linux 2.6 and later.  Include here for minimal
  * support of 2.4 kernel.
  **/
 #if !defined(LINUX_VERSION_CODE) || LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-/*!
+/**
  * Symbol defined somewhere in 2.5/2.6.  It is the return signature of an ISR.
  */
 #define irqreturn_t void
-/*! Possible return value of 'modern' ISR routine. */
+/** Possible return value of 'modern' ISR routine. */
 #define IRQ_HANDLED
-/*! Method of generating value of 'modern' ISR routine. */
+/** Method of generating value of 'modern' ISR routine. */
 #define IRQ_RETVAL(x)
 #endif
 
-/*!
+
+/**
  * Type used for registering and deregistering interrupts.
  */
 typedef int os_interrupt_id_t;
 
-/*!
+
+/**
  * Type used as handle for a process
  *
  * See #os_get_process_handle() and #os_send_signal().
@@ -129,20 +132,24 @@ typedef task_t *os_process_handle_t;
 typedef struct task_struct *os_process_handle_t;
 #endif
 
-/*!
+
+
+/**
  * Generic return code for functions which need such a thing.
  *
  * No knowledge should be assumed of the value of any of these symbols except
  * that @c OS_ERROR_OK_S is guaranteed to be zero.
  */
 typedef enum {
-	OS_ERROR_OK_S = 0,	/*!< Success  */
-	OS_ERROR_FAIL_S = -EIO,	/*!< Generic driver failure */
-	OS_ERROR_NO_MEMORY_S = -ENOMEM,	/*!< Failure to acquire/use memory  */
-	OS_ERROR_BAD_ADDRESS = -EFAULT	/*!< Bad address  */
+    OS_ERROR_OK_S = 0,         /**< Success  */
+    OS_ERROR_FAIL_S = -EIO,    /**< Generic driver failure */
+    OS_ERROR_NO_MEMORY_S = -ENOMEM, /**< Failure to acquire/use memory  */
+    OS_ERROR_BAD_ADDRESS_S = -EFAULT, /**< Bad address  */
+    OS_ERROR_BAD_ARG_S = -EINVAL, /**< Bad input argument  */
 } os_error_code;
 
-/*!
+
+/**
  * Handle to a lock.
  */
 #ifdef CONFIG_PREEMPT_RT
@@ -151,63 +158,64 @@ typedef raw_spinlock_t *os_lock_t;
 typedef spinlock_t *os_lock_t;
 #endif
 
-/*!
+/**
  * Context while locking.
  */
 typedef unsigned long os_lock_context_t;
 
-/*!
+/**
  * Declare a wait object for sleeping/waking processes.
  */
 #define OS_WAIT_OBJECT(name)                                            \
     DECLARE_WAIT_QUEUE_HEAD(name##_qh)
 
-/*!
+/**
  * Driver registration handle
  *
  * Used with #os_driver_init_registration(), #os_driver_add_registration(),
  * and #os_driver_complete_registration().
  */
 typedef struct {
-	unsigned reg_complete;	/*!< TRUE if next inits succeeded. */
-	dev_t dev;		/*!< dev_t for register_chrdev() */
-	struct file_operations fops;	/*!< struct for register_chrdev() */
+    unsigned reg_complete;      /**< TRUE if next inits succeeded. */
+    dev_t  dev;                 /**< dev_t for register_chrdev() */
+    struct file_operations fops; /**< struct for register_chrdev() */
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
-	struct class_simple *cs;	/*!< results of class_simple_create() */
+    struct class_simple *cs;    /**< results of class_simple_create() */
 #else
-	struct class *cs;	/*!< results of class_create() */
+    struct class        *cs;    /**< results of class_create() */
 #endif
-	struct class_device *cd;	/*!< Result of class_simple_device_add() */
-	unsigned power_complete;	/*!< TRUE if next inits succeeded */
+    struct class_device *cd;    /**< Result of class_simple_device_add() */
+    unsigned power_complete;    /**< TRUE if next inits succeeded */
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-	struct device_driver dd;	/*!< struct for register_driver() */
+    struct device_driver   dd;  /**< struct for register_driver() */
 #else
-	struct platform_driver dd;	/*!< struct for register_driver() */
+    struct platform_driver dd;  /**< struct for register_driver() */
 #endif
-	struct platform_device pd;	/*!< struct for platform_register_device() */
+    struct platform_device pd;  /**< struct for platform_register_device() */
 } os_driver_reg_t;
 
+
 /*
  *  Function types which can be associated with driver entry points.
  *
  *  Note that init and shutdown are absent.
  */
-/*! @{ */
-/*! Keyword for registering open() operation handler. */
+/** @{ */
+/** Keyword for registering open() operation handler. */
 #define OS_FN_OPEN open
-/*! Keyword for registering close() operation handler. */
+/** Keyword for registering close() operation handler. */
 #define OS_FN_CLOSE release
-/*! Keyword for registering read() operation handler. */
+/** Keyword for registering read() operation handler. */
 #define OS_FN_READ read
-/*! Keyword for registering write() operation handler. */
+/** Keyword for registering write() operation handler. */
 #define OS_FN_WRITE write
-/*! Keyword for registering ioctl() operation handler. */
+/** Keyword for registering ioctl() operation handler. */
 #define OS_FN_IOCTL ioctl
-/*! Keyword for registering mmap() operation handler. */
+/** Keyword for registering mmap() operation handler. */
 #define OS_FN_MMAP mmap
-/*! @} */
+/** @} */
 
-/*!
+/**
  * Function signature for the portable interrupt handler
  *
  * While it would be nice to know which interrupt is being serviced, the
@@ -215,19 +223,23 @@ typedef struct {
  *
  * @return  Zero if not handled, non-zero if handled.
  */
-typedef int (*os_interrupt_handler_t) (int, void *);
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+typedef int (*os_interrupt_handler_t)(int, void*, struct pt_regs*);
+#else
+typedef int (*os_interrupt_handler_t)(int, void*);
+#endif
 
-/*!
+/**
  * @defgroup dkops Driver-to-Kernel Operations
  *
  * These are the operations which drivers should call to get the OS to perform
  * services.
  */
 
-/*! @addtogroup dkops */
-/*! @{ */
+/** @addtogroup dkops */
+/** @{ */
 
-/*!
+/**
  * Register an interrupt handler.
  *
  * @param driver_name    The name of the driver
@@ -240,7 +252,9 @@ typedef int (*os_interrupt_handler_t) (int, void *);
 #define os_register_interrupt(driver_name, interrupt_id, function)            \
      request_irq(interrupt_id, function, 0, driver_name, NULL)
 
-/*!
+
+
+/**
  * Deregister an interrupt handler.
  *
  * @param interrupt_id   The interrupt line to stop monitoring
@@ -250,27 +264,28 @@ typedef int (*os_interrupt_handler_t) (int, void *);
 #define os_deregister_interrupt(interrupt_id)                                 \
      free_irq(interrupt_id, NULL)
 
-/*!
+/**
  * INTERNAL implementation of os_driver_init_registration()
  *
  * @return An os error code.
  */
-inline static int os_drv_do_init_reg(os_driver_reg_t * handle)
+static inline int os_drv_do_init_reg(os_driver_reg_t *handle)
 {
-	memset(handle, sizeof(*handle), 0);
-	handle->fops.owner = THIS_MODULE;
-	handle->power_complete = FALSE;
-	handle->reg_complete = FALSE;
+    memset(handle, sizeof(*handle), 0);
+    handle->fops.owner = THIS_MODULE;
+    handle->power_complete = FALSE;
+    handle->reg_complete = FALSE;
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-	handle->dd.name = NULL;
+    handle->dd.name = NULL;
 #else
-	handle->dd.driver.name = NULL;
+    handle->dd.driver.name = NULL;
 #endif
 
-	return OS_ERROR_OK_S;
+    return OS_ERROR_OK_S;
 }
 
-/*!
+
+/**
  * Initialize driver registration.
  *
  * If the driver handles open(), close(), ioctl(), read(), write(), or mmap()
@@ -286,7 +301,8 @@ inline static int os_drv_do_init_reg(os_driver_reg_t * handle)
 #define os_driver_init_registration(handle)                                   \
     os_drv_do_init_reg(&handle)
 
-/*!
+
+/**
  * Add a function registration to driver registration.
  *
  * @param handle    A handle initialized by #os_driver_init_registration().
@@ -298,7 +314,8 @@ inline static int os_drv_do_init_reg(os_driver_reg_t * handle)
 #define os_driver_add_registration(handle, name, function)                    \
     do {handle.fops.name = (void*)(function); } while (0)
 
-/*!
+
+/**
  * Record 'power suspend' function for the device.
  *
  * @param handle    A handle initialized by #os_driver_init_registration().
@@ -311,7 +328,8 @@ inline static int os_drv_do_init_reg(os_driver_reg_t * handle)
 #define os_driver_register_power_suspend(handle, function)                    \
    handle.dd.suspend = function
 
-/*!
+
+/**
  * Record 'power resume' function for the device.
  *
  * @param handle    A handle initialized by #os_driver_init_registration().
@@ -324,7 +342,8 @@ inline static int os_drv_do_init_reg(os_driver_reg_t * handle)
 #define os_driver_register_resume(handle, function)                          \
    handle.dd.resume = function
 
-/*!
+
+/**
  * INTERNAL function of the Linux port of the OS API.   Implements the
  * os_driver_complete_registration() function.
  *
@@ -338,121 +357,124 @@ inline static int os_drv_do_init_reg(os_driver_reg_t * handle)
  *
  * @return  An error code
  */
-inline static int os_drv_do_reg(os_driver_reg_t * handle,
-				unsigned major, char *driver_name)
+inline static int os_drv_do_reg(os_driver_reg_t *handle,
+                                unsigned major, char*driver_name)
 {
-	os_error_code code = OS_ERROR_NO_MEMORY_S;
-	char *name = kmalloc(strlen(driver_name) + 1, 0);
-
-	if (name != NULL) {
-		memcpy(name, driver_name, strlen(driver_name) + 1);
-		code = OS_ERROR_OK_S;	/* OK so far */
-		/* If any chardev/POSIX routines were added, then do chrdev part */
-		if (handle->fops.open || handle->fops.release
-		    || handle->fops.read || handle->fops.write
-		    || handle->fops.ioctl || handle->fops.mmap) {
-			code =
-			    register_chrdev(major, driver_name, &handle->fops);
-			if (code < 0) {
-				code = OS_ERROR_FAIL_S;
-			} else {
-				if (code != 0) {
-					/* Zero was passed in for major; code is actual value */
-					handle->dev = MKDEV(code, 0);
-				} else {
-					handle->dev = MKDEV(major, 0);
-				}
-				code = OS_ERROR_OK_S;
+    os_error_code code = OS_ERROR_NO_MEMORY_S;
+    char* name = kmalloc(strlen(driver_name)+1, 0);
+
+    if (name != NULL) {
+        memcpy(name, driver_name,strlen(driver_name)+1);
+        code = OS_ERROR_OK_S; /* OK so far */
+        /* If any chardev/POSIX routines were added, then do chrdev part */
+        if (handle->fops.open || handle->fops.release || handle->fops.read ||
+            handle->fops.write || handle->fops.ioctl || handle->fops.mmap) {
+
+            printk("ioctl pointer: %p.  mmap pointer: %p\n",
+                    handle->fops.ioctl, handle->fops.mmap);
+
+            /* this method is depricated, see:
+             * http://lwn.net/Articles/126808/
+             */
+            code = register_chrdev(major, driver_name, &handle->fops);
+
+
+            /* instead something like this: */
+#if 0
+            handle->dev = MKDEV(major, 0);
+	    	code = register_chrdev_region(handle->dev, 1, driver_name);
+            if (code < 0) {
+                code = OS_ERROR_FAIL_S;
+            } else {
+                cdev_init(&handle->cdev, &handle->fops);
+                code = cdev_add(&handle->cdev, major, 1);
+            }
+#endif
+
+
+            if (code < 0) {
+                code = OS_ERROR_FAIL_S;
+            } else {
+                if (code != 0) {
+                    /* Zero was passed in for major; code is actual value */
+                    handle->dev = MKDEV(code, 0);
+                } else {
+                    handle->dev = MKDEV(major, 0);
+                }
+                code = OS_ERROR_OK_S;
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
-				handle->cs =
-				    class_simple_create(THIS_MODULE,
-							driver_name);
-				if (IS_ERR(handle->cs)) {
-					code = (os_error_code) handle->cs;
-					handle->cs = NULL;
-				} else {
-					handle->cd =
-					    class_simple_device_add(handle->cs,
-								    handle->dev,
-								    NULL,
-								    driver_name);
-					if (IS_ERR(handle->cd)) {
-						class_simple_device_remove
-						    (handle->dev);
-						unregister_chrdev(MAJOR
-								  (handle->dev),
-								  driver_name);
-						code =
-						    (os_error_code) handle->cs;
-						handle->cs = NULL;
-					} else {
-						handle->reg_complete = TRUE;
-					}
-				}
+                handle->cs = class_simple_create(THIS_MODULE, driver_name);
+                if (IS_ERR(handle->cs)) {
+                    code = (os_error_code)handle->cs;
+                    handle->cs = NULL;
+                } else {
+                    handle->cd = class_simple_device_add(handle->cs,
+                                                        handle->dev, NULL,
+                                                        driver_name);
+                    if (IS_ERR(handle->cd)) {
+                        class_simple_device_remove(handle->dev);
+                        unregister_chrdev(MAJOR(handle->dev), driver_name);
+                        code = (os_error_code)handle->cs;
+                        handle->cs = NULL;
+                    } else {
+                        handle->reg_complete = TRUE;
+                    }
+                }
 #else
-				handle->cs =
-				    class_create(THIS_MODULE, driver_name);
-				if (IS_ERR(handle->cs)) {
-					code = (os_error_code) handle->cs;
-					handle->cs = NULL;
-				} else {
-					handle->cd =
-					    class_device_create(handle->cs,
-								NULL,
-								handle->dev,
-								NULL,
-								driver_name);
-					if (IS_ERR(handle->cd)) {
-						class_device_destroy(handle->cs,
-								     handle->
-								     dev);
-						class_destroy(handle->cs);
-						unregister_chrdev(MAJOR
-								  (handle->dev),
-								  driver_name);
-						code =
-						    (os_error_code) handle->cs;
-						handle->cs = NULL;
-					} else {
-						handle->reg_complete = TRUE;
-					}
-				}
+                handle->cs = class_create(THIS_MODULE, driver_name);
+                if (IS_ERR(handle->cs)) {
+                    code = (os_error_code)handle->cs;
+                    handle->cs = NULL;
+                } else {
+                    handle->cd = class_device_create(handle->cs, NULL,
+                                                        handle->dev, NULL,
+                                                        driver_name);
+                    if (IS_ERR(handle->cd)) {
+                        class_device_destroy(handle->cs, handle->dev);
+                        class_destroy(handle->cs);
+                        unregister_chrdev(MAJOR(handle->dev), driver_name);
+                        code = (os_error_code)handle->cs;
+                        handle->cs = NULL;
+                    } else {
+                        handle->reg_complete = TRUE;
+                    }
+                }
 #endif
-			}
-		}
-		/* ... fops routine registered */
-		/* Handle power management fns through separate interface */
-		if ((code == OS_ERROR_OK_S) &&
-		    (handle->dd.suspend || handle->dd.resume)) {
+            }
+        } /* ... fops routine registered */
+        /* Handle power management fns through separate interface */
+        if ((code == OS_ERROR_OK_S) &&
+            (handle->dd.suspend || handle->dd.resume)) {
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-			handle->dd.name = name;
-			handle->dd.bus = &platform_bus_type;
-			code = driver_register(&handle->dd);
+            handle->dd.name = name;
+            handle->dd.bus = &platform_bus_type;
+            code = driver_register(&handle->dd);
 #else
-			handle->dd.driver.name = name;
-			handle->dd.driver.bus = &platform_bus_type;
-			code = driver_register(&handle->dd.driver);
+            handle->dd.driver.name = name;
+            handle->dd.driver.bus = &platform_bus_type;
+            code = driver_register(&handle->dd.driver);
 #endif
-			if (code == OS_ERROR_OK_S) {
-				handle->pd.name = name;
-				handle->pd.id = 0;
-				code = platform_device_register(&handle->pd);
-				if (code != OS_ERROR_OK_S) {
+            if (code == OS_ERROR_OK_S) {
+                handle->pd.name = name;
+                handle->pd.id = 0;
+                code = platform_device_register(&handle->pd);
+                if (code != OS_ERROR_OK_S) {
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-					driver_unregister(&handle->dd);
+                    driver_unregister(&handle->dd);
 #else
-					driver_unregister(&handle->dd.driver);
+                    driver_unregister(&handle->dd.driver);
 #endif
-				} else {
-					handle->power_complete = TRUE;
-				}
-			}
-		}		/* ... suspend or resume */
-	}			/* name != NULL */
-	return code;
+                }  else {
+                    handle->power_complete = TRUE;
+                }
+            }
+        } /* ... suspend or resume */
+    }  /* name != NULL */
+    return code;
 }
 
-/*!
+
+/**
  * Finalize the driver registration with the kernel.
  *
  * Upon return from this call, the driver may begin receiving calls at the
@@ -471,7 +493,8 @@ inline static int os_drv_do_reg(os_driver_reg_t * handle,
 #define os_driver_complete_registration(handle, major, driver_name)           \
    os_drv_do_reg(&handle, major, driver_name)
 
-/*!
+
+/**
  * Get driver Major Number from handle after a successful registration.
  *
  * @param   handle  A handle which has completed registration.
@@ -481,63 +504,65 @@ inline static int os_drv_do_reg(os_driver_reg_t * handle,
 #define os_driver_get_major(handle)                                           \
     (handle.reg_complete ? MAJOR(handle.dev) : -1)
 
-/*!
+
+/**
  * INTERNAL implemention of os_driver_remove_registration.
  *
  * @param handle    A handle initialized by #os_driver_init_registration().
  *
  * @return  An error code.
  */
-inline static int os_drv_rmv_reg(os_driver_reg_t * handle)
+inline static int os_drv_rmv_reg(os_driver_reg_t* handle)
 {
-	if (handle->reg_complete) {
+    if (handle->reg_complete) {
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
-		if (handle->cd != NULL) {
-			class_simple_device_remove(handle->dev);
-			handle->cd = NULL;
-		}
-		if (handle->cs != NULL) {
-			class_simple_destroy(handle->cs);
-			handle->cs = NULL;
-		}
-		unregister_chrdev(MAJOR(handle->dev), handle->dd.name);
+        if (handle->cd != NULL) {
+            class_simple_device_remove(handle->dev);
+            handle->cd = NULL;
+        }
+        if (handle->cs != NULL) {
+            class_simple_destroy(handle->cs);
+            handle->cs = NULL;
+        }
+        unregister_chrdev(MAJOR(handle->dev), handle->dd.name);
 #else
-		if (handle->cd != NULL) {
-			class_device_destroy(handle->cs, handle->dev);
-			handle->cd = NULL;
-		}
-		if (handle->cs != NULL) {
-			class_destroy(handle->cs);
-			handle->cs = NULL;
-		}
-		unregister_chrdev(MAJOR(handle->dev), handle->dd.driver.name);
+        if (handle->cd != NULL) {
+            class_device_destroy(handle->cs, handle->dev);
+            handle->cd = NULL;
+        }
+        if (handle->cs != NULL) {
+            class_destroy(handle->cs);
+            handle->cs = NULL;
+        }
+        unregister_chrdev(MAJOR(handle->dev), handle->dd.driver.name);
 #endif
-		handle->reg_complete = FALSE;
-	}
-	if (handle->power_complete) {
-		platform_device_unregister(&handle->pd);
+        handle->reg_complete = FALSE;
+    }
+    if (handle->power_complete) {
+        platform_device_unregister(&handle->pd);
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-		driver_unregister(&handle->dd);
+        driver_unregister(&handle->dd);
 #else
-		driver_unregister(&handle->dd.driver);
+        driver_unregister(&handle->dd.driver);
 #endif
-		handle->power_complete = FALSE;
-	}
+        handle->power_complete = FALSE;
+    }
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-	if (handle->dd.name != NULL) {
-		kfree(handle->dd.name);
-		handle->dd.name = NULL;
-	}
+    if (handle->dd.name != NULL) {
+        kfree(handle->dd.name);
+        handle->dd.name = NULL;
+    }
 #else
-	if (handle->dd.driver.name != NULL) {
-		kfree(handle->dd.driver.name);
-		handle->dd.driver.name = NULL;
-	}
+    if (handle->dd.driver.name != NULL) {
+        kfree(handle->dd.driver.name);
+        handle->dd.driver.name = NULL;
+    }
 #endif
-	return OS_ERROR_OK_S;
+    return OS_ERROR_OK_S;
 }
 
-/*!
+
+/**
  * Remove the driver's registration with the kernel.
  *
  * Upon return from this call, the driver not receive any more calls at the
@@ -550,7 +575,8 @@ inline static int os_drv_rmv_reg(os_driver_reg_t * handle)
 #define os_driver_remove_registration(handle)                                 \
    os_drv_rmv_reg(&handle)
 
-/*!
+
+/**
  * Register a driver with the Linux Device Model.
  *
  * @param   driver_information  The device_driver structure information
@@ -562,7 +588,7 @@ inline static int os_drv_rmv_reg(os_driver_reg_t * handle)
 #define os_register_to_driver(driver_information)                             \
               driver_register(driver_information)
 
-/*!
+/**
  * Unregister a driver from the Linux Device Model
  *
  * this routine unregisters from the Linux Device Model
@@ -576,7 +602,7 @@ inline static int os_drv_rmv_reg(os_driver_reg_t * handle)
 #define os_unregister_from_driver(driver_information)                         \
                 driver_unregister(driver_information)
 
-/*!
+/**
  * register a device to a driver
  *
  * this routine registers a drivers devices to the Linux Device Model
@@ -590,7 +616,7 @@ inline static int os_drv_rmv_reg(os_driver_reg_t * handle)
 #define os_register_a_device(device_information)                              \
     platform_device_register(device_information)
 
-/*!
+/**
  * unregister a device from a driver
  *
  * this routine unregisters a drivers devices from the Linux Device Model
@@ -604,7 +630,8 @@ inline static int os_drv_rmv_reg(os_driver_reg_t * handle)
 #define os_unregister_a_device(device_information)                            \
     platform_device_unregister(device_information)
 
-/*!
+
+/**
  * Print a message to console / into log file.  After the @c msg argument a
  * number of printf-style arguments may be added.  Types should be limited to
  * printf string, char, octal, decimal, and hexadecimal types.  (This excludes
@@ -615,11 +642,10 @@ inline static int os_drv_rmv_reg(os_driver_reg_t * handle)
  *
  * @return (void)
  */
-/* This may be a GCC-ism which needs to be ported to ANSI */
-#define os_printk(msg, s...)                                                  \
-    (void) printk(msg, ## s)
+#define os_printk(...)                                                        \
+    (void) printk(__VA_ARGS__)
 
-/*!
+/**
  * Prepare a task to execute the given function.  This should only be done once
  * per function,, during the driver's initialization routine.
  *
@@ -630,7 +656,8 @@ inline static int os_drv_rmv_reg(os_driver_reg_t * handle)
 #define os_create_task(function_name)                                         \
     OS_ERROR_OK_S
 
-/*!
+
+/**
  * Schedule execution of a task.
  *
  * @param function_name   The function associated with the task.
@@ -640,7 +667,8 @@ inline static int os_drv_rmv_reg(os_driver_reg_t * handle)
 #define os_dev_schedule_task(function_name)                                   \
     tasklet_schedule(&(function_name ## let))
 
-/*!
+
+/**
  * Make sure that task is no longer running and will no longer run.
  *
  * This function will not return until both are true.  This is useful when
@@ -652,7 +680,7 @@ do {                                                                          \
     tasklet_kill(&(function_name ## let));                                    \
 } while (0)
 
-/*!
+/**
  * Allocate some kernel memory
  *
  * @param amount   Number of 8-bit bytes to allocate
@@ -663,7 +691,8 @@ do {                                                                          \
 #define os_alloc_memory(amount, flags)                                        \
     (void*)kmalloc(amount, flags)
 
-/*!
+
+/**
  * Free some kernel memory
  *
  * @param location  The beginning of the region to be freed.
@@ -675,7 +704,8 @@ do {                                                                          \
 #define os_free_memory(location)                                              \
     kfree(location)
 
-/*!
+
+/**
  * Allocate cache-coherent memory
  *
  * @param       amount     Number of bytes to allocate
@@ -690,7 +720,8 @@ do {                                                                          \
 #define os_alloc_coherent(amount, dma_addrp, flags)                           \
     (void*)dma_alloc_coherent(NULL, amount, dma_addrp, flags)
 
-/*!
+
+/**
  * Free cache-coherent memory
  *
  * @param       size       Number of bytes which were allocated.
@@ -705,7 +736,8 @@ do {                                                                          \
 #define os_free_coherent(size, virt_addr, dma_addr)                           \
     dma_free_coherent(NULL, size, virt_addr, dma_addr
 
-/*!
+
+/**
  * Map an I/O space into kernel memory space
  *
  * @param start       The starting address of the (physical / io space) region
@@ -716,7 +748,8 @@ do {                                                                          \
 #define os_map_device(start, range_bytes)                                     \
     (void*)ioremap_nocache((start), range_bytes)
 
-/*!
+
+/**
  * Unmap an I/O space from kernel memory space
  *
  * @param start       The starting address of the (virtual) region
@@ -727,7 +760,8 @@ do {                                                                          \
 #define os_unmap_device(start, range_bytes)                                   \
     iounmap((void*)(start))
 
-/*!
+
+/**
  * Copy data from Kernel space to User space
  *
  * @param to   The target location in user memory
@@ -737,9 +771,10 @@ do {                                                                          \
  * @return #os_error_code
  */
 #define os_copy_to_user(to, from, size)                                       \
-    ((copy_to_user(to, from, size) == 0) ? 0 : OS_ERROR_BAD_ADDRESS)
+    ((copy_to_user(to, from, size) == 0) ? 0 : OS_ERROR_BAD_ADDRESS_S)
 
-/*!
+
+/**
  * Copy data from User space to Kernel space
  *
  * @param to   The target location in kernel memory
@@ -749,9 +784,10 @@ do {                                                                          \
  * @return #os_error_code
  */
 #define os_copy_from_user(to, from, size)                                     \
-    ((copy_from_user(to, from, size) == 0) ? 0 : OS_ERROR_BAD_ADDRESS)
+    ((copy_from_user(to, from, size) == 0) ? 0 : OS_ERROR_BAD_ADDRESS_S)
 
-/*!
+
+/**
  * Read a 8-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -760,7 +796,8 @@ do {                                                                          \
 #define os_read8(register_address)                                            \
     __raw_readb(register_address)
 
-/*!
+
+/**
  * Write a 8-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -769,7 +806,7 @@ do {                                                                          \
 #define os_write8(register_address, value)                                    \
     __raw_writeb(value, register_address)
 
-/*!
+/**
  * Read a 16-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -778,7 +815,8 @@ do {                                                                          \
 #define os_read16(register_address)                                           \
     __raw_readw(register_address)
 
-/*!
+
+/**
  * Write a 16-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -787,7 +825,7 @@ do {                                                                          \
 #define os_write16(register_address, value)                                   \
     __raw_writew(value, (uint32_t*)(register_address))
 
-/*!
+/**
  * Read a 32-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -796,7 +834,8 @@ do {                                                                          \
 #define os_read32(register_address)                                           \
     __raw_readl((uint32_t*)(register_address))
 
-/*!
+
+/**
  * Write a 32-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -805,7 +844,7 @@ do {                                                                          \
 #define os_write32(register_address, value)                                   \
     __raw_writel(value, register_address)
 
-/*!
+/**
  * Read a 64-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -814,7 +853,8 @@ do {                                                                          \
 #define os_read64(register_address)                                           \
      ERROR_UNIMPLEMENTED
 
-/*!
+
+/**
  * Write a 64-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -823,7 +863,7 @@ do {                                                                          \
 #define os_write64(register_address, value)                                   \
     ERROR_UNIMPLEMENTED
 
-/*!
+/**
  * Delay some number of microseconds
  *
  * Note that this is a busy-loop, not a suspension of the task/process.
@@ -834,7 +874,8 @@ do {                                                                          \
  */
 #define os_mdelay mdelay
 
-/*!
+
+/**
  * Calculate virtual address from physical address
  *
  * @param pa    Physical address
@@ -845,7 +886,8 @@ do {                                                                          \
  */
 #define os_va __va
 
-/*!
+
+/**
  * Calculate physical address from virtual address
  *
  *
@@ -857,8 +899,9 @@ do {                                                                          \
  */
 #define os_pa __pa
 
+
 #ifdef CONFIG_PREEMPT_RT
-/*!
+/**
  * Allocate and initialize a lock, returning a lock handle.
  *
  * The lock state will be initialized to 'unlocked'.
@@ -867,18 +910,18 @@ do {                                                                          \
  */
 inline static os_lock_t os_lock_alloc_init(void)
 {
-	raw_spinlock_t *lockp;
-	lockp = (raw_spinlock_t *) kmalloc(sizeof(raw_spinlock_t), 0);
-	if (lockp) {
-		_raw_spin_lock_init(lockp);
-	} else {
-		printk("OS: lock init failedn");
-	}
-
-	return lockp;
+    raw_spinlock_t* lockp;
+    lockp = (raw_spinlock_t*)kmalloc(sizeof(raw_spinlock_t), 0);
+    if (lockp) {
+        _raw_spin_lock_init(lockp);
+    } else {
+        printk("OS: lock init failed\n");
+    }
+
+    return lockp;
 }
 #else
-/*!
+/**
  * Allocate and initialize a lock, returning a lock handle.
  *
  * The lock state will be initialized to 'unlocked'.
@@ -887,19 +930,19 @@ inline static os_lock_t os_lock_alloc_init(void)
  */
 inline static os_lock_t os_lock_alloc_init(void)
 {
-	spinlock_t *lockp;
-	lockp = (spinlock_t *) kmalloc(sizeof(spinlock_t), 0);
-	if (lockp) {
-		spin_lock_init(lockp);
-	} else {
-		printk("OS: lock init failedn");
-	}
-
-	return lockp;
+    spinlock_t* lockp;
+    lockp = (spinlock_t*)kmalloc(sizeof(spinlock_t), 0);
+    if (lockp) {
+        spin_lock_init(lockp);
+    } else {
+        printk("OS: lock init failed\n");
+    }
+
+    return lockp;
 }
-#endif				/* CONFIG_PREEMPT_RT */
+#endif /* CONFIG_PREEMPT_RT */
 
-/*!
+/**
  * Acquire a lock.
  *
  * This function should only be called from an interrupt service routine.
@@ -911,7 +954,8 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_lock(lock_handle)                                              \
    spin_lock(lock_handle)
 
-/*!
+
+/**
  * Unlock a lock.  Lock must have been acquired by #os_lock().
  *
  * @param   lock_handle  A handle to the lock to unlock.
@@ -921,7 +965,8 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_unlock(lock_handle)                                            \
    spin_unlock(lock_handle)
 
-/*!
+
+/**
  * Acquire a lock in non-ISR context
  *
  * This function will spin until the lock is available.
@@ -934,7 +979,7 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_lock_save_context(lock_handle, context)                        \
     spin_lock_irqsave(lock_handle, context)
 
-/*!
+/**
  * Release a lock in non-ISR context
  *
  * @param lock_handle  A handle of the lock to release.
@@ -945,7 +990,8 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_unlock_restore_context(lock_handle, context)                  \
     spin_unlock_irqrestore(lock_handle, context)
 
-/*!
+
+/**
  * Deallocate a lock handle.
  *
  * @param lock_handle   An #os_lock_t that has been allocated.
@@ -955,7 +1001,8 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_lock_deallocate(lock_handle)                                   \
     kfree(lock_handle)
 
-/*!
+
+/**
  * Determine process handle
  *
  * The process handle of the current user is returned.
@@ -965,7 +1012,8 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_get_process_handle()                                           \
     current
 
-/*!
+
+/**
  * Send a signal to a process
  *
  * @param  proc   A handle to the target process.
@@ -974,7 +1022,8 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_send_signal(proc, sig)                                         \
     send_sig(sig, proc, 0);
 
-/*!
+
+/**
  * Get some random bytes
  *
  * @param buf    The location to store the random data.
@@ -985,7 +1034,8 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_get_random_bytes(buf, count)                                   \
     get_random_bytes(buf, count)
 
-/*!
+
+/**
  * Go to sleep on an object.
  *
  * @param object    The object on which to sleep
@@ -1019,7 +1069,8 @@ inline static os_lock_t os_lock_alloc_init(void)
     code;                                                               \
 })
 
-/*!
+
+/**
  * Wake up whatever is sleeping on sleep object
  *
  * @param object  The object on which things might be sleeping
@@ -1029,13 +1080,15 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_wake_sleepers(object)                                        \
     wake_up_interruptible(&(object##_qh));
 
-	  /*! @} *//* dkops */
+
+/** @} */ /* dkops */
+
 
 /******************************************************************************
  *  Function signature-generating macros
  *****************************************************************************/
 
-/*!
+/**
  * @defgroup drsigs Driver Signatures
  *
  * These macros will define the entry point signatures for interrupt handlers;
@@ -1079,10 +1132,10 @@ inline static os_lock_t os_lock_alloc_init(void)
  *
  */
 
-/*! @addtogroup drsigs */
-/*! @{ */
+/** @addtogroup drsigs */
+/** @{ */
 
-/*!
+/**
  * Define a function which will handle device initialization
  *
  * This is tne driver initialization routine.  This is normally where the
@@ -1098,13 +1151,15 @@ inline static os_lock_t os_lock_alloc_init(void)
 module_init(function_name);                                                   \
 static int __init function_name (void)
 
-/*! Make declaration for driver init function.
+
+/** Make declaration for driver init function.
  * @param function_name foo
  */
 #define OS_DEV_INIT_DCL(function_name)                                        \
 static int __init function_name (void);
 
-/*!
+
+/**
  * Generate a function reference to the driver's init function.
  * @param function_name   Name of the OS_DEV_INIT() function.
  *
@@ -1113,7 +1168,8 @@ static int __init function_name (void);
 #define OS_DEV_INIT_REF(function_name)                                        \
 function_name
 
-/*!
+
+/**
  * Define a function which will handle device shutdown
  *
  * This is the inverse of the #OS_DEV_INIT() routine.
@@ -1127,7 +1183,8 @@ function_name
 module_exit(function_name);                                                   \
 static void function_name(void)
 
-/*!
+
+/**
  * Generate a function reference to the driver's shutdown function.
  * @param function_name   Name of the OS_DEV_HUSTDOWN() function.
  *
@@ -1136,7 +1193,7 @@ static void function_name(void)
 #define OS_DEV_SHUTDOWN_DCL(function_name)                                    \
 static void function_name(void);
 
-/*!
+/**
  * Generate a reference to driver's shutdown function
  * @param function_name   Name of the OS_DEV_HUSTDOWN() function.
 */
@@ -1144,7 +1201,8 @@ static void function_name(void);
 #define OS_DEV_SHUTDOWN_REF(function_name)                                    \
 function_name
 
-/*!
+
+/**
  * Define a function which will open the device for a user.
  *
  * @param function_name The name of the driver open() function
@@ -1154,7 +1212,8 @@ function_name
 #define OS_DEV_OPEN(function_name)                                            \
 static int function_name(struct inode* inode_p_, struct file* file_p_)
 
-/*!
+
+/**
  * Declare prototype for an open() function.
  *
  * @param function_name The name of the OS_DEV_OPEN() function.
@@ -1162,7 +1221,8 @@ static int function_name(struct inode* inode_p_, struct file* file_p_)
 #define OS_DEV_OPEN_DCL(function_name)                                        \
 OS_DEV_OPEN(function_name);
 
-/*!
+
+/**
  * Generate a function reference to the driver's open() function.
  * @param function_name   Name of the OS_DEV_OPEN() function.
  *
@@ -1171,7 +1231,8 @@ OS_DEV_OPEN(function_name);
 #define OS_DEV_OPEN_REF(function_name)                                        \
 function_name
 
-/*!
+
+/**
  * Define a function which will handle a user's ioctl() request
  *
  * @param function_name The name of the driver ioctl() function
@@ -1182,11 +1243,11 @@ function_name
 static int function_name(struct inode* inode_p_, struct file* file_p_,        \
                      unsigned int cmd_, unsigned long data_)
 
-/*! Boo. */
+/** Boo. */
 #define OS_DEV_IOCTL_DCL(function_name)                                       \
 OS_DEV_IOCTL(function_name);
 
-/*!
+/**
  * Generate a function reference to the driver's ioctl() function.
  * @param function_name   Name of the OS_DEV_IOCTL() function.
  *
@@ -1195,18 +1256,33 @@ OS_DEV_IOCTL(function_name);
 #define OS_DEV_IOCTL_REF(function_name)                                       \
 function_name
 
-/*!
- * Define a function which will handle a user's read() request
+/**
+ * Define a function which will handle a user's mmap() request
  *
- * @param function_name The name of the driver read() function
+ * @param function_name The name of the driver mmap() function
  *
- * @return A call to #os_dev_read_return()
+ * @return A call to #os_dev_ioctl_return()
  */
-#define OS_DEV_READ(function_name)                                            \
-static ssize_t function_name(struct file* file_p_, char* user_buffer_,        \
-                     size_t count_bytes_, loff_t* file_position_)
+#define OS_DEV_MMAP(function_name)                                            \
+int function_name(struct file* file_p_, struct vm_area_struct* vma_)
 
-/*!
+
+#define OS_DEV_MMAP_DCL(function_name)                                        \
+OS_DEV_MMAP(function_name);
+
+#define OS_DEV_MMAP_REF(function_name)                                        \
+function_name
+
+/* Retrieve the context to the memory structure that is to be MMAPed */
+#define os_mmap_memory_ctx() (vma_)
+
+/* Determine the size of the requested MMAP region*/
+#define os_mmap_memory_size() (vma_->vm_end - vma_->vm_start)
+
+/* Determine the base address of the requested MMAP region*/
+#define os_mmap_user_base() (vma_->vm_start)
+
+/**
  * Declare prototype for an read() function.
  *
  * @param function_name The name of the driver read function.
@@ -1214,7 +1290,7 @@ static ssize_t function_name(struct file* file_p_, char* user_buffer_,        \
 #define OS_DEV_READ_DCL(function_name)                                        \
 OS_DEV_READ(function_name);
 
-/*!
+/**
  * Generate a function reference to the driver's read() routine
  * @param function_name   Name of the OS_DEV_READ() function.
  *
@@ -1223,7 +1299,8 @@ OS_DEV_READ(function_name);
 #define OS_DEV_READ_REF(function_name)                                        \
 function_name
 
-/*!
+
+/**
  * Define a function which will handle a user's write() request
  *
  * @param function_name The name of the driver write() function
@@ -1234,7 +1311,8 @@ function_name
 static ssize_t function_name(struct file* file_p_, char* user_buffer_,        \
                      size_t count_bytes_, loff_t* file_position_)
 
-/*!
+
+/**
  * Declare prototype for an write() function.
  *
  * @param function_name The name of the driver write function.
@@ -1242,7 +1320,7 @@ static ssize_t function_name(struct file* file_p_, char* user_buffer_,        \
 #define OS_DEV_WRITE_DCL(function_name)                                       \
 OS_DEV_WRITE(function_name);
 
-/*!
+/**
  * Generate a function reference to the driver's write() routine
  * @param function_name   Name of the OS_DEV_WRITE() function.
  *
@@ -1251,7 +1329,8 @@ OS_DEV_WRITE(function_name);
 #define OS_DEV_WRITE_REF(function_name)                                       \
 function_name
 
-/*!
+
+/**
  * Define a function which will close the device - opposite of OS_DEV_OPEN()
  *
  * @param function_name The name of the driver close() function
@@ -1261,7 +1340,7 @@ function_name
 #define OS_DEV_CLOSE(function_name)                                           \
 static int function_name(struct inode* inode_p_, struct file* file_p_)
 
-/*!
+/**
  * Declare prototype for an close() function
  *
  * @param function_name The name of the driver close() function.
@@ -1269,7 +1348,7 @@ static int function_name(struct inode* inode_p_, struct file* file_p_)
 #define OS_DEV_CLOSE_DCL(function_name)                                       \
 OS_DEV_CLOSE(function_name);
 
-/*!
+/**
  * Generate a function reference to the driver's close function.
  * @param function_name   Name of the OS_DEV_CLOSE() function.
  *
@@ -1278,7 +1357,8 @@ OS_DEV_CLOSE(function_name);
 #define OS_DEV_CLOSE_REF(function_name)                                       \
 function_name
 
-/*!
+
+/**
  * Define a function which will handle an interrupt
  *
  * No arguments are available to the generic function.  It must not invoke any
@@ -1287,7 +1367,7 @@ function_name
  *
  * Example:
  * @code
- * OS_DEV_ISR(widget, widget_isr, WIDGET_IRQ_NUMBER)
+ * OS_DEV_ISR(widget)
  * {
  *     os_dev_isr_return(1);
  * }
@@ -1297,10 +1377,15 @@ function_name
  *
  * @return   A call to #os_dev_isr_return()
  */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#define OS_DEV_ISR(function_name)                                             \
+static irqreturn_t function_name(int N1_, void* N2_, struct pt_regs* N3_)
+#else
 #define OS_DEV_ISR(function_name)                                             \
 static irqreturn_t function_name(int N1_, void* N2_)
+#endif
 
-/*!
+/**
  * Declare prototype for an ISR function.
  *
  * @param function_name The name of the driver ISR function.
@@ -1308,7 +1393,7 @@ static irqreturn_t function_name(int N1_, void* N2_)
 #define OS_DEV_ISR_DCL(function_name)                                         \
 OS_DEV_ISR(function_name);
 
-/*!
+/**
  * Generate a function reference to the driver's interrupt service routine
  * @param function_name   Name of the OS_DEV_ISR() function.
  *
@@ -1317,7 +1402,8 @@ OS_DEV_ISR(function_name);
 #define OS_DEV_ISR_REF(function_name)                                         \
 function_name
 
-/*!
+
+/**
  * Define a function which will operate as a background task / bottom half.
  *
  * Tasklet stuff isn't strictly limited to 'Device drivers', but leave it
@@ -1330,7 +1416,8 @@ function_name
 #define OS_DEV_TASK(function_name)                                            \
 static void function_name(unsigned long data_)
 
-/*!
+
+/**
  * Declare prototype for a background task / bottom half function
  *
  * @param function_name The name of this background task function
@@ -1339,7 +1426,8 @@ static void function_name(unsigned long data_)
 OS_DEV_TASK(function_name);                                                   \
 DECLARE_TASKLET(function_name ## let, function_name, 0);
 
-/*!
+
+/**
  * Generate a reference to an #OS_DEV_TASK() function
  *
  * @param function_name   The name of the task being referenced.
@@ -1347,13 +1435,15 @@ DECLARE_TASKLET(function_name ## let, function_name, 0);
 #define OS_DEV_TASK_REF(function_name)                                        \
     (function_name ## let)
 
-	  /*! @} *//* drsigs */
+
+/** @} */ /* drsigs */
+
 
 /*****************************************************************************
  *  Functions/Macros for returning values from Driver Signature routines
  *****************************************************************************/
 
-/*!
+/**
  * Return from the #OS_DEV_INIT() function
  *
  * @param code    An error code to report success or failure.
@@ -1362,7 +1452,8 @@ DECLARE_TASKLET(function_name ## let, function_name, 0);
 #define os_dev_init_return(code)                                             \
     return code
 
-/*!
+
+/**
  * Return from the #OS_DEV_SHUTDOWN() function
  *
  * @param code    An error code to report success or failure.
@@ -1371,7 +1462,8 @@ DECLARE_TASKLET(function_name ## let, function_name, 0);
 #define os_dev_shutdown_return(code)                                         \
     return
 
-/*!
+
+/**
  * Return from the #OS_DEV_ISR() function
  *
  * The function should verify that it really was supposed to be called,
@@ -1381,6 +1473,17 @@ DECLARE_TASKLET(function_name ## let, function_name, 0);
  * @param code    non-zero if interrupt handled, zero otherwise.
  *
  */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#define os_dev_isr_return(code)                                              \
+do {                                                                         \
+    /* Unused warnings */                                                    \
+    (void)N1_;                                                               \
+    (void)N2_;                                                               \
+    (void)N3_;                                                               \
+                                                                             \
+    return IRQ_RETVAL(code);                                                 \
+} while (0)
+#else
 #define os_dev_isr_return(code)                                              \
 do {                                                                         \
     /* Unused warnings */                                                    \
@@ -1389,8 +1492,10 @@ do {                                                                         \
                                                                              \
     return IRQ_RETVAL(code);                                                 \
 } while (0)
+#endif
 
-/*!
+
+/**
  * Return from the #OS_DEV_OPEN() function
  *
  * @param code    An error code to report success or failure.
@@ -1407,7 +1512,9 @@ do {                                                                         \
     return retcode;                                                          \
 } while (0)
 
-/*!
+
+
+/**
  * Return from the #OS_DEV_IOCTL() function
  *
  * @param code    An error code to report success or failure.
@@ -1426,7 +1533,9 @@ do {                                                                         \
     return retcode;                                                          \
 } while (0)
 
-/*!
+
+
+/**
  * Return from the #OS_DEV_READ() function
  *
  * @param code    Number of bytes read, or an error code to report failure.
@@ -1445,7 +1554,8 @@ do {                                                                         \
     return retcode;                                                          \
 } while (0)
 
-/*!
+
+/**
  * Return from the #OS_DEV_WRITE() function
  *
  * @param code    Number of bytes written, or an error code to report failure.
@@ -1464,7 +1574,7 @@ do {                                                                         \
     return retcode;                                                          \
 } while (0)
 
-/*!
+/**
  * Return from the #OS_DEV_CLOSE() function
  *
  * @param code    An error code to report success or failure.
@@ -1481,7 +1591,8 @@ do {                                                                         \
     return retcode;                                                          \
 } while (0)
 
-/*!
+
+/**
  * Start the #OS_DEV_TASK() function
  *
  * In some implementations, this could be turned into a label for
@@ -1491,7 +1602,8 @@ do {                                                                         \
  */
 #define os_dev_task_begin()
 
-/*!
+
+/**
  * Return from the #OS_DEV_TASK() function
  *
  * In some implementations, this could be turned into a sleep followed
@@ -1508,16 +1620,17 @@ do {                                                                         \
     return;                                                                  \
 } while (0)
 
+
 /*****************************************************************************
  *  Functions/Macros for accessing arguments from Driver Signature routines
  *****************************************************************************/
 
-/*! @defgroup drsigargs Functions for Getting Arguments in Signature functions
+/** @defgroup drsigargs Functions for Getting Arguments in Signature functions
  *
  */
 /* @addtogroup @drsigargs */
-/*! @{ */
-/*!
+/** @{ */
+/**
  * Used in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ() and
  * #OS_DEV_WRITE() routines to check whether user is requesting read
  * (permission)
@@ -1525,7 +1638,7 @@ do {                                                                         \
 #define os_dev_is_flag_read()                                                 \
    (file_p_->f_mode & FMODE_READ)
 
-/*!
+/**
  * Used in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ() and
  * #OS_DEV_WRITE() routines to check whether user is requesting write
  * (permission)
@@ -1533,7 +1646,8 @@ do {                                                                         \
 #define os_dev_is_flag_write()                                                \
    (file_p_->f_mode & FMODE_WRITE)
 
-/*!
+
+/**
  * Used in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ() and
  * #OS_DEV_WRITE() routines to check whether user is requesting non-blocking
  * I/O.
@@ -1541,21 +1655,23 @@ do {                                                                         \
 #define os_dev_is_flag_nonblock()                                             \
    (file_p_->f_flags & (O_NONBLOCK | O_NDELAY))
 
-/*!
+
+/**
  * Used in #OS_DEV_OPEN() and #OS_DEV_CLOSE() to determine major device being
  * accessed.
  */
 #define os_dev_get_major()                                                    \
     (imajor(inode_p_))
 
-/*!
+
+/**
  * Used in #OS_DEV_OPEN() and #OS_DEV_CLOSE() to determine minor device being
  * accessed.
  */
 #define os_dev_get_minor()                                                    \
     (iminor(inode_p_))
 
-/*!
+/**
  * Used in #OS_DEV_IOCTL() to determine which operation the user wants
  * performed.
  *
@@ -1564,7 +1680,7 @@ do {                                                                         \
 #define os_dev_get_ioctl_op()                                                 \
     (cmd_)
 
-/*!
+/**
  * Used in #OS_DEV_IOCTL() to return the associated argument for the desired
  * operation.
  *
@@ -1574,7 +1690,7 @@ do {                                                                         \
 #define os_dev_get_ioctl_arg()                                                \
     (data_)
 
-/*!
+/**
  * Used in OS_DEV_READ() and OS_DEV_WRITE() routines to access the requested
  * byte count.
  *
@@ -1583,7 +1699,7 @@ do {                                                                         \
 #define os_dev_get_count()                                                    \
     ((unsigned)count_bytes_)
 
-/*!
+/**
  * Used in OS_DEV_READ() and OS_DEV_WRITE() routines to return the pointer
  * byte count.
  *
@@ -1592,7 +1708,7 @@ do {                                                                         \
 #define os_dev_get_user_buffer()                                              \
     ((void*)user_buffer_)
 
-/*!
+/**
  * Used in OS_DEV_READ(), OS_DEV_WRITE(), and OS_DEV_IOCTL() routines to
  * get the POSIX flags field for the associated open file).
  *
@@ -1601,7 +1717,8 @@ do {                                                                         \
 #define os_dev_get_file_flags()                                               \
     (file_p_->f_flags)
 
-/*!
+
+/**
  * Set the driver's private structure associated with this file/open.
  *
  * Generally used during #OS_DEV_OPEN().  See #os_dev_get_user_private().
@@ -1611,7 +1728,7 @@ do {                                                                         \
 #define os_dev_set_user_private(struct_p)                                     \
     file_p_->private_data = (void*)(struct_p)
 
-/*!
+/**
  * Get the driver's private structure associated with this file.
  *
  * May be used during #OS_DEV_OPEN(), #OS_DEV_READ(), #OS_DEV_WRITE(),
@@ -1621,17 +1738,28 @@ do {                                                                         \
  */
 #define os_dev_get_user_private()                                             \
     ((void*)file_p_->private_data)
-	   /*! @} *//* drsigargs */
 
-/*!
+
+/**
+ * Get the IRQ associated with this call to the #OS_DEV_ISR() function.
+ *
+ * @return  The IRQ (integer) interrupt number.
+ */
+#define os_dev_get_irq()                                                      \
+    N1_
+
+/** @} */  /* drsigargs */
+
+
+/**
  * @defgroup cacheops Cache Operations
  *
  * These functions are for synchronizing processor cache with RAM.
  */
-/*! @addtogroup cacheops */
-/*! @{ */
+/** @addtogroup cacheops */
+/** @{ */
 
-/*!
+/**
  * Flush and invalidate all cache lines.
  */
 #if 0
@@ -1642,7 +1770,7 @@ do {                                                                         \
 #define os_flush_cache_all()                                              \
     v6_flush_kern_cache_all_L2()
 
-/*!
+/**
  * ARM-routine to flush all cache.  Defined here, because it exists in no
  * easy-access header file.  ARM-11 with L210 cache only!
  */
@@ -1656,7 +1784,7 @@ extern void v6_flush_kern_cache_all_L2(void);
  *  call, which the Sahara driver code will never invoke.
  */
 
-/*!
+/**
  * Clean a range of addresses from the cache.  That is, write updates back
  * to (RAM, next layer).
  *
@@ -1665,13 +1793,20 @@ extern void v6_flush_kern_cache_all_L2(void);
  *
  * @return void
  */
-#define os_cache_clean_range(start,len)						\
-{										\
-	dmac_clean_range(start, (void *)((unsigned long)(start) + len));	\
-	outer_clean_range(__pa(start), __pa((unsigned long)(start) + len));	\
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+#define os_cache_clean_range(start,len)                                   \
+    dma_map_single(NULL, (void*)start, len, DMA_TO_DEVICE)
+#else
+#define os_cache_clean_range(start,len)                                   \
+{                                                                         \
+    void *s = (void*)start;                                               \
+    void *e = s + len;                                                    \
+    dmac_clean_range(s, e);                                               \
+    outer_clean_range(__pa(s), __pa(e));                                  \
 }
+#endif
 
-/*!
+/**
  * Invalidate a range of addresses in the cache
  *
  * @param  start    Starting virtual address
@@ -1679,13 +1814,20 @@ extern void v6_flush_kern_cache_all_L2(void);
  *
  * @return void
  */
-#define os_cache_inv_range(start,len)						\
-{										\
-	dmac_inv_range(start, (void *)((unsigned long)(start) + len));		\
-	outer_inv_range(__pa(start), __pa((unsigned long)(start) + len));	\
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+#define os_cache_inv_range(start,len)                                     \
+    dma_map_single(NULL, (void*)start, len, DMA_FROM_DEVICE)
+#else
+#define os_cache_inv_range(start,len)                                     \
+{                                                                         \
+    void *s = (void*)start;                                               \
+    void *e = s + len;                                                    \
+    dmac_inv_range(s, e);                                                 \
+    outer_inv_range(__pa(s), __pa(e));                                    \
 }
+#endif
 
-/*!
+/**
  * Flush a range of addresses from the cache.  That is, perform clean
  * and invalidate
  *
@@ -1694,12 +1836,20 @@ extern void v6_flush_kern_cache_all_L2(void);
  *
  * @return void
  */
-#define os_cache_flush_range(start,len)						\
-{										\
-	dmac_flush_range(start, (void *)((unsigned long)(start) + len));	\
-	outer_flush_range(__pa(start), __pa((unsigned long)(start) + len));	\
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+#define os_cache_flush_range(start,len)                                   \
+    dma_map_single(NULL, (void*)start, len, DMA_BIDIRECTIONAL)
+#else
+#define os_cache_flush_range(start,len)                                   \
+{                                                                         \
+    void *s = (void*)start;                                               \
+    void *e = s + len;                                                    \
+    dmac_flush_range(s, e);                                               \
+    outer_flush_range(__pa(s), __pa(e));                                  \
 }
+#endif
+
+/** @} */ /* cacheops */
 
-	  /*! @} *//* cacheops */
 
 #endif				/* LINUX_PORT_H */
diff --git a/drivers/mxc/security/sahara2/include/portable_os.h b/drivers/mxc/security/sahara2/include/portable_os.h
index 6211e11..baa5ca6 100644
--- a/drivers/mxc/security/sahara2/include/portable_os.h
+++ b/drivers/mxc/security/sahara2/include/portable_os.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -37,9 +37,10 @@
 
 #endif
 
+
 /***************************************************************************/
 
-/*!
+/**
  * @file portable_os.h
  *
  * This file should be included by portable driver code in order to gain access
@@ -52,7 +53,7 @@
  *
  */
 
-/*!
+/**
  * @if USE_MAINPAGE
  * @mainpage Generic OS API for STC Drivers
  * @endif
@@ -169,6 +170,7 @@
  *
  */
 
+
 /***************************************************************************
  * Compile flags
  **************************************************************************/
@@ -179,7 +181,7 @@
  */
 #ifdef DOXYGEN_PORTABLE_OS_DOC
 
-/*!
+/**
  * @todo module_init()/module_cleanup() for Linux need to be added to OS
  * abstractions.  Also need EXPORT_SYMBOL() equivalent??
  *
@@ -187,14 +189,15 @@
 
 /* Drop OS differentation documentation here */
 
-/*!
+
+/**
  * \#define this flag to build your driver as a Linux driver
  */
 #define LINUX
 
 /* end OS differentation documentation */
 
-/*!
+/**
  * Symbol to give version number of the implementation file.  Earliest
  * definition is in version 1.1, with value 101 (to mean version 1.1)
  */
@@ -210,25 +213,27 @@
  * DOXYGEN_PORTABLE_OS_DOC flag.
  */
 
+
 /***************************************************************************
  * Type definitions
  **************************************************************************/
 
-/*!
+/**
  * Type used for registering and deregistering interrupts.
  *
  * This is typically an interrupt channel number.
  */
 typedef int os_interrupt_id_t;
 
-/*!
+/**
  * Type used as handle for a process
  *
  * See #os_get_process_handle() and #os_send_signal().
  */
 typedef int os_process_handle_t;
 
-/*!
+
+/**
  * Generic return code for functions which need such a thing.
  *
  * No knowledge should be assumed of the value of any of these symbols except
@@ -238,54 +243,63 @@ typedef int os_process_handle_t;
  * too Linux/Unix-specific read()/write() return values) ?
  */
 typedef enum {
-	OS_ERROR_OK_S = 0,	/*!< Success  */
-	OS_ERROR_FAIL_S,	/*!< Generic driver failure */
-	OS_ERROR_NO_MEMORY_S,	/*!< Failure to acquire/use memory  */
-	OS_ERROR_BAD_ADDRESS	/*!< Bad address  */
+    OS_ERROR_OK_S = 0,          /**< Success  */
+    OS_ERROR_FAIL_S,            /**< Generic driver failure */
+    OS_ERROR_NO_MEMORY_S,       /**< Failure to acquire/use memory  */
+    OS_ERROR_BAD_ADDRESS_S,     /**< Bad address  */
+    OS_ERROR_BAD_ARG_S          /**< Bad input argument */
 } os_error_code;
 
-/*!
+
+/**
  * Handle to a lock.
  */
-typedef int *os_lock_t;
+typedef int* os_lock_t;
 
-/*!
+
+/**
  * Context while locking.
  */
 typedef int os_lock_context_t;
 
-/*!
+
+/**
  * An object which can be slept on and later used to wake any/all sleepers.
  */
 typedef int os_sleep_object_t;
 
-/*!
+
+/**
  * Driver registration handle
  */
-typedef void *os_driver_reg_t;
+typedef void* os_driver_reg_t;
+
 
-/*!
+/**
  * Function signature for an #OS_DEV_INIT() function.
  *
  * @return  A call to os_dev_init_return() function.
  */
-typedef void (*os_init_function_t) (void);
+typedef void (*os_init_function_t)(void);
 
-/*!
+
+/**
  * Function signature for an #OS_DEV_SHUTDOWN() function.
  *
  * @return  A call to os_dev_shutdown_return() function.
  */
-typedef void (*os_shutdown_function_t) (void);
+typedef void (*os_shutdown_function_t)(void);
+
 
-/*!
+/**
  * Function signature for a user-driver function.
  *
  * @return  A call to the appropriate os_dev_xxx_return() function.
  */
-typedef void (*os_user_function_t) (void);
+typedef void (*os_user_function_t)(void);
 
-/*!
+
+/**
  * Function signature for the portable interrupt handler
  *
  * While it would be nice to know which interrupt is being serviced, the
@@ -293,9 +307,10 @@ typedef void (*os_user_function_t) (void);
  *
  * @return  A call to #os_dev_isr_return()
  */
-typedef void (*os_interrupt_handler_t) (void);
+typedef void (*os_interrupt_handler_t)(void);
+
 
-/*!
+/**
  * Function signature for a task function
  *
  * Many task function definitions get some sort of generic argument so that the
@@ -305,38 +320,40 @@ typedef void (*os_interrupt_handler_t) (void);
  * This function must be structured as documented by #OS_DEV_TASK().
  *
  */
-typedef void (*os_task_fn_t) (void);
+typedef void (*os_task_fn_t)(void);
+
 
-/*!
+/**
  *  Function types which can be associated with driver entry points.  These are
  *  used in os_driver_add_registration().
  *
  *  Note that init and shutdown are absent.
  */
 typedef enum {
-	OS_FN_OPEN,		/*!< open() operation handler. */
-	OS_FN_CLOSE,		/*!< close() operation handler. */
-	OS_FN_READ,		/*!< read() operation handler. */
-	OS_FN_WRITE,		/*!< write() operation handler. */
-	OS_FN_IOCTL,		/*!< ioctl() operation handler. */
-	OS_FN_MMAP		/*!< mmap() operation handler. */
+    OS_FN_OPEN,                 /**< open() operation handler. */
+    OS_FN_CLOSE,                /**< close() operation handler. */
+    OS_FN_READ,                 /**< read() operation handler. */
+    OS_FN_WRITE,                /**< write() operation handler. */
+    OS_FN_IOCTL,                /**< ioctl() operation handler. */
+    OS_FN_MMAP                  /**< mmap() operation handler. */
 } os_driver_fn_t;
 
+
 /***************************************************************************
  * Driver-to-Kernel Operations
  **************************************************************************/
 
-/*!
+/**
  * @defgroup dkops Driver-to-Kernel Operations
  *
  * These are the operations which drivers should call to get the OS to perform
  * services.
  */
 
-/*! @addtogroup dkops */
-/*! @{ */
+/** @addtogroup dkops */
+/** @{ */
 
-/*!
+/**
  * Register an interrupt handler.
  *
  * @param driver_name    The name of the driver
@@ -346,11 +363,12 @@ typedef enum {
  *
  * @return #os_error_code
  */
-os_error_code os_register_interrupt(char *driver_name,
-				    os_interrupt_id_t interrupt_id,
-				    os_interrupt_handler_t function);
+os_error_code os_register_interrupt(char* driver_name,
+                                    os_interrupt_id_t interrupt_id,
+                                    os_interrupt_handler_t function);
+
 
-/*!
+/**
  * Deregister an interrupt handler.
  *
  * @param interrupt_id   The interrupt line to stop monitoring
@@ -359,7 +377,8 @@ os_error_code os_register_interrupt(char *driver_name,
  */
 os_error_code os_deregister_interrupt(os_interrupt_id_t interrupt_id);
 
-/*!
+
+/**
  * Initialize driver registration.
  *
  * If the driver handles open(), close(), ioctl(), read(), write(), or mmap()
@@ -374,7 +393,8 @@ os_error_code os_deregister_interrupt(os_interrupt_id_t interrupt_id);
  */
 os_error_code os_driver_init_registration(os_driver_reg_t handle);
 
-/*!
+
+/**
  * Add a function registration to driver registration.
  *
  * @param handle    The handle used with #os_driver_init_registration().
@@ -385,9 +405,10 @@ os_error_code os_driver_init_registration(os_driver_reg_t handle);
  * @return void
  */
 void os_driver_add_registration(os_driver_reg_t handle, os_driver_fn_t name,
-				void *function);
+                                void* function);
 
-/*!
+
+/**
  * Finalize the driver registration with the kernel.
  *
  * Upon return from this call, the driver may begin receiving calls at the
@@ -404,9 +425,11 @@ void os_driver_add_registration(os_driver_reg_t handle, os_driver_fn_t name,
  * @return  An error code
  */
 os_error_code os_driver_complete_registration(os_driver_reg_t handle,
-					      int major, char *driver_name);
+                                              int major,
+                                              char* driver_name);
+
 
-/*!
+/**
  * Get driver Major Number from handle after a successful registration.
  *
  * @param   handle  A handle which has completed registration.
@@ -415,7 +438,8 @@ os_error_code os_driver_complete_registration(os_driver_reg_t handle,
  */
 uint32_t os_driver_get_major(os_driver_reg_t handle);
 
-/*!
+
+/**
  * Remove the driver's registration with the kernel.
  *
  * Upon return from this call, the driver not receive any more calls at the
@@ -426,9 +450,10 @@ uint32_t os_driver_get_major(os_driver_reg_t handle);
  *
  * @return  An error code.
  */
-os_error_code os_driver_remove_registration(int major, char *driver_name);
+os_error_code os_driver_remove_registration(int major, char* driver_name);
 
-/*!
+
+/**
  * Print a message to console / into log file.  After the @c msg argument a
  * number of printf-style arguments may be added.  Types should be limited to
  * printf string, char, octal, decimal, and hexadecimal types.  (This excludes
@@ -438,9 +463,10 @@ os_error_code os_driver_remove_registration(int major, char *driver_name);
  *
  * @return (void)
  */
-void os_printk(char *msg, ...);
+void os_printk(char* msg, ...);
+
 
-/*!
+/**
  * Allocate some kernel memory
  *
  * @param amount   Number of 8-bit bytes to allocate
@@ -448,9 +474,10 @@ void os_printk(char *msg, ...);
  *
  * @return  Pointer to allocated memory, or NULL if failed.
  */
-void *os_alloc_memory(unsigned amount, int flags);
+void* os_alloc_memory(unsigned amount, int flags);
 
-/*!
+
+/**
  * Free some kernel memory
  *
  * @param location  The beginning of the region to be freed.
@@ -460,9 +487,10 @@ void *os_alloc_memory(unsigned amount, int flags);
  * size of the buffer being freed?  Perhaps separate routines for each
  * alloc/free pair (DMAable, etc.)?
  */
-void os_free_memory(void *location);
+void os_free_memory(void* location);
+
 
-/*!
+/**
  * Allocate cache-coherent memory
  *
  * @param       amount     Number of bytes to allocate
@@ -474,9 +502,10 @@ void os_free_memory(void *location);
  * @return (virtual space) pointer to allocated memory, or NULL if failed.
  *
  */
-void *os_alloc_coherent(unsigned amount, uint32_t * dma_addrp, int flags);
+void* os_alloc_coherent(unsigned amount, uint32_t* dma_addrp, int flags);
 
-/*!
+
+/**
  * Free cache-coherent memory
  *
  * @param       size       Number of bytes which were allocated.
@@ -488,9 +517,10 @@ void *os_alloc_coherent(unsigned amount, uint32_t * dma_addrp, int flags);
  * @return void
  *
  */
-void os_free_coherent(unsigned size, void *virt_addr, uint32_t dma_addr);
+void os_free_coherent(unsigned size, void* virt_addr, uint32_t dma_addr);
+
 
-/*!
+/**
  * Map an I/O space into kernel memory space
  *
  * @param start       The starting address of the (physical / io space) region
@@ -498,9 +528,11 @@ void os_free_coherent(unsigned size, void *virt_addr, uint32_t dma_addr);
  *
  * @return A pointer to the mapped area, or NULL on failure
  */
-void *os_map_device(uint32_t start, unsigned range_bytes);
+void* os_map_device(uint32_t start, unsigned range_bytes);
+
 
-/*!
+
+/**
  * Unmap an I/O space from kernel memory space
  *
  * @param start       The starting address of the (virtual) region
@@ -508,9 +540,10 @@ void *os_map_device(uint32_t start, unsigned range_bytes);
  *
  * @return None
  */
-void os_unmap_device(void *start, unsigned range_bytes);
+void os_unmap_device(void* start, unsigned range_bytes);
+
 
-/*!
+/**
  * Copy data from Kernel space to User space
  *
  * @param to   The target location in user memory
@@ -519,9 +552,10 @@ void os_unmap_device(void *start, unsigned range_bytes);
  *
  * @return #os_error_code
  */
-os_error_code os_copy_to_user(void *to, void *from, unsigned size);
+os_error_code os_copy_to_user(void* to, void* from, unsigned size);
 
-/*!
+
+/**
  * Copy data from User space to Kernel space
  *
  * @param to   The target location in kernel memory
@@ -530,73 +564,81 @@ os_error_code os_copy_to_user(void *to, void *from, unsigned size);
  *
  * @return #os_error_code
  */
-os_error_code os_copy_from_user(void *to, void *from, unsigned size);
+os_error_code os_copy_from_user(void* to, void* from, unsigned size);
+
 
-/*!
+/**
  * Read an 8-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @return                  The value in the register
  */
-uint8_t os_read8(uint8_t * register_address);
+uint8_t os_read8(uint8_t* register_address);
 
-/*!
+
+/**
  * Write an 8-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @param value             The value to write into the register
  */
-void os_write8(uint8_t * register_address, uint8_t value);
+void os_write8(uint8_t* register_address, uint8_t value);
+
 
-/*!
+/**
  * Read a 16-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @return                  The value in the register
  */
-uint16_t os_read16(uint16_t * register_address);
+uint16_t os_read16(uint16_t* register_address);
+
 
-/*!
+/**
  * Write a 16-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @param value             The value to write into the register
  */
-void os_write16(uint16_t * register_address, uint16_t value);
+void os_write16(uint16_t* register_address, uint16_t value);
 
-/*!
+/**
  * Read a 32-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @return                  The value in the register
  */
-uint32_t os_read32(uint32_t * register_address);
+uint32_t os_read32(uint32_t* register_address);
 
-/*!
+
+/**
  * Write a 32-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @param value             The value to write into the register
  */
-void os_write32(uint32_t * register_address, uint32_t value);
+void os_write32(uint32_t* register_address, uint32_t value);
+
 
-/*!
+/**
  * Read a 64-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @return                  The value in the register
  */
-uint64_t os_read64(uint64_t * register_address);
+uint64_t os_read64(uint64_t* register_address);
 
-/*!
+
+/**
  * Write a 64-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @param value             The value to write into the register
  */
-void os_write64(uint64_t * register_address, uint64_t value);
+void os_write64(uint64_t* register_address, uint64_t value);
+
 
-/*!
+/**
  * Prepare a task to execute the given function.  This should only be done once
  * per task, during the driver's initialization routine.
  *
@@ -604,9 +646,10 @@ void os_write64(uint64_t * register_address, uint64_t value);
  *
  * @return an OS ERROR code.
  */
-os_error os_create_task(os_task_fn_t * task_fn);
+os_error os_create_task(os_task_fn_t* task_fn);
 
-/*!
+
+/**
  * Run the task associated with an #OS_DEV_TASK() function
  *
  * The task will begin execution sometime after or during this call.
@@ -615,9 +658,9 @@ os_error os_create_task(os_task_fn_t * task_fn);
  *
  * @return void
  */
-void os_schedule_task(os_task_fn_t * task_fn);
+void os_schedule_task(os_task_fn_t* task_fn);
 
-/*!
+/**
  * Make sure that task is no longer running and will no longer run.
  *
  * This function will not return until both are true.  This is useful when
@@ -626,9 +669,10 @@ void os_schedule_task(os_task_fn_t * task_fn);
  * @param task_fn   Name of the OS_DEV_TASK() funciton to be stopped.
  *
  */
-void os_stop_task(os_task_fn_t * task_fn);
+void os_stop_task(os_task_fn_t* task_fn);
+
 
-/*!
+/**
  * Delay some number of microseconds
  *
  * Note that this is a busy-loop, not a suspension of the task/process.
@@ -639,7 +683,8 @@ void os_stop_task(os_task_fn_t * task_fn);
  */
 void os_mdelay(unsigned long msecs);
 
-/*!
+
+/**
  * Calculate virtual address from physical address
  *
  * @param pa    Physical address
@@ -650,7 +695,8 @@ void os_mdelay(unsigned long msecs);
  */
 void *os_va(uint32_t pa);
 
-/*!
+
+/**
  * Calculate physical address from virtual address
  *
  *
@@ -660,9 +706,10 @@ void *os_va(uint32_t pa);
  *
  * @note this assumes that addresses are 32 bits wide
  */
-uint32_t os_pa(void *va);
+uint32_t os_pa(void* va);
+
 
-/*!
+/**
  * Allocate and initialize a lock, returning a lock handle.
  *
  * The lock state will be initialized to 'unlocked'.
@@ -671,7 +718,8 @@ uint32_t os_pa(void *va);
  */
 os_lock_t os_lock_alloc_init(void);
 
-/*!
+
+/**
  * Acquire a lock.
  *
  * This function should only be called from an interrupt service routine.
@@ -682,7 +730,8 @@ os_lock_t os_lock_alloc_init(void);
  */
 void os_lock(os_lock_t lock_handle);
 
-/*!
+
+/**
  * Unlock a lock.  Lock must have been acquired by #os_lock().
  *
  * @param   lock_handle  A handle to the lock to unlock.
@@ -691,7 +740,7 @@ void os_lock(os_lock_t lock_handle);
  */
 void os_unlock(os_lock_t lock_handle);
 
-/*!
+/**
  * Acquire a lock in non-ISR context
  *
  * This function will spin until the lock is available.
@@ -703,7 +752,7 @@ void os_unlock(os_lock_t lock_handle);
  */
 void os_lock_save_context(os_lock_t lock_handle, os_lock_context_t context);
 
-/*!
+/**
  * Release a lock in non-ISR context
  *
  * @param lock_handle  A handle of the lock to release.
@@ -712,9 +761,9 @@ void os_lock_save_context(os_lock_t lock_handle, os_lock_context_t context);
  * @return void
  */
 void os_unlock_restore_context(os_lock_t lock_handle,
-			       os_lock_context_t context);
+                               os_lock_context_t context);
 
-/*!
+/**
  * Deallocate a lock handle.
  *
  * @param lock_handle   An #os_lock_t that has been allocated.
@@ -723,7 +772,8 @@ void os_unlock_restore_context(os_lock_t lock_handle,
  */
 void os_lock_deallocate(os_lock_t lock_handle);
 
-/*!
+
+/**
  * Determine process handle
  *
  * The process handle of the current user is returned.
@@ -732,7 +782,8 @@ void os_lock_deallocate(os_lock_t lock_handle);
  */
 os_process_handle_t os_get_process_handle();
 
-/*!
+
+/**
  * Send a signal to a process
  *
  * @param  proc   A handle to the target process.
@@ -740,7 +791,8 @@ os_process_handle_t os_get_process_handle();
  */
 void os_send_signal(os_process_handle_t proc, int sig);
 
-/*!
+
+/**
  * Get some random bytes
  *
  * @param buf    The location to store the random data.
@@ -748,9 +800,9 @@ void os_send_signal(os_process_handle_t proc, int sig);
  *
  * @return  void
  */
-void os_get_random_bytes(void *buf, unsigned count);
+void os_get_random_bytes(void* buf, unsigned count);
 
-/*!
+/**
  * Go to sleep on an object.
  *
  * Example: code = os_sleep(my_queue, available_count == 0, 0);
@@ -764,9 +816,10 @@ void os_get_random_bytes(void *buf, unsigned count);
  * @return error code -- OK or sleep interrupted??
  */
 os_error_code os_sleep(os_sleep_object_t object, unsigned condition,
-		       unsigned atomic);
+                       unsigned atomic);
 
-/*!
+
+/**
  * Wake up whatever is sleeping on sleep object
  *
  * @param object  The object on which things might be sleeping
@@ -775,13 +828,15 @@ os_error_code os_sleep(os_sleep_object_t object, unsigned condition,
  */
 void os_wake_sleepers(os_sleep_object_t object);
 
-	  /*! @} *//* dkops */
+
+/** @} */ /* dkops */
+
 
 /*****************************************************************************
  *  Function-signature-generating macros
  *****************************************************************************/
 
-/*!
+/**
  * @defgroup drsigs Driver Function Signatures
  *
  * These macros will define the entry point signatures for interrupt handlers;
@@ -832,10 +887,10 @@ void os_wake_sleepers(os_sleep_object_t object);
  * @endcode
  */
 
-/*! @addtogroup drsigs */
-/*! @{ */
+/** @addtogroup drsigs */
+/** @{ */
 
-/*!
+/**
  * Define a function which will handle device initialization
  *
  * This is tne driver initialization routine.  This is normally where the
@@ -849,7 +904,8 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_INIT(function_name)
 
-/*!
+
+/**
  * Define a function which will handle device shutdown
  *
  * This is the reverse of the #OS_DEV_INIT() routine.
@@ -860,7 +916,8 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_SHUTDOWN(function_name)
 
-/*!
+
+/**
  * Define a function which will open the device for a user.
  *
  * @param function_name The name of the driver open() function
@@ -869,7 +926,8 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_OPEN(function_name)
 
-/*!
+
+/**
  * Define a function which will handle a user's ioctl() request
  *
  * @param function_name The name of the driver ioctl() function
@@ -878,7 +936,8 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_IOCTL(function_name)
 
-/*!
+
+/**
  * Define a function which will handle a user's read() request
  *
  * @param function_name The name of the driver read() function
@@ -887,7 +946,8 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_READ(function_name)
 
-/*!
+
+/**
  * Define a function which will handle a user's write() request
  *
  * @param function_name The name of the driver write() function
@@ -896,7 +956,8 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_WRITE(function_name)
 
-/*!
+
+/**
  * Define a function which will handle a user's mmap() request
  *
  * The mmap() function requests the driver to map some memory into user space.
@@ -909,7 +970,8 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_MMAP(function_name)
 
-/*!
+
+/**
  * Define a function which will close the device - opposite of OS_DEV_OPEN()
  *
  * @param function_name The name of the driver close() function
@@ -918,7 +980,8 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_CLOSE(function_name)
 
-/*!
+
+/**
  * Define a function which will handle an interrupt
  *
  * No arguments are available to the generic function.  It must not invoke any
@@ -939,7 +1002,8 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_ISR(function_name)
 
-/*!
+
+/**
  * Define a function which will operate as a background task / bottom half.
  *
  * The function implementation must be structured in the following manner:
@@ -963,25 +1027,27 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_TASK(function_name)
 
-	  /*! @} *//* drsigs */
+/** @} */ /* drsigs */
+
 
-/*! @defgroup dclsigs Routines to declare Driver Signature routines
+/** @defgroup dclsigs Routines to declare Driver Signature routines
  *
  * These macros drop prototypes suitable for forward-declaration of
  * @ref drsigs "function signatures".
  */
 
-/*! @addtogroup dclsigs */
-/*! @{ */
+/** @addtogroup dclsigs */
+/** @{ */
 
-/*!
+/**
  * Declare prototype for the device initialization function
  *
  * @param function_name   The name of the portable initialization function.
  */
 #define OS_DEV_INIT_DCL(function_name)
 
-/*!
+
+/**
  * Declare prototype for the device shutdown function
  *
  * @param function_name   The name of the portable driver shutdown routine.
@@ -990,7 +1056,8 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_SHUTDOWN_DCL(function_name)
 
-/*!
+
+/**
  * Declare prototype for the open() function.
  *
  * @param function_name The name of the driver open() function
@@ -999,7 +1066,8 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_OPEN_DCL(function_name)
 
-/*!
+
+/**
  * Declare prototype for the user's ioctl() request function
  *
  * @param function_name The name of the driver ioctl() function
@@ -1008,28 +1076,32 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_IOCTL_DCL(function_name)
 
-/*!
+
+/**
  * Declare prototype for the function a user's read() request
  *
  * @param function_name The name of the driver read() function
  */
 #define OS_DEV_READ_DCL(function_name)
 
-/*!
+
+/**
  * Declare prototype for the user's write() request function
  *
  * @param function_name The name of the driver write() function
  */
 #define OS_DEV_WRITE_DCL(function_name)
 
-/*!
+
+/**
  * Declare prototype for the user's mmap() request function
  *
  * @param function_name The name of the driver mmap() function
  */
 #define OS_DEV_MMAP_DCL(function_name)
 
-/*!
+
+/**
  * Declare prototype for the close function
  *
  * @param function_name The name of the driver close() function
@@ -1038,34 +1110,37 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_CLOSE_DCL(function_name)
 
-/*!
+
+/**
  * Declare prototype for the interrupt handling function
  *
  * @param function_name The name of the driver ISR function
  */
 #define OS_DEV_ISR_DCL(function_name)
 
-/*!
+
+/**
  * Declare prototype for a background task / bottom half function
  *
  * @param function_name The name of this background task function
  */
 #define OS_DEV_TASK_DCL(function_name)
 
-	  /*! @} *//* dclsigs */
+/** @} */ /* dclsigs */
+
 
 /*****************************************************************************
  *  Functions for Returning Values from Driver Signature routines
  *****************************************************************************/
 
-/*!
+/**
  * @defgroup retfns Functions to Return Values from Driver Signature routines
  */
 
-/*! @addtogroup retfns */
-/*! @{ */
+/** @addtogroup retfns */
+/** @{ */
 
-/*!
+/**
  * Return from the #OS_DEV_INIT() function
  *
  * @param code    An error code to report success or failure.
@@ -1073,7 +1148,8 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 void os_dev_init_return(os_error_code code);
 
-/*!
+
+/**
  * Return from the #OS_DEV_SHUTDOWN() function
  *
  * @param code    An error code to report success or failure.
@@ -1081,7 +1157,8 @@ void os_dev_init_return(os_error_code code);
  */
 void os_dev_shutdown_return(os_error_code code);
 
-/*!
+
+/**
  * Return from the #OS_DEV_ISR() function
  *
  * The function should verify that it really was supposed to be called,
@@ -1093,7 +1170,8 @@ void os_dev_shutdown_return(os_error_code code);
  */
 void os_dev_isr_return(int code);
 
-/*!
+
+/**
  * Return from the #OS_DEV_OPEN() function
  *
  * @param code    An error code to report success or failure.
@@ -1101,7 +1179,8 @@ void os_dev_isr_return(int code);
  */
 void os_dev_open_return(os_error_code code);
 
-/*!
+
+/**
  * Return from the #OS_DEV_IOCTL() function
  *
  * @param code    An error code to report success or failure.
@@ -1109,7 +1188,8 @@ void os_dev_open_return(os_error_code code);
  */
 void os_dev_ioctl_return(os_error_code code);
 
-/*!
+
+/**
  * Return from the #OS_DEV_READ() function
  *
  * @param code    Number of bytes read, or an error code to report failure.
@@ -1117,7 +1197,8 @@ void os_dev_ioctl_return(os_error_code code);
  */
 void os_dev_read_return(os_error_code code);
 
-/*!
+
+/**
  * Return from the #OS_DEV_WRITE() function
  *
  * @param code    Number of bytes written, or an error code to report failure.
@@ -1125,7 +1206,8 @@ void os_dev_read_return(os_error_code code);
  */
 void os_dev_write_return(os_error_code code);
 
-/*!
+
+/**
  * Return from the #OS_DEV_MMAP() function
  *
  * @param code    Number of bytes written, or an error code to report failure.
@@ -1133,7 +1215,8 @@ void os_dev_write_return(os_error_code code);
  */
 void os_dev_mmap_return(os_error_code code);
 
-/*!
+
+/**
  * Return from the #OS_DEV_CLOSE() function
  *
  * @param code    An error code to report success or failure.
@@ -1141,7 +1224,7 @@ void os_dev_mmap_return(os_error_code code);
  */
 void os_dev_close_return(os_error_code code);
 
-/*!
+/**
  * Start the #OS_DEV_TASK() function
  *
  * In some implementations, this could be turned into a label for
@@ -1154,7 +1237,8 @@ void os_dev_close_return(os_error_code code);
  */
 void os_dev_task_begin(void);
 
-/*!
+
+/**
  * Return from the #OS_DEV_TASK() function
  *
  * In some implementations, this could be turned into a sleep followed
@@ -1165,33 +1249,37 @@ void os_dev_task_begin(void);
  */
 void os_dev_task_return(os_error_code code);
 
-	  /*! @} *//* retfns */
+
+/** @} */ /* retfns */
+
 
 /*****************************************************************************
  *  Functions/Macros for accessing arguments from Driver Signature routines
  *****************************************************************************/
 
-/*! @defgroup drsigargs Functions for Getting Arguments in Signature functions
+/** @defgroup drsigargs Functions for Getting Arguments in Signature functions
  *
  */
 /* @addtogroup @drsigargs */
-/*! @{ */
+/** @{ */
 
-/*!
+/**
  * Check whether user is requesting read (permission) on the file/device.
  * Usable in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ()
  * and #OS_DEV_WRITE() routines.
  */
 int os_dev_is_flag_read(void);
 
-/*!
+
+/**
  * Check whether user is requesting write (permission) on the file/device.
  * Usable in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ()
  * and #OS_DEV_WRITE() routines.
  */
 int os_dev_is_flag_write(void);
 
-/*!
+
+/**
  * Check whether user is requesting non-blocking I/O.  Usable in
  * #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ() and
  * #OS_DEV_WRITE() routines.
@@ -1202,19 +1290,22 @@ int os_dev_is_flag_write(void);
  */
 int os_dev_is_flag_nonblock(void);
 
-/*!
+
+/**
  * Determine which major device is being accessed.  Usable in #OS_DEV_OPEN()
  * and #OS_DEV_CLOSE().
  */
 int os_dev_get_major(void);
 
-/*!
+
+/**
  * Determine which minor device is being accessed.  Usable in #OS_DEV_OPEN()
  * and #OS_DEV_CLOSE().
  */
 int os_dev_get_minor(void);
 
-/*!
+
+/**
  * Determine which operation the user wants performed.  Usable in
  * #OS_DEV_IOCTL().
  *
@@ -1224,7 +1315,8 @@ int os_dev_get_minor(void);
  */
 unsigned os_dev_get_ioctl_op(void);
 
-/*!
+
+/**
  * Retrieve the associated argument for the desired operation.  Usable in
  * #OS_DEV_IOCTL().
  *
@@ -1233,7 +1325,8 @@ unsigned os_dev_get_ioctl_op(void);
  */
 os_dev_ioctl_arg_t os_dev_get_ioctl_arg(void);
 
-/*!
+
+/**
  * Determine the requested byte count. This should be the size of buffer at
  * #os_dev_get_user_buffer(). Usable in OS_DEV_READ() and OS_DEV_WRITE()
  * routines.
@@ -1242,16 +1335,18 @@ os_dev_ioctl_arg_t os_dev_get_ioctl_arg(void);
  */
 unsigned os_dev_get_count(void);
 
-/*!
+
+/**
  * Get the pointer to the user's data buffer. Usable in OS_DEV_READ(),
  * OS_DEV_WRITE(), and OS_DEV_MMAP() routines.
  *
  * @return   Pointer to user buffer (in user space).  See #os_copy_to_user()
  *           and #os_copy_from_user().
  */
-void *os_dev_get_user_buffer(void);
+void* os_dev_get_user_buffer(void);
 
-/*!
+
+/**
  * Get the POSIX flags field for the associated open file.  Usable in
  * OS_DEV_READ(), OS_DEV_WRITE(), and OS_DEV_IOCTL() routines.
  *
@@ -1259,7 +1354,7 @@ void *os_dev_get_user_buffer(void);
  */
 unsigned os_dev_get_file_flags(void);
 
-/*!
+/**
  * Set the driver's private structure associated with this file/open.
  *
  * Generally used during #OS_DEV_OPEN().  May also be used during
@@ -1268,9 +1363,10 @@ unsigned os_dev_get_file_flags(void);
  *
  * @param  struct_p   The driver data structure to associate with this user.
  */
-void os_dev_set_user_private(void *struct_p);
+void os_dev_set_user_private(void* struct_p);
+
 
-/*!
+/**
  * Get the driver's private structure associated with this file.
  *
  * May be used during #OS_DEV_OPEN(), #OS_DEV_READ(), #OS_DEV_WRITE(),
@@ -1279,15 +1375,24 @@ void os_dev_set_user_private(void *struct_p);
  *
  * @return   The driver data structure to associate with this user.
  */
-void *os_dev_get_user_private(void);
+void* os_dev_get_user_private(void);
+
+
+/**
+ * Get the IRQ associated with this call to the #OS_DEV_ISR() function.
+ *
+ * @return  The IRQ (integer) interrupt number.
+ */
+int os_dev_get_irq(void);
+
+/** @} */ /* drsigargs */
 
-	  /*! @} *//* drsigargs */
 
 /*****************************************************************************
  *  Functions for Generating References to Driver Routines
  *****************************************************************************/
 
-/*!
+/**
  * @defgroup drref Functions for Generating References to Driver Routines
  *
  * These functions will most likely be implemented as macros.  They are a
@@ -1300,10 +1405,10 @@ void *os_dev_get_user_private(void);
  * passing a pointer to the function.
  */
 
-/*! @addtogroup drref */
-/*! @{ */
+/** @addtogroup drref */
+/** @{ */
 
-/*!
+/**
  * Generate a reference to an #OS_DEV_INIT() function
  *
  * @param function_name   The name of the init function being referenced.
@@ -1312,7 +1417,8 @@ void *os_dev_get_user_private(void);
  */
 os_init_function_t OS_DEV_INIT_REF(symbol function_name);
 
-/*!
+
+/**
  * Generate a reference to an #OS_DEV_SHUTDOWN() function
  *
  * @param function_name   The name of the shutdown function being referenced.
@@ -1321,7 +1427,8 @@ os_init_function_t OS_DEV_INIT_REF(symbol function_name);
  */
 os_shutdown_function_t OS_DEV_SHUTDOWN_REF(symbol function_name);
 
-/*!
+
+/**
  * Generate a reference to an #OS_DEV_OPEN() function
  *
  * @param function_name   The name of the open function being referenced.
@@ -1330,7 +1437,8 @@ os_shutdown_function_t OS_DEV_SHUTDOWN_REF(symbol function_name);
  */
 os_user_function_t OS_DEV_OPEN_REF(symbol function_name);
 
-/*!
+
+/**
  * Generate a reference to an #OS_DEV_CLOSE() function
  *
  * @param function_name   The name of the close function being referenced.
@@ -1339,7 +1447,8 @@ os_user_function_t OS_DEV_OPEN_REF(symbol function_name);
  */
 os_user_function_t OS_DEV_CLOSE_REF(symbol function_name);
 
-/*!
+
+/**
  * Generate a reference to an #OS_DEV_READ() function
  *
  * @param function_name   The name of the read function being referenced.
@@ -1348,7 +1457,8 @@ os_user_function_t OS_DEV_CLOSE_REF(symbol function_name);
  */
 os_user_function_t OS_DEV_READ_REF(symbol function_name);
 
-/*!
+
+/**
  * Generate a reference to an #OS_DEV_WRITE() function
  *
  * @param function_name   The name of the write function being referenced.
@@ -1357,7 +1467,8 @@ os_user_function_t OS_DEV_READ_REF(symbol function_name);
  */
 os_user_function_t OS_DEV_WRITE_REF(symbol function_name);
 
-/*!
+
+/**
  * Generate a reference to an #OS_DEV_IOCTL() function
  *
  * @param function_name   The name of the ioctl function being referenced.
@@ -1366,7 +1477,8 @@ os_user_function_t OS_DEV_WRITE_REF(symbol function_name);
  */
 os_user_function_t OS_DEV_IOCTL_REF(symbol function_name);
 
-/*!
+
+/**
  * Generate a reference to an #OS_DEV_MMAP() function
  *
  * @param function_name   The name of the mmap function being referenced.
@@ -1375,7 +1487,8 @@ os_user_function_t OS_DEV_IOCTL_REF(symbol function_name);
  */
 os_user_function_t OS_DEV_MMAP_REF(symbol function_name);
 
-/*!
+
+/**
  * Generate a reference to an #OS_DEV_ISR() function
  *
  * @param function_name   The name of the isr being referenced.
@@ -1384,37 +1497,43 @@ os_user_function_t OS_DEV_MMAP_REF(symbol function_name);
  */
 os_interrupt_handler_t OS_DEV_ISR_REF(symbol function_name);
 
-	  /*! @} *//* drref */
 
-/*!
+/** @} */ /* drref */
+
+
+/**
  * Flush and invalidate all cache lines.
  */
 void os_flush_cache_all(void);
 
-/*!
+
+/**
  * Flush a range of addresses from the cache
  *
  * @param  start    Starting virtual address
  * @param  len      Number of bytes to flush
  */
-void os_cache_flush_range(void *start, uint32_t len);
+void os_cache_flush_range(void* start, uint32_t len);
 
-/*!
+
+/**
  * Invalidate a range of addresses in the cache
  *
  * @param  start    Starting virtual address
  * @param  len      Number of bytes to flush
  */
-void os_cache_inv_range(void *start, uint32_t len);
+void os_cache_inv_range(void* start, uint32_t len);
+
 
-/*!
+/**
  * Clean a range of addresses from the cache
  *
  * @param  start    Starting virtual address
  * @param  len      Number of bytes to flush
  */
-void os_cache_clean_range(void *start, uint32_t len);
+void os_cache_clean_range(void* start, uint32_t len);
+
+#endif /* DOXYGEN_PORTABLE_OS_DOC */
 
-#endif				/* DOXYGEN_PORTABLE_OS_DOC */
 
 #endif				/* PORTABLE_OS_H */
diff --git a/drivers/mxc/security/scc2_driver.c b/drivers/mxc/security/scc2_driver.c
index 85c2a73..d7b98be 100644
--- a/drivers/mxc/security/scc2_driver.c
+++ b/drivers/mxc/security/scc2_driver.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -65,10 +65,7 @@
 
 #include <linux/dmapool.h>
 
-#define SAHARA_PART_NO 4
-#define VPU_PART_NO   0
-
-/*!
+/**
  * This is the set of errors which signal that access to the SCM RAM has
  * failed or will fail.
  */
@@ -92,7 +89,7 @@ typedef char *(*reg_print_routine_t) (uint32_t value, char *print_buffer,
 
 #endif
 
-/*!
+/**
  * This is type void* so that a) it cannot directly be dereferenced,
  * and b) pointer arithmetic on it will function in a 'normal way' for
  * the offsets in scc_defines.h
@@ -111,40 +108,24 @@ typedef char *(*reg_print_routine_t) (uint32_t value, char *print_buffer,
  */
 static volatile void *scc_base;
 
-/*! Array to hold function pointers registered by
+/** Array to hold function pointers registered by
     #scc_monitor_security_failure() and processed by
     #scc_perform_callbacks() */
 static void (*scc_callbacks[SCC_CALLBACK_SIZE]) (void);
 
-uint32_t scm_ram_phys_base = SCM_RAM_BASE_ADDR;
+uint32_t scm_ram_phys_base = SCC_IRAM_BASE_ADDR;
 
 void *scm_ram_base = NULL;
 
-/*!
- * Starting address of Sahara key partition
- */
-uint8_t *sahara_partition_base;
-dma_addr_t sahara_partition_phys;
-
-uint8_t *scm_black_part_virt;
-uint32_t scm_black_part_phys;
-
-uint8_t *scm_red_part_virt;
-uint32_t scm_red_part_cmd;
-/*!
- * Starting address of VPU Partition
- */
-uint8_t *vpu_partition_base;
-dma_addr_t vpu_partition_phys;
-/*! Calculated once for quick reference to size of the unreserved space in
+/** Calculated once for quick reference to size of the unreserved space in
  *  RAM in SCM.
  */
 uint32_t scm_memory_size_bytes;
 
-/*! Structure returned by #scc_get_configuration() */
+/** Structure returned by #scc_get_configuration() */
 static scc_config_t scc_configuration = {
-	.driver_major_version = SCC_DRIVER_MAJOR_VERSION_1,
-	.driver_minor_version = SCC_DRIVER_MINOR_VERSION_97,
+	.driver_major_version = SCC_DRIVER_MAJOR_VERSION,
+	.driver_minor_version = SCC_DRIVER_MINOR_VERSION,
 	.scm_version = -1,
 	.smn_version = -1,
 	.block_size_bytes = -1,
@@ -152,65 +133,357 @@ static scc_config_t scc_configuration = {
 	.partition_count = -1,
 };
 
-/*! Key Control Information.  Integrity is controlled by use of
-    #scc_crypto_lock. */
-static struct scc_key_slot scc_key_info[SCC_KEY_SLOTS];
-
-/*! Internal flag to know whether SCC is in Failed state (and thus many
+/** Internal flag to know whether SCC is in Failed state (and thus many
  *  registers are unavailable).  Once it goes failed, it never leaves it. */
 static volatile enum scc_status scc_availability = SCC_STATUS_INITIAL;
 
-/*! Flag to say whether interrupt handler has been registered for
+/** Flag to say whether interrupt handler has been registered for
  * SMN interrupt */
 static int smn_irq_set = 0;
 
-/*! Flag to say whether interrupt handler has been registered for
+/** Flag to say whether interrupt handler has been registered for
  * SCM interrupt */
 static int scm_irq_set = 0;
 
-/*! This lock protects the #scc_callbacks list as well as the @c
+/** This lock protects the #scc_callbacks list as well as the @c
  * callbacks_performed flag in #scc_perform_callbacks.  Since the data this
  * protects may be read or written from either interrupt or base level, all
  * operations should use the irqsave/irqrestore or similar to make sure that
  * interrupts are inhibited when locking from base level.
  */
-static spinlock_t scc_callbacks_lock = SPIN_LOCK_UNLOCKED;
+static os_lock_t scc_callbacks_lock = NULL;
 
-/*!
- * Ownership of this lock prevents conflicts on the crypto operation in the SCC
- * and the integrity of the #scc_key_info.
+/**
+ * Ownership of this lock prevents conflicts on the crypto operation in the
+ * SCC.
  */
-static spinlock_t scc_crypto_lock = SPIN_LOCK_UNLOCKED;
-
-/*! Calculated once for quick reference to size of SCM address space */
-//static uint32_t scm_highest_memory_address;
+static os_lock_t scc_crypto_lock = NULL;
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18))
-/*! Pointer to SCC's clock information.  Initialized during scc_init(). */
+/** Pointer to SCC's clock information.  Initialized during scc_init(). */
 static struct clk *scc_clk = NULL;
 #endif
 
-/*! The lookup table for an 8-bit value.  Calculated once
+/** The lookup table for an 8-bit value.  Calculated once
  * by #scc_init_ccitt_crc().
  */
 static uint16_t scc_crc_lookup_table[256];
 
-/*! Fixed padding for appending to plaintext to fill out a block */
-static uint8_t scc_block_padding[16] =
-    { SCC_DRIVER_PAD_CHAR, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-
-static scc_return_t make_sahara_partition(void);
-uint8_t make_vpu_partition(void);
 /******************************************************************************
  *
  *  Function Implementations - Externally Accessible
  *
  *****************************************************************************/
 
+/**
+ * Allocate a partition of secure memory
+ *
+ * @param       smid_value  Value to use for the SMID register.  Must be 0 for
+ *                          kernel mode access.
+ * @param[out]  part_no     (If successful) Assigned partition number.
+ * @param[out]  part_base   Kernel virtual address of the partition.
+ * @param[out]  part_phys   Physical address of the partition.
+ *
+ * @return
+ */
+scc_return_t scc_allocate_partition(uint32_t smid_value,
+				    int *part_no,
+				    void **part_base, uint32_t *part_phys)
+{
+	uint32_t i;
+	os_lock_context_t irq_flags = 0;	/* for IRQ save/restore */
+	int local_part;
+	scc_return_t retval = SCC_RET_FAIL;
+	void *base_addr = NULL;
+	uint32_t reg_value;
+
+	local_part = -1;
+
+	if (scc_availability == SCC_STATUS_INITIAL) {
+		scc_init();
+	}
+	if (scc_availability == SCC_STATUS_UNIMPLEMENTED) {
+		goto out;
+	}
+
+	/* ACQUIRE LOCK to prevent others from using crypto or acquiring a
+	 * partition.  Note that crypto operations could take a long time, so the
+	 * calling process could potentially spin for some time.
+	 */
+	os_lock_save_context(scc_crypto_lock, irq_flags);
+
+	do {
+		/* Find current state of partition ownership */
+		reg_value = SCC_READ_REGISTER(SCM_PART_OWNERS_REG);
+
+		/* Search for a free one */
+		for (i = 0; i < scc_configuration.partition_count; i++) {
+			if (((reg_value >> (SCM_POWN_SHIFT * i))
+			     & SCM_POWN_MASK) == SCM_POWN_PART_FREE) {
+				break;	/* found a free one */
+			}
+		}
+		if (i == local_part) {
+			/* found this one last time, and failed to allocated it */
+			pr_debug(KERN_ERR "Partition %d cannot be allocated\n",
+				 i);
+			goto out;
+		}
+		if (i >= scc_configuration.partition_count) {
+			retval = SCC_RET_INSUFFICIENT_SPACE;	/* all used up */
+			goto out;
+		}
+
+		pr_debug
+		    ("SCC2: Attempting to allocate partition %i, owners:%08x\n",
+		     i, SCC_READ_REGISTER(SCM_PART_OWNERS_REG));
+
+		local_part = i;
+		/* Store SMID to grab a partition */
+		SCC_WRITE_REGISTER(SCM_SMID0_REG +
+				   SCM_SMID_WIDTH * (local_part), smid_value);
+		mdelay(2);
+
+		/* Now make sure it is ours... ? */
+		reg_value = SCC_READ_REGISTER(SCM_PART_OWNERS_REG);
+
+		if (((reg_value >> (SCM_POWN_SHIFT * (local_part)))
+		     & SCM_POWN_MASK) != SCM_POWN_PART_OWNED) {
+			continue;	/* try for another */
+		}
+		base_addr = scm_ram_base +
+		    (local_part * scc_configuration.partition_size_bytes);
+		break;
+	} while (1);
+
+out:
+
+	/* Free the lock */
+	os_unlock_restore_context(scc_callbacks_lock, irq_flags);
+
+	/* If the base address was assigned, then a partition was successfully
+	 * acquired.
+	 */
+	if (base_addr != NULL) {
+		pr_debug("SCC2 Part owners: %08x, engaged: %08x\n",
+			 reg_value, SCC_READ_REGISTER(SCM_PART_ENGAGED_REG));
+		pr_debug("SCC2 MAP for part %d: %08x\n",
+			 local_part,
+			 SCC_READ_REGISTER(SCM_ACC0_REG + 8 * local_part));
+
+		/* Copy the partition information to the data structures passed by the
+		 * user.
+		 */
+		*part_no = local_part;
+		*part_base = base_addr;
+		*part_phys = (uint32_t) scm_ram_phys_base
+		    + (local_part * scc_configuration.partition_size_bytes);
+		retval = SCC_RET_OK;
+
+		pr_debug
+		    ("SCC2 partition engaged.  Kernel address: %p.  Physical "
+		     "address: %p, pfn: %08x\n", *part_base, (void *)*part_phys,
+		     __phys_to_pfn(*part_phys));
+	}
+
+	return retval;
+}				/* allocate_partition() */
+
+/**
+ * Release a partition of secure memory
+ *
+ * @param   part_base   Kernel virtual address of the partition to be released.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+scc_return_t scc_release_partition(void *part_base)
+{
+	uint32_t partition_no;
+
+	if (part_base == NULL) {
+		return SCC_RET_FAIL;
+	}
+
+	/* Ensure that this is a proper partition location */
+	partition_no = SCM_PART_NUMBER((uint32_t) part_base);
+
+	pr_debug("SCC2: Attempting to release partition %i, owners:%08x\n",
+		 partition_no, SCC_READ_REGISTER(SCM_PART_OWNERS_REG));
+
+	/* check that the partition is ours to de-establish */
+	if (!host_owns_partition(partition_no)) {
+		return SCC_RET_FAIL;
+	}
+
+	/* TODO: The state of the zeroize engine (SRS field in the Command Status
+	 * Register) should be examined before issuing the zeroize command here.
+	 * To make the driver thread-safe, a lock should be taken out before
+	 * issuing the check and released after the zeroize command has been
+	 * issued.
+	 */
+
+	/* Zero the partition to release it */
+	scc_write_register(SCM_ZCMD_REG,
+			   (partition_no << SCM_ZCMD_PART_SHIFT) |
+			   (ZCMD_DEALLOC_PART << SCM_ZCMD_CCMD_SHIFT));
+	mdelay(2);
+
+	pr_debug("SCC2: done releasing partition %i, owners:%08x\n",
+		 partition_no, SCC_READ_REGISTER(SCM_PART_OWNERS_REG));
+
+	/* Check that the de-assignment went correctly */
+	if (host_owns_partition(partition_no)) {
+		return SCC_RET_FAIL;
+	}
+
+	return SCC_RET_OK;
+}
+
+/**
+ * Diminish the permissions on a partition of secure memory
+ *
+ * @param   part_base     Kernel virtual address of the partition.
+ * @param   permissions   ORed values of the type SCM_PERM_* which will be used as
+ *                        initial partition permissions.  SHW API users should use
+ *                        the FSL_PERM_* definitions instead.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+scc_return_t scc_diminish_permissions(void *part_base, uint32_t permissions)
+{
+	uint32_t partition_no;
+	uint32_t permissions_requested;
+	permissions_requested = permissions;
+
+	/* ensure that this is a proper partition location */
+	partition_no = SCM_PART_NUMBER((uint32_t) part_base);
+
+	/* invert the permissions, masking out unused bits */
+	permissions = (~permissions) & SCM_PERM_MASK;
+
+	/* attempt to diminish the permissions */
+	scc_write_register(SCM_ACC0_REG + 8 * partition_no, permissions);
+	mdelay(2);
+
+	/* Reading it back puts it into the original form */
+	permissions = SCC_READ_REGISTER(SCM_ACC0_REG + 8 * partition_no);
+	if (permissions == permissions_requested) {
+		pr_debug("scc_partition_diminish_perms: successful\n");
+		pr_debug("scc_partition_diminish_perms: successful\n");
+		return SCC_RET_OK;
+	}
+	pr_debug("scc_partition_diminish_perms: not successful\n");
+
+	return SCC_RET_FAIL;
+}
+
+extern scc_partition_status_t scc_partition_status(void *part_base)
+{
+	uint32_t part_no;
+	uint32_t part_owner;
+
+	/* Determine the partition number from the address */
+	part_no = SCM_PART_NUMBER((uint32_t) part_base);
+
+	/* Check if the partition is implemented */
+	if (part_no >= scc_configuration.partition_count) {
+		return SCC_PART_S_UNUSABLE;
+	}
+
+	/* Determine the value of the partition owners register */
+	part_owner = (SCC_READ_REGISTER(SCM_PART_OWNERS_REG)
+		      >> (part_no * SCM_POWN_SHIFT)) & SCM_POWN_MASK;
+
+	switch (part_owner) {
+	case SCM_POWN_PART_OTHER:
+		return SCC_PART_S_UNAVAILABLE;
+		break;
+	case SCM_POWN_PART_FREE:
+		return SCC_PART_S_AVAILABLE;
+		break;
+	case SCM_POWN_PART_OWNED:
+		/* could be allocated or engaged*/
+		if (partition_engaged(part_no)) {
+			return SCC_PART_S_ENGAGED;
+		} else {
+			return SCC_PART_S_ALLOCATED;
+		}
+		break;
+	case SCM_POWN_PART_UNUSABLE:
+	default:
+		return SCC_PART_S_UNUSABLE;
+		break;
+	}
+}
+
+/**
+ * Calculate the physical address from the kernel virtual address.
+ *
+ * @param   address Kernel virtual address of data in an Secure Partition.
+ * @return  Physical address of said data.
+ */
+uint32_t scc_virt_to_phys(void *address)
+{
+	return (uint32_t) address - (uint32_t) scm_ram_base
+	    + (uint32_t) scm_ram_phys_base;
+}
+
+/**
+ * Engage partition of secure memory
+ *
+ * @param part_base (kernel) Virtual
+ * @param UMID NULL, or 16-byte UMID for partition security
+ * @param permissions ORed values from fsl_shw_permission_t which
+ * will be used as initial partiition permissions.
+ *
+ * @return SCC_RET_OK if successful.
+ */
+
+scc_return_t
+scc_engage_partition(void *part_base,
+		     const uint8_t *UMID, uint32_t permissions)
+{
+	uint32_t partition_no;
+	uint8_t *UMID_base = part_base + 0x10;
+	uint32_t *MAP_base = part_base;
+	uint8_t i;
+
+	partition_no = SCM_PART_NUMBER((uint32_t) part_base);
+
+	if (!host_owns_partition(partition_no) ||
+	    partition_engaged(partition_no) ||
+	    !(SCC_READ_REGISTER(SCM_SMID0_REG + (partition_no * 8)) == 0)) {
+
+		return SCC_RET_FAIL;
+	}
+
+	if (UMID != NULL) {
+		for (i = 0; i < 16; i++) {
+			UMID_base[i] = UMID[i];
+		}
+	}
+
+	MAP_base[0] = permissions;
+
+	udelay(20);
+
+	/* Check that the partition was engaged correctly, and that it has the
+	 * proper permissions.
+	 */
+
+	if ((!partition_engaged(partition_no)) ||
+	    (permissions !=
+	     SCC_READ_REGISTER(SCM_ACC0_REG + 8 * partition_no))) {
+		return SCC_RET_FAIL;
+	}
+
+	return SCC_RET_OK;
+}
+
 /*****************************************************************************/
 /* fn scc_init()                                                             */
 /*****************************************************************************/
-/*!
+/**
  *  Initialize the driver at boot time or module load time.
  *
  *  Register with the kernel as the interrupt handler for the SCC interrupt
@@ -254,18 +527,27 @@ static int scc_init(void)
 		}
 #endif
 
+		/* Set up the hardware access locks */
+		scc_callbacks_lock = os_lock_alloc_init();
+		scc_crypto_lock = os_lock_alloc_init();
+		if (scc_callbacks_lock == NULL || scc_crypto_lock == NULL) {
+			os_printk(KERN_ERR
+				  "SCC2: Failed to allocate context locks.  Exiting.\n");
+			goto out;
+		}
+
 		/* See whether there is an SCC available */
 		if (0 && !SCC_ENABLED()) {
-			printk(KERN_ERR
-			       "SCC2: Fuse for SCC is set to disabled.  Exiting.\n");
+			os_printk(KERN_ERR
+				  "SCC2: Fuse for SCC is set to disabled.  Exiting.\n");
 			goto out;
 		}
 		/* Map the SCC (SCM and SMN) memory on the internal bus into
 		   kernel address space */
 		scc_base = (void *)IO_ADDRESS(SCC_BASE);
 		if (scc_base == NULL) {
-			printk(KERN_ERR
-			       "SCC2: Register mapping failed.  Exiting.\n");
+			os_printk(KERN_ERR
+				  "SCC2: Register mapping failed.  Exiting.\n");
 			goto out;
 		}
 
@@ -288,53 +570,38 @@ static int scc_init(void)
 			goto out;
 		}
 
-		scm_ram_base =
-		    (void *)ioremap_nocache(scm_ram_phys_base,
-					    scc_configuration.partition_count *
-					    scc_configuration.
-					    partition_size_bytes);
+		scm_ram_base = (void *)ioremap_nocache(scm_ram_phys_base,
+						       scc_configuration.
+						       partition_count *
+						       scc_configuration.
+						       partition_size_bytes);
 		if (scm_ram_base == NULL) {
-			printk(KERN_ERR
-			       "SCC2: RAM failed to remap: %p for %d bytes\n",
-			       (void *)scm_ram_phys_base,
-			       scc_configuration.partition_count *
-			       scc_configuration.partition_size_bytes);
+			os_printk(KERN_ERR
+				  "SCC2: RAM failed to remap: %p for %d bytes\n",
+				  (void *)scm_ram_phys_base,
+				  scc_configuration.partition_count *
+				  scc_configuration.partition_size_bytes);
 			goto out;
 		}
 		pr_debug("SCC2: RAM at Physical %p / Virtual %p\n",
 			 (void *)scm_ram_phys_base, scm_ram_base);
 
-		return_value = make_sahara_partition();
-		if (return_value != SCC_RET_OK) {
-			scc_availability = SCC_STATUS_UNIMPLEMENTED;
-			goto out;
-		}
-
-		/* Initialize key slots */
-		for (i = 0; i < SCC_KEY_SLOTS; i++) {
-			scc_key_info[i].offset = i * SCC_KEY_SLOT_SIZE;
-			scc_key_info[i].part_ctl =
-			    (((i * SCC_KEY_SLOT_SIZE) /
-			      SCC_BLOCK_SIZE_BYTES() << SCM_CCMD_OFFSET_SHIFT)
-			     | (SAHARA_PART_NO << SCM_CCMD_PART_SHIFT));
-			scc_key_info[i].status = 0;	/* unassigned */
-		}
+		pr_debug("Secure Partition Table: Found %i partitions\n",
+			 scc_configuration.partition_count);
 
 		if (setup_interrupt_handling() != 0) {
 			unsigned err_cond;
-			/*!
-			 * The error could be only that the SCM interrupt was
-			 * not set up.  This interrupt is always masked, so
-			 * that is not an issue.
-			 *
-			 * The SMN's interrupt may be shared on that line, it
-			 * may be separate, or it may not be wired.  Do what
-			 * is necessary to check its status.
-			 *
-			 * Although the driver is coded for possibility of not
-			 * having SMN interrupt, the fact that there is one
-			 * means it should be available and used.
-			 */
+	    /**
+		* The error could be only that the SCM interrupt was
+		* not set up.  This interrupt is always masked, so
+		* that is not an issue.
+		* The SMN's interrupt may be shared on that line, it
+		* may be separate, or it may not be wired.  Do what
+		* is necessary to check its status.
+		* Although the driver is coded for possibility of not
+		* having SMN interrupt, the fact that there is one
+		* means it should be available and used.
+		*/
 #ifdef USE_SMN_INTERRUPT
 			err_cond = !smn_irq_set;	/* Separate. Check SMN binding */
 #elif !defined(NO_SMN_INTERRUPT)
@@ -371,15 +638,15 @@ static int scc_init(void)
 		}
 	}
 	/* ! STATUS_INITIAL */
-	printk("SCC2: Driver Status is %s\n",
-	       (scc_availability == SCC_STATUS_INITIAL) ? "INITIAL" :
-	       (scc_availability == SCC_STATUS_CHECKING) ? "CHECKING" :
-	       (scc_availability ==
-		SCC_STATUS_UNIMPLEMENTED) ? "UNIMPLEMENTED" : (scc_availability
-							       ==
-							       SCC_STATUS_OK) ?
-	       "OK" : (scc_availability ==
-		       SCC_STATUS_FAILED) ? "FAILED" : "UNKNOWN");
+	os_printk(KERN_ALERT "SCC2: Driver Status is %s\n",
+		  (scc_availability == SCC_STATUS_INITIAL) ? "INITIAL" :
+		  (scc_availability == SCC_STATUS_CHECKING) ? "CHECKING" :
+		  (scc_availability ==
+		   SCC_STATUS_UNIMPLEMENTED) ? "UNIMPLEMENTED"
+		  : (scc_availability ==
+		     SCC_STATUS_OK) ? "OK" : (scc_availability ==
+					      SCC_STATUS_FAILED) ? "FAILED" :
+		  "UNKNOWN");
 
 	return return_value;
 }				/* scc_init */
@@ -387,7 +654,7 @@ static int scc_init(void)
 /*****************************************************************************/
 /* fn scc_cleanup()                                                          */
 /*****************************************************************************/
-/*!
+/**
  * Perform cleanup before driver/module is unloaded by setting the machine
  * state close to what it was when the driver was loaded.  This function is
  * called when the kernel is shutting down or when this driver is being
@@ -400,11 +667,15 @@ static int scc_init(void)
  * In any case, cleanup the callback table (by clearing out all of the
  * pointers).  Deregister the interrupt handler(s).  Unmap SCC registers.
  *
+ * Note that this will not release any partitions that have been allocated.
+ *
  */
 static void scc_cleanup(void)
 {
 	int i;
 
+    /******************************************************/
+
 	/* Mark the driver / SCC as unusable. */
 	scc_availability = SCC_STATUS_UNIMPLEMENTED;
 
@@ -423,25 +694,31 @@ static void scc_cleanup(void)
 				   SMN_COMMAND_CLEAR_INTERRUPT);
 	}
 
-	if (sahara_partition_base != NULL) {
-
-	}
 	/* Now that interrupts cannot occur, disassociate driver from the interrupt
 	 * lines.
 	 */
 
 	/* Deregister SCM interrupt handler */
 	if (scm_irq_set) {
-		free_irq(INT_SCC_SCM, NULL);
+		os_deregister_interrupt(INT_SCC_SCM);
 	}
 
 	/* Deregister SMN interrupt handler */
 	if (smn_irq_set) {
 #ifdef USE_SMN_INTERRUPT
-		free_irq(INT_SCC_SMN, NULL);
+		os_deregister_interrupt(INT_SCC_SMN);
 #endif
 	}
 
+	/* Finally, release the mapped memory */
+	iounmap(scm_ram_base);
+
+	if (scc_callbacks_lock != NULL)
+		os_lock_deallocate(scc_callbacks_lock);
+
+	if (scc_crypto_lock != NULL)
+		os_lock_deallocate(scc_crypto_lock);
+
 	pr_debug("SCC2 driver cleaned up.\n");
 
 }				/* scc_cleanup */
@@ -459,10 +736,10 @@ scc_config_t *scc_get_configuration(void)
 		scc_init();
 	}
 
-	/*!
-	 * If there is no SCC, yet the driver exists, the value -1 will be in
-	 * the #scc_config_t fields for other than the driver versions.
-	 */
+    /**
+     * If there is no SCC, yet the driver exists, the value -1 will be in
+     * the #scc_config_t fields for other than the driver versions.
+     */
 	return &scc_configuration;
 }				/* scc_get_configuration */
 
@@ -477,120 +754,6 @@ scc_return_t scc_zeroize_memories(void)
 }				/* scc_zeroize_memories */
 
 /*****************************************************************************/
-/* fn scc_crypt()                                                            */
-/*****************************************************************************/
-scc_return_t
-scc_crypt(unsigned long count_in_bytes, uint8_t * data_in,
-	  uint8_t * init_vector, scc_enc_dec_t direction,
-	  scc_crypto_mode_t crypto_mode, scc_verify_t check_mode,
-	  uint8_t * data_out, unsigned long *count_out_bytes)
-{
-	uint32_t scm_command = scm_red_part_cmd;
-	unsigned long irq_flags;	/* for IRQ save/restore */
-	unsigned locked = FALSE;
-	scc_return_t return_code = SCC_RET_FAIL;
-
-	if (scc_availability == SCC_STATUS_INITIAL) {
-		scc_init();
-	}
-	(void)scc_update_state();	/* in case no interrupt line from SMN */
-	/* make initial error checks */
-	if (scc_availability != SCC_STATUS_OK
-	    || count_in_bytes == 0
-	    || data_in == 0
-	    || data_out == 0
-	    || (crypto_mode != SCC_CBC_MODE && crypto_mode != SCC_ECB_MODE)
-	    || (crypto_mode == SCC_CBC_MODE && init_vector == NULL)
-	    || (direction != SCC_ENCRYPT && direction != SCC_DECRYPT)
-	    || (check_mode == SCC_VERIFY_MODE_NONE &&
-		count_in_bytes % SCC_BLOCK_SIZE_BYTES() != 0)
-	    || (direction == SCC_DECRYPT &&
-		count_in_bytes % SCC_BLOCK_SIZE_BYTES() != 0)
-	    || (check_mode != SCC_VERIFY_MODE_NONE &&
-		check_mode != SCC_VERIFY_MODE_CCITT_CRC)) {
-		pr_debug("SCC2: scc_crypt() detected bad argument\n");
-		goto out;
-	}
-	/* Lock access to crypto memory of the SCC */
-	spin_lock_irqsave(&scc_crypto_lock, irq_flags);
-	locked = TRUE;
-	/* Special needs for CBC Mode */
-	if (crypto_mode == SCC_CBC_MODE) {
-		scm_command |= SCM_CCMD_CBC;	/* change default of ECB */
-		/* Put in Initial Context.  Vector registers are contiguous */
-		copy_to_scc(init_vector,
-			    (uint32_t) (scc_base + SCM_AES_CBC_IV0_REG),
-			    SCC_BLOCK_SIZE_BYTES(), NULL);
-	}
-
-	/* Fill the BLACK_START register */
-	SCC_WRITE_REGISTER(SCM_C_BLACK_ST_REG, scm_black_part_phys);
-
-	if (direction == SCC_ENCRYPT) {
-		/* Check for sufficient space in data_out */
-		if (check_mode == SCC_VERIFY_MODE_NONE) {
-			if (*count_out_bytes < count_in_bytes) {
-				return_code = SCC_RET_INSUFFICIENT_SPACE;
-				goto out;
-			}
-		} else {	/* SCC_VERIFY_MODE_CCITT_CRC */
-			/* Calculate extra bytes needed for crc (2) and block
-			   padding */
-			int padding_needed =
-			    CRC_SIZE_BYTES + SCC_BLOCK_SIZE_BYTES() -
-			    ((count_in_bytes + CRC_SIZE_BYTES)
-			     % SCC_BLOCK_SIZE_BYTES());
-
-			/* Verify space is available */
-			if (*count_out_bytes < count_in_bytes + padding_needed) {
-				return_code = SCC_RET_INSUFFICIENT_SPACE;
-				goto out;
-			}
-		}
-		return_code =
-		    scc_encrypt(count_in_bytes, data_in, scm_command, data_out,
-				check_mode == SCC_VERIFY_MODE_CCITT_CRC,
-				count_out_bytes);
-	}
-	/* direction == SCC_ENCRYPT */
-	else {			/* SCC_DECRYPT */
-		/* Check for sufficient space in data_out */
-		if (check_mode == SCC_VERIFY_MODE_NONE) {
-			if (*count_out_bytes < count_in_bytes) {
-				return_code = SCC_RET_INSUFFICIENT_SPACE;
-			}
-		} else {	/* SCC_VERIFY_MODE_CCITT_CRC */
-			/* Do initial check.  Assume last block (of padding) and CRC
-			 * will get stripped.  After decipher is done and padding is
-			 * removed, will know exact value.
-			 */
-			int possible_size = (int)count_in_bytes - CRC_SIZE_BYTES
-			    - SCC_BLOCK_SIZE_BYTES();
-			if ((int)*count_out_bytes < possible_size) {
-				pr_debug
-				    ("SCC2: insufficient decrypt space %ld/%d.\n",
-				     *count_out_bytes, possible_size);
-				return_code = SCC_RET_INSUFFICIENT_SPACE;
-				goto out;
-			}
-		}
-
-		return_code =
-		    scc_decrypt(count_in_bytes, data_in, scm_command, data_out,
-				check_mode == SCC_VERIFY_MODE_CCITT_CRC,
-				count_out_bytes);
-	}			/* SCC_DECRYPT */
-
-      out:
-	/* unlock the SCC */
-	if (locked) {
-		spin_unlock_irqrestore(&scc_crypto_lock, irq_flags);
-	}
-
-	return return_code;
-}				/* scc_crypt */
-
-/*****************************************************************************/
 /* fn scc_set_sw_alarm()                                                     */
 /*****************************************************************************/
 void scc_set_sw_alarm(void)
@@ -627,7 +790,7 @@ void scc_set_sw_alarm(void)
 scc_return_t scc_monitor_security_failure(void callback_func(void))
 {
 	int i;
-	unsigned long irq_flags;	/* for IRQ save/restore */
+	os_lock_context_t irq_flags;	/* for IRQ save/restore */
 	scc_return_t return_status = SCC_RET_TOO_MANY_FUNCTIONS;
 	int function_stored = FALSE;
 
@@ -638,7 +801,7 @@ scc_return_t scc_monitor_security_failure(void callback_func(void))
 	/* Acquire lock of callbacks table.  Could be spin_lock_irq() if this
 	 * routine were just called from base (not interrupt) level
 	 */
-	spin_lock_irqsave(&scc_callbacks_lock, irq_flags);
+	os_lock_save_context(scc_callbacks_lock, irq_flags);
 
 	/* Search through table looking for empty slot */
 	for (i = 0; i < SCC_CALLBACK_SIZE; i++) {
@@ -659,7 +822,7 @@ scc_return_t scc_monitor_security_failure(void callback_func(void))
 	}
 
 	/* Free the lock */
-	spin_unlock_irqrestore(&scc_callbacks_lock, irq_flags);
+	os_unlock_restore_context(scc_callbacks_lock, irq_flags);
 
 	return return_status;
 }				/* scc_monitor_security_failure */
@@ -669,7 +832,7 @@ scc_return_t scc_monitor_security_failure(void callback_func(void))
 /*****************************************************************************/
 void scc_stop_monitoring_security_failure(void callback_func(void))
 {
-	unsigned long irq_flags;	/* for IRQ save/restore */
+	os_lock_context_t irq_flags;	/* for IRQ save/restore */
 	int i;
 
 	if (scc_availability == SCC_STATUS_INITIAL) {
@@ -679,7 +842,7 @@ void scc_stop_monitoring_security_failure(void callback_func(void))
 	/* Acquire lock of callbacks table.  Could be spin_lock_irq() if this
 	 * routine were just called from base (not interrupt) level
 	 */
-	spin_lock_irqsave(&scc_callbacks_lock, irq_flags);
+	os_lock_save_context(scc_callbacks_lock, irq_flags);
 
 	/* Search every entry of the table for this function */
 	for (i = 0; i < SCC_CALLBACK_SIZE; i++) {
@@ -690,7 +853,7 @@ void scc_stop_monitoring_security_failure(void callback_func(void))
 	}
 
 	/* Free the lock */
-	spin_unlock_irqrestore(&scc_callbacks_lock, irq_flags);
+	os_unlock_restore_context(scc_callbacks_lock, irq_flags);
 
 	return;
 }				/* scc_stop_monitoring_security_failure */
@@ -787,7 +950,7 @@ scc_return_t scc_write_register(int register_offset, uint32_t value)
 /*****************************************************************************/
 /* fn scc_irq()                                                              */
 /*****************************************************************************/
-/*!
+/**
  * This is the interrupt handler for the SCC.
  *
  * This function checks the SMN Status register to see whether it
@@ -800,11 +963,8 @@ scc_return_t scc_write_register(int register_offset, uint32_t value)
  * The SCM Interrupt should be masked, as this driver uses polling to determine
  * when the SCM has completed a crypto or zeroing operation.  Therefore, if the
  * interrupt is active, the driver will just clear the interrupt and (re)mask.
- *
- * @param irq Channel number for the IRQ. (@c SCC_INT_SMN or @c SCC_INT_SCM).
- * @param dev_id Pointer to the identification of the device.  Ignored.
  */
-static irqreturn_t scc_irq(int irq, void *dev_id)
+OS_DEV_ISR(scc_irq)
 {
 	uint32_t smn_status;
 	uint32_t scm_status;
@@ -822,7 +982,8 @@ static irqreturn_t scc_irq(int irq, void *dev_id)
 
 	/* SMN is on its own interrupt line.  Verify the IRQ was triggered
 	 * before clearing the interrupt and marking it handled.  */
-	if ((irq == smn_irq) && (smn_status & SMN_STATUS_SMN_STATUS_IRQ)) {
+	if ((os_dev_get_irq() == smn_irq) &&
+	    (smn_status & SMN_STATUS_SMN_STATUS_IRQ)) {
 		SCC_WRITE_REGISTER(SMN_COMMAND_REG,
 				   SMN_COMMAND_CLEAR_INTERRUPT);
 		handled++;	/* tell kernel that interrupt was handled */
@@ -832,20 +993,20 @@ static irqreturn_t scc_irq(int irq, void *dev_id)
 	scm_status = SCC_READ_REGISTER(SCM_STATUS_REG);
 
 	/* The driver masks interrupts, so this should never happen. */
-	if (irq == INT_SCC_SCM) {
+	if (os_dev_get_irq() == INT_SCC_SCM) {
 		/* but if it does, try to prevent it in the future */
 		SCC_WRITE_REGISTER(SCM_INT_CTL_REG, 0);
 		handled++;
 	}
 
 	/* Any non-zero value of handled lets kernel know we got something */
-	return IRQ_RETVAL(handled);
+	os_dev_isr_return(handled);
 }
 
 /*****************************************************************************/
 /* fn scc_perform_callbacks()                                                */
 /*****************************************************************************/
-/*! Perform callbacks registered by #scc_monitor_security_failure().
+/** Perform callbacks registered by #scc_monitor_security_failure().
  *
  *  Make sure callbacks only happen once...  Since there may be some reason why
  *  the interrupt isn't generated, this routine could be called from base(task)
@@ -860,7 +1021,7 @@ static void scc_perform_callbacks(void)
 	int i;
 
 	/* Acquire lock of callbacks table and callbacks_performed flag */
-	spin_lock_irqsave(&scc_callbacks_lock, irq_flags);
+	os_lock_save_context(scc_callbacks_lock, irq_flags);
 
 	if (!callbacks_performed) {
 		callbacks_performed = 1;
@@ -874,218 +1035,15 @@ static void scc_perform_callbacks(void)
 		}
 	}
 
-	spin_unlock_irqrestore(&scc_callbacks_lock, irq_flags);
+	os_unlock_restore_context(scc_callbacks_lock, irq_flags);
 
 	return;
 }
 
 /*****************************************************************************/
-/* fn copy_to_scc()                                                          */
-/*****************************************************************************/
-/*!
- *  Move data from possibly unaligned source and realign for SCC, possibly
- *  while calculating CRC.
- *
- *  Multiple calls can be made to this routine (without intervening calls to
- *  #copy_from_scc(), as long as the sum total of bytes copied is a multiple of
- *  four (SCC native word size).
- *
- *  @param[in]     from        Location in memory
- *  @param[out]    to          Location in SCC
- *  @param[in]     count_bytes Number of bytes to copy
- *  @param[in,out] crc         Pointer to CRC.  Initial value must be
- *                             #CRC_CCITT_START if this is the start of
- *                             message.  Output is the resulting (maybe
- *                             partial) CRC.  If NULL, no crc is calculated.
- *
- * @return  Zero - success.  Non-zero - SCM status bits defining failure.
- */
-static uint32_t
-copy_to_scc(const uint8_t * from, uint32_t to, unsigned long count_bytes,
-	    uint16_t * crc)
-{
-	int i;
-	uint32_t scm_word;
-	uint16_t current_crc = 0;	/* local copy for fast access */
-
-	pr_debug("SCC2: copying %ld bytes to 0x%0x.\n", count_bytes, to);
-
-	if (crc) {
-		current_crc = *crc;
-	}
-
-	/* Initialize value being built for SCM.  If we are starting 'clean',
-	 * set it to zero.  Otherwise pick up partial value which had been saved
-	 * earlier. */
-	if (SCC_BYTE_OFFSET(to) == 0) {
-		scm_word = 0;
-	} else {
-		scm_word = *(uint32_t *) SCC_WORD_PTR(to);	/* recover */
-	}
-
-	/* Now build up SCM words and write them out when each is full */
-	for (i = 0; i < count_bytes; i++) {
-		uint8_t byte = *from++;	/* value from plaintext */
-
-#ifdef __BIG_ENDIAN
-		scm_word = (scm_word << 8) | byte;	/* add byte to SCM word */
-#else
-		scm_word = (byte << 24) | (scm_word >> 8);
-#endif
-		/* now calculate CCITT CRC */
-		if (crc) {
-			CALC_CRC(byte, current_crc);
-		}
-
-		to++;		/* bump location in SCM */
-
-		/* check for full word */
-		if (SCC_BYTE_OFFSET(to) == 0) {
-			*(uint32_t *) (to - 4) = scm_word;	/* write it out */
-		}
-	}
-
-	/* If at partial word after previous loop, save it in SCM memory for
-	   next time. */
-	if (SCC_BYTE_OFFSET(to) != 0) {
-		*(uint32_t *) SCC_WORD_PTR(to) = scm_word;	/* save */
-	}
-
-	/* Copy CRC back */
-	if (crc) {
-		*crc = current_crc;
-	}
-
-	return SCC_RET_OK;
-}
-
-/*****************************************************************************/
-/* fn copy_from_scc()                                                        */
-/*****************************************************************************/
-/*!
- *  Move data from aligned 32-bit source and place in (possibly unaligned)
- *  target, and maybe calculate CRC at the same time.
- *
- *  Multiple calls can be made to this routine (without intervening calls to
- *  #copy_to_scc(), as long as the sum total of bytes copied is be a multiple
- *  of four.
- *
- *  @param[in]     from        Location in SCC
- *  @param[out]    to          Location in memory
- *  @param[in]     count_bytes Number of bytes to copy
- *  @param[in,out] crc         Pointer to CRC.  Initial value must be
- *                             #CRC_CCITT_START if this is the start of
- *                             message.  Output is the resulting (maybe
- *                             partial) CRC.  If NULL, crc is not calculated.
- *
- * @return  Zero - success.  Non-zero - SCM status bits defining failure.
- */
-static uint32_t
-copy_from_scc(const uint32_t from, uint8_t * to, unsigned long count_bytes,
-	      uint16_t * crc)
-{
-	uint32_t running_from = from;
-	uint32_t scm_word;
-	uint16_t current_crc = 0;	/* local copy for fast access */
-
-	pr_debug("SCC2: copying %ld bytes from 0x%x.\n", count_bytes, from);
-
-	if (crc) {
-		current_crc = *crc;
-	}
-
-	/* Read word which is sitting in SCM memory.  Ignore byte offset */
-	scm_word = *(uint32_t *) SCC_WORD_PTR(running_from);
-	pr_debug("%08x ", scm_word);
-	/* If necessary, move the 'first' byte into place */
-	if (SCC_BYTE_OFFSET(running_from) != 0) {
-#ifdef __BIG_ENDIAN
-		scm_word <<= 8 * SCC_BYTE_OFFSET(running_from);
-#else
-		scm_word >>= 8 * SCC_BYTE_OFFSET(running_from);
-#endif
-	}
-
-	/* Now build up SCM words and write them out when each is full */
-	while (count_bytes--) {
-		uint8_t byte;	/* value from plaintext */
-
-#ifdef __BIG_ENDIAN
-		byte = (scm_word & 0xff000000) >> 24;	/* pull byte out of SCM word */
-		scm_word <<= 8;	/* shift over to remove the just-pulled byte */
-#else
-		byte = (scm_word & 0xff);
-		scm_word >>= 8;	/* shift over to remove the just-pulled byte */
-#endif
-		*to++ = byte;	/* send byte to memory */
-
-		/* now calculate CRC */
-		if (crc) {
-			CALC_CRC(byte, current_crc);
-		}
-
-		running_from++;
-		/* check for empty word */
-		if (count_bytes && SCC_BYTE_OFFSET(running_from) == 0) {
-			/* read one in */
-			scm_word = *(uint32_t *) running_from;
-			pr_debug("%08x ", scm_word);
-		}
-	}
-
-	pr_debug("\n");
-	if (crc) {
-		*crc = current_crc;
-	}
-
-	return SCC_RET_OK;
-}
-
-/*****************************************************************************/
-/* fn scc_strip_padding()                                                    */
-/*****************************************************************************/
-/*!
- *  Remove padding from plaintext.  Search backwards for #SCC_DRIVER_PAD_CHAR,
- *  verifying that each byte passed over is zero (0).  Maximum number of bytes
- *  to examine is 8.
- *
- *  @param[in]     from           Pointer to byte after end of message
- *  @param[out]    count_bytes_stripped Number of padding bytes removed by this
- *                                      function.
- *
- *  @return   #SCC_RET_OK if all goes, well, #SCC_RET_FAIL if padding was
- *            not present.
-*/
-static scc_return_t
-scc_strip_padding(uint8_t * from, unsigned *count_bytes_stripped)
-{
-	int i = SCC_BLOCK_SIZE_BYTES();
-	scc_return_t return_code = SCC_RET_VERIFICATION_FAILED;
-
-	/*
-	 * Search backwards looking for the magic marker.  If it isn't found,
-	 * make sure that a 0 byte is there in its place.  Stop after the maximum
-	 * amount of padding (8 bytes) has been searched);
-	 */
-	while (i-- > 0) {
-		if (*--from == SCC_DRIVER_PAD_CHAR) {
-			*count_bytes_stripped = SCC_BLOCK_SIZE_BYTES() - i;
-			return_code = SCC_RET_OK;
-			break;
-		} else if (*from != 0) {	/* if not marker, check for 0 */
-			pr_debug("SCC2: Found non-zero interim pad: 0x%x\n",
-				 *from);
-			break;
-		}
-	}
-
-	return return_code;
-}
-
-/*****************************************************************************/
 /* fn scc_update_state()                                                     */
 /*****************************************************************************/
-/*!
+/**
  * Make certain SCC is still running.
  *
  * Side effect is to update #scc_availability and, if the state goes to failed,
@@ -1094,7 +1052,7 @@ scc_strip_padding(uint8_t * from, unsigned *count_bytes_stripped)
  * (If #SCC_BRINGUP is defined, bring SCC to secure state if it is found to be
  * in health check state)
  *
- * @return Current value of #SMN_STATUS register.
+ * @return Current value of #SMN_STATUS_REG register.
  */
 static uint32_t scc_update_state(void)
 {
@@ -1113,9 +1071,9 @@ static uint32_t scc_update_state(void)
 		if (scc_availability == SCC_STATUS_CHECKING &&
 		    smn_state == SMN_STATE_HEALTH_CHECK) {
 			/* Code up a simple algorithm for the ASC */
-			SCC_WRITE_REGISTER(SMN_SEQUENCE_START, 0xaaaa);
-			SCC_WRITE_REGISTER(SMN_SEQUENCE_END, 0x5555);
-			SCC_WRITE_REGISTER(SMN_SEQUENCE_CHECK, 0x5555);
+			SCC_WRITE_REGISTER(SMN_SEQ_START_REG, 0xaaaa);
+			SCC_WRITE_REGISTER(SMN_SEQ_END_REG, 0x5555);
+			SCC_WRITE_REGISTER(SMN_SEQ_CHECK_REG, 0x5555);
 			/* State should be SECURE now */
 			smn_status_register = SCC_READ_REGISTER(SMN_STATUS);
 			smn_state = smn_status_register & SMN_STATUS_STATE_MASK;
@@ -1134,11 +1092,12 @@ static uint32_t scc_update_state(void)
 		} else if (smn_state == SMN_STATE_FAIL) {
 			scc_availability = SCC_STATUS_FAILED;	/* uh oh - unhealthy */
 			scc_perform_callbacks();
-			printk(KERN_ERR "SCC2: SCC went into FAILED mode\n");
+			os_printk(KERN_ERR "SCC2: SCC went into FAILED mode\n");
 		} else {
 			/* START, ZEROIZE RAM, HEALTH CHECK, or unknown */
 			scc_availability = SCC_STATUS_UNIMPLEMENTED;	/* unuseable */
-			printk(KERN_ERR "SCC2: SCC declared UNIMPLEMENTED\n");
+			os_printk(KERN_ERR
+				  "SCC2: SCC declared UNIMPLEMENTED\n");
 		}
 	}
 	/* if availability is initial or ok */
@@ -1148,7 +1107,7 @@ static uint32_t scc_update_state(void)
 /*****************************************************************************/
 /* fn scc_init_ccitt_crc()                                                   */
 /*****************************************************************************/
-/*!
+/**
  * Populate the partial CRC lookup table.
  *
  * @return   none
@@ -1194,7 +1153,7 @@ static void scc_init_ccitt_crc(void)
 /*****************************************************************************/
 /* fn grab_config_values()                                                   */
 /*****************************************************************************/
-/*!
+/**
  * grab_config_values() will read the SCM Configuration and SMN Status
  * registers and store away version and size information for later use.
  *
@@ -1238,7 +1197,7 @@ static uint32_t scc_grab_config_values(void)
 /*****************************************************************************/
 /* fn setup_interrupt_handling()                                             */
 /*****************************************************************************/
-/*!
+/**
  * Register the SCM and SMN interrupt handlers.
  *
  * Called from #scc_init()
@@ -1255,12 +1214,12 @@ static int setup_interrupt_handling(void)
 
 #ifdef USE_SMN_INTERRUPT
 	/* Install interrupt service routine for SMN. */
-	smn_error_code = request_irq(INT_SCC_SMN, scc_irq, 0,
-				     SCC_DRIVER_NAME, NULL);
+	smn_error_code = os_register_interrupt(SCC_DRIVER_NAME,
+					       INT_SCC_SMN, scc_irq);
 	if (smn_error_code != 0) {
-		printk
-		    ("SCC2 Driver: Error installing SMN Interrupt Handler: %d\n",
-		     smn_error_code);
+		os_printk(KERN_ERR
+			  "SCC2 Driver: Error installing SMN Interrupt Handler: %d\n",
+			  smn_error_code);
 	} else {
 		smn_irq_set = 1;	/* remember this for cleanup */
 		/* Enable SMN interrupts */
@@ -1275,17 +1234,17 @@ static int setup_interrupt_handling(void)
 	/*
 	 * Install interrupt service routine for SCM (or both together).
 	 */
-	scm_error_code = request_irq(INT_SCC_SCM, scc_irq, 0,
-				     SCC_DRIVER_NAME, NULL);
+	scm_error_code = os_register_interrupt(SCC_DRIVER_NAME,
+					       INT_SCC_SCM, scc_irq);
 	if (scm_error_code != 0) {
 #ifndef MXC
-		printk
-		    ("SCC2 Driver: Error installing SCM Interrupt Handler: %d\n",
-		     scm_error_code);
+		os_printk(KERN_ERR
+			  "SCC2 Driver: Error installing SCM Interrupt Handler: %d\n",
+			  scm_error_code);
 #else
-		printk
-		    ("SCC2 Driver: Error installing SCC Interrupt Handler: %d\n",
-		     scm_error_code);
+		os_printk(KERN_ERR
+			  "SCC2 Driver: Error installing SCC Interrupt Handler: %d\n",
+			  scm_error_code);
 #endif
 	} else {
 		scm_irq_set = 1;	/* remember this for cleanup */
@@ -1304,7 +1263,7 @@ static int setup_interrupt_handling(void)
 /*****************************************************************************/
 /* fn scc_do_crypto()                                                        */
 /*****************************************************************************/
-/*! Have the SCM perform the crypto function.
+/** Have the SCM perform the crypto function.
  *
  * Set up length register, and the store @c scm_control into control register
  * to kick off the operation.  Wait for completion, gather status, clear
@@ -1313,7 +1272,7 @@ static int setup_interrupt_handling(void)
  * @param byte_count  number of bytes to perform in this operation
  * @param scm_command Bit values to be set in @c SCM_CCMD_REG register
  *
- * @return 0 on success, value of #SCM_ERROR_STATUS on failure
+ * @return 0 on success, value of #SCM_ERR_STATUS_REG on failure
  */
 static uint32_t scc_do_crypto(int byte_count, uint32_t scm_command)
 {
@@ -1321,6 +1280,11 @@ static uint32_t scc_do_crypto(int byte_count, uint32_t scm_command)
 	uint32_t crypto_status;
 	scc_return_t ret;
 
+	/* This seems to be necessary in order to allow subsequent cipher
+	 * operations to succeed when a partition is deallocated/reallocated!
+	 */
+	(void)SCC_READ_REGISTER(SCM_STATUS_REG);
+
 	/* In length register, 0 means 1, etc. */
 	scm_command |= (block_count - 1) << SCM_CCMD_LENGTH_SHIFT;
 
@@ -1346,791 +1310,223 @@ static uint32_t scc_do_crypto(int byte_count, uint32_t scm_command)
 	return crypto_status;
 }
 
-/*****************************************************************************/
-/* fn scc_encrypt()                                                          */
-/*****************************************************************************/
-/*!
- * Perform an encryption on the input.  If @c verify_crc is true, a CRC must be
- * calculated on the plaintext, and appended, with padding, before computing
- * the ciphertext.
- *
- * @param[in]     count_in_bytes  Count of bytes of plaintext
- * @param[in]     data_in         Pointer to the plaintext
- * @param[in]     scm_control     Bit values for the SCM_CONTROL register
- * @param[in,out] data_out        Pointer for storing ciphertext
- * @param[in]     add_crc         Flag for computing CRC - 0 no, else yes
- * @param[in,out] count_out_bytes Number of bytes available at @c data_out
- */
-static scc_return_t
-scc_encrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
-	    uint8_t * data_out, int add_crc, unsigned long *count_out_bytes)
-{
-	scc_return_t return_code = SCC_RET_FAIL;	/* initialised for failure */
-	uint32_t input_bytes_left = count_in_bytes;	/* local copy */
-	uint32_t output_bytes_copied = 0;	/* running total */
-	uint32_t bytes_to_process;	/* multi-purpose byte counter */
-	uint16_t crc = CRC_CCITT_START;	/* running CRC value */
-	crc_t *crc_ptr = NULL;	/* Reset if CRC required */
-	/* byte address into SCM RAM */
-	uint32_t scm_location = (uint32_t) scm_red_part_virt;
-	uint32_t scm_bytes_remaining = scm_memory_size_bytes;	/* free RED RAM */
-	uint8_t padding_buffer[PADDING_BUFFER_MAX_BYTES];	/* CRC+padding holder */
-	unsigned padding_byte_count = 0;	/* Reset if padding required */
-	uint32_t scm_error_status = 0;	/* No known SCM error initially */
-
-	scm_control |= SCM_CCMD_ENC;
-	/* Set location of CRC and prepare padding bytes if required */
-	if (add_crc != 0) {
-		crc_ptr = &crc;
-		padding_byte_count = SCC_BLOCK_SIZE_BYTES()
-		    - (count_in_bytes +
-		       CRC_SIZE_BYTES) % SCC_BLOCK_SIZE_BYTES();
-		memcpy(padding_buffer + CRC_SIZE_BYTES, scc_block_padding,
-		       padding_byte_count);
-	}
-
-	/* Process remaining input or padding data */
-	while (input_bytes_left > 0) {
-		/* Determine how much work to do this pass */
-		bytes_to_process = (input_bytes_left > scm_bytes_remaining) ?
-		    scm_bytes_remaining : input_bytes_left;
-		/* Copy plaintext into SCM RAM, calculating CRC if required */
-		copy_to_scc(data_in, scm_location, bytes_to_process, crc_ptr);
-		/* Adjust pointers & counters */
-		input_bytes_left -= bytes_to_process;
-		data_in += bytes_to_process;
-		scm_location += bytes_to_process;
-		scm_bytes_remaining -= bytes_to_process;
-
-		/* Add CRC and padding after the last byte is copied if required */
-		if ((input_bytes_left == 0) && (crc_ptr != NULL)) {
-
-			/* Copy CRC into padding buffer MSB first */
-			padding_buffer[0] = (crc >> 8) & 0xFF;
-			padding_buffer[1] = crc & 0xFF;
-
-			/* Reset pointers and counter */
-			data_in = padding_buffer;
-			input_bytes_left = CRC_SIZE_BYTES + padding_byte_count;
-			crc_ptr = NULL;	/* CRC no longer required */
-
-			/* Go round loop again to copy CRC and padding to SCM */
-			continue;
-		}
-
-		/* if no input and crc_ptr */
-		/* Now have block-sized plaintext in SCM to encrypt */
-		/* Encrypt plaintext; exit loop on error */
-		bytes_to_process = scm_location - (uint32_t) scm_red_part_virt;
-
-		if (output_bytes_copied + bytes_to_process > *count_out_bytes) {
-			return_code = SCC_RET_INSUFFICIENT_SPACE;
-			scm_error_status = -1;	/* error signal */
-			pr_debug
-			    ("SCC2: too many ciphertext bytes for space available\n");
-			break;
-		}
-		pr_debug("SCC2: Starting encryption. %x for %d bytes (%p)\n",
-			 scm_control, bytes_to_process,
-			 (void *)SCC_READ_REGISTER(SCM_C_BLACK_ST_REG));
-		scm_error_status = scc_do_crypto(bytes_to_process, scm_control);
-		if (scm_error_status != 0) {
-			break;
-		}
-
-		/* Copy out ciphertext */
-		copy_from_scc((uint32_t) scm_black_part_virt, data_out,
-			      bytes_to_process, NULL);
-
-		/* Adjust pointers and counters for next loop */
-		output_bytes_copied += bytes_to_process;
-		data_out += bytes_to_process;
-		scm_location = (uint32_t) scm_red_part_virt;
-		scm_bytes_remaining = scm_memory_size_bytes;
-	}			/* input_bytes_left > 0 */
-
-	/* If no SCM error, set OK status and save ouput byte count */
-	if (scm_error_status == 0) {
-		return_code = SCC_RET_OK;
-		*count_out_bytes = output_bytes_copied;
-	}
-
-	return return_code;
-}				/* scc_encrypt */
-
-/*****************************************************************************/
-/* fn scc_decrypt()                                                          */
-/*****************************************************************************/
-/*!
- * Perform a decryption on the input.  If @c verify_crc is true, the last block
- * (maybe the two last blocks) is special - it should contain a CRC and
- * padding.  These must be stripped and verified.
- *
- * @param[in]     count_in_bytes  Count of bytes of ciphertext
- * @param[in]     data_in         Pointer to the ciphertext
- * @param[in]     scm_control     Bit values for the SCM_CONTROL register
- * @param[in,out] data_out        Pointer for storing plaintext
- * @param[in]     verify_crc      Flag for running CRC - 0 no, else yes
- * @param[in,out] count_out_bytes Number of bytes available at @c data_out
-
- */
-static scc_return_t
-scc_decrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
-	    uint8_t * data_out, int verify_crc, unsigned long *count_out_bytes)
-{
-	scc_return_t return_code = SCC_RET_FAIL;
-	uint32_t bytes_left = count_in_bytes;	/* local copy */
-	uint32_t bytes_copied = 0;	/* running total of bytes going to user */
-	uint32_t bytes_to_copy = 0;	/* Number in this encryption 'chunk' */
-	uint16_t crc = CRC_CCITT_START;	/* running CRC value */
-	/* next target for  ctext */
-	uint32_t scm_location = (uint32_t) scm_black_part_virt;
-	unsigned padding_byte_count;	/* number of bytes of padding stripped */
-	uint8_t last_two_blocks[2 * SCC_BLOCK_SIZE_BYTES()];	/* temp */
-	uint32_t scm_error_status = 0;	/* register value */
-
-	scm_control |= SCM_CCMD_DEC;
-	if (verify_crc) {
-		/* Save last two blocks (if there are at least two) of ciphertext for
-		   special treatment. */
-		bytes_left -= SCC_BLOCK_SIZE_BYTES();
-		if (bytes_left >= SCC_BLOCK_SIZE_BYTES()) {
-			bytes_left -= SCC_BLOCK_SIZE_BYTES();
-		}
-	}
-
-	/* Copy ciphertext into SCM BLACK memory */
-	while (bytes_left && scm_error_status == 0) {
-
-		/* Determine how much work to do this pass */
-		if (bytes_left > (scm_memory_size_bytes)) {
-			bytes_to_copy = scm_memory_size_bytes;
-		} else {
-			bytes_to_copy = bytes_left;
-		}
-
-		if (bytes_copied + bytes_to_copy > *count_out_bytes) {
-			scm_error_status = -1;
-			break;
-		}
-		copy_to_scc(data_in, scm_location, bytes_to_copy, NULL);
-		data_in += bytes_to_copy;	/* move pointer */
-
-		pr_debug("SCC2: Starting decryption of %d bytes.\n",
-			 bytes_to_copy);
-
-		/*  Do the work, wait for completion */
-		scm_error_status = scc_do_crypto(bytes_to_copy, scm_control);
-
-		copy_from_scc((uint32_t) scm_red_part_virt, data_out,
-			      bytes_to_copy, &crc);
-		bytes_copied += bytes_to_copy;
-		data_out += bytes_to_copy;
-		scm_location = (uint32_t) scm_black_part_virt;
-
-		/* Do housekeeping */
-		bytes_left -= bytes_to_copy;
-
-	}			/* while bytes_left */
-
-	/* At this point, either the process is finished, or this is verify mode */
-
-	if (scm_error_status == 0) {
-		if (!verify_crc) {
-			*count_out_bytes = bytes_copied;
-			return_code = SCC_RET_OK;
-		} else {
-			/* Verify mode.  There are one or two blocks of unprocessed
-			 * ciphertext sitting at data_in.  They need to be moved to the
-			 * SCM, decrypted, searched to remove padding, then the plaintext
-			 * copied back to the user (while calculating CRC, of course).
-			 */
-
-			/* Calculate ciphertext still left */
-			bytes_to_copy = count_in_bytes - bytes_copied;
-
-			copy_to_scc(data_in, scm_location, bytes_to_copy, NULL);
-			data_in += bytes_to_copy;	/* move pointer */
-
-			pr_debug("SCC2: Finishing decryption (%d bytes).\n",
-				 bytes_to_copy);
-
-			/*  Do the work, wait for completion */
-			scm_error_status =
-			    scc_do_crypto(bytes_to_copy, scm_control);
-
-			if (scm_error_status == 0) {
-				/* Copy decrypted data back from SCM RED memory */
-				copy_from_scc((uint32_t) scm_red_part_virt,
-					      last_two_blocks, bytes_to_copy,
-					      NULL);
-
-				/* (Plaintext) + crc + padding should be in temp buffer */
-				if (scc_strip_padding
-				    (last_two_blocks + bytes_to_copy,
-				     &padding_byte_count) == SCC_RET_OK) {
-					bytes_to_copy -=
-					    padding_byte_count + CRC_SIZE_BYTES;
-
-					/* verify enough space in user buffer */
-					if (bytes_copied + bytes_to_copy <=
-					    *count_out_bytes) {
-						int i = 0;
-
-						/* Move out last plaintext and calc CRC */
-						while (i < bytes_to_copy) {
-							CALC_CRC(last_two_blocks
-								 [i], crc);
-							*data_out++ =
-							    last_two_blocks
-							    [i++];
-							bytes_copied++;
-						}
-
-						/* Verify the CRC by running over itself */
-						CALC_CRC(last_two_blocks
-							 [bytes_to_copy], crc);
-						CALC_CRC(last_two_blocks
-							 [bytes_to_copy + 1],
-							 crc);
-						if (crc == 0) {
-							/* Just fine ! */
-							*count_out_bytes =
-							    bytes_copied;
-							return_code =
-							    SCC_RET_OK;
-						} else {
-							return_code =
-							    SCC_RET_VERIFICATION_FAILED;
-							pr_debug
-							    ("SCC2:  CRC values are %04x, %02x%02x\n",
-							     crc,
-							     last_two_blocks
-							     [bytes_to_copy],
-							     last_two_blocks
-							     [bytes_to_copy +
-							      1]);
-						}
-					}	/* if space available */
-				} /* if scc_strip_padding... */
-				else {
-					/* bad padding means bad verification */
-					return_code =
-					    SCC_RET_VERIFICATION_FAILED;
-				}
-			}
-			/* scm_error_status == 0 */
-		}		/* verify_crc */
-	}
-
-	/* scm_error_status == 0 */
-	return return_code;
-}				/* scc_decrypt */
-
-/*****************************************************************************/
-/* fn scc_alloc_slot()                                                       */
-/*****************************************************************************/
-/*!
- * Allocate a key slot to fit the requested size.
- *
- * @param value_size_bytes   Size of the key or other secure data
- * @param owner_id           Value to tie owner to slot
- * @param[out] slot          Handle to access or deallocate slot
- *
- * @return SCC_RET_OK on success, SCC_RET_INSUFFICIENT_SPACE if not slots of
- *         requested size are available.
- */
-scc_return_t
-scc_alloc_slot(uint32_t value_size_bytes, uint64_t owner_id, uint32_t * slot)
-{
-	scc_return_t status = SCC_RET_FAIL;
-	unsigned long irq_flags;
-
-	if (scc_availability != SCC_STATUS_OK) {
-		goto out;
-	}
-	/* ACQUIRE LOCK to prevent others from using SCC crypto */
-	spin_lock_irqsave(&scc_crypto_lock, irq_flags);
-
-	pr_debug("SCC2: Allocating %d-byte slot\n", value_size_bytes);
-
-	if ((value_size_bytes != 0) && (value_size_bytes <= SCC_MAX_KEY_SIZE)) {
-		int i;
-
-		for (i = 0; i < SCC_KEY_SLOTS; i++) {
-			if (scc_key_info[i].status == 0) {
-				scc_key_info[i].owner_id = owner_id;
-				scc_key_info[i].length = value_size_bytes;
-				scc_key_info[i].status = 1;	/* assigned! */
-				*slot = i;
-				status = SCC_RET_OK;
-				break;	/* exit 'for' loop */
-			}
-		}
-		if (status != SCC_RET_OK) {
-			status = SCC_RET_INSUFFICIENT_SPACE;
-		} else {
-			pr_debug("SCC2: Allocated slot %d\n", i);
-		}
-	}
-
-	spin_unlock_irqrestore(&scc_crypto_lock, irq_flags);
-
-      out:
-	return status;
-}
-
-/*****************************************************************************/
-/* fn verify_slot_access()                                                   */
-/*****************************************************************************/
-inline static scc_return_t
-verify_slot_access(uint64_t owner_id, uint32_t slot, uint32_t access_len)
-{
-	scc_return_t status = SCC_RET_FAIL;
-
-	if (scc_availability != SCC_STATUS_OK) {
-		goto out;
-	}
-
-	if ((slot < SCC_KEY_SLOTS) && scc_key_info[slot].status
-	    && (scc_key_info[slot].owner_id == owner_id)
-	    && (access_len <= SCC_KEY_SLOT_SIZE)) {
-		status = SCC_RET_OK;
-		pr_debug("SCC2: Verify on slot %d succeeded\n", slot);
-	} else {
-		if (slot >= SCC_KEY_SLOTS) {
-			pr_debug("SCC2: Verify on bad slot (%d) failed\n",
-				 slot);
-		} else if (scc_key_info[slot].status) {
-			pr_debug("SCC2: Verify on slot %d failed (%Lx) \n",
-				 slot, owner_id);
-		} else {
-			pr_debug
-			    ("SC2C: Verify on slot %d failed: not allocated\n",
-			     slot);
-		}
-	}
-
-      out:
-	return status;
-}
-
-/*****************************************************************************/
-/* fn scc_dealloc_slot()                                                     */
-/*****************************************************************************/
-scc_return_t scc_dealloc_slot(uint64_t owner_id, uint32_t slot)
-{
-	scc_return_t status;
-	unsigned long irq_flags;
-	uint8_t *slot_loc = NULL;
-	int i;
-
-	/* ACQUIRE LOCK to prevent others from using SCC crypto */
-	spin_lock_irqsave(&scc_crypto_lock, irq_flags);
-
-	status = verify_slot_access(owner_id, slot, 0);
-	if (status != SCC_RET_OK) {
-		goto out;
-	}
-
-	scc_key_info[slot].owner_id = 0;
-	scc_key_info[slot].status = 0;	/* unassign */
-	slot_loc = sahara_partition_base + scc_key_info[slot].offset;
-
-	for (i = 0; i < SCC_KEY_SLOT_SIZE; i++) {
-		slot_loc[i] = 0;
-	}
-	pr_debug("SCC2: Deallocated slot %d\n", slot);
-
-      out:
-	spin_unlock_irqrestore(&scc_crypto_lock, irq_flags);
-
-	return status;
-}
-
-/*****************************************************************************/
-/* fn scc_load_slot()                                                        */
-/*****************************************************************************/
-/*!
- * Load a value into a slot.
+/**
+ * Encrypt a region of secure memory.
  *
- * @param owner_id      Value of owner of slot
- * @param slot          Handle of slot
- * @param key_data      Data to load into the slot
- * @param key_length    Length, in bytes, of @c key_data to copy to SCC.
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to the plaintext
+ *                       data.
+ * @param   byte_count   Length of the region (octets).
+ * @param   black_data   Physical location to store the encrypted data.
+ * @param   IV           Value to use for the IV.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
  *
- * @return SCC_RET_OK on success.  SCC_RET_FAIL will be returned if slot
- * specified cannot be accessed for any reason, or SCC_RET_INSUFFICIENT_SPACE
- * if @c key_length exceeds the size of the slot.
+ * @return  SCC_RET_OK if successful.
  */
 scc_return_t
-scc_load_slot(uint64_t owner_id, uint32_t slot, uint8_t * key_data,
-	      uint32_t key_length)
+scc_encrypt_region(uint32_t part_base, uint32_t offset_bytes,
+		   uint32_t byte_count, uint8_t *black_data,
+		   uint32_t *IV, scc_cypher_mode_t cypher_mode)
 {
-	scc_return_t status;
-	unsigned long irq_flags;
-
-	/* ACQUIRE LOCK to prevent others from using SCC crypto */
-	spin_lock_irqsave(&scc_crypto_lock, irq_flags);
-
-	status = verify_slot_access(owner_id, slot, key_length);
-	if ((status == SCC_RET_OK) && (key_data != NULL)) {
-		status = SCC_RET_FAIL;	/* reset expectations */
-
-		if (key_length > SCC_KEY_SLOT_SIZE) {
-			pr_debug
-			    ("SCC2: scc_load_slot() rejecting key of %d bytes.\n",
-			     key_length);
-			status = SCC_RET_INSUFFICIENT_SPACE;
-		} else {
-			if (copy_to_scc(key_data,
-					(uint32_t) sahara_partition_base +
-					scc_key_info[slot].offset, key_length,
-					NULL)) {
-				pr_debug("SCC2: RED copy_to_scc() failed for"
-					 " scc_load_slot()\n");
-			} else {
-				status = SCC_RET_OK;
-			}
-		}
-	}
-
-	spin_unlock_irqrestore(&scc_crypto_lock, irq_flags);
-
-	return status;
-}				/* scc_load_slot */
-
-/*****************************************************************************/
-/* fn scc_encrypt_slot()                                                     */
-/*****************************************************************************/
-/*!
- * Allocate a key slot to fit the requested size.
- *
- * @param owner_id      Value of owner of slot
- * @param slot          Handle of slot
- * @param length        Length, in bytes, of @c black_data
- * @param black_data    Location to store result of encrypting RED data in slot
- *
- * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
- *         accessed for any reason.
- */
-scc_return_t scc_encrypt_slot(uint64_t owner_id, uint32_t slot,
-			      uint32_t length, uint8_t * black_data)
-{
-	unsigned long irq_flags;
-	scc_return_t status;
+	os_lock_context_t irq_flags;	/* for IRQ save/restore */
+	scc_return_t status = SCC_RET_OK;
 	uint32_t crypto_status;
-	uint32_t scm_command = scc_key_info[slot].part_ctl;
+	uint32_t scm_command;
+	int offset_blocks = offset_bytes / SCC_BLOCK_SIZE_BYTES();
+
+	scm_command = ((offset_blocks << SCM_CCMD_OFFSET_SHIFT) |
+		       (SCM_PART_NUMBER(part_base) << SCM_CCMD_PART_SHIFT));
+
+	switch (cypher_mode) {
+	case SCC_CYPHER_MODE_CBC:
+		scm_command |= SCM_CCMD_AES_ENC_CBC;
+		break;
+	case SCC_CYPHER_MODE_ECB:
+		scm_command |= SCM_CCMD_AES_ENC_ECB;
+		break;
+	default:
+		status = SCC_RET_FAIL;
+		break;
+	}
+
+	pr_debug("Received encrypt request.  SCM_C_BLACK_ST_REG: %p, "
+		 "scm_Command: %08x, length: %i (part_base: %08x, "
+		 "offset: %i)\n",
+		 black_data, scm_command, byte_count, part_base, offset_blocks);
+
+	if (status != SCC_RET_OK)
+		goto out;
 
 	/* ACQUIRE LOCK to prevent others from using crypto or releasing slot */
-	spin_lock_irqsave(&scc_crypto_lock, irq_flags);
+	os_lock_save_context(scc_crypto_lock, irq_flags);
 
-	status = verify_slot_access(owner_id, slot, length);
 	if (status == SCC_RET_OK) {
-		SCC_WRITE_REGISTER(SCM_C_BLACK_ST_REG, scm_black_part_phys);
-
-		/* Use OwnerID as CBC IV to tie Owner to data */
-		SCC_WRITE_REGISTER(SCM_AES_CBC_IV0_REG,
-				   *(uint32_t *) & owner_id);
-		SCC_WRITE_REGISTER(SCM_AES_CBC_IV1_REG,
-				   *(((uint32_t *) & owner_id) + 1));
-		SCC_WRITE_REGISTER(SCM_AES_CBC_IV2_REG, 0);
-		SCC_WRITE_REGISTER(SCM_AES_CBC_IV3_REG, 0);
+		SCC_WRITE_REGISTER(SCM_C_BLACK_ST_REG, (uint32_t) black_data);
+
+		/* Only write the IV if it will actually be used */
+		if (cypher_mode == SCC_CYPHER_MODE_CBC) {
+			/* Write the IV register */
+			SCC_WRITE_REGISTER(SCM_AES_CBC_IV0_REG, *(IV));
+			SCC_WRITE_REGISTER(SCM_AES_CBC_IV1_REG, *(IV + 1));
+			SCC_WRITE_REGISTER(SCM_AES_CBC_IV2_REG, *(IV + 2));
+			SCC_WRITE_REGISTER(SCM_AES_CBC_IV3_REG, *(IV + 3));
+		}
 
 		/* Set modes and kick off the encryption */
-		crypto_status =
-		    scc_do_crypto(length, scm_command | SCM_CCMD_AES_ENC_CBC);
+		crypto_status = scc_do_crypto(byte_count, scm_command);
 
 		if (crypto_status != 0) {
 			pr_debug("SCM encrypt red crypto failure: 0x%x\n",
 				 crypto_status);
 		} else {
-
-			/* Give blob back to caller */
-			if (!copy_from_scc
-			    ((uint32_t) scm_black_part_virt, black_data, length,
-			     NULL)) {
-				status = SCC_RET_OK;
-				pr_debug
-				    ("SCC2: Encrypted slot %d for %d bytes\n",
-				     slot, length);
-			}
+			status = SCC_RET_OK;
+			pr_debug("SCC2: Encrypted %d bytes\n", byte_count);
 		}
 	}
 
-	spin_unlock_irqrestore(&scc_crypto_lock, irq_flags);
-
+	os_unlock_restore_context(scc_crypto_lock, irq_flags);
+out:
 	return status;
 }
 
-/*****************************************************************************/
-/* fn scc_decrypt_slot()                                                     */
-/*****************************************************************************/
-/*!
- * Decrypt some black data and leave result in the slot.
+/* Decrypt a region into secure memory
  *
- * @param owner_id      Value of owner of slot
- * @param slot          Handle of slot
- * @param length        Length, in bytes, of @c black_data
- * @param black_data    Location of data to dencrypt and store in slot
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to store the
+ *                       plaintext data.
+ * @param   byte_counts  Length of the region (octets).
+ * @param   black_data   Physical location of the encrypted data.
+ * @param   IV           Value to use for the IV.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
  *
- * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
- *         accessed for any reason.
+ * @return  SCC_RET_OK if successful.
  */
-scc_return_t scc_decrypt_slot(uint64_t owner_id, uint32_t slot,
-			      uint32_t length, const uint8_t * black_data)
+scc_return_t
+scc_decrypt_region(uint32_t part_base, uint32_t offset_bytes,
+		   uint32_t byte_count, uint8_t *black_data,
+		   uint32_t *IV, scc_cypher_mode_t cypher_mode)
 {
-	unsigned long irq_flags;
-	scc_return_t status;
+	os_lock_context_t irq_flags;	/* for IRQ save/restore */
+	scc_return_t status = SCC_RET_OK;
 	uint32_t crypto_status;
-	uint32_t scm_command = scc_key_info[slot].part_ctl;
+	uint32_t scm_command;
+	int offset_blocks = offset_bytes / SCC_BLOCK_SIZE_BYTES();
+
+	scm_command = ((offset_blocks << SCM_CCMD_OFFSET_SHIFT) |
+		       (SCM_PART_NUMBER(part_base) << SCM_CCMD_PART_SHIFT));
+
+	switch (cypher_mode) {
+	case SCC_CYPHER_MODE_CBC:
+		scm_command |= SCM_CCMD_AES_DEC_CBC;
+		break;
+	case SCC_CYPHER_MODE_ECB:
+		scm_command |= SCM_CCMD_AES_DEC_ECB;
+		break;
+	default:
+		status = SCC_RET_FAIL;
+		break;
+	}
+
+	pr_debug("Received decrypt request.  SCM_C_BLACK_ST_REG: %p, "
+		 "scm_Command: %08x, length: %i (part_base: %08x, "
+		 "offset: %i)\n",
+		 black_data, scm_command, byte_count, part_base, offset_blocks);
+
+	if (status != SCC_RET_OK)
+		goto out;
 
 	/* ACQUIRE LOCK to prevent others from using crypto or releasing slot */
-	spin_lock_irqsave(&scc_crypto_lock, irq_flags);
+	os_lock_save_context(scc_crypto_lock, irq_flags);
 
-	status = verify_slot_access(owner_id, slot, length);
 	if (status == SCC_RET_OK) {
 		status = SCC_RET_FAIL;	/* reset expectations */
+		SCC_WRITE_REGISTER(SCM_C_BLACK_ST_REG, (uint32_t) black_data);
 
-		/* Place black key in to BLACK RAM and set up the SCC */
-		copy_to_scc(black_data,
-			    (uint32_t) scm_black_part_virt, length, NULL);
-
-		SCC_WRITE_REGISTER(SCM_C_BLACK_ST_REG, scm_black_part_phys);
-
-		/* Use OwnerID as CBC IV to tie Owner to data */
-		SCC_WRITE_REGISTER(SCM_AES_CBC_IV0_REG,
-				   *(uint32_t *) & owner_id);
-		SCC_WRITE_REGISTER(SCM_AES_CBC_IV1_REG,
-				   *(((uint32_t *) & owner_id) + 1));
-		SCC_WRITE_REGISTER(SCM_AES_CBC_IV2_REG, 0);
-		SCC_WRITE_REGISTER(SCM_AES_CBC_IV3_REG, 0);
+		/* Write the IV register */
+		SCC_WRITE_REGISTER(SCM_AES_CBC_IV0_REG, *(IV));
+		SCC_WRITE_REGISTER(SCM_AES_CBC_IV1_REG, *(IV + 1));
+		SCC_WRITE_REGISTER(SCM_AES_CBC_IV2_REG, *(IV + 2));
+		SCC_WRITE_REGISTER(SCM_AES_CBC_IV3_REG, *(IV + 3));
 
 		/* Set modes and kick off the decryption */
-		crypto_status = scc_do_crypto(length,
-					      scm_command |
-					      SCM_CCMD_AES_DEC_CBC);
+		crypto_status = scc_do_crypto(byte_count, scm_command);
 
 		if (crypto_status != 0) {
 			pr_debug("SCM decrypt black crypto failure: 0x%x\n",
 				 crypto_status);
 		} else {
 			status = SCC_RET_OK;
-			pr_debug("SCC2: Decrypted slot %d for %d bytes\n", slot,
-				 length);
+			pr_debug("SCC2: Decrypted %d bytes\n", byte_count);
 		}
 	}
 
-	spin_unlock_irqrestore(&scc_crypto_lock, irq_flags);
-
+	os_unlock_restore_context(scc_crypto_lock, irq_flags);
+out:
 	return status;
 }
 
 /*****************************************************************************/
-/* fn scc_get_slot_info()                                                    */
+/* fn host_owns_partition()                                                  */
 /*****************************************************************************/
-/*!
- * Determine address and value length for a give slot.
+/**
+ * Determine if the host owns a given partition.
+ *
+ * @internal
  *
- * @param owner_id      Value of owner of slot
- * @param slot          Handle of slot
- * @param address       Location to store kernel address of slot data
- * @param value_size_bytes Location to store allocated length of data in slot.
- *                         May be NULL if value is not needed by caller.
- * @param slot_size_bytes  Location to store max length data in slot
- *                         May be NULL if value is not needed by caller.
+ * @param part_no       Partition number to query
  *
- * @return SCC_RET_OK or error indication
+ * @return TRUE if the host owns the partition, FALSE otherwise.
  */
-scc_return_t
-scc_get_slot_info(uint64_t owner_id, uint32_t slot, uint32_t * address,
-		  uint32_t * value_size_bytes, uint32_t * slot_size_bytes)
-{
-	scc_return_t status = verify_slot_access(owner_id, slot, 0);
-
-	if (status == SCC_RET_OK) {
-		*address = sahara_partition_phys + scc_key_info[slot].offset;
-		if (value_size_bytes != NULL) {
-			*value_size_bytes = scc_key_info[slot].length;
-		}
-		if (slot_size_bytes != NULL) {
-			*slot_size_bytes = SCC_KEY_SLOT_SIZE;
-		}
-	}
-
-	return status;
-}
 
-/*!
- * For now, this function will create a shared Sahara and SCC2 partition.  It
- * will be used as a key store for Sahara and, to mimic SCCv1 behavior, as the
- * temporary black and red memories for ephemeral cipher operations.
- *
- * This means that it will not be secure against kernel access, and in fact
- * must be available for host read/write.
- *
- * *========================================*
- * *     Key Slot 0                         *
- * *     Key Slot 1                         *
- * *     Key Slot ...                       *
- * *     Key Slot n                         *
- * * -------------------------------------- *
- * *                                        *
- * *    'BLACK RAM'                         *
- * *                                        *
- * * -------------------------------------- *
- * *                                        *
- * *    'RED RAM'                           *
- * *                                        *
- * *========================================*
- *
- * or -- the BLACK RAM gets put in a separate partition...
- */
-static
-scc_return_t make_sahara_partition()
+static uint32_t host_owns_partition(uint32_t part_no)
 {
-	unsigned part_no = SAHARA_PART_NO;	/* better be free!! */
-	int retval = -EIO;
-	uint32_t *part_base =
-	    scm_ram_base + (part_no * scc_configuration.partition_size_bytes);
-	uint32_t reg_value;
-
-	reg_value = SCC_READ_REGISTER(SCM_PART_OWNERS_REG);
-
-	/* Store SMID to grab a partition */
-	SCC_WRITE_REGISTER(SCM_SMID0_REG + 8 * part_no, 0x00000000);
-	mdelay(2);
-
-	/* Now make sure it is ours... ? */
-	reg_value = SCC_READ_REGISTER(SCM_PART_OWNERS_REG);
-
-	if (((reg_value >> (2 * part_no)) & 0x3) != 3) {
-		printk(KERN_ERR "Could not acquire partition %u\n", part_no);
-		goto out;
-	}
-	sahara_partition_base = (uint8_t *) part_base;
-
-	pr_debug("SCC2 Writing UMID at %p\n", part_base);
-
-	/* Write in the UMID */
-	part_base[4] = 0x42;
-	part_base[5] = 0x43;
-	part_base[6] = 0x19;
-	part_base[7] = 0x59;
-
-	mdelay(2);
-
-	/* Give both host and Sahara access for read/write */
-	part_base[0] =
-	    SCM_PERM_HD_WRITE | SCM_PERM_HD_READ | SCM_PERM_TH_READ |
-	    SCM_PERM_TH_WRITE;
-	mdelay(2);
+	uint32_t value;
 
-	reg_value = SCC_READ_REGISTER(SCM_PART_ENGAGED_REG);
+	if (part_no < scc_configuration.partition_count) {
 
-	if (((reg_value >> part_no) & 1) != 1) {
-		printk(KERN_ERR "SCC2 Could not engage partition %u\n",
-		       part_no);
-		retval = SCC_RET_FAIL;
-		goto out;
+		/* Check the partition owners register */
+		value = SCC_READ_REGISTER(SCM_PART_OWNERS_REG);
+		if (((value >> (part_no * SCM_POWN_SHIFT)) & SCM_POWN_MASK)
+		    == SCM_POWN_PART_OWNED)
+			return TRUE;
 	}
-//    (void)SCC_READ_REGISTER(SCM_ACC4_REG);
-
-	sahara_partition_phys =
-	    (uint32_t) scm_ram_phys_base +
-	    (part_no * scc_configuration.partition_size_bytes);
-
-	scm_black_part_virt =
-	    sahara_partition_base + (SCC_KEY_SLOTS * SCC_KEY_SLOT_SIZE);
-	scm_black_part_phys =
-	    sahara_partition_phys + (scm_black_part_virt -
-				     sahara_partition_base);
-
-	scm_memory_size_bytes = 256;
-	scm_red_part_virt = scm_black_part_virt + scm_memory_size_bytes;
-	if ((uint32_t) (scm_red_part_virt - sahara_partition_phys) < 256) {
-		printk(KERN_ERR
-		       "SCC2: not enough space in Sahara partition: too many / too large keys\n");
-		retval = SCC_RET_INSUFFICIENT_SPACE;
-		goto out;
-	}
-
-	scm_red_part_cmd = (((part_no << SCM_CCMD_PART_SHIFT)
-			     | ((scm_red_part_virt - sahara_partition_base) /
-				SCC_BLOCK_SIZE_BYTES())
-			     << SCM_CCMD_OFFSET_SHIFT)
-			    | SCM_CCMD_AES);
-
-	pr_debug
-	    ("SCC2: Sahara partition %08x/%p; Black RAM: %08x/%p; Red RAM: %p\n",
-	     sahara_partition_phys, sahara_partition_base, scm_black_part_phys,
-	     scm_black_part_virt, scm_red_part_virt);
-
-	retval = SCC_RET_OK;
+	return FALSE;
+}
 
-      out:
-	return retval;
-}				/* make_sahara_partition() */
+/*****************************************************************************/
+/* fn partition_engaged()                                                    */
+/*****************************************************************************/
+/**
+ * Determine if the given partition is engaged.
+ *
+ * @internal
+ *
+ * @param part_no       Partition number to query
+ *
+ * @return TRUE if the partition is engaged, FALSE otherwise.
+ */
 
-uint8_t make_vpu_partition()
+static uint32_t partition_engaged(uint32_t part_no)
 {
-	unsigned part_no = VPU_PART_NO;	/* better be free!! */
-	uint32_t *part_base =
-	    scm_ram_base + (part_no * scc_configuration.partition_size_bytes);
-	uint32_t reg_value;
-
-	reg_value = SCC_READ_REGISTER(SCM_PART_OWNERS_REG);
-
-	/* Store SMID to grab a partition */
-	for (; part_no < 4; part_no++)
-		SCC_WRITE_REGISTER(SCM_SMID0_REG + 8 * part_no, 0x00000000);
-
-	mdelay(2);
-
-	/* Now make sure it is ours... ? */
-	reg_value = SCC_READ_REGISTER(SCM_PART_OWNERS_REG);
-	for (; part_no < 4; part_no++) {
-		if (((reg_value >> (2 * part_no)) & 0x3) != 3) {
-			printk(KERN_ERR "Could not acquire partition %u\n",
-			       part_no);
-			goto out;
-		}
-	}
-	vpu_partition_base = (uint8_t *) part_base;
-
-	mdelay(2);
-	for (; part_no < 4; part_no++) {
-		part_base =
-		    scm_ram_base +
-		    (part_no * scc_configuration.partition_size_bytes);
-		part_base[0] =
-		    SCM_PERM_HD_WRITE | SCM_PERM_HD_READ | SCM_PERM_TH_READ |
-		    SCM_PERM_TH_WRITE;
-	}
-	mdelay(2);
+	uint32_t value;
 
-	reg_value = SCC_READ_REGISTER(SCM_PART_ENGAGED_REG);
+	if (part_no < scc_configuration.partition_count) {
 
-	if (((reg_value >> part_no) & 1) != 1) {
-		printk(KERN_ERR "SCC2 Could not engage partition %u\n",
-		       part_no);
-		goto out;
+		/* Check the partition engaged register */
+		value = SCC_READ_REGISTER(SCM_PART_ENGAGED_REG);
+		if (((value >> (part_no * SCM_PENG_SHIFT)) & 0x1)
+		    == SCM_PENG_ENGAGED)
+			return TRUE;
 	}
-	part_no = VPU_PART_NO;
-	vpu_partition_phys =
-	    (uint32_t) scm_ram_phys_base +
-	    (part_no * scc_configuration.partition_size_bytes);
-
-	return vpu_partition_phys;
-
-      out:
-	return 0;
-}				/* make_vpu_partition */
+	return FALSE;
+}
 
 /*****************************************************************************/
 /* fn scc_wait_completion()                                                  */
 /*****************************************************************************/
-/*!
+/**
  * Poll looking for end-of-cipher indication. Only used
  * if @c SCC_SCM_SLEEP is not defined.
  *
@@ -2139,6 +1535,10 @@ uint8_t make_vpu_partition()
  * On a Tahiti, crypto under 230 or so bytes is done after the first loop, all
  * the way up to five sets of spins for 1024 bytes.  (8- and 16-byte functions
  * are done when we first look.  Zeroizing takes one pass around.
+ *
+ * @param   scm_status      Address of the SCM_STATUS register
+ *
+ * @return  A return code of type #scc_return_t
  */
 static scc_return_t scc_wait_completion(uint32_t * scm_status)
 {
@@ -2151,6 +1551,7 @@ static scc_return_t scc_wait_completion(uint32_t * scm_status)
 		done = is_cipher_done(scm_status);
 		if (done)
 			break;
+		/* TODO: shorten this delay */
 		udelay(1000);
 	} while (i++ < SCC_CIPHER_MAX_POLL_COUNT);
 
@@ -2165,10 +1566,14 @@ static scc_return_t scc_wait_completion(uint32_t * scm_status)
 /*****************************************************************************/
 /* fn is_cipher_done()                                                       */
 /*****************************************************************************/
-/*!
+/**
  * This function returns non-zero if SCM Status register indicates
  * that a cipher has terminated or some other interrupt-generating
  * condition has occurred.
+ *
+ * @param scm_status    Address of the SCM STATUS register
+ *
+ * @return  0 if cipher operations are finished
  */
 static int is_cipher_done(uint32_t * scm_status)
 {
@@ -2218,22 +1623,22 @@ static inline int offset_within_scm(uint32_t register_offset)
 {
 	return 1;		/* (register_offset >= SCM_RED_START)
 				   && (register_offset < scm_highest_memory_address); */
-	/* Although this would cause trouble for zeroize testing, this change would
-	 * close a security whole which currently allows any kernel program to access
-	 * any location in RED RAM.  Perhaps enforce in non-SCC_DEBUG compiles?
-	 && (register_offset <= SCM_INIT_VECTOR_1); */
+/* Although this would cause trouble for zeroize testing, this change would
+ * close a security hole which currently allows any kernel program to access
+ * any location in RED RAM.  Perhaps enforce in non-SCC_DEBUG compiles?
+ && (register_offset <= SCM_INIT_VECTOR_1); */
 }
 
 /*****************************************************************************/
 /* fn check_register_accessible()                                            */
 /*****************************************************************************/
-/*!
+/**
  *  Given the current SCM and SMN status, verify that access to the requested
  *  register should be OK.
  *
  *  @param[in]   register_offset  register offset within SCC
- *  @param[in]   smn_status  recent value from #SMN_STATUS
- *  @param[in]   scm_status  recent value from #SCM_STATUS
+ *  @param[in]   smn_status  recent value from #SMN_STATUS_REG
+ *  @param[in]   scm_status  recent value from #SCM_STATUS_REG
  *
  *  @return   #SCC_RET_OK if ok, #SCC_RET_FAIL if not
  */
@@ -2289,7 +1694,7 @@ check_register_accessible(uint32_t register_offset, uint32_t smn_status,
 /*****************************************************************************/
 /* fn check_register_offset()                                                */
 /*****************************************************************************/
-/*!
+/**
  *  Check that the offset is with the bounds of the SCC register set.
  *
  *  @param[in]  register_offset    register offset of SMN.
@@ -2317,7 +1722,7 @@ static scc_return_t check_register_offset(uint32_t register_offset)
 
 #ifdef SCC_REGISTER_DEBUG
 
-/*!
+/**
  * Names of the SCC Registers, indexed by register number
  */
 static char *scc_regnames[] = {
@@ -2403,7 +1808,7 @@ static char *scc_regnames[] = {
 	"SMN_HAC_REG"
 };
 
-/*!
+/**
  * Names of the Secure RAM States
  */
 static char *srs_names[] = {
@@ -2426,7 +1831,7 @@ static char *srs_names[] = {
 	"SRS_FAIL"
 };
 
-/*!
+/**
  * Create a text interpretation of the SCM Version Register
  *
  * @param      value        The value of the register
@@ -2449,7 +1854,7 @@ char *scm_print_version_reg(uint32_t value, char *print_buffer, int buf_size)
 	return print_buffer;
 }
 
-/*!
+/**
  * Create a text interpretation of the SCM Status Register
  *
  * @param      value        The value of the register
@@ -2482,7 +1887,7 @@ char *scm_print_status_reg(uint32_t value, char *print_buffer, int buf_size)
 	return print_buffer;
 }
 
-/*!
+/**
  * Names of the SCM Error Codes
  */
 static
@@ -2505,7 +1910,7 @@ char *scm_err_code[] = {
 	"Unknown_F",
 };
 
-/*!
+/**
  * Names of the SMN States
  */
 static char *smn_state_name[] = {
@@ -2543,7 +1948,7 @@ static char *smn_state_name[] = {
 	"Invalid_1F"
 };
 
-/*!
+/**
  * Create a text interpretation of the SCM Error Status Register
  *
  * @param      value        The value of the register
@@ -2569,7 +1974,7 @@ char *scm_print_err_status_reg(uint32_t value, char *print_buffer, int buf_size)
 	return print_buffer;
 }
 
-/*!
+/**
  * Create a text interpretation of the SCM Zeroize Command Register
  *
  * @param      value        The value of the register
@@ -2592,7 +1997,7 @@ char *scm_print_zcmd_reg(uint32_t value, char *print_buffer, int buf_size)
 	return print_buffer;
 }
 
-/*!
+/**
  * Create a text interpretation of the SCM Cipher Command Register
  *
  * @param      value        The value of the register
@@ -2625,7 +2030,7 @@ char *scm_print_ccmd_reg(uint32_t value, char *print_buffer, int buf_size)
 	return print_buffer;
 }
 
-/*!
+/**
  * Create a text interpretation of an SCM Access Permissions Register
  *
  * @param      value        The value of the register
@@ -2652,7 +2057,7 @@ char *scm_print_acc_reg(uint32_t value, char *print_buffer, int buf_size)
 	return print_buffer;
 }
 
-/*!
+/**
  * Create a text interpretation of the SCM Partitions Engaged Register
  *
  * @param      value        The value of the register
@@ -2684,7 +2089,7 @@ char *scm_print_part_eng_reg(uint32_t value, char *print_buffer, int buf_size)
 	return print_buffer;
 }
 
-/*!
+/**
  * Create a text interpretation of the SMN Status Register
  *
  * @param      value        The value of the register
@@ -2719,97 +2124,97 @@ char *smn_print_status_reg(uint32_t value, char *print_buffer, int buf_size)
 	return print_buffer;
 }
 
-/*!
+/**
  * The array, indexed by register number (byte-offset / 4), of print routines
  * for the SCC (SCM and SMN) registers.
  */
 static reg_print_routine_t reg_printers[] = {
 	scm_print_version_reg,
-	NULL,			//"0x04",
-	NULL,			//"SCM_INT_CTL_REG",
+	NULL,			/* 0x04 */
+	NULL,			/* SCM_INT_CTL_REG */
 	scm_print_status_reg,
 	scm_print_err_status_reg,
-	NULL,			//"SCM_FAULT_ADR_REG",
-	NULL,			//"SCM_PART_OWNERS_REG",
+	NULL,			/* SCM_FAULT_ADR_REG */
+	NULL,			/* SCM_PART_OWNERS_REG */
 	scm_print_part_eng_reg,
-	NULL,			//"SCM_UNIQUE_ID0_REG",
-	NULL,			//"SCM_UNIQUE_ID1_REG",
-	NULL,			//"SCM_UNIQUE_ID2_REG",
-	NULL,			//"SCM_UNIQUE_ID3_REG",
-	NULL,			//"0x30",
-	NULL,			//"0x34",
-	NULL,			//"0x38",
-	NULL,			//"0x3C",
-	NULL,			//"0x40",
-	NULL,			//"0x44",
-	NULL,			//"0x48",
-	NULL,			//"0x4C",
+	NULL,			/* SCM_UNIQUE_ID0_REG */
+	NULL,			/* SCM_UNIQUE_ID1_REG */
+	NULL,			/* SCM_UNIQUE_ID2_REG */
+	NULL,			/* SCM_UNIQUE_ID3_REG */
+	NULL,			/* 0x30 */
+	NULL,			/* 0x34 */
+	NULL,			/* 0x38 */
+	NULL,			/* 0x3C */
+	NULL,			/* 0x40 */
+	NULL,			/* 0x44 */
+	NULL,			/* 0x48 */
+	NULL,			/* 0x4C */
 	scm_print_zcmd_reg,
 	scm_print_ccmd_reg,
-	NULL,			//"SCM_C_BLACK_ST_REG",
-	NULL,			//"SCM_DBG_STATUS_REG",
-	NULL,			//"SCM_AES_CBC_IV0_REG",
-	NULL,			//"SCM_AES_CBC_IV1_REG",
-	NULL,			//"SCM_AES_CBC_IV2_REG",
-	NULL,			//"SCM_AES_CBC_IV3_REG",
-	NULL,			//"0x70",
-	NULL,			//"0x74",
-	NULL,			//"0x78",
-	NULL,			//"0x7C",
-	NULL,			//"SCM_SMID0_REG",
+	NULL,			/* SCM_C_BLACK_ST_REG */
+	NULL,			/* SCM_DBG_STATUS_REG */
+	NULL,			/* SCM_AES_CBC_IV0_REG */
+	NULL,			/* SCM_AES_CBC_IV1_REG */
+	NULL,			/* SCM_AES_CBC_IV2_REG */
+	NULL,			/* SCM_AES_CBC_IV3_REG */
+	NULL,			/* 0x70 */
+	NULL,			/* 0x74 */
+	NULL,			/* 0x78 */
+	NULL,			/* 0x7C */
+	NULL,			/* SCM_SMID0_REG */
 	scm_print_acc_reg,	/* ACC0 */
-	NULL,			//"SCM_SMID1_REG",
+	NULL,			/* SCM_SMID1_REG */
 	scm_print_acc_reg,	/* ACC1 */
-	NULL,			//"SCM_SMID2_REG",
+	NULL,			/* SCM_SMID2_REG */
 	scm_print_acc_reg,	/* ACC2 */
-	NULL,			//"SCM_SMID3_REG",
+	NULL,			/* SCM_SMID3_REG */
 	scm_print_acc_reg,	/* ACC3 */
-	NULL,			//"SCM_SMID4_REG",
+	NULL,			/* SCM_SMID4_REG */
 	scm_print_acc_reg,	/* ACC4 */
-	NULL,			//"SCM_SMID5_REG",
+	NULL,			/* SCM_SMID5_REG */
 	scm_print_acc_reg,	/* ACC5 */
-	NULL,			//"SCM_SMID6_REG",
+	NULL,			/* SCM_SMID6_REG */
 	scm_print_acc_reg,	/* ACC6 */
-	NULL,			//"SCM_SMID7_REG",
+	NULL,			/* SCM_SMID7_REG */
 	scm_print_acc_reg,	/* ACC7 */
-	NULL,			//"SCM_SMID8_REG",
+	NULL,			/* SCM_SMID8_REG */
 	scm_print_acc_reg,	/* ACC8 */
-	NULL,			//"SCM_SMID9_REG",
+	NULL,			/* SCM_SMID9_REG */
 	scm_print_acc_reg,	/* ACC9 */
-	NULL,			//"SCM_SMID10_REG",
+	NULL,			/* SCM_SMID10_REG */
 	scm_print_acc_reg,	/* ACC10 */
-	NULL,			//"SCM_SMID11_REG",
+	NULL,			/* SCM_SMID11_REG */
 	scm_print_acc_reg,	/* ACC11 */
-	NULL,			//"SCM_SMID12_REG",
+	NULL,			/* SCM_SMID12_REG */
 	scm_print_acc_reg,	/* ACC12 */
-	NULL,			//"SCM_SMID13_REG",
+	NULL,			/* SCM_SMID13_REG */
 	scm_print_acc_reg,	/* ACC13 */
-	NULL,			//"SCM_SMID14_REG",
+	NULL,			/* SCM_SMID14_REG */
 	scm_print_acc_reg,	/* ACC14 */
-	NULL,			//"SCM_SMID15_REG",
+	NULL,			/* SCM_SMID15_REG */
 	scm_print_acc_reg,	/* ACC15 */
 	smn_print_status_reg,
-	NULL,			//"SMN_COMMAND_REG",
-	NULL,			//"SMN_SEQ_START_REG",
-	NULL,			//"SMN_SEQ_END_REG",
-	NULL,			//"SMN_SEQ_CHECK_REG",
-	NULL,			//"SMN_BB_CNT_REG",
-	NULL,			//"SMN_BB_INC_REG",
-	NULL,			//"SMN_BB_DEC_REG",
-	NULL,			//"SMN_COMPARE_REG",
-	NULL,			//"SMN_PT_CHK_REG",
-	NULL,			//"SMN_CT_CHK_REG",
-	NULL,			//"SMN_TIMER_IV_REG",
-	NULL,			//"SMN_TIMER_CTL_REG",
-	NULL,			//"SMN_SEC_VIO_REG",
-	NULL,			//"SMN_TIMER_REG",
-	NULL,			//"SMN_HAC_REG"
+	NULL,			/* SMN_COMMAND_REG */
+	NULL,			/* SMN_SEQ_START_REG */
+	NULL,			/* SMN_SEQ_END_REG */
+	NULL,			/* SMN_SEQ_CHECK_REG */
+	NULL,			/* SMN_BB_CNT_REG */
+	NULL,			/* SMN_BB_INC_REG */
+	NULL,			/* SMN_BB_DEC_REG */
+	NULL,			/* SMN_COMPARE_REG */
+	NULL,			/* SMN_PT_CHK_REG */
+	NULL,			/* SMN_CT_CHK_REG */
+	NULL,			/* SMN_TIMER_IV_REG */
+	NULL,			/* SMN_TIMER_CTL_REG */
+	NULL,			/* SMN_SEC_VIO_REG */
+	NULL,			/* SMN_TIMER_REG */
+	NULL,			/* SMN_HAC_REG */
 };
 
 /*****************************************************************************/
 /* fn dbg_scc_read_register()                                                */
 /*****************************************************************************/
-/*!
+/**
  * Noisily read a 32-bit value to an SCC register.
  * @param offset        The address of the register to read.
  *
diff --git a/drivers/mxc/security/scc2_internals.h b/drivers/mxc/security/scc2_internals.h
index 90a32eb..6bf0872 100644
--- a/drivers/mxc/security/scc2_internals.h
+++ b/drivers/mxc/security/scc2_internals.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -13,13 +13,13 @@
 #ifndef SCC_INTERNALS_H
 #define SCC_INTERNALS_H
 
-/** @file scc_internals.h
+/** @file scc2_internals.h
  *
  * @brief This is intended to be the file which contains most or all of the
  * code or changes need to port the driver.  It also includes other definitions
  * needed by the driver.
  *
- *  This header file should only ever be included by scc_driver.c
+ *  This header file should only ever be included by scc2_driver.c
  *
  *  Compile-time flags minimally needed:
  *
@@ -67,7 +67,7 @@
  * Define the number of Stored Keys which the SCC driver will make available.
  * Value shall be from 0 to 20.  Default is zero (0).
  */
-#define SCC_KEY_SLOTS   20
+/*#define SCC_KEY_SLOTS   20*/
 
 
 /* Temporarily define compile-time flags to make Doxygen happy. */
@@ -290,11 +290,30 @@
  * @return   (void)
  */
 #ifndef SCC_REGISTER_DEBUG
-#define SCC_WRITE_REGISTER(offset,value) (void)__raw_writel(value, scc_base+(offset))
+#define SCC_WRITE_REGISTER(offset,value) \
+	(void)__raw_writel(value, scc_base+(offset))
 #else
-#define SCC_WRITE_REGISTER(offset,value) dbg_scc_write_register(offset, value)
+#define SCC_WRITE_REGISTER(offset,value) \
+	dbg_scc_write_register(offset, value)
 #endif
 
+/**
+ * Calculate the physical address of a partition from the partition number.
+ */
+#define SCM_PART_PHYS_ADDRESS(part)                                     \
+ ((uint32_t)scm_ram_phys_base + (part*scc_configuration.partition_size_bytes))
+
+/**
+ * Calculate the kernel virtual address of a partition from the partition number.
+ */
+#define SCM_PART_ADDRESS(part)                                          \
+ (scm_ram_base + (part*scc_configuration.partition_size_bytes))
+
+/**
+ * Calculate the partition number from the kernel virtual address.
+ */
+#define SCM_PART_NUMBER(address)                                        \
+ ((address - (uint32_t)scm_ram_base)/scc_configuration.partition_size_bytes)
 
 /**
  * Calculates the byte offset into a word
@@ -415,7 +434,8 @@ static int scc_init(void);
 static void scc_cleanup(void);
 
 /* Forward defines of internal functions */
-static irqreturn_t scc_irq(int irq, void *dev_id);
+OS_DEV_ISR(scc_irq);
+/*static irqreturn_t scc_irq(int irq, void *dev_id);*/
 /** Perform callbacks registered by #scc_monitor_security_failure().
  *
  *  Make sure callbacks only happen once...  Since there may be some reason why
@@ -425,12 +445,9 @@ static irqreturn_t scc_irq(int irq, void *dev_id);
  *  One at a time, go through #scc_callbacks[] and call any non-null pointers.
  */
 static void scc_perform_callbacks(void);
-static uint32_t copy_to_scc(const uint8_t* from, uint32_t to,
-                            unsigned long count_bytes, uint16_t* crc);
-static uint32_t copy_from_scc(const uint32_t from, uint8_t* to,
-                              unsigned long count_bytes, uint16_t* crc);
-static scc_return_t scc_strip_padding(uint8_t* from,
-                                      unsigned* count_bytes_stripped);
+/*static uint32_t copy_to_scc(const uint8_t* from, uint32_t to, unsigned long count_bytes, uint16_t* crc);
+static uint32_t copy_from_scc(const uint32_t from, uint8_t* to,unsigned long count_bytes, uint16_t* crc);
+static scc_return_t scc_strip_padding(uint8_t* from,unsigned* count_bytes_stripped);*/
 static uint32_t scc_update_state(void);
 static void scc_init_ccitt_crc(void);
 static uint32_t scc_grab_config_values(void);
@@ -447,9 +464,7 @@ static int setup_interrupt_handling(void);
  * @param[in]     add_crc         Flag for computing CRC - 0 no, else yes
  * @param[in,out] count_out_bytes Number of bytes available at @c data_out
  */
-static scc_return_t scc_encrypt(uint32_t count_in_bytes, uint8_t* data_in,
-                                uint32_t scm_control, uint8_t* data_out,
-                                int add_crc, unsigned long* count_out_bytes);
+/*static scc_return_t scc_encrypt(uint32_t count_in_bytes, uint8_t* data_in, uint32_t scm_control, uint8_t* data_out,int add_crc, unsigned long* count_out_bytes);*/
 /**
  * Perform a decryption on the input.  If @c verify_crc is true, the last block
  * (maybe the two last blocks) is special - it should contain a CRC and
@@ -463,17 +478,17 @@ static scc_return_t scc_encrypt(uint32_t count_in_bytes, uint8_t* data_in,
  * @param[in,out] count_out_bytes Number of bytes available at @c data_out
 
  */
-static scc_return_t scc_decrypt(uint32_t count_in_bytes, uint8_t* data_in,
-                                uint32_t scm_control, uint8_t* data_out,
-                                int verify_crc,
-                                unsigned long* count_out_bytes);
+/*static scc_return_t scc_decrypt(uint32_t count_in_bytes, uint8_t* data_in, uint32_t scm_control, uint8_t* data_out, int verify_crc, unsigned long* count_out_bytes);*/
+static uint32_t host_owns_partition(uint32_t part_no);
+static uint32_t partition_engaged(uint32_t part_no);
+
 static scc_return_t scc_wait_completion(uint32_t* scm_status);
 static int is_cipher_done(uint32_t* scm_status);
 static scc_return_t check_register_accessible (uint32_t offset,
                                                uint32_t smn_status,
                                                uint32_t scm_status);
 static scc_return_t check_register_offset(uint32_t offset);
-uint8_t make_vpu_partition(void);
+/*uint8_t make_vpu_partition(void);*/
 
 #ifdef SCC_REGISTER_DEBUG
 static uint32_t dbg_scc_read_register(uint32_t offset);
@@ -484,19 +499,19 @@ static void dbg_scc_write_register(uint32_t offset, uint32_t value);
 /* For Linux kernel, export the API functions to other kernel modules */
 EXPORT_SYMBOL(scc_get_configuration);
 EXPORT_SYMBOL(scc_zeroize_memories);
-EXPORT_SYMBOL(scc_crypt);
+/*EXPORT_SYMBOL(scc_crypt);*/
 EXPORT_SYMBOL(scc_set_sw_alarm);
 EXPORT_SYMBOL(scc_monitor_security_failure);
 EXPORT_SYMBOL(scc_stop_monitoring_security_failure);
 EXPORT_SYMBOL(scc_read_register);
 EXPORT_SYMBOL(scc_write_register);
-EXPORT_SYMBOL(scc_alloc_slot);
-EXPORT_SYMBOL(scc_dealloc_slot);
-EXPORT_SYMBOL(scc_load_slot);
-EXPORT_SYMBOL(scc_encrypt_slot);
-EXPORT_SYMBOL(scc_decrypt_slot);
-EXPORT_SYMBOL(scc_get_slot_info);
-EXPORT_SYMBOL(make_vpu_partition);
+EXPORT_SYMBOL(scc_allocate_partition);
+EXPORT_SYMBOL(scc_engage_partition);
+EXPORT_SYMBOL(scc_release_partition);
+EXPORT_SYMBOL(scc_diminish_permissions);
+EXPORT_SYMBOL(scc_encrypt_region);
+EXPORT_SYMBOL(scc_decrypt_region);
+/*EXPORT_SYMBOL(make_vpu_partition);*/
 /* Tell Linux where to invoke driver at boot/module load time */
 module_init(scc_init);
 /* Tell Linux where to invoke driver on module unload  */
diff --git a/include/asm-arm/arch-mxc/mx37.h b/include/asm-arm/arch-mxc/mx37.h
index 98243cf..4b7908a 100644
--- a/include/asm-arm/arch-mxc/mx37.h
+++ b/include/asm-arm/arch-mxc/mx37.h
@@ -70,31 +70,51 @@
 #define IRAM_BASE_ADDR_VIRT	0xF8000000
 #define IRAM_SIZE			(9*SZ_8K)	/* 72KB */
 
-#ifndef CONFIG_SDMA_IRAM
+#if defined(CONFIG_MXC_SECURITY_SCC2) \
+	|| defined(CONFIG_MXC_SECURITY_SCC2_MODULE)
+#define SCC_IRAM_SIZE  SZ_16K
+#else
+#define SCC_IRAM_SIZE  0
+#endif
+
+/*#ifndef CONFIG_SDMA_IRAM
 #define CONFIG_SDMA_IRAM_SIZE 0
+#endif*/
+#ifdef CONFIG_SDMA_IRAM
+#define SDMA_IRAM_SIZE  CONFIG_SDMA_IRAM_SIZE
+#else
+#define SDMA_IRAM_SIZE  0
 #endif
+
 #ifdef CONFIG_SND_MXC_SOC_IRAM
 #define SND_RAM_SIZE 0x6000
 #else
 #define SND_RAM_SIZE 0
 #endif
 
-#define SND_RAM_BASE_ADDR	(IRAM_BASE_ADDR + CONFIG_SDMA_IRAM_SIZE)
-
-#define USB_IRAM_BASE_ADDR	(SND_RAM_BASE_ADDR + SND_RAM_SIZE)
 #ifdef CONFIG_USB_STATIC_IRAM
-#define USB_IRAM_SIZE	(2*SZ_8K)
+#define USB_IRAM_SIZE	SZ_8K
 #else
 #define USB_IRAM_SIZE 0
 #endif
 
-#define VPU_IRAM_BASE_ADDR	(USB_IRAM_BASE_ADDR + USB_IRAM_SIZE)
+#if (IRAM_SIZE < (SCC_IRAM_SIZE + SDMA_IRAM_SIZE + SND_RAM_SIZE + \
+	USB_IRAM_SIZE))
+#error "IRAM size exceeded"
+#endif
+
 #ifdef CONFIG_MXC_VPU_IRAM
 #define VPU_IRAM_SIZE	(IRAM_BASE_ADDR + IRAM_SIZE - VPU_IRAM_BASE_ADDR)
 #else
 #define VPU_IRAM_SIZE 0
 #endif
 
+#define SCC_IRAM_BASE_ADDR (IRAM_BASE_ADDR + IRAM_SIZE - SCC_IRAM_SIZE)
+#define SDMA_RAM_BASE_ADDR (IRAM_BASE_ADDR)
+#define SND_RAM_BASE_ADDR	(IRAM_BASE_ADDR + SDMA_IRAM_SIZE)
+#define USB_IRAM_BASE_ADDR	(SND_RAM_BASE_ADDR + SND_RAM_SIZE)
+#define VPU_IRAM_BASE_ADDR	(USB_IRAM_BASE_ADDR + USB_IRAM_SIZE)
+
 /*
  * NFC
  */
@@ -379,7 +399,7 @@
 #define MXC_INT_IPU_SYN		11
 #define MXC_INT_RESV12		12
 #define MXC_INT_RESV13		13
-#define MXC_INT_RNGC		14
+#define MXC_INT_RNG			14
 #define MXC_INT_EMI		15
 #define MXC_INT_RESV16		16
 #define MXC_INT_RESV17		17
diff --git a/include/asm-arm/arch-mxc/mxc_scc.h b/include/asm-arm/arch-mxc/mxc_scc.h
index 12108dd..4d2f4a4 100644
--- a/include/asm-arm/arch-mxc/mxc_scc.h
+++ b/include/asm-arm/arch-mxc/mxc_scc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -34,12 +34,12 @@
 /*!
  *  This must be the interrupt line number of the SCM interrupt.
  */
-#define INT_SCM         MXC_INT_SCC_SCM
+#define INT_SCC_SCM         MXC_INT_SCC_SCM
 
 /*!
  *  if #USE_SMN_INTERRUPT is defined, this must be the interrupt line number of
  *  the SMN interrupt.
  */
-#define INT_SMN         MXC_INT_SCC_SMN
+#define INT_SCC_SMN         MXC_INT_SCC_SMN
 
 #endif
diff --git a/include/asm-arm/arch-mxc/mxc_scc2_driver.h b/include/asm-arm/arch-mxc/mxc_scc2_driver.h
index 8898176..355d329 100644
--- a/include/asm-arm/arch-mxc/mxc_scc2_driver.h
+++ b/include/asm-arm/arch-mxc/mxc_scc2_driver.h
@@ -97,15 +97,15 @@ extern "C" {
 
 /* Temporarily define compile-time flags to make Doxygen happy. */
 #ifdef DOXYGEN_HACK
-/*! @defgroup scccompileflags SCC Driver compile-time flags
+/** @defgroup scccompileflags SCC Driver compile-time flags
  *
  * These preprocessor flags should be set, if desired, in a makefile so
  * that they show up on the compiler command line.
  */
-/*! @addtogroup scccompileflags */
+/** @addtogroup scccompileflags */
 
-/*! @{ */
-/*!
+/** @{ */
+/**
  * Compile-time flag to change @ref smnregs and @ref scmregs
  * offset values for the SCC's implementation on the MX.21 board.
  *
@@ -114,315 +114,287 @@ extern "C" {
  * register offsets.
  */
 #define TAHITI
-/*! @} */
+/** @} */
 #undef TAHITI
 
 #endif				/* DOXYGEN_HACK */
 
-/*! Major Version of the driver.  Used for
+/** Major Version of the driver.  Used for
     scc_configuration->driver_major_version */
-#define SCC_DRIVER_MAJOR_VERSION_1 1
-/*! Old Minor Version of the driver. */
-#define SCC_DRIVER_MINOR_VERSION_0 0
-/*! Old Minor Version of the driver. */
-#define SCC_DRIVER_MINOR_VERSION_4 4
-/*! Old Minor Version of the driver. */
-#define SCC_DRIVER_MINOR_VERSION_5 5
-/*! Minor Version of the driver.  Used for
+#define SCC_DRIVER_MAJOR_VERSION    2
+/** Minor Version of the driver.  Used for
     scc_configuration->driver_minor_version */
-#define SCC_DRIVER_MINOR_VERSION_97 97
+#define SCC_DRIVER_MINOR_VERSION    0
 
 /*!
- * @typedef scc_return_t (enum scc_return)
- */
-/*! Common status return values from SCC driver functions. */
-	typedef enum scc_return {
-		SCC_RET_OK = 0,	/*!< Function succeeded  */
-		SCC_RET_FAIL,	/*!< Non-specific failure */
-		SCC_RET_VERIFICATION_FAILED,	/*!< Decrypt validation failed */
-		SCC_RET_TOO_MANY_FUNCTIONS,	/*!< At maximum registered functions */
-		SCC_RET_BUSY,	/*!< SCC is busy and cannot handle request */
-		SCC_RET_INSUFFICIENT_SPACE,	/*!< Encryption or decryption failed because
-						   @c count_out_bytes says that @c data_out is
-						   too small to hold the value. */
-	} scc_return_t;
+ *  Interrupt line number of SCM interrupt.
+ */
+#define INT_SCC_SCM         MXC_INT_SCC_SCM
 
 /*!
- * @typedef scc_config_t (struct scc_config)
- **/
-/*!
- * @brief Configuration information about SCC and the driver.
+ *  Interrupt line number of the SMN interrupt.
+ */
+#define INT_SCC_SMN         MXC_INT_SCC_SMN
+
+/**
+ * @typedef scc_return_t
+ */
+/** Common status return values from SCC driver functions. */
+	typedef enum scc_return_t {
+		SCC_RET_OK = 0,	 /**< Function succeeded  */
+		SCC_RET_FAIL,	 /**< Non-specific failure */
+		SCC_RET_VERIFICATION_FAILED,
+				 /**< Decrypt validation failed */
+		SCC_RET_TOO_MANY_FUNCTIONS,
+				 /**< At maximum registered functions */
+		SCC_RET_BUSY,	 /**< SCC is busy and cannot handle request */
+		/**< Encryption or decryption failed because@c count_out_bytes
+			says that @c data_out is too small to hold the value. */
+		SCC_RET_INSUFFICIENT_SPACE,
+	} scc_return_t;
+
+/**
+ * @typedef scc_partition_status_t
+ */
+/** Partition status information. */
+	typedef enum scc_partition_status_t {
+		SCC_PART_S_UNUSABLE,
+				  /**< Partition not implemented */
+		SCC_PART_S_UNAVAILABLE,
+				  /**< Partition owned by other host */
+		SCC_PART_S_AVAILABLE,
+				  /**< Partition available */
+		SCC_PART_S_ALLOCATED,
+				  /**< Partition owned by host but not engaged*/
+		SCC_PART_S_ENGAGED,
+				  /**< Partition owned by host and engaged */
+	} scc_partition_status_t;
+
+/**
+ * Configuration information about SCC and the driver.
  *
  * This struct/typedef contains information from the SCC and the driver to
  * allow the user of the driver to determine the size of the SCC's memories and
  * the version of the SCC and the driver.
  */
-	typedef struct scc_config {
-		int driver_major_version;	/*!< Major version of the SCC driver code  */
-		int driver_minor_version;	/*!< Minor version of the SCC driver code  */
-		int scm_version;	/*!< Version from SCM Configuration register */
-		int smn_version;	/*!< Version from SMN Status register */
-		int block_size_bytes;	/*!< Number of bytes per block of RAM; also
-					   block size of the crypto algorithm. */
+	typedef struct scc_config_t {
+		int driver_major_version;
+				/**< Major version of the SCC driver code  */
+		int driver_minor_version;
+				/**< Minor version of the SCC driver code  */
+		int scm_version; /**< Version from SCM Configuration register */
+		int smn_version; /**< Version from SMN Status register */
+		/**< Number of bytes per block of RAM; also
+			block size of the crypto algorithm. */
+		int block_size_bytes;
 		int partition_size_bytes;
+				/**< Number of bytes in each partition */
 		int partition_count;
+				/**< Number of partitions on this platform */
 	} scc_config_t;
 
-/*!
- * @typedef scc_enc_dec_t (enum scc_enc_dec)
+/**
+ * @typedef scc_enc_dec_t
  */
-/*!
+/**
  * Determine whether SCC will run its cryptographic
- * function as an encryption or decryption.  Used as an argument to
- * #scc_crypt().
+ * function as an encryption or decryption.
  */
-	typedef enum scc_enc_dec {
-		SCC_ENCRYPT,	/*!< Encrypt (from Red to Black) */
-		SCC_DECRYPT	/*!< Decrypt (from Black to Red) */
+	typedef enum scc_enc_dec_t {
+		SCC_ENCRYPT,	/**< Encrypt (from Red to Black) */
+		SCC_DECRYPT	/**< Decrypt (from Black to Red) */
 	} scc_enc_dec_t;
 
-/*
- * @typedef scc_crypto_mode_t (enum scc_crypto_mode)
- */
-/*!
- * Determine whether SCC will run its cryptographic function in ECB (electronic
- * codebook) or CBC (cipher-block chaining) mode.  Used as an argument to
- * #scc_crypt().
- */
-	typedef enum scc_crypto_mode {
-		SCC_ECB_MODE,	/*!< Electronic Codebook Mode */
-		SCC_CBC_MODE	/*!< Cipher Block Chaining Mode  */
-	} scc_crypto_mode_t;
-
-/*!
- * @typedef scc_verify_t (enum scc_verify)
+/**
+ * @typedef scc_verify_t
  */
-/*!
+/**
  * Tell the driver whether it is responsible for verifying the integrity of a
  * secret.  During an encryption, using other than #SCC_VERIFY_MODE_NONE will
  * cause a check value to be generated and appended to the plaintext before
  * encryption.  During decryption, the check value will be verified after
  * decryption, and then stripped from the message.
  */
-	typedef enum scc_verify {
-		/*! No verification value added or checked.  Input plaintext data must be
-		 *  be a multiple of the blocksize (#scc_get_configuration()).  */
+	typedef enum scc_verify_t {
+    /** No verification value added or checked.  Input plaintext data must be
+     *  be a multiple of the blocksize (#scc_get_configuration()).  */
 		SCC_VERIFY_MODE_NONE,
-		/*! Driver will generate/validate a 2-byte CCITT CRC.  Input plaintext will
-		   be padded to a multiple of the blocksize, adding 3-10 bytes to the
-		   resulting output ciphertext.  Upon decryption, this padding will be
-		   stripped, and the CRC will be verified. */
+    /** Driver will generate/validate a 2-byte CCITT CRC.  Input plaintext
+    		will be padded to a multiple of the blocksize, adding 3-10 bytes
+    		to the resulting output ciphertext.  Upon decryption, this padding
+    		will be stripped, and the CRC will be verified. */
 		SCC_VERIFY_MODE_CCITT_CRC
 	} scc_verify_t;
 
-/*!
- * Retrieve configuration information from the SCC.
+/**
+ * @typedef scc_cypher_mode_t
+ */
+/**
+ * Select the cypher mode to use for partition cover/uncover operations.
+ */
+
+	typedef enum scc_cypher_mode_t {
+		SCC_CYPHER_MODE_ECB = 1,
+				   /**< ECB mode */
+		SCC_CYPHER_MODE_CBC = 2,
+				   /**< CBC mode */
+	} scc_cypher_mode_t;
+
+/**
+ * Allocate a partition of secure memory
  *
- * This function always succeeds.
+ * @param       smid_value  Value to use for the SMID register.  Must be 0 for
+ *                          kernel mode ownership.
+ * @param[out]  part_no     (If successful) Assigned partition number.
+ * @param[out]  part_base   Kernel virtual address of the partition.
+ * @param[out]  part_phys   Physical address of the partition.
  *
- * @return   A pointer to the configuration information.  This is a pointer to
- *           static memory and must not be freed.  The values never change, and
- *           the return value will never be null.
+ * @return      SCC_RET_OK if successful.
  */
-	extern scc_config_t *scc_get_configuration(void);
+	extern scc_return_t
+	    scc_allocate_partition(uint32_t smid_value,
+				   int *part_no,
+				   void **part_base, uint32_t *part_phys);
 
-/*!
- * Zeroize Red and Black memories of the SCC.  This will start the Zeroizing
- * process.  The routine will return when the memories have zeroized or failed
- * to do so.  The driver will poll waiting for this to occur, so this
- * routine must not be called from interrupt level.  Some future version of
- * driver may elect instead to sleep.
- *
- * @return 0 or error if initialization fails.
+/* Note: This function has to be run in the same context (userspace or kernel
+ * mode) as the process that will be using the partition.  Because the SCC2 API
+ * is not accessible in user mode, this function is also provided as a macro in
+ * in fsl_shw.h.  Kernel-mode users that include this file are able to use this
+ * version of the function without having to include the whole SHW API.  If the
+ * macro definition was defined before we got here, un-define it so this
+ * version will be used instead.
  */
-	extern scc_return_t scc_zeroize_memories(void);
 
-/*!
- * Perform a Triple DES encryption or decryption operation.
- *
- * This routine will cause the SCM to perform an encryption or decryption with
- * its internal key.  If the SCC's #SMN_STATUS register shows that the SCC is
- * in #SMN_STATE_SECURE, then the Secret Key will be used.  If it is
- * #SMN_STATE_NON_SECURE (or health check), then the Default Key will be used.
- *
- * This function will perform in a variety of ways, depending upon the values
- * of @c direction, @c crypto_mode, and @c check_mode.  If
- * #SCC_VERIFY_MODE_CCITT_CRC mode is requested, upon successful completion,
- * the @c count_in_bytes will be different from the returned value of @c
- * count_out_bytes.  This is because the two-byte CRC and some amount of
- * padding (at least one byte) will either be added or stripped.
- *
- * This function will not return until the SCC has performed the operation (or
- * reported failure to do so).  It must therefore not be called from interrupt
- * level.  In the current version, it will poll the SCC for completion.  In
- * future versions, it may sleep.
- *
- * @param[in]    count_in_bytes The number of bytes to move through the crypto
- *                            function.  Must be greater than zero.
- *
- * @param[in]    data_in      Pointer to the array of bytes to be used as input
- *                            to the crypto function.
- *
- * @param[in]    init_vector  Pointer to the block-sized (8 byte) array of
- *                            bytes which form the initialization vector for
- *                            this operation.  A non-null value is required
- *                            when @c crypto_mode has the value #SCC_CBC_MODE;
- *                            the value is ignored in #SCC_ECB_MODE.
- *
- * @param[in]    direction    Direct the driver to perform encryption or
- *                            decryption.
- *
- * @param[in]    crypto_mode  Run the crypto function in ECB or CBC mode.
- *
- * @param[in]    check_mode   During encryption, generate and append a check
- *                            value to the plaintext and pad the resulting
- *                            data.  During decryption, validate the plaintext
- *                            with that check value and remove the padding.
- *
- * @param[in,out] count_out_bytes On input, the number of bytes available for
- *                            copying to @c data_out.  On return, the number of
- *                            bytes copied to @c data_out.
- *
- * @param[out] data_out       Pointer to the array of bytes that are where the
- *                            output of the crypto function are to be placed.
- *                            For encryption, this must be able to hold a
- *                            longer ciphertext than the plaintext message at
- *                            @c data_in.  The driver will append a 'pad' of
- *                            1-8 bytes to the message, and if @c check_mode is
- *                            used, additional bytes may be added, the number
- *                            depending upon the type of check being requested.
- *
- * @return     0 on success, non-zero on failure.  See #scc_return_t.
+#ifdef scc_engage_partition
+#undef scc_engage_partition
+#endif
+
+/**
+ * Engage partition of secure memory
  *
- * @internal
- * This function will verify SCC state and the functions parameters.  It will
- * acquire the crypto lock, and set up some SCC registers and variables common
- * to encryption and decryption.  A rough check will be made to verify that
- * enough space is available in @c count_out_bytes.  Upon success, either the
- * #scc_encrypt or #scc_decrypt routine will be called to do the actual work.
- * The crypto lock will then be released.
- */
-	extern scc_return_t scc_crypt(unsigned long count_in_bytes,
-				      uint8_t * data_in, uint8_t * init_vector,
-				      scc_enc_dec_t direction,
-				      scc_crypto_mode_t crypto_mode,
-				      scc_verify_t check_mode,
-				      uint8_t * data_out,
-				      unsigned long *count_out_bytes);
+ * @param part_base (kernel) Virtual
+ * @param UMID NULL, or 16-byte UMID for partition security
+ * @param permissions ORed values of the type SCM_PERM_* which will be used as
+ *                    initial partition permissions.  SHW API users should use
+ *                    the FSL_PERM_* definitions instead.
+ *
+ * @return SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_engage_partition(void *part_base,
+				 const uint8_t *UMID, uint32_t permissions);
 
-/*!
- * Allocate a key slot for a stored key (or other stored value).
+/**
+ * Release a partition of secure memory
  *
- * This feature is to allow decrypted secret values to be kept in RED RAM.
- * This can all visibility of the data only by Sahara.
+ * @param   part_base   Kernel virtual address of the partition to be released.
  *
- * @param   value_size_bytes  Size, in bytes, of RED key/value.  Currently only
- *                            a size up to 32 bytes is supported.
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t scc_release_partition(void *part_base);
+
+/**
+ * Diminish the permissions on a partition of secure memory
  *
- * @param      owner_id       A value which will control access to the slot.
- *                            It must be passed into to any subsequent calls to
- *                            use the assigned slot.
+ * @param part_base   Kernel virtual address of the partition.
  *
- * @param[out] slot           The slot number for the key.
+ * @param permissions ORed values of the type SCM_PERM_* which will be used as
+ *                    initial partition permissions.  SHW API users should use
+ *                    the FSL_PERM_* definitions instead.
  *
- * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ * @return  SCC_RET_OK if successful.
  */
-	extern scc_return_t scc_alloc_slot(uint32_t value_size_bytes,
-					   uint64_t owner_id, uint32_t * slot);
+	extern scc_return_t
+	    scc_diminish_permissions(void *part_base, uint32_t permissions);
 
-/*!
- * Deallocate the key slot of a stored key or secret value.
+/**
+ * Query the status of a partition of secure memory
  *
- * @param      owner_id       The id which owns the @c slot.
+ * @param part_base   Kernel virtual address of the partition.
  *
- * @param      slot           The slot number for the key.
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_partition_status_t scc_partition_status(void *part_base);
 
- * @return     0 on success, non-zero on failure.  See #scc_return_t.
+/**
+ * Calculate the physical address from the kernel virtual address.
  */
-	extern scc_return_t scc_dealloc_slot(uint64_t owner_id, uint32_t slot);
+	extern uint32_t scc_virt_to_phys(void *address);
 
-/*!
- * Load a value into a slot.
+/**
+ * Encrypt a region of secure memory.
  *
- * @param owner_id      Value of owner of slot
- * @param slot          Handle of slot
- * @param key_data      Data to load into the slot
- * @param key_length    Length, in bytes, of @c key_data to copy to SCC.
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to the plaintext
+ *                       data.
+ * @param   byte_count   Length of the region (octets).
+ * @param   black_data   Physical location to store the encrypted data.
+ * @param   IV           Value to use for the Initialization Vector.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
  *
- * @return SCC_RET_OK on success.  SCC_RET_FAIL will be returned if slot
- * specified cannot be accessed for any reason, or SCC_RET_INSUFFICIENT_SPACE
- * if @c key_length exceeds the size of the slot.
+ * @return  SCC_RET_OK if successful.
  */
-	extern scc_return_t scc_load_slot(uint64_t owner_id, uint32_t slot,
-					  uint8_t * key_data,
-					  uint32_t key_length);
+	extern scc_return_t
+	    scc_encrypt_region(uint32_t part_base, uint32_t offset_bytes,
+			       uint32_t byte_count, uint8_t *black_data,
+			       uint32_t *IV, scc_cypher_mode_t cypher_mode);
 
-/*!
- * Allocate a key slot to fit the requested size.
+/**
+ * Decrypt a region into secure memory
  *
- * @param owner_id      Value of owner of slot
- * @param slot          Handle of slot
- * @param length        Length, in bytes, of @c black_data
- * @param black_data    Location to store result of encrypting RED data in slot
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to store the
+ *                       plaintext data.
+ * @param   byte_count   Length of the region (octets).
+ * @param   black_data   Physical location of the encrypted data.
+ * @param   IV           Value to use for the Initialization Vector.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
  *
- * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
- *         accessed for any reason.
+ * @return  SCC_RET_OK if successful.
  */
-	extern scc_return_t scc_encrypt_slot(uint64_t owner_id, uint32_t slot,
-					     uint32_t length,
-					     uint8_t * black_data);
+	extern scc_return_t
+	    scc_decrypt_region(uint32_t part_base, uint32_t offset_bytes,
+			       uint32_t byte_count, uint8_t *black_data,
+			       uint32_t *IV, scc_cypher_mode_t cypher_mode);
 
-/*!
- * Decrypt some black data and leave result in the slot.
+/**
+ * Retrieve configuration information from the SCC.
  *
- * @param owner_id      Value of owner of slot
- * @param slot          Handle of slot
- * @param length        Length, in bytes, of @c black_data
- * @param black_data    Location of data to dencrypt and store in slot
+ * This function always succeeds.
  *
- * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
- *         accessed for any reason.
+ * @return   A pointer to the configuration information.  This is a pointer to
+ *           static memory and must not be freed.  The values never change, and
+ *           the return value will never be null.
  */
-	extern scc_return_t scc_decrypt_slot(uint64_t owner_id, uint32_t slot,
-					     uint32_t length,
-					     const uint8_t * black_data);
+	extern scc_config_t *scc_get_configuration(void);
 
-/*!
- * Get attributes of data in RED slot.
- *
- * @param      owner_id         The id which owns the @c slot.
- *
- * @param      slot             The slot number for the key.
- *
- * @param[out] address          Physical address of RED value.
- *
- * @param[out] value_size_bytes Length, in bytes, of RED value,
- *                              or NULL if unneeded..
- *
- * @param[out] slot_size_bytes  Length, in bytes, of slot size,
- *                              or NULL if unneeded..
+/**
+ * Zeroize Red and Black memories of the SCC.  This will start the Zeroizing
+ * process.  The routine will return when the memories have zeroized or failed
+ * to do so.  The driver will poll waiting for this to occur, so this
+ * routine must not be called from interrupt level.  Some future version of
+ * driver may elect instead to sleep.
  *
- * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ * @return 0 or error if initialization fails.
  */
-	extern scc_return_t scc_get_slot_info(uint64_t owner_id, uint32_t slot,
-					      uint32_t * address,
-					      uint32_t * value_size_bytes,
-					      uint32_t * slot_size_bytes);
+	extern scc_return_t scc_zeroize_memories(void);
 
-/*!
+/**
  * Signal a software alarm to the SCC.  This will take the SCC and other PISA
  * parts out of Secure mode and into Security Failure mode.  The SCC will stay
  * in failed mode until a reboot.
  *
  * @internal
  * If the SCC is not already in fail state, simply write the
- * #SMN_COMMAND_SET_SOFTWARE_ALARM bit in #SMN_COMMAND.  Since there is no
+ * #SMN_COMMAND_SET_SOFTWARE_ALARM bit in #SMN_COMMAND_REG.  Since there is no
  * reason to wait for the interrupt to bounce back, simply act as though
  * one did.
  */
 	extern void scc_set_sw_alarm(void);
 
-/*!
+/**
  * This routine will register a function to be called should a Security Failure
  * be signalled by the SCC (Security Monitor).
  *
@@ -445,7 +417,7 @@ extern "C" {
 	extern scc_return_t scc_monitor_security_failure(void
 							 callback_func(void));
 
-/*!
+/**
  * This routine will deregister a function previously registered with
  * #scc_monitor_security_failure().
  *
@@ -455,7 +427,7 @@ extern "C" {
 	extern void scc_stop_monitoring_security_failure(void
 							 callback_func(void));
 
-/*!
+/**
  * Read value from an SCC register.
  * The offset will be checked for validity (range) as well as whether it is
  * accessible (e.g. not busy, not in failed state) at the time of the call.
@@ -475,10 +447,7 @@ extern "C" {
 	extern scc_return_t scc_read_register(int register_offset,
 					      uint32_t * value);
 
-/* Make Partition for VPU in Secure RAM */
-	extern uint8_t make_vpu_partition(void);
-
-/*!
+/**
  * Write a new value into an SCC register.
  * The offset will be checked for validity (range) as well as whether it is
  * accessible (e.g. not busy, not in failed state) at the time of the call.
@@ -497,459 +466,510 @@ extern "C" {
 	extern scc_return_t scc_write_register(int register_offset,
 					       uint32_t value);
 
-/*!
- * @name SCM Registers
- * These are the names of the SCM Registers
+/**
+ * @defgroup scmregs SCM Registers
+ *
+ * These values are offsets into the SCC for the Secure Memory
+ * (SCM) registers.  They are used in the @c register_offset parameter of
+ * #scc_read_register() and #scc_write_register().
  */
-/*! @{ */
-/*! Offset of SCM Version ID Register */
+/** @addtogroup scmregs */
+/** @{ */
+/** Offset of SCM Version ID Register */
 #define SCM_VERSION_REG		0x000
-/*! Offset of SCM Interrupt Control Register */
+/** Offset of SCM Interrupt Control Register */
 #define SCM_INT_CTL_REG		0x008
-/*! Offset of SCM Status Register */
+/** Offset of SCM Status Register */
 #define SCM_STATUS_REG		0x00c
-/*! Offset of SCM Error Status Register */
+/** Offset of SCM Error Status Register */
 #define SCM_ERR_STATUS_REG	0x010
-/*! Offset of SCM Fault Address Register */
+/** Offset of SCM Fault Address Register */
 #define SCM_FAULT_ADR_REG	0x014
-/*! Offset of SCM Partition Owners Register */
+/** Offset of SCM Partition Owners Register */
 #define SCM_PART_OWNERS_REG	0x018
-/*! Offset of SCM Partitions Engaged Register */
+/** Offset of SCM Partitions Engaged Register */
 #define SCM_PART_ENGAGED_REG	0x01c
-/*! Offset of SCM Unique Number 0 Register */
+/** Offset of SCM Unique Number 0 Register */
 #define SCM_UNIQUE_ID0_REG	0x020
-/*! Offset of SCM Unique Number 1 Register */
+/** Offset of SCM Unique Number 1 Register */
 #define SCM_UNIQUE_ID1_REG	0x024
-/*! Offset of SCM Unique Number 2 Register */
+/** Offset of SCM Unique Number 2 Register */
 #define SCM_UNIQUE_ID2_REG	0x028
-/*! Offset of SCM Unique Number 3 Register */
+/** Offset of SCM Unique Number 3 Register */
 #define SCM_UNIQUE_ID3_REG	0x02c
-/*! Offset of SCM Zeroize Command Register */
+/** Offset of SCM Zeroize Command Register */
 #define SCM_ZCMD_REG		0x050
-/*! Offset of SCM Cipher Command Register */
+/** Offset of SCM Cipher Command Register */
 #define SCM_CCMD_REG		0x054
-/*! Offset of SCM Cipher Black RAM Start Address Register */
+/** Offset of SCM Cipher Black RAM Start Address Register */
 #define SCM_C_BLACK_ST_REG	0x058
-/*! Offset of SCM Internal Debug Register */
+/** Offset of SCM Internal Debug Register */
 #define SCM_DBG_STATUS_REG	0x05c
-/*! Offset of SCM Cipher IV 0 Register */
+/** Offset of SCM Cipher IV 0 Register */
 #define SCM_AES_CBC_IV0_REG	0x060
-/*! Offset of SCM Cipher IV 1 Register */
+/** Offset of SCM Cipher IV 1 Register */
 #define SCM_AES_CBC_IV1_REG	0x064
-/*! Offset of SCM Cipher IV 2 Register */
+/** Offset of SCM Cipher IV 2 Register */
 #define SCM_AES_CBC_IV2_REG	0x068
-/*! Offset of SCM Cipher IV 3 Register */
+/** Offset of SCM Cipher IV 3 Register */
 #define SCM_AES_CBC_IV3_REG	0x06c
-/*! Offset of SCM SMID Partition 0 Register */
+/** Offset of SCM SMID Partition 0 Register */
 #define SCM_SMID0_REG		0x080
-/*! Offset of SCM Partition 0 Access Permissions Register */
+/** Offset of SCM Partition 0 Access Permissions Register */
 #define SCM_ACC0_REG		0x084
-/*! Offset of SCM SMID Partition 1 Register */
+/** Offset of SCM SMID Partition 1 Register */
 #define SCM_SMID1_REG		0x088
-/*! Offset of SCM Partition 1 Access Permissions Register */
+/** Offset of SCM Partition 1 Access Permissions Register */
 #define SCM_ACC1_REG		0x08c
-/*! Offset of SCM SMID Partition 2 Register */
+/** Offset of SCM SMID Partition 2 Register */
 #define SCM_SMID2_REG		0x090
-/*! Offset of SCM Partition 2 Access Permissions Register */
+/** Offset of SCM Partition 2 Access Permissions Register */
 #define SCM_ACC2_REG		0x094
-/*! Offset of SCM SMID Partition 3 Register */
+/** Offset of SCM SMID Partition 3 Register */
 #define SCM_SMID3_REG		0x098
-/*! Offset of SCM Partition 3 Access Permissions Register */
+/** Offset of SCM Partition 3 Access Permissions Register */
 #define SCM_ACC3_REG		0x09c
-/*! Offset of SCM SMID Partition 4 Register */
+/** Offset of SCM SMID Partition 4 Register */
 #define SCM_SMID4_REG		0x0a0
-/*! Offset of SCM Partition 4 Access Permissions Register */
+/** Offset of SCM Partition 4 Access Permissions Register */
 #define SCM_ACC4_REG		0x0a4
-/*! Offset of SCM SMID Partition 5 Register */
+/** Offset of SCM SMID Partition 5 Register */
 #define SCM_SMID5_REG		0x0a8
-/*! Offset of SCM Partition 5 Access Permissions Register */
+/** Offset of SCM Partition 5 Access Permissions Register */
 #define SCM_ACC5_REG		0x0ac
-/*! Offset of SCM SMID Partition 6 Register */
+/** Offset of SCM SMID Partition 6 Register */
 #define SCM_SMID6_REG		0x0b0
-/*! Offset of SCM Partition 6 Access Permissions Register */
+/** Offset of SCM Partition 6 Access Permissions Register */
 #define SCM_ACC6_REG		0x0b4
-/*! Offset of SCM SMID Partition 7 Register */
+/** Offset of SCM SMID Partition 7 Register */
 #define SCM_SMID7_REG		0x0b8
-/*! Offset of SCM Partition 7 Access Permissions Register */
+/** Offset of SCM Partition 7 Access Permissions Register */
 #define SCM_ACC7_REG		0x0bc
-/*! Offset of SCM SMID Partition 8 Register */
+/** Offset of SCM SMID Partition 8 Register */
 #define SCM_SMID8_REG		0x0c0
-/*! Offset of SCM Partition 8 Access Permissions Register */
+/** Offset of SCM Partition 8 Access Permissions Register */
 #define SCM_ACC8_REG		0x0c4
-/*! Offset of SCM SMID Partition 9 Register */
+/** Offset of SCM SMID Partition 9 Register */
 #define SCM_SMID9_REG		0x0c8
-/*! Offset of SCM Partition 9 Access Permissions Register */
+/** Offset of SCM Partition 9 Access Permissions Register */
 #define SCM_ACC9_REG		0x0cc
-/*! Offset of SCM SMID Partition 10 Register */
+/** Offset of SCM SMID Partition 10 Register */
 #define SCM_SMID10_REG		0x0d0
-/*! Offset of SCM Partition 10 Access Permissions Register */
+/** Offset of SCM Partition 10 Access Permissions Register */
 #define SCM_ACC10_REG		0x0d4
-/*! Offset of SCM SMID Partition 11 Register */
+/** Offset of SCM SMID Partition 11 Register */
 #define SCM_SMID11_REG		0x0d8
-/*! Offset of SCM Partition 11 Access Permissions Register */
+/** Offset of SCM Partition 11 Access Permissions Register */
 #define SCM_ACC11_REG		0x0dc
-/*! Offset of SCM SMID Partition 12 Register */
+/** Offset of SCM SMID Partition 12 Register */
 #define SCM_SMID12_REG		0x0e0
-/*! Offset of SCM Partition 12 Access Permissions Register */
+/** Offset of SCM Partition 12 Access Permissions Register */
 #define SCM_ACC12_REG		0x0e4
-/*! Offset of SCM SMID Partition 13 Register */
+/** Offset of SCM SMID Partition 13 Register */
 #define SCM_SMID13_REG		0x0e8
-/*! Offset of SCM Partition 13 Access Permissions Register */
+/** Offset of SCM Partition 13 Access Permissions Register */
 #define SCM_ACC13_REG		0x0ec
-/*! Offset of SCM SMID Partition 14 Register */
+/** Offset of SCM SMID Partition 14 Register */
 #define SCM_SMID14_REG		0x0f0
-/*! Offset of SCM Partition 14 Access Permissions Register */
+/** Offset of SCM Partition 14 Access Permissions Register */
 #define SCM_ACC14_REG		0x0f4
-/*! Offset of SCM SMID Partition 15 Register */
+/** Offset of SCM SMID Partition 15 Register */
 #define SCM_SMID15_REG		0x0f8
-/*! Offset of SCM Partition 15 Access Permissions Register */
+/** Offset of SCM Partition 15 Access Permissions Register */
 #define SCM_ACC15_REG		0x0fc
-/*! @} */
+/** @} */
 
-/*! Number of bytes of register space for the SCM. */
+/** Number of bytes of register space for the SCM. */
 #define SCM_REG_BANK_SIZE	0x100
 
-/*! Number of bytes of register space for the SCM. */
+/** Number of bytes of register space for the SCM. */
 #define SCM_REG_BANK_SIZE	0x100
 
+/** Offset of the SMN registers */
 #define SMN_ADDR_OFFSET		0x100
 
-/*!
- * @name SMN Registers
- * These are the names of the SMN Registers
+/**
+ * @defgroup smnregs SMN Registers
+ *
+ * These values are offsets into the SCC for the Security Monitor
+ * (SMN) registers.  They are used in the @c register_offset parameter of the
+ * #scc_read_register() and #scc_write_register().
  */
-/*! @{ */
-/*! Offset of SMN Status Register */
+/** @addtogroup smnregs */
+/** @{ */
+/** Offset of SMN Status Register */
 #define SMN_STATUS_REG		(SMN_ADDR_OFFSET+0x00000000)
-/*! Offset of SMH Command Register */
+/** Offset of SMH Command Register */
 #define SMN_COMMAND_REG		(SMN_ADDR_OFFSET+0x00000004)
-/*! Offset of SMH Sequence Start Register */
+/** Offset of SMH Sequence Start Register */
 #define SMN_SEQ_START_REG	(SMN_ADDR_OFFSET+0x00000008)
-/*! Offset of SMH Sequence End Register */
+/** Offset of SMH Sequence End Register */
 #define SMN_SEQ_END_REG		(SMN_ADDR_OFFSET+0x0000000c)
-/*! Offset of SMH Sequence Check Register */
+/** Offset of SMH Sequence Check Register */
 #define SMN_SEQ_CHECK_REG	(SMN_ADDR_OFFSET+0x00000010)
-/*! Offset of SMH BitBank Count Register */
+/** Offset of SMH BitBank Count Register */
 #define SMN_BB_CNT_REG		(SMN_ADDR_OFFSET+0x00000014)
-/*! Offset of SMH BitBank Increment Register */
+/** Offset of SMH BitBank Increment Register */
 #define SMN_BB_INC_REG		(SMN_ADDR_OFFSET+0x00000018)
-/*! Offset of SMH BitBank Decrement Register */
+/** Offset of SMH BitBank Decrement Register */
 #define SMN_BB_DEC_REG		(SMN_ADDR_OFFSET+0x0000001c)
-/*! Offset of SMH Compare Register */
+/** Offset of SMH Compare Register */
 #define SMN_COMPARE_REG		(SMN_ADDR_OFFSET+0x00000020)
-/*! Offset of SMH Plaintext Check Register */
+/** Offset of SMH Plaintext Check Register */
 #define SMN_PT_CHK_REG		(SMN_ADDR_OFFSET+0x00000024)
-/*! Offset of SMH Ciphertext Check Register */
+/** Offset of SMH Ciphertext Check Register */
 #define SMN_CT_CHK_REG		(SMN_ADDR_OFFSET+0x00000028)
-/*! Offset of SMH Timer Initial Value Register */
+/** Offset of SMH Timer Initial Value Register */
 #define SMN_TIMER_IV_REG	(SMN_ADDR_OFFSET+0x0000002c)
-/*! Offset of SMH Timer Control Register */
+/** Offset of SMH Timer Control Register */
 #define SMN_TIMER_CTL_REG	(SMN_ADDR_OFFSET+0x00000030)
-/*! Offset of SMH Security Violation Register */
+/** Offset of SMH Security Violation Register */
 #define SMN_SEC_VIO_REG		(SMN_ADDR_OFFSET+0x00000034)
-/*! Offset of SMH Timer Register */
+/** Offset of SMH Timer Register */
 #define SMN_TIMER_REG		(SMN_ADDR_OFFSET+0x00000038)
-/*! Offset of SMH High-Assurance Control Register */
+/** Offset of SMH High-Assurance Control Register */
 #define SMN_HAC_REG		(SMN_ADDR_OFFSET+0x0000003c)
-/*! Number of bytes allocated to the SMN registers */
+/** Number of bytes allocated to the SMN registers */
 #define SMN_REG_BANK_SIZE	0x40
-/*! @} */
+/** @} */
 
-/*! Number of bytes of total register space for the SCC. */
+/** Number of bytes of total register space for the SCC. */
 #define SCC_ADDRESS_RANGE	(SMN_ADDR_OFFSET + SMN_REG_BANK_SIZE)
 
-/*!
+/**
  * @defgroup smnstatusregdefs SMN Status Register definitions (SMN_STATUS)
  */
-/*! @addtogroup smnstatusregdefs */
-/*! @{ */
-/*! SMN version id. */
+/** @addtogroup smnstatusregdefs */
+/** @{ */
+/** SMN version id. */
 #define SMN_STATUS_VERSION_ID_MASK        0xfc000000
-/*!  number of bits to shift #SMN_STATUS_VERSION_ID_MASK to get it to LSB */
+/**  number of bits to shift #SMN_STATUS_VERSION_ID_MASK to get it to LSB */
 #define SMN_STATUS_VERSION_ID_SHIFT       28
-/*! Illegal bus master access attempted. */
+/** Illegal bus master access attempted. */
 #define SMN_STATUS_ILLEGAL_MASTER         0x01000000
-/*! Scan mode entered/exited since last reset. */
+/** Scan mode entered/exited since last reset. */
 #define SMN_STATUS_SCAN_EXIT              0x00800000
-/*! Some security peripheral is initializing */
+/** Some security peripheral is initializing */
 #define SMN_STATUS_PERIP_INIT             0x00010000
-/*! Internal error detected in SMN. */
+/** Internal error detected in SMN. */
 #define SMN_STATUS_SMN_ERROR              0x00008000
-/*! SMN has an outstanding interrupt. */
+/** SMN has an outstanding interrupt. */
 #define SMN_STATUS_SMN_STATUS_IRQ         0x00004000
-/*! Software Alarm was triggered. */
+/** Software Alarm was triggered. */
 #define SMN_STATUS_SOFTWARE_ALARM         0x00002000
-/*! Timer has expired. */
+/** Timer has expired. */
 #define SMN_STATUS_TIMER_ERROR            0x00001000
-/*! Plaintext/Ciphertext compare failed. */
+/** Plaintext/Ciphertext compare failed. */
 #define SMN_STATUS_PC_ERROR               0x00000800
-/*! Bit Bank detected overflow or underflow */
+/** Bit Bank detected overflow or underflow */
 #define SMN_STATUS_BITBANK_ERROR          0x00000400
-/*! Algorithm Sequence Check failed. */
+/** Algorithm Sequence Check failed. */
 #define SMN_STATUS_ASC_ERROR              0x00000200
-/*! Security Policy Block detected error. */
+/** Security Policy Block detected error. */
 #define SMN_STATUS_SECURITY_POLICY_ERROR  0x00000100
-/*! Security Violation Active error. */
+/** Security Violation Active error. */
 #define SMN_STATUS_SEC_VIO_ACTIVE_ERROR   0x00000080
-/*! Processor booted from internal ROM. */
+/** Processor booted from internal ROM. */
 #define SMN_STATUS_INTERNAL_BOOT          0x00000020
-/*! SMN's internal state. */
+/** SMN's internal state. */
 #define SMN_STATUS_STATE_MASK             0x0000001F
-/*! Number of bits to shift #SMN_STATUS_STATE_MASK to get it to LSB. */
+/** Number of bits to shift #SMN_STATUS_STATE_MASK to get it to LSB. */
 #define SMN_STATUS_STATE_SHIFT            0
-/*! @} */
+/** @} */
 
-/*!
+/**
  * @defgroup sccscmstates SMN Model Secure State Controller States (SMN_STATE_MASK)
  */
-/*! @addtogroup sccscmstates */
-/*! @{ */
-/*! This is the first state of the SMN after power-on reset  */
+/** @addtogroup sccscmstates */
+/** @{ */
+/** This is the first state of the SMN after power-on reset  */
 #define SMN_STATE_START         0x0
-/*! The SMN is zeroizing its RAM during reset */
+/** The SMN is zeroizing its RAM during reset */
 #define SMN_STATE_ZEROIZE_RAM   0x5
-/*! SMN has passed internal checks, and is waiting for Software check-in */
+/** SMN has passed internal checks, and is waiting for Software check-in */
 #define SMN_STATE_HEALTH_CHECK  0x6
-/*! Fatal Security Violation.  SMN is locked, SCM is inoperative. */
+/** Fatal Security Violation.  SMN is locked, SCM is inoperative. */
 #define SMN_STATE_FAIL          0x9
-/*! SCC is in secure state.  SCM is using secret key. */
+/** SCC is in secure state.  SCM is using secret key. */
 #define SMN_STATE_SECURE        0xA
-/*! Due to non-fatal error, device is not secure.  SCM is using default key. */
+/** Due to non-fatal error, device is not secure.  SCM is using default key. */
 #define SMN_STATE_NON_SECURE    0xC
-/*! @} */
+/** @} */
 
-/*! @{ */
-/*! SCM Status bit: Key Status is Default Key in Use */
+/** @{ */
+/** SCM Status bit: Key Status is Default Key in Use */
 #define SCM_STATUS_KST_DEFAULT_KEY	0x80000000
-/*! SCM Status bit: Key Status is (reserved) */
+/** SCM Status bit: Key Status is (reserved) */
 #define SCM_STATUS_KST_RESERVED1	0x40000000
-/*! SCM Status bit: Key status is Wrong Key */
+/** SCM Status bit: Key status is Wrong Key */
 #define SCM_STATUS_KST_WRONG_KEY	0x20000000
-/*! SCM Status bit: Bad Key detected */
+/** SCM Status bit: Bad Key detected */
 #define SCM_STATUS_KST_BAD_KEY	0x10000000
-/*! SCM Status bit: Error has occurred */
+/** SCM Status bit: Error has occurred */
 #define SCM_STATUS_ERR		0x00008000
-/*! SCM Status bit: Monitor State is Failed */
+/** SCM Status bit: Monitor State is Failed */
 #define SCM_STATUS_MSS_FAIL	0x00004000
-/*! SCM Status bit: Monitor State is Secure */
+/** SCM Status bit: Monitor State is Secure */
 #define SCM_STATUS_MSS_SEC	0x00002000
-/*! SCM Status bit: Secure Storage is Failed */
+/** SCM Status bit: Secure Storage is Failed */
 #define SCM_STATUS_RSS_FAIL	0x00000400
-/*! SCM Status bit: Secure Storage is Secure */
+/** SCM Status bit: Secure Storage is Secure */
 #define SCM_STATUS_RSS_SEC	0x00000200
-/*! SCM Status bit: Secure Storage is Initializing */
+/** SCM Status bit: Secure Storage is Initializing */
 #define SCM_STATUS_RSS_INIT	0x00000100
-/*! SCM Status bit: Unique Number Valid */
+/** SCM Status bit: Unique Number Valid */
 #define SCM_STATUS_UNV		0x00000080
-/*! SCM Status bit: ?? */
+/** SCM Status bit: Big Endian mode */
 #define SCM_STATUS_BIG		0x00000040
-/*! SCM Status bit: Using Secret Key */
+/** SCM Status bit: Using Secret Key */
 #define SCM_STATUS_USK		0x00000020
-/*!  */
+/** SCM Status bit: Ram is being blocked */
 #define SCM_STATUS_BAR		0x00000010
-/*! Bit mask of SRS */
+/** Bit mask of SRS */
 #define SCM_STATUS_SRS_MASK	0x0000000F
-/*! Number of bits to shift SRS to/from MSb */
+/** Number of bits to shift SRS to/from MSb */
 #define SCM_STATUS_SRS_SHIFT	0
-/*! @} */
-
-#define SCM_STATUS_SRS_RESET	0x0
-#define SCM_STATUS_SRS_READY	0x1
-#define SCM_STATUS_SRS_ZBUSY	0x2
-#define SCM_STATUS_SRS_CBUSY	0x3
-#define SCM_STATUS_SRS_ABUSY	0x4
-#define SCM_STATUS_SRS_ZDONE	0x5
-#define SCM_STATUS_SRS_CDONE	0x6
-#define SCM_STATUS_SRS_ZDONE2	0x7
-#define SCM_STATUS_SRS_CDONE2	0x8
-#define SCM_STATUS_SRS_ADONE	0xD
-
-// Format of the SCM VERSION ID REGISTER
-#define SCM_VER_BPP_MASK	0xFF000000
-#define SCM_VER_BPP_SHIFT 24
-#define SCM_VER_BPCB_MASK	0x001F0000
-#define SCM_VER_BPCB_SHIFT 16
-#define SCM_VER_NP_MASK		0x0000F000
-#define SCM_VER_NP_SHIFT 12
-#define SCM_VER_MAJ_MASK	0x00000F00
-#define SCM_VER_MAJ_SHIFT 8
-#define SCM_VER_MIN_MASK	0x000000FF
-#define SCM_VER_MIN_SHIFT	0
-
+/** @} */
+
+#define SCM_STATUS_SRS_RESET	0x0	/**< Reset, Zeroise All */
+#define SCM_STATUS_SRS_READY	0x1	/**< All Ready */
+#define SCM_STATUS_SRS_ZBUSY	0x2	/**< Zeroize Busy (Partition Only) */
+#define SCM_STATUS_SRS_CBUSY	0x3	/**< Cipher Busy */
+#define SCM_STATUS_SRS_ABUSY	0x4	/**< All Busy */
+#define SCM_STATUS_SRS_ZDONE	0x5	/**< Zeroize Done, Cipher Ready */
+#define SCM_STATUS_SRS_CDONE	0x6	/**< Cipher Done, Zeroize Ready */
+#define SCM_STATUS_SRS_ZDONE2	0x7	/**< Zeroize Done, Cipher Busy */
+#define SCM_STATUS_SRS_CDONE2	0x8	/**< Cipher Done, Zeroize Busy */
+#define SCM_STATUS_SRS_ADONE	0xD	/**< All Done */
+
+/* Format of the SCM VERSION ID REGISTER */
+#define SCM_VER_BPP_MASK    0xFF000000	/**< Bytes Per Partition Mask */
+#define SCM_VER_BPP_SHIFT   24		/**< Bytes Per Partition Shift */
+#define SCM_VER_BPCB_MASK   0x001F0000	/**< Bytes Per Cipher Block Mask */
+#define SCM_VER_BPCB_SHIFT  16		/**< Bytes Per Cipher Block Shift */
+#define SCM_VER_NP_MASK     0x0000F000	/**< Number of Partitions Mask */
+#define SCM_VER_NP_SHIFT    12		/**< Number of Partitions Shift */
+#define SCM_VER_MAJ_MASK    0x00000F00	/**< Major Version Mask */
+#define SCM_VER_MAJ_SHIFT   8		/**< Major Version Shift */
+#define SCM_VER_MIN_MASK    0x000000FF	/**< Minor Version Mask */
+#define SCM_VER_MIN_SHIFT   0		/**< Minor Version Shift */
+
+/**< SCC Hardware version supported by this driver */
 #define SCM_MAJOR_VERSION_2 2
 
-// Format of the SCM ERROR STATUS REGISTER
-#define SCM_ERRSTAT_MID_MASK	0x00F00000
-#define SCM_ERRSTAT_MID_SHIFT	20
-#define SCM_ERRSTAT_ILM		0x00080000
-#define SCM_ERRSTAT_SUP		0x00008000
-#define SCM_ERRSTAT_ERC_MASK	0x00000F00
-#define SCM_ERRSTAT_ERC_SHIFT	8
-#define SCM_ERRSTAT_SMS_MASK	0x000000F0
-#define SCM_ERRSTAT_SMS_SHIFT	4
-#define SCM_ERRSTAT_SRS_MASK	0x0000000F
-#define SCM_ERRSTAT_SRS_SHIFT	0
-
-#define SCM_ERCD_UNK_ADDR       0x1
-#define SCM_ERCD_UNK_CMD        0x2
-#define SCM_ERCD_READ_PERM      0x3
-#define SCM_ERCD_WRITE_PERM     0x4
-#define SCM_ERCD_DMA_ERROR      0x5
-#define SCM_ERCD_BLK_OVFL       0x6
-#define SCM_ERCD_NO_KEY         0x7
-#define SCM_ERCD_ZRZ_OVFL       0x8
-#define SCM_ERCD_CPHR_OVFL      0x9
-#define SCM_ERCD_PROC_INTR      0xA
-#define SCM_ERCD_WRNG_KEY       0xB
-#define SCM_ERCD_DEVICE_BUSY    0xC
-#define SCM_ERCD_UNALGN_ADDR    0xD
-
-// Format of the CIPHER COMMAND REGISTER
-#define SCM_CCMD_LENGTH_MASK	0xFFF00000
-#define SCM_CCMD_LENGTH_SHIFT	20
-#define SCM_CCMD_OFFSET_MASK	0x000FFF00
-#define SCM_CCMD_OFFSET_SHIFT	8
-#define SCM_CCMD_PART_MASK	0x000000F0
-#define SCM_CCMD_PART_SHIFT	4
-#define SCM_CCMD_CCMD_MASK	0x0000000F
-#define SCM_CCMD_CCMD_SHIFT	0
-
-// Values for SCM_CCMD_CCMD field
-#define SCM_CCMD_AES_DEC_ECB 1
-#define SCM_CCMD_AES_ENC_ECB 3
-#define SCM_CCMD_AES_DEC_CBC 5
-#define SCM_CCMD_AES_ENC_CBC 7
-
-#define SCM_CCMD_AES     1
-#define SCM_CCMD_DEC     0
-#define SCM_CCMD_ENC     2
-#define SCM_CCMD_ECB     0
-#define SCM_CCMD_CBC     4
-
-// Format of the ZEROIZE COMMAND REGISTER
-#define SCM_ZCMD_PART_MASK	0x000000F0
-#define SCM_ZCMD_PART_SHIFT	4
-#define SCM_ZCMD_CCMD_MASK	0x0000000F
-#define SCM_ZCMD_CCMD_SHIFT	0
+/* Format of the SCM ERROR STATUS REGISTER */
+#define SCM_ERRSTAT_MID_MASK    0x00F00000  /**< Master ID Mask */
+#define SCM_ERRSTAT_MID_SHIFT   20	    /**< Master ID Shift */
+#define SCM_ERRSTAT_ILM         0x00080000  /**< Illegal Master */
+#define SCM_ERRSTAT_SUP         0x00008000  /**< Supervisor Access */
+#define SCM_ERRSTAT_ERC_MASK    0x00000F00  /**< Error Code Mask */
+#define SCM_ERRSTAT_ERC_SHIFT   8	    /**< Error Code Shift */
+#define SCM_ERRSTAT_SMS_MASK    0x000000F0  /**< Secure Monitor State Mask */
+#define SCM_ERRSTAT_SMS_SHIFT   4	    /**< Secure Monitor State Shift */
+#define SCM_ERRSTAT_SRS_MASK    0x0000000F  /**< Secure Ram State Mask */
+#define SCM_ERRSTAT_SRS_SHIFT   0	    /**< Secure Ram State Shift */
+
+/* SCM ERROR STATUS REGISTER ERROR CODES */
+#define SCM_ERCD_UNK_ADDR       0x1 /**< Unknown Address */
+#define SCM_ERCD_UNK_CMD        0x2 /**< Unknown Command */
+#define SCM_ERCD_READ_PERM      0x3 /**< Read Permission Error */
+#define SCM_ERCD_WRITE_PERM     0x4 /**< Write Permission Error */
+#define SCM_ERCD_DMA_ERROR      0x5 /**< DMA Error */
+#define SCM_ERCD_BLK_OVFL       0x6 /**< Encryption Block Length Overflow */
+#define SCM_ERCD_NO_KEY         0x7 /**< Key Not Engaged */
+#define SCM_ERCD_ZRZ_OVFL       0x8 /**< Zeroize Command Queue Overflow */
+#define SCM_ERCD_CPHR_OVFL      0x9 /**< Cipher Command Queue Overflow */
+#define SCM_ERCD_PROC_INTR      0xA /**< Process Interrupted */
+#define SCM_ERCD_WRNG_KEY       0xB /**< Wrong Key */
+#define SCM_ERCD_DEVICE_BUSY    0xC /**< Device Busy */
+#define SCM_ERCD_UNALGN_ADDR    0xD /**< DMA Unaligned Address */
+
+/* Format of the CIPHER COMMAND REGISTER */
+#define SCM_CCMD_LENGTH_MASK	0xFFF00000 /**< Cipher Length Mask */
+#define SCM_CCMD_LENGTH_SHIFT	20	   /**< Cipher Length Shift */
+#define SCM_CCMD_OFFSET_MASK	0x000FFF00 /**< Block Offset Mask */
+#define SCM_CCMD_OFFSET_SHIFT	8	   /**< Block Offset Shift */
+#define SCM_CCMD_PART_MASK	0x000000F0     /**< Partition Number Mask */
+#define SCM_CCMD_PART_SHIFT	4	       /**< Partition Number Shift */
+#define SCM_CCMD_CCMD_MASK	0x0000000F     /**< Cipher Command Mask */
+#define SCM_CCMD_CCMD_SHIFT	0	       /**< Cipher Command Shift */
+
+/* Values for SCM_CCMD_CCMD field */
+#define SCM_CCMD_AES_DEC_ECB 1 /**< Decrypt without Chaining (ECB) */
+#define SCM_CCMD_AES_ENC_ECB 3 /**< Encrypt without Chaining (ECB) */
+#define SCM_CCMD_AES_DEC_CBC 5 /**< Decrypt with Chaining (CBC) */
+#define SCM_CCMD_AES_ENC_CBC 7 /**< Encrypt with Chaining (CBC) */
+
+#define SCM_CCMD_AES     1     /**< Use AES Mode */
+#define SCM_CCMD_DEC     0     /**< Decrypt */
+#define SCM_CCMD_ENC     2     /**< Encrypt */
+#define SCM_CCMD_ECB     0     /**< Perform operation without chaining (ECB) */
+#define SCM_CCMD_CBC     4     /**< Perform operation with chaining (CBC) */
+
+/* Format of the ZEROIZE COMMAND REGISTER */
+#define SCM_ZCMD_PART_MASK	0x000000F0  /**< Target Partition Mask */
+#define SCM_ZCMD_PART_SHIFT	4	    /**< Target Partition Shift */
+#define SCM_ZCMD_CCMD_MASK	0x0000000F  /**< Zeroize Command Mask */
+#define SCM_ZCMD_CCMD_SHIFT	0	    /**< Zeroize Command Shift */
 
 /* MASTER ACCESS PERMISSIONS REGISTER */
-/*! SCM Access Permission: Do not zeroize/deallocate partition on SMN Fail state */
-#define SCM_PERM_NO_ZEROIZE	0x80000000
-/*! SCM Access Permission: Ignore Supervisor/User mode in permission determination */
+/* Note that API users should use the FSL_PERM_ defines instead of these */
+/** SCM Access Permission: Do not zeroize/deallocate partition
+	on SMN Fail state */
+#define SCM_PERM_NO_ZEROIZE	0x10000000
+/** SCM Access Permission: Ignore Supervisor/User mode
+	in permission determination */
 #define SCM_PERM_HD_SUP_DISABLE	0x00000800
-/*! SCM Access Permission: Allow Read Access to  Host Domain */
+/** SCM Access Permission: Allow Read Access to  Host Domain */
 #define SCM_PERM_HD_READ	0x00000400
-/*! SCM Access Permission: Allow Write Access to  Host Domain */
+/** SCM Access Permission: Allow Write Access to  Host Domain */
 #define SCM_PERM_HD_WRITE	0x00000200
-/*! SCM Access Permission: Allow Execute Access to  Host Domain */
+/** SCM Access Permission: Allow Execute Access to  Host Domain */
 #define SCM_PERM_HD_EXECUTE	0x00000100
-/*! SCM Access Permission: Allow Read Access to Trusted Host Domain */
+/** SCM Access Permission: Allow Read Access to Trusted Host Domain */
 #define SCM_PERM_TH_READ	0x00000040
-/*! SCM Access Permission: Allow Write Access to Trusted Host Domain */
+/** SCM Access Permission: Allow Write Access to Trusted Host Domain */
 #define SCM_PERM_TH_WRITE	0x00000020
-/*! SCM Access Permission: Allow Read Access to Other/World Domain */
+/** SCM Access Permission: Allow Read Access to Other/World Domain */
 #define SCM_PERM_OT_READ	0x00000004
-/*! SCM Access Permission: Allow Write Access to Other/World Domain */
+/** SCM Access Permission: Allow Write Access to Other/World Domain */
 #define SCM_PERM_OT_WRITE	0x00000002
-/*! SCM Access Permission: Allow Execute Access to Other/World Domain */
+/** SCM Access Permission: Allow Execute Access to Other/World Domain */
 #define SCM_PERM_OT_EXECUTE	0x00000001
-
-// Zeroize
-#define ZCMD_DEALLOC_PART 3	///< Deallocate Partition
-
-#define Z_INT_EN	0x00000002	///< Zero Interrupt Enable
-
-/*!
- * @defgroup smncommandregdefs SMN Command Register Definitions (SMN_COMMAND)
- */
-/*! @addtogroup smncommandregdefs */
-/*! @{ */
-#define SMN_COMMAND_ZEROS_MASK   0xfffffff0	/*!< These bits are unimplemented
-						   or reserved */
-#define SMN_COMMAND_CLEAR_INTERRUPT     0x8	/*!< Clear SMN Interrupt */
-#define SMN_COMMAND_CLEAR_BIT_BANK      0x4	/*!< Clear SMN Bit Bank */
-#define SMN_COMMAND_ENABLE_INTERRUPT    0x2	/*!< Enable SMN Interrupts */
-#define SMN_COMMAND_SET_SOFTWARE_ALARM  0x1	/*!< Set Software Alarm */
-/*! @} */
-
-/*!
+/**< Valid bits that can be set in the Permissions register */
+#define SCM_PERM_MASK 0xC0000F67
+
+/* Zeroize Command register definitions */
+#define ZCMD_DEALLOC_PART 3	 /**< Deallocate Partition */
+#define Z_INT_EN	0x00000002   /**< Zero Interrupt Enable */
+
+/**
+ * @defgroup scmpartitionownersregdefs SCM Partition Owners Register
+ */
+/** @addtogroup scmpartitionownersregdefs */
+/** @{ */
+/** Number of bits to shift partition number to get to its field. */
+#define SCM_POWN_SHIFT   2
+/** Mask for a field once the register has been shifted. */
+#define SCM_POWN_MASK    3
+/** Partition is free */
+#define SCM_POWN_PART_FREE       0
+/** Partition is unable to be allocated */
+#define SCM_POWN_PART_UNUSABLE   1
+/** Partition is owned by another master */
+#define SCM_POWN_PART_OTHER      2
+/** Partition is owned by this master */
+#define SCM_POWN_PART_OWNED      3
+/** @} */
+
+/**
+ * @defgroup smnpartitionsengagedregdefs SCM Partitions Engaged Register
+ */
+/** @addtogroup smnpartitionsengagedregdefs */
+/** @{ */
+/** Number of bits to shift partition number to get to its field. */
+#define SCM_PENG_SHIFT   1
+/** Engaged value for a field once the register has been shifted. */
+#define SCM_PENG_ENGAGED    1
+/** @} */
+
+/** Number of bytes between each subsequent SMID register */
+#define SCM_SMID_WIDTH      8
+
+/**
+ * @defgroup smncommandregdefs SMN Command Register Definitions (SMN_COMMAND_REG)
+ */
+/** @addtogroup smncommandregdefs */
+/** @{ */
+
+/** These bits are unimplemented or reserved */
+#define SMN_COMMAND_ZEROS_MASK   0xfffffff0
+#define SMN_COMMAND_CLEAR_INTERRUPT     0x8 /**< Clear SMN Interrupt */
+#define SMN_COMMAND_CLEAR_BIT_BANK      0x4 /**< Clear SMN Bit Bank */
+#define SMN_COMMAND_ENABLE_INTERRUPT    0x2 /**< Enable SMN Interrupts */
+#define SMN_COMMAND_SET_SOFTWARE_ALARM  0x1 /**< Set Software Alarm */
+/** @} */
+
+/**
  * @defgroup smntimercontroldefs SMN Timer Control Register definitions (SMN_TIMER_CONTROL)
  */
-/*! @addtogroup smntimercontroldefs */
-/*! @{ */
-/*! These bits are reserved or zero */
+/** @addtogroup smntimercontroldefs */
+/** @{ */
+/** These bits are reserved or zero */
 #define SMN_TIMER_CTRL_ZEROS_MASK 0xfffffffc
-/*! Load the timer from #SMN_TIMER_IV */
+/** Load the timer from #SMN_TIMER_IV_REG */
 #define SMN_TIMER_LOAD_TIMER             0x2
-/*! Setting to zero stops the Timer */
+/** Setting to zero stops the Timer */
 #define SMN_TIMER_STOP_MASK              0x1
-/*! Setting this value starts the timer */
+/** Setting this value starts the timer */
 #define SMN_TIMER_START_TIMER            0x1
-/*! @} */
+/** @} */
 
-/*!
+/**
  * @defgroup scmchainmodedefs SCM_CHAINING_MODE_MASK - Bit definitions
  */
-/*! @addtogroup scmchainmodedefs */
-/*! @{ */
-#define SCM_CBC_MODE            0x2	/*!< Cipher block chaining */
-#define SCM_ECB_MODE            0x0	/*!< Electronic codebook. */
-/*! @} */
+/** @addtogroup scmchainmodedefs */
+/** @{ */
+#define SCM_CBC_MODE            0x2 /**< Cipher block chaining */
+#define SCM_ECB_MODE            0x0 /**< Electronic codebook. */
+/** @} */
 
 /* Bit definitions in the SCM_CIPHER_MODE_MASK */
-/*!
+/**
  * @defgroup scmciphermodedefs SCM_CIPHER_MODE_MASK - Bit definitions
  */
-/*! @{ */
-#define SCM_DECRYPT_MODE        0x1	/*!< decrypt from black to red memory */
-#define SCM_ENCRYPT_MODE        0x0	/*!< encrypt from red to black memory */
-/*! @} */
-/*!
+/** @addtogroup scmciphermodedefs */
+/** @{ */
+#define SCM_DECRYPT_MODE        0x1 /**< decrypt from black to red memory */
+#define SCM_ENCRYPT_MODE        0x0 /**< encrypt from red to black memory */
+/** @} */
+
+/**
  * @defgroup smndbgdetdefs SMN Debug Detector Status Register (SCM_DEBUG_DETECT_STAT)
  */
-/*! @addtogroup smndbgdetdefs */
-/*! @{ */
-#define SMN_DBG_ZEROS_MASK  0xfffff000	/*!< These bits are zero or reserved */
-#define SMN_DBG_D12             0x0800	/*!< Error detected on Debug Port D12 */
-#define SMN_DBG_D11             0x0400	/*!< Error detected on Debug Port D11 */
-#define SMN_DBG_D10             0x0200	/*!< Error detected on Debug Port D10 */
-#define SMN_DBG_D9              0x0100	/*!< Error detected on Debug Port D9 */
-#define SMN_DBG_D8              0x0080	/*!< Error detected on Debug Port D8 */
-#define SMN_DBG_D7              0x0040	/*!< Error detected on Debug Port D7 */
-#define SMN_DBG_D6              0x0020	/*!< Error detected on Debug Port D6 */
-#define SMN_DBG_D5              0x0010	/*!< Error detected on Debug Port D5 */
-#define SMN_DBG_D4              0x0008	/*!< Error detected on Debug Port D4 */
-#define SMN_DBG_D3              0x0004	/*!< Error detected on Debug Port D3 */
-#define SMN_DBG_D2              0x0002	/*!< Error detected on Debug Port D2 */
-#define SMN_DBG_D1              0x0001	/*!< Error detected on Debug Port D1 */
-/*! @} */
-
-/*! Mask for the usable bits of the Sequence Start Register
-    (#SMN_SEQUENCE_START) */
+/** @addtogroup smndbgdetdefs */
+/** @{ */
+#define SMN_DBG_ZEROS_MASK  0xfffff000 /**< These bits are zero or reserved */
+#define SMN_DBG_D12             0x0800 /**< Error detected on Debug Port D12 */
+#define SMN_DBG_D11             0x0400 /**< Error detected on Debug Port D11 */
+#define SMN_DBG_D10             0x0200 /**< Error detected on Debug Port D10 */
+#define SMN_DBG_D9              0x0100 /**< Error detected on Debug Port D9 */
+#define SMN_DBG_D8              0x0080 /**< Error detected on Debug Port D8 */
+#define SMN_DBG_D7              0x0040 /**< Error detected on Debug Port D7 */
+#define SMN_DBG_D6              0x0020 /**< Error detected on Debug Port D6 */
+#define SMN_DBG_D5              0x0010 /**< Error detected on Debug Port D5 */
+#define SMN_DBG_D4              0x0008 /**< Error detected on Debug Port D4 */
+#define SMN_DBG_D3              0x0004 /**< Error detected on Debug Port D3 */
+#define SMN_DBG_D2              0x0002 /**< Error detected on Debug Port D2 */
+#define SMN_DBG_D1              0x0001 /**< Error detected on Debug Port D1 */
+/** @} */
+
+/** Mask for the usable bits of the Sequence Start Register
+    (#SMN_SEQ_START_REG) */
 #define SMN_SEQUENCE_START_MASK    0x0000ffff
 
-/*! Mask for the usable bits of the Sequence End Register
-    (#SMN_SEQUENCE_END) */
+/** Mask for the usable bits of the Sequence End Register
+    (#SMN_SEQ_END_REG) */
 #define SMN_SEQUENCE_END_MASK      0x0000ffff
 
-/*! Mask for the usable bits of the Sequence Check Register
-    (#SMN_SEQUENCE_CHECK) */
+/** Mask for the usable bits of the Sequence Check Register
+    (#SMN_SEQ_CHECK_REG) */
 #define SMN_SEQUENCE_CHECK_MASK    0x0000ffff
 
-/*! Mask for the usable bits of the Bit Counter Register
-    (#SMN_BIT_COUNT) */
+/** Mask for the usable bits of the Bit Counter Register
+    (#SMN_BB_CNT_REG) */
 #define SMN_BIT_COUNT_MASK         0x000007ff
 
-/*! Mask for the usable bits of the Bit Bank Increment Size Register
-    (#SMN_BITBANK_INC_SIZE) */
+/** Mask for the usable bits of the Bit Bank Increment Size Register
+    (#SMN_BB_INC_REG) */
 #define SMN_BITBANK_INC_SIZE_MASK  0x000007ff
 
-/*! Mask for the usable bits of the Bit Bank Decrement Register
-    (#SMN_BITBANK_DECREMENT) */
+/** Mask for the usable bits of the Bit Bank Decrement Register
+    (#SMN_BB_DEC_REG) */
 #define SMN_BITBANK_DECREMENT_MASK 0x000007ff
 
-/*! Mask for the usable bits of the Compare Size Register
-    (#SMN_COMPARE_SIZE) */
+/** Mask for the usable bits of the Compare Size Register
+    (#SMN_COMPARE_REG) */
 #define SMN_COMPARE_SIZE_MASK      0x0000003f
 
 /* Close out marker for C++ compilers */
diff --git a/include/asm-arm/arch-mxc/mxc_scc_driver.h b/include/asm-arm/arch-mxc/mxc_scc_driver.h
index 7ea739e..e575f52 100644
--- a/include/asm-arm/arch-mxc/mxc_scc_driver.h
+++ b/include/asm-arm/arch-mxc/mxc_scc_driver.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -111,21 +111,24 @@ extern "C" {
 #define SCC_DRIVER_MINOR_VERSION_0 0
 /*! Old Minor Version of the driver. */
 #define SCC_DRIVER_MINOR_VERSION_4 4
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_5 5
 /*! Minor Version of the driver.  Used for
     scc_configuration->driver_minor_version */
-#define SCC_DRIVER_MINOR_VERSION_5 5
+#define SCC_DRIVER_MINOR_VERSION_6 6
+
 
 /*!
  * @typedef scc_return_t (enum scc_return)
  */
 /*! Common status return values from SCC driver functions. */
-	typedef enum scc_return {
+	typedef enum scc_return_t {
 		SCC_RET_OK = 0,	/*!< Function succeeded  */
-		SCC_RET_FAIL = -1,	/*!< Non-specific failure */
-		SCC_RET_VERIFICATION_FAILED = -2,	/*!< Decrypt validation failed */
-		SCC_RET_TOO_MANY_FUNCTIONS = -3,	/*!< At maximum registered functions */
-		SCC_RET_BUSY = -4,	/*!< SCC is busy and cannot handle request */
-		SCC_RET_INSUFFICIENT_SPACE = -5,	/*!< Encryption or decryption failed because
+		SCC_RET_FAIL,	/*!< Non-specific failure */
+		SCC_RET_VERIFICATION_FAILED,	/*!< Decrypt validation failed */
+		SCC_RET_TOO_MANY_FUNCTIONS,	/*!< At maximum registered functions */
+		SCC_RET_BUSY,	/*!< SCC is busy and cannot handle request */
+		SCC_RET_INSUFFICIENT_SPACE,	/*!< Encryption or decryption failed because
 							   @c count_out_bytes says that @c data_out is
 							   too small to hold the value. */
 	} scc_return_t;
@@ -140,7 +143,7 @@ extern "C" {
  * allow the user of the driver to determine the size of the SCC's memories and
  * the version of the SCC and the driver.
  */
-	typedef struct scc_config {
+	typedef struct scc_config_t {
 		int driver_major_version;	/*!< Major version of the SCC driver code  */
 		int driver_minor_version;	/*!< Minor version of the SCC driver code  */
 		int scm_version;	/*!< Version from SCM Configuration register */
@@ -159,7 +162,7 @@ extern "C" {
  * function as an encryption or decryption.  Used as an argument to
  * #scc_crypt().
  */
-	typedef enum scc_enc_dec {
+	typedef enum scc_enc_dec_t {
 		SCC_ENCRYPT,	/*!< Encrypt (from Red to Black) */
 		SCC_DECRYPT	/*!< Decrypt (from Black to Red) */
 	} scc_enc_dec_t;
@@ -172,7 +175,7 @@ extern "C" {
  * codebook) or CBC (cipher-block chaining) mode.  Used as an argument to
  * #scc_crypt().
  */
-	typedef enum scc_crypto_mode {
+	typedef enum scc_crypto_mode_t {
 		SCC_ECB_MODE,	/*!< Electronic Codebook Mode */
 		SCC_CBC_MODE	/*!< Cipher Block Chaining Mode  */
 	} scc_crypto_mode_t;
@@ -187,7 +190,7 @@ extern "C" {
  * encryption.  During decryption, the check value will be verified after
  * decryption, and then stripped from the message.
  */
-	typedef enum scc_verify {
+	typedef enum scc_verify_t {
 		/*! No verification value added or checked.  Input plaintext data must be
 		 *  be a multiple of the blocksize (#scc_get_configuration()).  */
 		SCC_VERIFY_MODE_NONE,
@@ -199,6 +202,19 @@ extern "C" {
 	} scc_verify_t;
 
 /*!
+ * Determine if the given credentials match that of the key slot.
+ *
+ * @param[in]  owner_id     A value which will control access to the slot.
+ * @param[in]  slot         Key Slot to query
+ * @param[in]  access_len   Length of the key
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	 scc_return_t
+	    scc_verify_slot_access(uint64_t owner_id, uint32_t slot,
+				   uint32_t access_len);
+
+/*!
  * Retrieve configuration information from the SCC.
  *
  * This function always succeeds.
@@ -444,7 +460,8 @@ extern "C" {
  * accessible (e.g. not busy, not in failed state) at the time of the call.
  *
  * @param[in]   register_offset  The (byte) offset within the SCC block
- *                               of the register to be queried.
+ *                               of the register to be queried. See
+ *                              @ref scmregs and @ref smnregs.
  * @param[out]  value            Pointer to where value from the register
  *                               should be placed.
  * @return      0 if OK, non-zero on error.  See #scc_return_t.
@@ -468,7 +485,8 @@ extern "C" {
  * accessible (e.g. not busy, not in failed state) at the time of the call.
  *
  * @param[in]  register_offset  The (byte) offset within the SCC block
- *                              of the register to be modified.
+ *                              of the register to be modified. See
+ *                              @ref scmregs and @ref smnregs.
  * @param[in]  value            The value to store into the register.
  * @return     0 if OK, non-zero on error.  See #scc_return_t.
  *
@@ -485,17 +503,18 @@ extern "C" {
  *
  * All of the doxygen comments for the register offset values are in this the
  * following comment section.  Any changes to register names or definitions
- * must be reflected in this section and other versions of the memory map.
- *
+ * must be reflected in this section and in both the TAHITI and non-TAHITI
+ *version of the memory map.
  */
 
 /*!
- * @name SCM Registers
+ * @defgroup scmregs SCM Registers
  *
  * These values are offsets into the SCC for the Secure Memory
  * (SCM) registers.  They are used in the @c register_offset parameter of
  * #scc_read_register() and #scc_write_register().
  */
+/*! @addtogroup scmregs */
 /*! @{ */
 /*! @def SCM_RED_START
  * Starting block offset in red memory for cipher function. */
@@ -508,28 +527,28 @@ extern "C" {
 
 /*! @def SCM_CONTROL
  * SCM Control register.
- * See "SCM Control Register definitions" for details.
+ * See @ref scmcontrolregdefs "SCM Control Register definitions" for details.
  */
 
 /*! @def SCM_STATUS
  * SCM Status register.
- * See "SCM Status Register Definitions" for details.
+ * See @ref scmstatusregdefs "SCM Status Register Definitions" for details.
  */
 
 /*! @def SCM_ERROR_STATUS
  * SCM Error Status Register.
- * See "SCM Error Status Register definitions" for
+ * See @ref scmerrstatdefs "SCM Error Status Register definitions" for
  * details. */
 
 /*! @def SCM_INTERRUPT_CTRL
  * SCM Interrupt Control Register.
- * See "SCM Interrupt Control Register definitions"
+ * See @ref scminterruptcontroldefs "SCM Interrupt Control Register definitions"
  * for details.
  */
 
 /*! @def SCM_CONFIGURATION
  * SCM Configuration Register.
- * See "SCM Configuration Register Definitions" for
+ * See @ref scmconfigdefs "SCM Configuration Register Definitions" for
  * details.
  */
 
@@ -548,22 +567,23 @@ extern "C" {
 	/*! @} *//* end of SCM group */
 
 /*!
- * @name SMN Registers
+ * @defgroup smnregs SMN Registers
  *
  * These values are offsets into the SCC for the Security Monitor
  * (SMN) registers.  They are used in the @c register_offset parameter of the
  * #scc_read_register() and #scc_write_register().
  */
+/*! @addtogroup smnregs */
 /*! @{ */
 /*! @def SMN_STATUS
  * Status register for SMN.
- * See "SMN Status Register definitions" for further
+ * See @ref smnstatusregdefs "SMN Status Register definitions" for further
  * information.
  */
 
 /** @def SMN_COMMAND
  * Command register for SMN. See
- * "Command Register Definitions" for further
+ * @ref smncommandregdefs "Command Register Definitions" for further
  * information.
  */
 
@@ -609,12 +629,12 @@ extern "C" {
 
 /*! @def SMN_TIMER_CONTROL
  * Timer Control register.
- * See "SMN Timer Control Register definitions".
+ * See @ref smntimercontroldefs "SMN Timer Control Register definitions".
  */
 
 /*! @def SMN_DEBUG_DETECT_STAT
  * Debug Detector Status Register
- * See "SMN Debug Detector Status Register"for definitions.
+ * See @ref smndbgdetdefs "SMN Debug Detector Status Register"for definitions.
  */
 
 /*! @def SMN_TIMER
@@ -663,7 +683,7 @@ extern "C" {
 #define SCC_ADDRESS_RANGE    0x103c
 
 /*!
- * @name SMN Status Register definitions (SMN_STATUS)
+ * @defgroup smnstatusregdefs SMN Status Register definitions (SMN_STATUS)
  */
 /*! @{ */
 /*! SMN version id. */
@@ -719,8 +739,9 @@ extern "C" {
 /*! @} */
 
 /*!
- * @name SMN Model Secure State Controller States (SMN_STATE_MASK)
+ * @defgroup sccscmstates SMN Model Secure State Controller States (SMN_STATE_MASK)
  */
+/*! @addtogroup sccscmstates */
 /*! @{ */
 /*! This is the first state of the SMN after power-on reset  */
 #define SMN_STATE_START         0x0
@@ -737,8 +758,9 @@ extern "C" {
 /*! @} */
 
 /*!
- * @name SCM Configuration Register definitions (SCM_CONFIGURATION)
+ * @defgroup scmconfigdefs SCM Configuration Register definitions (SCM_CONFIGURATION)
  **/
+/*! @addtogroup scmconfigdefs */
 /*! @{ */
 /*! Version number of the Secure Memory. */
 #define SCM_CFG_VERSION_ID_MASK         0xf8000000
@@ -761,8 +783,9 @@ extern "C" {
 /*! @} */
 
 /*!
- * @name SMN Command Register Definitions (SMN_COMMAND)
+ * @defgroup smncommandregdefs SMN Command Register Definitions (SMN_COMMAND)
  */
+/*! @addtogroup smncommandregdefs */
 /*! @{ */
 #define SMN_COMMAND_ZEROS_MASK   0xfffffff0	/*!< These bits are unimplemented
 						   or reserved */
@@ -773,8 +796,9 @@ extern "C" {
 /*! @} */
 
 /*!
- * @name SMN Timer Control Register definitions (SMN_TIMER_CONTROL)
+ * @defgroup smntimercontroldefs SMN Timer Control Register definitions (SMN_TIMER_CONTROL)
  */
+/*! @addtogroup smntimercontroldefs */
 /*! @{ */
 /*! These bits are reserved or zero */
 #define SMN_TIMER_CTRL_ZEROS_MASK 0xfffffffc
@@ -787,7 +811,7 @@ extern "C" {
 /*! @} */
 
 /*!
- * @name SCM Interrupt Control Register definitions (SCM_INTERRUPT_CTRL)
+ * @defgroup scminterruptcontroldefs SCM Interrupt Control Register definitions (SCM_INTERRUPT_CTRL)
  *
  * These are the bit definitions for the #SCM_INTERRUPT_CTRL register.
  */
-- 
1.5.4.4

