From a68131687c7a2033332cbc729a2b36eb0c313a26 Mon Sep 17 00:00:00 2001
From: Bruce Schmid <duck@freescale.com>
Date: Mon, 7 Jul 2008 15:11:09 -0600
Subject: [PATCH] ENGR00083330-8 Integrate Devtech's USB code patch 8/12

USB: mx35 platform_device registration

Signed-off-by: Bruce Schmid <duck@freescale.com>
---
 arch/arm/mach-mx35/Makefile |    9 +++-
 arch/arm/mach-mx35/usb.h    |  104 +++++++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-mx35/usb_dr.c |  103 ++++++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-mx35/usb_h2.c |   56 +++++++++++++++++++++++
 4 files changed, 271 insertions(+), 1 deletions(-)

diff --git a/arch/arm/mach-mx35/Makefile b/arch/arm/mach-mx35/Makefile
index 7450521..0eb7df5 100644
--- a/arch/arm/mach-mx35/Makefile
+++ b/arch/arm/mach-mx35/Makefile
@@ -4,10 +4,17 @@
 
 # Object file lists.
 
-obj-y		:= system.o iomux.o cpu.o mm.o clock.o devices.o serial.o usb.o 
+obj-y		:= system.o iomux.o cpu.o mm.o clock.o devices.o serial.o
 obj-$(CONFIG_MXC_SDMA_API) 	+= dma.o
 obj-$(CONFIG_MACH_MX35_3DS)	+= mx35_3stack.o mx35_3stack_gpio.o mx35_3stack_cpld.o dvfs.o
 obj-$(CONFIG_MACH_MX35EVB)	+= mx35evb.o mx35evb_cpld.o mx35evb_gpio.o
 
 obj-$(CONFIG_MXC_PSEUDO_IRQS)	+= mx35_3stack_irq.o
 obj-$(CONFIG_PM) 		+= pm.o
+
+obj-$(CONFIG_USB_EHCI_ARC_H2)	+= usb_h2.o
+
+ifneq ($(strip $(CONFIG_USB_GADGET_ARC) $(CONFIG_USB_EHCI_ARC_OTG)),)
+	obj-y	+= usb_dr.o
+endif
+
diff --git a/arch/arm/mach-mx35/usb.h b/arch/arm/mach-mx35/usb.h
new file mode 100644
index 0000000..52b6f80
--- /dev/null
+++ b/arch/arm/mach-mx35/usb.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern struct platform_device *host_pdev_register(struct resource *res,
+		  int n_res, struct fsl_usb2_platform_data *config);
+
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbh2_active(void);
+extern void gpio_usbh2_inactive(void);
+extern int gpio_usbotg_utmi_active(void);
+extern void gpio_usbotg_utmi_inactive(void);
+
+/*
+ * Determine which platform_data struct to use for the DR controller,
+ * based on which transceiver is configured.
+ * PDATA is a pointer to it.
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config;
+#define PDATA (&dr_utmi_config)
+
+
+/*
+ * Used to set pdata->operating_mode before registering the platform_device.
+ * If OTG is configured, the controller operates in OTG mode,
+ * otherwise it's either host or device.
+ */
+#ifdef CONFIG_USB_OTG
+#define DR_UDC_MODE	FSL_USB2_DR_OTG
+#define DR_HOST_MODE	FSL_USB2_DR_OTG
+#else
+#define DR_UDC_MODE	FSL_USB2_DR_DEVICE
+#define DR_HOST_MODE	FSL_USB2_DR_HOST
+#endif
+
+
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+static inline void dr_register_host(struct resource *r, int rs)
+{
+	PDATA->operating_mode = DR_HOST_MODE;
+	host_pdev_register(r, rs, PDATA);
+}
+#else
+static inline void dr_register_host(struct resource *r, int rs)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC
+static struct platform_device dr_udc_device;
+
+static inline void dr_register_udc(void)
+{
+	PDATA->operating_mode = DR_UDC_MODE;
+	dr_udc_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_udc_device))
+		printk(KERN_ERR "usb: can't register DR gadget\n");
+	else
+		printk(KERN_INFO "usb: DR gadget (%s) registered\n",
+		       PDATA->transceiver);
+}
+#else
+static inline void dr_register_udc(void)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_OTG
+static struct platform_device dr_otg_device;
+
+/*
+ * set the proper operating_mode and
+ * platform_data pointer, then register the
+ * device.
+ */
+static inline void dr_register_otg(void)
+{
+	PDATA->operating_mode = FSL_USB2_DR_OTG;
+	dr_otg_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_otg_device))
+		printk(KERN_ERR "usb: can't register otg device\n");
+	else
+		printk(KERN_INFO "usb: DR OTG registered\n");
+}
+#else
+static inline void dr_register_otg(void)
+{
+}
+#endif
diff --git a/arch/arm/mach-mx35/usb_dr.c b/arch/arm/mach-mx35/usb_dr.c
new file mode 100644
index 0000000..a2992c0
--- /dev/null
+++ b/arch/arm/mach-mx35/usb_dr.c
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <asm/arch/arc_otg.h>
+#include "usb.h"
+
+/*
+ * platform data structs
+ * 	- Which one to use is determined by CONFIG options in usb.h
+ * 	- operating_mode plugged at run time
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init,
+	.platform_uninit   = usbotg_uninit,
+	.phy_mode          = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget      = 250, /* 250 mA max power */
+	.gpio_usb_active   = gpio_usbotg_utmi_active,
+	.gpio_usb_inactive = gpio_usbotg_utmi_inactive,
+	.transceiver       = "utmi",
+};
+
+
+/*
+ * resources
+ */
+static struct resource otg_resources[] = {
+	[0] = {
+		.start = (u32)(USB_OTGREGS_BASE),
+		.end   = (u32)(USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_USB_OTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+
+static u64 dr_udc_dmamask = ~(u32) 0;
+static void dr_udc_release(struct device *dev)
+{
+}
+
+static u64 dr_otg_dmamask = ~(u32) 0;
+static void dr_otg_release(struct device *dev)
+{
+}
+
+/*
+ * platform device structs
+ * 	dev.platform_data field plugged at run time
+ */
+static struct platform_device __maybe_unused dr_udc_device = {
+	.name = "fsl-usb2-udc",
+	.id   = -1,
+	.dev  = {
+		.release           = dr_udc_release,
+		.dma_mask          = &dr_udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+static struct platform_device __maybe_unused dr_otg_device = {
+	.name = "fsl-usb2-otg",
+	.id = -1,
+	.dev = {
+		.release           = dr_otg_release,
+		.dma_mask          = &dr_otg_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+static int __init usb_dr_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	dr_register_otg();
+	dr_register_host(otg_resources, ARRAY_SIZE(otg_resources));
+	dr_register_udc();
+
+	return 0;
+}
+
+module_init(usb_dr_init);
diff --git a/arch/arm/mach-mx35/usb_h2.c b/arch/arm/mach-mx35/usb_h2.c
new file mode 100644
index 0000000..c41785f
--- /dev/null
+++ b/arch/arm/mach-mx35/usb_h2.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <asm/arch/arc_otg.h>
+#include "usb.h"
+
+static struct fsl_usb2_platform_data usbh2_config = {
+	.name              = "Host 2",
+	.platform_init     = fsl_usb_host_init,
+	.platform_uninit   = fsl_usb_host_uninit,
+	.operating_mode    = FSL_USB2_MPH_HOST,
+	.phy_mode          = FSL_USB2_PHY_SERIAL,
+	.power_budget      = 150,		/* 150 mA max power */
+	.gpio_usb_active   = gpio_usbh2_active,
+	.gpio_usb_inactive = gpio_usbh2_inactive,
+	.transceiver       = "serial",
+};
+
+static struct resource usbh2_resources[] = {
+	[0] = {
+		.start = (u32) (USB_H2REGS_BASE),
+		.end   = (u32) (USB_H2REGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = MXC_INT_USB_HS,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+
+static int __init usbh2_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	host_pdev_register(usbh2_resources, ARRAY_SIZE(usbh2_resources),
+			   &usbh2_config);
+	return 0;
+}
+module_init(usbh2_init);
-- 
1.5.4.4

