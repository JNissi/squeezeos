From 5847fb1363d309be71846daecc03b6b27be916d9 Mon Sep 17 00:00:00 2001
From: Xinyu Chen <xinyu.chen@freescale.com>
Date: Fri, 9 May 2008 16:11:37 +0800
Subject: [PATCH] ENGR00058735 MX35 SPDIF Tx Driver

Add support for MX35 SPDIF Tx

Signed-off-by: Xinyu Chen <xinyu.chen@freescale.com>
---
 arch/arm/mach-mx35/devices.c          |   41 +
 arch/arm/mach-mx35/dma.c              |   50 ++
 arch/arm/mach-mx35/mx35_3stack_gpio.c |   34 +
 arch/arm/mach-mx37/devices.c          |    7 +-
 include/asm-arm/arch-mxc/mx35.h       |    2 +
 include/asm-arm/arch-mxc/mxc.h        |    2 +
 sound/arm/mxc-alsa-spdif.c            | 1424 +++++++++++++++++++++++++++++----
 7 files changed, 1387 insertions(+), 173 deletions(-)

diff --git a/arch/arm/mach-mx35/devices.c b/arch/arm/mach-mx35/devices.c
index 6e64864..6b7cd06 100644
--- a/arch/arm/mach-mx35/devices.c
+++ b/arch/arm/mach-mx35/devices.c
@@ -25,6 +25,8 @@
 #include "iomux.h"
 #include "sdma_script_code.h"
 
+extern void gpio_spdif_active(void);
+
 void mxc_sdma_get_script_info(sdma_script_start_addrs * sdma_script_addr)
 {
 	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
@@ -432,6 +434,44 @@ static inline void mxc_init_dma(void)
 	(void)platform_device_register(&mxc_dma_device);
 }
 
+static struct resource spdif_resources[] = {
+	{
+	 .start = SPDIF_BASE_ADDR,
+	 .end = SPDIF_BASE_ADDR + 0x50,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct mxc_spdif_platform_data mxc_spdif_data = {
+	.spdif_tx = 1,
+	.spdif_rx = 1,
+	.spdif_clk_44100 = 3,	/* spdif_ext_clk source for 44.1KHz */
+	.spdif_clk_48000 = 0,	/* audio osc source */
+	.spdif_clkid = 0,
+	.spdif_clk = NULL,
+};
+
+static struct platform_device mxc_alsa_spdif_device = {
+	.name = "mxc_alsa_spdif",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_spdif_data,
+		},
+	.num_resources = ARRAY_SIZE(spdif_resources),
+	.resource = spdif_resources,
+};
+
+static inline void mxc_init_spdif(void)
+{
+	mxc_spdif_data.spdif_clk = clk_get(NULL, "spdif_audio_clk");
+	clk_put(mxc_spdif_data.spdif_clk);
+	mxc_spdif_data.spdif_core_clk = clk_get(NULL, "spdif_clk");
+	clk_put(mxc_spdif_data.spdif_core_clk);
+	gpio_spdif_active();
+	platform_device_register(&mxc_alsa_spdif_device);
+}
+
 static int __init mxc_init_devices(void)
 {
 	mxc_init_wdt();
@@ -440,6 +480,7 @@ static int __init mxc_init_devices(void)
 	mxc_init_i2c();
 	mxc_init_rtc();
 	mxc_init_dma();
+	mxc_init_spdif();
 
 	/* SPBA configuration for SSI2 - SDMA and MCU are set */
 	spba_take_ownership(SPBA_SSI2, SPBA_MASTER_C | SPBA_MASTER_A);
diff --git a/arch/arm/mach-mx35/dma.c b/arch/arm/mach-mx35/dma.c
index 3da50db..0a850a0 100644
--- a/arch/arm/mach-mx35/dma.c
+++ b/arch/arm/mach-mx35/dma.c
@@ -17,6 +17,11 @@
 
 #include "serial.h"
 
+#define MXC_SPDIF_TXFIFO_WML      8
+#define MXC_SPDIF_RXFIFO_WML      8
+#define MXC_SPDIF_TX_REG          0x2C
+#define MXC_SPDIF_RX_REG          0x14
+
 struct mxc_sdma_info_entry_s {
 	mxc_dma_device_t device;
 	mxc_sdma_channel_params_t *chnl_info;
@@ -106,6 +111,48 @@ static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
 	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
 };
 
+static mxc_sdma_channel_params_t mxc_sdma_spdif_16bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_TXFIFO_WML,
+			.per_address = SPDIF_BASE_ADDR + MXC_SPDIF_TX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SPDIF_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SPDIF_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_spdif_32bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_TXFIFO_WML,
+			.per_address = SPDIF_BASE_ADDR + MXC_SPDIF_TX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SPDIF_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SPDIF_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_spdif_32bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_RXFIFO_WML,
+			.per_address = SPDIF_BASE_ADDR + MXC_SPDIF_RX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SPDIF_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SPDIF_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
 static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
 	.chnl_params = {
 			.peripheral_type = MEMORY,
@@ -124,6 +171,9 @@ static struct mxc_sdma_info_entry_s mxc_sdma_active_dma_info[] = {
 	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
 	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
 	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_SPDIF_16BIT_TX, &mxc_sdma_spdif_16bit_tx_params},
+	{MXC_DMA_SPDIF_32BIT_TX, &mxc_sdma_spdif_32bit_tx_params},
+	{MXC_DMA_SPDIF_32BIT_RX, &mxc_sdma_spdif_32bit_rx_params},
 	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
 };
 
diff --git a/arch/arm/mach-mx35/mx35_3stack_gpio.c b/arch/arm/mach-mx35/mx35_3stack_gpio.c
index f6fe332..522df5d 100644
--- a/arch/arm/mach-mx35/mx35_3stack_gpio.c
+++ b/arch/arm/mach-mx35/mx35_3stack_gpio.c
@@ -699,3 +699,37 @@ void gpio_sensor_inactive()
 }
 
 EXPORT_SYMBOL(gpio_sensor_inactive);
+
+/*!
+ * Setup GPIO for spdif tx/rx to be active
+ */
+void gpio_spdif_active(void)
+{
+	/* SPDIF OUT */
+	mxc_request_iomux(MX35_PIN_STXD5, MUX_CONFIG_ALT1);
+	mxc_iomux_set_pad(MX35_PIN_STXD5, PAD_CTL_PKE_NONE | PAD_CTL_PUE_PUD);
+	/* SPDIF IN */
+	mxc_request_iomux(MX35_PIN_SRXD5, MUX_CONFIG_ALT1);
+	mxc_iomux_set_pad(MX35_PIN_SRXD5, PAD_CTL_PKE_ENABLE
+			  | PAD_CTL_100K_PU | PAD_CTL_HYS_SCHMITZ);
+	mxc_iomux_set_input(MUX_IN_SPDIF_SPDIF_IN1, INPUT_CTL_PATH1);
+	/* SPDIF ext clock */
+	mxc_request_iomux(MX35_PIN_SCK5, MUX_CONFIG_ALT1);
+}
+
+EXPORT_SYMBOL(gpio_spdif_active);
+
+/*!
+ * Setup GPIO for spdif tx/rx to be inactive
+ */
+void gpio_spdif_inactive(void)
+{
+	/* SPDIF OUT */
+	mxc_free_iomux(MX35_PIN_STXD5, MUX_CONFIG_GPIO);
+	/* SPDIF IN */
+	mxc_free_iomux(MX35_PIN_SRXD5, MUX_CONFIG_GPIO);
+	/* SPDIF ext clock */
+	mxc_free_iomux(MX35_PIN_SCK5, MUX_CONFIG_GPIO);
+}
+
+EXPORT_SYMBOL(gpio_spdif_inactive);
diff --git a/arch/arm/mach-mx37/devices.c b/arch/arm/mach-mx37/devices.c
index 7561e1b..5756831 100644
--- a/arch/arm/mach-mx37/devices.c
+++ b/arch/arm/mach-mx37/devices.c
@@ -626,6 +626,7 @@ static struct mxc_spdif_platform_data mxc_spdif_data = {
 	.spdif_clk_44100 = 0,
 	.spdif_clk_48000 = 3,
 	.spdif_clk = NULL,
+	.spdif_core_clk = NULL,
 };
 
 static struct platform_device mxc_alsa_spdif_device = {
@@ -643,10 +644,10 @@ static inline void mxc_init_spdif(void)
 {
 	struct clk *ckih_clk;
 	ckih_clk = clk_get(NULL, "ckih");
-	mxc_spdif_data.spdif_clk = clk_get(NULL, "spdif_xtal_clk");
-	clk_set_parent(mxc_spdif_data.spdif_clk, ckih_clk);
+	mxc_spdif_data.spdif_core_clk = clk_get(NULL, "spdif_xtal_clk");
+	clk_set_parent(mxc_spdif_data.spdif_core_clk, ckih_clk);
 	clk_put(ckih_clk);
-	clk_put(mxc_spdif_data.spdif_clk);
+	clk_put(mxc_spdif_data.spdif_core_clk);
 	gpio_spdif_active();
 	platform_device_register(&mxc_alsa_spdif_device);
 }
diff --git a/include/asm-arm/arch-mxc/mx35.h b/include/asm-arm/arch-mxc/mx35.h
index e0c3e3d..d4283cc 100644
--- a/include/asm-arm/arch-mxc/mx35.h
+++ b/include/asm-arm/arch-mxc/mx35.h
@@ -158,6 +158,8 @@
 #define MXC_DMA_CHANNEL_ATA_RX  MXC_DMA_DYNAMIC_CHANNEL
 #define MXC_DMA_CHANNEL_ATA_TX  MXC_DMA_DYNAMIC_CHANNEL
 #define MXC_DMA_CHANNEL_MEMORY  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SPDIF_TX        MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SPDIF_RX        MXC_DMA_DYNAMIC_CHANNEL
 
 /*
  * AIPS 2
diff --git a/include/asm-arm/arch-mxc/mxc.h b/include/asm-arm/arch-mxc/mxc.h
index a97049f..9de1abe 100644
--- a/include/asm-arm/arch-mxc/mxc.h
+++ b/include/asm-arm/arch-mxc/mxc.h
@@ -92,7 +92,9 @@ struct mxc_spdif_platform_data {
 	int spdif_rx;
 	int spdif_clk_44100;
 	int spdif_clk_48000;
+	int spdif_clkid;
 	struct clk *spdif_clk;
+	struct clk *spdif_core_clk;
 };
 
 struct mxc_lcd_platform_data {
diff --git a/sound/arm/mxc-alsa-spdif.c b/sound/arm/mxc-alsa-spdif.c
index 020ec97..c2283f1 100644
--- a/sound/arm/mxc-alsa-spdif.c
+++ b/sound/arm/mxc-alsa-spdif.c
@@ -61,30 +61,102 @@
 #define SPDIF_MIN_PERIOD	2
 #define SPDIF_MAX_PERIOD	255
 
-#define SPDIF_REG_SCR   0x00
-#define SPDIF_REG_SIE   0x0C
-#define SPDIF_REG_SIS   0x10
-#define SPDIF_REG_SIC   0x10
-#define SPDIF_REG_STL   0x2C
-#define SPDIF_REG_STR   0x30
-#define SPDIF_REG_STCSCH        0x34
-#define SPDIF_REG_STCSCL        0x38
-#define SPDIF_REG_STC   0x50
+#define SPDIF_REG_SCR		0x00
+#define SPDIF_REG_SRCD		0x04
+#define SPDIF_REG_SRPC		0x08
+#define SPDIF_REG_SIE		0x0C
+#define SPDIF_REG_SIS		0x10
+#define SPDIF_REG_SIC		0x10
+#define SPDIF_REG_SRL		0x14
+#define SPDIF_REG_SRR		0x18
+#define SPDIF_REG_SRCSLH	0x1C
+#define SPDIF_REG_SRCSLL	0x20
+#define SPDIF_REG_SQU		0x24
+#define SPDIF_REG_SRQ		0x28
+#define SPDIF_REG_STL		0x2C
+#define SPDIF_REG_STR		0x30
+#define SPDIF_REG_STCSCH	0x34
+#define SPDIF_REG_STCSCL	0x38
+#define SPDIF_REG_SRFM		0x44
+#define SPDIF_REG_STC		0x50
 
 /* SPDIF Configuration register */
-#define SCR_TXFIFO_AUTOSYNC     (1 << 17)
-#define SCR_TXFIFO_ZERO         (0 << 10)
-#define SCR_TXFIFO_NORMAL       (1 << 10)
-#define SCR_TXFIFO_ONESAMPLE    (2 << 10)
-#define SCR_DMA_TX_ENABLE       (1 << 8)
-#define SCR_DMA_TX_DISABLE      (0 << 8)
-#define SCR_TXSEL_OFF           (0 << 2)
-#define SCR_TXSEL_RX            (1 << 2)
-#define SCR_TXSEL_NORMAL        (5 << 2)
-
-#define INT_TXFIFO_UNOV         (1 << 19)
-#define INT_TXFIFO_RESYNC       (1 << 18)
-#define INT_TX_EMPTY            (1 << 1)
+#define SCR_RXFIFO_CTL_ZERO	(1 << 23)
+#define SCR_RXFIFO_OFF		(1 << 22)
+#define SCR_RXFIFO_RST		(1 << 21)
+#define SCR_RXFIFO_FSEL_BIT	(19)
+#define SCR_RXFIFO_FSEL_MASK	(0x3 << SCR_RXFIFO_FSEL_BIT)
+#define SCR_RXFIFO_AUTOSYNC	(1 << 18)
+#define SCR_TXFIFO_AUTOSYNC	(1 << 17)
+#define SCR_TXFIFO_ESEL_BIT	(15)
+#define SCR_TXFIFO_ESEL_MASK	(0x3 << SCR_TXFIFO_FSEL_BIT)
+#define SCR_LOW_POWER		(1 << 13)
+#define SCR_SOFT_RESET		(1 << 12)
+#define SCR_TXFIFO_ZERO		(0 << 10)
+#define SCR_TXFIFO_NORMAL	(1 << 10)
+#define SCR_TXFIFO_ONESAMPLE	(1 << 11)
+#define SCR_DMA_RX_EN		(1 << 9)
+#define SCR_DMA_TX_EN		(1 << 8)
+#define SCR_VAL_CLEAR		(1 << 5)
+#define SCR_TXSEL_OFF		(0 << 2)
+#define SCR_TXSEL_RX		(1 << 2)
+#define SCR_TXSEL_NORMAL	(0x5 << 2)
+#define SCR_USRC_SEL_NONE	(0x0)
+#define SCR_USRC_SEL_RECV	(0x1)
+#define SCR_USRC_SEL_CHIP	(0x3)
+
+/* SPDIF CDText control */
+#define SRCD_CD_USER_OFFSET	1
+#define SRCD_CD_USER		(1 << SRCD_CD_USER_OFFSET)
+
+/* SPDIF Phase Configuration register */
+#define SRPC_DPLL_LOCKED	(1 << 6)
+#define SRPC_CLKSRC_SEL_OFFSET	7
+#define SRPC_CLKSRC_SEL_LOCKED	5
+/* gain sel */
+#define SRPC_GAINSEL_OFFSET	3
+
+enum spdif_gainsel {
+	GAINSEL_MULTI_24 = 0,
+	GAINSEL_MULTI_16,
+	GAINSEL_MULTI_12,
+	GAINSEL_MULTI_8,
+	GAINSEL_MULTI_6,
+	GAINSEL_MULTI_4,
+	GAINSEL_MULTI_3,
+	GAINSEL_MULTI_MAX,
+};
+
+#define SPDIF_DEFAULT_GAINSEL	GAINSEL_MULTI_8
+
+/* SPDIF interrupt mask define */
+#define INT_DPLL_LOCKED		(1 << 20)
+#define INT_TXFIFO_UNOV		(1 << 19)
+#define INT_TXFIFO_RESYNC	(1 << 18)
+#define INT_CNEW		(1 << 17)
+#define INT_VAL_NOGOOD		(1 << 16)
+#define INT_SYM_ERR		(1 << 15)
+#define INT_BIT_ERR		(1 << 14)
+#define INT_URX_FUL		(1 << 10)
+#define INT_URX_OV		(1 << 9)
+#define INT_QRX_FUL		(1 << 8)
+#define INT_QRX_OV		(1 << 7)
+#define INT_UQ_SYNC		(1 << 6)
+#define INT_UQ_ERR		(1 << 5)
+#define INT_RX_UNOV		(1 << 4)
+#define INT_RX_RESYNC		(1 << 3)
+#define INT_LOSS_LOCK		(1 << 2)
+#define INT_TX_EMPTY		(1 << 1)
+#define INT_RXFIFO_FUL		(1 << 0)
+
+/* SPDIF Clock register */
+#define STC_SYSCLK_DIV_OFFSET	11
+#define STC_TXCLK_SRC_OFFSET	8
+#define STC_TXCLK_DIV_OFFSET	0
+
+#define SPDIF_CSTATUS_BYTE	6
+#define SPDIF_UBITS_SIZE	96
+#define SPDIF_QSUB_SIZE		(SPDIF_UBITS_SIZE/8)
 
 enum spdif_clk_accuracy {
 	SPDIF_CLK_ACCURACY_LEV2 = 0,
@@ -93,6 +165,15 @@ enum spdif_clk_accuracy {
 	SPDIF_CLK_ACCURACY_RESV = 3
 };
 
+/* SPDIF clock source */
+enum spdif_clk_src {
+	SPDIF_CLK_SRC1 = 0,
+	SPDIF_CLK_SRC2,
+	SPDIF_CLK_SRC3,
+	SPDIF_CLK_SRC4,
+	SPDIF_CLK_SRC5,
+};
+
 enum spdif_max_wdl {
 	SPDIF_MAX_WDL_20,
 	SPDIF_MAX_WDL_24
@@ -107,22 +188,89 @@ enum spdif_wdl {
 	SPDIF_WDL_MAX = 5
 };
 
+static unsigned int gainsel_multi[GAINSEL_MULTI_MAX] = {
+	24 * 1024, 16 * 1024, 12 * 1024,
+	8 * 1024, 6 * 1024, 4 * 1024,
+	3 * 1024,
+};
+
+/*!
+ * SPDIF control structure
+ * Defines channel status, subcode and Q sub
+ */
+struct spdif_mixer_control {
+
+	/* spinlock to access control data */
+	spinlock_t ctl_lock;
+	/* IEC958 channel tx status bit */
+	unsigned char ch_status[4];
+	/* User bits */
+	unsigned char subcode[2 * SPDIF_UBITS_SIZE];
+	/* Q subcode part of user bits */
+	unsigned char qsub[2 * SPDIF_QSUB_SIZE];
+	/* buffer ptrs for writer */
+	unsigned int upos;
+	unsigned int qpos;
+	/* ready buffer index of the two buffers */
+	unsigned int ready_buf;
+};
+
+static struct spdif_mixer_control mxc_spdif_control;
+
 static unsigned long spdif_base_addr;
 
+/* define each spdif interrupt handlers */
+typedef void (*spdif_irq_func_t) (unsigned int bit, void *desc);
+
+/* spdif irq functions declare */
+static void spdif_irq_fifo(unsigned int bit, void *devid);
+static void spdif_irq_dpll_lock(unsigned int bit, void *devid);
+static void spdif_irq_uq(unsigned int bit, void *devid);
+static void spdif_irq_bit_error(unsigned int bit, void *devid);
+static void spdif_irq_sym_error(unsigned int bit, void *devid);
+static void spdif_irq_valnogood(unsigned int bit, void *devid);
+static void spdif_irq_cnew(unsigned int bit, void *devid);
+
+/* irq function list */
+static spdif_irq_func_t spdif_irq_handlers[] = {
+	spdif_irq_fifo,
+	spdif_irq_fifo,
+	spdif_irq_dpll_lock,
+	NULL,
+	spdif_irq_fifo,
+	spdif_irq_uq,
+	spdif_irq_uq,
+	spdif_irq_uq,
+	spdif_irq_uq,
+	spdif_irq_uq,
+	spdif_irq_uq,
+	NULL,
+	NULL,
+	NULL,
+	spdif_irq_bit_error,
+	spdif_irq_sym_error,
+	spdif_irq_valnogood,
+	spdif_irq_cnew,
+	NULL,
+	spdif_irq_fifo,
+	spdif_irq_dpll_lock,
+};
+
 /*!
  * @brief Enable/Disable spdif DMA request
  *
  * This function is called to enable or disable the dma transfer
  */
-static int spdif_txdma_cfg(int txdma)
+static void spdif_dma_enable(int txrx, int enable)
 {
 	unsigned long value;
 
 	value = __raw_readl(SPDIF_REG_SCR + spdif_base_addr) & 0xfffeff;
-	value |= txdma;
+	if (enable)
+		value |= txrx;
+
 	__raw_writel(value, SPDIF_REG_SCR + spdif_base_addr);
 
-	return 0;
 }
 
 /*!
@@ -130,77 +278,113 @@ static int spdif_txdma_cfg(int txdma)
  *
  * This function is called to enable relevant interrupts.
  */
-static int spdif_intr_enable(int intr)
+static void spdif_intr_enable(unsigned long intr, int enable)
 {
 	unsigned long value;
 
-	value = __raw_readl(SPDIF_REG_SIE + spdif_base_addr) & 0xffffff;
-	value |= intr;
-	__raw_writel(value, SPDIF_REG_SIE + spdif_base_addr);
+	value = __raw_readl(spdif_base_addr + SPDIF_REG_SIE) & 0xffffff;
+	if (enable)
+		value |= intr;
+	else
+		value &= ~intr;
 
-	return 0;
+	__raw_writel(value, spdif_base_addr + SPDIF_REG_SIE);
 }
 
 /*!
- * @brief Disable spdif interrupt
+ * @brief Set the clock accuracy level in the channel bit
  *
- * This function is called to diable relevant interrupts.
+ * This function is called to set the clock accuracy level
  */
-static int spdif_intr_disable(int intr)
+static int spdif_set_clk_accuracy(enum spdif_clk_accuracy level)
 {
 	unsigned long value;
 
-	value = __raw_readl(SPDIF_REG_SIE + spdif_base_addr) & 0xffffff;
-	value &= ~intr;
-	__raw_writel(value, SPDIF_REG_SIE + spdif_base_addr);
+	value = __raw_readl(SPDIF_REG_STCSCL + spdif_base_addr) & 0xffffcf;
+	value |= (level << 4);
+	__raw_writel(value, SPDIF_REG_STCSCL + spdif_base_addr);
 
 	return 0;
 }
 
 /*!
- * @brief Set the clock accuracy level in the channel bit
- *
- * This function is called to set the clock accuracy level
+ * set SPDIF PhaseConfig register for rx clock
  */
-static int spdif_set_clk_accuracy(enum spdif_clk_accuracy level)
+static int spdif_set_rx_clksrc(enum spdif_clk_src clksrc,
+			       enum spdif_gainsel gainsel, int dpll_locked)
 {
 	unsigned long value;
+	if (clksrc > SPDIF_CLK_SRC5 || gainsel > GAINSEL_MULTI_3)
+		return 1;
 
-	value = __raw_readl(SPDIF_REG_STCSCL + spdif_base_addr) & 0xffffcf;
-	value |= (level << 4);
-	__raw_writel(value, SPDIF_REG_STCSCL + spdif_base_addr);
+	value = (dpll_locked ? (clksrc) :
+		 (clksrc + SRPC_CLKSRC_SEL_LOCKED)) << SRPC_CLKSRC_SEL_OFFSET |
+	    (gainsel << SRPC_GAINSEL_OFFSET);
+	__raw_writel(value, spdif_base_addr + SPDIF_REG_SRPC);
 
 	return 0;
 }
 
 /*!
+ * Get RX data clock rate
+ * given the SPDIF bus_clk
+ */
+static int spdif_get_rxclk_rate(struct clk *bus_clk)
+{
+	unsigned long freqmeas, phaseconf, busclk_freq = 0, gainsel;
+	enum spdif_clk_src clksrc;
+
+	freqmeas = __raw_readl(spdif_base_addr + SPDIF_REG_SRFM);
+	phaseconf = __raw_readl(spdif_base_addr + SPDIF_REG_SRPC);
+
+	clksrc = (phaseconf >> SRPC_CLKSRC_SEL_OFFSET) & 0x0F;
+	if (clksrc > 4 || !(phaseconf & SRPC_DPLL_LOCKED)) {
+		/* get bus clock from system */
+		busclk_freq = clk_get_rate(bus_clk);
+	}
+
+	gainsel = (phaseconf >> SRPC_GAINSEL_OFFSET) & 0x7;
+	if (busclk_freq == 0) {
+		/* the spdif is configured bus clock as rx clock */
+		return gainsel_multi[gainsel];
+	}
+
+	/* FreqMeas_CLK = (BUS_CLK*FreqMeas[23:0])/2^10*GAINSEL */
+	return (busclk_freq * freqmeas) / gainsel_multi[gainsel];
+}
+
+/*!
  * @brief Set the audio sample rate in the channel status bit
  *
  * This function is called to set the audio sample rate to be transfered.
  */
 static int spdif_set_sample_rate(int src_44100, int src_48000, int sample_rate)
 {
-	unsigned long value;
+	unsigned long cstatus, stc;
 
-	value = __raw_readl(SPDIF_REG_STCSCL + spdif_base_addr) & 0xfffff0;
+	cstatus = __raw_readl(SPDIF_REG_STCSCL + spdif_base_addr) & 0xfffff0;
+	stc = __raw_readl(SPDIF_REG_STC + spdif_base_addr) & ~0x7FF;
 
 	switch (sample_rate) {
 	case 44100:
-		__raw_writel(value, SPDIF_REG_STCSCL + spdif_base_addr);
-		value = (src_44100 << 8) | 0x07;
-		__raw_writel(value, SPDIF_REG_STC + spdif_base_addr);
+		__raw_writel(cstatus, SPDIF_REG_STCSCL + spdif_base_addr);
+		stc |= (src_44100 << 8) | 0x07;
+		__raw_writel(stc, SPDIF_REG_STC + spdif_base_addr);
+		pr_debug("set sample rate to 44100\n");
 		break;
 	case 48000:
-		value |= 0x04;
-		__raw_writel(value, SPDIF_REG_STCSCL + spdif_base_addr);
-		value = (src_48000 << 8) | 0x07;
-		__raw_writel(value, SPDIF_REG_STC + spdif_base_addr);
+		cstatus |= 0x04;
+		__raw_writel(cstatus, SPDIF_REG_STCSCL + spdif_base_addr);
+		stc |= (src_48000 << 8) | 0x07;
+		__raw_writel(stc, SPDIF_REG_STC + spdif_base_addr);
+		pr_debug("set sample rate to 48000\n");
 		break;
 	case 32000:
-		value |= 0x0c;
-		__raw_writel(value, SPDIF_REG_STCSCL + spdif_base_addr);
-		value = (src_48000 << 8) | 0x0b;
-		__raw_writel(value, SPDIF_REG_STC + spdif_base_addr);
+		cstatus |= 0x0c;
+		__raw_writel(cstatus, SPDIF_REG_STCSCL + spdif_base_addr);
+		stc |= (src_48000 << 8) | 0x0b;
+		__raw_writel(stc, SPDIF_REG_STC + spdif_base_addr);
+		pr_debug("set sample rate to 32000\n");
 		break;
 	}
 
@@ -229,7 +413,6 @@ static int spdif_intr_status(void)
 	unsigned long value;
 
 	value = __raw_readl(SPDIF_REG_SIS + spdif_base_addr) & 0xffffff;
-
 	__raw_writel(0, SPDIF_REG_SIC + spdif_base_addr);
 
 	return value;
@@ -240,47 +423,222 @@ static int spdif_intr_status(void)
  */
 static irqreturn_t spdif_isr(int irq, void *dev_id)
 {
-	unsigned long status, value;
+	unsigned long int_stat;
+	int line;
 
-	status = spdif_intr_status();
-	value = __raw_readl(SPDIF_REG_SIE + spdif_base_addr);
+	int_stat = spdif_intr_status();
+	int_stat &= __raw_readl(spdif_base_addr + SPDIF_REG_SIE);
 
-	if ((value & (1 << 19)) && (status & 0x80000))
-		pr_info("spdif tx underrun\n");
-	else if ((value & (1 << 18)) && (status & 0x40000))
-		pr_info("spdif tx resync\n");
-	else if ((value & (1 << 1)) && (status & 0x2))
-		pr_info("spdif tx fifo empty\n");
+	while ((line = ffs(int_stat)) != 0) {
+		int_stat &= ~(1UL << (line - 1));
+		pr_info("SPDIF interrupt trigger:%d\n", line - 1);
+		if (spdif_irq_handlers[line - 1] != NULL)
+			spdif_irq_handlers[line - 1] (line - 1, dev_id);
+	}
 
 	return IRQ_HANDLED;
 }
 
 /*!
+ * Interrupt handlers
+ *
+ */
+/*!
+ * FIFO related interrupts handler
+ *
+ * Rx FIFO Full, Underrun/Overrun interrupts
+ * Tx FIFO Empty, Underrun/Overrun interrupts
+ */
+static void spdif_irq_fifo(unsigned int bit, void *devid)
+{
+
+}
+
+/*!
+ * DPLL lock related interrupts handler
+ *
+ * DPLL locked and lock loss interrupts
+ */
+static void spdif_irq_dpll_lock(unsigned int bit, void *devid)
+{
+	if (bit == INT_DPLL_LOCKED) {
+		pr_debug("SPDIF Rx dpll locked\n");
+	} else {
+		/* INT_LOSS_LOCK */
+		pr_debug("SPDIF Rx dpll loss lock\n");
+	}
+}
+
+/*!
+ * U/Q channel related interrupts handler
+ *
+ * U/QChannel full, overrun interrupts
+ * U/QChannel sync error and frame error interrupts
+ */
+static void spdif_irq_uq(unsigned int bit, void *devid)
+{
+	unsigned long val, flags;
+	int index;
+	struct spdif_mixer_control *ctrl = &mxc_spdif_control;
+
+	spin_lock_irqsave(ctrl->ctl_lock, flags);
+
+	/* get U/Q channel datas */
+	switch (bit) {
+
+	case INT_URX_OV:	/* read U data */
+		pr_debug("User bit receive overrun\n");
+	case INT_URX_FUL:
+		if (unlikely((ctrl->upos % SPDIF_UBITS_SIZE) + 3
+			     > SPDIF_UBITS_SIZE)) {
+			dev_err((struct device *)devid,
+				"User bit receivce buffer overflow\n");
+			break;
+		}
+		val = __raw_readl(spdif_base_addr + SPDIF_REG_SQU);
+		ctrl->subcode[ctrl->upos++] = val >> 16;
+		ctrl->subcode[ctrl->upos++] = val >> 8;
+		ctrl->subcode[ctrl->upos++] = val;
+		break;
+
+	case INT_QRX_OV:	/* read Q data */
+		pr_debug("Q bit receive overrun\n");
+	case INT_QRX_FUL:
+		if (unlikely((ctrl->qpos % SPDIF_QSUB_SIZE) + 3
+			     > SPDIF_QSUB_SIZE)) {
+			dev_err((struct device *)devid,
+				"Q bit receivce buffer overflow\n");
+			break;
+		}
+		val = __raw_readl(spdif_base_addr + SPDIF_REG_SRQ);
+		ctrl->qsub[ctrl->qpos++] = val >> 16;
+		ctrl->qsub[ctrl->qpos++] = val >> 8;
+		ctrl->qsub[ctrl->qpos++] = val;
+		break;
+
+	case INT_UQ_ERR:	/* read U/Q data and do buffer reset */
+		pr_debug("U/Q bit receive error\n");
+		val = __raw_readl(spdif_base_addr + SPDIF_REG_SQU);
+		val = __raw_readl(spdif_base_addr + SPDIF_REG_SRQ);
+		/* drop this U/Q buffer */
+		index = ctrl->qpos / SPDIF_QSUB_SIZE;
+		ctrl->ready_buf &= ~(1 << index);
+		ctrl->upos = index * SPDIF_UBITS_SIZE;
+		ctrl->qpos = index * SPDIF_QSUB_SIZE;
+		break;
+
+	case INT_UQ_SYNC:	/* U/Q buffer reset */
+		index = ctrl->qpos / SPDIF_QSUB_SIZE;
+		/* set ready to this buffer */
+		ctrl->ready_buf &= ~(1 << index);
+		index = index ? 0 : 1;
+		ctrl->ready_buf |= 1 << index;
+		ctrl->upos = index * SPDIF_UBITS_SIZE;
+		ctrl->qpos = index * SPDIF_QSUB_SIZE;
+		break;
+	}
+
+	spin_unlock_irqrestore(&ctrl->ctl_lock, flags);
+}
+
+/*!
+ * SPDIF receiver found parity bit error interrupt handler
+ */
+static void spdif_irq_bit_error(unsigned int bit, void *devid)
+{
+	pr_debug("SPDIF interrupt parity bit error\n");
+}
+
+/*!
+ * SPDIF receiver found illegal symbol interrupt handler
+ */
+static void spdif_irq_sym_error(unsigned int bit, void *devid)
+{
+	pr_debug("SPDIF interrupt symbol error\n");
+}
+
+/*!
+ * SPDIF validity flag no good interrupt handler
+ */
+static void spdif_irq_valnogood(unsigned int bit, void *devid)
+{
+	pr_debug("SPDIF interrupt validate is not good\n");
+}
+
+/*!
+ * SPDIF receive change in value of control channel
+ */
+static void spdif_irq_cnew(unsigned int bit, void *devid)
+{
+	/* get channel status */
+	/* FIXME: no need to fetch in ISR, user can define */
+}
+
+/*!
+ * Do software reset to SPDIF
+ */
+static void spdif_softreset(void)
+{
+	__raw_writel(SCR_SOFT_RESET, spdif_base_addr + SPDIF_REG_SCR);
+
+	/* Marly SPDIF do not have software reset, just wait */
+	udelay(10);
+}
+
+/*!
+ * SPDIF RX initial function
+ */
+static void spdif_rx_init(void)
+{
+	unsigned long regval;
+
+	regval = __raw_readl(spdif_base_addr + SPDIF_REG_SCR);
+	/**
+	 * initial and reset SPDIF configuration:
+	 * RxFIFO off
+	 * RxFIFO sel to 8 sample
+	 * Autosync
+	 * Valid bit set
+	 */
+	regval &= ~(SCR_RXFIFO_OFF | SCR_RXFIFO_CTL_ZERO | SCR_LOW_POWER);
+	regval |= (2 << SCR_RXFIFO_FSEL_BIT) | SCR_RXFIFO_AUTOSYNC;
+	__raw_writel(regval, spdif_base_addr + SPDIF_REG_SCR);
+}
+
+/*!
+ * SPDIF RX un-initial function
+ */
+static void spdif_rx_uninit(void)
+{
+	unsigned long regval;
+
+	/* turn off RX fifo, disable dma and autosync */
+	regval = __raw_readl(spdif_base_addr + SPDIF_REG_SCR);
+	regval |= SCR_RXFIFO_OFF | SCR_RXFIFO_CTL_ZERO;
+	regval &= ~(SCR_DMA_RX_EN | SCR_RXFIFO_AUTOSYNC);
+	__raw_writel(regval, spdif_base_addr + SPDIF_REG_SCR);
+}
+
+/*!
  * @brief Initialize spdif module
  *
  * This function is called to set the spdif to initial state.
  */
-static int spdif_tx_init(void)
+static void spdif_tx_init(void)
 {
-	unsigned long value;
+	unsigned long regval;
 
-	value = 0x20414;
-	__raw_writel(value, SPDIF_REG_SCR + spdif_base_addr);
+	regval = __raw_readl(spdif_base_addr + SPDIF_REG_SCR);
 
-	value = 0xc0000;
-	/*Spdif has no watermark, so the underrun interrupt can't be enabled */
-	/*__raw_writel(value, SPDIF_REG_SIE);*/
+	regval &= 0xfc32e3;
+	regval |= SCR_TXFIFO_AUTOSYNC | SCR_TXFIFO_NORMAL |
+	    SCR_TXSEL_NORMAL | SCR_USRC_SEL_CHIP | (2 << SCR_TXFIFO_ESEL_BIT);
+	__raw_writel(regval, SPDIF_REG_SCR + spdif_base_addr);
 
 	/* Default clock source from EXTAL, divider by 8, generate 44.1kHz
 	   sample rate */
-	value = 0x07;
-	__raw_writel(value, SPDIF_REG_STC + spdif_base_addr);
-
-	/* spdif intrrupt bug */
-	if (request_irq(MXC_INT_SPDIF, spdif_isr, 0, "spdif", NULL))
-		return -1;
-
-	return 0;
+	regval = 0x07;
+	__raw_writel(regval, SPDIF_REG_STC + spdif_base_addr);
 
 }
 
@@ -289,17 +647,14 @@ static int spdif_tx_init(void)
  *
  * This function is called to stop the spdif
  */
-static int spdif_tx_exit(void)
+static void spdif_tx_uninit(void)
 {
-	int value;
+	unsigned long regval;
 
-	value = __raw_readl(SPDIF_REG_SCR + spdif_base_addr) & 0xffffe3;
-	value |= SCR_TXSEL_OFF;
-	__raw_writel(value, SPDIF_REG_SCR + spdif_base_addr);
-	disable_irq(MXC_INT_SPDIF);
-	free_irq(MXC_INT_SPDIF, NULL);
+	regval = __raw_readl(SPDIF_REG_SCR + spdif_base_addr) & 0xffffe3;
+	regval |= SCR_TXSEL_OFF;
+	__raw_writel(regval, SPDIF_REG_SCR + spdif_base_addr);
 
-	return 0;
 }
 
 /*!
@@ -342,14 +697,6 @@ struct mxc_spdif_stream {
 	struct snd_pcm_substream *stream;
 };
 
-struct spdif_mixer_control {
-
-	/*!
-	 * IEC958 channel status bit
-	 */
-	unsigned char ch_status[4];
-};
-
 struct mxc_spdif_device {
 	/*!
 	 * SPDIF module register base address
@@ -386,11 +733,17 @@ struct mxc_spdif_device {
 	 */
 	struct snd_pcm *pcm;
 
+	/*!
+	 * DPLL locked status
+	 */
+	atomic_t dpll_locked;
+
+	/*!
+	 * Playback/Capture substream
+	 */
 	struct mxc_spdif_stream s[2];
 };
 
-static struct spdif_mixer_control mxc_spdif_control;
-
 static unsigned int spdif_playback_rates[] = { 32000, 44100, 48000 };
 
 /*!
@@ -403,6 +756,64 @@ static struct snd_pcm_hw_constraint_list hw_playback_rates_stereo = {
 	.mask = 0,
 };
 
+static struct snd_pcm_hw_constraint_list hw_capture_rates_stereo = {
+	.count = ARRAY_SIZE(spdif_playback_rates),
+	.list = spdif_playback_rates,
+	.mask = 0,
+};
+
+/*!
+ * This structure reprensents the capabilities of the driver
+ * in playback mode.
+ */
+static struct snd_pcm_hardware snd_spdif_playback_hw = {
+	.info =
+	    (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
+	     SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_HALF_DUPLEX |
+	     SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_PAUSE |
+	     SNDRV_PCM_INFO_RESUME),
+	.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |
+	    SNDRV_PCM_FMTBIT_S24_LE,
+	.rates =
+	    SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+	.rate_min = 32000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 2,
+	.buffer_bytes_max = SPDIF_MAX_BUF_SIZE,
+	.period_bytes_min = SPDIF_MIN_PERIOD_SIZE,
+	.period_bytes_max = SPDIF_DMA_BUF_SIZE,
+	.periods_min = SPDIF_MIN_PERIOD,
+	.periods_max = SPDIF_MAX_PERIOD,
+	.fifo_size = 0,
+};
+
+/*!
+ * This structure reprensents the capabilities of the driver
+ * in capture mode.
+ */
+static struct snd_pcm_hardware snd_spdif_capture_hw = {
+	.info = (SNDRV_PCM_INFO_INTERLEAVED |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		 SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	.rates = (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
+		  SNDRV_PCM_RATE_48000),
+	.rate_min = 32000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 2,
+	.buffer_bytes_max = SPDIF_MAX_BUF_SIZE,
+	.period_bytes_min = SPDIF_MIN_PERIOD_SIZE,
+	.period_bytes_max = SPDIF_DMA_BUF_SIZE,
+	.periods_min = SPDIF_MIN_PERIOD,
+	.periods_max = SPDIF_MAX_PERIOD,
+	.fifo_size = 0,
+
+};
+
 /*!
   * This function configures the DMA channel used to transfer
   * audio from MCU to SPDIF or from SPDIF to MCU
@@ -424,6 +835,7 @@ spdif_configure_dma_channel(struct mxc_spdif_stream *s,
 		mxc_dma_free(s->dma_wchannel);
 
 	if (s->stream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+
 		if (s->stream->runtime->sample_bits > 16) {
 			channel =
 			    mxc_dma_request(MXC_DMA_SPDIF_32BIT_TX,
@@ -437,6 +849,11 @@ spdif_configure_dma_channel(struct mxc_spdif_stream *s,
 		pr_debug("spdif_configure_dma_channel: %d\n", channel);
 	} else if (s->stream->stream == SNDRV_PCM_STREAM_CAPTURE) {
 
+		channel = mxc_dma_request(MXC_DMA_SPDIF_32BIT_RX,
+					  "SPDIF RX DMA");
+
+		pr_debug("spdif_configure_dma_channel: %d\n", channel);
+
 	}
 	ret = mxc_dma_callback_set(channel,
 				   (mxc_dma_callback_t) callback, (void *)s);
@@ -450,7 +867,7 @@ spdif_configure_dma_channel(struct mxc_spdif_stream *s,
 }
 
 /*!
-  * This function gets the dma pointer position during playback.
+  * This function gets the dma pointer position during playback/capture.
   * Our DMA implementation does not allow to retrieve this position
   * when a transfert is active, so, it answers the middle of
   * the current period beeing transfered
@@ -458,7 +875,7 @@ spdif_configure_dma_channel(struct mxc_spdif_stream *s,
   * @param	s	pointer to the structure of the current stream.
   *
   */
-static u_int spdif_get_playback_dma_pos(struct mxc_spdif_stream *s)
+static u_int spdif_get_dma_pos(struct mxc_spdif_stream *s)
 {
 	struct snd_pcm_substream *substream;
 	struct snd_pcm_runtime *runtime;
@@ -511,7 +928,7 @@ static void spdif_stop_tx(struct mxc_spdif_stream *s)
 
 	/* this stops the dma channel and clears the buffer ptrs */
 	mxc_dma_disable(s->dma_wchannel);
-	spdif_txdma_cfg(SCR_DMA_TX_DISABLE);
+	spdif_dma_enable(SCR_DMA_TX_EN, 0);
 	dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
 			 DMA_TO_DEVICE);
 	spin_unlock_irqrestore(&s->dma_lock, flags);
@@ -550,7 +967,7 @@ static void spdif_start_tx(struct mxc_spdif_stream *s)
 		mxc_dma_config(s->dma_wchannel, &dma_request, 1,
 			       MXC_DMA_MODE_WRITE);
 		ret = mxc_dma_enable(s->dma_wchannel);
-		spdif_txdma_cfg(SCR_DMA_TX_ENABLE);
+		spdif_dma_enable(SCR_DMA_TX_EN, 1);
 		s->tx_spin = 1;
 		if (ret) {
 			pr_info("audio_process_dma: cannot queue DMA \
@@ -589,6 +1006,8 @@ static void spdif_start_tx(struct mxc_spdif_stream *s)
 
 		pr_debug
 		    ("audio playback chain dma:to set up the 2nd dma buffer\n");
+		pr_debug("SCR: 0x%08x\n",
+			 __raw_readl(spdif_base_addr + SPDIF_REG_SCR));
 
 		offset = dma_size * s->period;
 		dma_request.src_addr =
@@ -706,9 +1125,12 @@ static int snd_mxc_spdif_playback_prepare(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime;
 	int err;
 	unsigned int ch_status;
+
 	chip = snd_pcm_substream_chip(substream);
 	runtime = substream->runtime;
+
 	spdif_tx_init();
+
 	ch_status =
 	    ((mxc_spdif_control.ch_status[2] << 16) | (mxc_spdif_control.
 						       ch_status[1] << 8) |
@@ -716,7 +1138,7 @@ static int snd_mxc_spdif_playback_prepare(struct snd_pcm_substream *substream)
 	spdif_set_channel_status(ch_status, SPDIF_REG_STCSCH);
 	ch_status = mxc_spdif_control.ch_status[3];
 	spdif_set_channel_status(ch_status, SPDIF_REG_STCSCL);
-	spdif_intr_enable(INT_TXFIFO_RESYNC);
+	spdif_intr_enable(INT_TXFIFO_RESYNC, 1);
 	spdif_set_sample_rate(chip->spdif_txclk_44100, chip->spdif_txclk_48000,
 			      runtime->rate);
 	spdif_set_clk_accuracy(SPDIF_CLK_ACCURACY_LEV2);
@@ -728,6 +1150,13 @@ static int snd_mxc_spdif_playback_prepare(struct snd_pcm_substream *substream)
 		pr_info("snd_mxc_spdif_playback_prepare - err < 0\n");
 		return err;
 	}
+
+	/**
+	 * FIXME: dump registers
+	 */
+	pr_debug("SCR: 0x%08x\n", __raw_readl(spdif_base_addr + SPDIF_REG_SCR));
+	pr_debug("SIE: 0x%08x\n", __raw_readl(spdif_base_addr + SPDIF_REG_SIE));
+	pr_debug("STC: 0x%08x\n", __raw_readl(spdif_base_addr + SPDIF_REG_STC));
 	return 0;
 }
 
@@ -743,40 +1172,9 @@ snd_mxc_spdif_playback_pointer(struct snd_pcm_substream *substream)
 {
 	struct mxc_spdif_device *chip;
 	chip = snd_pcm_substream_chip(substream);
-	return spdif_get_playback_dma_pos(&chip->s[SNDRV_PCM_STREAM_PLAYBACK]);
+	return spdif_get_dma_pos(&chip->s[SNDRV_PCM_STREAM_PLAYBACK]);
 }
 
-static struct snd_pcm_hardware snd_spdif_playback_hw = {
-	.info =
-	    (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
-	     SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_HALF_DUPLEX |
-	     SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_PAUSE |
-	     SNDRV_PCM_INFO_RESUME),
-	.formats =
-	    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |
-	    SNDRV_PCM_FMTBIT_S24_LE,
-	.rates =
-	    SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
-	.rate_min = 32000,
-	.rate_max = 48000,
-	.channels_min = 2,
-	.channels_max = 2,
-	.buffer_bytes_max = SPDIF_MAX_BUF_SIZE,
-	.period_bytes_min = SPDIF_MIN_PERIOD_SIZE,
-	.period_bytes_max = SPDIF_DMA_BUF_SIZE,
-	.periods_min = SPDIF_MIN_PERIOD,
-	.periods_max = SPDIF_MAX_PERIOD,
-	.fifo_size = 0,
-};
-
-/*!
-  * This function opens a spdif device in playback mode
-  * It is called by ALSA framework.
-  *
-  * @param	substream	pointer to the structure of the current stream.
-  *
-  * @return              0 on success, -1 otherwise.
-  */
 static int snd_card_mxc_spdif_playback_open(struct snd_pcm_substream *substream)
 {
 	struct mxc_spdif_device *chip;
@@ -785,8 +1183,13 @@ static int snd_card_mxc_spdif_playback_open(struct snd_pcm_substream *substream)
 	struct mxc_spdif_platform_data *spdif_data;
 
 	chip = snd_pcm_substream_chip(substream);
+
 	spdif_data = chip->card->dev->platform_data;
+	/* enable core clock */
+	clk_enable(spdif_data->spdif_core_clk);
+	/* enable tx clock */
 	clk_enable(spdif_data->spdif_clk);
+
 	runtime = substream->runtime;
 	chip->s[SNDRV_PCM_STREAM_PLAYBACK].stream = substream;
 	runtime->hw = snd_spdif_playback_hw;
@@ -794,12 +1197,17 @@ static int snd_card_mxc_spdif_playback_open(struct snd_pcm_substream *substream)
 					 SNDRV_PCM_HW_PARAM_RATE,
 					 &hw_playback_rates_stereo);
 	if (err < 0)
-		return err;
+		goto failed;
 	err =
 	    snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
 	if (err < 0)
-		return err;
+		goto failed;
+
 	return 0;
+      failed:
+	clk_disable(spdif_data->spdif_clk);
+	clk_disable(spdif_data->spdif_core_clk);
+	return err;
 }
 
 /*!
@@ -818,11 +1226,383 @@ static int snd_card_mxc_spdif_playback_close(struct snd_pcm_substream
 
 	chip = snd_pcm_substream_chip(substream);
 	spdif_data = chip->card->dev->platform_data;
-	spdif_intr_disable(INT_TXFIFO_UNOV | INT_TXFIFO_RESYNC | INT_TX_EMPTY);
-	spdif_tx_exit();
+
+	pr_debug("SIS: 0x%08x\n", __raw_readl(spdif_base_addr + SPDIF_REG_SIS));
+
+	spdif_intr_status();
+	spdif_intr_enable(INT_TXFIFO_RESYNC, 0);
+	spdif_tx_uninit();
 	clk_disable(spdif_data->spdif_clk);
+	clk_disable(spdif_data->spdif_core_clk);
 	mxc_dma_free(chip->s[SNDRV_PCM_STREAM_PLAYBACK].dma_wchannel);
 	chip->s[SNDRV_PCM_STREAM_PLAYBACK].dma_wchannel = 0;
+
+	return 0;
+}
+
+/*! TODO: update the dma start/stop callback routine
+  * This function stops the current dma transfert for capture
+  * and clears the dma pointers.
+  *
+  * @param	s	pointer to the structure of the current stream.
+  *
+  */
+static void spdif_stop_rx(struct mxc_spdif_stream *s)
+{
+	unsigned long flags;
+	struct snd_pcm_substream *substream;
+	struct snd_pcm_runtime *runtime;
+	unsigned int dma_size;
+	unsigned int offset;
+
+	substream = s->stream;
+	runtime = substream->runtime;
+	dma_size = frames_to_bytes(runtime, runtime->period_size);
+	offset = dma_size * s->periods;
+
+	spin_lock_irqsave(&s->dma_lock, flags);
+
+	s->active = 0;
+	s->period = 0;
+	s->periods = 0;
+
+	/* this stops the dma channel and clears the buffer ptrs */
+	mxc_dma_disable(s->dma_wchannel);
+	spdif_dma_enable(SCR_DMA_RX_EN, 0);
+	dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
+			 DMA_FROM_DEVICE);
+	spin_unlock_irqrestore(&s->dma_lock, flags);
+}
+
+/*!
+  * This function is called whenever a new audio block needs to be
+  * received from SPDIF. The function receives the address and the size
+  * of the new block and start a new DMA transfer.
+  *
+  * @param	s	pointer to the structure of the current stream.
+  *
+  */
+static void spdif_start_rx(struct mxc_spdif_stream *s)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_pcm_runtime *runtime;
+	unsigned int dma_size = 0;
+	unsigned int offset;
+	int ret = 0;
+	mxc_dma_requestbuf_t dma_request;
+
+	substream = s->stream;
+	runtime = substream->runtime;
+	memset(&dma_request, 0, sizeof(mxc_dma_requestbuf_t));
+
+	if (s->active) {
+		dma_size = frames_to_bytes(runtime, runtime->period_size);
+		pr_debug("s->period (%x) runtime->periods (%d)\n",
+			 s->period, runtime->periods);
+		pr_debug("runtime->period_size (%d) dma_size (%d)\n",
+			 (unsigned int)runtime->period_size,
+			 runtime->dma_bytes);
+
+		offset = dma_size * s->period;
+		dma_request.dst_addr =
+		    (dma_addr_t) (dma_map_single
+				  (NULL, runtime->dma_area + offset, dma_size,
+				   DMA_FROM_DEVICE));
+
+		dma_request.src_addr =
+		    (dma_addr_t) (SPDIF_BASE_ADDR + SPDIF_REG_SRL);
+		dma_request.num_of_bytes = dma_size;
+		/* config and enable sdma for RX */
+		mxc_dma_config(s->dma_wchannel, &dma_request, 1,
+			       MXC_DMA_MODE_READ);
+		ret = mxc_dma_enable(s->dma_wchannel);
+		/* enable SPDIF dma */
+		spdif_dma_enable(SCR_DMA_RX_EN, 1);
+
+		s->tx_spin = 1;
+		if (ret) {
+			pr_info("audio_process_dma: cannot queue DMA \
+				buffer\n");
+			return;
+		}
+		s->period++;
+		s->period %= runtime->periods;
+
+		if ((s->period > s->periods)
+		    && ((s->period - s->periods) > 1)) {
+			pr_debug("audio capture chain dma: already double \
+				buffered\n");
+			return;
+		}
+
+		if ((s->period < s->periods)
+		    && ((s->period + runtime->periods - s->periods) > 1)) {
+			pr_debug("audio playback chain dma: already double  \
+				buffered\n");
+			return;
+		}
+
+		if (s->period == s->periods) {
+			pr_debug("audio capture chain dma: s->period == \
+				s->periods\n");
+			return;
+		}
+
+		if (snd_pcm_capture_hw_avail(runtime) <
+		    2 * runtime->period_size) {
+			pr_debug("audio capture chain dma: available data \
+				is not enough\n");
+			return;
+		}
+
+		pr_debug
+		    ("audio playback chain dma:to set up the 2nd dma buffer\n");
+
+		offset = dma_size * s->period;
+		dma_request.dst_addr =
+		    (dma_addr_t) (dma_map_single
+				  (NULL, runtime->dma_area + offset, dma_size,
+				   DMA_FROM_DEVICE));
+		mxc_dma_config(s->dma_wchannel, &dma_request, 1,
+			       MXC_DMA_MODE_READ);
+		ret = mxc_dma_enable(s->dma_wchannel);
+		s->period++;
+		s->period %= runtime->periods;
+
+	}
+	return;
+}
+
+/*!
+  * This is a callback which will be called
+  * when a RX transfer finishes. The call occurs
+  * in interrupt context.
+  *
+  * @param	data	pointer to the structure of the current stream
+  * @param	error	DMA error flag
+  * @param	count	number of bytes transfered by the DMA
+  */
+static void spdif_rx_callback(void *data, int error, unsigned int count)
+{
+	struct mxc_spdif_stream *s;
+	struct snd_pcm_substream *substream;
+	struct snd_pcm_runtime *runtime;
+	unsigned int dma_size;
+	unsigned int previous_period;
+	unsigned int offset;
+
+	s = data;
+	substream = s->stream;
+	runtime = substream->runtime;
+	previous_period = s->periods;
+	dma_size = frames_to_bytes(runtime, runtime->period_size);
+	offset = dma_size * previous_period;
+
+	s->tx_spin = 0;
+	s->periods++;
+	s->periods %= runtime->periods;
+
+	dma_unmap_single(NULL, runtime->dma_addr + offset, dma_size,
+			 DMA_FROM_DEVICE);
+	if (s->active)
+		snd_pcm_period_elapsed(s->stream);
+	spin_lock(&s->dma_lock);
+	spdif_start_rx(s);
+	spin_unlock(&s->dma_lock);
+}
+
+/*!
+  * This function is a dispatcher of command to be executed
+  * by the driver for capture.
+  *
+  * @param	substream	pointer to the structure of the current stream.
+  * @param	cmd		command to be executed
+  *
+  * @return              0 on success, -1 otherwise.
+  */
+static int
+snd_mxc_spdif_capture_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct mxc_spdif_device *chip;
+	struct mxc_spdif_stream *s;
+	int err = 0;
+	chip = snd_pcm_substream_chip(substream);
+	s = &chip->s[SNDRV_PCM_STREAM_CAPTURE];
+	spin_lock(&s->dma_lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		s->tx_spin = 0;
+		s->active = 1;
+		spdif_start_rx(s);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		spdif_stop_rx(s);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		s->active = 0;
+		s->periods = 0;
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+		s->active = 1;
+		s->tx_spin = 0;
+		spdif_start_rx(s);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		s->active = 0;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		s->active = 1;
+		s->tx_spin = 0;
+		spdif_start_rx(s);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+	spin_unlock(&s->dma_lock);
+	return err;
+}
+
+/*!
+  * This function configures the hardware to allow audio
+  * capture operations. It is called by ALSA framework.
+  *
+  * @param	substream	pointer to the structure of the current stream.
+  *
+  * @return              0 on success, -1 otherwise.
+  */
+static int snd_mxc_spdif_capture_prepare(struct snd_pcm_substream *substream)
+{
+	struct mxc_spdif_device *chip;
+	struct mxc_spdif_platform_data *spdif_data;
+	struct snd_pcm_runtime *runtime;
+	int err;
+
+	chip = snd_pcm_substream_chip(substream);
+	runtime = substream->runtime;
+	spdif_data = chip->card->dev->platform_data;
+
+	spdif_rx_init();
+	/* enable interrupts, include DPLL lock */
+	spdif_intr_enable(INT_SYM_ERR | INT_BIT_ERR | INT_URX_FUL |
+			  INT_URX_OV | INT_QRX_FUL | INT_QRX_OV |
+			  INT_UQ_SYNC | INT_UQ_ERR | INT_RX_RESYNC |
+			  INT_LOSS_LOCK, 1);
+
+	/* setup rx clock source */
+	spdif_set_rx_clksrc(spdif_data->spdif_clkid, SPDIF_DEFAULT_GAINSEL, 0);
+
+	/* setup DMA controller for spdif rx */
+	err = spdif_configure_dma_channel(&chip->
+					  s[SNDRV_PCM_STREAM_CAPTURE],
+					  spdif_rx_callback);
+	if (err < 0) {
+		pr_info("snd_mxc_spdif_playback_prepare - err < 0\n");
+		return err;
+	}
+	/**
+	 * FIXME: dump registers
+	 */
+	pr_debug("SCR: 0x%08x\n", __raw_readl(spdif_base_addr + SPDIF_REG_SCR));
+	pr_debug("SIE: 0x%08x\n", __raw_readl(spdif_base_addr + SPDIF_REG_SIE));
+	pr_debug("SRPC: 0x%08x\n",
+		 __raw_readl(spdif_base_addr + SPDIF_REG_SRPC));
+
+	return 0;
+}
+
+/*!
+  * This function gets the current capture pointer position.
+  * It is called by ALSA framework.
+  *
+  * @param	substream	pointer to the structure of the current stream.
+  *
+  */
+static snd_pcm_uframes_t
+snd_mxc_spdif_capture_pointer(struct snd_pcm_substream *substream)
+{
+	struct mxc_spdif_device *chip;
+	chip = snd_pcm_substream_chip(substream);
+	return spdif_get_dma_pos(&chip->s[SNDRV_PCM_STREAM_CAPTURE]);
+}
+
+/*!
+  * This function opens a spdif device in capture mode
+  * It is called by ALSA framework.
+  *
+  * @param	substream	pointer to the structure of the current stream.
+  *
+  * @return              0 on success, -1 otherwise.
+  */
+static int snd_card_mxc_spdif_capture_open(struct snd_pcm_substream *substream)
+{
+	struct mxc_spdif_device *chip;
+	struct snd_pcm_runtime *runtime;
+	int err = 0;
+	struct mxc_spdif_platform_data *spdif_data;
+
+	chip = snd_pcm_substream_chip(substream);
+
+	spdif_data = chip->card->dev->platform_data;
+	/* enable core clock */
+	clk_enable(spdif_data->spdif_core_clk);
+	/* enable rx bus clock */
+	clk_enable(spdif_data->spdif_clk);
+
+	runtime = substream->runtime;
+	chip->s[SNDRV_PCM_STREAM_CAPTURE].stream = substream;
+	runtime->hw = snd_spdif_capture_hw;
+
+	/* set hw param constraints */
+	err = snd_pcm_hw_constraint_list(runtime, 0,
+					 SNDRV_PCM_HW_PARAM_RATE,
+					 &hw_capture_rates_stereo);
+	if (err < 0)
+		goto failed;
+	err =
+	    snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	if (err < 0)
+		goto failed;
+
+	/* enable spdif dpll lock interrupt */
+	spdif_intr_enable(INT_DPLL_LOCKED, 1);
+
+	return 0;
+
+      failed:
+	clk_disable(spdif_data->spdif_clk);
+	clk_disable(spdif_data->spdif_core_clk);
+	return err;
+}
+
+/*!
+  * This function closes an spdif device for capture.
+  * It is called by ALSA framework.
+  *
+  * @param	substream	pointer to the structure of the current stream.
+  *
+  * @return              0 on success, -1 otherwise.
+  */
+static int snd_card_mxc_spdif_capture_close(struct snd_pcm_substream
+					    *substream)
+{
+	struct mxc_spdif_device *chip;
+	struct mxc_spdif_platform_data *spdif_data;
+
+	chip = snd_pcm_substream_chip(substream);
+	spdif_data = chip->card->dev->platform_data;
+
+	pr_debug("SIS: 0x%08x\n", __raw_readl(spdif_base_addr + SPDIF_REG_SIS));
+
+	spdif_intr_enable(INT_DPLL_LOCKED | INT_SYM_ERR | INT_BIT_ERR |
+			  INT_URX_FUL | INT_URX_OV | INT_QRX_FUL | INT_QRX_OV |
+			  INT_UQ_SYNC | INT_UQ_ERR | INT_RX_RESYNC |
+			  INT_LOSS_LOCK, 0);
+	spdif_rx_uninit();
+	clk_disable(spdif_data->spdif_clk);
+	clk_disable(spdif_data->spdif_core_clk);
+	mxc_dma_free(chip->s[SNDRV_PCM_STREAM_CAPTURE].dma_wchannel);
+	chip->s[SNDRV_PCM_STREAM_CAPTURE].dma_wchannel = 0;
 	return 0;
 }
 
@@ -880,14 +1660,14 @@ static struct snd_pcm_ops snd_card_mxc_spdif_playback_ops = {
 };
 
 static struct snd_pcm_ops snd_card_mxc_spdif_capture_ops = {
-	.open = NULL,
-	.close = NULL,
-	.ioctl = NULL,
-	.hw_params = NULL,
-	.hw_free = NULL,
-	.prepare = NULL,
-	.trigger = NULL,
-	.pointer = NULL,
+	.open = snd_card_mxc_spdif_capture_open,
+	.close = snd_card_mxc_spdif_capture_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = snd_mxc_spdif_hw_params,
+	.hw_free = snd_mxc_spdif_hw_free,
+	.prepare = snd_mxc_spdif_capture_prepare,
+	.trigger = snd_mxc_spdif_capture_trigger,
+	.pointer = snd_mxc_spdif_capture_pointer,
 };
 
 /*!
@@ -899,8 +1679,14 @@ static struct snd_pcm_ops snd_card_mxc_spdif_capture_ops = {
   */
 void mxc_init_spdif_device(struct mxc_spdif_device *mxc_spdif)
 {
+
+	/* initial spinlock for control data */
+	spin_lock_init(&mxc_spdif_control.ctl_lock);
+
 	if (mxc_spdif->mxc_spdif_tx) {
+
 		mxc_spdif->s[SNDRV_PCM_STREAM_PLAYBACK].id = "spdif tx";
+		/* init tx channel status default value */
 		mxc_spdif_control.ch_status[0] =
 		    IEC958_AES0_CON_NOT_COPYRIGHT |
 		    IEC958_AES0_CON_EMPHASIS_5015;
@@ -911,11 +1697,22 @@ void mxc_init_spdif_device(struct mxc_spdif_device *mxc_spdif)
 	}
 	if (mxc_spdif->mxc_spdif_rx) {
 
-		/*Add code here if capture is available */
+		/* TODO: Add code here if capture is available */
+		mxc_spdif->s[SNDRV_PCM_STREAM_CAPTURE].id = "spdif rx";
 	}
 
 }
 
+/*!
+ * MXC SPDIF IEC958 controller(mixer) functions
+ *
+ * 	Channel status get/put control
+ * 	User bit value get/put control
+ * 	Valid bit value get control
+ * 	DPLL lock status get control
+ * 	User bit sync mode selection control
+ *
+ */
 static int mxc_pb_spdif_info(struct snd_kcontrol *kcontrol,
 			     struct snd_ctl_elem_info *uinfo)
 {
@@ -952,15 +1749,262 @@ static int mxc_pb_spdif_put(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+static int snd_mxc_spdif_info(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+/*!
+ * Get channel status from SPDIF_RX_CCHAN register
+ */
+static int snd_mxc_spdif_capture_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	unsigned int cstatus;
+
+	cstatus = __raw_readl(spdif_base_addr + SPDIF_REG_SRCSLH);
+	ucontrol->value.iec958.status[0] = (cstatus >> 16) & 0xFF;
+	ucontrol->value.iec958.status[1] = (cstatus >> 8) & 0xFF;
+	ucontrol->value.iec958.status[2] = cstatus & 0xFF;
+	cstatus = __raw_readl(spdif_base_addr + SPDIF_REG_SRCSLL);
+	ucontrol->value.iec958.status[3] = (cstatus >> 16) & 0xFF;
+	ucontrol->value.iec958.status[4] = (cstatus >> 8) & 0xFF;
+	ucontrol->value.iec958.status[5] = cstatus & 0xFF;
+
+	return 0;
+}
+
+/*!
+ * Get User bits (subcode) from chip value which readed out
+ * in UChannel register.
+ */
+static int snd_mxc_spdif_subcode_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&mxc_spdif_control.ctl_lock, flags);
+	if (mxc_spdif_control.ready_buf) {
+		int index = 1 << mxc_spdif_control.ready_buf;
+		memcpy(&ucontrol->value.iec958.subcode[0],
+		       &mxc_spdif_control.subcode[(index - 1) *
+						  SPDIF_UBITS_SIZE],
+		       SPDIF_UBITS_SIZE);
+	} else {
+		ret = -EAGAIN;
+	}
+	spin_unlock_irqrestore(&mxc_spdif_control.ctl_lock, flags);
+
+	return ret;
+}
+
+/*!
+ * Q-subcode infomation.
+ * the byte size is SPDIF_UBITS_SIZE/8
+ */
+static int snd_mxc_spdif_qinfo(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	uinfo->count = SPDIF_QSUB_SIZE;
+	return 0;
+}
+
 /*!
- * This structure defines the spdif control interface
+ * Get Q subcode from chip value which readed out
+ * in QChannel register.
  */
-struct snd_kcontrol_new snd_mxc_spdif_playback __devinitdata = {
-	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-	.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
-	.info = mxc_pb_spdif_info,
-	.get = mxc_pb_spdif_get,
-	.put = mxc_pb_spdif_put,
+static int snd_mxc_spdif_qget(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&mxc_spdif_control.ctl_lock, flags);
+	if (mxc_spdif_control.ready_buf) {
+		int index = 1 << mxc_spdif_control.ready_buf;
+		memcpy(&ucontrol->value.bytes.data[0],
+		       &mxc_spdif_control.qsub[(index - 1) * SPDIF_QSUB_SIZE],
+		       SPDIF_QSUB_SIZE);
+	} else {
+		ret = -EAGAIN;
+	}
+	spin_unlock_irqrestore(&mxc_spdif_control.ctl_lock, flags);
+
+	return ret;
+}
+
+/*!
+ * Valid bit infomation.
+ */
+static int snd_mxc_spdif_vbit_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+/*!
+ * Get valid good bit from interrupt status register.
+ */
+static int snd_mxc_spdif_vbit_get(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	unsigned int int_val;
+
+	int_val = __raw_readl(SPDIF_REG_SIS);
+	ucontrol->value.integer.value[0] = (int_val & INT_VAL_NOGOOD) == 0;
+	return 0;
+}
+
+/*!
+ * DPLL lock infomation.
+ */
+static int snd_mxc_spdif_rxrate_info(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 32;
+	uinfo->value.integer.max = 48;
+	return 0;
+}
+
+/*!
+ * Get DPLL lock or not info from stable interrupt status register.
+ * User application must use this control to get locked,
+ * then can do next PCM operation
+ */
+static int snd_mxc_spdif_rxrate_get(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct mxc_spdif_device *chip = snd_kcontrol_chip(kcontrol);
+	struct mxc_spdif_platform_data *spdif_data;
+
+	spdif_data = chip->card->dev->platform_data;
+
+	if (atomic_read(&chip->dpll_locked)) {
+		ucontrol->value.integer.value[0] =
+		    spdif_get_rxclk_rate(spdif_data->spdif_clk);
+	} else {
+		ucontrol->value.integer.value[0] = 0;
+	}
+	return 0;
+}
+
+/*!
+ * User bit sync mode info
+ */
+static int snd_mxc_spdif_usync_info(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+/*!
+ * User bit sync mode:
+ * 1 CD User channel subcode
+ * 0 Non-CD data
+ */
+static int snd_mxc_spdif_usync_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	unsigned int int_val;
+
+	int_val = __raw_readl(SPDIF_REG_SRCD);
+	ucontrol->value.integer.value[0] = (int_val & SRCD_CD_USER) != 0;
+	return 0;
+}
+
+/*!
+ * User bit sync mode:
+ * 1 CD User channel subcode
+ * 0 Non-CD data
+ */
+static int snd_mxc_spdif_usync_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	unsigned int int_val;
+
+	int_val = ucontrol->value.integer.value[0] << SRCD_CD_USER_OFFSET;
+	__raw_writel(int_val, SPDIF_REG_SRCD);
+	return 0;
+}
+
+/*!
+ * MXC SPDIF IEC958 controller defines
+ */
+static struct snd_kcontrol_new snd_mxc_spdif_ctrls[] = {
+	/* status cchanel controller */
+	{
+	 .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	 .name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
+	 .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE |
+	 SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	 .info = mxc_pb_spdif_info,
+	 .get = mxc_pb_spdif_get,
+	 .put = mxc_pb_spdif_put,
+	 },
+	{
+	 .iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	 .name = SNDRV_CTL_NAME_IEC958("", CAPTURE, DEFAULT),
+	 .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	 .info = snd_mxc_spdif_info,
+	 .get = snd_mxc_spdif_capture_get,
+	 },
+	/* user bits controller */
+	{
+	 .iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	 .name = "IEC958 Subcode Capture Default",
+	 .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	 .info = snd_mxc_spdif_info,
+	 .get = snd_mxc_spdif_subcode_get,
+	 },
+	{
+	 .iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	 .name = "IEC958 Q-subcode Capture Default",
+	 .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	 .info = snd_mxc_spdif_qinfo,
+	 .get = snd_mxc_spdif_qget,
+	 },
+	/* valid bit error controller */
+	{
+	 .iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	 .name = "IEC958 V-Bit Errors",
+	 .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	 .info = snd_mxc_spdif_vbit_info,
+	 .get = snd_mxc_spdif_vbit_get,
+	 },
+	/* DPLL lock info get controller */
+	{
+	 .iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	 .name = "IEC958 RX Sample Rate",
+	 .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	 .info = snd_mxc_spdif_rxrate_info,
+	 .get = snd_mxc_spdif_rxrate_get,
+	 },
+	/* User bit sync mode set/get controller */
+	{
+	 .iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	 .name = "IEC958 User-bit SyncMode",
+	 .access =
+	 SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE |
+	 SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	 .info = snd_mxc_spdif_usync_info,
+	 .get = snd_mxc_spdif_usync_get,
+	 .put = snd_mxc_spdif_usync_put,
+	 },
 };
 
 /*!
@@ -1012,18 +2056,19 @@ static int snd_card_mxc_spdif_pcm(struct mxc_spdif_device *mxc_spdif)
 static int mxc_alsa_spdif_probe(struct platform_device
 				*pdev)
 {
-	int err;
+	int err, idx;
 	struct snd_card *card;
 	struct mxc_spdif_device *chip;
 	struct resource *res;
-	struct mxc_spdif_platform_data *spdif_platform_data;
+	struct snd_kcontrol *kctl;
+	struct mxc_spdif_platform_data *plat_data;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res)
 		return -ENOENT;
 
 	/* register the soundcard */
-	card = snd_card_new(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1, THIS_MODULE,
+	card = snd_card_new(SNDRV_DEFAULT_IDX1, "MXC SPDIF", THIS_MODULE,
 			    sizeof(struct mxc_spdif_device));
 	if (card == NULL)
 		return -ENOMEM;
@@ -1032,20 +2077,54 @@ static int mxc_alsa_spdif_probe(struct platform_device
 	card->dev = &pdev->dev;
 	chip->reg_base = ioremap(res->start, res->end - res->start + 1);
 	spdif_base_addr = (unsigned long)chip->reg_base;
-	spdif_platform_data =
-	    (struct mxc_spdif_platform_data *)pdev->dev.platform_data;
-	chip->mxc_spdif_tx = spdif_platform_data->spdif_tx;
-	chip->mxc_spdif_rx = spdif_platform_data->spdif_rx;
-	chip->spdif_txclk_44100 = spdif_platform_data->spdif_clk_44100;
-	chip->spdif_txclk_48000 = spdif_platform_data->spdif_clk_48000;
+	plat_data = (struct mxc_spdif_platform_data *)pdev->dev.platform_data;
+	chip->mxc_spdif_tx = plat_data->spdif_tx;
+	chip->mxc_spdif_rx = plat_data->spdif_rx;
+	chip->spdif_txclk_44100 = plat_data->spdif_clk_44100;
+	chip->spdif_txclk_48000 = plat_data->spdif_clk_48000;
+	atomic_set(&chip->dpll_locked, 0);
+
 	err = snd_card_mxc_spdif_pcm(chip);
 	if (err < 0)
 		goto nodev;
-	err = snd_ctl_add(card,
-			  snd_ctl_new1(&snd_mxc_spdif_playback,
-				       &mxc_spdif_control));
-	if (err < 0)
+
+	/*!
+	 * Add controls to the card
+	 */
+	for (idx = 0; idx < ARRAY_SIZE(snd_mxc_spdif_ctrls); idx++) {
+
+		kctl = snd_ctl_new1(&snd_mxc_spdif_ctrls[idx], chip);
+		if (kctl == NULL) {
+			err = -ENOMEM;
+			goto nodev;
+		}
+		/* check to add control to corresponding substream */
+		if (strstr(kctl->id.name, "Playback"))
+			kctl->id.device = 0;
+		else
+			kctl->id.device = 1;
+
+		err = snd_ctl_add(card, kctl);
+		if (err < 0)
+			goto nodev;
+	}
+
+	/*!
+	 * SPDIF interrupt initialization
+	 * software reset to SPDIF
+	 */
+	clk_enable(plat_data->spdif_core_clk);
+	spdif_softreset();
+	/* disable all the interrupts */
+	spdif_intr_enable(0xffffff, 0);
+	/* spdif interrupt register and disable */
+	if (request_irq(MXC_INT_SPDIF, spdif_isr, 0, "spdif",
+			chip->card->dev)) {
+		pr_err("MXC spdif: failed to request irq\n");
+		err = -EBUSY;
 		goto nodev;
+	}
+	clk_disable(plat_data->spdif_core_clk);
 
 	if (chip->mxc_spdif_tx)
 		spin_lock_init(&chip->s[SNDRV_PCM_STREAM_PLAYBACK].dma_lock);
@@ -1054,9 +2133,10 @@ static int mxc_alsa_spdif_probe(struct platform_device
 	strcpy(card->driver, MXC_SPDIF_NAME);
 	strcpy(card->shortname, "MXC SPDIF TX/RX");
 	sprintf(card->longname, "MXC Freescale with SPDIF");
+
 	err = snd_card_register(card);
 	if (err == 0) {
-		pr_debug(KERN_INFO "MXC spdif support initialized\n");
+		pr_info("MXC spdif support initialized\n");
 		platform_set_drvdata(pdev, card);
 		return 0;
 	}
@@ -1077,11 +2157,15 @@ static int mxc_alsa_spdif_remove(struct platform_device *pdev)
 {
 	struct mxc_spdif_device *chip;
 	struct snd_card *card;
+
 	card = platform_get_drvdata(pdev);
 	chip = card->private_data;
+	free_irq(MXC_INT_SPDIF, card->dev);
 	iounmap(chip->reg_base);
+
 	snd_card_free(card);
 	platform_set_drvdata(pdev, NULL);
+
 	return 0;
 }
 
-- 
1.5.4.4

