From 353919fb59bdf082b16087ed712985e9e91fef98 Mon Sep 17 00:00:00 2001
From: Richard Zhao <b20223@freescale.com>
Date: Mon, 30 Jun 2008 14:29:42 +0800
Subject: [PATCH] ENGR00084762 add UniFi SDIO glue for Freescale MMC/SDIO

Enable mmc2 on imx31
Port the CSR UniFi SDIO glue to the new sdio framework.

Signed-off-by: Richard Zhao <b20223@freescale.com>
---
 arch/arm/configs/imx31_3stack_defconfig |    1 +
 arch/arm/mach-mx3/mx3_3stack.c          |   84 +++++
 drivers/mmc/card/Kconfig                |   10 +
 drivers/mmc/card/Makefile               |    1 +
 drivers/mmc/card/unifi_fs/Makefile      |    2 +
 drivers/mmc/card/unifi_fs/fs_lx.c       |  617 +++++++++++++++++++++++++++++++
 drivers/mmc/card/unifi_fs/fs_sdio_api.h |   60 +++
 drivers/mmc/host/mxc_mmc.c              |   70 +++-
 include/asm-arm/arch-mxc/mmc.h          |    4 +-
 include/asm-arm/arch-mxc/mxc.h          |   17 +
 10 files changed, 844 insertions(+), 22 deletions(-)

diff --git a/arch/arm/configs/imx31_3stack_defconfig b/arch/arm/configs/imx31_3stack_defconfig
index d13b95a..bb5d99a 100644
--- a/arch/arm/configs/imx31_3stack_defconfig
+++ b/arch/arm/configs/imx31_3stack_defconfig
@@ -1287,6 +1287,7 @@ CONFIG_MMC=y
 CONFIG_MMC_BLOCK=y
 CONFIG_MMC_BLOCK_BOUNCE=y
 # CONFIG_SDIO_UART is not set
+CONFIG_SDIO_UNIFI_FS=m
 
 #
 # MMC/SD Host Controller Drivers
diff --git a/arch/arm/mach-mx3/mx3_3stack.c b/arch/arm/mach-mx3/mx3_3stack.c
index 3f08ec8..c941167 100644
--- a/arch/arm/mach-mx3/mx3_3stack.c
+++ b/arch/arm/mach-mx3/mx3_3stack.c
@@ -687,6 +687,38 @@ static struct resource mxcsdhc1_resources[] = {
 	       },
 };
 
+static struct mxc_mmc_platform_data mmc1_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30 |
+		    MMC_VDD_31_32,
+	.min_clk = 150000,
+	.max_clk = 25000000,
+	.card_fixed = 1,
+	.card_inserted_state = 1,
+	.status = sdhc_get_card_det_status,
+	.power_mmc = "VMMC2",
+};
+
+/*!
+ * Resource definition for the SDHC1
+ */
+static struct resource mxcsdhc2_resources[] = {
+	[0] = {
+	       .start = MMC_SDHC2_BASE_ADDR,
+	       .end = MMC_SDHC2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_MMC_SDHC2,
+	       .end = MXC_INT_MMC_SDHC2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
 /*! Device Definition for MXC SDHC1 */
 static struct platform_device mxcsdhc1_device = {
 	.name = "mxcmci",
@@ -699,6 +731,18 @@ static struct platform_device mxcsdhc1_device = {
 	.resource = mxcsdhc1_resources,
 };
 
+/*! Device Definition for MXC SDHC2 */
+static struct platform_device mxcsdhc2_device = {
+	.name = "mxcmci",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
+	.resource = mxcsdhc2_resources,
+};
+
 static inline void mxc_init_mmc(void)
 {
 	int cd_irq;
@@ -709,8 +753,17 @@ static inline void mxc_init_mmc(void)
 		mxcsdhc1_device.resource[2].end = cd_irq;
 	}
 
+	cd_irq = sdhc_init_card_det(1);
+	if (cd_irq) {
+		mxcsdhc2_device.resource[2].start = cd_irq;
+		mxcsdhc2_device.resource[2].end = cd_irq;
+	}
+
 	spba_take_ownership(SPBA_SDHC1, SPBA_MASTER_A | SPBA_MASTER_C);
 	(void)platform_device_register(&mxcsdhc1_device);
+
+	spba_take_ownership(SPBA_SDHC2, SPBA_MASTER_A | SPBA_MASTER_C);
+	(void)platform_device_register(&mxcsdhc2_device);
 }
 #else
 static inline void mxc_init_mmc(void)
@@ -865,6 +918,37 @@ static void mxc_init_bluetooth(void)
 	(void)platform_device_register(&mxc_bt_device);
 }
 
+static void mxc_unifi_hardreset(void)
+{
+	mxc_set_gpio_dataout(MX31_PIN_DCD_DCE1, 0);
+	msleep(100);
+	mxc_set_gpio_dataout(MX31_PIN_DCD_DCE1, 1);
+}
+
+static struct mxc_unifi_platform_data unifi_data = {
+	.hardreset = mxc_unifi_hardreset,
+
+	/* GPO3 -> enables SW2B 1.8V out - this becomes 1V8 on personality
+	 * board, then 1V8_EXT, then BT_VUSB
+	 */
+	.reg_gpo1 = "GPO3",
+
+	/* GPO4 -> WiFi_PWEN, but this signal is not used on current boards */
+	.reg_gpo2 = "GPO4",
+
+	.reg_1v5_ana_bb = "VRF1",	/* VRF1 -> WL_1V5ANA and WL_1V5BB */
+	.reg_vdd_vpa = "VMMC2",		/* VMMC2 -> WL_VDD and WL_VPA */
+	.reg_1v5_dd = "VRF2",		/* VRF2 -> WL_1V5DD */
+
+	.host_id = 1,
+};
+
+struct mxc_unifi_platform_data *get_unifi_plat_data(void)
+{
+	return &unifi_data;
+}
+EXPORT_SYMBOL(get_unifi_plat_data);
+
 #if defined(CONFIG_GPS_IOCTRL) || defined(CONFIG_GPS_IOCTRL_MODULE)
 static struct mxc_gps_platform_data gps_data = {
 	.core_reg = "GPO3",
diff --git a/drivers/mmc/card/Kconfig b/drivers/mmc/card/Kconfig
index aa8a4e4..a170e24 100644
--- a/drivers/mmc/card/Kconfig
+++ b/drivers/mmc/card/Kconfig
@@ -39,3 +39,13 @@ config SDIO_UART
 	  SDIO function driver for SDIO cards that implements the UART
 	  class, as well as the GPS class which appears like a UART.
 
+config SDIO_UNIFI_FS
+	tristate "UniFi SDIO glue for Freescale MMC/SDIO"
+	depends on MMC_MXC && MACH_MX31_3DS
+	help
+	  This provides an interface between the CSR UniFi WiFi
+	  driver and the Freescale MMC/SDIO interface.
+	  If you have a MXC platform with a UniFi WiFi chip,
+	  say M here.
+
+	  If unsure, say N.
diff --git a/drivers/mmc/card/Makefile b/drivers/mmc/card/Makefile
index fc5a784..29cc3f3 100644
--- a/drivers/mmc/card/Makefile
+++ b/drivers/mmc/card/Makefile
@@ -11,3 +11,4 @@ mmc_block-objs			:= block.o queue.o
 
 obj-$(CONFIG_SDIO_UART)		+= sdio_uart.o
 
+obj-$(CONFIG_SDIO_UNIFI_FS)	+= unifi_fs/
diff --git a/drivers/mmc/card/unifi_fs/Makefile b/drivers/mmc/card/unifi_fs/Makefile
new file mode 100644
index 0000000..381d4a2
--- /dev/null
+++ b/drivers/mmc/card/unifi_fs/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_SDIO_UNIFI_FS) = unifi_fs.o
+unifi_fs-objs = fs_lx.o
diff --git a/drivers/mmc/card/unifi_fs/fs_lx.c b/drivers/mmc/card/unifi_fs/fs_lx.c
new file mode 100644
index 0000000..a879cd3
--- /dev/null
+++ b/drivers/mmc/card/unifi_fs/fs_lx.c
@@ -0,0 +1,617 @@
+/*
+ * Freescale SDIO glue modules.
+ *
+ * Copyright (C) 2008 Cambridge Silicon Radio Ltd.
+ *
+ *  Note:
+ *      The Freescale MMC/SDIO driver is a project under development so the
+ *      code that interfaces their driver is likely to have changed between
+ *      releases. This code is tested only with the SDIO/MMC driver released
+ *      by Freescale for the imx31_3stack board using Linux Kernel 2.6.24.
+ *
+ *      Also, the code in the probe that sets the pull-ups is platform
+ *      specific and should really be part of the controller's initialisation.
+ *      In the aforesaid Freescale release this code was missing but may
+ *      be in place in the future releases.
+ *
+ *  Important:
+ *      This module does not support more than one device driver instances.
+ *
+ */
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/scatterlist.h>
+
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+
+#include <linux/clk.h>
+#include <asm/arch/pmic_power.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/gpio.h>
+
+#include <linux/platform_device.h>
+#include <linux/regulator/regulator.h>
+
+#include "fs_sdio_api.h"
+
+struct regulator_unifi {
+	struct regulator *reg_gpo1;
+	struct regulator *reg_gpo2;
+	struct regulator *reg_1v5_ana_bb;
+	struct regulator *reg_vdd_vpa;
+	struct regulator *reg_1v5_dd;
+};
+
+static struct sdio_driver sdio_unifi_driver;
+
+static int fs_sdio_probe(struct sdio_func *func,
+			 const struct sdio_device_id *id);
+static void fs_sdio_remove(struct sdio_func *func);
+static void fs_sdio_irq(struct sdio_func *func);
+static int fs_sdio_suspend(struct device *dev, pm_message_t state);
+static int fs_sdio_resume(struct device *dev);
+static int do_sdio_hard_reset(struct sdio_dev *fdev);
+
+/* Globals to store the context to this module and the device driver */
+static struct sdio_dev *available_sdio_dev;
+static struct fs_driver *available_driver;
+struct mxc_unifi_platform_data *plat_data;
+
+static struct mmc_host *fsl_mmc_host;
+struct mmc_host *mxc_mmc_get_host(int id);
+
+enum sdio_cmd_direction {
+	CMD_READ,
+	CMD_WRITE,
+};
+
+static int fsl_io_rw_direct(struct mmc_card *card, int write, unsigned fn,
+	unsigned addr, u8 in, u8 *out)
+{
+	struct mmc_command cmd;
+	int err;
+
+	BUG_ON(!card);
+	BUG_ON(fn > 7);
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = SD_IO_RW_DIRECT;
+	cmd.arg = write ? 0x80000000 : 0x00000000;
+	cmd.arg |= fn << 28;
+	cmd.arg |= (write && out) ? 0x08000000 : 0x00000000;
+	cmd.arg |= addr << 9;
+	cmd.arg |= in;
+	cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC;
+
+	err = mmc_wait_for_cmd(card->host, &cmd, 0);
+	if (err)
+		return err;
+
+	if (mmc_host_is_spi(card->host)) {
+		/* host driver already reported errors */
+	} else {
+		if (cmd.resp[0] & R5_ERROR)
+			return -EIO;
+		if (cmd.resp[0] & R5_FUNCTION_NUMBER)
+			return -EINVAL;
+		if (cmd.resp[0] & R5_OUT_OF_RANGE)
+			return -ERANGE;
+	}
+
+	if (out) {
+		if (mmc_host_is_spi(card->host))
+			*out = (cmd.resp[0] >> 8) & 0xFF;
+		else
+			*out = cmd.resp[0] & 0xFF;
+	}
+
+	return 0;
+}
+
+
+int fs_sdio_readb(struct sdio_dev *fdev, int funcnum, unsigned long addr,
+		  unsigned char *pdata)
+{
+	int err;
+	char val;
+
+	sdio_claim_host(fdev->func);
+	if (funcnum == 0)
+		val = sdio_f0_readb(fdev->func, (unsigned int)addr, &err);
+	else
+		val = sdio_readb(fdev->func, (unsigned int)addr, &err);
+	sdio_release_host(fdev->func);
+	if (!err)
+		*pdata = val;
+	else
+		printk(KERN_ERR "fs_lx: readb error,fun=%d,addr=%d,data=%d,"
+		       "err=%d\n", funcnum, (int)addr, *pdata, err);
+
+	return err;
+}
+EXPORT_SYMBOL(fs_sdio_readb);
+
+int fs_sdio_writeb(struct sdio_dev *fdev, int funcnum, unsigned long addr,
+		   unsigned char data)
+{
+	int err;
+
+	sdio_claim_host(fdev->func);
+	if (funcnum == 0)
+		err = fsl_io_rw_direct(fdev->func->card, 1, 0, addr,
+				       data, NULL);
+	else
+		sdio_writeb(fdev->func, data, (unsigned int)addr, &err);
+	sdio_release_host(fdev->func);
+
+	if (err)
+		printk(KERN_ERR "fs_lx: writeb error,fun=%d,addr=%d,data=%d,"
+		       "err=%d\n", funcnum, (int)addr, data, err);
+	return err;
+}
+EXPORT_SYMBOL(fs_sdio_writeb);
+
+int fs_sdio_block_rw(struct sdio_dev *fdev, int funcnum, unsigned long addr,
+		     unsigned char *pdata, unsigned int count, int direction)
+{
+	int err;
+
+	sdio_claim_host(fdev->func);
+	if (direction == CMD_READ)
+		err = sdio_memcpy_fromio(fdev->func, pdata, addr, count);
+	else
+		err = sdio_memcpy_toio(fdev->func, addr, pdata, count);
+	sdio_release_host(fdev->func);
+
+	return err;
+}
+EXPORT_SYMBOL(fs_sdio_block_rw);
+
+int fs_sdio_enable_interrupt(struct sdio_dev *fdev, int enable)
+{
+	struct mmc_host *host = fdev->func->card->host;
+	unsigned flags;
+
+	spin_lock_irqsave(&fdev->lock, flags);
+	if (enable) {
+		if (!fdev->int_enabled) {
+		fdev->int_enabled = 1;
+		host->ops->enable_sdio_irq(host, 1);
+		}
+	} else {
+		if (fdev->int_enabled) {
+		host->ops->enable_sdio_irq(host, 0);
+		fdev->int_enabled = 0;
+		}
+	}
+	spin_unlock_irqrestore(&fdev->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(fs_sdio_enable_interrupt);
+
+int fs_sdio_enable(struct sdio_dev *fdev)
+{
+	int err = 0;
+
+	sdio_claim_host(fdev->func);
+	err = sdio_disable_func(fdev->func);
+	err = sdio_enable_func(fdev->func);
+	sdio_release_host(fdev->func);
+	if (err)
+		printk(KERN_ERR "fs_lx:fs_sdio_enable error,err=%d\n", err);
+	return err;
+}
+EXPORT_SYMBOL(fs_sdio_enable);
+
+int fs_sdio_set_max_clock_speed(struct sdio_dev *fdev, int max_khz)
+{
+	struct mmc_card *card = fdev->func->card;
+
+	/* Respect the host controller's min-max. */
+	max_khz *= 1000;
+	if (max_khz < card->host->f_min)
+		max_khz = card->host->f_min;
+	if (max_khz > card->host->f_max)
+		max_khz = card->host->f_max;
+
+	card->host->ios.clock = max_khz;
+	card->host->ops->set_ios(card->host, &card->host->ios);
+
+	return max_khz / 1000;
+}
+EXPORT_SYMBOL(fs_sdio_set_max_clock_speed);
+
+int fs_sdio_set_block_size(struct sdio_dev *fdev, int blksz)
+{
+	return 0;
+}
+EXPORT_SYMBOL(fs_sdio_set_block_size);
+
+/*
+ * ---------------------------------------------------------------------------
+ *
+ * Turn on the power of WIFI card
+ *
+ * ---------------------------------------------------------------------------
+ */
+static void fs_unifi_power_on(int check_card)
+{
+	struct regulator_unifi *reg_unifi;
+
+	reg_unifi = plat_data->priv;
+
+	regulator_enable(reg_unifi->reg_gpo1);
+	regulator_enable(reg_unifi->reg_gpo2);
+
+	regulator_set_voltage(reg_unifi->reg_1v5_ana_bb, 1500000);
+	regulator_enable(reg_unifi->reg_1v5_ana_bb);
+
+	regulator_set_voltage(reg_unifi->reg_vdd_vpa, 2300000);
+	regulator_enable(reg_unifi->reg_vdd_vpa);
+
+	/* WL_1V5DD should come on last, 10ms after other supplies */
+	msleep(10);
+	regulator_set_voltage(reg_unifi->reg_1v5_dd, 1500000);
+	regulator_enable(reg_unifi->reg_1v5_dd);
+	msleep(10);
+	if (check_card && fsl_mmc_host) {
+		do_sdio_hard_reset(NULL);
+		msleep(500);
+		mmc_detect_change(fsl_mmc_host, msecs_to_jiffies(100));
+	}
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *
+ * Turn off the power of WIFI card
+ *
+ * ---------------------------------------------------------------------------
+ */
+static void fs_unifi_power_off(int check_card)
+{
+	struct regulator_unifi *reg_unifi;
+
+	reg_unifi = plat_data->priv;
+	regulator_disable(reg_unifi->reg_gpo2);
+	regulator_disable(reg_unifi->reg_1v5_ana_bb);
+	regulator_disable(reg_unifi->reg_1v5_dd);
+	regulator_disable(reg_unifi->reg_vdd_vpa);
+
+	if (check_card && fsl_mmc_host)
+		mmc_detect_change(fsl_mmc_host, msecs_to_jiffies(50));
+
+}
+
+/* This should be made conditional on being slot 2 too - so we can
+ * use a plug in card in slot 1
+ */
+int fs_sdio_hard_reset(struct sdio_dev *fdev)
+{
+	return 0;
+}
+EXPORT_SYMBOL(fs_sdio_hard_reset);
+
+static int do_sdio_hard_reset(struct sdio_dev *fdev)
+{
+	plat_data->hardreset();
+	return 0;
+}
+
+static const struct sdio_device_id fs_sdio_ids[] = {
+	{SDIO_DEVICE(0x032a, 0x0001)},
+	{ /* end: all zeroes */	},
+};
+
+static struct sdio_driver sdio_unifi_driver = {
+	.name = "fs_unifi",
+	.probe = fs_sdio_probe,
+	.remove = fs_sdio_remove,
+	.id_table = fs_sdio_ids,
+	.drv = {
+		.suspend = fs_sdio_suspend,
+		.resume	= fs_sdio_resume,
+	}
+};
+
+int fs_sdio_register_driver(struct fs_driver *driver)
+{
+	int ret;
+
+	/* Switch us on */
+	fs_unifi_power_on(-1);
+
+	/* Store the context to the device driver to the global */
+	available_driver = driver;
+
+	/*
+	 * If available_sdio_dev is not NULL, probe has been called,
+	 * so pass the probe to the registered driver
+	 */
+	if (available_sdio_dev) {
+		/* Store the context to the new device driver */
+		available_sdio_dev->driver = driver;
+
+		printk(KERN_INFO "fs_sdio_register_driver: Glue exists, add "
+		       "device driver and register IRQ\n");
+		driver->probe(available_sdio_dev);
+
+		/* Register the IRQ handler to the SDIO IRQ. */
+		ret = sdio_claim_irq(available_sdio_dev->func, fs_sdio_irq);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(fs_sdio_register_driver);
+
+void fs_sdio_unregister_driver(struct fs_driver *driver)
+{
+	/*
+	 * If available_sdio_dev is not NULL, probe has been called,
+	 * so pass the remove to the registered driver to clean up.
+	 */
+	if (available_sdio_dev) {
+		printk(KERN_INFO "fs_sdio_unregister_driver: Glue exists, "
+		       "unregister IRQ and remove device driver\n");
+
+		/* Unregister the IRQ handler first. */
+		sdio_claim_host(available_sdio_dev->func);
+		sdio_release_irq(available_sdio_dev->func);
+		sdio_release_host(available_sdio_dev->func);
+
+		driver->remove(available_sdio_dev);
+
+		/* Invalidate the context to the device driver */
+		available_sdio_dev->driver = NULL;
+	}
+
+	/* Power down the UniFi */
+	fs_unifi_power_off(-1);
+
+	/* invalidate the context to the device driver to the global */
+	available_driver = NULL;
+}
+EXPORT_SYMBOL(fs_sdio_unregister_driver);
+
+static void fs_sdio_irq(struct sdio_func *func)
+{
+	struct sdio_dev *fdev = (struct sdio_dev *)sdio_get_drvdata(func);
+	if (fdev->driver) {
+		if (fdev->driver->card_int_handler)
+			fdev->driver->card_int_handler(fdev);
+	}
+}
+
+#ifdef CONFIG_PM
+static int fs_sdio_suspend(struct device *dev, pm_message_t state)
+{
+	struct sdio_dev *fdev = available_sdio_dev;
+
+	/* Pass event to the registered driver. */
+	if (fdev->driver)
+		if (fdev->driver->suspend)
+			fdev->driver->suspend(fdev, state);
+
+	return 0;
+}
+
+static int fs_sdio_resume(struct device *dev)
+{
+	struct sdio_dev *fdev = available_sdio_dev;
+
+	/* Pass event to the registered driver. */
+	if (fdev->driver)
+		if (fdev->driver->resume)
+			fdev->driver->resume(fdev);
+
+	return 0;
+}
+#else
+#define fs_sdio_suspend NULL
+#define fs_sdio_resume  NULL
+#endif
+
+static int fs_sdio_probe(struct sdio_func *func,
+			 const struct sdio_device_id *id)
+{
+	struct sdio_dev *fdev;
+	int ret = 0;
+
+	/* Allocate our private context */
+	fdev = kmalloc(sizeof(struct sdio_dev), GFP_KERNEL);
+	available_sdio_dev = fdev;
+	memset(fdev, 0, sizeof(struct sdio_dev));
+	fdev->func = func;
+	fdev->vendor_id = id->vendor;
+	fdev->device_id = id->device;
+	fdev->max_blocksize = func->max_blksize;
+	fdev->int_enabled = 1;
+	spin_lock_init(&fdev->lock);
+
+	/* Store our context in the MMC driver */
+	printk(KERN_INFO "fs_sdio_probe: Add glue driver\n");
+	sdio_set_drvdata(func, fdev);
+
+	/* TODO: If a device driver is registered, call it's probe here */
+	if (available_driver) {
+		/* Store the context to the device driver */
+		fdev->driver = available_driver;
+
+		printk(KERN_INFO "fs_sdio_probe: Add device driver and "
+		       "register IRQ\n");
+		available_driver->probe(fdev);
+
+		/* Register the IRQ handler to the SDIO IRQ. */
+		sdio_claim_host(fdev->func);
+		ret = sdio_claim_irq(func, fs_sdio_irq);
+		sdio_release_host(fdev->func);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static void fs_sdio_remove(struct sdio_func *func)
+{
+	struct sdio_dev *fdev = (struct sdio_dev *)sdio_get_drvdata(func);
+
+	/* If there is a registered device driver, pass on the remove */
+	if (fdev->driver) {
+		printk(KERN_INFO "fs_sdio_remove: Free IRQ and remove device "
+		       "driver\n");
+		/* Unregister the IRQ handler first. */
+		sdio_claim_host(fdev->func);
+		sdio_release_irq(func);
+		sdio_release_host(fdev->func);
+
+		fdev->driver->remove(fdev);
+	}
+
+	/* Unregister the card context from the MMC driver. */
+	sdio_set_drvdata(func, NULL);
+
+	/* Invalidate the global to our context. */
+	available_sdio_dev = NULL;
+	kfree(fdev);
+}
+
+static int fs_unifi_init(void)
+{
+	struct regulator_unifi *reg_unifi;
+	struct regulator *reg;
+	int err = 0;
+
+	plat_data = get_unifi_plat_data();
+	fsl_mmc_host = mxc_mmc_get_host(plat_data->host_id);
+	if (!fsl_mmc_host || !plat_data)
+		return -ENOENT;
+
+	reg_unifi = kzalloc(sizeof(struct regulator_unifi), GFP_KERNEL);
+
+	reg = regulator_get(NULL, plat_data->reg_gpo1);
+	if (reg != ERR_PTR(-ENOENT))
+		reg_unifi->reg_gpo1 = reg;
+	else {
+		err = -EINVAL;
+		goto err_reg_gpo1;
+	}
+
+	reg = regulator_get(NULL, plat_data->reg_gpo2);
+	if (reg != ERR_PTR(-ENOENT))
+		reg_unifi->reg_gpo2 = reg;
+	else {
+		err = -EINVAL;
+		goto err_reg_gpo2;
+	}
+
+	reg = regulator_get(NULL, plat_data->reg_1v5_ana_bb);
+	if (reg != ERR_PTR(-ENOENT))
+		reg_unifi->reg_1v5_ana_bb = reg;
+	else {
+		err = -EINVAL;
+		goto err_reg_1v5_ana_bb;
+	}
+
+	reg = regulator_get(NULL, plat_data->reg_vdd_vpa);
+	if (reg != ERR_PTR(-ENOENT))
+		reg_unifi->reg_vdd_vpa = reg;
+	else {
+		err = -EINVAL;
+		goto err_reg_vdd_vpa;
+	}
+
+	reg = regulator_get(NULL, plat_data->reg_1v5_dd);
+	if (reg != ERR_PTR(-ENOENT))
+		reg_unifi->reg_1v5_dd = reg;
+	else {
+		err = -EINVAL;
+		goto err_reg_1v5_dd;
+	}
+
+	plat_data->priv = reg_unifi;
+	return 0;
+
+err_reg_1v5_dd:
+	regulator_put(reg_unifi->reg_vdd_vpa, NULL);
+err_reg_vdd_vpa:
+	regulator_put(reg_unifi->reg_1v5_ana_bb, NULL);
+err_reg_1v5_ana_bb:
+	regulator_put(reg_unifi->reg_gpo2, NULL);
+err_reg_gpo2:
+	regulator_put(reg_unifi->reg_gpo1, NULL);
+err_reg_gpo1:
+	kfree(reg_unifi);
+	return err;
+}
+
+int fs_unifi_remove(void)
+{
+	struct regulator_unifi *reg_unifi;
+
+	reg_unifi = plat_data->priv;
+	plat_data->priv = NULL;
+
+	regulator_put(reg_unifi->reg_1v5_dd, NULL);
+	regulator_put(reg_unifi->reg_vdd_vpa, NULL);
+	regulator_put(reg_unifi->reg_1v5_ana_bb, NULL);
+	regulator_put(reg_unifi->reg_gpo2, NULL);
+	regulator_put(reg_unifi->reg_gpo1, NULL);
+	kfree(reg_unifi);
+	return 0;
+}
+
+/* Module init and exit, register and unregister to the SDIO/MMC driver */
+static int __init fs_sdio_init(void)
+{
+	int err;
+
+	printk(KERN_INFO "Freescale: Register to MMC/SDIO driver\n");
+	/* Sleep a bit - otherwise if the mmc subsystem has just started, it
+	 * will allow us to register, then immediatly remove us!
+	 */
+	msleep(10);
+	err = fs_unifi_init();
+	if (err) {
+		printk(KERN_ERR "Error: fs_unifi_init failed!\n");
+		return err;
+	}
+	err = sdio_register_driver(&sdio_unifi_driver);
+	if (err) {
+		printk(KERN_ERR "Error: register sdio_unifi_driver failed!\n");
+		fs_unifi_remove();
+	}
+	return err;
+}
+
+module_init(fs_sdio_init);
+
+static void __exit fs_sdio_exit(void)
+{
+	printk(KERN_INFO "Freescale: Unregister from MMC/SDIO driver\n");
+	sdio_unregister_driver(&sdio_unifi_driver);
+	fs_unifi_remove();
+}
+
+module_exit(fs_sdio_exit);
+
+MODULE_DESCRIPTION("Freescale SDIO glue driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mmc/card/unifi_fs/fs_sdio_api.h b/drivers/mmc/card/unifi_fs/fs_sdio_api.h
new file mode 100644
index 0000000..1f0c570
--- /dev/null
+++ b/drivers/mmc/card/unifi_fs/fs_sdio_api.h
@@ -0,0 +1,60 @@
+/*
+ * Freescale SDIO glue module API.
+ *
+ * Copyright (C) 2008 Cambridge Silicon Radio Ltd.
+ *
+ */
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#ifndef _FS_SDIO_API_H
+#define _FS_SDIO_API_H
+
+struct sdio_dev;
+
+struct fs_driver {
+	const char *name;
+	int (*probe)(struct sdio_dev *fdev);
+	void (*remove)(struct sdio_dev *fdev);
+	void (*card_int_handler)(struct sdio_dev *fdev);
+	void (*suspend)(struct sdio_dev *fdev, pm_message_t state);
+	void (*resume)(struct sdio_dev *fdev);
+};
+
+int fs_sdio_readb(struct sdio_dev *fdev, int funcnum,
+		  unsigned long addr, unsigned char *pdata);
+int fs_sdio_writeb(struct sdio_dev *fdev, int funcnum,
+		   unsigned long addr, unsigned char data);
+int fs_sdio_block_rw(struct sdio_dev *fdev, int funcnum,
+		     unsigned long addr, unsigned char *pdata,
+		     unsigned int count, int direction);
+
+int fs_sdio_register_driver(struct fs_driver *driver);
+void fs_sdio_unregister_driver(struct fs_driver *driver);
+int fs_sdio_set_block_size(struct sdio_dev *fdev, int blksz);
+int fs_sdio_set_max_clock_speed(struct sdio_dev *fdev, int max_khz);
+int fs_sdio_enable_interrupt(struct sdio_dev *fdev, int enable);
+int fs_sdio_enable(struct sdio_dev *fdev);
+int fs_sdio_hard_reset(struct sdio_dev *fdev);
+
+struct sdio_dev {
+	/**< Device driver for this module. */
+	struct fs_driver *driver;
+
+	struct sdio_func *func;
+
+	/**< Data private to the device driver. */
+	void *drv_data;
+
+	int int_enabled;
+	spinlock_t lock;
+
+	uint16_t vendor_id;     /**< Vendor ID of the card. */
+	uint16_t device_id;     /**< Device ID of the card. */
+
+	/**< Maximum block size supported. */
+	int max_blocksize;
+};
+
+
+#endif	/* #ifndef _FS_SDIO_API_H */
diff --git a/drivers/mmc/host/mxc_mmc.c b/drivers/mmc/host/mxc_mmc.c
index 8b22ac4..0e0e4e3 100644
--- a/drivers/mmc/host/mxc_mmc.c
+++ b/drivers/mmc/host/mxc_mmc.c
@@ -291,6 +291,11 @@ struct mxcmci_host {
 	unsigned int mxc_mmc_suspend_flag;
 
 	/*!
+	 * sdio_irq enable/disable ref count
+	 */
+	int sdio_irq_cnt;
+
+	/*!
 	 * Platform specific data
 	 */
 	struct mxc_mmc_platform_data *plat_data;
@@ -307,6 +312,18 @@ static int mxcmci_data_done(struct mxcmci_host *host, unsigned int stat);
 /* Wait count to start the clock */
 #define CMD_WAIT_CNT 100
 
+#define MAX_HOST 10
+static struct mmc_host *hosts[MAX_HOST];
+
+struct mmc_host *mxc_mmc_get_host(int id)
+{
+	if (id < MAX_HOST)
+		return hosts[id];
+	else
+		return NULL;
+}
+EXPORT_SYMBOL(mxc_mmc_get_host);
+
 /*!
  * This function sets the SDHC register to stop the clock and waits for the
  * clock stop indication.
@@ -1053,13 +1070,20 @@ static void mxcmci_enable_sdio_irq(struct mmc_host *mmc, int enable)
 	unsigned long flags;
 
 	spin_lock_irqsave(&host->lock, flags);
-	intctrl = __raw_readl(host->base + MMC_INT_CNTR);
-	intctrl &= ~INT_CNTR_SDIO_IRQ_EN;
 
 	if (enable)
-		intctrl |= INT_CNTR_SDIO_IRQ_EN;
+		host->sdio_irq_cnt++;
+	else
+		host->sdio_irq_cnt--;
+
+	if (host->sdio_irq_cnt == 1 || host->sdio_irq_cnt == 0) {
+		intctrl = __raw_readl(host->base + MMC_INT_CNTR);
+		intctrl &= ~INT_CNTR_SDIO_IRQ_EN;
+		if (host->sdio_irq_cnt)
+			intctrl |= INT_CNTR_SDIO_IRQ_EN;
+		__raw_writel(intctrl, host->base + MMC_INT_CNTR);
+	}
 
-	__raw_writel(intctrl, host->base + MMC_INT_CNTR);
 	spin_unlock_irqrestore(&host->lock, flags);
 }
 
@@ -1223,25 +1247,26 @@ static int mxcmci_probe(struct platform_device *pdev)
 		goto out3;
 	}
 
-	host->detect_irq = platform_get_irq(pdev, 1);
-	if (!host->detect_irq) {
-		goto out3;
-	}
+	if (!host->plat_data->card_fixed) {
+		host->detect_irq = platform_get_irq(pdev, 1);
+		if (!host->detect_irq)
+			goto out3;
 
-	do {
-		card_gpio_status = host->plat_data->status(host->mmc->parent);
-		if (card_gpio_status) {
-			set_irq_type(host->detect_irq, IRQT_FALLING);
-		} else {
-			set_irq_type(host->detect_irq, IRQT_RISING);
-		}
-	} while (card_gpio_status !=
-		 host->plat_data->status(host->mmc->parent));
+		do {
+			card_gpio_status =
+				host->plat_data->status(host->mmc->parent);
+			if (card_gpio_status)
+				set_irq_type(host->detect_irq, IRQT_FALLING);
+			else
+				set_irq_type(host->detect_irq, IRQT_RISING);
 
-	ret =
-	    request_irq(host->detect_irq, mxcmci_gpio_irq, 0, pdev->name, host);
-	if (ret) {
-		goto out3;
+		} while (card_gpio_status !=
+			 host->plat_data->status(host->mmc->parent));
+
+		ret = request_irq(host->detect_irq, mxcmci_gpio_irq, 0,
+				  pdev->name, host);
+		if (ret)
+			goto out3;
 	}
 
 	mxcmci_softreset(host);
@@ -1265,6 +1290,8 @@ static int mxcmci_probe(struct platform_device *pdev)
 	}
 
 	printk(KERN_INFO "%s-%d found\n", pdev->name, pdev->id);
+	if (host->id < MAX_HOST)
+		hosts[host->id] = host->mmc;
 
 	return 0;
 
@@ -1302,6 +1329,7 @@ static int mxcmci_remove(struct platform_device *pdev)
 	if (mmc) {
 		struct mxcmci_host *host = mmc_priv(mmc);
 
+		hosts[host->id] = NULL;
 		mmc_remove_host(mmc);
 		free_irq(host->irq, host);
 		free_irq(host->detect_irq, host);
diff --git a/include/asm-arm/arch-mxc/mmc.h b/include/asm-arm/arch-mxc/mmc.h
index 3d904c7..cfb7828 100644
--- a/include/asm-arm/arch-mxc/mmc.h
+++ b/include/asm-arm/arch-mxc/mmc.h
@@ -19,7 +19,9 @@ struct mxc_mmc_platform_data {
 	unsigned int ocr_mask;	/* available voltages */
 	unsigned int min_clk;
 	unsigned int max_clk;
-	unsigned int card_inserted_state;
+	unsigned int reserved:16;
+	unsigned int card_fixed:1;
+	unsigned int card_inserted_state:1;
 //      u32 (*translate_vdd)(struct device *, unsigned int);
 	unsigned int (*status) (struct device *);
 	int (*wp_status) (void);
diff --git a/include/asm-arm/arch-mxc/mxc.h b/include/asm-arm/arch-mxc/mxc.h
index 02e1de6..e4c85b8 100644
--- a/include/asm-arm/arch-mxc/mxc.h
+++ b/include/asm-arm/arch-mxc/mxc.h
@@ -173,6 +173,21 @@ struct mxc_keyp_platform_data {
 	void (*inactive) (void);
 };
 
+struct mxc_unifi_platform_data {
+	void (*hardreset) (void);
+
+	/* power parameters */
+	char *reg_gpo1;
+	char *reg_gpo2;
+	char *reg_1v5_ana_bb;
+	char *reg_vdd_vpa;
+	char *reg_1v5_dd;
+
+	int host_id;
+
+	void *priv;
+};
+
 struct mxc_gps_platform_data {
 	char *core_reg;
 	char *analog_reg;
@@ -196,6 +211,8 @@ struct platform_device;
 void mxc_pg_enable(struct platform_device *pdev);
 void mxc_pg_disable(struct platform_device *pdev);
 
+struct mxc_unifi_platform_data *get_unifi_plat_data(void);
+
 #endif				/* __ASSEMBLY__ */
 
 #define MUX_IO_P		29
-- 
1.5.4.4

