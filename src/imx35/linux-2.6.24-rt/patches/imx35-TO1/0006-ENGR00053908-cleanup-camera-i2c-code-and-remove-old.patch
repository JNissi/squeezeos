From 935d708422df416c20ed99cd2977422fc3a982ce Mon Sep 17 00:00:00 2001
From: Rob Herring <r.herring@freescale.com>
Date: Thu, 14 Feb 2008 14:42:10 -0600
Subject: [PATCH] ENGR00053908 cleanup camera i2c code and remove old sensors

This patch removes old camera sensors and cleans up
the camera i2c code to use the standard i2c_smbus_xxx functions.
---
 drivers/media/video/mxc/capture/Kconfig    |   26 +-
 drivers/media/video/mxc/capture/hv7161.c   |  434 ---------------------
 drivers/media/video/mxc/capture/hv7161.h   |   38 --
 drivers/media/video/mxc/capture/mc521da.c  |   78 +----
 drivers/media/video/mxc/capture/mt9v111.c  |   86 +----
 drivers/media/video/mxc/capture/s5k3aaex.c |  572 ----------------------------
 drivers/media/video/mxc/capture/s5k3aaex.h |   88 -----
 include/asm-arm/arch-mxc/mxc_i2c.h         |  111 ------
 8 files changed, 34 insertions(+), 1399 deletions(-)

diff --git a/drivers/media/video/mxc/capture/Kconfig b/drivers/media/video/mxc/capture/Kconfig
index 3528719..bf40f0e 100644
--- a/drivers/media/video/mxc/capture/Kconfig
+++ b/drivers/media/video/mxc/capture/Kconfig
@@ -8,7 +8,7 @@ config VIDEO_MXC_IPU_CAMERA
 
 config VIDEO_MXC_EMMA_CAMERA
 	tristate "MX27 eMMA support"
-	depends on VIDEO_MXC_CAMERA && MXC_EMMA && FB_MXC_SYNC_PANEL && (MXC_CAMERA_MICRON111 || MXC_CAMERA_MC521DA)
+	depends on VIDEO_MXC_CAMERA && MXC_EMMA && FB_MXC_SYNC_PANEL
 	select VIDEO_MXC_OPL
 	default y
 
@@ -25,37 +25,25 @@ config VIDEO_MXC_CSI_DMA
 choice
 	prompt "Select Camera"
 	default MXC_CAMERA_MICRON111
-	depends on (VIDEO_MXC_CAMERA && I2C_MXC)
+	depends on VIDEO_MXC_CAMERA
 
 config MXC_CAMERA_MC521DA
 	tristate "Magnachip mc521da camera support"
-	depends on ((!MACH_I30030ADS) && (!MACH_MXC30030ADS))
+	select I2C_MXC
 	---help---
 	  If you plan to use the mc521da Camera with your MXC system, say Y here.
 
 config MXC_CAMERA_MICRON111
 	tristate "Micron mt9v111 camera support"
-	depends on ((!MACH_I30030ADS) && (!MACH_MXC30030ADS))
+	select I2C_MXC
 	---help---
 	  If you plan to use the mt9v111 Camera with your MXC system, say Y here.
 
-config MXC_CAMERA_S5K3AAEX
-	tristate "Sumsung s5k3aaex camera support"
-	depends on ((MACH_I30030ADS || MACH_MXC30030ADS))
-	---help---
-	  If you plan to use the s5k3aaex Camera with your MXC system, say Y here.
-	  Will be replaced by Magna hv7161.
-
-config MXC_CAMERA_HV7161
-	tristate "Magna Hv7161 camera support"
-	depends on ((MACH_I30030ADS || MACH_MXC30030ADS))
-	---help---
-	  If you plan to use the magna hv7161 Camera with your MXC system, say Y here.
 endchoice
 
 config MXC_IPU_PRP_VF_SDC
 	tristate "Pre-Processor VF SDC library"
-	depends on (VIDEO_MXC_IPU_CAMERA && FB_MXC_SYNC_PANEL && (MXC_CAMERA_MC521DA || MXC_CAMERA_MICRON111 || MXC_CAMERA_S5K3AAEX || MXC_CAMERA_HV7161))
+	depends on VIDEO_MXC_IPU_CAMERA && FB_MXC_SYNC_PANEL
 	default y
 	---help---
 	  Use case PRP_VF_SDC:
@@ -68,7 +56,7 @@ config MXC_IPU_PRP_VF_SDC
 
 config MXC_IPU_PRP_VF_ADC
 	tristate "Pre-Processor VF ADC library"
-	depends on (VIDEO_MXC_IPU_CAMERA && FB_MXC_ASYNC_PANEL && (MXC_CAMERA_MC521DA || MXC_CAMERA_MICRON111 || MXC_CAMERA_S5K3AAEX || MXC_CAMERA_HV7161))
+	depends on VIDEO_MXC_IPU_CAMERA && FB_MXC_ASYNC_PANEL
 	default y
 	---help---
 	  Use case PRP_VF_ADC:
@@ -78,7 +66,7 @@ config MXC_IPU_PRP_VF_ADC
 
 config MXC_IPU_PRP_ENC
 	tristate "Pre-processor Encoder library"
-	depends on (VIDEO_MXC_IPU_CAMERA && (MXC_CAMERA_MC521DA || MXC_CAMERA_MICRON111 || MXC_CAMERA_S5K3AAEX || MXC_CAMERA_HV7161))
+	depends on VIDEO_MXC_IPU_CAMERA
 	default y
 	---help---
 	  Use case PRP_ENC:
diff --git a/drivers/media/video/mxc/capture/hv7161.c b/drivers/media/video/mxc/capture/hv7161.c
deleted file mode 100644
index 2ba0f92..0000000
--- a/drivers/media/video/mxc/capture/hv7161.c
+++ /dev/null
@@ -1,434 +0,0 @@
-/*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-/*!
- * @file hv7161.c
- *
- * @brief hv7161 camera driver functions
- *
- * @ingroup Camera
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/ctype.h>
-#include <linux/types.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/i2c.h>
-#include "asm/arch/mxc_i2c.h"
-#include "hv7161.h"
-#include "mxc_v4l2_capture.h"
-
-#define HV7161_TERM 0xFF
-
-static sensor_interface *interface_param = NULL;
-static int reset_frame_rate = 30;
-
-static hv7161_image_format format[2] = {
-	{
-	 .index = 0,
-	 .width = 1280,
-	 .height = 960,
-	 },
-	{
-	 .index = 1,
-	 .width = 640,
-	 .height = 480,
-	 },
-};
-
-const static struct hv7161_reg hv7161_common[] = {
-	{0x31, 0x20}, {0x32, 0x3}, {0xee, 0x3},
-	{HV7161_TERM, HV7161_TERM}
-};
-
-static int hv7161_attach(struct i2c_adapter *adapter);
-static int hv7161_detach(struct i2c_client *client);
-
-static struct i2c_driver hv7161_i2c_driver = {
-	.owner = THIS_MODULE,
-	.name = "HV7161 Client",
-	.flags = I2C_DF_NOTIFY,
-	.attach_adapter = hv7161_attach,
-	.detach_client = hv7161_detach,
-};
-
-static struct i2c_client hv7161_i2c_client = {
-	.name = "hv7161 I2C dev",
-	.id = 1,
-	.addr = HV7161_I2C_ADDRESS,
-	.driver = &hv7161_i2c_driver,
-};
-
-extern void gpio_sensor_setup(void);
-extern void gpio_sensor_reset(bool flag);
-extern void gpio_sensor_suspend(bool flag);
-
-/*
- * Function definitions
- */
-static int hv7161_i2c_client_xfer(unsigned int addr, char *reg,
-				  int reg_len, char *buf, int num,
-				  int tran_flag)
-{
-	struct i2c_msg msg[2];
-	int ret;
-
-	msg[0].addr = addr;
-	msg[0].len = reg_len;
-	msg[0].buf = reg;
-	msg[0].flags = tran_flag;
-	msg[0].flags &= ~I2C_M_RD;
-
-	msg[1].addr = addr;
-	msg[1].len = num;
-	msg[1].buf = buf;
-	msg[1].flags = tran_flag;
-
-	if (tran_flag & MXC_I2C_FLAG_READ) {
-		msg[1].flags |= I2C_M_RD;
-	} else {
-		msg[1].flags &= ~I2C_M_RD;
-	}
-
-	ret = i2c_transfer(hv7161_i2c_client.adapter, msg, 2);
-	if (ret >= 0)
-		return 0;
-
-	return ret;
-}
-
-static int hv7161_read_reg(u8 * reg, u8 * val)
-{
-	return hv7161_i2c_client_xfer(HV7161_I2C_ADDRESS, reg, 1, val, 1,
-				      MXC_I2C_FLAG_READ);
-}
-
-static int hv7161_write_reg(u8 reg, u8 val)
-{
-	u8 temp1, temp2;
-	temp1 = reg;
-	temp2 = val;
-	return hv7161_i2c_client_xfer(HV7161_I2C_ADDRESS, &temp1, 1, &temp2,
-				      1, 0);
-}
-
-static int hv7161_write_regs(const struct hv7161_reg reglist[])
-{
-	int err;
-	const struct hv7161_reg *next = reglist;
-
-	while (!((next->reg == HV7161_TERM) && (next->val == HV7161_TERM))) {
-		err = hv7161_write_reg(next->reg, next->val);
-		if (err) {
-			return err;
-		}
-		next++;
-	}
-	return 0;
-}
-
-/*!
- * hv7161 sensor downscale function
- * @param downscale            bool
- * @return  Error code indicating success or failure
- */
-static u8 hv7161_sensor_downscale(bool downscale)
-{
-	u8 error = 0;
-	u8 reg, data;
-
-	if (downscale == true) {
-		reg = 0x1;
-		data = 0x16;
-		hv7161_write_reg(reg, data);
-	} else {
-		reg = 0x1;
-		data = 0x13;
-		hv7161_write_reg(reg, data);
-	}
-
-	hv7161_write_regs(hv7161_common);
-
-	return error;
-}
-
-/*!
- * hv7161 sensor interface Initialization
- * @param param            sensor_interface *
- * @param width            u32
- * @param height           u32
- * @return  None
- */
-static void hv7161_interface(sensor_interface * param, u32 width, u32 height)
-{
-	param->clk_mode = 0x0;	//gated
-	param->pixclk_pol = 0x0;
-	param->data_width = 0x1;
-	param->data_pol = 0x0;
-	param->ext_vsync = 0x1;
-	param->Vsync_pol = 0x1;
-	param->Hsync_pol = 0x1;
-	param->width = width - 1;
-	param->height = height - 1;
-	param->pixel_fmt = IPU_PIX_FMT_UYVY;
-}
-
-/*!
- * hv7161 sensor configuration
- *
- * @param frame_rate       int 	*
- * @param high_quality     int
- * @return  sensor_interface *
- */
-static sensor_interface *hv7161_config(int *frame_rate, int high_quality)
-{
-	u8 reg, data;
-	int num_clock_per_row;
-	u16 h_blank;
-	int max_rate = 0;
-	int index = 1;
-
-	if (high_quality == 1)
-		index = 0;
-
-	hv7161_interface(interface_param, format[index].width,
-			 format[index].height);
-
-	if (index == 0) {
-		pr_info("SXGA\n");
-		hv7161_sensor_downscale(false);
-	} else {
-		pr_info("VGA\n");
-		hv7161_sensor_downscale(true);
-	}
-
-	num_clock_per_row = format[0].width + 208;
-	max_rate = interface_param->mclk / (num_clock_per_row *
-					    (format[0].height + 8));
-
-	if ((*frame_rate > max_rate) || (*frame_rate == 0)) {
-		*frame_rate = max_rate;
-	}
-
-	num_clock_per_row = interface_param->mclk / *frame_rate;
-	num_clock_per_row /= format[0].height + 8;
-	h_blank = num_clock_per_row - format[0].width;
-	reg = 0x11;
-	data = (u8) (h_blank & 0xff);
-	hv7161_write_reg(reg, data);
-	reg = 0x10;
-	data = (u8) ((h_blank >> 8) & 0xff);
-	hv7161_write_reg(reg, data);
-
-	reset_frame_rate = *frame_rate;
-
-	return interface_param;
-}
-
-/*!
- * hv7161 sensor set color configuration
- *
- * @param bright       int
- * @param saturation   int
- * @param red          int
- * @param green        int
- * @param blue         int
- * @return  None
- */
-static void
-hv7161_set_color(int bright, int saturation, int red, int green, int blue)
-{
-	u8 reg;
-	u8 data;
-
-	// set Brightness
-	reg = 0x5b;
-	data = (u8) bright;
-	hv7161_write_reg(reg, data);
-	// set Saturation
-	reg = 0x5c;
-	data = (u8) saturation;
-	hv7161_write_reg(reg, data);
-	// set Red
-	reg = 0x14;
-	data = (u8) red;
-	hv7161_write_reg(reg, data);
-	// set Green
-	reg = 0x15;
-	data = (u8) green;
-	hv7161_write_reg(reg, data);
-	// set Blue
-	reg = 0x16;
-	data = (u8) blue;
-	hv7161_write_reg(reg, data);
-}
-
-/*!
- * hv7161 sensor get color configuration
- *
- * @param bright       int *
- * @param saturation   int *
- * @param red          int *
- * @param green        int *
- * @param blue         int *
- * @return  None
- */
-static void
-hv7161_get_color(int *bright, int *saturation, int *red, int *green, int *blue)
-{
-	u8 reg[1];
-	u8 *pdata;
-
-	// get Brightness
-	reg[0] = 0x5b;
-	pdata = (u8 *) bright;
-	hv7161_read_reg(reg, pdata);
-	// get saturation
-	reg[0] = 0x5c;
-	pdata = (u8 *) saturation;
-	hv7161_read_reg(reg, pdata);
-	// get Red
-	reg[0] = 0x14;
-	pdata = (u8 *) red;
-	hv7161_read_reg(reg, pdata);
-	// get Green
-	reg[0] = 0x15;
-	pdata = (u8 *) red;
-	hv7161_read_reg(reg, pdata);
-	// get Blue
-	reg[0] = 0x16;
-	pdata = (u8 *) blue;
-	hv7161_read_reg(reg, pdata);
-}
-
-/*!
- * hv7161 Reset function
- *
- * @return  None
- */
-static sensor_interface *hv7161_reset(void)
-{
-	set_mclk_rate(&interface_param->mclk);
-
-	/* Reset for at least 4 cycles */
-	gpio_sensor_reset(true);
-	msleep(10);
-	gpio_sensor_reset(false);
-	msleep(10);
-
-	hv7161_config(&reset_frame_rate, 0);
-	return interface_param;
-}
-
-struct camera_sensor camera_sensor_if = {
-      set_color:hv7161_set_color,
-      get_color:hv7161_get_color,
-      config:hv7161_config,
-      reset:hv7161_reset,
-};
-
-/*!
- * hv7161 I2C attach function
- *
- * @param adapter            struct i2c_adapter *
- * @return  Error code indicating success or failure
- */
-static int hv7161_attach(struct i2c_adapter *adapter)
-{
-	if (strcmp(adapter->name, MXC_ADAPTER_NAME) != 0) {
-		printk(KERN_ERR "hv7161_attach: %s\n", adapter->name);
-		return -1;
-	}
-
-	hv7161_i2c_client.adapter = adapter;
-	if (i2c_attach_client(&hv7161_i2c_client)) {
-		hv7161_i2c_client.adapter = NULL;
-		printk(KERN_ERR "hv7161_attach: i2c_attach_client failed\n");
-		return -1;
-	}
-
-	interface_param = (sensor_interface *)
-	    kmalloc(sizeof(sensor_interface), GFP_KERNEL);
-	if (!interface_param) {
-		printk(KERN_ERR "hv7161_attach: kmalloc failed \n");
-		return -1;
-	}
-
-	gpio_sensor_setup();
-
-	gpio_sensor_suspend(false);
-
-	interface_param->mclk = 0x2a00000;
-
-	return 0;
-}
-
-/*!
- * hv7161 I2C detach function
- *
- * @param client            struct i2c_client *
- * @return  Error code indicating success or failure
- */
-static int hv7161_detach(struct i2c_client *client)
-{
-	int err;
-
-	if (!hv7161_i2c_client.adapter)
-		return -1;
-
-	err = i2c_detach_client(&hv7161_i2c_client);
-	hv7161_i2c_client.adapter = NULL;
-
-	if (interface_param)
-		kfree(interface_param);
-	interface_param = NULL;
-
-	return err;
-}
-
-/*!
- * hv7161 init function
- *
- * @return  Error code indicating success or failure
- */
-static __init int hv7161_init(void)
-{
-	u8 err;
-
-	err = i2c_add_driver(&hv7161_i2c_driver);
-
-	return err;
-}
-
-/*!
- * hv7161 cleanup function
- *
- * @return  Error code indicating success or failure
- */
-static void __exit hv7161_clean(void)
-{
-	i2c_del_driver(&hv7161_i2c_driver);
-}
-
-module_init(hv7161_init);
-module_exit(hv7161_clean);
-
-/* Exported symbols for modules. */
-EXPORT_SYMBOL(camera_sensor_if);
-
-MODULE_AUTHOR("Freescale Semiconductor, Inc.");
-MODULE_DESCRIPTION("hv7161 Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/mxc/capture/hv7161.h b/drivers/media/video/mxc/capture/hv7161.h
deleted file mode 100644
index 26c5bd6..0000000
--- a/drivers/media/video/mxc/capture/hv7161.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-/*!
- * @file hv7161.h
- *
- * @brief HV7161 Camera Header file
- *
- * @ingroup Camera
- */
-
-#ifndef __HV7161_H__
-#define __HV7161_H__
-
-#define HV7161_I2C_ADDRESS	0x11
-
-typedef struct {
-	u8 index;
-	u16 width;
-	u16 height;
-} hv7161_image_format;
-
-struct hv7161_reg {
-	u8 reg;
-	u8 val;
-};
-
-#endif				/* __HV7161_H__ */
diff --git a/drivers/media/video/mxc/capture/mc521da.c b/drivers/media/video/mxc/capture/mc521da.c
index a3bcb83..ebd2257 100644
--- a/drivers/media/video/mxc/capture/mc521da.c
+++ b/drivers/media/video/mxc/capture/mc521da.c
@@ -28,7 +28,6 @@
 #include <linux/device.h>
 #include <linux/i2c.h>
 #include <linux/clk.h>
-#include <asm/arch/mxc_i2c.h>
 #include "mxc_v4l2_capture.h"
 
 #define MC521DA_I2C_ADDRESS	0x22
@@ -272,53 +271,14 @@ static struct i2c_client mc521da_i2c_client = {
 	.driver = &mc521da_i2c_driver,
 };
 
-/*
- * Function definitions
- */
-static int mc521da_i2c_client_xfer(unsigned int addr, char *reg,
-				   int reg_len, char *buf, int num,
-				   int tran_flag)
+static inline int mc521da_read_reg(u8 reg)
 {
-	struct i2c_msg msg[2];
-	int ret;
-
-	msg[0].addr = addr;
-	msg[0].len = reg_len;
-	msg[0].buf = reg;
-	msg[0].flags = tran_flag;
-	msg[0].flags &= ~I2C_M_RD;
-
-	msg[1].addr = addr;
-	msg[1].len = num;
-	msg[1].buf = buf;
-	msg[1].flags = tran_flag;
-
-	if (tran_flag & MXC_I2C_FLAG_READ) {
-		msg[1].flags |= I2C_M_RD;
-	} else {
-		msg[1].flags &= ~I2C_M_RD;
-	}
-
-	ret = i2c_transfer(mc521da_i2c_client.adapter, msg, 2);
-	if (ret >= 0)
-		return 0;
-
-	return ret;
+	return i2c_smbus_read_byte_data(&mc521da_i2c_client, reg);
 }
 
-static int mc521da_read_reg(u8 * reg, u8 * val)
+static inline int mc521da_write_reg(u8 reg, u8 val)
 {
-	return mc521da_i2c_client_xfer(MC521DA_I2C_ADDRESS, reg, 1, val, 1,
-				       MXC_I2C_FLAG_READ);
-}
-
-static int mc521da_write_reg(u8 reg, u8 val)
-{
-	u8 temp1, temp2;
-	temp1 = reg;
-	temp2 = val;
-	return mc521da_i2c_client_xfer(MC521DA_I2C_ADDRESS, &temp1, 1, &temp2,
-				       1, 0);
+	return i2c_smbus_write_byte_data(&mc521da_i2c_client, reg, val);
 }
 
 static int mc521da_write_regs(const struct mc521da_reg reglist[])
@@ -343,7 +303,7 @@ static int mc521da_write_regs(const struct mc521da_reg reglist[])
  */
 static u8 mc521da_sensor_downscale(bool downscale)
 {
-	u8 reg[1], data;
+	u8 data;
 	u32 i = 0;
 
 	if (downscale == true) {
@@ -357,10 +317,9 @@ static u8 mc521da_sensor_downscale(bool downscale)
 		mc521da_write_reg(0x00, 0x8C);
 
 		/* Wait for changes to take effect */
-		reg[0] = 0x00;
 		while (i < 256) {
 			i++;
-			mc521da_read_reg(reg, &data);
+			data = mc521da_read_reg(0x00);
 			if ((data & 0x80) == 0)
 				break;
 			msleep(5);
@@ -388,10 +347,9 @@ static u8 mc521da_sensor_downscale(bool downscale)
 		mc521da_write_reg(0x00, 0x84);
 
 		/* Wait for changes to take effect */
-		reg[0] = 0x00;
 		while (i < 256) {
 			i++;
-			mc521da_read_reg(reg, &data);
+			data = mc521da_read_reg(0x00);
 			if ((data & 0x80) == 0)
 				break;
 			msleep(5);
@@ -550,29 +508,15 @@ mc521da_set_color(int bright, int saturation, int red, int green, int blue)
 static void
 mc521da_get_color(int *bright, int *saturation, int *red, int *green, int *blue)
 {
-	u8 reg[1];
-	u8 *pdata;
-
 	*saturation = 0;
 
 	/* Select ISP */
 	mc521da_write_reg(0xff, 0x02);
 
-	reg[0] = 0x41;
-	pdata = (u8 *) bright;
-	mc521da_read_reg(reg, pdata);
-
-	reg[0] = 0xCA;
-	pdata = (u8 *) red;
-	mc521da_read_reg(reg, pdata);
-
-	reg[0] = 0xCB;
-	pdata = (u8 *) green;
-	mc521da_read_reg(reg, pdata);
-
-	reg[0] = 0xCC;
-	pdata = (u8 *) blue;
-	mc521da_read_reg(reg, pdata);
+	*bright = mc521da_read_reg(0x41);
+	*red = mc521da_read_reg(0xCA);
+	*green = mc521da_read_reg(0xCB);
+	*blue = mc521da_read_reg(0xCC);
 }
 
 struct camera_sensor camera_sensor_if = {
diff --git a/drivers/media/video/mxc/capture/mt9v111.c b/drivers/media/video/mxc/capture/mt9v111.c
index c34edf0..fe34fad 100644
--- a/drivers/media/video/mxc/capture/mt9v111.c
+++ b/drivers/media/video/mxc/capture/mt9v111.c
@@ -28,7 +28,6 @@
 #include <linux/device.h>
 #include <linux/i2c.h>
 #include <linux/clk.h>
-#include <asm/arch/mxc_i2c.h>
 #include "mxc_v4l2_capture.h"
 #include "mt9v111.h"
 
@@ -77,63 +76,21 @@ static struct i2c_client mt9v111_i2c_client = {
  * Function definitions
  */
 
-static u16 mt9v111_endian_swap16(u16 data)
-{
-	u16 temp;
-
-	temp = data;
-	temp = ((data >> 8) & 0xff) | ((data << 8) & 0xff00);
-
-	return temp;
-}
-
-static int mt9v111_i2c_client_xfer(unsigned int addr, char *reg, int reg_len,
-				   char *buf, int num, int tran_flag)
-{
-	struct i2c_msg msg[2];
-	int ret;
-
-	msg[0].addr = addr;
-	msg[0].len = reg_len;
-	msg[0].buf = reg;
-	msg[0].flags = tran_flag;
-	msg[0].flags &= ~I2C_M_RD;
-
-	msg[1].addr = addr;
-	msg[1].len = num;
-	msg[1].buf = buf;
-	msg[1].flags = tran_flag;
-
-	if (tran_flag & MXC_I2C_FLAG_READ) {
-		msg[1].flags |= I2C_M_RD;
-	} else {
-		msg[1].flags &= ~I2C_M_RD;
-	}
-
-	ret = i2c_transfer(mt9v111_i2c_client.adapter, msg, 2);
-	if (ret >= 0)
-		return 0;
-
-	return ret;
-}
-
 #ifdef MT9V111_DEBUG
-static int mt9v111_read_reg(u8 * reg, u16 * val)
+static inline int mt9v111_read_reg(u8 reg)
 {
-	return mt9v111_i2c_client_xfer(MT9V111_I2C_ADDRESS, reg, 1,
-				       (u8 *) val, 2, MXC_I2C_FLAG_READ);
+	int val = i2c_smbus_read_word_data(&mt9v111_i2c_client, reg);
+	if (val != -1)
+		val = cpu_to_be16(val);
+	return val;
 }
 #endif
 
-static int mt9v111_write_reg(u8 reg, u16 val)
+static inline int mt9v111_write_reg(u8 reg, u16 val)
 {
-	u8 temp1;
-	u16 temp2;
-	temp1 = reg;
-	temp2 = mt9v111_endian_swap16(val);
 	pr_debug("write reg %x val %x.\n", reg, val);
-	return mt9v111_i2c_client_xfer(MT9V111_I2C_ADDRESS, &temp1, 1,
-				       (u8 *) & temp2, 2, 0);
+	return i2c_smbus_write_word_data(&mt9v111_i2c_client, reg,
+					 cpu_to_be16(val));
 }
 
 /*!
@@ -539,42 +496,31 @@ struct camera_sensor camera_sensor_if = {
  */
 static void mt9v111_test_pattern(bool flag)
 {
-	u8 reg;
 	u16 data;
 
 	// switch to sensor registers
-	reg = MT9V111I_ADDR_SPACE_SEL;
-	data = MT9V111I_SEL_SCA;
-	mt9v111_write_reg(reg, data);
+	mt9v111_write_reg(MT9V111I_ADDR_SPACE_SEL, MT9V111I_SEL_SCA);
 
 	if (flag == true) {
 		testpattern = MT9V111S_OUTCTRL_TEST_MODE;
 
-		reg = MT9V111S_ROW_NOISE_CTRL;
-		data = mt9v111_read_reg(&reg, &data) & 0xBF;
-		data = mt9v111_endian_swap16(data);
-		mt9v111_write_reg(reg, data);
+		data = mt9v111_read_reg(MT9V111S_ROW_NOISE_CTRL) & 0xBF;
+		mt9v111_write_reg(MT9V111S_ROW_NOISE_CTRL, data);
 
-		reg = MT9V111S_TEST_DATA;
-		data = 0;
-		mt9v111_write_reg(reg, data);
+		mt9v111_write_reg(MT9V111S_TEST_DATA, 0);
 
-		reg = MT9V111S_OUTPUT_CTRL;
 		// changes take effect
 		data = MT9V111S_OUTCTRL_CHIP_ENABLE | testpattern | 0x3000;
-		mt9v111_write_reg(reg, data);
+		mt9v111_write_reg(MT9V111S_OUTPUT_CTRL, data);
 	} else {
 		testpattern = 0;
 
-		reg = MT9V111S_ROW_NOISE_CTRL;
-		data = mt9v111_read_reg(&reg, &data) | 0x40;
-		data = mt9v111_endian_swap16(data);
-		mt9v111_write_reg(reg, data);
+		data = mt9v111_read_reg(MT9V111S_ROW_NOISE_CTRL) | 0x40;
+		mt9v111_write_reg(MT9V111S_ROW_NOISE_CTRL, data);
 
-		reg = MT9V111S_OUTPUT_CTRL;
 		// changes take effect
 		data = MT9V111S_OUTCTRL_CHIP_ENABLE | testpattern | 0x3000;
-		mt9v111_write_reg(reg, data);
+		mt9v111_write_reg(MT9V111S_OUTPUT_CTRL, data);
 	}
 }
 #endif
diff --git a/drivers/media/video/mxc/capture/s5k3aaex.c b/drivers/media/video/mxc/capture/s5k3aaex.c
deleted file mode 100644
index 455d55e..0000000
--- a/drivers/media/video/mxc/capture/s5k3aaex.c
+++ /dev/null
@@ -1,572 +0,0 @@
-/*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-/*!
- * @file s5k3aaex.c
- *
- * @brief s5k3aaex camera driver functions
- *
- * @ingroup Camera
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/ctype.h>
-#include <linux/types.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/i2c.h>
-#include "asm/arch/mxc_i2c.h"
-#include "s5k3aaex.h"
-#include "mxc_v4l2_capture.h"
-
-static s5k3aaex_conf s5k3aaex_device;
-static sensor_interface *interface_param = NULL;
-
-static int s5k3aaex_attach(struct i2c_adapter *adapter);
-static int s5k3aaex_detach(struct i2c_client *client);
-
-static struct i2c_driver s5k3aaex_i2c_driver = {
-	.owner = THIS_MODULE,
-	.name = "S5K3AAEX Client",
-	.flags = I2C_DF_NOTIFY,
-	.attach_adapter = s5k3aaex_attach,
-	.detach_client = s5k3aaex_detach,
-};
-
-static struct i2c_client s5k3aaex_i2c_client = {
-	.name = "s5k3aaex I2C dev",
-	.id = 1,
-	.addr = S5K3AAEX_I2C_ADDRESS,
-	.driver = &s5k3aaex_i2c_driver,
-};
-
-static s5k3aaex_image_format format[2] = {
-	{
-	 .index = 0,
-	 .imageFormat = S5K3AAEX_OutputResolution_SXGA,
-	 .width = S5K3AAEX_WINWIDTH,
-	 .height = S5K3AAEX_WINHEIGHT,
-	 },
-	{
-	 .index = 1,
-	 .imageFormat = S5K3AAEX_OutputResolution_VGA,
-	 .width = 640,
-	 .height = 512,
-	 },
-};
-
-extern void gpio_sensor_setup(void);
-extern void gpio_sensor_reset(bool flag);
-extern void gpio_sensor_suspend(bool flag);
-
-/*
- * Function definitions
- */
-static int s5k3aaex_i2c_client_xfer(unsigned int addr, char *reg,
-				    int reg_len, char *buf, int num,
-				    int tran_flag)
-{
-	struct i2c_msg msg[2];
-	int ret;
-
-	msg[0].addr = addr;
-	msg[0].len = reg_len;
-	msg[0].buf = reg;
-	msg[0].flags = tran_flag;
-	msg[0].flags &= ~I2C_M_RD;
-
-	msg[1].addr = addr;
-	msg[1].len = num;
-	msg[1].buf = buf;
-	msg[1].flags = tran_flag;
-
-	if (tran_flag & MXC_I2C_FLAG_READ) {
-		msg[1].flags |= I2C_M_RD;
-	} else {
-		msg[1].flags &= ~I2C_M_RD;
-	}
-
-	ret = i2c_transfer(s5k3aaex_i2c_client.adapter, msg, 2);
-	if (ret >= 0)
-		return 0;
-	return ret;
-}
-
-static int s5k3aaex_read_reg(u8 * reg, u8 * val)
-{
-	msleep(100);
-	return s5k3aaex_i2c_client_xfer(S5K3AAEX_I2C_ADDRESS, reg, 1, val, 1,
-					MXC_I2C_FLAG_READ);
-}
-
-static int s5k3aaex_write_reg(u8 reg, u8 val)
-{
-	u8 temp1, temp2;
-	temp1 = reg;
-	temp2 = val;
-	msleep(100);
-	return s5k3aaex_i2c_client_xfer(S5K3AAEX_I2C_ADDRESS, &temp1, 1, &temp2,
-					1, 0);
-}
-
-static u8 s5k3aaex_sensor_downscale(bool downscale)
-{
-	u8 error = 0;
-	u8 reg;
-	u8 data;
-
-	if (downscale == true) {
-		pr_info("VGA\n");
-		reg = 0xEC;
-		data = 0;
-		s5k3aaex_write_reg(reg, data);
-
-		reg = 0x2;
-		data = 0x30;
-		s5k3aaex_write_reg(reg, data);
-	} else {
-		pr_info("SXGA\n");
-		reg = 0xEC;
-		data = 0;
-		s5k3aaex_write_reg(reg, data);
-
-		reg = 0x2;
-		data = 0;
-		s5k3aaex_write_reg(reg, data);
-	}
-
-	return error;
-}
-
-/*!
- * Initialize s5k3aaex_sensor_lib
- * Libarary for Sensor configuration through I2C
- *
- * @param       page0        page0 Registers
- * @param       page2        page2 Registers
- *
- * @return status
- */
-static u8 s5k3aaex_sensor_lib(s5k3aaex_page0 * page0, s5k3aaex_page2 * page2)
-{
-	u8 error = 0;
-	u8 reg;
-	u8 data;
-
-	// changed to ARM command register map page 0
-	reg = 0xEC;
-	data = page0->addressSelect;
-	s5k3aaex_write_reg(reg, data);
-	// set the main clock
-	reg = 0x72;
-	data = page0->mainClock;
-	s5k3aaex_write_reg(reg, data);
-
-	// changed to CIS register map page 02
-	reg = 0xEC;
-	data = page2->addressSelect;
-	s5k3aaex_write_reg(reg, data);
-
-	// write the Hblank width
-	reg = 0x1e;
-	data = (u8) (page2->hblank & 0xFF);
-	s5k3aaex_write_reg(reg, data);
-	reg = 0x1d;
-	data = (u8) ((page2->hblank >> 8) & 0xFF);
-	s5k3aaex_write_reg(reg, data);
-
-	// write the Vblank width
-	reg = 0x18;
-	data = (u8) (page2->vblank & 0xFF);
-	s5k3aaex_write_reg(reg, data);
-	reg = 0x17;
-	data = (u8) ((page2->vblank >> 8) & 0xFF);
-	s5k3aaex_write_reg(reg, data);
-
-	// write the WRP
-	reg = 0x5;
-	data = (u8) (page2->wrp & 0xFF);
-	s5k3aaex_write_reg(reg, data);
-	reg = 0x4;
-	data = (u8) ((page2->wrp >> 8) & 0xFF);
-	s5k3aaex_write_reg(reg, data);
-
-	// write the WCP
-	reg = 0x7;
-	data = (u8) (page2->wcp & 0xFF);
-	s5k3aaex_write_reg(reg, data);
-	reg = 0x6;
-	data = (u8) ((page2->wcp >> 8) & 0xFF);
-	s5k3aaex_write_reg(reg, data);
-
-	// write DEFCOR_MOV_ADC 8 bit
-	reg = 0x2;
-	data = 0x8;
-	s5k3aaex_write_reg(reg, data);
-
-	// changed to ARM command register map page 1
-	reg = 0xEC;
-	data = 1;
-	s5k3aaex_write_reg(reg, data);
-
-	// write size to itu r 601
-	reg = 0x6a;
-	data = 0x5;
-	s5k3aaex_write_reg(reg, data);
-
-	return error;
-}
-
-/*!
- * s5k3aaex sensor interface Initialization
- * @param param            sensor_interface *
- * @param width            u32
- * @param height           u32
- * @return  None
- */
-static void s5k3aaex_interface(sensor_interface * param, u32 width, u32 height)
-{
-	param->clk_mode = 0x0;	//gated
-	param->pixclk_pol = 0x0;
-	param->data_width = 0x1;
-	param->data_pol = 0x0;
-	param->ext_vsync = 0x0;
-	param->Vsync_pol = 0x0;
-	param->Hsync_pol = 0x1;
-	param->width = width - 1;
-	param->height = ((height == 512) ? 480 : height) - 1;
-	param->pixel_fmt = IPU_PIX_FMT_UYVY;
-}
-
-static int s5k3aaex_rate_cal(int *frame_rate, int mclk)
-{
-	int num_clock_per_row;
-	int max_rate = 0;
-	int index = 0;
-	u16 width;
-	u16 height;
-
-	do {
-		s5k3aaex_device.page0->imageFormat = format[index].imageFormat;
-		height = format[index].height;
-		width = format[index++].width;
-		s5k3aaex_device.page2->hblank = S5K3AAEX_HORZBLANK_DEFAULT;
-		s5k3aaex_device.page2->vblank = S5K3AAEX_VERTBLANK_DEFAULT;
-
-		num_clock_per_row = (width + s5k3aaex_device.page2->hblank) * 2;
-		max_rate = mclk / (num_clock_per_row *
-				   (height + s5k3aaex_device.page2->vblank));
-	} while ((index < 2) && (max_rate < *frame_rate));
-
-	s5k3aaex_interface(interface_param, width, height);
-
-	if (max_rate < *frame_rate)
-		*frame_rate = max_rate;
-	if (*frame_rate == 0)
-		*frame_rate = max_rate;
-
-	s5k3aaex_device.page2->vblank = mclk /
-	    (*frame_rate * num_clock_per_row) - height;
-
-	return index;
-}
-
-/*!
- * s5k3aaex sensor configuration
- *
- * @param frame_rate       int *
- * @param high_quality     int
- * @return  sensor_interface *
- */
-static sensor_interface *s5k3aaex_config(int *frame_rate, int high_quality)
-{
-	int index;
-
-	index = s5k3aaex_rate_cal(frame_rate, interface_param->mclk);
-
-	if (index == 1) {
-		s5k3aaex_sensor_downscale(false);
-	} else {
-		s5k3aaex_sensor_downscale(true);
-	}
-
-	s5k3aaex_device.page0->mainClock = interface_param->mclk / 1048576 * 5;
-	s5k3aaex_sensor_lib(s5k3aaex_device.page0, s5k3aaex_device.page2);
-
-	return interface_param;
-}
-
-/*!
- * s5k3aaex sensor set color configuration
- *
- * @param bright       int
- * @param saturation   int
- * @param red          int
- * @param green        int
- * @param blue         int
- * @return  None
- */
-static void s5k3aaex_set_color(int bright, int saturation, int red, int green,
-			       int blue)
-{
-	u8 reg;
-	u8 data;
-
-	reg = 0xEC;
-	data = 0;
-	s5k3aaex_write_reg(reg, data);
-
-	// set Brightness/Color Level balance
-	reg = 0x76;
-	data = (u8) bright;
-	s5k3aaex_write_reg(reg, data);
-	reg = 0x77;
-	data = (u8) saturation;
-	s5k3aaex_write_reg(reg, data);
-
-	reg = 0xEC;
-	data = 1;
-	s5k3aaex_write_reg(reg, data);
-
-	// set Red
-	reg = 0x10;
-	data = (u8) red;
-	s5k3aaex_write_reg(reg, data);
-	// set Blue
-	reg = 0x18;
-	data = (u8) blue;
-	s5k3aaex_write_reg(reg, data);
-}
-
-/*!
- * s5k3aaex sensor get color configuration
- *
- * @param bright       int *
- * @param saturation   int *
- * @param red          int *
- * @param green        int *
- * @param blue         int *
- * @return  None
- */
-static void s5k3aaex_get_color(int *bright, int *saturation, int *red,
-			       int *green, int *blue)
-{
-	u8 reg;
-	u8 data;
-	u8 *pdata;
-
-	reg = 0xEC;
-	data = 0;
-	s5k3aaex_write_reg(reg, data);
-
-	// get Brightness/Color Level balance
-	reg = 0x76;
-	pdata = (u8 *) bright;
-	s5k3aaex_read_reg(&reg, pdata);
-
-	reg = 0x77;
-	pdata = (u8 *) saturation;
-	s5k3aaex_read_reg(&reg, pdata);
-
-	reg = 0xEC;
-	data = 1;
-	s5k3aaex_write_reg(reg, data);
-
-	// get Red
-	reg = 0x10;
-	pdata = (u8 *) red;
-	s5k3aaex_read_reg(&reg, pdata);
-
-	// get Blue
-	reg = 0x18;
-	pdata = (u8 *) blue;
-	s5k3aaex_read_reg(&reg, pdata);
-}
-
-/*!
- * s5k3aaex Reset function
- *
- * @return  None
- */
-static sensor_interface *s5k3aaex_reset(void)
-{
-	set_mclk_rate(&interface_param->mclk);
-
-	/* Reset for 10 cycle */
-	gpio_sensor_reset(true);
-	msleep(10);
-	gpio_sensor_reset(false);
-	msleep(30);
-
-	s5k3aaex_interface(interface_param, format[0].width, format[0].height);
-	return interface_param;
-}
-
-struct camera_sensor camera_sensor_if = {
-      set_color:s5k3aaex_set_color,
-      get_color:s5k3aaex_get_color,
-      config:s5k3aaex_config,
-      reset:s5k3aaex_reset,
-};
-
-#if 0
-static void s5k3aaex_test_pattern(bool flag)
-{
-	u8 reg;
-	u8 data;
-
-	// changed to ARM command register map page 0
-	reg = 0xEC;
-	data = 0;
-	s5k3aaex_write_reg(reg, data);
-
-	if (flag == true) {
-		reg = 0xb;
-		data = 0x1;
-		s5k3aaex_write_reg(reg, data);
-	} else {
-		reg = 0xb;
-		data = 0x0;
-		s5k3aaex_write_reg(reg, data);
-	}
-}
-#endif
-
-/*!
- * s5k3aaex I2C attach function
- *
- * @param adapter            struct i2c_adapter *
- * @return  Error code indicating success or failure
- */
-static int s5k3aaex_attach(struct i2c_adapter *adapter)
-{
-	if (strcmp(adapter->name, MXC_ADAPTER_NAME) != 0) {
-		printk(KERN_ERR "s5k3aaex_attach: %s\n", adapter->name);
-		return -1;
-	}
-
-	s5k3aaex_i2c_client.adapter = adapter;
-	if (i2c_attach_client(&s5k3aaex_i2c_client)) {
-		s5k3aaex_i2c_client.adapter = NULL;
-		printk(KERN_ERR "s5k3aaex_attach: i2c_attach_client failed\n");
-		return -1;
-	}
-
-	interface_param = (sensor_interface *)
-	    kmalloc(sizeof(sensor_interface), GFP_KERNEL);
-	if (!interface_param) {
-		printk(KERN_ERR "s5k3aaex_attach: kmalloc failed \n");
-		return -1;
-	}
-
-	gpio_sensor_setup();
-
-	gpio_sensor_suspend(false);
-
-	interface_param->mclk = 0x2000000;
-
-	return 0;
-}
-
-/*!
- * s5k3aaex I2C detach function
- *
- * @param client            struct i2c_client *
- * @return  Error code indicating success or failure
- */
-static int s5k3aaex_detach(struct i2c_client *client)
-{
-	int err;
-
-	if (!s5k3aaex_i2c_client.adapter)
-		return -1;
-
-	err = i2c_detach_client(&s5k3aaex_i2c_client);
-	s5k3aaex_i2c_client.adapter = NULL;
-
-	if (interface_param)
-		kfree(interface_param);
-	interface_param = NULL;
-
-	return err;
-}
-
-/*!
- * s5k3aaex init function
- *
- * @return  Error code indicating success or failure
- */
-static __init int s5k3aaex_init(void)
-{
-	u8 err = 0;
-
-	s5k3aaex_device.page0 = (s5k3aaex_page0 *)
-	    kmalloc(sizeof(s5k3aaex_page0), GFP_KERNEL);
-
-	if (!s5k3aaex_device.page0)
-		return -1;
-	memset(s5k3aaex_device.page0, 0, sizeof(s5k3aaex_page0));
-	s5k3aaex_device.page0->addressSelect = 0;
-	s5k3aaex_device.page0->functionOnOff = 0x48;
-
-	s5k3aaex_device.page2 = (s5k3aaex_page2 *)
-	    kmalloc(sizeof(s5k3aaex_page2), GFP_KERNEL);
-	if (!s5k3aaex_device.page2) {
-		kfree(s5k3aaex_device.page0);
-		s5k3aaex_device.page0 = NULL;
-		return -1;
-	}
-	memset(s5k3aaex_device.page2, 0, sizeof(s5k3aaex_page2));
-	s5k3aaex_device.page2->addressSelect = 2;
-	s5k3aaex_device.page2->wrp = 14;
-	s5k3aaex_device.page2->wcp = 14;
-
-	s5k3aaex_device.page2->hblank = S5K3AAEX_HORZBLANK_DEFAULT;
-	s5k3aaex_device.page2->vblank = S5K3AAEX_VERTBLANK_DEFAULT;
-
-	err = i2c_add_driver(&s5k3aaex_i2c_driver);
-
-	return err;
-}
-
-/*!
- * s5k3aaex cleanup function
- *
- * @return  Error code indicating success or failure
- */
-static void __exit s5k3aaex_clean(void)
-{
-	i2c_del_driver(&s5k3aaex_i2c_driver);
-
-	if (s5k3aaex_device.page0) {
-		kfree(s5k3aaex_device.page0);
-		s5k3aaex_device.page0 = NULL;
-	}
-
-	if (s5k3aaex_device.page2) {
-		kfree(s5k3aaex_device.page2);
-		s5k3aaex_device.page2 = NULL;
-	}
-}
-
-module_init(s5k3aaex_init);
-module_exit(s5k3aaex_clean);
-
-/* Exported symbols for modules. */
-EXPORT_SYMBOL(camera_sensor_if);
-
-MODULE_AUTHOR("Freescale Semiconductor, Inc.");
-MODULE_DESCRIPTION("s5k3aaex Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/mxc/capture/s5k3aaex.h b/drivers/media/video/mxc/capture/s5k3aaex.h
deleted file mode 100644
index 61bcb15..0000000
--- a/drivers/media/video/mxc/capture/s5k3aaex.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-/*!
- * @file s5k3aaex.h
- *
- * @brief S5K3AAEX Camera Header file
- *
- * It include all the defines for bitmaps operations, also two main structure
- * one for IFP interface structure, other for sensor core registers.
- *
- * @ingroup Camera
- */
-
-#ifndef __S5K3AAEX_H__
-#define __S5K3AAEX_H__
-
-/*! I2C Slave Address */
-#define S5K3AAEX_I2C_ADDRESS	0x2d
-
-enum {
-	S5K3AAEX_OutputResolution_SXGA = 0,
-	S5K3AAEX_OutputResolution_VGA = 0x1c,
-	S5K3AAEX_OutputResolution_QVGA = 0x14,
-	S5K3AAEX_OutputResolution_QQVGA = 0x16,
-	S5K3AAEX_OutputResolution_CIF = 0x10,
-	S5K3AAEX_OutputResolution_QCIF = 0x12,
-};
-
-enum {
-	S5K3AAEX_WINWIDTH = 0x500,
-	S5K3AAEX_WINHEIGHT = 0x400,
-	S5K3AAEX_ROWSTART = 14,
-	S5K3AAEX_COLSTART = 14,
-
-	S5K3AAEX_HORZBLANK_DEFAULT = 142,
-	S5K3AAEX_VERTBLANK_DEFAULT = 101,
-};
-
-typedef struct {
-	u8 index;
-	u8 imageFormat;
-	u16 width;
-	u16 height;
-} s5k3aaex_image_format;
-
-/*!
- * s5k3aaex ARM command Register page 0 structure.
- */
-typedef struct {
-	u8 addressSelect;
-	u8 imageFormat;
-	u8 functionOnOff;
-	u8 mainClock;
-} s5k3aaex_page0;
-
-/*!
- * s5k3aaex IFP Register structure.
- */
-typedef struct {
-	u8 addressSelect;
-	u16 wrp;
-	u16 wcp;
-	u16 wrd;
-	u16 wcw;
-	u16 vblank;
-	u16 hblank;
-} s5k3aaex_page2;
-
-/*!
- * s5k3aaex Config structure
- */
-typedef struct {
-	s5k3aaex_page0 *page0;
-	s5k3aaex_page2 *page2;
-} s5k3aaex_conf;
-
-#endif				/* __S5K3AAEX_H__ */
diff --git a/include/asm-arm/arch-mxc/mxc_i2c.h b/include/asm-arm/arch-mxc/mxc_i2c.h
deleted file mode 100644
index 97fee0f..0000000
--- a/include/asm-arm/arch-mxc/mxc_i2c.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-#ifndef __ASM_ARCH_MXC_I2C_H__
-#define __ASM_ARCH_MXC_I2C_H__
-
-/*!
- * @defgroup MXCI2C Inter-IC (I2C) Driver
- */
-
-/*!
- * @file arch-mxc/mxc_i2c.h
- *
- * @brief This file contains the I2C chip level configuration details.
- *
- * It also contains the API function that other drivers can use to read/write
- * to the I2C device registers.
- *
- * @ingroup MXCI2C
- */
-
-/*!
- * This defines the string used to identify MXC I2C Bus drivers
- */
-#define MXC_ADAPTER_NAME        "MXC I2C Adapter"
-
-#define MXC_I2C_FLAG_READ	0x01	/* if set, is read; else is write */
-#define MXC_I2C_FLAG_POLLING	0x02	/* if set, is polling mode; else is interrupt mode */
-
-/*!
- * Function used to read the register of the i2c slave device. This function
- * is a kernel level API that can be called by other device drivers.
- *
- * @param   bus_id       the MXC I2C bus that the slave device is connected to
- *                       (0 based)
- * @param   addr         slave address of the device we wish to read data from
- * @param   *reg         register in the device we wish to access
- * @param   reg_len      number of bytes in the register address
- * @param   *buf         data buffer
- * @param   num          number of data bytes to transfer
- *
- * @return  Function returns the number of messages transferred to/from the device
- *          or a negative number on failure
- */
-int mxc_i2c_read(int bus_id, unsigned int addr, char *reg, int reg_len,
-		 char *buf, int num);
-
-/*!
- * Function used to write to the register of the i2c slave device. This function
- * is a kernel level API that can be called by other device drivers.
- *
- * @param   bus_id       the MXC I2C bus that the slave device is connected to
- *                       (0 based)
- * @param   addr         slave address of the device we wish to write data to
- * @param   *reg         register in the device we wish to access
- * @param   reg_len      number of bytes in the register address
- * @param   *buf         data buffer
- * @param   num          number of data bytes to transfer
- *
- * @return  Function returns the number of messages transferred to/from the device
- *          or a negative number on failure
- */
-int mxc_i2c_write(int bus_id, unsigned int addr, char *reg, int reg_len,
-		  char *buf, int num);
-
-/*!
- * Function used to read the register of the i2c slave device. This function
- * is a kernel level API that can be called by other device drivers.
- *
- * @param   bus_id       the MXC I2C bus that the slave device is connected to
- *                       (0 based)
- * @param   addr         slave address of the device we wish to read data from
- * @param   *reg         register in the device we wish to access
- * @param   reg_len      number of bytes in the register address
- * @param   *buf         data buffer
- * @param   num          number of data bytes to transfer
- *
- * @return  Function returns the number of messages transferred to/from the
- *          device or a negative number on failure *
- */
-int mxc_i2c_polling_read(int bus_id, unsigned int addr, char *reg, int reg_len,
-			 char *buf, int num);
-
-/*!
- * Function used to write to the register of the i2c slave device. This function
- * is a kernel level API that can be called by other device drivers.
- *
- * @param   bus_id       the MXC I2C bus that the slave device is connected to
- *                       (0 based)
- * @param   addr         slave address of the device we wish to write data to
- * @param   *reg         register in the device we wish to access
- * @param   reg_len      number of bytes in the register address
- * @param   *buf         data buffer
- * @param   num          number of data bytes to transfer
- *
- * @return  Function returns the number of messages transferred to/from the
- *          device or a negative number on failure
- */
-int mxc_i2c_polling_write(int bus_id, unsigned int addr, char *reg, int reg_len,
-			  char *buf, int num);
-
-#endif				/* __ASM_ARCH_MXC_I2C_H__ */
-- 
1.5.4.4

