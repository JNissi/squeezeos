From b7ead2d6329c0ce17e832a4cd074c9e157acca6d Mon Sep 17 00:00:00 2001
From: Wu Guoxing <b02248@freescale.com>
Date: Mon, 28 Apr 2008 15:14:51 +0800
Subject: [PATCH] ENGR00058788 MX35: Camera driver

Request to support Camera driver (CMOS sensor OV2640) in MX35 platform

Signed-off-by: Guoxing Wu <b02248@freescale.com>
---
 arch/arm/configs/imx35_3stack_defconfig        |   12 ++++-
 arch/arm/mach-mx3/mx3_3stack.c                 |    5 +-
 arch/arm/mach-mx35/clock.c                     |   14 ++++-
 arch/arm/mach-mx35/mx35_3stack.c               |   13 ++++
 arch/arm/mach-mx35/mx35_3stack_gpio.c          |   31 ++++++++++
 drivers/media/video/mxc/capture/Kconfig        |    2 +-
 drivers/media/video/mxc/capture/ov2640.c       |   72 ++++++++++-------------
 drivers/media/video/mxc/capture/sensor_clock.c |   10 +---
 include/asm-arm/arch-mxc/mxc.h                 |    1 +
 9 files changed, 105 insertions(+), 55 deletions(-)

diff --git a/arch/arm/configs/imx35_3stack_defconfig b/arch/arm/configs/imx35_3stack_defconfig
index 21f5033..4b91f2d 100644
--- a/arch/arm/configs/imx35_3stack_defconfig
+++ b/arch/arm/configs/imx35_3stack_defconfig
@@ -837,7 +837,17 @@ CONFIG_VIDEO_CAPTURE_DRIVERS=y
 CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
 # CONFIG_VIDEO_VIVI is not set
 # CONFIG_VIDEO_PMS is not set
-# CONFIG_VIDEO_MXC_CAMERA is not set
+CONFIG_VIDEO_MXC_CAMERA=y
+
+#
+# MXC Camera/V4L2 PRP Features support
+#
+CONFIG_VIDEO_MXC_IPU_CAMERA=y
+# CONFIG_MXC_CAMERA_MC521DA is not set
+# CONFIG_MXC_CAMERA_MICRON111 is not set
+CONFIG_MXC_CAMERA_OV2640=y
+CONFIG_MXC_IPU_PRP_VF_SDC=y
+CONFIG_MXC_IPU_PRP_ENC=y
 CONFIG_VIDEO_MXC_OUTPUT=y
 CONFIG_VIDEO_MXC_IPU_OUTPUT=y
 # CONFIG_VIDEO_MXC_OPL is not set
diff --git a/arch/arm/mach-mx3/mx3_3stack.c b/arch/arm/mach-mx3/mx3_3stack.c
index 88ecfff..b534692 100644
--- a/arch/arm/mach-mx3/mx3_3stack.c
+++ b/arch/arm/mach-mx3/mx3_3stack.c
@@ -222,6 +222,7 @@ static struct mxc_camera_platform_data camera_data = {
 	.io_regulator = "VMMC1",
 	.analog_regulator = "SW2B_NORMAL",
 	.gpo_regulator = "GPO3",
+	.mclk = 27000000,
 };
 
 struct mxc_tvout_platform_data tvout_data = {
@@ -810,11 +811,11 @@ static void __init mxc_init_pata(void)
 {
 	(void)platform_device_register(&pata_fsl_device);
 }
-#else				/* CONFIG_PATA_FSL */
+#else /* CONFIG_PATA_FSL */
 static void __init mxc_init_pata(void)
 {
 }
-#endif				/* CONFIG_PATA_FSL */
+#endif /* CONFIG_PATA_FSL */
 
 /*!
  * Board specific initialization.
diff --git a/arch/arm/mach-mx35/clock.c b/arch/arm/mach-mx35/clock.c
index 1c2c0c7..92d0cf4 100644
--- a/arch/arm/mach-mx35/clock.c
+++ b/arch/arm/mach-mx35/clock.c
@@ -517,6 +517,16 @@ static void _clk_csi_recalc(struct clk *clk)
 	clk->rate = clk->parent->rate / ((pre + 1) * (post + 1));
 }
 
+static void __csi_calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
+{
+	*pre = div;
+
+	while (*pre > 8)
+		*pre = *pre / 2;
+
+	*post = div / *pre;
+}
+
 static unsigned long _clk_csi_round_rate(struct clk *clk, unsigned long rate)
 {
 	u32 pre, post;
@@ -524,7 +534,7 @@ static unsigned long _clk_csi_round_rate(struct clk *clk, unsigned long rate)
 	if (clk->parent->rate % rate)
 		div++;
 
-	__calc_pre_post_dividers(div, &pre, &post);
+	__csi_calc_pre_post_dividers(div, &pre, &post);
 
 	return clk->parent->rate / (pre * post);
 }
@@ -550,7 +560,7 @@ static int _clk_csi_set_rate(struct clk *clk, unsigned long rate)
 	if ((clk->parent->rate / div) != rate)
 		return -EINVAL;
 
-	__calc_pre_post_dividers(div, &pre, &post);
+	__csi_calc_pre_post_dividers(div, &pre, &post);
 
 	/* Set CSI clock divider */
 	reg = __raw_readl(MXC_CCM_PDR2) &
diff --git a/arch/arm/mach-mx35/mx35_3stack.c b/arch/arm/mach-mx35/mx35_3stack.c
index 7722e68..d0818ea 100644
--- a/arch/arm/mach-mx35/mx35_3stack.c
+++ b/arch/arm/mach-mx35/mx35_3stack.c
@@ -260,6 +260,14 @@ static struct mxc_tsc_platform_data tsc2007_data = {
 	.inactive = gpio_tsc_inactive,
 };
 
+static struct mxc_camera_platform_data camera_data = {
+	.core_regulator = NULL,
+	.io_regulator = NULL,
+	.analog_regulator = "LDO7",
+	.gpo_regulator = NULL,
+	.mclk = 15000000,
+};
+
 static struct i2c_board_info mxc_i2c_board_info[] __initdata = {
 	{
 	 .driver_name = "mc9sdz60",
@@ -275,6 +283,11 @@ static struct i2c_board_info mxc_i2c_board_info[] __initdata = {
 	 .platform_data = &tsc2007_data,
 	 .irq = IOMUX_TO_IRQ(MX35_PIN_CAPTURE),
 	 },
+	{
+	 .driver_name = "ov2640",
+	 .addr = 0x30,
+	 .platform_data = (void *)&camera_data,
+	 },
 };
 
 #if  defined(CONFIG_SMSC911X) || defined(CONFIG_SMSC911X_MODULE)
diff --git a/arch/arm/mach-mx35/mx35_3stack_gpio.c b/arch/arm/mach-mx35/mx35_3stack_gpio.c
index 75d498e..72491c8 100644
--- a/arch/arm/mach-mx35/mx35_3stack_gpio.c
+++ b/arch/arm/mach-mx35/mx35_3stack_gpio.c
@@ -645,3 +645,34 @@ void gpio_usbotg_utmi_inactive(void)
 	mxc_free_iomux(MX35_PIN_USBOTG_OC, MUX_CONFIG_GPIO);
 }
 EXPORT_SYMBOL(gpio_usbotg_utmi_inactive);
+
+void gpio_sensor_active()
+{
+	/*CSI D6 */
+	mxc_request_iomux(MX35_PIN_TX1, MUX_CONFIG_ALT6);
+	/*CSI D7 */
+	mxc_request_iomux(MX35_PIN_TX0, MUX_CONFIG_ALT6);
+	mxc_request_iomux(MX35_PIN_CSI_D8, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_CSI_D9, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_CSI_D10, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_CSI_D11, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_CSI_D12, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_CSI_D13, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_CSI_D14, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_CSI_D15, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_CSI_HSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_CSI_MCLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_CSI_PIXCLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_CSI_VSYNC, MUX_CONFIG_FUNC);
+}
+
+EXPORT_SYMBOL(gpio_sensor_active);
+
+void gpio_sensor_inactive()
+{
+	mxc_request_iomux(MX35_PIN_TX1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_TX0, MUX_CONFIG_FUNC);
+}
+
+EXPORT_SYMBOL(gpio_sensor_inactive);
+
diff --git a/drivers/media/video/mxc/capture/Kconfig b/drivers/media/video/mxc/capture/Kconfig
index 9e10376..10a1d8c 100644
--- a/drivers/media/video/mxc/capture/Kconfig
+++ b/drivers/media/video/mxc/capture/Kconfig
@@ -24,7 +24,7 @@ config VIDEO_MXC_CSI_DMA
 
 choice
 	prompt "Select Camera"
-	default MXC_CAMERA_MICRON111
+	default MXC_CAMERA_OV2640
 	depends on VIDEO_MXC_CAMERA
 
 config MXC_CAMERA_MC521DA
diff --git a/drivers/media/video/mxc/capture/ov2640.c b/drivers/media/video/mxc/capture/ov2640.c
index 99129a1..61f0dd3 100644
--- a/drivers/media/video/mxc/capture/ov2640.c
+++ b/drivers/media/video/mxc/capture/ov2640.c
@@ -139,6 +139,7 @@ static struct regulator *io_regulator;
 static struct regulator *core_regulator;
 static struct regulator *analog_regulator;
 static struct regulator *gpo_regulator;
+u32 mclk = 24000000;
 
 struct i2c_client *ov2640_i2c_client;
 
@@ -167,6 +168,7 @@ static int ov2640_probe(struct i2c_client *client)
 	struct mxc_camera_platform_data *plat_data = client->dev.platform_data;
 
 	ov2640_i2c_client = client;
+	mclk = plat_data->mclk;
 
 	io_regulator = regulator_get(&client->dev, plat_data->io_regulator);
 	core_regulator = regulator_get(&client->dev, plat_data->core_regulator);
@@ -196,17 +198,25 @@ static int ov2640_remove(struct i2c_client *client)
 	kfree(interface_param);
 	interface_param = NULL;
 
-	regulator_disable(io_regulator);
-	regulator_put(io_regulator, NULL);
+	if (!IS_ERR_VALUE(io_regulator)) {
+		regulator_disable(io_regulator);
+		regulator_put(io_regulator, NULL);
+	}
 
-	regulator_disable(core_regulator);
-	regulator_put(core_regulator, NULL);
+	if (!IS_ERR_VALUE(core_regulator)) {
+		regulator_disable(core_regulator);
+		regulator_put(core_regulator, NULL);
+	}
 
-	regulator_disable(gpo_regulator);
-	regulator_put(gpo_regulator, NULL);
+	if (!IS_ERR_VALUE(gpo_regulator)) {
+		regulator_disable(gpo_regulator);
+		regulator_put(gpo_regulator, NULL);
+	}
 
-	regulator_disable(analog_regulator);
-	regulator_put(analog_regulator, NULL);
+	if (!IS_ERR_VALUE(analog_regulator)) {
+		regulator_disable(analog_regulator);
+		regulator_put(analog_regulator, NULL);
+	}
 
 	return 0;
 }
@@ -269,7 +279,7 @@ static void ov2640_interface(sensor_interface *param, u32 width, u32 height)
 	param->width = width - 1;
 	param->height = height - 1;
 	param->pixel_fmt = IPU_PIX_FMT_UYVY;
-	param->mclk = 27000000;
+	param->mclk = mclk;
 }
 
 static void ov2640_set_color(int bright, int saturation, int red, int green,
@@ -299,44 +309,34 @@ static sensor_interface *ov2640_config(int *frame_rate, int high_quality)
 
 	u32 out_width, out_height;
 
-	/*set vmmc1 */
-	if (io_regulator) {
+	/*set io votage */
+	if (!IS_ERR_VALUE(io_regulator)) {
 		regulator_set_voltage(io_regulator, 2800000);
 		if (regulator_enable(io_regulator) != 0) {
 			dev_dbg(&ov2640_i2c_client->dev,
-				"%s:vmmc1 set voltage error\n", __func__);
+				"%s:io set voltage error\n", __func__);
 			return NULL;
 		} else {
 			dev_dbg(&ov2640_i2c_client->dev,
-				"%s:vmmc1 set voltage ok\n", __func__);
+				"%s:io set voltage ok\n", __func__);
 		}
-	} else {
-		dev_dbg(&ov2640_i2c_client->dev,
-			"%s:vmmc1 set voltage error:regulator not found\n",
-			__func__);
-		return NULL;
 	}
 
-	/*vvib */
-	if (core_regulator) {
+	/*core votage */
+	if (!IS_ERR_VALUE(core_regulator)) {
 		regulator_set_voltage(core_regulator, 1300000);
 		if (regulator_enable(core_regulator) != 0) {
 			dev_dbg(&ov2640_i2c_client->dev,
-				"%s:vvib set voltage error\n", __func__);
+				"%s:core set voltage error\n", __func__);
 			return NULL;
 		} else {
 			dev_dbg(&ov2640_i2c_client->dev,
-				"%s:vvib set voltage ok\n", __func__);
+				"%s:core set voltage ok\n", __func__);
 		}
-	} else {
-		dev_dbg(&ov2640_i2c_client->dev,
-			"%s:vvib set voltage error:regulator not found\n",
-			__func__);
-		return NULL;
 	}
 
 	/*GPO 3 */
-	if (gpo_regulator) {
+	if (!IS_ERR_VALUE(gpo_regulator)) {
 		if (regulator_enable(gpo_regulator) != 0) {
 			dev_dbg(&ov2640_i2c_client->dev,
 				"%s:gpo3 enable error\n", __func__);
@@ -345,28 +345,18 @@ static sensor_interface *ov2640_config(int *frame_rate, int high_quality)
 			dev_dbg(&ov2640_i2c_client->dev, "%s:gpo3 enable ok\n",
 				__func__);
 		}
-	} else {
-		dev_dbg(&ov2640_i2c_client->dev,
-			"%s:gpo3 error: regulator not found\n", __func__);
-		return NULL;
 	}
 
-	/*sw2b */
-	if (analog_regulator) {
+	if (!IS_ERR_VALUE(analog_regulator)) {
 		regulator_set_voltage(analog_regulator, 2000000);
 		if (regulator_enable(analog_regulator) != 0) {
 			dev_dbg(&ov2640_i2c_client->dev,
-				"%s:sw2b set voltage error\n", __func__);
+				"%s:analog set voltage error\n", __func__);
 			return NULL;
 		} else {
 			dev_dbg(&ov2640_i2c_client->dev,
-				"%s:sw2b set voltage ok\n", __func__);
+				"%s:analog set voltage ok\n", __func__);
 		}
-	} else {
-		dev_dbg(&ov2640_i2c_client->dev,
-			"%s:sw2b set voltage error:regulator not found\n",
-			__func__);
-		return NULL;
 	}
 
 	gpio_sensor_active();
diff --git a/drivers/media/video/mxc/capture/sensor_clock.c b/drivers/media/video/mxc/capture/sensor_clock.c
index e2be4f4..9da391a 100644
--- a/drivers/media/video/mxc/capture/sensor_clock.c
+++ b/drivers/media/video/mxc/capture/sensor_clock.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -33,17 +33,11 @@
 void set_mclk_rate(uint32_t * p_mclk_freq)
 {
 	struct clk *clk;
-	int i;
 	uint32_t freq = 0;
-	uint32_t step = *p_mclk_freq / 8;
 
 	clk = clk_get(NULL, "csi_clk");
 
-	for (i = 0; i <= 8; i++) {
-		freq = clk_round_rate(clk, *p_mclk_freq - (i * step));
-		if (freq <= *p_mclk_freq)
-			break;
-	}
+	freq = clk_round_rate(clk, *p_mclk_freq);
 	clk_set_rate(clk, freq);
 
 	*p_mclk_freq = freq;
diff --git a/include/asm-arm/arch-mxc/mxc.h b/include/asm-arm/arch-mxc/mxc.h
index 50442b7..89156cf 100644
--- a/include/asm-arm/arch-mxc/mxc.h
+++ b/include/asm-arm/arch-mxc/mxc.h
@@ -125,6 +125,7 @@ struct mxc_camera_platform_data {
 	char *io_regulator;
 	char *analog_regulator;
 	char *gpo_regulator;
+	u32 mclk;
 };
 
 /*gpo1-3 is in fixed state by hardware design,
-- 
1.5.4.4

