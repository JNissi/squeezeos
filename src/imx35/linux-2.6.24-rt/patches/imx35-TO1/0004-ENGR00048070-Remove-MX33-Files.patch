From 22f7df0a4d5e903a6822cf08e2084ccdcff1cfc4 Mon Sep 17 00:00:00 2001
From: Raj Rajasekaran <b10872@freescale.com>
Date: Tue, 22 Jan 2008 15:29:42 -0600
Subject: [PATCH] ENGR00048070 Remove MX33 Files

Removed i.MX33 related files.
---
 arch/arm/Makefile                                 |    1 -
 arch/arm/configs/imx27ads_defconfig               |    1 -
 arch/arm/configs/imx31ads_defconfig               |    1 -
 arch/arm/configs/imx33ads_defconfig               | 1466 ---------------------
 arch/arm/configs/mxc30030evb_defconfig            |    1 -
 arch/arm/mach-mx33/Kconfig                        |   21 -
 arch/arm/mach-mx33/Makefile                       |   12 -
 arch/arm/mach-mx33/Makefile.boot                  |    3 -
 arch/arm/mach-mx33/clock.c                        | 1292 ------------------
 arch/arm/mach-mx33/cpu.c                          |  123 --
 arch/arm/mach-mx33/crm_regs.h                     |  606 ---------
 arch/arm/mach-mx33/devices.c                      |  543 --------
 arch/arm/mach-mx33/dma.c                          |  590 ---------
 arch/arm/mach-mx33/iomux.c                        |  237 ----
 arch/arm/mach-mx33/iomux.h                        |  349 -----
 arch/arm/mach-mx33/irq.c                          |   94 --
 arch/arm/mach-mx33/mm.c                           |   95 --
 arch/arm/mach-mx33/mx33ads.c                      |  565 --------
 arch/arm/mach-mx33/mx33ads_gpio.c                 |  537 --------
 arch/arm/mach-mx33/sdma_script_code.h             |  355 -----
 arch/arm/mach-mx33/serial.c                       |  252 ----
 arch/arm/mach-mx33/serial.h                       |  152 ---
 arch/arm/mach-mx33/system.c                       |   61 -
 arch/arm/plat-mxc/Makefile                        |    2 -
 drivers/char/Kconfig                              |    4 -
 drivers/ide/Kconfig                               |    2 +-
 drivers/mxc/security/sahara2/include/sah_kernel.h |    3 +-
 drivers/net/Kconfig                               |    2 +-
 include/asm-arm/arch-mxc/board-mx33ads.h          |  365 -----
 include/asm-arm/arch-mxc/mx33.h                   |  491 -------
 include/asm-arm/arch-mxc/mx33_pins.h              |  296 -----
 31 files changed, 3 insertions(+), 8519 deletions(-)

diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 5cd6f3a..fb6fb11 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -138,7 +138,6 @@ endif
  machine-$(CONFIG_ARCH_DAVINCI)	   := davinci
  machine-$(CONFIG_ARCH_KS8695)     := ks8695
   incdir-$(CONFIG_ARCH_MXC)	   := mxc
- machine-$(CONFIG_ARCH_MX33)	   := mx33
  machine-$(CONFIG_ARCH_MX3)	   := mx3
  machine-$(CONFIG_ARCH_MX27)	   := mx27
  machine-$(CONFIG_ARCH_MX21)	   := mx21
diff --git a/arch/arm/configs/imx27ads_defconfig b/arch/arm/configs/imx27ads_defconfig
index eac1555..7ff00c2 100644
--- a/arch/arm/configs/imx27ads_defconfig
+++ b/arch/arm/configs/imx27ads_defconfig
@@ -157,7 +157,6 @@ CONFIG_ARCH_MXC=y
 # CONFIG_ARCH_MXC91231 is not set
 # CONFIG_ARCH_MXC91221 is not set
 # CONFIG_ARCH_MXC91131 is not set
-# CONFIG_ARCH_MX33 is not set
 # CONFIG_ARCH_MX3 is not set
 CONFIG_ARCH_MX27=y
 # CONFIG_ARCH_MX21 is not set
diff --git a/arch/arm/configs/imx31ads_defconfig b/arch/arm/configs/imx31ads_defconfig
index 4567383..f7ec50d 100644
--- a/arch/arm/configs/imx31ads_defconfig
+++ b/arch/arm/configs/imx31ads_defconfig
@@ -157,7 +157,6 @@ CONFIG_ARCH_MXC=y
 # CONFIG_ARCH_MXC91231 is not set
 # CONFIG_ARCH_MXC91221 is not set
 # CONFIG_ARCH_MXC91131 is not set
-# CONFIG_ARCH_MX33 is not set
 CONFIG_ARCH_MX3=y
 # CONFIG_ARCH_MX27 is not set
 # CONFIG_ARCH_MX21 is not set
diff --git a/arch/arm/configs/imx33ads_defconfig b/arch/arm/configs/imx33ads_defconfig
deleted file mode 100644
index 53841d3..0000000
--- a/arch/arm/configs/imx33ads_defconfig
+++ /dev/null
@@ -1,1466 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.18.1
-# Thu Dec 21 17:32:20 2006
-#
-CONFIG_ARM=y
-CONFIG_MMU=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# Code maturity level options
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-
-#
-# General setup
-#
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-CONFIG_SYSVIPC=y
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-# CONFIG_RELAY is not set
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-CONFIG_SYSCTL=y
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-CONFIG_ELF_CORE=y
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SHMEM=y
-CONFIG_SLAB=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_RT_MUTEXES=y
-# CONFIG_TINY_SHMEM is not set
-CONFIG_BASE_SMALL=0
-# CONFIG_SLOB is not set
-
-#
-# Loadable module support
-#
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-CONFIG_MODVERSIONS=y
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_KMOD=y
-
-#
-# Block layer
-#
-# CONFIG_BLK_DEV_IO_TRACE is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-# CONFIG_DEFAULT_AS is not set
-# CONFIG_DEFAULT_DEADLINE is not set
-CONFIG_DEFAULT_CFQ=y
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="cfq"
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS7500 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_CO285 is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP3XX is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_L7200 is not set
-CONFIG_ARCH_MXC=y
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_OMAP is not set
-
-#
-# Freescale MXC Implementations
-#
-# CONFIG_ARCH_MXC91321 is not set
-# CONFIG_ARCH_MXC91231 is not set
-# CONFIG_ARCH_MXC91131 is not set
-CONFIG_ARCH_MX33=y
-# CONFIG_ARCH_MX3 is not set
-# CONFIG_ARCH_MX27 is not set
-# CONFIG_ARCH_MX21 is not set
-CONFIG_ISP1504_MXC=m
-# CONFIG_MX3_DOZE_DURING_IDLE is not set
-# CONFIG_MXC_SDMA_API is not set
-
-#
-# MX33 Options
-#
-CONFIG_MACH_MX33ADS=y
-CONFIG_MXC_TZIC=y
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_V6=y
-# CONFIG_CPU_32v6K is not set
-CONFIG_CPU_32v6=y
-CONFIG_CPU_ABRT_EV6=y
-CONFIG_CPU_CACHE_V6=y
-CONFIG_CPU_CACHE_VIPT=y
-CONFIG_CPU_COPY_V6=y
-CONFIG_CPU_TLB_V6=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
-# CONFIG_CPU_BPREDICT_DISABLE is not set
-
-#
-# Bus support
-#
-CONFIG_ISA=y
-
-#
-# PCCARD (PCMCIA/CardBus) support
-#
-CONFIG_PCCARD=m
-# CONFIG_PCMCIA_DEBUG is not set
-CONFIG_PCMCIA=m
-CONFIG_PCMCIA_LOAD_CIS=y
-CONFIG_PCMCIA_IOCTL=y
-
-#
-# PC-card bridges
-#
-# CONFIG_I82365 is not set
-# CONFIG_TCIC is not set
-CONFIG_PCMCIA_PROBE=y
-
-#
-# Kernel Features
-#
-CONFIG_PREEMPT=y
-# CONFIG_NO_IDLE_HZ is not set
-CONFIG_HZ=100
-CONFIG_AEABI=y
-CONFIG_OABI_COMPAT=y
-# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_SPARSEMEM_STATIC is not set
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_RESOURCES_64BIT is not set
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw ip=off  rootfstype=cramfs"
-# CONFIG_XIP_KERNEL is not set
-
-#
-# CPU Frequency scaling
-#
-# CONFIG_CPU_FREQ is not set
-
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-# CONFIG_FPE_NWFPE is not set
-# CONFIG_FPE_FASTFPE is not set
-CONFIG_VFP=y
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-CONFIG_PM=y
-CONFIG_PM_LEGACY=y
-# CONFIG_PM_DEBUG is not set
-# CONFIG_APM is not set
-
-#
-# Networking
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-# CONFIG_NETDEBUG is not set
-CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-CONFIG_UNIX=y
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-CONFIG_INET_XFRM_MODE_TUNNEL=y
-CONFIG_INET_DIAG=y
-CONFIG_INET_TCP_DIAG=y
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_BIC=y
-
-#
-# IP: Virtual Server Configuration
-#
-# CONFIG_IP_VS is not set
-CONFIG_IPV6=m
-# CONFIG_IPV6_PRIVACY is not set
-# CONFIG_IPV6_ROUTER_PREF is not set
-# CONFIG_INET6_AH is not set
-# CONFIG_INET6_ESP is not set
-# CONFIG_INET6_IPCOMP is not set
-# CONFIG_INET6_XFRM_TUNNEL is not set
-# CONFIG_INET6_TUNNEL is not set
-CONFIG_INET6_XFRM_MODE_TRANSPORT=m
-CONFIG_INET6_XFRM_MODE_TUNNEL=m
-# CONFIG_IPV6_TUNNEL is not set
-# CONFIG_NETWORK_SECMARK is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-
-#
-# Core Netfilter Configuration
-#
-# CONFIG_NETFILTER_NETLINK is not set
-# CONFIG_NF_CONNTRACK is not set
-# CONFIG_NETFILTER_XTABLES is not set
-
-#
-# IP: Netfilter Configuration
-#
-# CONFIG_IP_NF_CONNTRACK is not set
-# CONFIG_IP_NF_QUEUE is not set
-
-#
-# IPv6: Netfilter Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP6_NF_QUEUE is not set
-
-#
-# DCCP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_DCCP is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-
-#
-# TIPC Configuration (EXPERIMENTAL)
-#
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-CONFIG_IRDA=m
-
-#
-# IrDA protocols
-#
-CONFIG_IRLAN=m
-CONFIG_IRNET=m
-CONFIG_IRCOMM=m
-# CONFIG_IRDA_ULTRA is not set
-
-#
-# IrDA options
-#
-CONFIG_IRDA_CACHE_LAST_LSAP=y
-CONFIG_IRDA_FAST_RR=y
-# CONFIG_IRDA_DEBUG is not set
-
-#
-# Infrared-port device drivers
-#
-
-#
-# SIR device drivers
-#
-CONFIG_IRTTY_SIR=m
-
-#
-# Dongle support
-#
-# CONFIG_DONGLE is not set
-
-#
-# Old SIR device drivers
-#
-# CONFIG_IRPORT_SIR is not set
-
-#
-# Old Serial dongle support
-#
-
-#
-# FIR device drivers
-#
-# CONFIG_USB_IRDA is not set
-# CONFIG_SIGMATEL_FIR is not set
-# CONFIG_MCS_FIR is not set
-# CONFIG_MXC_FIR is not set
-# CONFIG_BT is not set
-CONFIG_IEEE80211=y
-# CONFIG_IEEE80211_DEBUG is not set
-# CONFIG_IEEE80211_CRYPT_WEP is not set
-# CONFIG_IEEE80211_CRYPT_CCMP is not set
-# CONFIG_IEEE80211_CRYPT_TKIP is not set
-# CONFIG_IEEE80211_SOFTMAC is not set
-CONFIG_WIRELESS_EXT=y
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=m
-# CONFIG_SYS_HYPERVISOR is not set
-
-#
-# Connector - unified userspace <-> kernelspace linker
-#
-# CONFIG_CONNECTOR is not set
-
-#
-# Memory Technology Devices (MTD)
-#
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-CONFIG_MTD_REDBOOT_PARTS=y
-CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
-# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
-# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-CONFIG_MTD_CFI=y
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_GEN_PROBE=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_NOSWAP=y
-# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
-# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
-CONFIG_MTD_CFI_GEOMETRY=y
-# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-# CONFIG_MTD_CFI_I2 is not set
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_OTP is not set
-CONFIG_MTD_CFI_INTELEXT=y
-# CONFIG_MTD_CFI_AMDSTD is not set
-# CONFIG_MTD_CFI_STAA is not set
-CONFIG_MTD_CFI_UTIL=y
-CONFIG_MTD_RAM=y
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_OBSOLETE_CHIPS is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PHYSMAP is not set
-# CONFIG_MTD_ARM_INTEGRATOR is not set
-# CONFIG_MTD_PLATRAM is not set
-CONFIG_MTD_MXC=y
-
-#
-# Self-contained MTD device drivers
-#
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-
-#
-# NAND Flash Device Drivers
-#
-# CONFIG_MTD_NAND is not set
-
-#
-# OneNAND Flash Device Drivers
-#
-# CONFIG_MTD_ONENAND is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Plug and Play support
-#
-# CONFIG_PNP is not set
-
-#
-# Block devices
-#
-# CONFIG_BLK_DEV_COW_COMMON is not set
-CONFIG_BLK_DEV_LOOP=y
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_UB is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_BLK_DEV_RAM_SIZE=16384
-CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-CONFIG_SCSI=y
-CONFIG_SCSI_PROC_FS=y
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=y
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
-# CONFIG_CHR_DEV_SCH is not set
-
-#
-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
-#
-CONFIG_SCSI_MULTI_LUN=y
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_LOGGING is not set
-
-#
-# SCSI Transport Attributes
-#
-# CONFIG_SCSI_SPI_ATTRS is not set
-# CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
-# CONFIG_SCSI_SAS_ATTRS is not set
-
-#
-# SCSI low-level drivers
-#
-# CONFIG_ISCSI_TCP is not set
-# CONFIG_SCSI_AHA152X is not set
-# CONFIG_SCSI_AIC7XXX_OLD is not set
-# CONFIG_SCSI_IN2000 is not set
-# CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_DTC3280 is not set
-# CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GENERIC_NCR5380 is not set
-# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
-# CONFIG_SCSI_NCR53C406A is not set
-# CONFIG_SCSI_PAS16 is not set
-# CONFIG_SCSI_PSI240I is not set
-# CONFIG_SCSI_QLOGIC_FAS is not set
-# CONFIG_SCSI_SYM53C416 is not set
-# CONFIG_SCSI_T128 is not set
-# CONFIG_SCSI_DEBUG is not set
-
-#
-# PCMCIA SCSI adapter support
-#
-# CONFIG_PCMCIA_AHA152X is not set
-# CONFIG_PCMCIA_FDOMAIN is not set
-# CONFIG_PCMCIA_NINJA_SCSI is not set
-# CONFIG_PCMCIA_QLOGIC is not set
-# CONFIG_PCMCIA_SYM53C500 is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-
-#
-# Fusion MPT device support
-#
-# CONFIG_FUSION is not set
-
-#
-# IEEE 1394 (FireWire) support
-#
-
-#
-# I2O device support
-#
-
-#
-# Network device support
-#
-CONFIG_NETDEVICES=y
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-CONFIG_TUN=m
-
-#
-# ARCnet devices
-#
-# CONFIG_ARCNET is not set
-
-#
-# PHY device support
-#
-# CONFIG_PHYLIB is not set
-
-#
-# Ethernet (10 or 100Mbit)
-#
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_NET_VENDOR_3COM is not set
-# CONFIG_NET_VENDOR_SMC is not set
-# CONFIG_SMC91X is not set
-# CONFIG_DM9000 is not set
-# CONFIG_NET_VENDOR_RACAL is not set
-# CONFIG_AT1700 is not set
-# CONFIG_DEPCA is not set
-# CONFIG_HP100 is not set
-# CONFIG_NET_ISA is not set
-CONFIG_NET_PCI=y
-# CONFIG_AC3200 is not set
-# CONFIG_APRICOT is not set
-# CONFIG_CS89x0 is not set
-# CONFIG_FEC is not set
-
-#
-# Ethernet (1000 Mbit)
-#
-
-#
-# Ethernet (10000 Mbit)
-#
-
-#
-# Token Ring devices
-#
-# CONFIG_TR is not set
-
-#
-# Wireless LAN (non-hamradio)
-#
-CONFIG_NET_RADIO=y
-# CONFIG_NET_WIRELESS_RTNETLINK is not set
-
-#
-# Obsolete Wireless cards support (pre-802.11)
-#
-# CONFIG_STRIP is not set
-# CONFIG_ARLAN is not set
-# CONFIG_WAVELAN is not set
-# CONFIG_PCMCIA_WAVELAN is not set
-# CONFIG_PCMCIA_NETWAVE is not set
-
-#
-# Wireless 802.11 Frequency Hopping cards support
-#
-# CONFIG_PCMCIA_RAYCS is not set
-
-#
-# Wireless 802.11b ISA/PCI cards support
-#
-# CONFIG_HERMES is not set
-# CONFIG_ATMEL is not set
-
-#
-# Wireless 802.11b Pcmcia/Cardbus cards support
-#
-# CONFIG_AIRO_CS is not set
-# CONFIG_PCMCIA_WL3501 is not set
-# CONFIG_USB_ZD1201 is not set
-# CONFIG_HOSTAP is not set
-CONFIG_NET_WIRELESS=y
-
-#
-# PCMCIA network device support
-#
-CONFIG_NET_PCMCIA=y
-# CONFIG_PCMCIA_3C589 is not set
-# CONFIG_PCMCIA_3C574 is not set
-# CONFIG_PCMCIA_FMVJ18X is not set
-CONFIG_PCMCIA_PCNET=m
-# CONFIG_PCMCIA_NMCLAN is not set
-# CONFIG_PCMCIA_SMC91C92 is not set
-# CONFIG_PCMCIA_XIRC2PS is not set
-# CONFIG_PCMCIA_AXNET is not set
-
-#
-# Wan interfaces
-#
-# CONFIG_WAN is not set
-CONFIG_PPP=m
-# CONFIG_PPP_MULTILINK is not set
-# CONFIG_PPP_FILTER is not set
-CONFIG_PPP_ASYNC=m
-CONFIG_PPP_SYNC_TTY=m
-CONFIG_PPP_DEFLATE=m
-# CONFIG_PPP_BSDCOMP is not set
-# CONFIG_PPP_MPPE is not set
-# CONFIG_PPPOE is not set
-# CONFIG_SLIP is not set
-# CONFIG_SHAPER is not set
-# CONFIG_NETCONSOLE is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-
-#
-# ISDN subsystem
-#
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_TSDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-
-#
-# Input Device Drivers
-#
-CONFIG_INPUT_KEYBOARD=y
-# CONFIG_KEYBOARD_ATKBD is not set
-# CONFIG_KEYBOARD_SUNKBD is not set
-# CONFIG_KEYBOARD_LKKBD is not set
-# CONFIG_KEYBOARD_XTKBD is not set
-# CONFIG_KEYBOARD_NEWTON is not set
-CONFIG_KEYBOARD_MXC=y
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
-# CONFIG_VT_HW_CONSOLE_BINDING is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-# CONFIG_SERIAL_8250_CS is not set
-CONFIG_SERIAL_8250_NR_UARTS=2
-CONFIG_SERIAL_8250_RUNTIME_UARTS=2
-# CONFIG_SERIAL_8250_EXTENDED is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_MXC=y
-CONFIG_SERIAL_MXC_CONSOLE=y
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_CORE_CONSOLE=y
-CONFIG_UNIX98_PTYS=y
-CONFIG_LEGACY_PTYS=y
-CONFIG_LEGACY_PTY_COUNT=256
-
-#
-# IPMI
-#
-# CONFIG_IPMI_HANDLER is not set
-
-#
-# Watchdog Cards
-#
-CONFIG_WATCHDOG=y
-CONFIG_WATCHDOG_NOWAYOUT=y
-
-#
-# Watchdog Device Drivers
-#
-# CONFIG_SOFT_WATCHDOG is not set
-CONFIG_MXC_WATCHDOG=y
-
-#
-# ISA-based Watchdog Cards
-#
-# CONFIG_PCWATCHDOG is not set
-# CONFIG_MIXCOMWD is not set
-# CONFIG_WDT is not set
-
-#
-# USB-based Watchdog Cards
-#
-# CONFIG_USBPCWATCHDOG is not set
-CONFIG_HW_RANDOM=y
-# CONFIG_NVRAM is not set
-# CONFIG_MXC_RTC is not set
-# CONFIG_DTLK is not set
-# CONFIG_R3964 is not set
-
-#
-# Ftape, the floppy tape device driver
-#
-
-#
-# PCMCIA character devices
-#
-# CONFIG_SYNCLINK_CS is not set
-# CONFIG_CARDMAN_4000 is not set
-# CONFIG_CARDMAN_4040 is not set
-# CONFIG_RAW_DRIVER is not set
-
-#
-# TPM devices
-#
-# CONFIG_TCG_TPM is not set
-# CONFIG_TELCLOCK is not set
-
-#
-# I2C support
-#
-# CONFIG_I2C is not set
-
-#
-# SPI support
-#
-# CONFIG_SPI is not set
-# CONFIG_SPI_MASTER is not set
-
-#
-# Dallas's 1-wire bus
-#
-
-#
-# Hardware Monitoring support
-#
-CONFIG_HWMON=y
-# CONFIG_HWMON_VID is not set
-# CONFIG_SENSORS_ABITUGURU is not set
-# CONFIG_SENSORS_F71805F is not set
-# CONFIG_HWMON_DEBUG_CHIP is not set
-
-#
-# Misc devices
-#
-
-#
-# LED devices
-#
-# CONFIG_NEW_LEDS is not set
-
-#
-# LED drivers
-#
-
-#
-# LED Triggers
-#
-
-#
-# Multimedia devices
-#
-CONFIG_VIDEO_DEV=y
-CONFIG_VIDEO_V4L1=y
-CONFIG_VIDEO_V4L1_COMPAT=y
-CONFIG_VIDEO_V4L2=y
-
-#
-# Video Capture Adapters
-#
-
-#
-# Video Capture Adapters
-#
-# CONFIG_VIDEO_ADV_DEBUG is not set
-# CONFIG_VIDEO_VIVI is not set
-# CONFIG_VIDEO_PMS is not set
-CONFIG_VIDEO_MXC_CAMERA=y
-
-#
-# MXC Camera/V4L2 PRP Features support
-#
-CONFIG_VIDEO_MXC_OUTPUT=y
-# CONFIG_VIDEO_MXC_OPL is not set
-# CONFIG_VIDEO_CPIA is not set
-# CONFIG_VIDEO_CPIA2 is not set
-
-#
-# Encoders and Decoders
-#
-# CONFIG_VIDEO_CX2341X is not set
-
-#
-# V4L USB devices
-#
-# CONFIG_USB_VICAM is not set
-# CONFIG_USB_IBMCAM is not set
-# CONFIG_USB_KONICAWC is not set
-# CONFIG_USB_QUICKCAM_MESSENGER is not set
-# CONFIG_USB_ET61X251 is not set
-# CONFIG_USB_OV511 is not set
-# CONFIG_USB_SE401 is not set
-# CONFIG_USB_SN9C102 is not set
-# CONFIG_USB_STV680 is not set
-# CONFIG_USB_ZC0301 is not set
-# CONFIG_USB_PWC is not set
-
-#
-# Radio Adapters
-#
-# CONFIG_RADIO_CADET is not set
-# CONFIG_RADIO_RTRACK is not set
-# CONFIG_RADIO_RTRACK2 is not set
-# CONFIG_RADIO_AZTECH is not set
-# CONFIG_RADIO_GEMTEK is not set
-# CONFIG_RADIO_MAESTRO is not set
-# CONFIG_RADIO_SF16FMI is not set
-# CONFIG_RADIO_SF16FMR2 is not set
-# CONFIG_RADIO_TERRATEC is not set
-# CONFIG_RADIO_TRUST is not set
-# CONFIG_RADIO_TYPHOON is not set
-# CONFIG_RADIO_ZOLTRIX is not set
-# CONFIG_USB_DSBR is not set
-
-#
-# Digital Video Broadcasting Devices
-#
-# CONFIG_DVB is not set
-# CONFIG_USB_DABUSB is not set
-
-#
-# Graphics support
-#
-CONFIG_FIRMWARE_EDID=y
-CONFIG_FB=y
-# CONFIG_FB_CFB_FILLRECT is not set
-# CONFIG_FB_CFB_COPYAREA is not set
-# CONFIG_FB_CFB_IMAGEBLIT is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_VIRTUAL is not set
-
-#
-# Console display driver support
-#
-# CONFIG_VGA_CONSOLE is not set
-# CONFIG_MDA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
-# CONFIG_FONTS is not set
-CONFIG_FONT_8x8=y
-CONFIG_FONT_8x16=y
-
-#
-# Logo configuration
-#
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-CONFIG_LOGO_LINUX_CLUT224=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Sound
-#
-CONFIG_SOUND=y
-
-#
-# Advanced Linux Sound Architecture
-#
-# CONFIG_SND is not set
-
-#
-# Open Sound System
-#
-CONFIG_SOUND_PRIME=y
-# CONFIG_OSS_OBSOLETE_DRIVER is not set
-# CONFIG_SOUND_MSNDCLAS is not set
-# CONFIG_SOUND_MSNDPIN is not set
-
-#
-# USB support
-#
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-CONFIG_USB=y
-# CONFIG_USB_DEBUG is not set
-
-#
-# Miscellaneous USB options
-#
-CONFIG_USB_DEVICEFS=y
-# CONFIG_USB_BANDWIDTH is not set
-# CONFIG_USB_DYNAMIC_MINORS is not set
-CONFIG_USB_SUSPEND=y
-# CONFIG_USB_OTG is not set
-
-#
-# USB Host Controller Drivers
-#
-# CONFIG_USB_ISP116X_HCD is not set
-# CONFIG_USB_SL811_HCD is not set
-
-#
-# USB Device Class drivers
-#
-# CONFIG_USB_ACM is not set
-# CONFIG_USB_PRINTER is not set
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
-#
-
-#
-# may also be needed; see USB_STORAGE Help for more information
-#
-CONFIG_USB_STORAGE=y
-# CONFIG_USB_STORAGE_DEBUG is not set
-# CONFIG_USB_STORAGE_DATAFAB is not set
-# CONFIG_USB_STORAGE_FREECOM is not set
-# CONFIG_USB_STORAGE_DPCM is not set
-# CONFIG_USB_STORAGE_USBAT is not set
-# CONFIG_USB_STORAGE_SDDR09 is not set
-# CONFIG_USB_STORAGE_SDDR55 is not set
-# CONFIG_USB_STORAGE_JUMPSHOT is not set
-# CONFIG_USB_STORAGE_ALAUDA is not set
-# CONFIG_USB_LIBUSUAL is not set
-
-#
-# USB Input Devices
-#
-# CONFIG_USB_HID is not set
-
-#
-# USB HID Boot Protocol drivers
-#
-# CONFIG_USB_KBD is not set
-# CONFIG_USB_MOUSE is not set
-# CONFIG_USB_AIPTEK is not set
-# CONFIG_USB_WACOM is not set
-# CONFIG_USB_ACECAD is not set
-# CONFIG_USB_KBTAB is not set
-# CONFIG_USB_POWERMATE is not set
-# CONFIG_USB_TOUCHSCREEN is not set
-# CONFIG_USB_YEALINK is not set
-# CONFIG_USB_XPAD is not set
-# CONFIG_USB_ATI_REMOTE is not set
-# CONFIG_USB_ATI_REMOTE2 is not set
-# CONFIG_USB_KEYSPAN_REMOTE is not set
-# CONFIG_USB_APPLETOUCH is not set
-
-#
-# USB Imaging devices
-#
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_MICROTEK is not set
-
-#
-# USB Network Adapters
-#
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_KAWETH is not set
-# CONFIG_USB_PEGASUS is not set
-# CONFIG_USB_RTL8150 is not set
-# CONFIG_USB_USBNET is not set
-CONFIG_USB_MON=y
-
-#
-# Belcarra USBLAN Networking for USB
-#
-# CONFIG_USB_USBLAN is not set
-
-#
-# USB port drivers
-#
-
-#
-# USB Serial Converter support
-#
-# CONFIG_USB_SERIAL is not set
-
-#
-# USB Miscellaneous drivers
-#
-# CONFIG_USB_EMI62 is not set
-# CONFIG_USB_EMI26 is not set
-# CONFIG_USB_AUERSWALD is not set
-# CONFIG_USB_RIO500 is not set
-# CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_LCD is not set
-# CONFIG_USB_LED is not set
-# CONFIG_USB_CYPRESS_CY7C63 is not set
-# CONFIG_USB_CYTHERM is not set
-# CONFIG_USB_PHIDGETKIT is not set
-# CONFIG_USB_PHIDGETSERVO is not set
-# CONFIG_USB_IDMOUSE is not set
-# CONFIG_USB_APPLEDISPLAY is not set
-# CONFIG_USB_LD is not set
-# CONFIG_USB_TEST is not set
-
-#
-# USB DSL modem support
-#
-
-#
-# USB Gadget Support
-#
-CONFIG_USB_GADGET=m
-# CONFIG_USB_GADGET_DEBUG_FILES is not set
-CONFIG_USB_GADGET_SELECTED=y
-# CONFIG_USB_GADGET_NET2280 is not set
-# CONFIG_USB_GADGET_PXA2XX is not set
-# CONFIG_USB_GADGET_GOKU is not set
-# CONFIG_USB_GADGET_LH7A40X is not set
-# CONFIG_USB_GADGET_OMAP is not set
-CONFIG_USB_GADGET_ARC=y
-CONFIG_USB_ARC=m
-# CONFIG_USB_GADGET_AT91 is not set
-# CONFIG_USB_GADGET_DUMMY_HCD is not set
-CONFIG_USB_GADGET_DUALSPEED=y
-CONFIG_USB_GADGET_ARC_OTG=y
-# CONFIG_USB_GADGET_ARC_OTGFS is not set
-CONFIG_USB_GADGET_ARC_OTGHS=y
-# CONFIG_USB_ZERO is not set
-CONFIG_USB_ETH=m
-CONFIG_USB_ETH_RNDIS=y
-CONFIG_USB_GADGETFS=m
-CONFIG_USB_FILE_STORAGE=m
-# CONFIG_USB_FILE_STORAGE_TEST is not set
-CONFIG_USB_G_SERIAL=m
-
-#
-# On-The-Go and USB Peripheral Support
-#
-# CONFIG_OTG is not set
-
-#
-#
-#
-
-#
-#
-#
-
-#
-# MMC/SD Card support
-#
-# CONFIG_MMC is not set
-
-#
-# Real Time Clock
-#
-CONFIG_RTC_LIB=y
-# CONFIG_RTC_CLASS is not set
-
-#
-# MXC support drivers
-#
-
-#
-# MXC IPU
-#
-# CONFIG_MXC_IPU is not set
-
-#
-# MXC SSI support
-#
-CONFIG_MXC_SSI=y
-
-#
-# MXC Digital Audio Multiplexer support
-#
-CONFIG_MXC_DAM=y
-
-#
-# MXC PMIC support
-#
-# CONFIG_MXC_PMIC is not set
-
-#
-# Advanced Power Management devices
-#
-
-#
-# MXC Security Drivers
-#
-# CONFIG_MXC_SECURITY_SCC is not set
-# CONFIG_MXC_SECURITY_RNGA is not set
-# CONFIG_MXC_SECURITY_HAC is not set
-CONFIG_MXC_SECURITY_RTIC=y
-# CONFIG_MXC_RTIC_TEST_DEBUG is not set
-CONFIG_MXC_SECURITY_CORE=y
-
-#
-# MXC MPEG4 Encoder Kernel module support
-#
-# CONFIG_MXC_HMP4E is not set
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-# CONFIG_EXT2_FS_XATTR is not set
-# CONFIG_EXT2_FS_XIP is not set
-CONFIG_EXT3_FS=m
-CONFIG_EXT3_FS_XATTR=y
-# CONFIG_EXT3_FS_POSIX_ACL is not set
-# CONFIG_EXT3_FS_SECURITY is not set
-CONFIG_JBD=m
-# CONFIG_JBD_DEBUG is not set
-CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_FS_POSIX_ACL is not set
-CONFIG_XFS_FS=m
-# CONFIG_XFS_QUOTA is not set
-# CONFIG_XFS_SECURITY is not set
-# CONFIG_XFS_POSIX_ACL is not set
-# CONFIG_XFS_RT is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_ROMFS_FS is not set
-CONFIG_INOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
-CONFIG_DNOTIFY=y
-# CONFIG_AUTOFS_FS is not set
-CONFIG_AUTOFS4_FS=m
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=m
-CONFIG_MSDOS_FS=m
-CONFIG_VFAT_FS=m
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_HUGETLB_PAGE is not set
-CONFIG_RAMFS=y
-# CONFIG_CONFIGFS_FS is not set
-
-#
-# Miscellaneous filesystems
-#
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-# CONFIG_JFFS_FS is not set
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
-CONFIG_JFFS2_FS_WRITEBUFFER=y
-# CONFIG_JFFS2_SUMMARY is not set
-# CONFIG_JFFS2_FS_XATTR is not set
-# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
-CONFIG_JFFS2_ZLIB=y
-CONFIG_JFFS2_RTIME=y
-# CONFIG_JFFS2_RUBIN is not set
-CONFIG_CRAMFS=y
-# CONFIG_VXFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-
-#
-# Network File Systems
-#
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V3_ACL is not set
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFS_DIRECTIO is not set
-CONFIG_NFSD=m
-CONFIG_NFSD_V3=y
-# CONFIG_NFSD_V3_ACL is not set
-# CONFIG_NFSD_V4 is not set
-CONFIG_NFSD_TCP=y
-CONFIG_ROOT_NFS=y
-CONFIG_LOCKD=y
-CONFIG_LOCKD_V4=y
-CONFIG_EXPORTFS=m
-CONFIG_NFS_COMMON=y
-CONFIG_SUNRPC=y
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RPCSEC_GSS_SPKM3 is not set
-CONFIG_SMB_FS=m
-# CONFIG_SMB_NLS_DEFAULT is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-# CONFIG_9P_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-
-#
-# Native Language Support
-#
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=m
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-CONFIG_NLS_ASCII=m
-CONFIG_NLS_ISO8859_1=m
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-CONFIG_NLS_UTF8=m
-
-#
-# Profiling support
-#
-# CONFIG_PROFILING is not set
-
-#
-# Kernel hacking
-#
-# CONFIG_PRINTK_TIME is not set
-# CONFIG_MAGIC_SYSRQ is not set
-# CONFIG_UNUSED_SYMBOLS is not set
-# CONFIG_DEBUG_KERNEL is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_DEBUG_BUGVERBOSE is not set
-# CONFIG_DEBUG_FS is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_UNWIND_INFO is not set
-# CONFIG_DEBUG_USER is not set
-
-#
-# CodeTEST setup
-#
-# CONFIG_CODETEST is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-
-#
-# Cryptographic options
-#
-# CONFIG_CRYPTO is not set
-
-#
-# Hardware crypto devices
-#
-
-#
-# Library routines
-#
-CONFIG_CRC_CCITT=m
-# CONFIG_CRC16 is not set
-CONFIG_CRC32=y
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_PLIST=y
diff --git a/arch/arm/configs/mxc30030evb_defconfig b/arch/arm/configs/mxc30030evb_defconfig
index f77e836..b208f66 100644
--- a/arch/arm/configs/mxc30030evb_defconfig
+++ b/arch/arm/configs/mxc30030evb_defconfig
@@ -157,7 +157,6 @@ CONFIG_ARCH_MXC91321=y
 # CONFIG_ARCH_MXC91231 is not set
 # CONFIG_ARCH_MXC91221 is not set
 # CONFIG_ARCH_MXC91131 is not set
-# CONFIG_ARCH_MX33 is not set
 # CONFIG_ARCH_MX3 is not set
 # CONFIG_ARCH_MX27 is not set
 # CONFIG_ARCH_MX21 is not set
diff --git a/arch/arm/mach-mx33/Kconfig b/arch/arm/mach-mx33/Kconfig
deleted file mode 100644
index b4ffa50..0000000
--- a/arch/arm/mach-mx33/Kconfig
+++ /dev/null
@@ -1,21 +0,0 @@
-menu "MX33 Options"
-	depends on ARCH_MX33
-
-config MACH_MX33ADS
-	bool "Support MX33ADS platforms"
-	default y
-	help
-	  Include support for MX33ADS platform. This includes specific
-	  configurations for the board and its peripherals.
-
-config MXC_TZIC
-	bool
-	default y
-
-config MXC_SDMA_API
-        bool "Use SDMA API"
-        default y
-        help
-           This selects the Freescale MXC SDMA API.
-           If unsure, say N.
-endmenu
diff --git a/arch/arm/mach-mx33/Makefile b/arch/arm/mach-mx33/Makefile
deleted file mode 100644
index 9958792..0000000
--- a/arch/arm/mach-mx33/Makefile
+++ /dev/null
@@ -1,12 +0,0 @@
-#
-# Makefile for the linux kernel.
-#
-
-# Object file lists.
-
-obj-y			:= system.o iomux.o cpu.o mm.o clock.o devices.o serial.o irq.o dma.o
-
-obj-$(CONFIG_MACH_MX33ADS)	+= mx33ads.o mx33ads_gpio.o
-
-# power management
-obj-$(CONFIG_MXC_DVFS)  += dvfs.o
diff --git a/arch/arm/mach-mx33/Makefile.boot b/arch/arm/mach-mx33/Makefile.boot
deleted file mode 100644
index 2d4ddc3..0000000
--- a/arch/arm/mach-mx33/Makefile.boot
+++ /dev/null
@@ -1,3 +0,0 @@
-   zreladdr-y	:= 0x50008000
-params_phys-y	:= 0x50000100
-initrd_phys-y	:= 0x50800000
diff --git a/arch/arm/mach-mx33/clock.c b/arch/arm/mach-mx33/clock.c
deleted file mode 100644
index 5b99ee2..0000000
--- a/arch/arm/mach-mx33/clock.c
+++ /dev/null
@@ -1,1292 +0,0 @@
-/*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-/*!
- * @file clock.c
- * @brief API for setting up and retrieving clocks.
- *
- * This file contains API for setting up and retrieving clocks.
- *
- * @ingroup CLOCKS
- */
-
-#include <linux/module.h>
-#include <linux/spinlock.h>
-#include <asm/io.h>
-#include <asm/arch/clock.h>
-
-#include "crm_regs.h"
-
-/*!
- * Spinlock to protect CRM register accesses
- */
-static DEFINE_SPINLOCK(mxc_crm_lock);
-
-int __mxc_get_clocks_div(enum mxc_clocks clk, unsigned int *div);
-
-/*
- * This function returns the clock CKIH clock input value.
- */
-static unsigned long mxc_clock_ckih(void)
-{
-	static unsigned long g_clk_ckih = 0;
-
-	if (g_clk_ckih == 0) {
-		g_clk_ckih = CKIH_CLK_FREQ;
-		pr_info("Clock input source is %ld\n", g_clk_ckih);
-	}
-
-	return g_clk_ckih;
-}
-
-/*!
- * This function returns the PLL output value in Hz based on pll.
- * @param       pll     PLL as defined in enum plls
- * @return      PLL value in Hz.
- */
-unsigned long mxc_pll_clock(enum plls pll)
-{
-	unsigned long mfi, mfn, mfd, pdf, ref_clk;
-	volatile unsigned long base, reg;
-	unsigned long long temp;
-
-	reg = __raw_readl(MXC_CCM_CCSR);
-	ref_clk = mxc_clock_ckih();
-
-	switch (pll) {
-	case MCUPLL:
-		/*TODO::assume just configure step_clk to reference clock */
-		if ((reg & MXC_CCM_CCSR_PLL1_BYPASS) == 1) {
-			return ref_clk;
-		}
-		base = MXC_DPLL1_BASE;
-		break;
-	case BUSPLL:
-		base = MXC_DPLL2_BASE;
-		break;
-	case SERIALPLL:
-		base = MXC_DPLL3_BASE;
-		break;
-	default:
-		printk(KERN_ERR "\nUnknown pll: %d\n\n", pll);
-		BUG();		/* oops */
-		return 0;
-	}
-
-	mfn = __raw_readl(base + MXC_DPLL_DP_HFS_MFN);
-	reg = __raw_readl(base + MXC_DPLL_DP_HFS_OP);
-	pdf = ((reg & MXC_DPLL_PDF_MASK) >> MXC_DPLL_PDF_OFFSET);
-	mfi = ((reg & MXC_DPLL_MFI_MASK) >> MXC_DPLL_MFI_OFFSET);
-	reg = __raw_readl(base + MXC_DPLL_DP_HFS_MFD);
-	mfd = ((reg & MXC_DPLL_MFD_MASK) >> MXC_DPLL_MFD_OFFSET);
-	reg = __raw_readl(base + MXC_DPLL_DP_HFS_MFN);
-	mfi = (mfi <= 5) ? 5 : mfi;
-
-	temp = (unsigned long long)2 *ref_clk * mfn;
-	do_div(temp, mfd + 1);
-	temp = (unsigned long long)2 *ref_clk * mfi + temp;
-	do_div(temp, pdf + 1);
-
-	return (unsigned long)temp;
-}
-
-/*!
- * This function returns the mcu main clock frequency
- *
- * @return      mcu main clock value in Hz.
- */
-static unsigned long mxc_main_clock(unsigned long reg, unsigned int offset)
-{
-	unsigned long val = (__raw_readl(reg) >> offset) & 3;
-
-	if (val == 2) {
-		return mxc_pll_clock(SERIALPLL);
-	} else if (val == 1) {
-		return mxc_pll_clock(BUSPLL);
-	}
-	return mxc_pll_clock(MCUPLL);
-}
-
-/*!
- * This function returns the main clock values in Hz.
- *
- * @param       clk     as defined in enum mxc_clocks
- *
- * @return      clock value in Hz
- */
-unsigned long mxc_get_clocks(enum mxc_clocks clk)
-{
-	unsigned long pll, ret_val = 0;
-	switch (clk) {
-		/*TODO:: Need support it. */
-		/*case CKIL_CLK:
-		   ret_val = CKIL_CLK_FREQ;
-		   break; */
-	case CKIH_CLK:
-		ret_val = mxc_clock_ckih();
-		break;
-	case CPU_CLK:
-		pll = mxc_pll_clock(MCUPLL);
-		ret_val = pll / mxc_get_clocks_div(CPU_CLK);
-		break;
-	case AHB_CLK:
-		pll =
-		    mxc_main_clock(MXC_CCM_CAMR,
-				   MXC_CCM_CAMR_PERIPH_CLK_SEL_OFFSET);
-		ret_val = pll / mxc_get_clocks_div(AHB_CLK);
-		break;
-	case NFC_CLK:
-		pll =
-		    mxc_main_clock(MXC_CCM_CAMR,
-				   MXC_CCM_CAMR_PERIPH_CLK_SEL_OFFSET);
-		ret_val = pll / mxc_get_clocks_div(NFC_CLK);
-		break;
-	case UART1_BAUD:
-	case UART2_BAUD:
-	case UART3_BAUD:
-	case UART4_BAUD:
-	case UART5_BAUD:
-	case I2C_CLK:
-	case I2C2_CLK:
-	case I2C3_CLK:
-	case OWIRE_CLK:
-	case GPT_CLK:
-	case PERCLK:
-		pll = __raw_readl(MXC_CCM_CSCMR1);
-		pll =
-		    mxc_main_clock(MXC_CCM_CAMR,
-				   MXC_CCM_CAMR_PERIPH_CLK_SEL_OFFSET);
-		ret_val = pll / mxc_get_clocks_div(clk);
-		break;
-	case SDMA_CLK:
-	case IPG_CLK:
-		pll =
-		    mxc_main_clock(MXC_CCM_CAMR,
-				   MXC_CCM_CAMR_PERIPH_CLK_SEL_OFFSET);
-		ret_val =
-		    pll / (mxc_get_clocks_div(AHB_CLK) +
-			   mxc_get_clocks_div(IPG_CLK));
-		break;
-	case SDHC1_CLK:
-	case SDHC2_CLK:
-	case SDHC3_CLK:
-	case MSTICK1_BAUD:
-	case MSTICK2_BAUD:
-		pll = mxc_get_clocks_parent(clk);
-		ret_val = pll / mxc_get_clocks_div(clk);
-		break;
-	default:
-		ret_val = 66516666;
-		break;
-	}
-	return ret_val;
-}
-
-/*!
- * This function returns the parent clock values in Hz.
- *
- * @param       clk     as defined in enum mxc_clocks
- *
- * @return      clock value in Hz
- */
-unsigned long mxc_get_clocks_parent(enum mxc_clocks clk)
-{
-	unsigned long ret_val = 0;
-	unsigned long reg = __raw_readl(MXC_CCM_CSCMR1);
-
-	switch (clk) {
-	case CSI1_BAUD:
-		reg = MXC_CCM_GET_FIELD(reg,
-					MXC_CCM_CSCMR1_SEL_BITS,
-					MXC_CCM_CSCMR1_CSI_MCLK1_CLK_SEL_OFFSET);
-		break;
-	case CSI2_BAUD:
-		reg = MXC_CCM_GET_FIELD(reg,
-					MXC_CCM_CSCMR1_SEL_BITS,
-					MXC_CCM_CSCMR1_CSI_MCLK2_CLK_SEL_OFFSET);
-		break;
-	case SDHC3_CLK:
-		if (reg & (1 << MXC_CCM_CSCMR1_ESDHC3_CLK_SEL_OFFSET)) {
-			clk = SDHC2_CLK;
-		} else {
-			clk = SDHC1_CLK;
-		}
-	case SDHC1_CLK:
-	case SDHC2_CLK:
-	case MSTICK1_BAUD:
-	case MSTICK2_BAUD:
-		if (clk == SDHC1_CLK || clk == MSTICK1_BAUD) {
-			reg = MXC_CCM_GET_FIELD(reg,
-						MXC_CCM_CSCMR1_SEL_BITS,
-						MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_OFFSET);
-		} else {
-			reg = MXC_CCM_GET_FIELD(reg,
-						MXC_CCM_CSCMR1_SEL_BITS,
-						MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_OFFSET);
-		}
-		break;
-	default:
-		return ret_val;
-	}
-	switch (reg) {
-	case 0:		/*PLL1_sw_clock */
-		ret_val = mxc_pll_clock(MCUPLL);
-		break;
-	case 1:		/*PLL2_sw_clock */
-		ret_val = mxc_pll_clock(BUSPLL);
-		break;
-	case 2:		/*PLL3_sw_clock */
-		ret_val = mxc_pll_clock(SERIALPLL);
-	}
-	return ret_val;
-}
-
-/*!
- * This function calculates the pre and post divider values for a clock
- *
- * @param div  divider value passed in
- * @param div1 returns the pre-divider value
- * @param div2 returns the post-divider value
- * @param lim1 limit of divider 1
- * @param lim2 limit of divider 2
- */
-void mxc_clk_getdivs(unsigned int div, unsigned int *div1,
-		     unsigned int *div2, int lim1, int lim2)
-{
-	int i;
-
-	if (div <= lim1) {
-		*div1 = div;
-		*div2 = 1;
-		return;
-	}
-	if (div <= lim2) {
-		*div1 = 1;
-		*div2 = div;
-		return;
-	}
-	for (i = 2; i < (lim1 + 1); i++) {
-		if ((div % i) == 0) {
-			*div1 = i;
-			*div2 = div / i;
-			return;
-		}
-	}
-
-	*div1 = 1;
-	*div2 = lim2;
-	return;
-}
-
-/*!
- * This function sets the PLL source for a clock.
- *
- * @param clk     as defined in enum mxc_clocks
- * @param pll_num the PLL that you wish to use as source for this clock
- */
-void mxc_set_clocks_pll(enum mxc_clocks clk, enum plls pll_num)
-{
-	unsigned long reg, sel;
-	unsigned long flags;
-
-	switch (pll_num) {
-	case MCUPLL:
-		sel = 0;
-		break;
-	case BUSPLL:
-		sel = 1;
-		break;
-	case SERIALPLL:
-		sel = 2;
-		break;
-	default:
-		return;
-	}
-
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-
-	switch (clk) {
-	case CSI1_BAUD:
-		reg = __raw_readl(MXC_CCM_CSCMR1);
-		reg &= ~(MXC_CCM_MASK(MXC_CCM_CSCMR1_SEL_BITS,
-				      MXC_CCM_CSCMR1_CSI_MCLK1_CLK_SEL_OFFSET));
-		reg |= sel << MXC_CCM_CSCMR1_CSI_MCLK1_CLK_SEL_OFFSET;
-		__raw_writel(reg, MXC_CCM_CSCMR1);
-		break;
-	case CSI2_BAUD:
-		reg = __raw_readl(MXC_CCM_CSCMR1);
-		reg &= ~(MXC_CCM_MASK(MXC_CCM_CSCMR1_SEL_BITS,
-				      MXC_CCM_CSCMR1_CSI_MCLK2_CLK_SEL_OFFSET));
-		reg |= sel << MXC_CCM_CSCMR1_CSI_MCLK2_CLK_SEL_OFFSET;
-		__raw_writel(reg, MXC_CCM_CSCMR1);
-		break;
-	default:
-		printk(KERN_ERR
-		       "This clock does not have ability to choose its clock source\n");
-		break;
-	}
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-	return;
-}
-
-/*!
- * This function gets the divider value for a clock .
- *
- * @param clk as defined in enum mxc_clocks
- * @return the division factor
- */
-unsigned long mxc_get_clocks_div(enum mxc_clocks clk)
-{
-	unsigned long reg, flags, ret = 1;
-	unsigned int div1 = 0, div2 = 0, div3 = 0;
-
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-	switch (clk) {
-	case AHB_CLK:
-		reg = __raw_readl(MXC_CCM_CBCDR2);
-		ret = 1 + MXC_CCM_GET_FIELD(reg,
-					    MXC_CCM_CBCDR2_AHB_CORE_PODF_BITS,
-					    MXC_CCM_CBCDR2_AHB_CORE_PODF_OFFSET);
-		break;
-	case CPU_CLK:
-		reg = __raw_readl(MXC_CCM_CACRR);
-		ret = 1 + (MXC_CCM_GET_FIELD(reg,
-					     MXC_CCM_CACRR_ARM_PODF_BITS,
-					     MXC_CCM_CACRR_ARM_PODF_OFFSET));
-		break;
-	case SDMA_CLK:
-	case IPG_CLK:
-		reg = __raw_readl(MXC_CCM_CBCDR2);
-		ret = 1 + MXC_CCM_GET_FIELD(reg,
-					    MXC_CCM_CBCDR2_IPG_CORE_PODF_BITS,
-					    MXC_CCM_CBCDR2_IPG_CORE_PODF_OFFSET);
-		break;
-	case NFC_CLK:
-		reg = __raw_readl(MXC_CCM_CBCDR7);
-		ret = 1 + MXC_CCM_GET_FIELD(reg,
-					    MXC_CCM_CBCDR7_NFC_PODF_BITS,
-					    MXC_CCM_CBCDR7_NFC_PODF_OFFSET);
-		break;
-	case CSI1_BAUD:
-	case CSI2_BAUD:
-		reg = __raw_readl(MXC_CCM_CSCDR2);
-		if (clk == CSI1_BAUD) {
-			div1 = 1 + MXC_CCM_GET_FIELD(reg,
-						     MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PRED_BITS,
-						     MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PRED_OFFSET);
-			div2 = 1 + MXC_CCM_GET_FIELD(reg,
-						     MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PODF_BITS,
-						     MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PODF_OFFSET);
-		} else {
-			div1 = 1 + MXC_CCM_GET_FIELD(reg,
-						     MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PRED_BITS,
-						     MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PRED_OFFSET);
-			div2 = 1 + MXC_CCM_GET_FIELD(reg,
-						     MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PODF_BITS,
-						     MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PODF_OFFSET);
-		}
-		ret = div1 * div2;
-		break;
-	case UART1_BAUD:
-	case UART2_BAUD:
-	case UART3_BAUD:
-	case UART4_BAUD:
-	case UART5_BAUD:
-	case I2C_CLK:
-	case I2C2_CLK:
-	case I2C3_CLK:
-	case OWIRE_CLK:
-	case GPT_CLK:
-	case PERCLK:
-		reg = __raw_readl(MXC_CCM_CBCDR2);
-		div1 = 1 + MXC_CCM_GET_FIELD(reg,
-					     MXC_CCM_CBCDR2_PERCLK_PRED1_BITS,
-					     MXC_CCM_CBCDR2_PERCLK_PRED1_OFFSET);
-		div2 = 1 + MXC_CCM_GET_FIELD(reg,
-					     MXC_CCM_CBCDR2_PERCLK_PRED2_BITS,
-					     MXC_CCM_CBCDR2_PERCLK_PRED2_OFFSET);
-		div3 = 1 + MXC_CCM_GET_FIELD(reg,
-					     MXC_CCM_CBCDR2_PERCLK_PODF_BITS,
-					     MXC_CCM_CBCDR2_PERCLK_PODF_OFFSET);
-		ret = div1 * div2 * div3;
-		break;
-	case SDHC3_CLK:
-		reg = __raw_readl(MXC_CCM_CSCMR1);
-		if (reg & (1 << MXC_CCM_CSCMR1_ESDHC3_CLK_SEL_OFFSET)) {
-			clk = SDHC2_CLK;
-		} else {
-			clk = SDHC1_CLK;
-		}
-	case SDHC1_CLK:
-	case SDHC2_CLK:
-	case MSTICK1_BAUD:
-	case MSTICK2_BAUD:
-		reg = __raw_readl(MXC_CCM_CSCDR1);
-		if (clk == SDHC1_CLK || clk == MSTICK1_BAUD) {
-			div1 = 1 + MXC_CCM_GET_FIELD(reg,
-						     MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_BITS,
-						     MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_OFFSET);
-			div2 = 1 + MXC_CCM_GET_FIELD(reg,
-						     MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_BITS,
-						     MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_OFFSET);
-		} else {
-			div1 = 1 + MXC_CCM_GET_FIELD(reg,
-						     MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_BITS,
-						     MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_OFFSET);
-			div2 = 1 + MXC_CCM_GET_FIELD(reg,
-						     MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_BITS,
-						     MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET);
-		}
-		ret = div1 * div2;
-		break;
-	default:
-		break;
-	}
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-	return ret;
-}
-
-/*!
- * This function sets the divider value for a clock.
- *
- * @param clk as defined in enum mxc_clocks
- * @param div the division factor to be used for the clock (For SSI & CSI, pass
- *            in 2 times the expected division value to account for FP vals on certain
- *            platforms)
- */
-void mxc_set_clocks_div(enum mxc_clocks clk, unsigned int div)
-{
-	volatile unsigned long reg;
-	unsigned long flags;
-	unsigned int d = 0, div1 = 0, div2 = 0, div3;
-
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-
-	switch (clk) {
-	case AHB_CLK:
-		reg = __raw_readl(MXC_CCM_CBCDR2);
-		reg &= (~MXC_CCM_MASK(MXC_CCM_CBCDR2_AHB_CORE_PODF_BITS,
-				      MXC_CCM_CBCDR2_AHB_CORE_PODF_OFFSET));
-		reg |= (((div - 1) << MXC_CCM_CBCDR2_AHB_CORE_PODF_OFFSET) &
-			MXC_CCM_MASK(MXC_CCM_CBCDR2_AHB_CORE_PODF_BITS,
-				     MXC_CCM_CBCDR2_AHB_CORE_PODF_OFFSET));
-		__raw_writel(reg, MXC_CCM_CBCDR2);
-		break;
-	case CPU_CLK:
-		reg = __raw_readl(MXC_CCM_CACRR);
-		reg &= (~MXC_CCM_MASK(MXC_CCM_CACRR_ARM_PODF_BITS,
-				      MXC_CCM_CACRR_ARM_PODF_OFFSET));
-		reg |= (((div - 1) << MXC_CCM_CACRR_ARM_PODF_OFFSET) &
-			MXC_CCM_MASK(MXC_CCM_CACRR_ARM_PODF_BITS,
-				     MXC_CCM_CACRR_ARM_PODF_OFFSET));
-		__raw_writel(reg, MXC_CCM_CACRR);
-		break;
-	case IPG_CLK:
-		reg = __raw_readl(MXC_CCM_CBCDR2);
-		reg &= (~MXC_CCM_MASK(MXC_CCM_CBCDR2_AHB_CORE_PODF_BITS,
-				      MXC_CCM_CBCDR2_IPG_CORE_PODF_OFFSET));
-		reg |= (((div - 1) << MXC_CCM_CBCDR2_IPG_CORE_PODF_OFFSET) &
-			MXC_CCM_MASK(MXC_CCM_CBCDR2_AHB_CORE_PODF_BITS,
-				     MXC_CCM_CBCDR2_IPG_CORE_PODF_OFFSET));
-		__raw_writel(reg, MXC_CCM_CBCDR2);
-		break;
-	case NFC_CLK:
-		reg = __raw_readl(MXC_CCM_CBCDR7);
-		reg &= (~MXC_CCM_MASK(MXC_CCM_CBCDR7_NFC_PODF_BITS,
-				      MXC_CCM_CBCDR7_NFC_PODF_OFFSET));
-		reg |= (((div - 1) << MXC_CCM_CBCDR7_NFC_PODF_OFFSET) &
-			MXC_CCM_MASK(MXC_CCM_CBCDR7_NFC_PODF_BITS,
-				     MXC_CCM_CBCDR7_NFC_PODF_OFFSET));
-		__raw_writel(reg, MXC_CCM_CBCDR7);
-		break;
-	case CSI1_BAUD:
-	case CSI2_BAUD:
-		d = div / 2;
-		mxc_clk_getdivs(d, &div1, &div2, 8, 64);
-		reg = __raw_readl(MXC_CCM_CSCDR2);
-		if (clk == CSI1_BAUD) {
-			reg &=
-			    ~MXC_CCM_MASK(MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PRED_BITS
-					  +
-					  MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PODF_BITS,
-					  MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PODF_OFFSET);
-			reg |=
-			    ((((div1 -
-				1) << MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PRED_OFFSET)
-			      | ((div2 - 1) <<
-				 MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PODF_OFFSET)) &
-			     MXC_CCM_MASK(MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PRED_BITS
-					  +
-					  MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PODF_BITS,
-					  MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PODF_OFFSET));
-		} else {
-			reg &=
-			    ~MXC_CCM_MASK(MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PRED_BITS
-					  +
-					  MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PODF_BITS,
-					  MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PODF_OFFSET);
-			reg |=
-			    ((((div1 -
-				1) << MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PRED_OFFSET)
-			      | ((div2 - 1) <<
-				 MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PODF_OFFSET)) &
-			     MXC_CCM_MASK(MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PRED_BITS
-					  +
-					  MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PODF_BITS,
-					  MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PODF_OFFSET));
-		}
-		__raw_writel(reg, MXC_CCM_CSCDR2);
-		break;
-	case UART1_BAUD:
-	case UART2_BAUD:
-	case UART3_BAUD:
-	case UART4_BAUD:
-	case UART5_BAUD:
-	case I2C_CLK:
-	case I2C2_CLK:
-	case I2C3_CLK:
-	case OWIRE_CLK:
-	case GPT_CLK:
-	case PERCLK:
-		d = div / 2;
-		mxc_clk_getdivs(d, &div2, &div3, 32, 8);
-		d = div2 / 2;
-		mxc_clk_getdivs(d, &div1, &div2, 4, 8);
-		reg = __raw_readl(MXC_CCM_CBCDR2);
-		reg &= (~MXC_CCM_MASK(MXC_CCM_CBCDR2_PERCLK_PRED1_BITS +
-				      MXC_CCM_CBCDR2_PERCLK_PRED2_BITS +
-				      MXC_CCM_CBCDR2_PERCLK_PODF_BITS,
-				      MXC_CCM_CBCDR2_PERCLK_PODF_OFFSET));
-		reg |= ((((div1 - 1) << MXC_CCM_CBCDR2_PERCLK_PRED1_OFFSET) |
-			 ((div2 - 1) << MXC_CCM_CBCDR2_PERCLK_PRED2_OFFSET) |
-			 ((div3 - 1) << MXC_CCM_CBCDR2_PERCLK_PODF_OFFSET)) &
-			MXC_CCM_MASK(MXC_CCM_CBCDR2_PERCLK_PRED1_BITS +
-				     MXC_CCM_CBCDR2_PERCLK_PRED2_BITS +
-				     MXC_CCM_CBCDR2_PERCLK_PODF_BITS,
-				     MXC_CCM_CBCDR2_PERCLK_PODF_OFFSET));
-		__raw_writel(reg, MXC_CCM_CBCDR2);
-		break;
-	default:
-		break;
-	}
-
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-}
-
-/*!
- * This function is called to enable the individual module clocks
- *
- * @param       clk     as defined in enum mxc_clocks
- */
-void mxc_clks_enable(enum mxc_clocks clk)
-{
-	unsigned long flags;
-	unsigned long reg;
-
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-	switch (clk) {
-	case UART1_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_UART1_IPG_CLK_GATE,
-				    MXC_CCM_CCGR_UART1_IPG_CLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_UART1_PERCLK_GATE,
-				    MXC_CCM_CCGR_UART1_PERCLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case UART2_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_UART2_IPG_CLK_GATE,
-				    MXC_CCM_CCGR_UART2_IPG_CLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_UART2_PERCLK_GATE,
-				    MXC_CCM_CCGR_UART2_PERCLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case UART3_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_UART3_IPG_CLK_GATE,
-				    MXC_CCM_CCGR_UART3_IPG_CLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_UART3_PERCLK_GATE,
-				    MXC_CCM_CCGR_UART3_PERCLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case UART4_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_UART4_IPG_CLK_GATE,
-				    MXC_CCM_CCGR_UART4_IPG_CLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_UART4_PERCLK_GATE,
-				    MXC_CCM_CCGR_UART4_PERCLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case UART5_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_UART5_IPG_CLK_GATE,
-				    MXC_CCM_CCGR_UART5_IPG_CLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_UART5_PERCLK_GATE,
-				    MXC_CCM_CCGR_UART5_PERCLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case I2C1_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_I2C1_CLK_GATE,
-				    MXC_CCM_CCGR_I2C1_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case I2C2_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_I2C2_CLK_GATE,
-				    MXC_CCM_CCGR_I2C2_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case I2C3_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR2);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_I2C3_CLK_GATE,
-				    MXC_CCM_CCGR_I2C3_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR2);
-		break;
-	case OWIRE_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR2);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_OWIRE_CLK_GATE,
-				    MXC_CCM_CCGR_OWIRE_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR2);
-		break;
-	case FEC_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR2);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_FEC_CLK_GATE,
-				    MXC_CCM_CCGR_FEC_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR2);
-		break;
-	case USB_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR2);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_USBOH2_IPG_HCLK_GATE,
-				    MXC_CCM_CCGR_USBOH2_IPG_HCLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_USBOH2_60M_CLK_GATE,
-				    MXC_CCM_CCGR_USBOH2_60M_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR2);
-		break;
-	case SSI1_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_SSI1_IPG_CLK_GATE,
-				    MXC_CCM_CCGR_SSI1_IPG_CLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_SSI1_SSI_CLK_GATE,
-				    MXC_CCM_CCGR_SSI1_SSI_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case SSI2_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_SSI2_IPG_CLK_GATE,
-				    MXC_CCM_CCGR_SSI2_IPG_CLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_SSI2_SSI_CLK_GATE,
-				    MXC_CCM_CCGR_SSI2_SSI_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case SSI_EXT1_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_SSI_EXT1_CLK_GATE,
-				    MXC_CCM_CCGR_SSI_EXT1_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case SSI_EXT2_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_SSI_EXT2_CLK_GATE,
-				    MXC_CCM_CCGR_SSI_EXT2_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case MARC_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_MARC_CLK_GATE,
-				    MXC_CCM_CCGR_MARC_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case CSI1_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR5);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_CSI_MCLK1_CLK_GATE,
-				    MXC_CCM_CCGR_CSI_MCLK1_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR5);
-		break;
-	case CSI2_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR5);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_CSI_MCLK2_CLK_GATE,
-				    MXC_CCM_CCGR_CSI_MCLK2_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR5);
-		break;
-	case IPU_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR4);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_DI_CLK_GATE,
-				    MXC_CCM_CCGR_DI_CLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_IPU_CLK_GATE,
-				    MXC_CCM_CCGR_IPU_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR4);
-		break;
-	case SDHC1_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR2);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_ESDHC1_IPG_HCLK_GATE,
-				    MXC_CCM_CCGR_ESDHC1_IPG_HCLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_ESDHC1_PERCLK_GATE,
-				    MXC_CCM_CCGR_ESDHC1_PERCLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR2);
-		break;
-	case SDHC2_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR2);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_ESDHC2_IPG_HCLK_GATE,
-				    MXC_CCM_CCGR_ESDHC2_IPG_HCLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR2);
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_ESDHC2_PERCLK_GATE,
-				    MXC_CCM_CCGR_ESDHC2_PERCLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case SDHC3_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_ESDHC3_IPG_HCLK_GATE,
-				    MXC_CCM_CCGR_ESDHC3_IPG_HCLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_ESDHC3_PERCLK_GATE,
-				    MXC_CCM_CCGR_ESDHC3_PERCLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case CSPI1_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR4);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_CSPI1_IPG_CLK_GATE,
-				    MXC_CCM_CCGR_CSPI1_IPG_CLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_CSPI1_PERCLK_GATE,
-				    MXC_CCM_CCGR_CSPI1_PERCLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR4);
-		break;
-	case CSPI2_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR4);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_CSPI2_IPG_CLK_GATE,
-				    MXC_CCM_CCGR_CSPI2_IPG_CLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_CSPI2_PERCLK_GATE,
-				    MXC_CCM_CCGR_CSPI2_PERCLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR4);
-		break;
-	case CSPI3_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR4);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_CSPI3_IPG_CLK_GATE,
-				    MXC_CCM_CCGR_CSPI3_IPG_CLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_CSPI3_PERCLK_GATE,
-				    MXC_CCM_CCGR_CSPI3_PERCLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR4);
-		break;
-	case ATA_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_PATA_CLK_GATE,
-				    MXC_CCM_CCGR_PATA_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case SIM_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_SIM_CLK_GATE,
-				    MXC_CCM_CCGR_SIM_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case RTIC_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR4);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_RTIC_CLK_GATE,
-				    MXC_CCM_CCGR_RTIC_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR4);
-		break;
-	case SDMA_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR5);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_SDMA_CLK_GATE,
-				    MXC_CCM_CCGR_SDMA_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR5);
-		break;
-	case MSTICK1_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_MSHC1_IPG_HCLK_GATE,
-				    MXC_CCM_CCGR_MSHC1_IPG_HCLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_MSHC1_DI_CLK_GATE,
-				    MXC_CCM_CCGR_MSHC1_DI_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case MSTICK2_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_MSHC2_IPG_HCLK_GATE,
-				    MXC_CCM_CCGR_MSHC2_IPG_HCLK_EN);
-		reg =
-		    MXC_CCM_CCGR_ON(reg, MXC_CCM_CCGR_MSHC2_DI_CLK_GATE,
-				    MXC_CCM_CCGR_MSHC2_DI_CLK_EN);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	default:
-		break;
-	}
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-}
-
-/*!
- * This function is called to disable the individual module clocks
- *
- * @param       clk     as defined in enum mxc_clocks
- */
-void mxc_clks_disable(enum mxc_clocks clk)
-{
-	unsigned long flags;
-	unsigned long reg;
-
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-	switch (clk) {
-	case UART1_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_UART1_IPG_CLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_UART1_PERCLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case UART2_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_UART2_IPG_CLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_UART2_PERCLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case UART3_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_UART3_IPG_CLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_UART3_PERCLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case UART4_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_UART4_IPG_CLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_UART4_PERCLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case UART5_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_UART5_IPG_CLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_UART5_PERCLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case I2C1_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_I2C1_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case I2C2_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR1);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_I2C2_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR1);
-		break;
-	case I2C3_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR2);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_I2C3_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR2);
-		break;
-	case OWIRE_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR2);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_OWIRE_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR2);
-		break;
-	case FEC_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR2);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_FEC_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR2);
-		break;
-	case USB_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR2);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_USBOH2_IPG_HCLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_USBOH2_60M_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR2);
-		break;
-	case SSI1_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_SSI1_IPG_CLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_SSI1_SSI_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case SSI2_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_SSI2_IPG_CLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_SSI2_SSI_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case SSI_EXT1_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_SSI_EXT1_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case SSI_EXT2_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_SSI_EXT2_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case MARC_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_MARC_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case CSI1_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR5);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_CSI_MCLK1_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR5);
-		break;
-	case CSI2_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR5);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_CSI_MCLK2_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR5);
-		break;
-	case IPU_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR4);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_DI_CLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_IPU_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR4);
-		break;
-	case SDHC1_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR2);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_ESDHC1_IPG_HCLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_ESDHC1_PERCLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR2);
-		break;
-	case SDHC2_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR2);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_ESDHC2_IPG_HCLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR2);
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_ESDHC2_PERCLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case SDHC3_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_ESDHC3_IPG_HCLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_ESDHC3_PERCLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case CSPI1_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR4);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_CSPI1_IPG_CLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_CSPI1_PERCLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR4);
-		break;
-	case CSPI2_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR4);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_CSPI2_IPG_CLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_CSPI2_PERCLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR4);
-		break;
-	case CSPI3_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR4);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_CSPI3_IPG_CLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_CSPI3_PERCLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR4);
-		break;
-	case ATA_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_PATA_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case SIM_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_SIM_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case RTIC_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR4);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_RTIC_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR4);
-		break;
-	case SDMA_CLK:
-		reg = __raw_readl(MXC_CCM_CCGR5);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_SDMA_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR5);
-		break;
-	case MSTICK1_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_MSHC1_IPG_HCLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_MSHC1_DI_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	case MSTICK2_BAUD:
-		reg = __raw_readl(MXC_CCM_CCGR3);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_MSHC2_IPG_HCLK_GATE);
-		reg = MXC_CCM_CCGR_OFF(reg, MXC_CCM_CCGR_MSHC2_DI_CLK_GATE);
-		__raw_writel(reg, MXC_CCM_CCGR3);
-		break;
-	default:
-		break;
-	}
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-}
-
-/*!
- * This function is called to read the contents of a CCM register
- *
- * @param reg_offset the CCM register that will read
- *
- * @return the register contents
- */
-unsigned long mxc_ccm_get_reg(unsigned int reg_offset)
-{
-	volatile unsigned long reg;
-
-	reg = __raw_readl(reg_offset);
-	return reg;
-}
-
-/*!
- * This function is called to modify the contents of a CCM register
- *
- * @param reg_offset the CCM register that will read
- * @param mask       the mask to be used to clear the bits that are to be modified
- * @param data       the data that should be written to the register
- */
-void mxc_ccm_modify_reg(unsigned int reg_offset, unsigned int mask,
-			unsigned int data)
-{
-	unsigned long flags;
-	volatile unsigned long reg;
-
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-	reg = __raw_readl(reg_offset);
-	reg = (reg & (~mask)) | data;
-	__raw_writel(reg, reg_offset);
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-}
-
-/*!
- * This function is used to modify PLL registers to generate the required
- * frequency.
- *
- * @param  pll_num  the PLL that you wish to modify
- * @param  mfi      multiplication factor integer part
- * @param  pdf      pre-division factor
- * @param  mfd      multiplication factor denominator
- * @param  mfn      multiplication factor numerator
- */
-void mxc_pll_set(enum plls pll_num, unsigned int mfi, unsigned int pdf,
-		 unsigned int mfd, unsigned int mfn)
-{
-	volatile unsigned long ccmr;
-	unsigned long flags;
-	unsigned long base, val;
-
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-
-	if (pll_num == MCUPLL) {
-		/* Swap to reference clock and disable PLL */
-		/* The PLL1 step clock should be connect with reference clock */
-		ccmr = __raw_readl(MXC_CCM_CCSR);
-		ccmr |= MXC_CCM_CCSR_PLL1_BYPASS;
-		__raw_writel(ccmr, MXC_CCM_CCSR);
-	}
-	/* Change the Pll value */
-	switch (pll_num) {
-	case MCUPLL:
-		base = MXC_DPLL1_BASE;
-		break;
-	case BUSPLL:
-		base = MXC_DPLL2_BASE;
-		break;
-	case SERIALPLL:
-		base = MXC_DPLL3_BASE;
-		break;
-	default:
-		goto exit;
-	}
-
-	__raw_writel(mfn, base + MXC_DPLL_DP_HFS_MFN);
-
-	val = (mfd << MXC_DPLL_MFD_OFFSET) & MXC_DPLL_MFD_MASK;
-	__raw_writel(val, base + MXC_DPLL_DP_HFS_MFD);
-
-	val = (mfi << MXC_DPLL_MFI_OFFSET) & MXC_DPLL_MFI_MASK;
-	val |= (pdf << MXC_DPLL_PDF_OFFSET) & MXC_DPLL_PDF_MASK;
-	__raw_writel(val, base + MXC_DPLL_DP_HFS_OP);
-
-	val = __raw_readl(base + MXC_DPLL_DP_CONFIG);
-	val |= MXC_DPLL_DP_CONFIG_LDREQ;
-	__raw_writel(val, base + MXC_DPLL_DP_CONFIG);
-
-#if 0
-	//TODO: enable this section when it run in hardware.
-	while (1) {
-		if (!(__raw_readl(base + MXC_DPLL_DP_CONFIG) &
-		      MXC_DPLL_DP_CONFIG_LDREQ)) {
-			break;
-		}
-	}
-#endif
-
-	if (pll_num == MCUPLL) {
-		/* Swap to the new value */
-		ccmr = __raw_readl(MXC_CCM_CCSR);
-		ccmr &= ~MXC_CCM_CCSR_PLL1_BYPASS;
-		__raw_writel(ccmr, MXC_CCM_CCSR);
-	}
-      exit:
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-}
-
-/*!
- * This function is used to get PLL registers value used to generate the clock
- * frequency.
- *
- * @param  pll_num  the PLL that you wish to modify
- * @param  mfi      pointer that holds multiplication factor integer part
- * @param  pdf      pointer that holds pre-division factor
- * @param  mfd      pointer that holds multiplication factor denominator
- * @param  mfn      pointer that holds multiplication factor numerator
- */
-void mxc_pll_get(enum plls pll_num, unsigned int *mfi, unsigned int *pdf,
-		 unsigned int *mfd, unsigned int *mfn)
-{
-	unsigned long flags;
-	unsigned long base, val;
-
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-
-	switch (pll_num) {
-	case MCUPLL:
-		base = MXC_DPLL1_BASE;
-		break;
-	case BUSPLL:
-		base = MXC_DPLL2_BASE;
-		break;
-	case SERIALPLL:
-		base = MXC_DPLL3_BASE;
-		break;
-	default:
-		goto exit;
-	}
-
-	*mfn = __raw_readl(base + MXC_DPLL_DP_HFS_MFN);
-
-	val = __raw_readl(base + MXC_DPLL_DP_HFS_MFD);
-	*mfd = (val & MXC_DPLL_MFD_MASK) >> MXC_DPLL_MFD_OFFSET;
-
-	val = __raw_readl(base + MXC_DPLL_DP_HFS_OP);
-	*mfi = (val & MXC_DPLL_MFI_MASK) >> MXC_DPLL_MFI_OFFSET;
-	*pdf = (val & MXC_DPLL_PDF_MASK) >> MXC_DPLL_PDF_OFFSET;
-      exit:
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-}
-
-/*!
- * Configure clock output on CKO pin
- *
- * @param       output     as defined in enum mxc_clk_out
- * @param       clk        as defined in enum mxc_clocks
- * @param       div        clock output divider value. The possible values
- *                               for this are 1, 2, 4, 8 and 16
- *
- */
-void mxc_set_clock_output(enum mxc_clk_out output, enum mxc_clocks clk, int div)
-{
-	unsigned long flags;
-	u32 reg;
-
-	if ((--div) & 0xFFFFFFF8) {
-		/*invalid dividor */
-		return;
-	}
-
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-
-	reg = __raw_readl(MXC_CCM_CCOSR);
-
-	switch (output) {
-	case CKO2:
-		goto ret;
-	case CKO1:
-		reg &=
-		    ~(((1 << MXC_CCM_CCOSR_CKO1_DIV_BITS) -
-		       1) << MXC_CCM_CCOSR_CKO1_DIV_OFFSET);
-		reg &=
-		    ~(((1 << MXC_CCM_CCOSR_CKO1_SEL_BITS) -
-		       1) << MXC_CCM_CCOSR_CKO1_SEL_OFFSET);
-		switch (clk) {
-		case CPU_CLK:
-			/* To select AP clock : */
-			/*CPU_CLK = (0<<MXC_CCM_CCOSR_CKO1_SEL_OFFSET) */
-			break;
-		case AHB_CLK:
-			/* To select AHB clock */
-			reg |= 0x0000000B << MXC_CCM_CCOSR_CKO1_SEL_OFFSET;
-			break;
-		case IPG_CLK:
-			/* To select IP clock */
-			reg |= 0x0000000C << MXC_CCM_CCOSR_CKO1_SEL_OFFSET;
-			break;
-		default:
-			goto ret;
-		}
-		reg |= (1 << MXC_CCM_CCOSR_CKO1_EN_OFFSET);
-		break;
-	default:
-		goto ret;
-	}
-
-	__raw_writel(reg, MXC_CCM_CCOSR);
-
-      ret:
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-}
-
-EXPORT_SYMBOL(mxc_pll_get);
-EXPORT_SYMBOL(mxc_pll_set);
-EXPORT_SYMBOL(mxc_pll_clock);
-EXPORT_SYMBOL(mxc_get_clocks);
-EXPORT_SYMBOL(mxc_get_clocks_parent);
-EXPORT_SYMBOL(mxc_set_clocks_pll);
-EXPORT_SYMBOL(mxc_set_clocks_div);
-EXPORT_SYMBOL(mxc_get_clocks_div);
-EXPORT_SYMBOL(mxc_clks_disable);
-EXPORT_SYMBOL(mxc_clks_enable);
-EXPORT_SYMBOL(mxc_ccm_get_reg);
-EXPORT_SYMBOL(mxc_ccm_modify_reg);
-EXPORT_SYMBOL(mxc_set_clock_output);
diff --git a/arch/arm/mach-mx33/cpu.c b/arch/arm/mach-mx33/cpu.c
deleted file mode 100644
index 62aac06..0000000
--- a/arch/arm/mach-mx33/cpu.c
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- *  Copyright (C) 2001 Deep Blue Solutions Ltd.
- *  Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- */
-
-/*!
- * @file cpu.c
- *
- * @brief This file contains the CPU initialization code.
- *
- * @ingroup System
- */
-
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/cpufreq.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <asm/hardware.h>
-#include <asm/setup.h>
-#include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/cacheflush.h>
-#include <linux/proc_fs.h>
-
-/*!
- * CPU initialization. It is called by fixup_mxc_board()
- */
-void __init mxc_cpu_init(void)
-{
-	/* Setup Peripheral Port Remap register for AVIC */
-	asm("ldr r0, =0x80000016				\n\
-	 mcr p15, 0, r0, c15, c2, 4");
-}
-
-/*!
- * Post CPU init code
- *
- * @return 0 always
- */
-static int __init post_cpu_init(void)
-{
-	volatile unsigned long aips_reg;
-
-	/*
-	 * S/W workaround: Clear the off platform peripheral modules
-	 * Supervisor Protect bit for SDMA to access them.
-	 */
-	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x40));
-	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x44));
-	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x48));
-	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x4C));
-	aips_reg = __raw_readl(IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
-	aips_reg &= 0x00FFFFFF;
-	__raw_writel(aips_reg, IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
-
-	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x40));
-	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x44));
-	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x48));
-	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x4C));
-	aips_reg = __raw_readl(IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
-	aips_reg &= 0x00FFFFFF;
-	__raw_writel(aips_reg, IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
-
-	return 0;
-}
-
-postcore_initcall(post_cpu_init);
-
-static int mxc_clock_read_proc(char *page, char **start, off_t off,
-			       int count, int *eof, void *data)
-{
-	char *p = page;
-	int len;
-
-	p += sprintf(p, "MCUPLL:\t\t%lu\n", mxc_pll_clock(MCUPLL));
-	p += sprintf(p, "BUSPLL:\t\t%lu\n", mxc_pll_clock(BUSPLL));
-	p += sprintf(p, "SERIALPLL:\t%lu\n", mxc_pll_clock(SERIALPLL));
-	p += sprintf(p, "CPU_CLK:\t%lu\n", mxc_get_clocks(CPU_CLK));
-	p += sprintf(p, "AHB_CLK:\t%lu\n", mxc_get_clocks(AHB_CLK));
-	p += sprintf(p, "IPG_CLK:\t%lu\n", mxc_get_clocks(IPG_CLK));
-	p += sprintf(p, "NFC_CLK:\t%lu\n", mxc_get_clocks(NFC_CLK));
-	p += sprintf(p, "USB_CLK:\t%lu\n", mxc_get_clocks(USB_CLK));
-	p += sprintf(p, "UART1_BAUD:\t%lu\n", mxc_get_clocks(UART1_BAUD));
-	p += sprintf(p, "UART2_BAUD:\t%lu\n", mxc_get_clocks(UART2_BAUD));
-	p += sprintf(p, "UART3_BAUD:\t%lu\n", mxc_get_clocks(UART3_BAUD));
-	p += sprintf(p, "I2C_CLK:\t%lu\n", mxc_get_clocks(I2C_CLK));
-	p += sprintf(p, "IPU_CLK:\t%lu\n", mxc_get_clocks(IPU_CLK));
-	p += sprintf(p, "SDMA_CLK:\t%lu\n", mxc_get_clocks(SDMA_CLK));
-	p += sprintf(p, "SDHC1_CLK:\t%lu\n", mxc_get_clocks(SDHC1_CLK));
-	p += sprintf(p, "SDHC2_CLK:\t%lu\n", mxc_get_clocks(SDHC2_CLK));
-
-	len = (p - page) - off;
-	if (len < 0)
-		len = 0;
-
-	*eof = (len <= count) ? 1 : 0;
-	*start = page + off;
-
-	return len;
-}
-
-static int __init mxc_setup_proc_entry(void)
-{
-#ifdef CONFIG_PROC_FS
-	struct proc_dir_entry *res;
-
-	res = create_proc_read_entry("cpu/clocks", 0, NULL,
-				     mxc_clock_read_proc, NULL);
-	if (!res) {
-		printk(KERN_ERR "Failed to create proc/cpu/clocks\n");
-		return -ENOMEM;
-	}
-#endif
-	return 0;
-}
-
-late_initcall(mxc_setup_proc_entry);
diff --git a/arch/arm/mach-mx33/crm_regs.h b/arch/arm/mach-mx33/crm_regs.h
deleted file mode 100644
index 8e2ef2a..0000000
--- a/arch/arm/mach-mx33/crm_regs.h
+++ /dev/null
@@ -1,606 +0,0 @@
-/*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-#ifndef __ARCH_ARM_MACH_MX33_CRM_REGS_H__
-#define __ARCH_ARM_MACH_MX33_CRM_REGS_H__
-
-#define CKIH_CLK_FREQ           26000000
-
-#define MXC_CCM_BASE	IO_ADDRESS(CCM_BASE_ADDR)
-#define MXC_DPLL1_BASE 	IO_ADDRESS(DPLLIP1_BASE_ADDR)
-#define MXC_DPLL2_BASE 	IO_ADDRESS(DPLLIP2_BASE_ADDR)
-#define MXC_DPLL3_BASE 	IO_ADDRESS(DPLLIP3_BASE_ADDR)
-
-/* Register addresses of DPLL */
-#define MXC_DPLL_DP_CTL		(0x0000)
-#define MXC_DPLL_DP_CONFIG 	(0x0004)
-#define MXC_DPLL_DP_OP		(0x0008)
-#define MXC_DPLL_DP_MFD		(0x000C)
-#define MXC_DPLL_DP_MFN		(0x0010)
-#define MXC_DPLL_DP_MFNMINUS	(0x0014)
-#define MXC_DPLL_DP_MFNPLUS	(0x0018)
-#define MXC_DPLL_DP_HFS_OP	(0x001C)
-#define MXC_DPLL_DP_HFS_MFD	(0x0020)
-#define MXC_DPLL_DP_HFS_MFN	(0x0024)
-#define MXC_DPLL_DP_MFN_TOGC	(0x0028)
-#define MXC_DPLL_DP_DESTAT	(0x002C)
-
-/* bits of DPLL registers */
-
-#define MXC_DPLL_DP_CTL_HFSM	(1<<7)
-#define MXC_DPLL_DP_CTL_UPEN	(1<<6)
-#define MXC_DPLL_DP_CTL_LRF	(1<<0)
-
-#define MXC_DPLL_DP_CONFIG_AREN  (2)
-#define MXC_DPLL_DP_CONFIG_LDREQ (1)
-
-#define MXC_DPLL_PDF_OFFSET	(0)
-#define MXC_DPLL_PDF_MASK	(0x0000000F<<MXC_DPLL_PDF_OFFSET)
-#define MXC_DPLL_MFI_OFFSET	(4)
-#define MXC_DPLL_MFI_MASK	(0x0000000F<<MXC_DPLL_MFI_OFFSET)
-#define MXC_DPLL_MFD_OFFSET	(0)
-#define MXC_DPLL_MFD_MASK	(0x07FFFFFF<<MXC_DPLL_MFD_OFFSET)
-
-/* Register addresses of CCM*/
-#define MXC_CCM_CCR (MXC_CCM_BASE + 0x00)
-#define MXC_CCM_CCDR (MXC_CCM_BASE + 0x04)
-#define MXC_CCM_CSR (MXC_CCM_BASE + 0x08)
-#define MXC_CCM_CCSR (MXC_CCM_BASE + 0x0C)
-#define MXC_CCM_CACRR (MXC_CCM_BASE + 0x10)
-#define MXC_CCM_CBCDR1 (MXC_CCM_BASE + 0x14)
-#define MXC_CCM_CBCDR2 (MXC_CCM_BASE + 0x18)
-#define MXC_CCM_CBCDR3 (MXC_CCM_BASE + 0x1C)
-#define MXC_CCM_CBCDR4 (MXC_CCM_BASE + 0x20)
-#define MXC_CCM_CBCDR5 (MXC_CCM_BASE + 0x24)
-#define MXC_CCM_CBCDR6 (MXC_CCM_BASE + 0x28)
-#define MXC_CCM_CBCDR7 (MXC_CCM_BASE + 0x2C)
-#define MXC_CCM_CAMR (MXC_CCM_BASE + 0x30)
-#define MXC_CCM_CSCMR1 (MXC_CCM_BASE + 0x34)
-#define MXC_CCM_CSCMR2 (MXC_CCM_BASE + 0x38)
-#define MXC_CCM_CSCDR1 (MXC_CCM_BASE + 0x3C)
-#define MXC_CCM_CS1CDR (MXC_CCM_BASE + 0x40)
-#define MXC_CCM_CS2CDR (MXC_CCM_BASE + 0x44)
-#define MXC_CCM_CSECDR1 (MXC_CCM_BASE + 0x48)
-#define MXC_CCM_CSECDR2 (MXC_CCM_BASE + 0x4C)
-#define MXC_CCM_CECDR (MXC_CCM_BASE + 0x50)
-#define MXC_CCM_CDCDR (MXC_CCM_BASE + 0x54)
-#define MXC_CCM_CH1CDR (MXC_CCM_BASE + 0x58)
-#define MXC_CCM_CH2CDR (MXC_CCM_BASE + 0x5C)
-#define MXC_CCM_CSCDR2 (MXC_CCM_BASE + 0x60)
-#define MXC_CCM_CR2 (MXC_CCM_BASE + 0x64)
-#define MXC_CCM_CDHIPR (MXC_CCM_BASE + 0x68)
-#define MXC_CCM_CDCR (MXC_CCM_BASE + 0x6C)
-#define MXC_CCM_CTOR (MXC_CCM_BASE + 0x70)
-#define MXC_CCM_CLPCR (MXC_CCM_BASE + 0x74)
-#define MXC_CCM_CISR (MXC_CCM_BASE + 0x78)
-#define MXC_CCM_CIMR (MXC_CCM_BASE + 0x7C)
-#define MXC_CCM_CCOSR (MXC_CCM_BASE + 0x80)
-#define MXC_CCM_CGPR (MXC_CCM_BASE + 0x84)
-#define MXC_CCM_CCGR0 (MXC_CCM_BASE + 0x88)
-#define MXC_CCM_CCGR1 (MXC_CCM_BASE + 0x8C)
-#define MXC_CCM_CCGR2 (MXC_CCM_BASE + 0x90)
-#define MXC_CCM_CCGR3 (MXC_CCM_BASE + 0x94)
-#define MXC_CCM_CCGR4 (MXC_CCM_BASE + 0x98)
-#define MXC_CCM_CCGR5 (MXC_CCM_BASE + 0x9C)
-#define MXC_CCM_CMEOR (MXC_CCM_BASE + 0xA0)
-
-/* Register bit definitions */
-#define MXC_CCM_MASK(bits, offset) \
-		(((1<<(bits)) -1) << (offset) )
-#define MXC_CCM_GET_FIELD(reg, bits, offset) \
-		(((reg) >> (offset))&((1<<(bits))-1))
-#define MXC_CCM_SET_FIELD(val, bits, offset) \
-		(((val)&((1<<(bits))-1)) << (offset) )
-
-/* Define the bits in register CCR */
-#define MXC_CCM_CCR_FPM_512MULT		(0 << 10)
-#define MXC_CCM_CCR_FPM_1024MULT	(1 << 10)
-#define MXC_CCM_CCR_CAMP_EN		(1 << 9)
-#define MXC_CCM_CCR_FPM_EN		(1 << 8)
-#define MXC_CCM_CCR_OSCNT_OFFSET	(0)
-#define MXC_CCM_CCR_OSCNT_BITS		(8)
-
-/* Define the bits in register CCDR */
-#define MXC_CCM_CCDR_HSC_HS_MASK	(1 << 18)
-#define MXC_CCM_CCDR_IPU_HS_MASK	(1 << 17)
-#define MXC_CCM_CCDR_EMI_HS_MASK	(1 << 16)
-#define MXC_CCM_CCDR_LOAD_DIVIDERS	(1 << 0)
-
-/* Define the bits in register CCSR */
-#define MXC_CCM_CCSR_STEP_SEL_OFFSET	(7)
-#define MXC_CCM_CCSR_STEP_SEL_BITS	(2)
-#define MXC_CCM_CCSR_PLL2_PODF_OFFSET (5)
-#define MXC_CCM_CCSR_PLL2_PODF_BITS	(2)
-#define MXC_CCM_CCSR_PLL3_PODF_OFFSET (3)
-#define MXC_CCM_CCSR_PLL3_PODF_BITS	(2)
-#define MXC_CCM_CCSR_PLL1_BYPASS (1 << 2)
-#define MXC_CCM_CCSR_PLL2_BYPASS (1 << 1)
-#define MXC_CCM_CCSR_PLL3_BYAPSS (1 << 0)
-
-/* Define the bits in register CACRR */
-#define MXC_CCM_CACRR_ARM_PODF_OFFSET (0)
-#define MXC_CCM_CACRR_ARM_PODF_BITS (3)
-
-/* Define the bits in register CBCDR1 */
-#define MXC_CCM_CBCDR1_VPU_CORE_PODF_OFFSET (3)
-#define MXC_CCM_CBCDR1_VPU_CORE_PODF_BITS (3)
-#define MXC_CCM_CBCDR1_APU_CORE_PODF_OFFSET (0)
-#define MXC_CCM_CBCDR1_APU_CORE_PODF_BITS (3)
-
-/* Define the bits in register CBCDR2 */
-#define MXC_CCM_CBCDR2_AHB_CORE_PODF_OFFSET (10)
-#define MXC_CCM_CBCDR2_AHB_CORE_PODF_BITS (3)
-#define MXC_CCM_CBCDR2_IPG_CORE_PODF_OFFSET (8)
-#define MXC_CCM_CBCDR2_IPG_CORE_PODF_BITS (2)
-#define MXC_CCM_CBCDR2_PERCLK_PRED1_OFFSET (6)
-#define MXC_CCM_CBCDR2_PERCLK_PRED1_BITS (2)
-#define MXC_CCM_CBCDR2_PERCLK_PRED2_OFFSET (3)
-#define MXC_CCM_CBCDR2_PERCLK_PRED2_BITS (3)
-#define MXC_CCM_CBCDR2_PERCLK_PODF_OFFSET (0)
-#define MXC_CCM_CBCDR2_PERCLK_PODF_BITS (3)
-
-/* Define the bits in register CBCDR3 */
-#define MXC_CCM_CBCDR3_AXI_A_PODF_OFFSET (0)
-#define MXC_CCM_CBCDR3_AXI_A_PODF_BITS (3)
-
-/* Define the bits in register CBCDR4 */
-#define MXC_CCM_CBCDR4_AXI_B_PODF_OFFSET (0)
-#define MXC_CCM_CBCDR4_AXI_B_PODF_BITS (3)
-
-/* Define the bits in register CBCDR5 */
-#define MXC_CCM_CBCDR5_AXI_C_PODF_OFFSET (0)
-#define MXC_CCM_CBCDR5_AXI_C_PODF_BITS (3)
-
-/* Define the bits in register CBCDR6 */
-#define MXC_CCM_CBCDR6_EMI_PODF_OFFSET (0)
-#define MXC_CCM_CBCDR6_EMI_PODF_BITS (3)
-
-/* Define the bits in register CBCDR7 */
-#define MXC_CCM_CBCDR7_IPG_INT_MEM_PODF_OFFSET (3)
-#define MXC_CCM_CBCDR7_IPG_INIT_MEM_PODF_BITS (2)
-#define MXC_CCM_CBCDR7_NFC_PODF_OFFSET (0)
-#define MXC_CCM_CBCDR7_NFC_PODF_BITS (3)
-
-/* Define the bits in register CAMR */
-#define MXC_CCM_CAMR_PERIPH_CLK_SEL_OFFSET (12)
-#define MXC_CCM_CAMR_SEL_BITS (2)
-#define MXC_CCM_CAMR_DDR_CLK_SEL_OFFSET (10)
-#define MXC_CCM_CAMR_ARM_AXI_CLK_SEL_OFFSET (8)
-#define MXC_CCM_CAMR_GPU_AXI_SEL_OFFSET (6)
-#define MXC_CCM_CAMR_VPU_CLK_SEL_OFFSET (4)
-#define MXC_CCM_CAMR_IPU_CLK_SEL_OFFSET (2)
-#define MXC_CCM_CAMR_APU_CLK_SEL_OFFSET (0)
-
-/* Define the bits in register CSCMR1 */
-#define MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_OFFSET (30)
-#define MXC_CCM_CSCMR1_SEL_BITS (2)
-#define MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_OFFSET (28)
-#define MXC_CCM_CSCMR1_DI_CLK_SEL_OFFSET (26)
-#define MXC_CCM_CSCMR1_SIM_CLK_SEL_OFFSET (24)
-#define MXC_CCM_CSCMR1_USBOH2_CLK_SEL_OFFSET (22)
-#define MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_OFFSET (20)
-#define MXC_CCM_CSCMR1_ESDHC3_CLK_SEL_OFFSET (19)
-#define MXC_CCM_CSCMR1_PERCLK_IPG_CLK_SEL_OFFSET (18)
-#define MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_OFFSET (16)
-#define MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET (14)
-#define MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET (12)
-#define MXC_CCM_CSCMR1_HSC1_CLK_SEL_OFFSET (10)
-#define MXC_CCM_CSCMR1_HSC2_CLK_SEL_OFFSET (8)
-#define MXC_CCM_CSCMR1_ESC_CLK_SEL_OFFSET (6)
-#define MXC_CCM_CSCMR1_CSPI_CLK_SEL_OFFSET (4)
-#define MXC_CCM_CSCMR1_CSI_MCLK1_CLK_SEL_OFFSET (2)
-#define MXC_CCM_CSCMR1_CSI_MCLK2_CLK_SEL_OFFSET (0)
-
-/* Define the bits in register CSCDR1 */
-#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_OFFSET (22)
-#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_BITS (3)
-#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET (19)
-#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_BITS (3)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_OFFSET (16)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_BITS (3)
-#define MXC_CCM_CSCDR1_PGC_CLK_PODF_OFFSET (14)
-#define MXC_CCM_CSCDR1_PGC_CLK_PODF_BITS (2)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_OFFSET (11)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_BITS (3)
-#define MXC_CCM_CSCDR1_USBOH2_CLK_PRED_OFFSET (8)
-#define MXC_CCM_CSCDR1_USBOH2_CLK_PRED_BITS (3)
-#define MXC_CCM_CSCDR1_USBOH2_CLK_PODF_OFFSET (5)
-#define MXC_CCM_CSCDR1_USBOH2_CLK_PODF_BITS (2)
-#define MXC_CCM_CSCDR1_SIM_CLK_PRED_OFFSET (2)
-#define MXC_CCM_CSCDR1_SIM_CLK_PRED_BITS (3)
-#define MXC_CCM_CSCDR1_SIM_CLK_PODF_OFFSET (0)
-#define MXC_CCM_CSCDR1_SIM_CLK_PODF_BITS (2)
-
-/* Define the bits in register CS1CDR and CS2CDR */
-#define MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET (6)
-#define MXC_CCM_CS1CDR_SSI1_CLK_PRED_BITS (3)
-#define MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET (0)
-#define MXC_CCM_CS1CDR_SSI1_CLK_PODF_BITS (6)
-#define MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET (6)
-#define MXC_CCM_CS2CDR_SSI2_CLK_PRED_BITS (3)
-#define MXC_CCM_CS2CDR_SSI2_CLK_PODF_OFFSET (0)
-#define MXC_CCM_CS2CDR_SSI2_CLK_PODF_BITS (6)
-
-/* Define the bits in register SCECDR1 and SCECDR2 */
-#define MXC_CCM_SCECDR1_SSI_EXT1_CLK_PRED_OFFSET (6)
-#define MXC_CCM_SCECDR1_SSI_EXT1_CLK_PRED_BITS (3)
-#define MXC_CCM_SCECDR1_SSI_EXT1_CLK_PODF_OFFSET (0)
-#define MXC_CCM_SCECDR1_SSI_EXT1_CLK_PODF_BITS (6)
-#define MXC_CCM_SCECDR2_SSI_EXT2_CLK_PRED_OFFSET (6)
-#define MXC_CCM_SCECDR2_SSI_EXT2_CLK_PRED_BITS (3)
-#define MXC_CCM_SCECDR2_SSI_EXT2_CLK_PODF_OFFSET (0)
-#define MXC_CCM_SCECDR2_SSI_EXT2_CLK_PODF_BITS (6)
-
-/* Define the bits in register CECDR */
-#define MXC_CCM_CECDR_ESC_CLK_PRED_OFFSET (6)
-#define MXC_CCM_CECDR_ESC_CLK_PRED_BITS (3)
-#define MXC_CCM_CECDR_ESC_CLK_PODF_OFFSET (0)
-#define MXC_CCM_CECDR_ESC_CLK_PODF_BITS (6)
-
-/* Define the bits in register CDCDR */
-#define MXC_CCM_CDCDR_DI_CLK_PRED_OFFSET (6)
-#define MXC_CCM_CDCDR_DI_CLK_PRED_BITS (3)
-#define MXC_CCM_CDCDR_DI_CLK_PODF_OFFSET (0)
-#define MXC_CCM_CDCDR_DI_CLK_PODF_BITS (6)
-
-/* Define the bits in register CH1CDR and CH2CDR */
-#define MXC_CCM_CH1CDR_HSC1_CLK_PODF_OFFSET (0)
-#define MXC_CCM_CH1CDR_HSC1_CLK_PODF_BITS (3)
-#define MXC_CCM_CH2CDR_HSC2_CLK_PODF_OFFSET (0)
-#define MXC_CCM_CH2CDR_HSC2_CLK_PODF_BITS (3)
-
-/* Define the bits in register CSCDR2 */
-#define MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET (25)
-#define MXC_CCM_CSCDR2_CSPI_CLK_PRED_BITS (3)
-#define MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET (19)
-#define MXC_CCM_CSCDR2_CSPI_CLK_PODF_BITS (6)
-#define MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PRED_OFFSET (16)
-#define MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PRED_BITS (3)
-#define MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PODF_OFFSET (9)
-#define MXC_CCM_CSCDR2_CSI_MCLK1_CLK_PODF_BITS (6)
-#define MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PRED_OFFSET (6)
-#define MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PRED_BITS (3)
-#define MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PODF_OFFSET (0)
-#define MXC_CCM_CSCDR2_CSI_MCLK2_CLK_PODF_BITS (6)
-
-/* Define the bits in register CDHIPR */
-#define MXC_CCM_CDHIPR_ARM_PODF_BUSY (1<<16)
-#define MXC_CCM_CDHIPR_HSC2_CLK_PODF_BUSY (1<<9)
-#define MXC_CCM_CDHIPR_HSC1_CLK_PODF_BUSY (1<<8)
-#define MXC_CCM_CDHIPR_ESC_CLK_DIVIDER_BUSY (1<<6)
-#define MXC_CCM_CDHIPR_NFC_IPG_INT_MEM_PODF_BUSY (1<<4)
-#define MXC_CCM_CDHIPR_EMI_PODF_BUSY (1<<3)
-#define MXC_CCM_CDHIPR_AXI_C_PODF_BUSY (1<<2)
-#define MXC_CCM_CDHIPR_AXI_B_PODF_BUSY (1<<1)
-#define MXC_CCM_CDHIPR_AXI_A_PODF_BUSY (1<<0)
-
-/* Define the bits in register CDCR */
-#define MXC_CCM_CDCR_HSC2_DVFS_EN_OFFSET (8)
-#define MXC_CCM_CDCR_HSC2_DVFS_EN_BITS (1)
-#define MXC_CCM_CDCR_HSC1_DVFS_EN_OFFSET (7)
-#define MXC_CCM_CDCR_HSC1_DVFS_EN_BITS (1)
-#define MXC_CCM_CDCR_ARM_FREQ_SHIFT_DIVIDER_OFFSET (2)
-#define MXC_CCM_CDCR_ARM_FREQ_SHIFT_DIVIDER_BITS (1)
-#define MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_OFFSET (0)
-#define MXC_CCM_CDCR_ PERIPH_CLK_DVFS_PODF_BITS (2)
-
-/* Define the bits in register CLPCR */
-#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS_OFFSET (22)
-#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS_BITS (1)
-#define MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_OFFSET (21)
-#define MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_BITS (1)
-#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_OFFSET (20)
-#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_BITS (1)
-#define MXC_CCM_CLPCR_BYPASS_EMI_LPM_HS_OFFSET (19)
-#define MXC_CCM_CLPCR_BYPASS_EMI_LPM_HS_BITS (1)
-#define MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS_OFFSET (18)
-#define MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS_BITS (1)
-#define MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS_OFFSET (17)
-#define MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS_BITS (1)
-#define MXC_CCM_CLPCR_BYPASS_SAHARA_LPM_HS_OFFSET (16)
-#define MXC_CCM_CLPCR_BYPASS_SAHARA_LPM_HS_BITS (1)
-#define MXC_CCM_CLPCR_STBY_COUNT_OFFSET (9)
-#define MXC_CCM_CLPCR_STBY_COUNT _BITS (2)
-#define MXC_CCM_CLPCR_STBY_OFFSET (8)
-#define MXC_CCM_CLPCR_VSTBY_BITS (1)
-#define MXC_CCM_CLPCR_DIS_REF_OSC_OFFSET (7)
-#define MXC_CCM_CLPCR_DIS_REF_OSC_BITS (1)
-#define MXC_CCM_CLPCR_SBYOS_OFFSET (6)
-#define MXC_CCM_CLPCR_SBYOS_BITS (1)
-#define MXC_CCM_CLPCR_ARM_CLK_DIS_ON_LPM_OFFSET (5)
-#define MXC_CCM_CLPCR_ARM_CLK_DIS_ON_LPM_BITS (1)
-#define MXC_CCM_CLPCR_LPSR_CLK_SEL_OFFSET (3)
-#define MXC_CCM_CLPCR_LPSR_CLK_SEL_BITS (2)
-#define MXC_CCM_CLPCR_LPM_OFFSET (0)
-#define MXC_CCM_CLPCR_LPM_BITS (2)
-
-/* Define the bits in register ISR */
-#define MXC_CCM_ISR_ARM_PODF_LOADED (25)
-#define MXC_CCM_ISR_HSC2_CLK_PODF_LOADED (24)
-#define MXC_CCM_ISR_HSC1_CLK_PODF_LOADED (23)
-#define MXC_CCM_ISR_ESC_CLK_DIVIDER_LOADED (22)
-#define MXC_CCM_ISR_NFC_IPG_INT_MEM_PODF_LOADED (21)
-#define MXC_CCM_ISR_EMI_PODF_LOADED (20)
-#define MXC_CCM_ISR_AXI_C_PODF_LOADED (19)
-#define MXC_CCM_ISR_AXI_B_PODF_LOADED (18)
-#define MXC_CCM_ISR_AXI_A_PODF_LOADED (17)
-#define MXC_CCM_ISR_DIVIDER_LOADED (16)
-#define MXC_CCM_ISR_CHIH_READY (4)
-#define MXC_CCM_ISR_FPM_READY (3)
-#define MXC_CCM_ISR_LRF_PLL3 (2)
-#define MXC_CCM_ISR_LRF_PLL2 (1)
-#define MXC_CCM_ISR_LRF_PLL1 (0)
-
-/* Define the bits in register CCOSR */
-#define MXC_CCM_CCOSR_CKO2_EN_OFFSET  (24)
-#define MXC_CCM_CCOSR_CKO2_EN_BITS  (1)
-#define MXC_CCM_CCOSR_CKO2_DIV_OFFSET  (21)
-#define MXC_CCM_CCOSR_CKO2_DIV_BITS  (3)
-#define MXC_CCM_CCOSR_CKO2_SEL_OFFSET  (16)
-#define MXC_CCM_CCOSR_CKO2_SEL_BITS  (5)
-#define MXC_CCM_CCOSR_CKO1_EN_OFFSET  (7)
-#define MXC_CCM_CCOSR_CKO1_EN_BITS  (1)
-#define MXC_CCM_CCOSR_CKO1_DIV_OFFSET  (4)
-#define MXC_CCM_CCOSR_CKO1_DIV_BITS  (3)
-#define MXC_CCM_CCOSR_CKO1_SEL_OFFSET  (0)
-#define MXC_CCM_CCOSR_CKO1_SEL_BITS  (4)
-
-/* Define the bits in registers CGPR */
-#define MXC_CCM_CGPR_FPM_SEL_OFFSET (3)
-#define MXC_CCM_CGPR_FPM_SEL_BITS (1)
-#define MXC_CCM_CGPR_VL_L2BIST_CLKDIV_OFFSET (0)
-#define MXC_CCM_CGPR_ VL_L2BIST_CLKDIV _BITS (3)
-
-/* Define the bits in registers CCGRx */
-
-/* The definitions for gate parameter*/
-#define MXC_CCM_CCGR_CLK_OFF	(0)
-#define MXC_CCM_CCGR_CLK_ON_IN_RUN	(1)
-#define MXC_CCM_CCGR_CLK_ON_ALWAYS	(3)
-
-#define MXC_CCM_CCGR_OFF(val, index)   \
-		((val) & (~((MXC_CCM_CCGR_CLK_OFF)<<((index)<<1))))
-#define MXC_CCM_CCGR_ON(val, index, en) \
-		(MXC_CCM_CCGR_OFF(val, index) |((en)<<((index)<<1)) )
-
-/* The clock index in register CCGR1 */
-#define MXC_CCM_CCGR_XSPLIT_CLK_GATE (0)
-#define MXC_CCM_CCGR_ARM_AXI_CLK_GATE (1)
-#define MXC_CCM_CCGR_DAP_CLK_GATE (2)
-#define MXC_CCM_CCGR_CTM_CLK_GATE (3)
-#define MXC_CCM_CCGR_CTI1_CLK_GATE (4)
-#define MXC_CCM_CCGR_CTI2_CLK_GATE (5)
-#define MXC_CCM_CCGR_CTI3_CLK_GATE (6)
-#define MXC_CCM_CCGR_AHB_MUX2_CLK_GATE (7)
-#define MXC_CCM_CCGR_ROMCP_CLK_GATE (8)
-#define MXC_CCM_CCGR_ROM32K_CLK_GATE (9)
-#define MXC_CCM_CCGR_AHB_MAX_CLK_GATE (12)
-#define MXC_CCM_CCGR_AIPS_TZ1_CLK_GATE (13)
-#define MXC_CCM_CCGR_AIPS_TZ2_CLK_GATE (14)
-#define MXC_CCM_CCGR_IIM_CLK_GATE (15)
-
-/* the configuration to enable separate clock in register CCGR0*/
-#define MXC_CCM_CCGR_XSPLIT_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS	)
-#define MXC_CCM_CCGR_ARM_AXI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_DAP_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_CTM_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_CTI1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_CTI2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_CTI3_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_AHB_MUX2_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_ROMCP_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_ROM32K_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_AHB_MAX_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_AIPS_TZ1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_AIPS_TZ2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_IIM_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-
-/* The clock index in register CCGR1 */
-#define MXC_CCM_CCGR_TMAX1_CLK_GATE (0)
-#define MXC_CCM_CCGR_TMAX2_CLK_GATE (1)
-#define MXC_CCM_CCGR_TMAX3_CLK_GATE (2)
-#define MXC_CCM_CCGR_TMAX4_CLK_GATE (3)
-#define MXC_CCM_CCGR_UART1_IPG_CLK_GATE (4)
-#define MXC_CCM_CCGR_UART1_PERCLK_GATE (5)
-#define MXC_CCM_CCGR_UART2_IPG_CLK_GATE (6)
-#define MXC_CCM_CCGR_UART2_PERCLK_GATE (7)
-#define MXC_CCM_CCGR_UART3_IPG_CLK_GATE (8)
-#define MXC_CCM_CCGR_UART3_PERCLK_GATE (9)
-#define MXC_CCM_CCGR_UART4_IPG_CLK_GATE (10)
-#define MXC_CCM_CCGR_UART4_PERCLK_GATE (11)
-#define MXC_CCM_CCGR_UART5_IPG_CLK_GATE (12)
-#define MXC_CCM_CCGR_UART5_PERCLK_GATE (13)
-#define MXC_CCM_CCGR_I2C1_CLK_GATE (14)
-#define MXC_CCM_CCGR_I2C2_CLK_GATE (15)
-
-/* The configuration to enable separate clock in register CCGR1 */
-#define MXC_CCM_CCGR_TMAX1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_TMAX2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_TMAX3_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_TMAX4_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_UART1_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_UART1_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_UART2_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_UART2_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_UART3_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_UART3_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_UART4_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_UART4_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_UART5_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_UART5_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_I2C1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_I2C2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-
-/* The clock index in register CCGR2 */
-#define MXC_CCM_CCGR_I2C3_CLK_GATE (0)
-#define MXC_CCM_CCGR_EPIT1_IPG_CLK_GATE (1)
-#define MXC_CCM_CCGR_EPIT1_HIGHFREQ_CLK_GATE (2)
-#define MXC_CCM_CCGR_EPIT2_IPG_CLK_GATE (3)
-#define MXC_CCM_CCGR_EPIT2_HIGHFREQ_CLK_GATE (4)
-#define MXC_CCM_CCGR_PWM_IPG_CLK_GATE (5)
-#define MXC_CCM_CCGR_PWM_HIGHFREQ_CLK_GATE (6)
-#define MXC_CCM_CCGR_GPT_IPG_CLK_GATE (7)
-#define MXC_CCM_CCGR_GPT_HIGHFREQ_CLK_GATE (8)
-#define MXC_CCM_CCGR_OWIRE_CLK_GATE (9)
-#define MXC_CCM_CCGR_FEC_CLK_GATE (10)
-#define MXC_CCM_CCGR_USBOH2_IPG_HCLK_GATE (11)
-#define MXC_CCM_CCGR_USBOH2_60M_CLK_GATE (12)
-#define MXC_CCM_CCGR_ESDHC1_IPG_HCLK_GATE (13)
-#define MXC_CCM_CCGR_ESDHC1_PERCLK_GATE (14)
-#define MXC_CCM_CCGR_ESDHC2_IPG_HCLK_GATE (15)
-
-/* The configuration to enable separate clock in register CCGR2 */
-#define MXC_CCM_CCGR_I2C3_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_EPIT1_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_EPIT1_HIGHFREQ_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_EPIT2_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_EPIT2_HIGHFREQ_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_PWM_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_PWM_HIGHFREQ_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_GPT_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_GPT_HIGHFREQ_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_OWIRE_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_FEC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_USBOH2_IPG_HCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_USBOH2_60M_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_ESDHC1_IPG_HCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_ESDHC1_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_ESDHC2_IPG_HCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-
-/* The clock index in register CCGR3 */
-#define MXC_CCM_CCGR_ESDHC2_PERCLK_GATE (0)
-#define MXC_CCM_CCGR_ESDHC3_IPG_HCLK_GATE (1)
-#define MXC_CCM_CCGR_ESDHC3_PERCLK_GATE (2)
-#define MXC_CCM_CCGR_MSHC1_IPG_HCLK_GATE (3)
-#define MXC_CCM_CCGR_MSHC1_DI_CLK_GATE (4)
-#define MXC_CCM_CCGR_MSHC2_IPG_HCLK_GATE (5)
-#define MXC_CCM_CCGR_MSHC2_DI_CLK_GATE (6)
-#define MXC_CCM_CCGR_SSI1_IPG_CLK_GATE (7)
-#define MXC_CCM_CCGR_SSI1_SSI_CLK_GATE (8)
-#define MXC_CCM_CCGR_SSI2_IPG_CLK_GATE (9)
-#define MXC_CCM_CCGR_SSI2_SSI_CLK_GATE (10)
-#define MXC_CCM_CCGR_SSI_EXT1_CLK_GATE (11)
-#define MXC_CCM_CCGR_SSI_EXT2_CLK_GATE (12)
-#define MXC_CCM_CCGR_MARC_CLK_GATE (13)
-#define MXC_CCM_CCGR_PATA_CLK_GATE (14)
-#define MXC_CCM_CCGR_SIM_CLK_GATE (15)
-
-/* The configuration to enable separate clock in register CCGR3 */
-#define MXC_CCM_CCGR_ESDHC2_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_ESDHC3_IPG_HCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_ESDHC3_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_MSHC1_IPG_HCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_MSHC1_DI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_MSHC2_IPG_HCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_MSHC2_DI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_SSI1_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_SSI1_SSI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_SSI2_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_SSI2_SSI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_SSI_EXT1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_SSI_EXT2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_MARC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_PATA_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_SIM_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-
-/* The clock index in register CCGR4 */
-#define MXC_CCM_CCGR_HSC1_CLK_GATE (0)
-#define MXC_CCM_CCGR_HSC_ESC_CLK_GATE (1)
-#define MXC_CCM_CCGR_HSC2_CLK_GATE (2)
-#define MXC_CCM_CCGR_HSC_HSP_CLK_GATE (3)
-#define MXC_CCM_CCGR_SAHARA_CLK_GATE (4)
-#define MXC_CCM_CCGR_RTIC_CLK_GATE (5)
-#define MXC_CCM_CCGR_SDDC_CLK_GATE (6)
-#define MXC_CCM_CCGR_CSPI1_IPG_CLK_GATE (7)
-#define MXC_CCM_CCGR_CSPI1_PERCLK_GATE (8)
-#define MXC_CCM_CCGR_CSPI2_IPG_CLK_GATE (9)
-#define MXC_CCM_CCGR_CSPI2_PERCLK_GATE (10)
-#define MXC_CCM_CCGR_CSPI3_IPG_CLK_GATE (11)
-#define MXC_CCM_CCGR_CSPI3_PERCLK_GATE (12)
-#define MXC_CCM_CCGR_SRTC_CLK_GATE (13)
-#define MXC_CCM_CCGR_DI_CLK_GATE (14)
-#define MXC_CCM_CCGR_IPU_CLK_GATE (15)
-
-/* The configuration to enable separate clock in register CCGR4 */
-#define MXC_CCM_CCGR_HSC1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_HSC_ESC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_HSC2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_HSC_HSP_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_SAHARA_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_RTIC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_SDDC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_CSPI1_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_CSPI1_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_CSPI2_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_CSPI2_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_CSPI3_IPG_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_CSPI3_PERCLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_SRTC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_DI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_IPU_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-
-/* The clock index in register CCGR5 */
-#define MXC_CCM_CCGR_SDMA_CLK_GATE (0)
-#define MXC_CCM_CCGR_SPBA_CLK_GATE (1)
-#define MXC_CCM_CCGR_CSI_MCLK1_CLK_GATE (2)
-#define MXC_CCM_CCGR_CSI_MCLK2_CLK_GATE (3)
-#define MXC_CCM_CCGR_AHB_MUX1_CLK_GATE (4)
-#define MXC_CCM_CCGR_GPU_CLK_GATE (5)
-#define MXC_CCM_CCGR_VPU_CLK_GATE (6)
-#define MXC_CCM_CCGR_VPU_SERIAL_CLK_GATE (7)
-#define MXC_CCM_CCGR_APU_CLK_GATE (8)
-#define MXC_CCM_CCGR_MU_CLK_GATE (9)
-#define MXC_CCM_CCGR_EMI_CLK_GATE (11)
-#define MXC_CCM_CCGR_EMI_FAST_CLK_GATE (12)
-#define MXC_CCM_CCGR_EMI_SLOW_CLK_GATE (13)
-#define MXC_CCM_CCGR_EMI_INTR_CLK_GATE (14)
-#define MXC_CCM_CCGR_GPC_CLK_GATE (15)
-
-/* The configuration to enable separate clock in register CCGR5 */
-#define MXC_CCM_CCGR_SDMA_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_SPBA_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_CSI_MCLK1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_CSI_MCLK2_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_AHB_MUX1_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_GPU_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_VPU_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_VPU_SERIAL_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_APU_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_MU_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_EMI_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_EMI_FAST_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_EMI_SLOW_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_EMI_INTR_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-#define MXC_CCM_CCGR_GPC_CLK_EN (MXC_CCM_CCGR_CLK_ON_ALWAYS)
-
-/* Define the bit in register CMEOR */
-#define MXC_CCM_CMEOR_EN_OV_HSC_ESC (1<<18)
-#define MXC_CCM_CMEOR_EN_OV_HSC_SEC (1<<17)
-#define MXC_CCM_CMEOR_EN_OV_HSC_PRIM (1<<16)
-#define MXC_CCM_CMEOR_EN_OV_EMI_INTR (1<<15)
-#define MXC_CCM_CMEOR_EN_OV_EMI_SLOW (1<<14)
-#define MXC_CCM_CMEOR_EN_OV_EMI_FAST (1<<13)
-#define MXC_CCM_CMEOR_EN_OV_GPC (1<<12)
-#define MXC_CCM_CMEOR_EN_OV_MBX3D (1<<11)
-#define MXC_CCM_CMEOR_EN_OV_MBX (1<<10)
-#define MXC_CCM_CMEOR_EN_OV_VPU (1<<9)
-#define MXC_CCM_CMEOR_EN_OV_DAP (1<<8)
-#define MXC_CCM_CMEOR_EN_OV_APU (1<<7)
-#define MXC_CCM_CMEOR_EN_OV_EPIT (1<<6)
-#define MXC_CCM_CMEOR_EN_OV_GPT (1<<5)
-#define MXC_CCM_CMEOR_EN_OV_ESDHC (1<<4)
-#define MXC_CCM_CMEOR_EN_OV_IIM (1<<3)
-#define MXC_CCM_CMEOR_EN_OV_OWIRE (1<<2)
-#define MXC_CCM_CMEOR_EN_OV_SDDC (1<<1)
-#define MXC_CCM_CMEOR_EN_OV_SAHARA (1<<0)
-
-#endif				/* __ARCH_ARM_MACH_MX33_CRM_REGS_H__ */
diff --git a/arch/arm/mach-mx33/devices.c b/arch/arm/mach-mx33/devices.c
deleted file mode 100644
index a6e056d..0000000
--- a/arch/arm/mach-mx33/devices.c
+++ /dev/null
@@ -1,543 +0,0 @@
-/*
- * Author: MontaVista Software, Inc.
- *       <source@mvista.com>
- *
- * Based on the OMAP devices.c
- *
- * 2005 (c) MontaVista Software, Inc. This file is licensed under the
- * terms of the GNU General Public License version 2. This program is
- * licensed "as is" without any warranty of any kind, whether express
- * or implied.
- *
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-
-#include <linux/spi/spi.h>
-
-#include <asm/hardware.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/mmc.h>
-
-#include <asm/arch/spba.h>
-#include "iomux.h"
-#include <asm/arch/sdma.h>
-#include "sdma_script_code.h"
-
-#if 0
-int board_device_enable(u32 device_id);
-int board_device_disable(u32 device_id);
-
-int mxc_device_enable(u32 device_id)
-{
-	int ret = 0;
-
-	switch (device_id) {
-	default:
-		ret = board_device_enable(device_id);
-	}
-
-	return ret;
-}
-
-int mxc_device_disable(u32 device_id)
-{
-	int ret = 0;
-
-	switch (device_id) {
-	default:
-		ret = board_device_disable(device_id);
-	}
-	return ret;
-}
-
-EXPORT_SYMBOL(mxc_device_enable);
-EXPORT_SYMBOL(mxc_device_disable);
-#endif
-
-void mxc_sdma_get_script_info(sdma_script_start_addrs * sdma_script_addr)
-{
-	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
-	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
-	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
-	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
-	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
-	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
-	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
-	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
-	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
-	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code;
-	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR;
-	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
-	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
-	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR;
-	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = dptc_dvfs_ADDR;
-	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
-	sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
-	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
-	sdma_script_addr->mxc_sdma_per_2_app_addr = -1;
-	sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
-	sdma_script_addr->mxc_sdma_per_2_shp_addr = -1;
-	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
-	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
-	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
-	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
-	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = -1;
-	sdma_script_addr->mxc_sdma_shp_2_per_addr = -1;
-	sdma_script_addr->mxc_sdma_uart_2_per_addr = -1;
-	sdma_script_addr->mxc_sdma_app_2_per_addr = -1;
-}
-
-static void mxc_nop_release(struct device *dev)
-{
-	/* Nothing */
-}
-
-#if defined(CONFIG_W1_MXC) || defined(CONFIG_W1_MXC_MODULE)
-static struct platform_device mxc_w1_devices = {
-	.name = "mxc_w1",
-	.dev = {
-		.release = mxc_nop_release,
-		},
-	.id = 0
-};
-
-static void mxc_init_owire(void)
-{
-	platform_device_register(&mxc_w1_devices);
-}
-#else
-static inline void mxc_init_owire(void)
-{
-}
-#endif
-
-#if defined(CONFIG_MXC_RTC)
-
-static struct platform_device mxc_rtc_device = {
-	.name = "mxc_rtc",
-	.id = 0,
-};
-static void mxc_init_rtc(void)
-{
-	(void)platform_device_register(&mxc_rtc_device);
-}
-#else
-static inline void mxc_init_rtc(void)
-{
-}
-#endif
-
-#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
-
-static struct resource wdt_resources[] = {
-	{
-	 .start = WDOG1_BASE_ADDR,
-	 .end = WDOG1_BASE_ADDR + 0x30,
-	 .flags = IORESOURCE_MEM,
-	 },
-};
-
-static struct platform_device mxc_wdt_device = {
-	.name = "mxc_wdt",
-	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		},
-	.num_resources = ARRAY_SIZE(wdt_resources),
-	.resource = wdt_resources,
-};
-
-static void mxc_init_wdt(void)
-{
-	(void)platform_device_register(&mxc_wdt_device);
-}
-#else
-static inline void mxc_init_wdt(void)
-{
-}
-#endif
-
-#if defined(CONFIG_MXC_IPU) || defined(CONFIG_MXC_IPU_MODULE)
-static struct mxc_ipu_config mxc_ipu_data = {
-	.rev = 1,
-};
-
-static struct resource ipu_resources[] = {
-	{
-	 .start = IPU_CTRL_BASE_ADDR,
-	 .end = IPU_CTRL_BASE_ADDR + SZ_4K,
-	 .flags = IORESOURCE_MEM,
-	 },
-	{
-	 .start = INT_IPU_SYN,
-	 .flags = IORESOURCE_IRQ,
-	 },
-	{
-	 .start = INT_IPU_ERR,
-	 .flags = IORESOURCE_IRQ,
-	 },
-};
-
-static struct platform_device mxc_ipu_device = {
-	.name = "mxc_ipu",
-	.id = -1,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxc_ipu_data,
-		},
-	.num_resources = ARRAY_SIZE(ipu_resources),
-	.resource = ipu_resources,
-};
-
-static void mxc_init_ipu(void)
-{
-	platform_device_register(&mxc_ipu_device);
-}
-#else
-static inline void mxc_init_ipu(void)
-{
-}
-#endif
-
-/* MMC device data */
-
-#if defined(CONFIG_MMC_MXC) || defined(CONFIG_MMC_MXC_MODULE)
-
-extern unsigned int sdhc_get_card_det_status(struct device *dev);
-extern int sdhc_init_card_det(int id);
-
-static struct mxc_mmc_platform_data mmc_data = {
-	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30,
-	.min_clk = 150000,
-	.max_clk = 25000000,
-	.card_inserted_state = 1,
-};
-
-/*!
- * Resource definition for the SDHC1
- */
-static struct resource mxcsdhc1_resources[] = {
-	[0] = {
-	       .start = MMC_SDHC1_BASE_ADDR,
-	       .end = MMC_SDHC1_BASE_ADDR + SZ_16K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = INT_MMC_SDHC1,
-	       .end = INT_MMC_SDHC1,
-	       .flags = IORESOURCE_IRQ,
-	       },
-	[2] = {
-	       .start = 0,
-	       .end = 0,
-	       .flags = IORESOURCE_IRQ,
-	       },
-	[3] = {
-	       .start = MXC_SDIO1_CARD_IRQ,
-	       .end = MXC_SDIO1_CARD_IRQ,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*!
- * Resource definition for the SDHC2
- */
-static struct resource mxcsdhc2_resources[] = {
-	[0] = {
-	       .start = MMC_SDHC2_BASE_ADDR,
-	       .end = MMC_SDHC2_BASE_ADDR + SZ_16K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = INT_MMC_SDHC2,
-	       .end = INT_MMC_SDHC2,
-	       .flags = IORESOURCE_IRQ,
-	       },
-	[2] = {
-	       .start = 0,
-	       .end = 0,
-	       .flags = IORESOURCE_IRQ,
-	       },
-	[3] = {
-	       .start = MXC_SDIO2_CARD_IRQ,
-	       .end = MXC_SDIO2_CARD_IRQ,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Device Definition for MXC SDHC1 */
-static struct platform_device mxcsdhc1_device = {
-	.name = "mxc_esdhc",
-	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mmc_data,
-		},
-	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
-	.resource = mxcsdhc1_resources,
-};
-
-/*! Device Definition for MXC SDHC2 */
-static struct platform_device mxcsdhc2_device = {
-	.name = "mxc_esdhc",
-	.id = 1,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mmc_data,
-		},
-	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
-	.resource = mxcsdhc2_resources,
-};
-
-static inline void mxc_init_mmc(void)
-{
-	int cd_irq = 0;
-
-	/*TODO:cd_irq = sdhc_init_card_det(0); */
-	if (cd_irq) {
-		mxcsdhc1_device.resource[2].start = cd_irq;
-		mxcsdhc1_device.resource[2].end = cd_irq;
-	}
-	cd_irq = 0;
-	/* set cd_irq = 0 here to disable sdhc2 */
-	/* TODO:cd_irq = sdhc_init_card_det(1); */
-	if (cd_irq) {
-		mxcsdhc2_device.resource[2].start = cd_irq;
-		mxcsdhc2_device.resource[2].end = cd_irq;
-	}
-
-	spba_take_ownership(SPBA_SDHC1, SPBA_MASTER_A | SPBA_MASTER_C);
-	(void)platform_device_register(&mxcsdhc1_device);
-	spba_take_ownership(SPBA_SDHC2, SPBA_MASTER_A | SPBA_MASTER_C);
-	(void)platform_device_register(&mxcsdhc2_device);
-}
-#else
-static inline void mxc_init_mmc(void)
-{
-}
-#endif
-
-/* SPI controller and device data */
-#if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
-
-#ifdef CONFIG_SPI_MXC_SELECT1
-/*!
- * Resource definition for the CSPI1
- */
-static struct resource mxcspi1_resources[] = {
-	[0] = {
-	       .start = CSPI1_BASE_ADDR,
-	       .end = CSPI1_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = INT_CSPI1,
-	       .end = INT_CSPI1,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Platform Data for MXC CSPI1 */
-static struct mxc_spi_master mxcspi1_data = {
-	.bus_num = 1,
-	.maxchipselect = 4,
-	.spi_version = 4,
-	.clock = CSPI1_CLK,
-};
-
-/*! Device Definition for MXC CSPI1 */
-static struct platform_device mxcspi1_device = {
-	.name = "mxc_spi",
-	.id = 1,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxcspi1_data,
-		},
-	.num_resources = ARRAY_SIZE(mxcspi1_resources),
-	.resource = mxcspi1_resources,
-};
-
-#endif				/* CONFIG_SPI_MXC_SELECT1 */
-
-#ifdef CONFIG_SPI_MXC_SELECT2
-/*!
- * Resource definition for the CSPI2
- */
-static struct resource mxcspi2_resources[] = {
-	[0] = {
-	       .start = CSPI2_BASE_ADDR,
-	       .end = CSPI2_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = INT_CSPI2,
-	       .end = INT_CSPI2,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Platform Data for MXC CSPI2 */
-static struct mxc_spi_master mxcspi2_data = {
-	.bus_num = 2,
-	.maxchipselect = 4,
-	.spi_version = 4,
-	.clock = CSPI2_CLK,
-};
-
-/*! Device Definition for MXC CSPI2 */
-static struct platform_device mxcspi2_device = {
-	.name = "mxc_spi",
-	.id = 2,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxcspi2_data,
-		},
-	.num_resources = ARRAY_SIZE(mxcspi2_resources),
-	.resource = mxcspi2_resources,
-};
-#endif				/* CONFIG_SPI_MXC_SELECT2 */
-
-#ifdef CONFIG_SPI_MXC_SELECT3
-/*!
- * Resource definition for the CSPI3
- */
-static struct resource mxcspi3_resources[] = {
-	[0] = {
-	       .start = CSPI3_BASE_ADDR,
-	       .end = CSPI3_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = INT_CSPI3,
-	       .end = INT_CSPI3,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Platform Data for MXC CSPI3 */
-static struct mxc_spi_master mxcspi3_data = {
-	.bus_num = 3,
-	.maxchipselect = 4,
-	.spi_version = 4,
-	.clock = CSPI3_CLK,
-};
-
-/*! Device Definition for MXC CSPI3 */
-static struct platform_device mxcspi3_device = {
-	.name = "mxc_spi",
-	.id = 3,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxcspi3_data,
-		},
-	.num_resources = ARRAY_SIZE(mxcspi3_resources),
-	.resource = mxcspi3_resources,
-};
-#endif				/* CONFIG_SPI_MXC_SELECT3 */
-
-static inline void mxc_init_spi(void)
-{
-	/* SPBA configuration for CSPI2 - MCU is set */
-	spba_take_ownership(SPBA_CSPI2, SPBA_MASTER_A);
-#ifdef CONFIG_SPI_MXC_SELECT1
-	if (platform_device_register(&mxcspi1_device) < 0)
-		printk("Error: Registering the SPI Controller_1\n");
-#endif				/* CONFIG_SPI_MXC_SELECT1 */
-#ifdef CONFIG_SPI_MXC_SELECT2
-	if (platform_device_register(&mxcspi2_device) < 0)
-		printk("Error: Registering the SPI Controller_2\n");
-#endif				/* CONFIG_SPI_MXC_SELECT2 */
-#ifdef CONFIG_SPI_MXC_SELECT3
-	if (platform_device_register(&mxcspi3_device) < 0)
-		printk("Error: Registering the SPI Controller_3\n");
-#endif				/* CONFIG_SPI_MXC_SELECT3 */
-}
-#else
-static inline void mxc_init_spi(void)
-{
-}
-#endif
-
-struct mxc_gpio_port mxc_gpio_ports[GPIO_PORT_NUM] = {
-	{
-	 .num = 0,
-	 .base = IO_ADDRESS(GPIO1_BASE_ADDR),
-	 .irq_0_15 = INT_GPIO1_LOW,
-	 .irq_16_31 = INT_GPIO1_HIGH,
-	 .virtual_irq_start = MXC_GPIO_BASE,
-	 },
-	{
-	 .num = 1,
-	 .base = IO_ADDRESS(GPIO2_BASE_ADDR),
-	 .irq_0_15 = INT_GPIO2_LOW,
-	 .irq_16_31 = INT_GPIO2_HIGH,
-	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN * 1,
-	 },
-	{
-	 .num = 2,
-	 .base = IO_ADDRESS(GPIO3_BASE_ADDR),
-	 .irq_0_15 = INT_GPIO3_LOW,
-	 .irq_16_31 = INT_GPIO3_HIGH,
-	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN * 2,
-	 },
-	{
-	 .num = 3,
-	 .base = IO_ADDRESS(GPIO4_BASE_ADDR),
-	 .irq_0_15 = INT_GPIO4_LOW,
-	 .irq_16_31 = INT_GPIO4_HIGH,
-	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN * 3,
-	 },
-};
-
-#if	defined(CONFIG_PCMCIA_MX33ADS) || defined(CONFIG_PCMCIA_MX33ADS_MODULE)
-
-static struct platform_device mx33ads_device = {
-	.name = "Mx33ads pcmcia socket",
-	.id = 0,
-	.dev.release = mxc_nop_release,
-};
-static inline void mxc_init_pcmcia(void)
-{
-	platform_device_register(&mx33ads_device);
-}
-#else
-static inline void mxc_init_pcmcia(void)
-{
-}
-#endif
-
-static struct platform_device mxc_dma_device = {
-	.name = "mxc_dma",
-	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		},
-};
-
-static inline void mxc_init_dma(void)
-{
-	(void)platform_device_register(&mxc_dma_device);
-}
-
-static int __init mxc_init_devices(void)
-{
-	mxc_init_wdt();
-	mxc_init_ipu();
-	mxc_init_mmc();
-	mxc_init_spi();
-	mxc_init_rtc();
-	mxc_init_owire();
-	mxc_init_pcmcia();
-	mxc_init_dma();
-
-	/* SPBA configuration for SSI2 - SDMA and MCU are set */
-	spba_take_ownership(SPBA_SSI2, SPBA_MASTER_C | SPBA_MASTER_A);
-	spba_take_ownership(SPBA_FEC, SPBA_MASTER_A);
-	return 0;
-}
-
-arch_initcall(mxc_init_devices);
diff --git a/arch/arm/mach-mx33/dma.c b/arch/arm/mach-mx33/dma.c
deleted file mode 100644
index 51bebe1..0000000
--- a/arch/arm/mach-mx33/dma.c
+++ /dev/null
@@ -1,590 +0,0 @@
-/*
- *  Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-#include <linux/init.h>
-#include <asm/dma.h>
-#include <asm/arch/hardware.h>
-
-#include <linux/device.h>
-#include "serial.h"
-
-#define MXC_MMC_BUFFER_ACCESS     0x38
-#define MXC_SSI_TX0_REG           0x0
-#define MXC_SSI_TX1_REG           0x4
-#define MXC_SSI_RX0_REG           0x8
-#define MXC_SSI_RX1_REG           0xC
-#define MXC_FIRI_TXFIFO           0x14
-#define MXC_SDHC_MMC_WML          16
-#define MXC_SDHC_SD_WML           64
-#define MXC_SSI_TXFIFO_WML        0x4
-#define MXC_SSI_RXFIFO_WML        0x6
-#define MXC_FIRI_WML              16
-
-typedef struct mxc_sdma_info_entry_s {
-	mxc_dma_device_t device;
-	mxc_sdma_channel_params_t *chnl_info;
-} mxc_sdma_info_entry_t;
-
-static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
-	.chnl_params = {
-			.watermark_level = UART1_UFCR_RXTL,
-			.per_address = UART1_BASE_ADDR,
-			.peripheral_type = UART,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_UART1_RX,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_UART1_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_uart1_tx_params = {
-	.chnl_params = {
-			.watermark_level = UART1_UFCR_TXTL,
-			.per_address = UART1_BASE_ADDR + MXC_UARTUTXD,
-			.peripheral_type = UART,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_UART1_TX,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_UART1_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_uart2_rx_params = {
-	.chnl_params = {
-			.watermark_level = UART2_UFCR_RXTL,
-			.per_address = UART2_BASE_ADDR,
-			.peripheral_type = UART,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_UART2_RX,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_UART2_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_uart2_tx_params = {
-	.chnl_params = {
-			.watermark_level = UART2_UFCR_TXTL,
-			.per_address = UART2_BASE_ADDR + MXC_UARTUTXD,
-			.peripheral_type = UART,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_UART2_TX,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_UART2_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
-	.chnl_params = {
-			.watermark_level = UART3_UFCR_RXTL,
-			.per_address = UART3_BASE_ADDR,
-			.peripheral_type = UART_SP,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_UART3_RX,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_UART3_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
-	.chnl_params = {
-			.watermark_level = UART3_UFCR_TXTL,
-			.per_address = UART3_BASE_ADDR + MXC_UARTUTXD,
-			.peripheral_type = UART_SP,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_UART3_TX,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_UART3_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_uart4_rx_params = {
-	.chnl_params = {
-			.watermark_level = UART4_UFCR_RXTL,
-			.per_address = UART4_BASE_ADDR,
-			.peripheral_type = UART,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_UART4_RX,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_UART4_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_uart4_tx_params = {
-	.chnl_params = {
-			.watermark_level = UART4_UFCR_TXTL,
-			.per_address = UART4_BASE_ADDR + MXC_UARTUTXD,
-			.peripheral_type = UART,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_UART4_TX,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_UART4_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_uart5_rx_params = {
-	.chnl_params = {
-			.watermark_level = UART5_UFCR_RXTL,
-			.per_address = UART5_BASE_ADDR,
-			.peripheral_type = UART,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_UART5_RX,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_UART5_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_uart5_tx_params = {
-	.chnl_params = {
-			.watermark_level = UART5_UFCR_TXTL,
-			.per_address = UART5_BASE_ADDR + MXC_UARTUTXD,
-			.peripheral_type = UART,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_UART5_TX,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_UART5_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx0_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_RXFIFO_WML,
-			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
-			.peripheral_type = SSI,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_SSI1_RX1,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx0_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_TXFIFO_WML,
-			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
-			.peripheral_type = SSI,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SSI1_TX1,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx0_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_RXFIFO_WML,
-			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
-			.peripheral_type = SSI,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_SSI1_RX1,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx0_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_TXFIFO_WML,
-			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
-			.peripheral_type = SSI,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SSI1_TX1,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx0_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_RXFIFO_WML,
-			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
-			.peripheral_type = SSI,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_SSI1_RX1,
-			.bd_number = 32,
-			.word_size = TRANSFER_32BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx0_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_TXFIFO_WML,
-			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
-			.peripheral_type = SSI,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SSI1_TX1,
-			.bd_number = 32,
-			.word_size = TRANSFER_32BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx1_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_RXFIFO_WML,
-			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
-			.peripheral_type = SSI,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_SSI1_RX2,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx1_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_TXFIFO_WML,
-			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
-			.peripheral_type = SSI,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SSI1_TX2,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx1_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_RXFIFO_WML,
-			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
-			.peripheral_type = SSI,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_SSI1_RX2,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx1_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_TXFIFO_WML,
-			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
-			.peripheral_type = SSI,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SSI1_TX2,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx1_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_RXFIFO_WML,
-			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
-			.peripheral_type = SSI,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_SSI1_RX2,
-			.bd_number = 32,
-			.word_size = TRANSFER_32BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx1_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_TXFIFO_WML,
-			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
-			.peripheral_type = SSI,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SSI1_TX2,
-			.bd_number = 32,
-			.word_size = TRANSFER_32BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx0_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_RXFIFO_WML,
-			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
-			.peripheral_type = SSI_SP,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_SSI2_RX1,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_TXFIFO_WML,
-			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
-			.peripheral_type = SSI_SP,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SSI2_TX1,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx0_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_RXFIFO_WML,
-			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
-			.peripheral_type = SSI_SP,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_SSI2_RX1,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_TXFIFO_WML,
-			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
-			.peripheral_type = SSI_SP,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SSI2_TX1,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx0_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_RXFIFO_WML,
-			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
-			.peripheral_type = SSI_SP,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_SSI2_RX1,
-			.bd_number = 32,
-			.word_size = TRANSFER_32BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_TXFIFO_WML,
-			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
-			.peripheral_type = SSI_SP,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SSI2_TX1,
-			.bd_number = 32,
-			.word_size = TRANSFER_32BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx1_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_RXFIFO_WML,
-			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
-			.peripheral_type = SSI_SP,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_SSI2_RX2,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_TXFIFO_WML,
-			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
-			.peripheral_type = SSI_SP,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SSI2_TX2,
-			.bd_number = 32,
-			.word_size = TRANSFER_8BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx1_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_RXFIFO_WML,
-			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
-			.peripheral_type = SSI_SP,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_SSI2_RX2,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_TXFIFO_WML,
-			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
-			.peripheral_type = SSI_SP,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SSI2_TX2,
-			.bd_number = 32,
-			.word_size = TRANSFER_16BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx1_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_RXFIFO_WML,
-			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
-			.peripheral_type = SSI_SP,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_SSI2_RX2,
-			.bd_number = 32,
-			.word_size = TRANSFER_32BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
-	.chnl_params = {
-			.watermark_level = MXC_SSI_TXFIFO_WML,
-			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
-			.peripheral_type = SSI_SP,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SSI2_TX2,
-			.bd_number = 32,
-			.word_size = TRANSFER_32BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
-	.chnl_params = {
-			.peripheral_type = MEMORY,
-			.transfer_type = emi_2_emi,
-			.bd_number = 32,
-			.word_size = TRANSFER_32BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_MEMORY,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ata_rx_params = {
-	.chnl_params = {
-			.watermark_level = MXC_IDE_DMA_WATERMARK,
-			.per_address = ATA_DMA_BASE_ADDR,
-			.peripheral_type = ATA,
-			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_ATA_TX_END,
-			.event_id2 = DMA_REQ_ATA_RX,
-			.bd_number = MXC_IDE_DMA_BD_NR,
-			.word_size = TRANSFER_32BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_ATA_RX,
-};
-
-static mxc_sdma_channel_params_t mxc_sdma_ata_tx_params = {
-	.chnl_params = {
-			.watermark_level = MXC_IDE_DMA_WATERMARK,
-			.per_address = ATA_DMA_BASE_ADDR + 0x18,
-			.peripheral_type = ATA,
-			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_ATA_TX_END,
-			.event_id2 = DMA_REQ_ATA_TX,
-			.bd_number = MXC_IDE_DMA_BD_NR,
-			.word_size = TRANSFER_32BIT,
-			},
-	.channel_num = MXC_DMA_CHANNEL_ATA_TX,
-};
-static mxc_sdma_info_entry_t mxc_sdma_active_dma_info[] = {
-	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
-	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
-	{MXC_DMA_UART2_RX, &mxc_sdma_uart2_rx_params},
-	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
-	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
-	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
-	{MXC_DMA_UART4_RX, &mxc_sdma_uart4_rx_params},
-	{MXC_DMA_UART4_TX, &mxc_sdma_uart4_tx_params},
-	{MXC_DMA_UART5_RX, &mxc_sdma_uart5_rx_params},
-	{MXC_DMA_UART5_TX, &mxc_sdma_uart5_tx_params},
-	{MXC_DMA_SSI1_8BIT_RX0, &mxc_sdma_ssi1_8bit_rx0_params},
-	{MXC_DMA_SSI1_8BIT_TX0, &mxc_sdma_ssi1_8bit_tx0_params},
-	{MXC_DMA_SSI1_16BIT_RX0, &mxc_sdma_ssi1_16bit_rx0_params},
-	{MXC_DMA_SSI1_16BIT_TX0, &mxc_sdma_ssi1_16bit_tx0_params},
-	{MXC_DMA_SSI1_24BIT_RX0, &mxc_sdma_ssi1_24bit_rx0_params},
-	{MXC_DMA_SSI1_24BIT_TX0, &mxc_sdma_ssi1_24bit_tx0_params},
-	{MXC_DMA_SSI1_8BIT_RX1, &mxc_sdma_ssi1_8bit_rx1_params},
-	{MXC_DMA_SSI1_8BIT_TX1, &mxc_sdma_ssi1_8bit_tx1_params},
-	{MXC_DMA_SSI1_16BIT_RX1, &mxc_sdma_ssi1_16bit_rx1_params},
-	{MXC_DMA_SSI1_16BIT_TX1, &mxc_sdma_ssi1_16bit_tx1_params},
-	{MXC_DMA_SSI1_24BIT_RX1, &mxc_sdma_ssi1_24bit_rx1_params},
-	{MXC_DMA_SSI1_24BIT_TX1, &mxc_sdma_ssi1_24bit_tx1_params},
-	{MXC_DMA_SSI2_8BIT_RX0, &mxc_sdma_ssi2_8bit_rx0_params},
-	{MXC_DMA_SSI2_8BIT_TX0, &mxc_sdma_ssi2_8bit_tx0_params},
-	{MXC_DMA_SSI2_16BIT_RX0, &mxc_sdma_ssi2_16bit_rx0_params},
-	{MXC_DMA_SSI2_16BIT_TX0, &mxc_sdma_ssi2_16bit_tx0_params},
-	{MXC_DMA_SSI2_24BIT_RX0, &mxc_sdma_ssi2_24bit_rx0_params},
-	{MXC_DMA_SSI2_24BIT_TX0, &mxc_sdma_ssi2_24bit_tx0_params},
-	{MXC_DMA_SSI2_8BIT_RX1, &mxc_sdma_ssi2_8bit_rx1_params},
-	{MXC_DMA_SSI2_8BIT_TX1, &mxc_sdma_ssi2_8bit_tx1_params},
-	{MXC_DMA_SSI2_16BIT_RX1, &mxc_sdma_ssi2_16bit_rx1_params},
-	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
-	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
-	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
-	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
-	{MXC_DMA_ATA_RX, &mxc_sdma_ata_rx_params},
-	{MXC_DMA_ATA_TX, &mxc_sdma_ata_tx_params},
-};
-
-static int mxc_sdma_info_entrys =
-    sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
-
-/*!
- * This functions Returns the SDMA paramaters associated for a module
- *
- * @param channel_id the ID of the module requesting DMA
- * @return returns the sdma parameters structure for the device
- */
-mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
-						       channel_id)
-{
-	mxc_sdma_info_entry_t *p = mxc_sdma_active_dma_info;
-	int i;
-
-	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
-		if (p->device == channel_id) {
-			return p->chnl_info;
-		}
-	}
-	return NULL;
-}
-
-/*!
- * This functions marks the SDMA channels that are statically allocated
- *
- * @param chnl the channel array used to store channel information
- */
-void mxc_get_static_channels(mxc_dma_channel_t * chnl)
-{
-	/* No channels statically allocated for MX33 */
-}
-
-EXPORT_SYMBOL(mxc_sdma_get_channel_params);
-EXPORT_SYMBOL(mxc_get_static_channels);
diff --git a/arch/arm/mach-mx33/iomux.c b/arch/arm/mach-mx33/iomux.c
deleted file mode 100644
index 4f0507d..0000000
--- a/arch/arm/mach-mx33/iomux.c
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#include <linux/module.h>
-#include <linux/spinlock.h>
-#include <asm/hardware.h>
-#include <asm/arch/gpio.h>
-#include "iomux.h"
-
-#define IOMUX_BASE_ADDRESS IO_ADDRESS(IOMUXC_BASE_ADDR)
-
-static DEFINE_SPINLOCK(gpio_mux_lock);
-
-static u32 iomux_pin_res_table[MUX_PIN_NUM_MAX];
-
-static int inline iomux_warning_ignored(iomux_pin_name_t pin)
-{
-	if (pin != MX33_PIN_UART1_CTS &&
-	    pin != MX33_PIN_UART1_RTS &&
-	    pin != MX33_PIN_UART1_DCD &&
-	    pin != MX33_PIN_UART1_DSR &&
-	    pin != MX33_PIN_UART1_DTR &&
-	    pin != MX33_PIN_UART1_RI &&
-	    pin != MX33_PIN_UART1_RXD && pin != MX33_PIN_UART1_TXD) {
-		return 1;
-	}
-	return 0;
-}
-
-/*!
- * This function is used to configure a pin through the IOMUX module.
- * FIXED ME: for backward compatible. Will be static function!
- * @param  pin		a pin number as defined in \b #iomux_pin_name_t
- * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
- * @param  in		an input function as defined in \b #iomux_pin_icfg_t
- *
- * @return 		0 if successful; Non-zero otherwise
- */
-int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
-		     iomux_pin_icfg_t in)
-{
-	u32 ret = 0;
-	u32 mux_index = PIN_TO_IOMUX_INDEX(pin);
-	u32 mux_reg = IOMUX_BASE_ADDRESS + PIN_TO_IOMUX_OFFSET(pin);
-	u32 *rp;
-
-	BUG_ON((mux_index > (MUX_PIN_NUM_MAX - 1)) || (out != in));
-
-	spin_lock(&gpio_mux_lock);
-	/*
-	 * Log a warning if a pin changes ownership
-	 */
-	rp = iomux_pin_res_table + (mux_index >> 2);
-	if ((out & *rp) && (*rp != out)) {
-		/*
-		 * Don't call printk if we're tweaking the console uart or
-		 * we'll deadlock.
-		 */
-		if (!iomux_warning_ignored(pin)) {
-			printk(KERN_ERR "iomux_config_mux: Warning: iomux pin"
-			       " config changed, reg=%x"
-			       " prev=0x%x new=0x%x\n", mux_reg, *rp, out);
-		}
-		ret = -EINVAL;
-	} else {
-		__raw_writel(out, mux_reg);
-
-		*rp = out;
-	}
-	spin_unlock(&gpio_mux_lock);
-
-	return ret;
-}
-
-/*!
- * Request ownership for an IO pin. This function has to be the first one
- * being called before that pin is used. The caller has to check the
- * return value to make sure it returns 0.
- *
- * @param  pin		a name defined by \b iomux_pin_name_t
- * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
- * @param  in		an input function as defined in \b #iomux_pin_icfg_t
- *
- * @return		0 if successful; Non-zero otherwise
- */
-int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
-		      iomux_pin_icfg_t in)
-{
-	int ret = iomux_config_mux(pin, out, in);
-	int gpio_port = GPIO_TO_PORT(IOMUX_TO_GPIO(pin));
-	if (!ret && (gpio_port != 7) && (out == PIN_TO_IOGPIO_INDEX(pin))) {
-		ret |= mxc_request_gpio(pin);
-	}
-	return ret;
-}
-
-/*!
- * Release ownership for an IO pin
- *
- * @param  pin		a name defined by \b iomux_pin_name_t
- * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
- * @param  in		an input function as defined in \b #iomux_pin_icfg_t
- */
-void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
-		    iomux_pin_icfg_t in)
-{
-	u32 mux_index = PIN_TO_IOMUX_INDEX(pin);
-	u32 *rp = iomux_pin_res_table + (mux_index >> 2);
-	int gpio_port = GPIO_TO_PORT(IOMUX_TO_GPIO(pin));
-
-	BUG_ON(mux_index > (MUX_PIN_NUM_MAX - 1));
-
-	*rp = 0;
-	if ((gpio_port != 7) && (out == PIN_TO_IOGPIO_INDEX(pin))) {
-		mxc_free_gpio(pin);
-	}
-}
-
-/*!
- * This function configures the pad value for a IOMUX pin.
- *
- * @param  pin          a pin number as defined in \b #iomux_pin_name_t
- * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
- */
-void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
-{
-	u32 pad_reg = IOMUX_BASE_ADDRESS + PIN_TO_IOPAD_OFFSET(pin);
-
-	BUG_ON(pad_reg > (PAD_CTL_GRP_BASE - 1));
-
-	spin_lock(&gpio_mux_lock);
-	__raw_writel(config, pad_reg);
-	spin_unlock(&gpio_mux_lock);
-}
-
-/*!
- * This function configures the pad value for a IOMUX pin group.
- *
- * @param  grp         a pin number as defined in \b #iomux_pad_grp_t
- * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
- */
-void mxc_iomux_set_pad_grp(iomux_pad_grp_t grp, u32 config)
-{
-	u32 grp_reg = IOMUX_BASE_ADDRESS + PAD_CTL_GRP_INDEX(grp);
-
-	BUG_ON(grp > (PAD_CTL_GRP_MAX - 1));
-
-	spin_lock(&gpio_mux_lock);
-	__raw_writel(config, grp_reg);
-	spin_unlock(&gpio_mux_lock);
-
-}
-
-/*!
- * This function select a input for a IOMUX signal.
- *
- * @param  signal       a signal number as defined in \b #iomux_signal_name_t
- * @param  config       value of input configuration
- */
-void iomux_select_input(iomux_signal_name_t signal, __u32 config)
-{
-	u32 input_reg = IOMUX_BASE_ADDRESS + IOMUXC_SELECT_INPUT(signal);
-
-	BUG_ON(signal > (IOMUX_SIGNAL_MAX - 1));
-
-	spin_lock(&gpio_mux_lock);
-	__raw_writel(config, input_reg);
-	spin_unlock(&gpio_mux_lock);
-}
-
-/*
- * FIXED ME: for backward compatible. to be removed!
- */
-void iomux_config_pad(iomux_pin_name_t pin, u32 config)
-{
-	mxc_iomux_set_pad(pin, config);
-}
-
-/*
- * FIXED ME: for backward compatible. to be removed!
- */
-void iomux_config_pad_grp(iomux_pad_grp_t grp, __u32 config)
-{
-	mxc_iomux_set_pad_grp(grp, config);
-}
-
-/*!
- * This function enables/disables the general purpose function for a particular
- * signal.
- *
- * @param  gp   one signal as defined in \b #iomux_gp_func_t
- * @param  en   \b #true to enable; \b #false to disable
- */
-void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en)
-{
-//      u32 reg, l;
-
-	spin_lock(&gpio_mux_lock);
-/*TODO: after the spec is finished
-	reg = base + gp>>5;
-	BUG_ON(reg > base+num)
-	l = __raw_readl(reg);
-	if (en) {
-		l |= 1<<(gp&31);
-	} else {
-		l &= ~(1<<(gp&31));
-	}
-	__raw_writel(l, reg);
-*/
-	spin_unlock(&gpio_mux_lock);
-}
-
-/*!
- * FIXED ME: for backward compatible. to be removed!
- */
-void iomux_config_gpr(iomux_gp_func_t gp, bool en)
-{
-	mxc_iomux_set_gpr(gp, en);
-}
-
-EXPORT_SYMBOL(mxc_request_iomux);
-EXPORT_SYMBOL(mxc_free_iomux);
-EXPORT_SYMBOL(mxc_iomux_set_pad);
-EXPORT_SYMBOL(mxc_iomux_set_gpr);
-EXPORT_SYMBOL(iomux_config_pad);
-EXPORT_SYMBOL(iomux_config_gpr);
-EXPORT_SYMBOL(iomux_config_mux);
diff --git a/arch/arm/mach-mx33/iomux.h b/arch/arm/mach-mx33/iomux.h
deleted file mode 100644
index 296f971..0000000
--- a/arch/arm/mach-mx33/iomux.h
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-#ifndef __MACH_MX33_IOMUX_H__
-#define __MACH_MX33_IOMUX_H__
-
-#include <linux/types.h>
-
-/*!
- * various IOMUX output functions
- */
-typedef enum iomux_output_config {
-	OUTPUTCONFIG_ALT0 = 0,	/*!< used as alternate function 0 */
-	OUTPUTCONFIG_ALT1,	/*!< used as alternate function 1 */
-	OUTPUTCONFIG_ALT2,	/*!< used as GPIO : same as ALT2  */
-	OUTPUTCONFIG_ALT3,	/*!< used as alternate function 3 */
-	OUTPUTCONFIG_ALT4,	/*!< used as alternate function 4 */
-	OUTPUTCONFIG_ALT5,	/*!< used as alternate function 5 */
-	OUTPUTCONFIG_ALT6,	/*!< used as alternate function 6 */
-	OUTPUTCONFIG_ALT7,	/*!< used as alternate function 2 */
-	OUTPUTCONFIG_FUNC = 0x10,	/*!< used as function */
-} iomux_pin_ocfg_t;
-
-/*!
- * various IOMUX input functions
- */
-typedef enum iomux_input_config {
-	INPUTCONFIG_ALT0 = 0,	/*!< used as alternate function 0 */
-	INPUTCONFIG_ALT1,	/*!< used as alternate function 1 */
-	INPUTCONFIG_ALT2,	/*!< used as GPIO : same as ALT2  */
-	INPUTCONFIG_ALT3,	/*!< used as alternate function 3 */
-	INPUTCONFIG_ALT4,	/*!< used as alternate function 4 */
-	INPUTCONFIG_ALT5,	/*!< used as alternate function 5 */
-	INPUTCONFIG_ALT6,	/*!< used as alternate function 6 */
-	INPUTCONFIG_ALT7,	/*!< used as alternate function 2 */
-	INPUTCONFIG_FUNC = 0x10,	/*!< used as function */
-} iomux_pin_icfg_t;
-
-/*!
- * various IOMUX pad functions
- */
-typedef enum iomux_pad_config {
-	PAD_CTL_CMOS_INPUT = 0x0 << 9,
-	PAD_CTL_DDR_INPUT = 0x1 << 9,
-	PAD_CTL_HYS_NONE = 0x0 << 8,
-	PAD_CTL_HYS_ENABLE = 0x1 << 8,
-	PAD_CTL_PKE_NONE = 0x0 << 7,
-	PAD_CTL_PKE_ENABLE = 0x1 << 7,
-	PAD_CTL_PUE_KEEPER = 0x0 << 6,
-	PAD_CTL_PUE_PUD = 0x1 << 6,
-	PAD_CTL_100K_PD = 0x0 << 4,
-	PAD_CTL_100K_PU = 0x1 << 4,
-	PAD_CTL_47K_PU = 0x2 << 4,
-	PAD_CTL_22K_PU = 0x3 << 4,
-	PAD_CTL_ODE_CMOS = 0x0 << 3,
-	PAD_CTL_ODE_OpenDrain = 0x1 << 3,
-	PAD_CTL_DRV_LOW = 0x0 << 1,
-	PAD_CTL_DRV_MEDIUM = 0x1 << 1,
-	PAD_CTL_DRV_HIGH = 0x2 << 1,
-	PAD_CTL_DRV_MAX = 0x3 << 1,
-	PAD_CTL_SRE_SLOW = 0x0 << 0,
-	PAD_CTL_SRE_FAST = 0x1 << 0
-} iomux_pad_config_t;
-
-/*!
- * various IOMUX pad functions for pin group
- */
-#define PAD_CTL_GRP_BASE	0x05F8
-#define PAD_CTL_GRP_INDEX(x) (PAD_CTL_GRP_BASE+((x)<<2))
-
-typedef enum iomux_pad_group {
-	PAD_CTL_GRP_H323 = 0,
-	PAD_CTL_GRP_H26,
-	PAD_CTL_GRP_H8,
-	PAD_CTL_GRP_DS1,
-	PAD_CTL_GRP_H27,
-	PAD_CTL_GRP_H243,
-	PAD_CTL_GRP_H10,
-	PAD_CTL_GRP_H9,
-	PAD_CTL_GRP_DS272,
-	PAD_CTL_GRP_H11,
-	PAD_CTL_GRP_H12,
-	PAD_CTL_GRP_H31,
-	PAD_CTL_GRP_H13,
-	PAD_CTL_GRP_H32,
-	PAD_CTL_GRP_SD2_PU,
-	PAD_CTL_GRP_DS275,
-	PAD_CTL_GRP_DS68,
-	PAD_CTL_GRP_H33,
-	PAD_CTL_GRP_DS69,
-	PAD_CTL_GRP_H34,
-	PAD_CTL_GRP_H16,
-	PAD_CTL_GRP_H17,
-	PAD_CTL_GRP_H18,
-	PAD_CTL_GRP_DS55,
-	PAD_CTL_GRP_H1,
-	PAD_CTL_GRP_H20,
-	PAD_CTL_GRP_H19,
-	PAD_CTL_GRP_H2,
-	PAD_CTL_GRP_DS310,
-	PAD_CTL_GRP_DS299,
-	PAD_CTL_GRP_H290,
-	PAD_CTL_GRP_H21,
-	PAD_CTL_GRP_H3,
-	PAD_CTL_GRP_SD1_PU,
-	PAD_CTL_GRP_H22,
-	PAD_CTL_GRP_H4,
-	PAD_CTL_GRP_H319,
-	PAD_CTL_GRP_H5,
-	PAD_CTL_GRP_SD3_PU,
-	PAD_CTL_GRP_H24,
-	PAD_CTL_GRP_H239,
-	PAD_CTL_GRP_H6,
-	PAD_CTL_GRP_IMDQS,
-	PAD_CTL_GRP_H294,
-	PAD_CTL_GRP_H25,
-	PAD_CTL_GRP_H7,
-	PAD_CTL_GRP_IM1,
-	PAD_CTL_GRP_MAX
-} iomux_pad_grp_t;
-
-/*!
- * various IOMUX the index of pad's select input register
- */
-#define IOMUXC_SELECT_INPUT(x) (0x06B4+((x)<<2))
-
-typedef enum iomux_signal_name {
-	AUDMUX_P7_INPUT_DB_AMX = 0,
-	AUDMUX_P7_INPUT_TXCLK_AMX,
-	AUDMUX_P7_INPUT_TXFS_AMX,
-	CCM_IPP_DI_CLK,
-	CCM_PLL1_BYPASS_CLK,
-	CCM_PLL2_BYPASS_CLK,
-	CCM_PLL3_BYPASS_CLK,
-	CSPI1_IPP_CSPI_CLK_IN,
-	CSPI1_IPP_IND_MISO,
-	CSPI1_IPP_IND_MOSI,
-	CSPI1_IPP_IND_SS_B_0,
-	CSPI1_IPP_IND_SS_B_1,
-	CSPI2_IPP_CSPI_CLK_IN,
-	CSPI2_IPP_IND_DATAREADY_B,
-	CSPI2_IPP_IND_MISO,
-	CSPI2_IPP_IND_MOSI,
-	CSPI2_IPP_IND_SS_B_0,
-	CSPI2_IPP_IND_SS_B_2,
-	CSPI2_IPP_IND_SS_B_3,
-	CSPI3_IPP_CSPI_CLK_IN,
-	CSPI3_IPP_IND_MISO,
-	CSPI3_IPP_IND_MOSI,
-	CSPI3_IPP_IND_SS_B_3,
-	EMI_IPP_IND_RDY_INT,
-	FEC_FEC_COL,
-	FEC_FEC_CRS,
-	FEC_FEC_MDI,
-	FEC_FEC_RDATA_0,
-	FEC_FEC_RDATA_1,
-	FEC_FEC_RDATA_2,
-	FEC_FEC_RDATA_3,
-	FEC_FEC_RX_CLK,
-	FEC_FEC_RX_DV,
-	FEC_FEC_RX_ER,
-	FEC_FEC_TX_CLK,
-	HSC_IPP_IND_SENS1_DATA_EN,
-	HSC_IPP_IND_SENS2_DATA_EN,
-	HSC_PAR_SISG_TRIG,
-	I2C3_IPP_SCL_IN,
-	I2C3_IPP_SDA_IN,
-	IPU_IPP_DI_1_EXT_CLK,
-	IPU_IPP_DI_1_IND_DISPB_DATA_16,
-	IPU_IPP_DI_1_IND_DISPB_DATA_17,
-	IPU_IPP_DI_1_IND_DISPB_SD_D,
-	PATA_IPP_IND_ATA_DATA_0,
-	PATA_IPP_IND_ATA_DATA_10,
-	PATA_IPP_IND_ATA_DATA_11,
-	PATA_IPP_IND_ATA_DATA_12,
-	PATA_IPP_IND_ATA_DATA_13,
-	PATA_IPP_IND_ATA_DATA_14,
-	PATA_IPP_IND_ATA_DATA_15,
-	PATA_IPP_IND_ATA_DATA_1,
-	PATA_IPP_IND_ATA_DATA_2,
-	PATA_IPP_IND_ATA_DATA_3,
-	PATA_IPP_IND_ATA_DATA_4,
-	PATA_IPP_IND_ATA_DATA_5,
-	PATA_IPP_IND_ATA_DATA_6,
-	PATA_IPP_IND_ATA_DATA_7,
-	PATA_IPP_IND_ATA_DATA_8,
-	PATA_IPP_IND_ATA_DATA_9,
-	PATA_IPP_IND_ATA_DMARQ,
-	PATA_IPP_IND_ATA_INTRQ,
-	PATA_IPP_IND_ATA_IORDY,
-	UART1_IPP_UART_DCD_DTE_I_B,
-	UART1_IPP_UART_DSR_DTE_I_B,
-	UART1_IPP_UART_DTR_DCE_I_B,
-	UART1_IPP_UART_RI_DTE_I_B,
-	UART1_IPP_UART_RTS_B,
-	UART1_IPP_UART_RXD_MUX,
-	UART2_IPP_UART_RTS_B,
-	UART2_IPP_UART_RXD_MUX,
-	UART3_IPP_UART_RTS_B,
-	UART3_IPP_UART_RXD_MUX,
-	UART4_IPP_UART_RTS_B,
-	UART4_IPP_UART_RXD_MUX,
-	UART5_IPP_UART_RTS_B,
-	UART5_IPP_UART_RXD_MUX,
-	IOMUX_SIGNAL_MAX
-} iomux_signal_name_t;
-
-/*!
- * various IOMUX general purpose functions
- * TODO:// Still be not define in zappa
- */
-typedef enum iomux_gp_func {
-	MUX_PGP_FIRI = 0x1 << 0,
-	MUX_DDR_MODE = 0x1 << 1,
-	MUX_PGP_CSPI_BB = 0x1 << 2,
-	MUX_PGP_ATA_1 = 0x1 << 3,
-	MUX_PGP_ATA_2 = 0x1 << 4,
-	MUX_PGP_ATA_3 = 0x1 << 5,
-	MUX_PGP_ATA_4 = 0x1 << 6,
-	MUX_PGP_ATA_5 = 0x1 << 7,
-	MUX_PGP_ATA_6 = 0x1 << 8,
-	MUX_PGP_ATA_7 = 0x1 << 9,
-	MUX_PGP_ATA_8 = 0x1 << 10,
-	MUX_PGP_UH2 = 0x1 << 11,
-	MUX_SDCTL_CSD0_SEL = 0x1 << 12,
-	MUX_SDCTL_CSD1_SEL = 0x1 << 13,
-	MUX_CSPI1_UART3 = 0x1 << 14,
-	MUX_EXTDMAREQ2_MBX_SEL = 0x1 << 15,
-	MUX_TAMPER_DETECT_EN = 0x1 << 16,
-	MUX_PGP_USB_4WIRE = 0x1 << 17,
-	MUX_PGB_USB_COMMON = 0x1 << 18,
-	MUX_SDHC_MEMSTICK1 = 0x1 << 19,
-	MUX_SDHC_MEMSTICK2 = 0x1 << 20,
-	MUX_PGP_SPLL_BYP = 0x1 << 21,
-	MUX_PGP_UPLL_BYP = 0x1 << 22,
-	MUX_PGP_MSHC1_CLK_SEL = 0x1 << 23,
-	MUX_PGP_MSHC2_CLK_SEL = 0x1 << 24,
-	MUX_CSPI3_UART5_SEL = 0x1 << 25,
-	MUX_PGP_ATA_9 = 0x1 << 26,
-	MUX_PGP_USB_SUSPEND = 0x1 << 27,
-	MUX_PGP_USB_OTG_LOOPBACK = 0x1 << 28,
-	MUX_PGP_USB_HS1_LOOPBACK = 0x1 << 29,
-	MUX_PGP_USB_HS2_LOOPBACK = 0x1 << 30,
-	MUX_CLKO_DDR_MODE = 0x1 << 31,
-} iomux_gp_func_t;
-
-/*!
- * This function is used to configure a pin through the IOMUX module.
- *
- * @param  pin		a pin number as defined in \b #iomux_pin_name_t
- * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
- * @param  in		an input function as defined in \b #iomux_pin_icfg_t
- * @return 		0 if successful; Non-zero otherwise
- */
-int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
-		     iomux_pin_icfg_t in);
-
-/*!
- * This function configures the pad value for a IOMUX pin.
- *
- * @param  pin          a pin number as defined in \b #iomux_pins
- * @param  config       ORed value of elements defined in \b #iomux_pad_config_t
- */
-void iomux_config_pad(iomux_pin_name_t pin, __u32 config);
-
-/*!
- * This function select a input for a IOMUX signal.
- *
- * @param  signal       a signal number as defined in \b #iomux_signal_name_t
- * @param  config       value of input configuration
- */
-void iomux_select_input(iomux_signal_name_t signal, __u32 config);
-
-/*!
- * This function configures the pad value for a IOMUX pin group.
- *
- * @param  grp          a pin number as defined in \b #iomux_pad_grp_t
- * @param  config       ORed value of elements defined in \b #iomux_pad_config_t
- */
-void iomux_config_pad_grp(iomux_pad_grp_t grp, __u32 config);
-
-/*!
- * This function enables/disables the general purpose function for a particular
- * signal.
- *
- * @param  gp   one signal as defined in \b #iomux_gp_func_t
- * @param  en   \b #true to enable; \b #false to disable
- */
-void iomux_config_gpr(iomux_gp_func_t gp, bool en);
-
-/*!
- * Request ownership for an IO pin. This function has to be the first one
- * being called before that pin is used. The caller has to check the
- * return value to make sure it returns 0.
- *
- * @param  pin		a name defined by \b iomux_pin_name_t
- * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
- * @param  in		an input function as defined in \b #iomux_pin_icfg_t
- *
- * @return		0 if successful; Non-zero otherwise
- */
-int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
-		      iomux_pin_icfg_t in);
-
-/*!
- * Release ownership for an IO pin
- *
- * @param  pin		a name defined by \b iomux_pin_name_t
- * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
- * @param  in		an input function as defined in \b #iomux_pin_icfg_t
- */
-void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
-		    iomux_pin_icfg_t in);
-
-/*!
- * This function enables/disables the general purpose function for a particular
- * signal.
- *
- * @param  gp   one signal as defined in \b #iomux_gp_func_t
- * @param  en   \b #true to enable; \b #false to disable
- */
-void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en);
-
-/*!
- * This function configures the pad value for a IOMUX pin.
- *
- * @param  pin          a pin number as defined in \b #iomux_pin_name_t
- * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
- */
-void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config);
-
-/*!
- * This function configures the pad value for a IOMUX pin group.
- *
- * @param  grp         a pin number as defined in \b #iomux_pad_grp_t
- * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
- */
-void mxc_iomux_set_pad_grp(iomux_pad_grp_t grp, u32 config);
-
-#endif
diff --git a/arch/arm/mach-mx33/irq.c b/arch/arm/mach-mx33/irq.c
deleted file mode 100644
index f51d88f..0000000
--- a/arch/arm/mach-mx33/irq.c
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- *  Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/errno.h>
-#include <asm/hardware.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/mach/irq.h>
-
-/*!
- * Disable interrupt number "irq" in the TZIC
- *
- * @param  irq          interrupt source number
- */
-static void mxc_mask_irq(unsigned int irq)
-{
-	int index, off;
-	index = irq >> 5;
-	off = irq & 0x1F;
-	__raw_writel(1 << off, TZIC_ENCLEAR0 + (index << 2));
-}
-
-/*!
- * Enable interrupt number "irq" in the TZIC
- *
- * @param  irq          interrupt source number
- */
-static void mxc_unmask_irq(unsigned int irq)
-{
-	int index, off;
-	index = irq >> 5;
-	off = irq & 0x1F;
-	__raw_writel(1 << off, TZIC_ENSET0 + (index << 2));
-}
-
-static struct irqchip mxc_avic_chip = {
-	.ack = mxc_mask_irq,
-	.mask = mxc_mask_irq,
-	.unmask = mxc_unmask_irq,
-};
-
-/*!
- * This function initializes the AVIC hardware and disables all the
- * interrupts. It registers the interrupt enable and disable functions
- * to the kernel for each interrupt source.
- */
-void __init mxc_init_irq(void)
-{
-	int i;
-	u32 reg;
-
-	/* put the AVIC into the reset value with
-	 * all interrupts disabled
-	 */
-	i = __raw_readl(TZIC_INTCNTL);
-
-	__raw_writel(0x80010001, TZIC_INTCNTL);
-	i = __raw_readl(TZIC_INTCNTL);
-	__raw_writel(0x1f, TZIC_PRIOMASK);
-	i = __raw_readl(TZIC_PRIOMASK);
-	__raw_writel(0x02, TZIC_SYNCCTRL);
-	i = __raw_readl(TZIC_SYNCCTRL);
-	for (i = 0; i < 32; i++) {
-		__raw_writel(0xFFFFFFFF, TZIC_INTSEC0 + i * 4);
-	}
-	/* disable all interrupts */
-	for (i = 0; i < 32; i++) {
-		__raw_writel(0xFFFFFFFF, TZIC_ENCLEAR0 + i * 4);
-	}
-
-	/* all IRQ no FIQ Warning :: No selection */
-
-	for (i = 0; i < MXC_MAX_INT_LINES; i++) {
-		set_irq_chip(i, &mxc_avic_chip);
-		set_irq_handler(i, do_level_IRQ);
-		set_irq_flags(i, IRQF_VALID);
-	}
-
-	printk(KERN_INFO "MXC IRQ initialized\n");
-}
diff --git a/arch/arm/mach-mx33/mm.c b/arch/arm/mach-mx33/mm.c
deleted file mode 100644
index 14ca8d3..0000000
--- a/arch/arm/mach-mx33/mm.c
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- *  Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- *    - add MX33 specific definitions
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <linux/mm.h>
-#include <linux/init.h>
-#include <asm/hardware.h>
-#include <asm/pgtable.h>
-#include <asm/mach/map.h>
-
-/*!
- * @file mm.c
- *
- * @brief This file creates static mapping between physical to virtual memory.
- *
- * @ingroup Memory
- */
-
-/*!
- * This structure defines the MX33 memory map.
- */
-static struct map_desc mxc_io_desc[] __initdata = {
-	/*  Virtual Address      Physical Address  Size         Type    */
-	{
-	 .virtual = IRAM_BASE_ADDR_VIRT,
-	 .pfn = __phys_to_pfn(IRAM_BASE_ADDR),
-	 .length = IRAM_SIZE,
-	 .type = MT_NONSHARED_DEVICE},
-	{
-	 .virtual = CS4_BASE_ADDR_VIRT,
-	 .pfn = __phys_to_pfn(CS4_BASE_ADDR),
-	 .length = CS4_SIZE,
-	 .type = MT_DEVICE},
-	{
-	 .virtual = L2CC_BASE_ADDR_VIRT,
-	 .pfn = __phys_to_pfn(L2CC_BASE_ADDR),
-	 .length = L2CC_SIZE,
-//       .type = MT_DEVICE
-	 .type = MT_NONSHARED_DEVICE},
-	{
-	 .virtual = PLATFORM_BASE_ADDR_VIRT,
-	 .pfn = __phys_to_pfn(PLATFORM_BASE_ADDR),
-	 .length = PLATFORM_SIZE,
-	 .type = MT_DEVICE},
-	{
-	 .virtual = TZIC_BASE_ADDR_VIRT,
-	 .pfn = __phys_to_pfn(TZIC_BASE_ADDR),
-	 .length = TZIC_SIZE,
-	 .type = MT_NONSHARED_DEVICE},
-	{
-	 .virtual = DEBUG_BASE_ADDR_VIRT,
-	 .pfn = __phys_to_pfn(DEBUG_BASE_ADDR),
-	 .length = DEBUG_SIZE,
-	 .type = MT_NONSHARED_DEVICE},
-	{
-	 .virtual = SPBA0_BASE_ADDR_VIRT,
-	 .pfn = __phys_to_pfn(SPBA0_BASE_ADDR),
-	 .length = SPBA0_SIZE,
-	 .type = MT_NONSHARED_DEVICE},
-	{
-	 .virtual = AIPS1_BASE_ADDR_VIRT,
-	 .pfn = __phys_to_pfn(AIPS1_BASE_ADDR),
-	 .length = AIPS1_SIZE,
-	 .type = MT_NONSHARED_DEVICE},
-	{
-	 .virtual = AIPS2_BASE_ADDR_VIRT,
-	 .pfn = __phys_to_pfn(AIPS2_BASE_ADDR),
-	 .length = AIPS2_SIZE,
-	 .type = MT_NONSHARED_DEVICE},
-};
-
-/*!
- * This function initializes the memory map. It is called during the
- * system startup to create static physical to virtual memory map for
- * the IO modules.
- */
-void __init mxc_map_io(void)
-{
-	iotable_init(mxc_io_desc, ARRAY_SIZE(mxc_io_desc));
-}
diff --git a/arch/arm/mach-mx33/mx33ads.c b/arch/arm/mach-mx33/mx33ads.c
deleted file mode 100644
index e0e5372..0000000
--- a/arch/arm/mach-mx33/mx33ads.c
+++ /dev/null
@@ -1,565 +0,0 @@
-/*
- *  Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <linux/types.h>
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/init.h>
-#include <linux/serial_8250.h>
-#ifdef CONFIG_KGDB_8250
-#include <linux/kgdb.h>
-#endif
-#include <linux/input.h>
-#include <linux/nodemask.h>
-#include <linux/spi/spi.h>
-#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/map.h>
-#include <linux/mtd/partitions.h>
-
-#include <asm/mach/flash.h>
-#endif
-
-#include <asm/hardware.h>
-#include <asm/irq.h>
-#include <asm/setup.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/irq.h>
-#include <asm/mach/keypad.h>
-#include <asm/arch/memory.h>
-#include <asm/arch/gpio.h>
-#include <asm/arch/clock.h>
-
-#include "crm_regs.h"
-#include "iomux.h"
-/*!
- * @file mx33ads.c
- *
- * @brief This file contains the board specific initialization routines.
- *
- * @ingroup System
- */
-
-extern void mxc_map_io(void);
-extern void mxc_init_irq(void);
-extern void mxc_cpu_init(void) __init;
-extern void mx33ads_gpio_init(void) __init;
-extern struct sys_timer mxc_timer;
-extern void mxc_cpu_common_init(void);
-
-static void mxc_nop_release(struct device *dev)
-{
-	/* Nothing */
-}
-
-#if defined(CONFIG_KEYBOARD_MXC) || defined(CONFIG_KEYBOARD_MXC_MODULE)
-
-/* Keypad keycodes for the EVB 8x8
- * keypad.  POWER and PTT keys don't generate
- * any interrupts via this driver so they are
- * not support. Change any keys as u like!
- */
-static u16 keymapping[64] = {
-	KEY_SELECT, KEY_LEFT, KEY_DOWN, KEY_RIGHT,
-	KEY_UP, KEY_F12, KEY_END, KEY_BACK,
-	KEY_F1, KEY_SENDFILE, KEY_HOME, KEY_F6,
-	KEY_VOLUMEUP, KEY_F8, KEY_F9, KEY_F10,
-	KEY_3, KEY_2, KEY_1, KEY_4,
-	KEY_VOLUMEDOWN, KEY_7, KEY_5, KEY_6,
-	KEY_9, KEY_LEFTSHIFT, KEY_8, KEY_0,
-	KEY_KPASTERISK, KEY_RECORD, KEY_Q, KEY_W,
-	KEY_A, KEY_S, KEY_D, KEY_E,
-	KEY_F, KEY_R, KEY_T, KEY_Y,
-	KEY_TAB, KEY_F7, KEY_CAPSLOCK, KEY_Z,
-	KEY_X, KEY_C, KEY_V, KEY_G,
-	KEY_B, KEY_H, KEY_N, KEY_M,
-	KEY_J, KEY_K, KEY_U, KEY_I,
-	KEY_SPACE, KEY_F2, KEY_DOT, KEY_ENTER,
-	KEY_L, KEY_BACKSPACE, KEY_P, KEY_O,
-};
-
-static struct resource mxc_kpp_resources[] = {
-	[0] = {
-	       .start = INT_KPP,
-	       .end = INT_KPP,
-	       .flags = IORESOURCE_IRQ,
-	       }
-};
-
-static struct keypad_data evb_8_by_8_keypad = {
-	.rowmax = 8,
-	.colmax = 8,
-	.irq = INT_KPP,
-	.learning = 0,
-	.delay = 2,
-	.matrix = keymapping,
-};
-
-/* mxc keypad driver */
-static struct platform_device mxc_keypad_device = {
-	.name = "mxc_keypad",
-	.id = 0,
-	.num_resources = ARRAY_SIZE(mxc_kpp_resources),
-	.resource = mxc_kpp_resources,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &evb_8_by_8_keypad,
-		},
-};
-
-static void mxc_init_keypad(void)
-{
-	(void)platform_device_register(&mxc_keypad_device);
-}
-#else
-static inline void mxc_init_keypad(void)
-{
-}
-#endif
-
-#if defined(CONFIG_SERIAL_8250) || defined(CONFIG_SERIAL_8250_MODULE)
-/*!
- * The serial port definition structure. The fields contain:
- * {UART, CLK, PORT, IRQ, FLAGS}
- */
-static struct plat_serial8250_port serial_platform_data[] = {
-	{
-	 .membase = (void __iomem *)(PBC_BASE_ADDRESS + PBC_SC16C652_UARTA),
-	 .mapbase = (unsigned long)(CS4_BASE_ADDR + PBC_SC16C652_UARTA),
-	 .irq = EXPIO_INT_XUART_INTA,
-	 .uartclk = 14745600,
-	 .regshift = 0,
-	 .iotype = UPIO_MEM,
-	 .flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_AUTO_IRQ,
-	 },
-	{
-	 .membase = (void __iomem *)(PBC_BASE_ADDRESS + PBC_SC16C652_UARTB),
-	 .mapbase = (unsigned long)(CS4_BASE_ADDR + PBC_SC16C652_UARTB),
-	 .irq = EXPIO_INT_XUART_INTB,
-	 .uartclk = 14745600,
-	 .regshift = 0,
-	 .iotype = UPIO_MEM,
-	 .flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_AUTO_IRQ,
-	 },
-};
-
-/*!
- * REVISIT: document me
- */
-static struct platform_device serial_device = {
-	.name = "serial8250",
-	.id = 0,
-	.dev = {
-		.platform_data = serial_platform_data,
-		},
-};
-
-/*!
- * REVISIT: document me
- */
-static int __init mxc_init_extuart(void)
-{
-	return platform_device_register(&serial_device);
-}
-#else
-static inline int mxc_init_extuart(void)
-{
-	return 0;
-}
-#endif
-/* MTD NOR flash */
-
-#if defined(CONFIG_MTD_MXC) || defined(CONFIG_MTD_MXC_MODULE)
-
-static struct mtd_partition mxc_nor_partitions[] = {
-	{
-	 .name = "Bootloader",
-	 .size = 512 * 1024,
-	 .offset = 0x00000000,
-	 .mask_flags = MTD_WRITEABLE	/* force read-only */
-	 },
-	{
-	 .name = "nor.Kernel",
-	 .size = 2 * 1024 * 1024,
-	 .offset = MTDPART_OFS_APPEND,
-	 .mask_flags = 0},
-#if 0
-	{
-	 .name = "nor.userfs",
-	 .size = 14 * 1024 * 1024,
-	 .offset = MTDPART_OFS_APPEND,
-	 .mask_flags = 0},
-	{
-	 .name = "rootfs",
-	 .size = 12 * 1024 * 1024,
-	 .offset = MTDPART_OFS_APPEND,
-	 .mask_flags = MTD_WRITEABLE},
-#endif
-	{
-	 .name = "nor.rootfs",
-	 .size = 26 * 1024 * 1024,
-	 .offset = MTDPART_OFS_APPEND,
-	 .mask_flags = MTD_WRITEABLE},
-
-	{
-	 .name = "FIS directory",
-	 .size = 12 * 1024,
-	 .offset = 0x01FE0000,
-	 .mask_flags = MTD_WRITEABLE	/* force read-only */
-	 },
-	{
-	 .name = "Redboot config",
-	 .size = MTDPART_SIZ_FULL,
-	 .offset = 0x01FFF000,
-	 .mask_flags = MTD_WRITEABLE	/* force read-only */
-	 },
-};
-
-static struct flash_platform_data mxc_flash_data = {
-	.map_name = "cfi_probe",
-	.width = 2,
-	.parts = mxc_nor_partitions,
-	.nr_parts = ARRAY_SIZE(mxc_nor_partitions),
-};
-
-static struct resource mxc_flash_resource = {
-	.start = 0x60000000,
-	.end = 0x60000000 + SZ_128M - 1,
-	.flags = IORESOURCE_MEM,
-
-};
-
-static struct platform_device mxc_nor_mtd_device = {
-	.name = "mxc_nor_flash",
-	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxc_flash_data,
-		},
-	.num_resources = 1,
-	.resource = &mxc_flash_resource,
-};
-
-static void mxc_init_nor_mtd(void)
-{
-	(void)platform_device_register(&mxc_nor_mtd_device);
-}
-#else
-static void mxc_init_nor_mtd(void)
-{
-}
-#endif
-
-/* MTD NAND flash */
-
-#if defined(CONFIG_MTD_NAND_MXC) || defined(CONFIG_MTD_NAND_MXC_MODULE)
-
-static struct mtd_partition mxc_nand_partitions[4] = {
-	{
-	 .name = "IPL-SPL",
-	 .offset = 0,
-	 .size = 0x4000},
-	{
-	 .name = "nand.kernel",
-	 .offset = MTDPART_OFS_APPEND,
-	 .size = 4 * 1024 * 1024},
-	{
-	 .name = "nand.rootfs",
-	 .offset = MTDPART_OFS_APPEND,
-	 .size = 22 * 1024 * 1024},
-	{
-	 .name = "nand.userfs",
-	 .offset = MTDPART_OFS_APPEND,
-	 .size = MTDPART_SIZ_FULL},
-};
-
-static struct flash_platform_data mxc_nand_data = {
-	.parts = mxc_nand_partitions,
-	.nr_parts = ARRAY_SIZE(mxc_nand_partitions),
-	.width = 1,
-};
-
-static struct platform_device mxc_nand_mtd_device = {
-	.name = "mxc_nand_flash",
-	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxc_nand_data,
-		},
-};
-
-static void mxc_init_nand_mtd(void)
-{
-	if (__raw_readl(MXC_CCM_RCSR) & MXC_CCM_RCSR_NF16B) {
-		mxc_nand_data.width = 2;
-	}
-	(void)platform_device_register(&mxc_nand_mtd_device);
-}
-#else
-static inline void mxc_init_nand_mtd(void)
-{
-}
-#endif
-
-#if 0
-static struct spi_board_info mxc_spi_board_info[] __initdata = {
-	{
-	 .modalias = "pmic_spi",
-	 .irq = IOMUX_TO_IRQ(MX33_PIN_GPIO1_3),
-	 .max_speed_hz = 4000000,
-	 .bus_num = 2,
-	 .chip_select = 0,
-	 },
-};
-#endif
-#if defined(CONFIG_FB_MXC_SYNC_PANEL) || defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
-static const char fb_default_mode[] = "Sharp-QVGA";
-
-/* mxc lcd driver */
-static struct platform_device mxc_fb_device = {
-	.name = "mxc_sdc_fb",
-	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &fb_default_mode,
-		.coherent_dma_mask = 0xFFFFFFFF,
-		},
-};
-
-static void mxc_init_fb(void)
-{
-	(void)platform_device_register(&mxc_fb_device);
-}
-#else
-static inline void mxc_init_fb(void)
-{
-}
-#endif
-
-static void mxc_expio_irq_handler(u32 irq, struct irqdesc *desc,
-				  struct pt_regs *regs)
-{
-	u32 imr_val;
-	u32 int_valid;
-	u32 expio_irq;
-
-	desc->chip->mask(irq);	/* irq = gpio irq number */
-
-	imr_val = __raw_readw(PBC_INTMASK_SET_REG);
-	int_valid = __raw_readw(PBC_INTSTATUS_REG) & imr_val;
-
-	if (unlikely(!int_valid)) {
-		printk(KERN_ERR "\nEXPIO: Spurious interrupt:0x%0x\n\n",
-		       int_valid);
-		goto out;
-	}
-
-	expio_irq = MXC_EXP_IO_BASE;
-	for (; int_valid != 0; int_valid >>= 1, expio_irq++) {
-		struct irqdesc *d;
-		if ((int_valid & 1) == 0)
-			continue;
-		d = irq_desc + expio_irq;
-		if (unlikely(!(d->handle_irq))) {
-			printk(KERN_ERR "\nEXPIO irq: %d unhandeled\n",
-			       expio_irq);
-			BUG();	/* oops */
-		}
-		d->handle_irq(expio_irq, d, regs);
-	}
-
-      out:
-	desc->chip->ack(irq);
-	desc->chip->unmask(irq);
-}
-
-/*
- * Disable an expio pin's interrupt by setting the bit in the imr.
- * @param irq		an expio virtual irq number
- */
-static void expio_mask_irq(u32 irq)
-{
-	u32 expio = MXC_IRQ_TO_EXPIO(irq);
-	/* mask the interrupt */
-	__raw_writew(1 << expio, PBC_INTMASK_CLEAR_REG);
-}
-
-/*
- * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
- * @param irq		an expanded io virtual irq number
- */
-static void expio_ack_irq(u32 irq)
-{
-	u32 expio = MXC_IRQ_TO_EXPIO(irq);
-	/* clear the interrupt status */
-	__raw_writew(1 << expio, PBC_INTSTATUS_REG);
-	/* mask the interrupt */
-	expio_mask_irq(irq);
-}
-
-/*
- * Enable a expio pin's interrupt by clearing the bit in the imr.
- * @param irq		a expio virtual irq number
- */
-static void expio_unmask_irq(u32 irq)
-{
-	u32 expio = MXC_IRQ_TO_EXPIO(irq);
-	/* unmask the interrupt */
-	__raw_writew(1 << expio, PBC_INTMASK_SET_REG);
-}
-
-static struct irqchip expio_irq_chip = {
-	.ack = expio_ack_irq,
-	.mask = expio_mask_irq,
-	.unmask = expio_unmask_irq,
-};
-
-static int initialized = 0;
-
-static int __init _mxc_expio_init(void)
-{
-	int i;
-
-	initialized = 1;
-
-	printk(KERN_INFO "MX33ADS EXPIO(CPLD) hardware\n");
-#if 0
-	/*
-	 * Configure INT line as GPIO input
-	 */
-	mxc_request_iomux(MX33_PIN_GPIO1_4, OUTPUTCONFIG_GPIO,
-			  INPUTCONFIG_GPIO);
-	mxc_set_gpio_direction(MX33_PIN_GPIO1_4, 1);
-
-	/* disable the interrupt and clear the status */
-	__raw_writew(0xFFFF, PBC_INTMASK_CLEAR_REG);
-	__raw_writew(0xFFFF, PBC_INTSTATUS_REG);
-	for (i = MXC_EXP_IO_BASE; i < (MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES);
-	     i++) {
-		set_irq_chip(i, &expio_irq_chip);
-		set_irq_handler(i, do_level_IRQ);
-		set_irq_flags(i, IRQF_VALID);
-	}
-	set_irq_type(EXPIO_PARENT_INT, IRQT_HIGH);
-	set_irq_chained_handler(EXPIO_PARENT_INT, mxc_expio_irq_handler);
-#endif
-	return 0;
-}
-
-/*
- * This may get called early from board specific init
- */
-int mxc_expio_init(void)
-{
-	if (!initialized)
-		return _mxc_expio_init();
-	else
-		return 0;
-}
-
-/*!
- * Board specific fixup function. It is called by \b setup_arch() in
- * setup.c file very early on during kernel starts. It allows the user to
- * statically fill in the proper values for the passed-in parameters. None of
- * the parameters is used currently.
- *
- * @param  desc         pointer to \b struct \b machine_desc
- * @param  tags         pointer to \b struct \b tag
- * @param  cmdline      pointer to the command line
- * @param  mi           pointer to \b struct \b meminfo
- */
-static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
-				   char **cmdline, struct meminfo *mi)
-{
-	struct tag *t;
-#ifdef CONFIG_KGDB_8250
-	int i;
-	for (i = 0;
-	     i <
-	     (sizeof(serial_platform_data) / sizeof(serial_platform_data[0]));
-	     i += 1)
-		kgdb8250_add_platform_port(i, &serial_platform_data[i]);
-#endif
-
-	mxc_cpu_init();
-	for_each_tag(t, tags) {
-		if (t->hdr.tag == ATAG_MEM) {
-			t->u.mem.size = MEM_SIZE;
-			break;
-		}
-	}
-	if (t->hdr.size == 0) {
-		printk("%s: no mem tag found\n", __FUNCTION__);
-	}
-#ifdef CONFIG_DISCONTIGMEM
-	do {
-		int nid;
-		mi->nr_banks = MXC_NUMNODES;
-		for (nid = 0; nid < mi->nr_banks; nid++) {
-			SET_NODE(mi, nid);
-		}
-	} while (0);
-#endif
-}
-
-/*!
- * Board specific initialization.
- */
-static void __init mxc_board_init(void)
-#include <asm/arch/board.h>
-{
-
-	/* Enable 26 mhz clock on CKO1 for MC13783 audio */
-	//TODO: mxc_ccm_modify_reg(MXC_CCM_COSR, 0x00000fff, 0x00000208);
-
-	mxc_gpio_init();
-	mx33ads_gpio_init();
-	//mxc_expio_init();
-	//mxc_init_keypad();
-	//mxc_init_extuart();
-	mxc_init_nor_mtd();
-	//mxc_init_nand_mtd();
-
-	//spi_register_board_info(mxc_spi_board_info,
-	//                      ARRAY_SIZE(mxc_spi_board_info));
-
-	//mxc_init_fb();
-}
-
-/*
- * The following uses standard kernel macros define in arch.h in order to
- * initialize __mach_desc_MX33ADS data structure.
- */
-/* *INDENT-OFF* */
-MACHINE_START(MX33ADS, "Freescale MX33ADS")
-	/* Maintainer: Freescale Semiconductor, Inc. */
-#ifdef CONFIG_SERIAL_8250_CONSOLE
-	.phys_io = CS4_BASE_ADDR,
-	.io_pg_offst = ((CS4_BASE_ADDR_VIRT) >> 18) & 0xfffc,
-#else
-	.phys_io = AIPS1_BASE_ADDR,
-	.io_pg_offst = ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
-#endif
-	.boot_params = PHYS_OFFSET + 0x100,
-	.fixup = fixup_mxc_board,
-	.map_io = mxc_map_io,
-	.init_irq = mxc_init_irq,
-	.init_machine = mxc_board_init,
-	.timer = &mxc_timer,
-MACHINE_END
diff --git a/arch/arm/mach-mx33/mx33ads_gpio.c b/arch/arm/mach-mx33/mx33ads_gpio.c
deleted file mode 100644
index c58ca1d..0000000
--- a/arch/arm/mach-mx33/mx33ads_gpio.c
+++ /dev/null
@@ -1,537 +0,0 @@
-/*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#include <linux/errno.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <asm/io.h>
-#include <asm/hardware.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/gpio.h>
-#include "iomux.h"
-
-/*!
- * @file mx31ads_gpio.c
- *
- * @brief This file contains all the GPIO setup functions for the board.
- *
- * @ingroup GPIO
- */
-
-void gpio_activate_audio_ports(void);
-
-/*!
- * This system-wise GPIO function initializes the pins during system startup.
- * All the statically linked device drivers should put the proper GPIO initialization
- * code inside this function. It is called by \b fixup_mx31ads() during
- * system startup. This function is board specific.
- */
-void mx33ads_gpio_init(void)
-{
- /*TODO*/}
-
-/*!
- * Setup GPIO for a UART port to be active
- *
- * @param  port         a UART port
- * @param  no_irda      indicates if the port is used for SIR
- */
-void gpio_uart_active(int port, int no_irda)
-{
- /*TODO*/}
-
-/*!
- * Setup GPIO for a UART port to be inactive
- *
- * @param  port         a UART port
- * @param  no_irda      indicates if the port is used for SIR
- */
-void gpio_uart_inactive(int port, int no_irda)
-{
- /*TODO*/}
-
-/*!
- * Configure the IOMUX GPR register to receive shared SDMA UART events
- *
- * @param  port         a UART port
- */
-void config_uartdma_event(int port)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_uart_active);
-EXPORT_SYMBOL(gpio_uart_inactive);
-EXPORT_SYMBOL(config_uartdma_event);
-
-/*!
- * Setup GPIO for Keypad  to be active
- *
- */
-void gpio_keypad_active(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_keypad_active);
-
-/*!
- * Setup GPIO for Keypad to be inactive
- *
- */
-void gpio_keypad_inactive(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_keypad_inactive);
-
-/*!
- * Setup GPIO for a CSPI device to be active
- *
- * @param  cspi_mod         an CSPI device
- */
-void gpio_spi_active(int cspi_mod)
-{
- /*TODO*/}
-
-/*!
- * Setup GPIO for a CSPI device to be inactive
- *
- * @param  cspi_mod         a CSPI device
- */
-void gpio_spi_inactive(int cspi_mod)
-{
- /*TODO*/}
-
-/*!
- * Setup 1-Wire to be active
- */
-void gpio_owire_active(void)
-{
- /*TODO*/}
-
-/*!
- * Setup 1-Wire to be active
- */
-void gpio_owire_inactive(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_owire_active);
-EXPORT_SYMBOL(gpio_owire_inactive);
-
-/*!
- * Setup GPIO for an I2C device to be active
- *
- * @param  i2c_num         an I2C device
- */
-void gpio_i2c_active(int i2c_num)
-{
- /*TODO*/}
-
-/*!
- * Setup GPIO for an I2C device to be inactive
- *
- * @param  i2c_num         an I2C device
- */
-void gpio_i2c_inactive(int i2c_num)
-{
- /*TODO*/}
-
-/*!
- * This function configures the IOMux block for MC13783 standard operations.
- *
- */
-void gpio_mc13783_active(void)
-{
- /*TODO*/}
-
-/*!
- * This function clears the MC13783 intrrupt.
- *
- */
-void gpio_mc13783_clear_int(void)
-{
- /*TODO*/}
-
-/*!
- * This function return the SPI connected to MC13783.
- *
- */
-int gpio_mc13783_get_spi(void)
-{
-	 /*TODO*/ return 1;
-}
-
-/*!
- * This function return the SPI smave select for MC13783.
- *
- */
-int gpio_mc13783_get_ss(void)
-{
-	 /*TODO*/ return 0;
-}
-
-/*!
- * This function activates DAM ports 4 & 5 to enable
- * audio I/O. Thsi function is called from mx31ads_gpio_init
- * function, which is board-specific.
- */
-void gpio_activate_audio_ports(void)
-{
-}
-
-/*!
- * Setup GPIO for SDHC to be active
- *
- * @param module SDHC module number
- */
-void gpio_sdhc_active(int module)
-{
-#if 0
-	switch (module) {
-	case 0:
-		mxc_request_iomux(MX33_PIN_SD1_CLK, OUTPUTCONFIG_FUNC,
-				  INPUTCONFIG_FUNC);
-		mxc_request_iomux(MX33_PIN_SD1_CMD, OUTPUTCONFIG_FUNC,
-				  INPUTCONFIG_FUNC);
-		mxc_request_iomux(MX33_PIN_SD1_DATA0, OUTPUTCONFIG_FUNC,
-				  INPUTCONFIG_FUNC);
-		mxc_request_iomux(MX33_PIN_SD1_DATA1, OUTPUTCONFIG_FUNC,
-				  INPUTCONFIG_FUNC);
-		mxc_request_iomux(MX33_PIN_SD1_DATA2, OUTPUTCONFIG_FUNC,
-				  INPUTCONFIG_FUNC);
-		mxc_request_iomux(MX33_PIN_SD1_DATA3, OUTPUTCONFIG_FUNC,
-				  INPUTCONFIG_FUNC);
-		break;
-	case 1:
-		mxc_request_iomux(MX33_PIN_PC_CD2_B, OUTPUTCONFIG_ALT1,
-				  INPUTCONFIG_ALT1);
-		mxc_request_iomux(MX33_PIN_PC_CD1_B, OUTPUTCONFIG_ALT1,
-				  INPUTCONFIG_ALT1);
-		mxc_request_iomux(MX33_PIN_PC_WAIT_B, OUTPUTCONFIG_ALT1,
-				  INPUTCONFIG_ALT1);
-		mxc_request_iomux(MX33_PIN_PC_READY, OUTPUTCONFIG_ALT1,
-				  INPUTCONFIG_ALT1);
-		mxc_request_iomux(MX33_PIN_PC_VS1, OUTPUTCONFIG_ALT1,
-				  INPUTCONFIG_ALT1);
-		mxc_request_iomux(MX33_PIN_PC_PWRON, OUTPUTCONFIG_ALT1,
-				  INPUTCONFIG_ALT1);
-		break;
-	default:
-		break;
-	}
-#endif
-}
-
-EXPORT_SYMBOL(gpio_sdhc_active);
-
-/*!
- * Setup GPIO for SDHC1 to be inactive
- *
- * @param module SDHC module number
- */
-void gpio_sdhc_inactive(int module)
-{
-#if 0
-	switch (module) {
-	case 0:
-		mxc_request_iomux(MX33_PIN_SD1_CLK, OUTPUTCONFIG_GPIO,
-				  INPUTCONFIG_NONE);
-		mxc_request_iomux(MX33_PIN_SD1_CMD, OUTPUTCONFIG_GPIO,
-				  INPUTCONFIG_NONE);
-		mxc_request_iomux(MX33_PIN_SD1_DATA0, OUTPUTCONFIG_GPIO,
-				  INPUTCONFIG_NONE);
-		mxc_request_iomux(MX33_PIN_SD1_DATA1, OUTPUTCONFIG_GPIO,
-				  INPUTCONFIG_NONE);
-		mxc_request_iomux(MX33_PIN_SD1_DATA2, OUTPUTCONFIG_GPIO,
-				  INPUTCONFIG_NONE);
-		mxc_request_iomux(MX33_PIN_SD1_DATA3, OUTPUTCONFIG_GPIO,
-				  INPUTCONFIG_NONE);
-		break;
-	case 1:
-		/* TODO:what are the pins for SDHC2? */
-		mxc_request_iomux(MX33_PIN_PC_CD2_B, OUTPUTCONFIG_GPIO,
-				  INPUTCONFIG_NONE);
-		mxc_request_iomux(MX33_PIN_PC_CD1_B, OUTPUTCONFIG_GPIO,
-				  INPUTCONFIG_NONE);
-		mxc_request_iomux(MX33_PIN_PC_WAIT_B, OUTPUTCONFIG_GPIO,
-				  INPUTCONFIG_NONE);
-		mxc_request_iomux(MX33_PIN_PC_READY, OUTPUTCONFIG_GPIO,
-				  INPUTCONFIG_NONE);
-		mxc_request_iomux(MX33_PIN_PC_VS1, OUTPUTCONFIG_GPIO,
-				  INPUTCONFIG_NONE);
-		mxc_request_iomux(MX33_PIN_PC_PWRON, OUTPUTCONFIG_GPIO,
-				  INPUTCONFIG_NONE);
-		break;
-	default:
-		break;
-	}
-#endif
-}
-
-EXPORT_SYMBOL(gpio_sdhc_inactive);
-
-/*
- * Probe for the card. If present the GPIO data would be set.
- */
-int sdhc_get_card_det_status(struct device *dev)
-{
-#if 0
-	if (to_platform_device(dev)->id == 0) {
-		return mxc_get_gpio_datain(MX33_PIN_GPIO1_1);
-	} else {
-		return mxc_get_gpio_datain(MX33_PIN_GPIO1_2);
-	}
-#endif
-}
-
-EXPORT_SYMBOL(sdhc_get_card_det_status);
-
-/*
- * Return the card detect pin.
- */
-int sdhc_init_card_det(int id)
-{
-#if 0
-	if (id == 0) {
-		iomux_config_mux(MX33_PIN_GPIO1_1, OUTPUTCONFIG_GPIO,
-				 INPUTCONFIG_GPIO);
-		return IOMUX_TO_IRQ(MX33_PIN_GPIO1_1);
-	} else {
-		iomux_config_mux(MX33_PIN_GPIO1_2, OUTPUTCONFIG_GPIO,
-				 INPUTCONFIG_GPIO);
-		return IOMUX_TO_IRQ(MX33_PIN_GPIO1_2);
-
-	}
-#endif
-}
-
-EXPORT_SYMBOL(sdhc_init_card_det);
-
-/*!
- * Setup GPIO for LCD to be active
- *
- */
-void gpio_lcd_active(void)
-{
- /*TODO*/}
-
-/*!
- * Setup GPIO for LCD to be inactive
- *
- */
-void gpio_lcd_inactive(void)
-{
- /*TODO*/}
-
-/*!
- * Setup pins for SLCD to be active
- *
- */
-void slcd_gpio_config(void)
-{
- /*TODO*/}
-
-/*!
- * Switch to the specified sensor - MX33 ADS has two
- *
- */
-void gpio_sensor_select(int sensor)
-{
- /*TODO*/}
-
-/*!
- * Setup GPIO for sensor to be active
- *
- */
-void gpio_sensor_active(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_sensor_active);
-
-/*!
- * Setup GPIO for sensor to be inactive
- *
- */
-void gpio_sensor_inactive(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_sensor_inactive);
-
-/*!
- * Setup GPIO for ATA interface
- *
- */
-void gpio_ata_active(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_ata_active);
-
-/*!
- * Restore ATA interface pins to reset values
- *
- */
-void gpio_ata_inactive(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_ata_inactive);
-
-/*!
- * Setup EDIO/IOMUX for external UART.
- *
- * @param port UART port
- * @param irq Interrupt line to allocate
- * @param handler Function to be called when the IRQ occurs
- * @param irq_flags Interrupt type flags
- * @param devname An ascii name for the claiming device
- * @param dev_id A cookie passed back to the handler function
- * @return  Returns 0 if the interrupt was successfully requested,
- *          otherwise returns an error code.
- */
-int extuart_intr_setup(unsigned int port, unsigned int irq,
-		       irqreturn_t(*handler) (int, void *, struct pt_regs *),
-		       unsigned long irq_flags, const char *devname,
-		       void *dev_id)
-{
-	 /*TODO*/ return 0;
-}
-
-/*!
- * Get the EDIO interrupt, clear if set.
- *
- * @param port UART port
- */
-void extuart_intr_clear(unsigned int port)
-{
- /*TODO*/}
-
-/*!
- * Do IOMUX configs required to put the
- * pin back in low power mode.
- *
- * @param port UART port
- * @param irq Interrupt line to free
- * @param dev_id Device identity to free
- * @return  Returns 0 if the interrupt was successfully freed,
- *          otherwise returns an error code.
- */
-int extuart_intr_cleanup(unsigned int port, unsigned int irq, void *dev_id)
-{
-	 /*TODO*/ return 0;
-}
-
-/*
- * USB Host 1
- * pins conflict with SPI1, ATA, UART3
- */
-int gpio_usbh1_active(void)
-{
-	 /*TODO*/ return 0;
-}
-
-EXPORT_SYMBOL(gpio_usbh1_active);
-
-void gpio_usbh1_inactive(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_usbh1_inactive);
-
-/*
- * USB Host 2
- * pins conflict with UART5, PCMCIA
- */
-int gpio_usbh2_active(void)
-{
-	 /*TODO*/ return 0;
-}
-
-EXPORT_SYMBOL(gpio_usbh2_active);
-
-void gpio_usbh2_inactive(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_usbh2_inactive);
-
-/*
- * USB OTG HS port
- */
-int gpio_usbotg_hs_active(void)
-{
-	 /*TODO*/ return 0;
-}
-
-EXPORT_SYMBOL(gpio_usbotg_hs_active);
-
-void gpio_usbotg_hs_inactive(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
-
-/*
- * USB OTG FS port
- */
-int gpio_usbotg_fs_active(void)
-{
-	 /*TODO*/ return 0;
-}
-
-EXPORT_SYMBOL(gpio_usbotg_fs_active);
-
-void gpio_usbotg_fs_inactive(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_usbotg_fs_inactive);
-
-/*!
- * Setup GPIO for PCMCIA interface
- *
- */
-void gpio_pcmcia_active(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_pcmcia_active);
-
-/*!
- * Setup GPIO for pcmcia to be inactive
- */
-void gpio_pcmcia_inactive(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_pcmcia_inactive);
-
-/*!
- * Setup GPIO for fec to be active
- */
-void gpio_fec_active(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_fec_active);
-/*!
- * Setup GPIO for fec to be inactive
- */
-void gpio_fec_inactive(void)
-{
- /*TODO*/}
-
-EXPORT_SYMBOL(gpio_fec_inactive);
diff --git a/arch/arm/mach-mx33/sdma_script_code.h b/arch/arm/mach-mx33/sdma_script_code.h
deleted file mode 100644
index 650e5fc..0000000
--- a/arch/arm/mach-mx33/sdma_script_code.h
+++ /dev/null
@@ -1,355 +0,0 @@
-
-/*
- * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.  */
-
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  */
-
-#ifndef SDMA_SCRIPT_CODE_H
-#define SDMA_SCRIPT_CODE_H
-
-/*!
-* Following define start address of signature script
-*/
-#define signature_ADDR	1023
-/*!
-* Following define size of signature script
-*/
-#define signature_SIZE	1
-
-/*!
-* Following define start address of start script
-*/
-#define start_ADDR	0
-/*!
-* Following define size of start script
-*/
-#define start_SIZE	19
-
-/*!
-* Following define start address of core script
-*/
-#define core_ADDR	80
-/*!
-* Following define size of core script
-*/
-#define core_SIZE	151
-
-/*!
-* Following define start address of common script
-*/
-#define common_ADDR	231
-/*!
-* Following define size of common script
-*/
-#define common_SIZE	330
-
-/*!
-* Following define start address of ap_2_ap script
-*/
-#define ap_2_ap_ADDR	561
-/*!
-* Following define size of ap_2_ap script
-*/
-#define ap_2_ap_SIZE	41
-
-/*!
-* Following define start address of app_2_mcu script
-*/
-#define app_2_mcu_ADDR	602
-/*!
-* Following define size of app_2_mcu script
-*/
-#define app_2_mcu_SIZE	64
-
-/*!
-* Following define start address of mcu_2_app script
-*/
-#define mcu_2_app_ADDR	666
-/*!
-* Following define size of mcu_2_app script
-*/
-#define mcu_2_app_SIZE	70
-
-/*!
-* Following define start address of uart_2_mcu script
-*/
-#define uart_2_mcu_ADDR	736
-/*!
-* Following define size of uart_2_mcu script
-*/
-#define uart_2_mcu_SIZE	75
-
-/*!
-* Following define start address of shp_2_mcu script
-*/
-#define shp_2_mcu_ADDR	811
-/*!
-* Following define size of shp_2_mcu script
-*/
-#define shp_2_mcu_SIZE	69
-
-/*!
-* Following define start address of mcu_2_shp script
-*/
-#define mcu_2_shp_ADDR	880
-/*!
-* Following define size of mcu_2_shp script
-*/
-#define mcu_2_shp_SIZE	72
-
-/*!
-* Following define start address of uartsh_2_mcu script
-*/
-#define uartsh_2_mcu_ADDR	952
-/*!
-* Following define size of uartsh_2_mcu script
-*/
-#define uartsh_2_mcu_SIZE	69
-
-/*!
-* Following define start address of mcu_2_ata script
-*/
-#define mcu_2_ata_ADDR	1021
-/*!
-* Following define size of mcu_2_ata script
-*/
-#define mcu_2_ata_SIZE	81
-
-/*!
-* Following define start address of ata_2_mcu script
-*/
-#define ata_2_mcu_ADDR	1102
-/*!
-* Following define size of ata_2_mcu script
-*/
-#define ata_2_mcu_SIZE	96
-
-/*!
-* Following define start address of burstDMA__2__burstDMA_routine script
-*/
-#define burstDMA__2__burstDMA_routine_ADDR	1198
-/*!
-* Following define size of burstDMA__2__burstDMA_routine script
-*/
-#define burstDMA__2__burstDMA_routine_SIZE	226
-
-/*!
-* Following define start address of test script
-*/
-#define test_ADDR	1424
-/*!
-* Following define size of test script
-*/
-#define test_SIZE	63
-
-/*!
-* Following define start address of dptc_dvfs script
-*/
-#define dptc_dvfs_ADDR	6144
-/*!
-* Following define size of dptc_dvfs script
-*/
-#define dptc_dvfs_SIZE	270
-
-/*!
-* Following define start address of ext_mem__ipu_ram script
-*/
-#define ext_mem__ipu_ram_ADDR	6414
-/*!
-* Following define size of ext_mem__ipu_ram script
-*/
-#define ext_mem__ipu_ram_SIZE	123
-
-/*!
-* Following define start address of marc_os_2_mcu script
-*/
-#define marc_os_2_mcu_ADDR	6537
-/*!
-* Following define size of marc_os_2_mcu script
-*/
-#define marc_os_2_mcu_SIZE	140
-
-/*!
-* Following define start address of marc_os_2_ssi2 script
-*/
-#define marc_os_2_ssi2_ADDR	6677
-/*!
-* Following define size of marc_os_2_ssi2 script
-*/
-#define marc_os_2_ssi2_SIZE	105
-
-/*!
-* Following define start address of mcu_2_marc_is script
-*/
-#define mcu_2_marc_is_ADDR	6782
-/*!
-* Following define size of mcu_2_marc_is script
-*/
-#define mcu_2_marc_is_SIZE	199
-
-/*!
-* Following define start address of ssi2_2_marc_is script
-*/
-#define ssi2_2_marc_is_ADDR	6981
-/*!
-* Following define size of ssi2_2_marc_is script
-*/
-#define ssi2_2_marc_is_SIZE	109
-
-/*!
-* Following define the start address of sdma ram
-*/
-
-#define RAM_CODE_START_ADDR	6144
-/*!
-* Following define the size of sdma ram
-*/
-#define RAM_CODE_SIZE	946
-
-/*!
-* This function returns buffer that holds the image of SDMA RAM
-* This is required to start on a 4-byte aligned boundary on some platforms
-* for SDMA to work properly.
-*
-* @return pointer to buffer that holds the image of SDMA RAM
-*/
-
-__attribute__ ((__aligned__(4)))
-#ifndef CONFIG_XIP_KERNEL
-const
-#endif
-static short sdma_code[] = {
-	0xc0eb, 0x7d70, 0x0800, 0x0970, 0x0111, 0x5111, 0x5ac1, 0x5bc9,
-	0x028e, 0xc0fd, 0x068a, 0x7c66, 0x5dd9, 0x5ce1, 0x0bff, 0x0311,
-	0x1bff, 0x03bc, 0x5bd1, 0x1a5c, 0x6ac3, 0x63c8, 0x0363, 0x7c05,
-	0x036f, 0x7d27, 0x0374, 0x7c76, 0x9874, 0xd907, 0x3c06, 0x4c00,
-	0x7df7, 0x028f, 0x1a04, 0x6a20, 0x620b, 0x6f20, 0x301f, 0x00aa,
-	0x0462, 0x7c04, 0x4a00, 0x7d0b, 0x2001, 0x9837, 0x048a, 0x620b,
-	0x2201, 0x1c01, 0x1801, 0x02dc, 0x7d02, 0x301f, 0x00aa, 0x048f,
-	0x1c04, 0x6c04, 0x0488, 0x3c1f, 0x6c2b, 0x0045, 0x028e, 0x1a5c,
-	0x9818, 0x058f, 0x1d0c, 0x6d20, 0x650b, 0x007d, 0x7c01, 0x1d08,
-	0x007c, 0x7c01, 0x1d04, 0x6d20, 0x650b, 0x0488, 0x3c1f, 0x0417,
-	0x0417, 0x0417, 0x0417, 0x059c, 0x6d20, 0x028e, 0x1a34, 0x6ad7,
-	0x0488, 0x0804, 0x7802, 0x650b, 0x6dc8, 0x008c, 0x1a28, 0x6ad7,
-	0x63c8, 0x034c, 0x6bc8, 0x54d1, 0x4c00, 0x7d06, 0x0065, 0x7c02,
-	0x0101, 0x0025, 0x0400, 0x9814, 0x52c1, 0x53c9, 0x54e1, 0x0453,
-	0xc108, 0x7d95, 0x0200, 0x9800, 0x55d9, 0x6d04, 0x54d1, 0x058a,
-	0x2508, 0x6dc7, 0x0373, 0x7c03, 0x65c8, 0x6d0b, 0x2408, 0x0372,
-	0x7c04, 0x65c8, 0x6d0b, 0x2408, 0x9889, 0x6cce, 0x65c8, 0x6d0a,
-	0x2404, 0x6d28, 0x6504, 0x5dd9, 0x5cd1, 0x6ad7, 0x6ae3, 0x63c8,
-	0x0334, 0x6bc8, 0x0370, 0x7cad, 0x0c60, 0x0411, 0x04bb, 0x4c00,
-	0x7da8, 0x0410, 0x1c30, 0x0410, 0x04bb, 0x046d, 0x7d0a, 0x047d,
-	0x7c03, 0x047c, 0x7c01, 0x9841, 0x003b, 0x003a, 0x0039, 0x0058,
-	0x98b8, 0x047d, 0x7d03, 0x047c, 0x7d01, 0x9841, 0x005b, 0xd8fc,
-	0x1d18, 0x6d20, 0x650b, 0x0510, 0x003a, 0x0039, 0x0038, 0x00ad,
-	0xd907, 0x0c30, 0x0410, 0x04bb, 0x003c, 0x003d, 0x00ac, 0xd8fc,
-	0x007b, 0x7c04, 0x003d, 0x003c, 0x1d0c, 0x98d9, 0x048f, 0x1c14,
-	0x6c20, 0x640b, 0x4401, 0x7d04, 0x005d, 0x005c, 0x1d0c, 0x98d9,
-	0x0310, 0x3b30, 0x4b30, 0x7d01, 0x1b10, 0x0310, 0x003d, 0x003c,
-	0x00ab, 0x6ad7, 0x63c8, 0x6d20, 0x650b, 0x0560, 0x7d03, 0x005e,
-	0xd8f0, 0x9841, 0x003e, 0x0c80, 0x0410, 0x0394, 0xd8f0, 0x640b,
-	0x037f, 0x7d02, 0x1a14, 0x98ed, 0x1a0c, 0x6ad7, 0x6cc8, 0x9841,
-	0x0c7f, 0x0410, 0x03b4, 0x04b8, 0x03ac, 0x640b, 0x6bc8, 0x028e,
-	0x1a04, 0x6ad7, 0x6cc8, 0x0006, 0x058f, 0x1d08, 0x6d20, 0x650b,
-	0x007d, 0x7c01, 0x1d38, 0x007c, 0x7c01, 0x1d1c, 0x0006, 0x048b,
-	0x042c, 0x0454, 0x042b, 0x6ad7, 0x6cc8, 0x0006, 0x0e70, 0x0611,
-	0x5616, 0xc0eb, 0x7d2a, 0x5ade, 0x008e, 0xc0fd, 0x7c26, 0x5be0,
-	0x5ef0, 0x5ce8, 0x0688, 0x08ff, 0x0011, 0x28ff, 0x00bc, 0x53f6,
-	0x05df, 0x7d0b, 0x6dc5, 0x03df, 0x7d03, 0x6bd5, 0xd95d, 0x9939,
-	0x6b05, 0xc50d, 0x7e27, 0x7f29, 0x9939, 0x6d01, 0x03df, 0x7d05,
-	0x6bd5, 0xc537, 0x7e18, 0x7f1a, 0x9939, 0x6b05, 0xc4ae, 0x7e07,
-	0x7f06, 0x52de, 0x53e6, 0xc108, 0x7dd7, 0x0200, 0x9911, 0x0007,
-	0x6004, 0x680c, 0x53f6, 0x028e, 0x00a3, 0xc205, 0x048b, 0x0498,
-	0x0454, 0x068a, 0x9939, 0x0207, 0x680c, 0x6ddf, 0x0107, 0x68ff,
-	0x60d0, 0x9942, 0x0207, 0x68ff, 0x6d28, 0x0107, 0x6004, 0x680c,
-	0x9942, 0x0007, 0x68ff, 0x60d0, 0x9942, 0x0288, 0x03a5, 0x3b03,
-	0x3d03, 0x4d00, 0x7d0a, 0x0804, 0x00a5, 0x00da, 0x7d1a, 0x02a0,
-	0x7b01, 0x65d8, 0x7eee, 0x65ff, 0x7eec, 0x0804, 0x02d0, 0x7d11,
-	0x4b00, 0x7c0f, 0x008a, 0x3003, 0x6dcf, 0x6bdf, 0x0015, 0x0015,
-	0x7b02, 0x65d8, 0x0000, 0x7edd, 0x63ff, 0x7edb, 0x3a03, 0x6dcd,
-	0x6bdd, 0x008a, 0x7b02, 0x65d8, 0x0000, 0x7ed3, 0x65ff, 0x7ed1,
-	0x0006, 0xdb37, 0x52fb, 0x02b9, 0x4a00, 0x7c03, 0x0400, 0xdb3e,
-	0x998a, 0x0901, 0x4e00, 0x7d4a, 0xd9f9, 0x0901, 0x4a00, 0x7d50,
-	0xda08, 0x0901, 0x48ff, 0x7d4c, 0x018e, 0x1904, 0x0d00, 0x05c8,
-	0x7d03, 0x1d01, 0x1904, 0x999f, 0x6920, 0x640b, 0x0902, 0x4c00,
-	0x7d3f, 0xdb06, 0x018c, 0x56ea, 0xc188, 0x0489, 0x57fa, 0x50d2,
-	0x55da, 0x00a5, 0x00df, 0x7c01, 0x008f, 0x51e2, 0x0517, 0x0517,
-	0x0599, 0x6d04, 0x0188, 0x7802, 0x5306, 0x6b0b, 0x6b28, 0x0806,
-	0x7e2a, 0x7f29, 0x56f2, 0x55da, 0x0599, 0x038c, 0x1b0e, 0x6b04,
-	0x6d2a, 0x50d2, 0x05c8, 0x7c08, 0x038c, 0x1b01, 0x0806, 0x6b04,
-	0x6829, 0x0101, 0xdb3e, 0x9989, 0x56f2, 0x51c2, 0xd9f9, 0x4a00,
-	0x7cbf, 0xdb3e, 0x9989, 0x0300, 0xdb3e, 0x9989, 0x5313, 0x58c3,
-	0x0101, 0x0707, 0x0801, 0x6e04, 0x682a, 0x0300, 0xdb3e, 0x9989,
-	0x6e04, 0x692a, 0x99db, 0x038c, 0x1b10, 0x6b04, 0x692a, 0x038c,
-	0x1b01, 0x0d01, 0x6b04, 0x6d29, 0x99db, 0x0a02, 0x0006, 0x0801,
-	0x0006, 0x018e, 0x1910, 0x6920, 0x650b, 0x0903, 0x4d00, 0x7de8,
-	0x1d34, 0x5205, 0x0212, 0x0212, 0x0212, 0x0d07, 0x02bd, 0x0006,
-	0x0800, 0x0b01, 0x018b, 0x01ba, 0x4900, 0x7c05, 0x0317, 0x1801,
-	0x4804, 0x7cf8, 0x08ff, 0x02b3, 0x0006, 0xdb37, 0x522b, 0x02b9,
-	0x4a00, 0x7c03, 0x0400, 0xdb3e, 0x9a16, 0x0901, 0x4e00, 0x7d48,
-	0x0388, 0xd9f9, 0x0901, 0x4a00, 0x7d4d, 0x0903, 0x008b, 0x0c00,
-	0x00d4, 0x7d48, 0x0c03, 0x00dc, 0x7d45, 0x018e, 0x1904, 0x0d00,
-	0x05c8, 0x7d03, 0x1d01, 0x1904, 0x9a30, 0x6920, 0x640b, 0x0902,
-	0x4c00, 0x7d38, 0xdb06, 0x57fa, 0x50d2, 0x55da, 0x00a5, 0x00df,
-	0x7c01, 0x008f, 0x018c, 0x56ea, 0xc188, 0x038e, 0x56e2, 0xc188,
-	0x058e, 0x0489, 0x0788, 0x7802, 0x5103, 0x5905, 0x0906, 0x7e25,
-	0x7f24, 0x56f2, 0x55da, 0x059f, 0x038c, 0x1b0e, 0x6b04, 0x6d2a,
-	0x50d2, 0x05c8, 0x7c08, 0x038c, 0x1b01, 0x0806, 0x6b04, 0x6829,
-	0x0101, 0xdb3e, 0x9a15, 0xdb3e, 0x9a16, 0x0300, 0xdb3e, 0x9a15,
-	0x5313, 0x59c3, 0x0101, 0x0707, 0x0801, 0x6e04, 0x682a, 0x0300,
-	0xdb3e, 0x9a15, 0x6e04, 0x692a, 0x9a65, 0x038c, 0x1b10, 0x6b04,
-	0x692a, 0x9a65, 0x0a02, 0x0006, 0x0801, 0x0006, 0xdb37, 0x52fb,
-	0x02b9, 0x4a00, 0x7c03, 0x0400, 0xdb3e, 0x9a7f, 0x0901, 0x4e00,
-	0x7d46, 0xdaea, 0x0901, 0x4a00, 0x7d4c, 0xdaf9, 0x48ff, 0x7d49,
-	0x018e, 0x1904, 0x0d00, 0x05c8, 0x7d03, 0x1d01, 0x1904, 0x9a93,
-	0x6920, 0x640b, 0x0902, 0x4c00, 0x7d3c, 0xdb06, 0x018c, 0x56ea,
-	0xc188, 0x0489, 0x57fa, 0x50d2, 0x55da, 0x00a5, 0x00df, 0x7c01,
-	0x008f, 0x51e2, 0x0517, 0x0517, 0x0599, 0x0188, 0x6d20, 0x7802,
-	0x630b, 0x5b06, 0x0806, 0x7e28, 0x7f27, 0x56f2, 0x55da, 0x0599,
-	0x038c, 0x1b0e, 0x6b04, 0x6d2a, 0x50d2, 0x05c8, 0x7c08, 0x038c,
-	0x1b01, 0x0806, 0x6b04, 0x6829, 0x0101, 0xdb3e, 0x9a7e, 0xdaea,
-	0x4a00, 0x7cc3, 0xdb3e, 0x9a7e, 0x0300, 0xdb3e, 0x9a7e, 0x5313,
-	0x59c3, 0x0101, 0x0707, 0x0801, 0x6e04, 0x682a, 0x0300, 0xdb3e,
-	0x9a7e, 0x6e04, 0x692a, 0x9acc, 0x038c, 0x1b10, 0x6b04, 0x692a,
-	0x038c, 0x1b01, 0x0d01, 0x6b04, 0x6d29, 0x9acc, 0x0a02, 0x0006,
-	0x0801, 0x0006, 0x018e, 0x1944, 0x6920, 0x650b, 0x0903, 0x4d00,
-	0x7de8, 0x1d34, 0x018d, 0x0dff, 0x0511, 0x1dff, 0x5201, 0x02bd,
-	0x0006, 0x0800, 0x0b01, 0x018b, 0x01ba, 0x4900, 0x7c05, 0x0317,
-	0x1801, 0x4810, 0x7cf8, 0x08ff, 0x02b3, 0x0006, 0x038c, 0x1b00,
-	0x6b20, 0x6509, 0x0901, 0x4d00, 0x7dcf, 0x038c, 0x1b08, 0x6b20,
-	0x650b, 0x0902, 0x4d00, 0x7dc8, 0x0a70, 0x0211, 0x5212, 0x5de2,
-	0x038c, 0x1b04, 0x6b20, 0x650b, 0x0903, 0x4d00, 0x7dbd, 0x5dea,
-	0x038c, 0x1b02, 0x6b20, 0x650a, 0x0905, 0x4d00, 0x7db5, 0x5dfa,
-	0x038c, 0x1b0c, 0x6b20, 0x650a, 0x5dd2, 0x038c, 0x1b0e, 0x6b20,
-	0x650a, 0x5dda, 0x0904, 0x53d2, 0x05db, 0x7da6, 0x0006, 0x0b70,
-	0x0311, 0x5213, 0x58c2, 0x59ca, 0x5ef2, 0x0006, 0x0b70, 0x0311,
-	0x5213, 0x50c2, 0x51ca, 0x56f2, 0x0006, 0xdb37, 0x522b, 0x02b9,
-	0x4a00, 0x7c03, 0x0400, 0xdb3e, 0x9b46, 0x0901, 0x4e00, 0x7d47,
-	0xdaea, 0x0901, 0x4a00, 0x7d4d, 0xdb3e, 0x0903, 0x0c00, 0x00d4,
-	0x7d48, 0x0c10, 0x00dc, 0x7d45, 0x018e, 0x1904, 0x0d00, 0x05c8,
-	0x7d03, 0x1d01, 0x1904, 0x9b5f, 0x6920, 0x640b, 0x0902, 0x4c00,
-	0x7d38, 0xdb06, 0x57fa, 0x50d2, 0x55da, 0x00a5, 0x00df, 0x7c01,
-	0x008f, 0x018c, 0x56ea, 0xc188, 0x038e, 0x56e2, 0xc188, 0x058e,
-	0x0489, 0x0788, 0x7802, 0x5105, 0x5903, 0x0906, 0x7e25, 0x7f24,
-	0x56f2, 0x55da, 0x059f, 0x038c, 0x1b0e, 0x6b04, 0x6d2a, 0x50d2,
-	0x05c8, 0x7c08, 0x038c, 0x1b01, 0x0806, 0x6b04, 0x6829, 0x0101,
-	0xdb3e, 0x9b45, 0xdb3e, 0x9b46, 0x0300, 0xdb3e, 0x9b45, 0x5313,
-	0x59c3, 0x0101, 0x0707, 0x0801, 0x6e04, 0x682a, 0x0300, 0xdb3e,
-	0x9b45, 0x6e04, 0x692a, 0x9b94, 0x038c, 0x1b10, 0x6b04, 0x692a,
-	0x038c, 0x1b01, 0x0d01, 0x6b04, 0x6d29, 0x9b94, 0x0a02, 0x0006,
-	0x0801, 0x0006, 0x0006
-};
-#endif
diff --git a/arch/arm/mach-mx33/serial.c b/arch/arm/mach-mx33/serial.c
deleted file mode 100644
index fe19f4c..0000000
--- a/arch/arm/mach-mx33/serial.c
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-/*!
- * @file serial.c
- *
- * @brief This file contains the UART initiliazation.
- *
- * @ingroup System
- */
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/serial.h>
-#include <asm/hardware.h>
-#include <asm/arch/mxc_uart.h>
-#include <asm/arch/spba.h>
-#include "serial.h"
-
-#if defined(CONFIG_SERIAL_MXC) || defined(CONFIG_SERIAL_MXC_MODULE)
-
-/*!
- * This is an array where each element holds information about a UART port,
- * like base address of the UART, interrupt numbers etc. This structure is
- * passed to the serial_core.c file. Based on which UART is used, the core file
- * passes back the appropriate port structure as an argument to the control
- * functions.
- */
-static uart_mxc_port mxc_ports[] = {
-	[0] = {
-	       .port = {
-			.membase = (void *)IO_ADDRESS(UART1_BASE_ADDR),
-			.mapbase = UART1_BASE_ADDR,
-			.iotype = SERIAL_IO_MEM,
-			.irq = UART1_INT1,
-			.fifosize = 32,
-			.flags = ASYNC_BOOT_AUTOCONF,
-			.line = 0,
-			},
-	       .ints_muxed = UART1_MUX_INTS,
-	       .irqs = {UART1_INT2, UART1_INT3},
-	       .mode = UART1_MODE,
-	       .ir_mode = UART1_IR,
-	       .enabled = UART1_ENABLED,
-	       .hardware_flow = UART1_HW_FLOW,
-	       .cts_threshold = UART1_UCR4_CTSTL,
-	       .dma_enabled = UART1_DMA_ENABLE,
-	       .dma_rxbuf_size = UART1_DMA_RXBUFSIZE,
-	       .rx_threshold = UART1_UFCR_RXTL,
-	       .tx_threshold = UART1_UFCR_TXTL,
-	       .shared = UART1_SHARED_PERI,
-	       .clock_id = UART1_BAUD,
-	       .dma_tx_id = MXC_DMA_UART1_TX,
-	       .dma_rx_id = MXC_DMA_UART1_RX,
-	       .rxd_mux = MXC_UART_RXDMUX,
-	       },
-	[1] = {
-	       .port = {
-			.membase = (void *)IO_ADDRESS(UART2_BASE_ADDR),
-			.mapbase = UART2_BASE_ADDR,
-			.iotype = SERIAL_IO_MEM,
-			.irq = UART2_INT1,
-			.fifosize = 32,
-			.flags = ASYNC_BOOT_AUTOCONF,
-			.line = 1,
-			},
-	       .ints_muxed = UART2_MUX_INTS,
-	       .irqs = {UART2_INT2, UART2_INT3},
-	       .mode = UART2_MODE,
-	       .ir_mode = UART2_IR,
-	       .enabled = UART2_ENABLED,
-	       .hardware_flow = UART2_HW_FLOW,
-	       .cts_threshold = UART2_UCR4_CTSTL,
-	       .dma_enabled = UART2_DMA_ENABLE,
-	       .dma_rxbuf_size = UART2_DMA_RXBUFSIZE,
-	       .rx_threshold = UART2_UFCR_RXTL,
-	       .tx_threshold = UART2_UFCR_TXTL,
-	       .shared = UART2_SHARED_PERI,
-	       .clock_id = UART2_BAUD,
-	       .dma_tx_id = MXC_DMA_UART2_TX,
-	       .dma_rx_id = MXC_DMA_UART2_RX,
-	       .rxd_mux = MXC_UART_RXDMUX,
-	       },
-	[2] = {
-	       .port = {
-			.membase = (void *)IO_ADDRESS(UART3_BASE_ADDR),
-			.mapbase = UART3_BASE_ADDR,
-			.iotype = SERIAL_IO_MEM,
-			.irq = UART3_INT1,
-			.fifosize = 32,
-			.flags = ASYNC_BOOT_AUTOCONF,
-			.line = 2,
-			},
-	       .ints_muxed = UART3_MUX_INTS,
-	       .irqs = {UART3_INT2, UART3_INT3},
-	       .mode = UART3_MODE,
-	       .ir_mode = UART3_IR,
-	       .enabled = UART3_ENABLED,
-	       .hardware_flow = UART3_HW_FLOW,
-	       .cts_threshold = UART3_UCR4_CTSTL,
-	       .dma_enabled = UART3_DMA_ENABLE,
-	       .dma_rxbuf_size = UART3_DMA_RXBUFSIZE,
-	       .rx_threshold = UART3_UFCR_RXTL,
-	       .tx_threshold = UART3_UFCR_TXTL,
-	       .shared = 0,	/*TODO::UART3_SHARED_PERI, */
-	       .clock_id = UART3_BAUD,
-	       .dma_tx_id = MXC_DMA_UART3_TX,
-	       .dma_rx_id = MXC_DMA_UART3_RX,
-	       .rxd_mux = MXC_UART_RXDMUX,
-	       },
-#if UART4_ENABLED == 1
-	[3] = {
-	       .port = {
-			.membase = (void *)IO_ADDRESS(UART4_BASE_ADDR),
-			.mapbase = UART4_BASE_ADDR,
-			.iotype = SERIAL_IO_MEM,
-			.irq = UART4_INT1,
-			.fifosize = 32,
-			.flags = ASYNC_BOOT_AUTOCONF,
-			.line = 3,
-			},
-	       .ints_muxed = UART4_MUX_INTS,
-	       .irqs = {UART4_INT2, UART4_INT3},
-	       .mode = UART4_MODE,
-	       .ir_mode = UART4_IR,
-	       .enabled = UART4_ENABLED,
-	       .hardware_flow = UART4_HW_FLOW,
-	       .cts_threshold = UART4_UCR4_CTSTL,
-	       .dma_enabled = UART4_DMA_ENABLE,
-	       .dma_rxbuf_size = UART4_DMA_RXBUFSIZE,
-	       .rx_threshold = UART4_UFCR_RXTL,
-	       .tx_threshold = UART4_UFCR_TXTL,
-	       .shared = UART4_SHARED_PERI,
-	       .clock_id = UART4_BAUD,
-	       .dma_tx_id = MXC_DMA_UART4_TX,
-	       .dma_rx_id = MXC_DMA_UART4_RX,
-	       .rxd_mux = MXC_UART_RXDMUX,
-	       },
-#endif
-	[4] = {
-	       .port = {
-			.membase = (void *)IO_ADDRESS(UART5_BASE_ADDR),
-			.mapbase = UART5_BASE_ADDR,
-			.iotype = SERIAL_IO_MEM,
-			.irq = UART5_INT1,
-			.fifosize = 32,
-			.flags = ASYNC_BOOT_AUTOCONF,
-			.line = 4,
-			},
-	       .ints_muxed = UART5_MUX_INTS,
-	       .irqs = {UART5_INT2, UART5_INT3},
-	       .mode = UART5_MODE,
-	       .ir_mode = UART5_IR,
-	       .enabled = UART5_ENABLED,
-	       .hardware_flow = UART5_HW_FLOW,
-	       .cts_threshold = UART5_UCR4_CTSTL,
-	       .dma_enabled = UART5_DMA_ENABLE,
-	       .dma_rxbuf_size = UART5_DMA_RXBUFSIZE,
-	       .rx_threshold = UART5_UFCR_RXTL,
-	       .tx_threshold = UART5_UFCR_TXTL,
-	       .shared = UART5_SHARED_PERI,
-	       .clock_id = UART5_BAUD,
-	       .dma_tx_id = MXC_DMA_UART5_TX,
-	       .dma_rx_id = MXC_DMA_UART5_RX,
-	       .rxd_mux = MXC_UART_RXDMUX,
-	       },
-};
-
-static struct platform_device mxc_uart_device1 = {
-	.name = "mxcintuart",
-	.id = 0,
-	.dev = {
-		.platform_data = &mxc_ports[0],
-		},
-};
-
-static struct platform_device mxc_uart_device2 = {
-	.name = "mxcintuart",
-	.id = 1,
-	.dev = {
-		.platform_data = &mxc_ports[1],
-		},
-};
-
-static struct platform_device mxc_uart_device3 = {
-	.name = "mxcintuart",
-	.id = 2,
-	.dev = {
-		.platform_data = &mxc_ports[2],
-		},
-};
-
-#if UART4_ENABLED == 1
-static struct platform_device mxc_uart_device4 = {
-	.name = "mxcintuart",
-	.id = 3,
-	.dev = {
-		.platform_data = &mxc_ports[3],
-		},
-};
-#endif
-
-static struct platform_device mxc_uart_device5 = {
-	.name = "mxcintuart",
-	.id = 4,
-	.dev = {
-		.platform_data = &mxc_ports[4],
-		},
-};
-
-static int __init mxc_init_uart(void)
-{
-	/* Register all the MXC UART platform device structures */
-	platform_device_register(&mxc_uart_device1);
-	platform_device_register(&mxc_uart_device2);
-
-	/* Grab ownership of shared UARTs 3 and 4, only when enabled */
-#if UART3_ENABLED == 1
-#if UART3_DMA_ENABLE == 1
-	spba_take_ownership(UART3_SHARED_PERI, (SPBA_MASTER_A | SPBA_MASTER_C));
-#else
-	spba_take_ownership(UART3_SHARED_PERI, SPBA_MASTER_A);
-#endif				/* UART3_DMA_ENABLE */
-	platform_device_register(&mxc_uart_device3);
-#endif				/* UART3_ENABLED */
-
-#if UART4_ENABLED == 1
-	platform_device_register(&mxc_uart_device4);
-#endif				/* UART4_ENABLED */
-
-#if UART5_ENABLED == 1
-	platform_device_register(&mxc_uart_device5);
-#endif				/* UART5_ENABLED */
-	return 0;
-}
-
-#else
-static int __init mxc_init_uart(void)
-{
-	return 0;
-}
-#endif
-
-arch_initcall(mxc_init_uart);
diff --git a/arch/arm/mach-mx33/serial.h b/arch/arm/mach-mx33/serial.h
deleted file mode 100644
index 425f614..0000000
--- a/arch/arm/mach-mx33/serial.h
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#ifndef __ARCH_ARM_MACH_MX33_SERIAL_H__
-#define __ARCH_ARM_MACH_MX33_SERIAL_H__
-
-#include <asm/arch/mxc_uart.h>
-
-/* UART 1 configuration */
-/*!
- * This option allows to choose either an interrupt-driven software controlled
- * hardware flow control (set this option to 0) or hardware-driven hardware
- * flow control (set this option to 1).
- */
-#define UART1_HW_FLOW           1
-/*!
- * This specifies the threshold at which the CTS pin is deasserted by the
- * RXFIFO. Set this value in Decimal to anything from 0 to 32 for
- * hardware-driven hardware flow control. Read the HW spec while specifying
- * this value. When using interrupt-driven software controlled hardware
- * flow control set this option to -1.
- */
-#define UART1_UCR4_CTSTL        16
-/*!
- * This is option to enable (set this option to 1) or disable DMA data transfer
- */
-#define UART1_DMA_ENABLE        0
-/*!
- * Specify the size of the DMA receive buffer. The minimum buffer size is 512
- * bytes. The buffer size should be a multiple of 256.
- */
-#define UART1_DMA_RXBUFSIZE     1024
-/*!
- * Specify the MXC UART's Receive Trigger Level. This controls the threshold at
- * which a maskable interrupt is generated by the RxFIFO. Set this value in
- * Decimal to anything from 0 to 32. Read the HW spec while specifying this
- * value.
- */
-#define UART1_UFCR_RXTL         16
-/*!
- * Specify the MXC UART's Transmit Trigger Level. This controls the threshold at
- * which a maskable interrupt is generated by the TxFIFO. Set this value in
- * Decimal to anything from 0 to 32. Read the HW spec while specifying this
- * value.
- */
-#define UART1_UFCR_TXTL         16
-/* UART 2 configuration */
-#define UART2_HW_FLOW           0
-#define UART2_UCR4_CTSTL        -1
-#define UART2_DMA_ENABLE        0
-#define UART2_DMA_RXBUFSIZE     512
-#define UART2_UFCR_RXTL         16
-#define UART2_UFCR_TXTL         16
-/* UART 3 configuration */
-#define UART3_HW_FLOW           1
-#define UART3_UCR4_CTSTL        16
-#define UART3_DMA_ENABLE        1
-#define UART3_DMA_RXBUFSIZE     1024
-#define UART3_UFCR_RXTL         16
-#define UART3_UFCR_TXTL         16
-/* UART 4 configuration */
-#define UART4_HW_FLOW           1
-#define UART4_UCR4_CTSTL        16
-#define UART4_DMA_ENABLE        0
-#define UART4_DMA_RXBUFSIZE     512
-#define UART4_UFCR_RXTL         16
-#define UART4_UFCR_TXTL         16
-/* UART 5 configuration */
-#define UART5_HW_FLOW           1
-#define UART5_UCR4_CTSTL        16
-#define UART5_DMA_ENABLE        0
-#define UART5_DMA_RXBUFSIZE     512
-#define UART5_UFCR_RXTL         16
-#define UART5_UFCR_TXTL         16
-/*
- * UART Chip level Configuration that a user may not have to edit. These
- * configuration vary depending on how the UART module is integrated with
- * the ARM core
- */
-/*
- * Is the MUXED interrupt output sent to the ARM core
- */
-#define INTS_NOTMUXED           0
-#define INTS_MUXED              1
-/* UART 1 configuration */
-/*!
- * This define specifies whether the muxed ANDed interrupt line or the
- * individual interrupts from the UART port is integrated with the ARM core.
- * There exists a define like this for each UART port. Valid values that can
- * be used are \b INTS_NOTMUXED or \b INTS_MUXED.
- */
-#define UART1_MUX_INTS          INTS_MUXED
-/*!
- * This define specifies the transmitter interrupt number or the interrupt
- * number of the ANDed interrupt in case the interrupts are muxed. There exists
- * a define like this for each UART port.
- */
-#define UART1_INT1              INT_UART1
-/*!
- * This define specifies the receiver interrupt number. If the interrupts of
- * the UART are muxed, then we specify here a dummy value -1. There exists a
- * define like this for each UART port.
- */
-#define UART1_INT2              -1
-/*!
- * This specifies the master interrupt number. If the interrupts of the UART
- * are muxed, then we specify here a dummy value of -1. There exists a define
- * like this for each UART port.
- */
-#define UART1_INT3              -1
-/*!
- * This specifies if the UART is a shared peripheral. It holds the shared
- * peripheral number if it is shared or -1 if it is not shared. There exists
- * a define like this for each UART port.
- */
-#define UART1_SHARED_PERI       -1
-/* UART 2 configuration */
-#define UART2_MUX_INTS          INTS_MUXED
-#define UART2_INT1              INT_UART2
-#define UART2_INT2              -1
-#define UART2_INT3              -1
-#define UART2_SHARED_PERI       -1
-/* UART 3 configuration */
-#define UART3_MUX_INTS          INTS_MUXED
-#define UART3_INT1              INT_UART3
-#define UART3_INT2              -1
-#define UART3_INT3              -1
-#define UART3_SHARED_PERI       SPBA_UART3
-/* UART 4 configuration */
-#define UART4_MUX_INTS          INTS_MUXED
-#define UART4_INT1              INT_UART4
-#define UART4_INT2              -1
-#define UART4_INT3              -1
-#define UART4_SHARED_PERI       -1
-/* UART 5 configuration */
-#define UART5_MUX_INTS          INTS_MUXED
-#define UART5_INT1              INT_UART5
-#define UART5_INT2              -1
-#define UART5_INT3              -1
-#define UART5_SHARED_PERI       -1
-
-#endif				/* __ARCH_ARM_MACH_MX33_SERIAL_H__ */
diff --git a/arch/arm/mach-mx33/system.c b/arch/arm/mach-mx33/system.c
deleted file mode 100644
index ea36e28..0000000
--- a/arch/arm/mach-mx33/system.c
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 1999 ARM Limited
- * Copyright (C) 2000 Deep Blue Solutions Ltd
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <asm/io.h>
-#include <asm/hardware.h>
-#include <asm/proc-fns.h>
-#include <asm/system.h>
-#include "crm_regs.h"
-
-/*!
- * @defgroup MSL Machine Specific Layer (MSL)
- */
-
-/*!
- * @defgroup System System-wide Misc Files for MSL
- * @ingroup MSL
- */
-
-/*!
- * @file system.h
- * @brief This file contains idle and reset functions.
- *
- * @ingroup System
- */
-
-/*!
- * This function puts the CPU into idle mode. It is called by default_idle()
- * in process.c file.
- */
-void arch_idle(void)
-{
-	/*TODO:: fix me to add code to verify the condiction of calling cpu_do_idle */
-}
-
-/*
- * This function resets the system. It is called by machine_restart().
- *
- * @param  mode         indicates different kinds of resets
- */
-void arch_reset(char mode)
-{
-	/* Assert Watchdog Reset signal */
-	mxc_wd_reset();
-}
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
index a22020a..495ce3d 100644
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -9,9 +9,7 @@ ifneq ($(CONFIG_ARCH_MX21)$(CONFIG_ARCH_MX27),y)
 obj-y += time.o spba.o sdma/
 endif
 
-ifneq ($(CONFIG_ARCH_MX33),y)
 obj-y += irq.o
-endif
 
 obj-$(CONFIG_ARCH_MX21) += dma_mx2.o
 obj-$(CONFIG_ARCH_MX27) += dma_mx2.o usb_common.o
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index b779014..c91a9ea 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -415,7 +415,6 @@ config MXC_MU
 	bool "MXC Messaging Unit Driver"
 	depends on ARCH_MXC
 	depends on !ARCH_MX3
-	depends on !ARCH_MX33
 	depends on !ARCH_MX27
 	depends on !ARCH_MX21
 	select INPUT
@@ -429,7 +428,6 @@ config MXC_IPC
 	depends on MXC_MU && MXC_SDMA_API
 	depends on ARCH_MXC
 	depends on !ARCH_MX3
-	depends on !ARCH_MX33
 	depends on !ARCH_MX27
 	depends on !ARCH_MX21
 	default y
@@ -442,7 +440,6 @@ config MXC_SUPER_GEM
 	depends on MXC_SDMA_API
 	depends on ARCH_MXC
 	depends on !ARCH_MX3
-	depends on !ARCH_MX33
 	depends on !ARCH_MX27
 	depends on !ARCH_MX21
 	default n
@@ -453,7 +450,6 @@ config MXC_SDMA_TTY
 	tristate "MXC SDMA TTY Driver"
 	depends on ARCH_MXC && MXC_SDMA_API
 	depends on !ARCH_MX3
-	depends on !ARCH_MX33
 	depends on !ARCH_MX21
 	depends on !ARCH_MX27
 	select INPUT
diff --git a/drivers/ide/Kconfig b/drivers/ide/Kconfig
index 94e1958..6f455ae 100644
--- a/drivers/ide/Kconfig
+++ b/drivers/ide/Kconfig
@@ -889,7 +889,7 @@ config BLK_DEV_IDE_BAST
 
 config BLK_DEV_IDE_MXC
         tristate "Freescale MXC IDE support"
-        depends on ARM && ( ARCH_MX3 || ARCH_MX27 || ARCH_MX33)
+        depends on ARM && ( ARCH_MX3 || ARCH_MX27 )
         help
           Say Y here if you want to support the IDE controller on the
           Freescale iMX3 processor.
diff --git a/drivers/mxc/security/sahara2/include/sah_kernel.h b/drivers/mxc/security/sahara2/include/sah_kernel.h
index 994ff68..7f82b91 100644
--- a/drivers/mxc/security/sahara2/include/sah_kernel.h
+++ b/drivers/mxc/security/sahara2/include/sah_kernel.h
@@ -27,8 +27,7 @@
 #if defined(__KERNEL__)
 
 #if defined(CONFIG_ARCH_MXC91321) || defined(CONFIG_ARCH_MXC91231)     \
-    || defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX33)          \
-    || defined(CONFIG_ARCH_MXC92323)
+    || defined(CONFIG_ARCH_MX27)  || defined(CONFIG_ARCH_MXC92323)
 #include <asm/arch/hardware.h>
 #define SAHA_BASE_ADDR SAHARA_BASE_ADDR
 #define SAHARA_IRQ     MXC_INT_SAHARA
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 323f5e7..8d92dff 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -1808,7 +1808,7 @@ config 68360_ENET
 
 config FEC
 	tristate "FEC ethernet controller"
-	depends on M523x || M527x || M5272 || M528x || M520x || ARCH_MX27 || ARCH_MX33
+	depends on M523x || M527x || M5272 || M528x || M520x || ARCH_MX27 
 	help
 	  Say Y here if you want to use the built-in 10/100 Fast ethernet
 	  controller on some Motorola/Freescale processors.
diff --git a/include/asm-arm/arch-mxc/board-mx33ads.h b/include/asm-arm/arch-mxc/board-mx33ads.h
deleted file mode 100644
index 6ff74a1..0000000
--- a/include/asm-arm/arch-mxc/board-mx33ads.h
+++ /dev/null
@@ -1,365 +0,0 @@
-/*
- * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#ifndef __ASM_ARCH_MXC_BOARD_MX33ADS_H__
-#define __ASM_ARCH_MXC_BOARD_MX33ADS_H__
-
-/*
- * Include Files
- */
-#include <asm/arch/board.h>
-#include <asm/arch/mx33.h>
-
-/* Start of physical RAM */
-#define PHYS_OFFSET	        (SDRAM_BASE_ADDR)
-
-/* Size of contiguous memory for DMA and other h/w blocks */
-#define CONSISTENT_DMA_SIZE	SZ_8M
-
-/* I2C configuration */
-/*!
- * This defines the number of I2C modules in the MXC platform
- * Defined as 1, as MC13783 on ADS uses the other pins
- */
-#define I2C_NR                  1
-/*!
- * This define specifies the frequency divider value to be written into
- * the I2C \b IFDR register.
- */
-#define I2C1_FRQ_DIV            0x17
-
-/*!
- * @name MXC UART EVB board level configurations
- */
-/*! @{ */
-/*!
- * Specify the max baudrate for the MXC UARTs for your board, do not specify a max
- * baudrate greater than 1500000. This is used while specifying the UART Power
- * management constraints.
- */
-#define MAX_UART_BAUDRATE       1500000
-/*!
- * Specifies if the Irda transmit path is inverting
- */
-#define MXC_IRDA_TX_INV         0
-/*!
- * Specifies if the Irda receive path is inverting
- */
-#define MXC_IRDA_RX_INV         0
-/* UART 1 configuration */
-/*!
- * This define specifies if the UART port is configured to be in DTE or
- * DCE mode. There exists a define like this for each UART port. Valid
- * values that can be used are \b MODE_DTE or \b MODE_DCE.
- */
-#define UART1_MODE              MODE_DCE
-/*!
- * This define specifies if the UART is to be used for IRDA. There exists a
- * define like this for each UART port. Valid values that can be used are
- * \b IRDA or \b NO_IRDA.
- */
-#define UART1_IR                NO_IRDA
-/*!
- * This define is used to enable or disable a particular UART port. If
- * disabled, the UART will not be registered in the file system and the user
- * will not be able to access it. There exists a define like this for each UART
- * port. Specify a value of 1 to enable the UART and 0 to disable it.
- */
-#define UART1_ENABLED           1
-/*! @} */
-/* UART 2 configuration */
-#define UART2_MODE              MODE_DCE
-#define UART2_IR                IRDA
-#define UART2_ENABLED           1
-/* UART 3 configuration */
-#define UART3_MODE              MODE_DTE
-#define UART3_IR                NO_IRDA
-/*TODO #define UART3_ENABLED           1 */
-#define UART3_ENABLED           0
-/* UART 4 configuration */
-#define UART4_MODE              MODE_DTE
-#define UART4_IR                NO_IRDA
-#define UART4_ENABLED           0	/* Disable UART 4 as its pins are shared with ATA */
-/* UART 5 configuration */
-#define UART5_MODE              MODE_DTE
-#define UART5_IR                NO_IRDA
-#define UART5_ENABLED           1
-
-#define MXC_LL_EXTUART_PADDR	(CS4_BASE_ADDR + 0x10000)
-#define MXC_LL_EXTUART_VADDR	CS4_IO_ADDRESS(MXC_LL_EXTUART_PADDR)
-#undef  MXC_LL_EXTUART_16BIT_BUS
-
-#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
-#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
-
-/*!
- * @name Memory Size parameters
- */
-/*! @{ */
-/*!
- * Size of SDRAM memory
- */
-#define SDRAM_MEM_SIZE          SZ_256M
-/*!
- * Size of MBX buffer memory
- */
-#define MXC_GPU_MEM_SIZE        SZ_16M
-/*!
- * Size of memory available to kernel
- */
-#define MEM_SIZE                (SDRAM_MEM_SIZE - MXC_GPU_MEM_SIZE)
-/*! @} */
-
-/*!
- * @name Keypad Configurations FIXME
- */
-/*! @{ */
-/*!
- * Maximum number of rows (0 to 7)
- */
-#define MAXROW                  8
-/*!
- * Maximum number of columns (0 to 7)
- */
-#define MAXCOL                  8
-/*! @} */
-
-/*!
- * @name PBC Controller parameters
- */
-/*! @{ */
-/*!
- * Base address of PBC controller
- */
-#define PBC_BASE_ADDRESS        IO_ADDRESS(CS4_BASE_ADDR)
-/* Offsets for the PBC Controller register */
-/*!
- * PBC Board status register offset
- */
-#define PBC_BSTAT               0x000002
-/*!
- * PBC Board control register 1 set address.
- */
-#define PBC_BCTRL1_SET          0x000004
-/*!
- * PBC Board control register 1 clear address.
- */
-#define PBC_BCTRL1_CLEAR        0x000006
-/*!
- * PBC Board control register 2 set address.
- */
-#define PBC_BCTRL2_SET          0x000008
-/*!
- * PBC Board control register 2 clear address.
- */
-#define PBC_BCTRL2_CLEAR        0x00000A
-/*!
- * PBC Board control register 3 set address.
- */
-#define PBC_BCTRL3_SET          0x00000C
-/*!
- * PBC Board control register 3 clear address.
- */
-#define PBC_BCTRL3_CLEAR        0x00000E
-/*!
- * PBC Board control register 4 set address.
- */
-#define PBC_BCTRL4_SET          0x000010
-/*!
- * PBC Board control register 4 clear address.
- */
-#define PBC_BCTRL4_CLEAR        0x000012
-/*!
- * PBC Board status register 1.
- */
-#define PBC_BSTAT1              0x000014
-/*!
- * PBC Board interrupt status register.
- */
-#define PBC_INTSTATUS           0x000016
-/*!
- * PBC Board interrupt current status register.
- */
-#define PBC_INTCURR_STATUS      0x000018
-/*!
- * PBC Interrupt mask register set address.
- */
-#define PBC_INTMASK_SET         0x00001A
-/*!
- * PBC Interrupt mask register clear address.
- */
-#define PBC_INTMASK_CLEAR       0x00001C
-
-/*!
- * External UART A.
- */
-#define PBC_SC16C652_UARTA      0x010000
-/*!
- * External UART B.
- */
-#define PBC_SC16C652_UARTB      0x010010
-/*!
- * Ethernet Controller IO base address.
- */
-#define PBC_CS8900A_IOBASE      0x020000
-/*!
- * Ethernet Controller Memory base address.
- */
-#define PBC_CS8900A_MEMBASE     0x021000
-/*!
- * Ethernet Controller DMA base address.
- */
-#define PBC_CS8900A_DMABASE     0x022000
-/*!
- * External chip select 0.
- */
-#define PBC_XCS0                0x040000
-/*!
- * LCD Display enable.
- */
-#define PBC_LCD_EN_B            0x060000
-/*!
- * Code test debug enable.
- */
-#define PBC_CODE_B              0x070000
-/*!
- * PSRAM memory select.
- */
-#define PBC_PSRAM_B             0x5000000
-
-/* PBC Board Status Register 1 bit definitions */
-#define PBC_BSTAT1_NF_DET       0x0001	/* NAND flash card. 0 = connected */
-#define PBC_BSTAT1_KP_ON        0x0002	/* KPP board. 0 = connected */
-#define PBC_BSTAT1_LS           0x0004	/* KPP:LightSense signal */
-#define PBC_BSTAT1_ATA_IOCS16   0x0008	/* ATA_IOCS16 signal */
-#define PBC_BSTAT1_ATA_CBLID    0x0010	/* ATA_CBLID signal */
-#define PBC_BSTAT1_ATA_DASP     0x0020	/* ATA_DASP signal */
-#define PBC_BSTAT1_PWR_RDY      0x0040	/* MC13783 power. 1 = ready */
-#define PBC_BSTAT1_SD1_WP       0x0080	/* 0 = SD1 card is write protected */
-#define PBC_BSTAT1_SD2_WP       0x0100	/* 0 = SD2 card is write protected */
-#define PBC_BSTAT1_FS1          0x0200	/* KPP:FlipSense1 signal */
-#define PBC_BSTAT1_FS2          0x0400	/* KPP:FlipSense2 signal */
-#define PBC_BSTAT1_PTT          0x0800	/* KPP:PTT signal */
-#define PBC_BSTAT1_MC13783_IN   0x1000	/* MC13783 board. 0 = connected. */
-
-/* PBC Board Control Register 1 bit definitions */
-#define PBC_BCTRL1_ERST         0x0001	/* Ethernet Reset */
-#define PBC_BCTRL1_URST         0x0002	/* Reset External UART controller */
-#define PBC_BCTRL1_UENA         0x0004	/* Enable UART A transceiver */
-#define PBC_BCTRL1_UENB         0x0008	/* Enable UART B transceiver */
-#define PBC_BCTRL1_UENCE        0x0010	/* Enable UART CE transceiver */
-#define PBC_BCTRL1_IREN         0x0020	/* Enable the IRDA transmitter */
-#define PBC_BCTRL1_LED0         0x0040	/* Used to control LED 0 (green) */
-#define PBC_BCTRL1_LED1         0x0080	/* Used to control LED 1 (yellow) */
-#define PBC_BCTRL1_SENSOR1_ON	0x0600	/* Enable Sensor 1 */
-#define PBC_BCTRL1_SENSOR2_ON	0x3000	/* Enable Sensor 2 */
-#define PBC_BCTRL1_BEND         0x4000	/* Big Endian Select */
-#define PBC_BCTRL1_LCDON        0x8000	/* Enable the LCD */
-
-/* PBC Board Control Register 2 bit definitions */
-#define PBC_BCTRL2_USELA	0x0001	/* UART A Select, 0 = UART1, 1 = UART5 */
-#define PBC_BCTRL2_USELB	0x0002	/* UART B Select, 0 = UART3, 1 = UART5 */
-#define PBC_BCTRL2_USELC	0x0004	/* UART C Select, 0 = UART2, 1 = UART1 */
-#define PBC_BCTRL2_UMODENA	0x0008	/* UART A Modem Signals Enable, 0 = enabled */
-#define PBC_BCTRL2_UMODENC	0x0008	/* UART C Modem Signals Enable, 0 = enabled */
-#define PBC_BCTRL2_CSI_EN	0x0020	/* Enable the CSI interface, 0 = enabled */
-#define PBC_BCTRL2_ATA_EN	0x0040	/* Enable the ATA interface, 0 = enabled */
-#define PBC_BCTRL2_ATA_SEL	0x0080	/* ATA Select, 0 = group A, 1 = group B */
-#define PBC_BCTRL2_IRDA_MOD	0x0100	/* IRDA Mode (see CPLD spec) */
-#define PBC_BCTRL2_LDC_RST0	0x0200	/* LCD 0 Reset, 1 = reset signal asserted */
-#define PBC_BCTRL2_LDC_RST1	0x0400	/* LCD 1 Reset, 1 = reset signal asserted */
-#define PBC_BCTRL2_LDC_RST2	0x0800	/* LCD 2 Reset, 1 = reset signal asserted */
-#define PBC_BCTRL2_LDCIO_EN	0x1000	/* LCD GPIO Enable, 0 = enabled */
-#define PBC_BCTRL2_CT_CS	0x2000	/* Code Test Chip Select, = Code Test selected */
-#define PBC_BCTRL2_VPP_EN	0x4000	/* PCMCIA VPP Enable, 1 = power on */
-#define PBC_BCTRL2_VCC_EN	0x8000	/* PCMCIA VCC Enable, 1 = power on */
-
-/* PBC Board Control Register 3 bit definitions */
-#define PBC_BCTRL3_OTG_FS_SEL	0x0001	/* USB OTG Full Speed Select, 0 = PMIC, 1 = CPU */
-#define PBC_BCTRL3_OTG_FS_EN	0x0002	/* USB OTG Full Speed Enable, 0 = enabled */
-#define PBC_BCTRL3_FSH_SEL	0x0004	/* USB Full Speed Host Select, 0 = Group A, 1 = Group B */
-#define PBC_BCTRL3_FSH_EN	0x0008	/* USB Full Speed Host Enable, 0 = enabled */
-#define PBC_BCTRL3_HSH_SEL	0x0010	/* USB High Speed Host Select, 0 = Group A, 1 = Group B */
-#define PBC_BCTRL3_HSH_EN	0x0020	/* USB High Speed Host Enable, 0 = enabled */
-#define PBC_BCTRL3_FSH_MOD	0x0040	/* USB Full Speed Host Mode, 0 = Differential, 1 = Single ended */
-#define PBC_BCTRL3_OTG_HS_EN	0x0080	/* USB OTG High Speed Enable, 0 = enabled */
-#define PBC_BCTRL3_OTG_VBUS_EN	0x0100	/* USB OTG VBUS Regulator Enable, 0 = enabled */
-#define PBC_BCTRL3_FSH_VBUS_EN	0x0200	/* USB Full Speed Host VBUS Regulator Enable, 0 = enabled */
-#define PBC_BCTRL3_CARD1_SEL	0x0400	/* Card1 Select, 0 = SD1, 1 = MS1 */
-#define PBC_BCTRL3_CARD2_SEL	0x0800	/* Card2 Select, 0 = PCMCIA & SD2, 1 = MS2 */
-#define PBC_BCTRL3_SYNTH_RST	0x1000	/* Audio Synthesizer Reset, 0 = reset asserted */
-#define PBC_BCTRL3_VSIM_EN	0x2000	/* VSIM Regulator Enable, 1 = enabled */
-#define PBC_BCTRL3_VESIM_EN	0x4000	/* VESIM Regulator Enable, 1 = enabled */
-#define PBC_BCTRL3_SPI3_RESET	0x8000	/* CSPI3 Connector Reset, 0 = reset asserted */
-
-/* PBC Board Control Register 4 bit definitions */
-#define PBC_BCTRL4_CSI_MSB_EN	0x0001	/* CSI MSB Enable, 0 = CSI_Data[3:0] enabled */
-#define PBC_BCTRL4_REGEN_SEL	0x0002	/* Regulator Enable Select, 0 = enabled */
-#define PBC_BCTRL4_USER_OFF	0x0004	/* User Off Indication, 1 = user off confirmation */
-#define PBC_BCTRL4_VIB_EN	0x0008	/* Vibrator Enable, 1 = enabled */
-#define PBC_BCTRL4_PCMCIA_EN	0x0010	/* PCMCIA Enable, 0 = buffer enabled */
-
-#define PBC_INT_CS8900A         4
-/*! @} */
-
-#define PBC_INTSTATUS_REG	(PBC_INTSTATUS + PBC_BASE_ADDRESS)
-#define PBC_INTCURR_STATUS_REG	(PBC_INTCURR_STATUS + PBC_BASE_ADDRESS)
-#define PBC_INTMASK_SET_REG	(PBC_INTMASK_SET + PBC_BASE_ADDRESS)
-#define PBC_INTMASK_CLEAR_REG	(PBC_INTMASK_CLEAR + PBC_BASE_ADDRESS)
-#define EXPIO_PARENT_INT	IOMUX_TO_IRQ(MX33_PIN_GPIO1_4)
-
-#define EXPIO_INT_LOW_BAT	(MXC_EXP_IO_BASE + 0)
-#define EXPIO_INT_PB_IRQ	(MXC_EXP_IO_BASE + 1)
-#define EXPIO_INT_OTG_FS_OVR	(MXC_EXP_IO_BASE + 2)
-#define EXPIO_INT_FSH_OVR	(MXC_EXP_IO_BASE + 3)
-#define EXPIO_INT_RES4		(MXC_EXP_IO_BASE + 4)
-#define EXPIO_INT_RES5		(MXC_EXP_IO_BASE + 5)
-#define EXPIO_INT_RES6		(MXC_EXP_IO_BASE + 6)
-#define EXPIO_INT_RES7		(MXC_EXP_IO_BASE + 7)
-#define EXPIO_INT_ENET_INT	(MXC_EXP_IO_BASE + 8)
-#define EXPIO_INT_OTG_FS_INT	(MXC_EXP_IO_BASE + 9)
-#define EXPIO_INT_XUART_INTA	(MXC_EXP_IO_BASE + 10)
-#define EXPIO_INT_XUART_INTB	(MXC_EXP_IO_BASE + 11)
-#define EXPIO_INT_SYNTH_IRQ	(MXC_EXP_IO_BASE + 12)
-#define EXPIO_INT_CE_INT1	(MXC_EXP_IO_BASE + 13)
-#define EXPIO_INT_CE_INT2	(MXC_EXP_IO_BASE + 14)
-#define EXPIO_INT_RES15		(MXC_EXP_IO_BASE + 15)
-
-#define MXC_MAX_EXP_IO_LINES	16
-
-/*!
- * @name  Defines Base address and IRQ used for CS8900A Ethernet Controller on MXC Boards
- */
-/*! @{*/
-/*! This is System IRQ used by CS8900A for interrupt generation taken from platform.h */
-#define CS8900AIRQ              EXPIO_INT_ENET_INT
-/*! This is I/O Base address used to access registers of CS8900A on MXC ADS */
-#define CS8900A_BASE_ADDRESS    (PBC_BASE_ADDRESS + PBC_CS8900A_IOBASE + 0x300)
-/*! @} */
-
-#define MXC_PMIC_INT_LINE	IOMUX_TO_IRQ(MX33_PIN_GPIO1_3)
-
-#define AHB_FREQ                133000000
-#define IPG_FREQ                66500000
-
-/*! This is used to active or inactive ata signal in CPLD .
- *  It is dependent with hardware
- */
-#define PBC_ATA_SIGNAL_ACTIVE() \
-        __raw_writew(PBC_BCTRL2_ATA_SEL, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);\
-        __raw_writew(PBC_BCTRL2_ATA_EN, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
-
-#define PBC_ATA_SIGNAL_INACTIVE() \
-         __raw_writew(PBC_BCTRL2_ATA_EN, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
-
-#endif				/* __ASM_ARCH_MXC_BOARD_MX33ADS_H__ */
diff --git a/include/asm-arm/arch-mxc/mx33.h b/include/asm-arm/arch-mxc/mx33.h
deleted file mode 100644
index 63078c8..0000000
--- a/include/asm-arm/arch-mxc/mx33.h
+++ /dev/null
@@ -1,491 +0,0 @@
-/*
- * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-#ifndef __ASM_ARCH_MXC_MX33_H__
-#define __ASM_ARCH_MXC_MX33_H__
-
-#ifndef __ASM_ARCH_MXC_HARDWARE_H__
-#error "Do not include directly."
-#endif
-
-#include <asm/arch/mx33_pins.h>
-
-/*!
- * defines the OS clock tick rate
- */
-#define CLOCK_TICK_RATE         16625000
-
-#define ATA_BASE_CLK            (IPG_CLK)
-/*!
- * Register an interrupt handler for the SMN as well as the SCC.  In some
- * implementations, the SMN is not connected at all, and in others, it is
- * on the same interrupt line as the SCM. Comment this line out accordingly
- */
-#define USE_SMN_INTERRUPT
-
-/*
- * UART Chip level Configuration that a user may not have to edit. These
- * configuration vary depending on how the UART module is integrated with
- * the ARM core
- */
-#define MXC_UART_NR 5
-/*!
- * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
- * Certain platforms need this bit to be set in order to receive Irda data.
- */
-#define MXC_UART_IR_RXDMUX      0x0004
-/*!
- * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
- * Certain platforms need this bit to be set in order to receive UART data.
- */
-#define MXC_UART_RXDMUX         0x0004
-
-/*
- * IRAM
- */
-#define IRAM_BASE_ADDR		0x10000000	/* internal ram */
-#define IRAM_BASE_ADDR_VIRT	0xE0000000
-#define IRAM_SIZE		SZ_128K
-
-/*
- * L2CC
- */
-#define L2CC_BASE_ADDR		0xB0000000
-#define L2CC_BASE_ADDR_VIRT	0xE1000000
-#define L2CC_SIZE		SZ_1M
-
-#define PLATFORM_BASE_ADDR	0xB0400000
-#define PLATFORM_BASE_ADDR_VIRT 0xE1400000
-#define PLATFORM_SIZE		SZ_1M
-#define EVTMON_BASE_ADDR	(PLATFORM_BASE_ADDR + 0x00000000)
-#define ARM1176_BASE_ADDR	(PLATFORM_BASE_ADDR + 0x00002000)
-
-#define TZIC_BASE_ADDR		0xB0800000
-#define TZIC_BASE_ADDR_VIRT	0xE1800000
-#define TZIC_SIZE		SZ_1M
-
-#define DEBUG_BASE_ADDR		0xB0C00000
-#define DEBUG_BASE_ADDR_VIRT	0xE1C00000
-#define DEBUG_SIZE		SZ_1M
-#define ETB_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00001000)
-#define ETM_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00002000)
-#define TPIU_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00003000)
-#define CTI0_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00004000)
-#define CTI1_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00005000)
-#define CTI2_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00006000)
-#define CTI3_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00007000)
-
-/*
- * SPBA global module enabled #0
- */
-#define SPBA0_BASE_ADDR 	0xC0000000
-#define SPBA0_BASE_ADDR_VIRT	0xE4000000
-#define SPBA0_SIZE		SZ_1M
-
-#define MMC_SDHC1_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00004000)
-#define MMC_SDHC2_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00008000)
-#define UART3_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x0000C000)
-#define CSPI2_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x00010000)
-#define SSI2_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00014000)
-#define MMC_SDHC3_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00020000)
-#define MARC_BASE_ADDR		(SPBA0_BASE_ADDR + 0x0002C000)
-#define ATA_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00034000)
-#define FEC_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00038000)
-#define SPBA_CTRL_BASE_ADDR	(SPBA0_BASE_ADDR + 0x0003C000)
-/*
- * AIPS 1
- */
-#define AIPS1_BASE_ADDR 	0xC3F00000
-#define AIPS1_BASE_ADDR_VIRT	0xE4100000
-#define AIPS1_SIZE		SZ_1M
-
-#define MAX_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00080000)
-#define GPIO1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00084000)
-#define GPIO2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00088000)
-#define GPIO3_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0008C000)
-#define GPIO4_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00090000)
-#define KPP_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00094000)
-#define WDOG1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00098000)
-#define WDOG2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0009C000)
-#define GPT1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A0000)
-#define SRTC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A4000)
-#define IOMUXC_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000A8000)
-#define IIM_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000AC000)
-#define CSU_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000B0000)
-#define SDMA_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000B4000)
-#define SAHARA_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B8000)
-#define SCC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000BC000)
-#define ROMCP_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000C0000)
-#define RTIC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000C4000)
-#define MU_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000C8000)
-#define SDDC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000CC000)
-#define VPU_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D0000)
-#define USBOH2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000D4000)
-#define ATA_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D8000)
-#define SIM1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000DC000)
-#define MSHC1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000E0000)
-#define MSHC2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000E4000)
-
-/*!
- * defines for SPBA modules
- */
-
-#define SPBA_SDHC1	0x04
-#define SPBA_SDHC2	0x08
-#define SPBA_UART3	0x0C
-#define SPBA_CSPI2	0x10
-#define SPBA_SSI2	0x14
-#define SPBA_SDHC3	0x20
-#define SPBA_MARC	0x2C
-#define SPBA_ATA	0x34
-#define SPBA_FEC	0x38
-
-/*!
- * Defines for modules using static and dynamic DMA channels
- */
-#define MXC_DMA_CHANNEL_UART1_RX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART1_TX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART2_RX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART2_TX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART3_RX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART3_TX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART4_RX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART4_TX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART5_RX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART5_TX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_MMC1  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_MMC2  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_SSI1_RX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_SSI1_TX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_SSI2_RX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_SSI2_TX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_FIR_RX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_FIR_TX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_CSPI1_RX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_CSPI1_TX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_CSPI2_RX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_CSPI2_TX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_ATA_RX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_ATA_TX  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_MEMORY  MXC_DMA_DYNAMIC_CHANNEL
-
-/*
- * AIPS 2
- */
-#define AIPS2_BASE_ADDR		0xE3F00000
-#define AIPS2_BASE_ADDR_VIRT	0xE4800000
-#define AIPS2_SIZE		SZ_1M
-
-#define DPLLIP1_BASE_ADDR	(AIPS2_BASE_ADDR + 0x00080000)
-#define DPLLIP2_BASE_ADDR	(AIPS2_BASE_ADDR + 0x00084000)
-#define DPLLIP3_BASE_ADDR	(AIPS2_BASE_ADDR + 0x00088000)
-#define CCM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0008C000)
-#define GPC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00090000)
-#define SRC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00094000)
-#define EPIT1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00098000)
-#define EPIT2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0009C000)
-#define PWM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A0000)
-#define OWIRE_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000A4000)
-#define CSPI3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A8000)
-#define CSPI1_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000AC000)
-#define UART1_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000B0000)
-#define UART4_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000B4000)
-#define UART5_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000B8000)
-#define UART2_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000BC000)
-#define I2C3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C0000)
-#define I2C2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C4000)
-#define I2C_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C8000)
-#define SSI1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000CC000)
-#define AUDMUX_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000D0000)
-#define EMI_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D8000)
-#define HSC_CTL_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000DC000)
-
-#if 0
-#define PCMCIA_CTL_BASE_ADDR	EMI_CTL_BASE_ADDR
-#define FIRI_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0008C000)
-#define SCM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000AE000)
-#define SMN_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000AF000)
-#define RNGA_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000B0000)
-#define IPU_CTRL_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000C0000)
-#define MPEG4_ENC_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000C8000)
-#define RTC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D8000)
-
-#define ETB_SLOT4_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00010000)
-#define ETB_SLOT5_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00014000)
-#define ECT_CTIO_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00018000)
-#define OTG_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00088000)
-#define ECT_IP1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B8000)
-#define ECT_IP2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000BC000)
-
-#endif
-
-/*
- * NAND, SDRAM, WEIM, M3IF, EMI controllers
- */
-#define M4IF_BASE_ADDR		(EMI_BASE_ADDR + 0x0000)
-#define ESDCTL_BASE_ADDR	(EMI_BASE_ADDR + 0x1000)
-#define WEIM_BASE_ADDR		(EMI_BASE_ADDR + 0x2000)
-#define NFC_BASE_ADDR		(EMI_BASE_ADDR + 0x3000)
-#define EMI_CTL_BASE_ADDR	(EMI_BASE_ADDR + 0x3F00)
-
-/*
- * Memory regions and CS
- */
-/* MX33 ADS SDRAM is from CSD1, 64M */
-#define CSD0_BASE_ADDR          0x40000000
-#define CSD1_BASE_ADDR          0x50000000
-
-#define CS0_BASE_ADDR           0x60000000
-#define CS1_BASE_ADDR           0x68000000
-#define CS2_BASE_ADDR           0x70000000
-#define CS3_BASE_ADDR           0x72000000
-#define CS4_BASE_ADDR           0x74000000
-#define CS4_BASE_ADDR_VIRT      0xEB000000
-#define CS4_SIZE                SZ_16M
-#define CS5_BASE_ADDR           0x76000000
-#define SDRAM_BASE_ADDR         0x50000000
-
-#define IPU_MEM_BASE_ADDR       0x80000000
-#define GPU_MEM_BASE_ADDR       0xA0000000
-
-#define PCMCIA_MEM_BASE_ADDR    0xBC000000
-
-/*!
- * This macro defines the physical to virtual address mapping for all the
- * peripheral modules. It is used by passing in the physical address as x
- * and returning the virtual address. If the physical address is not mapped,
- * it returns 0xEEADBEEF
- */
-#define IO_ADDRESS(x)   \
-        (((x >= IRAM_BASE_ADDR) && (x < (IRAM_BASE_ADDR + IRAM_SIZE))) ? IRAM_IO_ADDRESS(x):\
-        ((x >= CS4_BASE_ADDR) && (x < (CS4_BASE_ADDR + CS4_SIZE))) ? CS4_IO_ADDRESS(x):\
-        ((x >= L2CC_BASE_ADDR) && (x < (L2CC_BASE_ADDR + L2CC_SIZE))) ? L2CC_IO_ADDRESS(x):\
-        ((x >= PLATFORM_BASE_ADDR) && (x < (PLATFORM_BASE_ADDR + PLATFORM_SIZE))) ? PLATFORM_IO_ADDRESS(x):\
-        ((x >= TZIC_BASE_ADDR) && (x < (TZIC_BASE_ADDR + TZIC_SIZE))) ? TZIC_IO_ADDRESS(x):\
-        ((x >= DEBUG_BASE_ADDR) && (x < (DEBUG_BASE_ADDR + DEBUG_SIZE))) ? DEBUG_IO_ADDRESS(x):\
-        ((x >= SPBA0_BASE_ADDR) && (x < (SPBA0_BASE_ADDR + SPBA0_SIZE))) ? SPBA0_IO_ADDRESS(x):\
-        ((x >= AIPS1_BASE_ADDR) && (x < (AIPS1_BASE_ADDR + AIPS1_SIZE))) ? AIPS1_IO_ADDRESS(x):\
-        ((x >= AIPS2_BASE_ADDR) && (x < (AIPS2_BASE_ADDR + AIPS2_SIZE))) ? AIPS2_IO_ADDRESS(x):\
-        0xEEADBEEF)
-
-/*
- * define the address mapping macros: in physical address order
- */
-
-#define IRAM_IO_ADDRESS(x)  \
-        (((x) - IRAM_BASE_ADDR) + IRAM_BASE_ADDR_VIRT)
-
-#define CS4_IO_ADDRESS(x)  \
-        (((x) - CS4_BASE_ADDR) + CS4_BASE_ADDR_VIRT)
-
-#define L2CC_IO_ADDRESS(x)  \
-        (((x) - L2CC_BASE_ADDR) + L2CC_BASE_ADDR_VIRT)
-
-#define PLATFORM_IO_ADDRESS(x)  \
-        (((x) - PLATFORM_BASE_ADDR) + PLATFORM_BASE_ADDR_VIRT)
-
-#define TZIC_IO_ADDRESS(x)  \
-        (((x) - TZIC_BASE_ADDR) + TZIC_BASE_ADDR_VIRT)
-
-#define DEBUG_IO_ADDRESS(x)  \
-        (((x) - DEBUG_BASE_ADDR) + DEBUG_BASE_ADDR_VIRT)
-
-#define SPBA0_IO_ADDRESS(x)  \
-        (((x) - SPBA0_BASE_ADDR) + SPBA0_BASE_ADDR_VIRT)
-
-#define AIPS1_IO_ADDRESS(x)  \
-        (((x) - AIPS1_BASE_ADDR) + AIPS1_BASE_ADDR_VIRT)
-
-#define AIPS2_IO_ADDRESS(x)  \
-        (((x) - AIPS2_BASE_ADDR) + AIPS2_BASE_ADDR_VIRT)
-
-/*
- * DMA request assignments
- */
-#define DMA_REQ_47	   47
-#define DMA_REQ_46	   46
-#define DMA_REQ_45	   45
-#define DMA_REQ_UART3_TX   44
-#define DMA_REQ_UART3_RX   43
-#define DMA_REQ_MU_RX      42
-#define DMA_REQ_MU_TX      41
-#define DMA_REQ_SDHC3      40
-#define DMA_REQ_CSPI3_TX   39
-#define DMA_REQ_CSPI3_RX   38
-#define DMA_REQ_37         37
-#define DMA_REQ_IPU	   36
-#define DMA_REQ_GPU	   35
-#define DMA_REQ_34         34
-#define DMA_REQ_MARC_TX    33
-#define DMA_REQ_MARC_RX    32
-#define DMA_REQ_ECT        31
-#define DMA_REQ_NFC        30
-#define DMA_REQ_SSI1_TX1   29
-#define DMA_REQ_SSI1_RX1   28
-#define DMA_REQ_SSI1_TX2   27
-#define DMA_REQ_SSI1_RX2   26
-#define DMA_REQ_SSI2_TX1   25
-#define DMA_REQ_SSI2_RX1   24
-#define DMA_REQ_SSI2_TX2   23
-#define DMA_REQ_SSI2_RX2   22
-#define DMA_REQ_SDHC2      21
-#define DMA_REQ_SDHC1      20
-#define DMA_REQ_UART1_TX   19
-#define DMA_REQ_UART1_RX   18
-#define DMA_REQ_UART2_TX   17
-#define DMA_REQ_UART2_RX   16
-#define DMA_REQ_GPIO1_0    15
-#define DMA_REQ_GPIO1_1    14
-#define DMA_REQ_UART4_TX   13
-#define DMA_REQ_UART4_RX   12
-#define DMA_REQ_UART5_TX   11
-#define DMA_REQ_UART5_RX   10
-#define DMA_REQ_CSPI1_TX   9
-#define DMA_REQ_CSPI1_RX   8
-#define DMA_REQ_CSPI2_TX   7
-#define DMA_REQ_CSPI2_RX   6
-#define DMA_REQ_SIM        5
-#define DMA_REQ_ATA_TX_END 4
-#define DMA_REQ_ATA_TX     3
-#define DMA_REQ_ATA_RX     2
-#define DMA_REQ_GPC        1
-#define DMA_REQ_0   	   0
-
-/*
- * Interrupt numbers
- */
-#define MXC_INT_BASE		0
-
-#define INT_RESV0               0
-#define INT_MMC_SDHC1           1
-#define INT_MMC_SDHC2           2
-#define INT_MMC_SDHC3           3
-#define INT_RESV4               4
-#define INT_SDDC		5
-#define INT_SDMA                6
-#define INT_IOMUX		7
-#define INT_RESV8		8
-#define INT_VPU			9
-#define INT_IPU_ERR             10
-#define INT_IPU_SYN             11
-#define INT_GPU    	        12
-#define INT_MARC    	        13
-#define INT_RESV14		14
-#define INT_EMI			15
-#define INT_USB_HOST1           16
-#define INT_USB_HOST2           17
-#define INT_USB_OTG             18
-#define INT_SAHARA_HOST1	19
-#define INT_SAHARA_HOST2	20
-#define INT_SCC_SCM             21
-#define INT_SCC_STZ             22
-#define INT_SCC_SNTZ            23
-#define INT_SRTC_NTZ		24
-#define INT_SRTC_TZ		25
-#define INT_RTIC		26
-#define INT_CSU			27
-#define INT_RESV28		28
-#define INT_SSI1                29
-#define INT_SSI2                30
-#define INT_UART1               31
-#define INT_UART2               32
-#define INT_UART3               33
-#define INT_UART4               34
-#define INT_UART5               35
-#define INT_CSPI1               36
-#define INT_CSPI2               37
-#define INT_CSPI3               38
-#define INT_GPT                 39
-#define INT_EPIT1               40
-#define INT_EPIT2               41
-#define INT_GPIO1_INT7          42
-#define INT_GPIO1_INT6          43
-#define INT_GPIO1_INT5          44
-#define INT_GPIO1_INT4          45
-#define INT_GPIO1_INT3          46
-#define INT_GPIO1_INT2          47
-#define INT_GPIO1_INT1          48
-#define INT_GPIO1_INT0          49
-#define INT_GPIO1_LOW           50
-#define INT_GPIO1_HIGH          51
-#define INT_GPIO2_LOW           52
-#define INT_GPIO2_HIGH          53
-#define INT_GPIO3_LOW           54
-#define INT_GPIO3_HIGH          55
-#define INT_GPIO4_LOW           56
-#define INT_GPIO4_HIGH          57
-#define INT_WDOG1               58
-#define INT_WDOG2               59
-#define INT_KPP                 60
-#define INT_PWM                 61
-#define INT_I2C                 62
-#define INT_I2C2                63
-#define INT_I2C3                64
-#define INT_MSHC1               65
-#define INT_MSHC2               66
-#define INT_SIM1                67
-#define INT_SIM2                68
-#define INT_IIM                 69
-#define INT_ATA                 70
-#define INT_CCM1                71
-#define INT_CCM2                72
-#define INT_GPC1		73
-#define INT_GPC2		74
-#define INT_SRC			75
-#define INT_EVTMON              76
-#define INT_PER_MEASURE         77
-#define INT_DECODE_ERR		78
-#define INT_EVT_COUNT		79
-#define INT_SLAVE_ERR		80
-#define INT_HSC_ERR		81
-#define INT_HSC_FUN		82
-#define INT_HSC_TIMER		83
-#define INT_MU_APU		84
-#define INT_MU_RX1		85
-#define INT_MU_TX1		86
-#define INT_FEC			87
-#define INT_OWIRE		88
-#define INT_CTI0		89
-#define INT_CTM0		90
-#define INT_CTM1		91
-
-#define MXC_MAX_INT_LINES       128
-
-/*!
- * Interrupt Number for ARM11 PMU
- */
-#define ARM11_PMU_IRQ		INT_EVTMON
-
-#define	MXC_GPIO_BASE		(MXC_MAX_INT_LINES)
-
-/*!
- * Number of GPIO port as defined in the IC Spec
- */
-#define GPIO_PORT_NUM           4
-/*!
- * Number of GPIO pins per port
- */
-#define GPIO_NUM_PIN            32
-
-#define PROD_SIGNATURE        0x1	/* For MX33 */
-#define MXC_GPIO_SPLIT_IRQ_2
-
-#define SYSTEM_REV_MIN          CHIP_REV_1_0
-#define SYSTEM_REV_NUM          3
-
-/*
- * Used for 1-Wire
- */
-#define owire_read(a) (__raw_readw(a))
-#define owire_write(v,a) (__raw_writew(v,a))
-
-#endif				/*  __ASM_ARCH_MXC_MX33_H__ */
diff --git a/include/asm-arm/arch-mxc/mx33_pins.h b/include/asm-arm/arch-mxc/mx33_pins.h
deleted file mode 100644
index d0d4a12..0000000
--- a/include/asm-arm/arch-mxc/mx33_pins.h
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-#ifndef __ASM_ARCH_MXC_MX33_PINS_H__
-#define __ASM_ARCH_MXC_MX33_PINS_H__
-
-#ifndef __ASSEMBLY__
-
-/*!
- * @name IOMUX/PAD Bit field definitions
- */
-
-/*! @{ */
-
-/*!
- * In order to identify pins more effectively, each mux-controlled pin's
- * enumerated value is constructed in the following way:
- *
- * -------------------------------------------------------------------
- * 31-29 | 28 - 24 |  23    | 22 - 20 | 19  - 10| 9 - 0
- * -------------------------------------------------------------------
- * IO_P  |  IO_I   | RESV_I |  GPIO_I | PAD_I  | MUX_I
- * -------------------------------------------------------------------
- *
- * Bit 0 to 9 contains MUX_I used to identify the register
- * offset (0-based. base is IOMUX_module_base + 0x20) defined in the Section
- * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. The
- * similar field definitions are used for the pad control register.
- * For example, the MX33_PIN_I2C1_CLK is defined in the enumeration:
- *    ( (8 - MUX_I_START) << MUX_I)|( (0x38C - PAD_I_START) << PAD_I)
- * It means the mux control register is at register offset 8. The pad control
- * register offset is: 0x38C and also occupy the least significant bits
- * within the register.
- */
-
-/*!
- * Starting bit position within each entry of \b iomux_pins to represent the
- * gpio port number (0-based) for that pin. For non-gpio pins, the bits will
- * be all 1's for error checking in the functions. (gpio port 7 is invalid)
- */
-#define MUX_IO_P	29
-
-/*!
- * Starting bit position within each entry of \b iomux_pins to represent the
- * gpio offset bit (0-based) for that pin. For non-gpio pins, the bits will
- * be all 0's since they are don't cares. So for port 2 pin 21, bit 31-24
- * will be (1 << MUX_IO_P) | (21 << MUX_IO_I).
- */
-#define MUX_IO_I	24
-
-/*!
- * Starting bit position within each entry of \b iomux_pins to represent the
- * MUX control register index (0-based)
- */
-#define MUX_I		0
-
-/*!
- * Starting bit position within each entry of \b iomux_pins to represent the
- * PAD control register index (0-based)
- */
-#define PAD_I		10
-
-/*!
- * Starting bit position within each entry of \b iomux_pins to represent which
- * mux mode is for GPIO (0-based)
- */
-#define GPIO_I		20
-
-/*!
- * Starting bit position which is reserved.
- */
-#define RESV_I		23
-
-#define MUX_I_START  0x0008
-#define PAD_I_START  0x0274
-
-#define NO_PAD	(((1<<(RESV_I-PAD_I))-1) + PAD_I_START)
-
-#define _MXC_BUILD_PIN(gp,gi, ga, mi, pi) \
-	(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | \
-	((mi - MUX_I_START) << MUX_I) | \
-	((pi - PAD_I_START) << PAD_I) | \
-	((ga)<< GPIO_I) )
-
-#define _MXC_BUILD_GPIO_PIN(gp,gi,ga,mi,pi) _MXC_BUILD_PIN(gp,gi,ga, mi,pi)
-#define _MXC_BUILD_NON_GPIO_PIN(mi,pi) 	_MXC_BUILD_PIN(7,0,0,mi,pi)
-
-#define PIN_TO_IOMUX_INDEX(pin) ((pin >> MUX_I) & ((1 << (PAD_I - MUX_I)) - 1))
-#define PIN_TO_IOPAD_INDEX(pin) ((pin >> PAD_I) & ((1 << (GPIO_I - PAD_I)) - 1))
-#define PIN_TO_IOGPIO_INDEX(pin) ((pin >> GPIO_I) & ((1 << (RESV_I - GPIO_I)) - 1))
-
-#define PIN_TO_IOMUX_OFFSET(pin) (PIN_TO_IOMUX_INDEX(pin) + MUX_I_START)
-#define PIN_TO_IOPAD_OFFSET(pin) (PIN_TO_IOPAD_INDEX(pin) + PAD_I_START)
-
-#define MUX_PIN_NUM_MAX ((PAD_I_START - MUX_I_START)>>2)
-/*! @} End IOMUX/PAD Bit field definitions */
-
-/*!
- * This enumeration is constructed based on the Section
- * "sw_pad_ctl & sw_mux_ctl details" of the MX33 IC Spec. Each enumerated
- * value is constructed based on the rules described above.
- */
-typedef enum iomux_pins {
-	MX33_PIN_I2C1_CLK = _MXC_BUILD_GPIO_PIN(0, 9, 2, 0x008, 0x38C),
-	MX33_PIN_I2C1_DAT = _MXC_BUILD_GPIO_PIN(0, 10, 2, 0x00C, 0x390),
-
-	MX33_PIN_AUD3_BB_TXD = _MXC_BUILD_GPIO_PIN(0, 11, 2, 0x10, 0x394),
-	MX33_PIN_AUD3_BB_RXD = _MXC_BUILD_GPIO_PIN(0, 12, 2, 0x14, 0x398),
-	MX33_PIN_AUD3_BB_CK = _MXC_BUILD_GPIO_PIN(0, 13, 2, 0x18, 0x39C),
-	MX33_PIN_AUD3_BB_FS = _MXC_BUILD_GPIO_PIN(0, 14, 2, 0x1C, 0x3A0),
-	MX33_PIN_AUD5_RXFS = _MXC_BUILD_GPIO_PIN(0, 15, 2, 0x20, 0x3A4),
-	MX33_PIN_AUD5_RXC = _MXC_BUILD_GPIO_PIN(0, 16, 2, 0x24, 0x3A8),
-	MX33_PIN_AUD5_WB_TXD = _MXC_BUILD_GPIO_PIN(0, 17, 2, 0x28, 0x3AC),
-	MX33_PIN_AUD5_WB_RXD = _MXC_BUILD_GPIO_PIN(0, 18, 2, 0x2C, 0x3B0),
-	MX33_PIN_AUD5_WB_CK = _MXC_BUILD_GPIO_PIN(0, 19, 2, 0x30, 0x3B4),
-	MX33_PIN_AUD5_WB_FS = _MXC_BUILD_GPIO_PIN(0, 20, 2, 0x34, 0x3B8),
-	MX33_PIN_AUD6_BT_TXD = _MXC_BUILD_GPIO_PIN(0, 21, 2, 0x38, 0x3BC),
-	MX33_PIN_AUD6_BT_RXD = _MXC_BUILD_GPIO_PIN(0, 22, 2, 0x3C, 0x3C0),
-	MX33_PIN_AUD6_BT_CK = _MXC_BUILD_GPIO_PIN(0, 23, 2, 0x40, 0x3C4),
-	MX33_PIN_AUD6_BT_FS = _MXC_BUILD_GPIO_PIN(0, 24, 2, 0x44, 0x3C8),
-
-	MX33_PIN_CSPI1_MOSI = _MXC_BUILD_GPIO_PIN(0, 25, 2, 0x48, 0x3CC),
-	MX33_PIN_CSPI1_MISO = _MXC_BUILD_GPIO_PIN(0, 26, 2, 0x4C, 0x3D0),
-	MX33_PIN_CSPI1_SS0 = _MXC_BUILD_GPIO_PIN(0, 27, 2, 0x50, 0x3D4),
-	MX33_PIN_CSPI1_SS1 = _MXC_BUILD_GPIO_PIN(0, 28, 2, 0x54, 0x3D8),
-	MX33_PIN_CSPI1_SCLK = _MXC_BUILD_GPIO_PIN(0, 29, 2, 0x58, 0x3DC),
-	MX33_PIN_CSPI2_MOSI = _MXC_BUILD_GPIO_PIN(0, 30, 2, 0x5C, 0x3E0),
-	MX33_PIN_CSPI2_MISO = _MXC_BUILD_GPIO_PIN(0, 31, 2, 0x60, 0x3E4),
-	MX33_PIN_CSPI2_SS0 = _MXC_BUILD_NON_GPIO_PIN(0x64, 0x3E8),
-	MX33_PIN_CSPI2_SS1 = _MXC_BUILD_NON_GPIO_PIN(0x68, 0x3EC),
-	MX33_PIN_CSPI2_SCLK = _MXC_BUILD_GPIO_PIN(1, 0, 2, 0x6C, 0x3F0),
-	MX33_PIN_CSPI3_MOSI = _MXC_BUILD_GPIO_PIN(1, 1, 2, 0x70, 0x3F4),
-	MX33_PIN_CSPI3_MISO = _MXC_BUILD_GPIO_PIN(1, 2, 2, 0x74, 0x3F8),
-	MX33_PIN_CSPI3_SCLK = _MXC_BUILD_GPIO_PIN(1, 3, 2, 0x78, 0x3FC),
-
-	MX33_PIN_UART1_RXD = _MXC_BUILD_GPIO_PIN(1, 4, 2, 0x7C, 0x400),
-	MX33_PIN_UART1_TXD = _MXC_BUILD_GPIO_PIN(1, 5, 2, 0x80, 0x404),
-	MX33_PIN_UART1_RTS = _MXC_BUILD_GPIO_PIN(1, 6, 2, 0x84, 0x408),
-	MX33_PIN_UART1_CTS = _MXC_BUILD_GPIO_PIN(1, 7, 2, 0x88, 0x40C),
-	MX33_PIN_UART2_RXD = _MXC_BUILD_GPIO_PIN(1, 8, 2, 0x8C, 0x410),
-	MX33_PIN_UART2_TXD = _MXC_BUILD_GPIO_PIN(1, 9, 2, 0x90, 0x414),
-	MX33_PIN_UART2_RTS = _MXC_BUILD_GPIO_PIN(1, 10, 2, 0x94, 0x418),
-	MX33_PIN_UART2_CTS = _MXC_BUILD_GPIO_PIN(1, 11, 2, 0x98, 0x41C),
-	MX33_PIN_UART1_DTR = _MXC_BUILD_GPIO_PIN(1, 12, 2, 0x9C, 0x420),
-	MX33_PIN_UART1_DSR = _MXC_BUILD_GPIO_PIN(1, 13, 2, 0xA0, 0x424),
-	MX33_PIN_UART1_RI = _MXC_BUILD_GPIO_PIN(1, 14, 2, 0xA4, 0x428),
-	MX33_PIN_UART1_DCD = _MXC_BUILD_GPIO_PIN(1, 15, 2, 0xA8, 0x42C),
-
-	MX33_PIN_OWIRE_LINE = _MXC_BUILD_GPIO_PIN(1, 16, 2, 0xAC, 0x430),
-
-	MX33_PIN_KEY_ROW0 = _MXC_BUILD_NON_GPIO_PIN(0xB0, 0x434),
-	MX33_PIN_KEY_ROW1 = _MXC_BUILD_NON_GPIO_PIN(0xB4, 0x438),
-	MX33_PIN_KEY_ROW2 = _MXC_BUILD_NON_GPIO_PIN(0xB8, 0x43C),
-	MX33_PIN_KEY_ROW3 = _MXC_BUILD_GPIO_PIN(1, 17, 2, 0xBC, 0x440),
-	MX33_PIN_KEY_ROW4 = _MXC_BUILD_GPIO_PIN(1, 18, 2, 0xC0, 0x444),
-	MX33_PIN_KEY_ROW5 = _MXC_BUILD_GPIO_PIN(1, 19, 2, 0xC4, 0x448),
-	MX33_PIN_KEY_ROW6 = _MXC_BUILD_GPIO_PIN(1, 20, 2, 0xC8, 0x44C),
-	MX33_PIN_KEY_ROW7 = _MXC_BUILD_GPIO_PIN(1, 21, 2, 0xCC, 0x450),
-	MX33_PIN_KEY_COL0 = _MXC_BUILD_GPIO_PIN(1, 22, 2, 0xD0, 0x454),
-	MX33_PIN_KEY_COL1 = _MXC_BUILD_GPIO_PIN(1, 23, 2, 0xD4, 0x458),
-	MX33_PIN_KEY_COL2 = _MXC_BUILD_GPIO_PIN(1, 24, 2, 0xD8, 0x45C),
-	MX33_PIN_KEY_COL3 = _MXC_BUILD_GPIO_PIN(1, 25, 2, 0xDC, 0x460),
-	MX33_PIN_KEY_COL4 = _MXC_BUILD_GPIO_PIN(1, 26, 2, 0xE0, 0x464),
-	MX33_PIN_KEY_COL5 = _MXC_BUILD_GPIO_PIN(1, 27, 2, 0xE4, 0x468),
-	MX33_PIN_KEY_COL6 = _MXC_BUILD_GPIO_PIN(1, 28, 2, 0xE8, 0x46C),
-	MX33_PIN_KEY_COL7 = _MXC_BUILD_GPIO_PIN(1, 29, 2, 0xEC, 0x470),
-
-	MX33_PIN_JTAG_DE_B = _MXC_BUILD_NON_GPIO_PIN(0xF0, 0x474),
-
-	MX33_PIN_USBOTG_CLK = _MXC_BUILD_GPIO_PIN(1, 30, 2, 0xF4, 0x478),
-	MX33_PIN_USBOTG_DIR = _MXC_BUILD_GPIO_PIN(1, 31, 2, 0xF8, 0x47C),
-	MX33_PIN_USBOTG_STP = _MXC_BUILD_GPIO_PIN(3, 28, 2, 0xFC, 0x480),
-	MX33_PIN_USBOTG_NXT = _MXC_BUILD_GPIO_PIN(3, 29, 2, 0x100, 0x484),
-	MX33_PIN_USBOTG_DATA0 = _MXC_BUILD_GPIO_PIN(3, 30, 2, 0x104, 0x488),
-	MX33_PIN_USBOTG_DATA1 = _MXC_BUILD_GPIO_PIN(3, 31, 2, 0x108, 0x48C),
-	MX33_PIN_USBOTG_DATA2 = _MXC_BUILD_GPIO_PIN(2, 31, 2, 0x10C, 0x490),
-	MX33_PIN_USBOTG_DATA3 = _MXC_BUILD_GPIO_PIN(2, 20, 2, 0x110, 0x494),
-	MX33_PIN_USBOTG_DATA4 = _MXC_BUILD_GPIO_PIN(2, 0, 2, 0x114, 0x498),
-	MX33_PIN_USBOTG_DATA5 = _MXC_BUILD_GPIO_PIN(2, 1, 2, 0x118, 0x49C),
-	MX33_PIN_USBOTG_DATA6 = _MXC_BUILD_GPIO_PIN(2, 2, 2, 0x11C, 0x4A0),
-	MX33_PIN_USBOTG_DATA7 = _MXC_BUILD_GPIO_PIN(2, 3, 2, 0x120, 0x4A4),
-
-	MX33_PIN_USBH2_CLK = _MXC_BUILD_NON_GPIO_PIN(0x124, 0x4A8),
-	MX33_PIN_USBH2_DIR = _MXC_BUILD_NON_GPIO_PIN(0x128, 0x4AC),
-	MX33_PIN_USBH2_STP = _MXC_BUILD_NON_GPIO_PIN(0x12C, 0x4B0),
-	MX33_PIN_USBH2_NXT = _MXC_BUILD_NON_GPIO_PIN(0x130, 0x4B4),
-	MX33_PIN_USBH2_DATA0 = _MXC_BUILD_GPIO_PIN(2, 21, 6, 0x134, 0x4B8),
-	MX33_PIN_USBH2_DATA1 = _MXC_BUILD_GPIO_PIN(2, 4, 2, 0x138, 0x4BC),
-	MX33_PIN_USBH2_DATA2 = _MXC_BUILD_GPIO_PIN(2, 5, 2, 0x13C, 0x4C0),
-	MX33_PIN_USBH2_DATA3 = _MXC_BUILD_NON_GPIO_PIN(0x140, 0x4C4),
-	MX33_PIN_USBH2_DATA4 = _MXC_BUILD_GPIO_PIN(3, 21, 2, 0x144, 0x4C8),
-	MX33_PIN_USBH2_DATA5 = _MXC_BUILD_GPIO_PIN(3, 22, 2, 0x148, 0x4CC),
-	MX33_PIN_USBH2_DATA6 = _MXC_BUILD_GPIO_PIN(3, 23, 2, 0x14C, 0x4D0),
-	MX33_PIN_USBH2_DATA7 = _MXC_BUILD_NON_GPIO_PIN(0x150, 0x4D4),
-	MX33_PIN_USBH1_CLK = _MXC_BUILD_GPIO_PIN(2, 17, 2, 0x154, 0x4D8),
-	MX33_PIN_USBH1_DIR = _MXC_BUILD_GPIO_PIN(2, 18, 2, 0x158, 0x4DC),
-	MX33_PIN_USBH1_STP = _MXC_BUILD_GPIO_PIN(2, 19, 2, 0x15C, 0x4E0),
-	MX33_PIN_USBH1_NXT = _MXC_BUILD_GPIO_PIN(2, 22, 2, 0x160, 0x4E4),
-	MX33_PIN_USBH1_DATA0 = _MXC_BUILD_GPIO_PIN(2, 25, 3, 0x164, 0x4E8),
-	MX33_PIN_USBH1_DATA1 = _MXC_BUILD_GPIO_PIN(2, 6, 4, 0x168, 0x4EC),
-	MX33_PIN_USBH1_DATA2 = _MXC_BUILD_GPIO_PIN(2, 7, 4, 0x16C, 0x4F0),
-	MX33_PIN_USBH1_DATA3 = _MXC_BUILD_GPIO_PIN(2, 8, 4, 0x170, 0x4F4),
-	MX33_PIN_USBH1_DATA4 = _MXC_BUILD_GPIO_PIN(2, 9, 4, 0x174, 0x4F8),
-	MX33_PIN_USBH1_DATA5 = _MXC_BUILD_GPIO_PIN(2, 10, 4, 0x178, 0x4FC),
-	MX33_PIN_USBH1_DATA6 = _MXC_BUILD_GPIO_PIN(2, 11, 4, 0x17C, 0x500),
-	MX33_PIN_USBH1_DATA7 = _MXC_BUILD_GPIO_PIN(2, 12, 4, 0x180, 0x504),
-
-	MX33_PIN_DISPB2_SER_DIN = _MXC_BUILD_GPIO_PIN(2, 13, 4, 0x184, 0x508),
-	MX33_PIN_DISPB2_SER_DIO = _MXC_BUILD_GPIO_PIN(2, 14, 4, 0x188, 0x50C),
-	MX33_PIN_DISPB2_SER_CLK = _MXC_BUILD_GPIO_PIN(2, 15, 4, 0x18C, 0x510),
-	MX33_PIN_DISPB2_SER_RS = _MXC_BUILD_GPIO_PIN(2, 16, 4, 0x190, 0x514),
-	MX33_PIN_DISP1_DAT18 = _MXC_BUILD_NON_GPIO_PIN(0x194, 0x518),
-	MX33_PIN_DISP1_DAT19 = _MXC_BUILD_NON_GPIO_PIN(0x198, 0x51C),
-	MX33_PIN_DISP1_DAT20 = _MXC_BUILD_NON_GPIO_PIN(0x19C, 0x520),
-	MX33_PIN_DISP1_DAT21 = _MXC_BUILD_NON_GPIO_PIN(0x1A0, 0x524),
-	MX33_PIN_DISP1_DAT22 = _MXC_BUILD_GPIO_PIN(2, 26, 4, 0x1A4, 0x528),
-	MX33_PIN_DISP1_DAT23 = _MXC_BUILD_GPIO_PIN(2, 27, 4, 0x1A8, 0x52C),
-
-	/* TODO::
-	 * There are two pins which must configure PAD but it is not muxing.
-	 * So I hope it is configured in bootloader.
-	 */
-	MX33_PIN_SD1_CMD = _MXC_BUILD_NON_GPIO_PIN(0x1AC, 0x538),
-	MX33_PIN_SD1_CLK = _MXC_BUILD_NON_GPIO_PIN(0x1B0, 0x53C),
-	MX33_PIN_SD1_DATA0 = _MXC_BUILD_NON_GPIO_PIN(0x1B4, 0x540),
-	MX33_PIN_SD1_DATA1 = _MXC_BUILD_GPIO_PIN(2, 23, 4, 0x1B8, 0x544),
-	MX33_PIN_SD1_DATA2 = _MXC_BUILD_GPIO_PIN(2, 24, 4, 0x1BC, 0x548),
-	MX33_PIN_SD1_DATA3 = _MXC_BUILD_NON_GPIO_PIN(0x1C0, 0x54C),
-	MX33_PIN_SD2_CMD = _MXC_BUILD_NON_GPIO_PIN(0x1C4, 0x550),
-	MX33_PIN_SD2_CLK = _MXC_BUILD_NON_GPIO_PIN(0x1C8, 0x554),
-	MX33_PIN_SD2_DATA0 = _MXC_BUILD_GPIO_PIN(3, 24, 4, 0x1CC, 0x558),
-	MX33_PIN_SD2_DATA1 = _MXC_BUILD_GPIO_PIN(3, 25, 4, 0x1D0, 0x55C),
-	MX33_PIN_SD2_DATA2 = _MXC_BUILD_GPIO_PIN(3, 26, 4, 0x1D4, 0x560),
-	MX33_PIN_SD2_DATA3 = _MXC_BUILD_GPIO_PIN(3, 27, 4, 0x1D8, 0x564),
-	MX33_PIN_SD3_CMD = _MXC_BUILD_NON_GPIO_PIN(0x1DC, 0x568),
-	MX33_PIN_SD3_CLK = _MXC_BUILD_NON_GPIO_PIN(0x1E0, 0x56C),
-	MX33_PIN_SD3_DATA0 = _MXC_BUILD_NON_GPIO_PIN(0x1E4, 0x570),
-	MX33_PIN_SD3_DATA1 = _MXC_BUILD_GPIO_PIN(2, 29, 4, 0x1E8, 0x574),
-	MX33_PIN_SD3_DATA2 = _MXC_BUILD_GPIO_PIN(2, 30, 4, 0x1EC, 0x578),
-	MX33_PIN_SD3_DATA3 = _MXC_BUILD_NON_GPIO_PIN(0x1F0, 0x57C),
-	MX33_PIN_SD3_DATA4 = _MXC_BUILD_GPIO_PIN(3, 0, 4, 0x1F4, 0x580),
-	MX33_PIN_SD3_DATA5 = _MXC_BUILD_GPIO_PIN(3, 1, 4, 0x1F8, 0x584),
-	MX33_PIN_SD3_DATA6 = _MXC_BUILD_GPIO_PIN(3, 2, 4, 0x1FC, 0x588),
-	MX33_PIN_SD3_DATA7 = _MXC_BUILD_GPIO_PIN(3, 3, 4, 0x200, 0x58C),
-
-	MX33_PIN_ATA_CS0 = _MXC_BUILD_GPIO_PIN(3, 4, 4, 0x204, 0x590),
-	MX33_PIN_ATA_CS1 = _MXC_BUILD_GPIO_PIN(3, 5, 4, 0x208, 0x594),
-	MX33_PIN_ATA_DIOR = _MXC_BUILD_GPIO_PIN(3, 6, 4, 0x20C, 0x598),
-	MX33_PIN_ATA_DIOW = _MXC_BUILD_GPIO_PIN(3, 7, 4, 0x210, 0x59C),
-	MX33_PIN_ATA_DMACK = _MXC_BUILD_GPIO_PIN(3, 8, 4, 0x214, 0x5A0),
-	MX33_PIN_ATA_RESET_B = _MXC_BUILD_GPIO_PIN(3, 9, 4, 0x218, 0x5A4),
-
-	MX33_PIN_CLKO = _MXC_BUILD_NON_GPIO_PIN(0x21C, 0x5A8),
-
-	/* TODO:: PMIC pin just has PAD register 0x05AC */
-
-	MX33_PIN_CLK_SS = _MXC_BUILD_GPIO_PIN(3, 10, 0, 0x220, 0x5B0),
-
-	MX33_PIN_ATA_IORDY = _MXC_BUILD_GPIO_PIN(3, 11, 4, 0x224, 0x5B4),
-
-	MX33_PIN_TIM_CAPTURE = _MXC_BUILD_GPIO_PIN(3, 12, 4, 0x228, 0x5B8),
-	MX33_PIN_TIM_COMPARE = _MXC_BUILD_GPIO_PIN(3, 13, 4, 0x22C, 0x5BC),
-
-	MX33_PIN_WDOG_RST = _MXC_BUILD_GPIO_PIN(2, 28, 4, 0x230, 0x5C0),
-
-	MX33_PIN_PWMO = _MXC_BUILD_GPIO_PIN(3, 14, 4, 0x234, 0x5C4),
-
-	MX33_PIN_GPIO1_0 = _MXC_BUILD_GPIO_PIN(0, 0, 0, 0x238, 0x5C8),
-	MX33_PIN_GPIO1_1 = _MXC_BUILD_GPIO_PIN(0, 1, 0, 0x23C, 0x5CC),
-	MX33_PIN_GPIO1_2 = _MXC_BUILD_GPIO_PIN(0, 2, 0, 0x240, 0x5D0),
-	MX33_PIN_GPIO1_3 = _MXC_BUILD_GPIO_PIN(0, 3, 0, 0x244, 0x5D4),
-	MX33_PIN_GPIO1_4 = _MXC_BUILD_GPIO_PIN(0, 4, 0, 0x248, 0x5D8),
-	MX33_PIN_GPIO1_5 = _MXC_BUILD_GPIO_PIN(0, 5, 0, 0x24C, 0x5DC),
-	MX33_PIN_GPIO1_6 = _MXC_BUILD_GPIO_PIN(0, 6, 0, 0x250, 0x5E0),
-	MX33_PIN_GPIO1_7 = _MXC_BUILD_GPIO_PIN(0, 7, 1, 0x254, NO_PAD),
-	MX33_PIN_GPIO1_8 = _MXC_BUILD_GPIO_PIN(0, 8, 0, 0x258, 0x5E4),
-
-	MX33_PIN_SIM_CLK = _MXC_BUILD_GPIO_PIN(3, 15, 2, 0x25C, 0x5E8),
-	MX33_PIN_SIM_RST = _MXC_BUILD_GPIO_PIN(3, 16, 2, 0x260, NO_PAD),
-	MX33_PIN_SIM_VEN = _MXC_BUILD_GPIO_PIN(3, 17, 2, 0x264, NO_PAD),
-	MX33_PIN_SIM_TX = _MXC_BUILD_GPIO_PIN(3, 18, 2, 0x268, 0x5EC),
-	MX33_PIN_SIM_RX = _MXC_BUILD_GPIO_PIN(3, 19, 2, 0x26C, 0x5F0),
-	MX33_PIN_SIM_PD = _MXC_BUILD_GPIO_PIN(3, 20, 2, 0x270, 0x5F4)
-} iomux_pin_name_t;
-
-#endif
-#endif
-- 
1.5.4.4

