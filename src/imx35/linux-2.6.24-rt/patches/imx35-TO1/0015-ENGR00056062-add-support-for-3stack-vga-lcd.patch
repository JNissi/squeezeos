From ea51d810fd7ff9ba88fb87a1c51ce9584e1b6853 Mon Sep 17 00:00:00 2001
From: Rob Herring <ra7055@freescale.com>
Date: Tue, 22 Jan 2008 15:30:02 -0600
Subject: [PATCH] ENGR00056062 add support for 3stack vga lcd

This patch adds support for MX31 3-stack board Epson VGA LCD.
---
 arch/arm/mach-mx3/mx3_3stack.c      |   17 +++-
 drivers/mxc/ipu/ipu_sdc.c           |   16 ++-
 drivers/video/mxc/Kconfig           |    5 +
 drivers/video/mxc/Makefile          |    1 +
 drivers/video/mxc/mxcfb.c           |   11 +-
 drivers/video/mxc/mxcfb_epson_vga.c |  245 +++++++++++++++++++++++++++++++++++
 6 files changed, 283 insertions(+), 12 deletions(-)

diff --git a/arch/arm/mach-mx3/mx3_3stack.c b/arch/arm/mach-mx3/mx3_3stack.c
index ed7b662..47c9967 100644
--- a/arch/arm/mach-mx3/mx3_3stack.c
+++ b/arch/arm/mach-mx3/mx3_3stack.c
@@ -20,6 +20,7 @@
 
 #include <linux/types.h>
 #include <linux/sched.h>
+#include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/init.h>
@@ -186,6 +187,19 @@ static inline void mxc_init_nand_mtd(void)
 }
 #endif
 
+static void lcd_reset(void)
+{
+	/* ensure that LCDIO(1.8V) has been turn on */
+	/* active reset line GPIO */
+	mxc_request_iomux(MX31_PIN_LCS1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_set_gpio_dataout(MX31_PIN_LCS1, 0);
+	mxc_set_gpio_direction(MX31_PIN_LCS1, 0);
+	/* do reset */
+	msleep(10);		/* tRES >= 100us */
+	mxc_set_gpio_dataout(MX31_PIN_LCS1, 1);
+	msleep(60);
+}
+
 static struct spi_board_info mxc_spi_board_info[] __initdata = {
 	{
 	 .modalias = "pmic_spi",
@@ -195,7 +209,8 @@ static struct spi_board_info mxc_spi_board_info[] __initdata = {
 	 .chip_select = 2,},
 	{
 	 .modalias = "lcd_spi",
-	 .max_speed_hz = 500000,
+	 .platform_data = (void *)lcd_reset,
+	 .max_speed_hz = 5000000,
 	 .bus_num = 1,
 	 .chip_select = 2,},
 };
diff --git a/drivers/mxc/ipu/ipu_sdc.c b/drivers/mxc/ipu/ipu_sdc.c
index 6feb24d..6636146 100644
--- a/drivers/mxc/ipu/ipu_sdc.c
+++ b/drivers/mxc/ipu/ipu_sdc.c
@@ -79,7 +79,7 @@ int32_t ipu_sdc_init_panel(ipu_panel_t panel,
 			   uint32_t pixel_fmt,
 			   uint16_t h_start_width, uint16_t h_sync_width,
 			   uint16_t h_end_width, uint16_t v_start_width,
-			   uint16_t vSyncWidth, uint16_t v_end_width,
+			   uint16_t v_sync_width, uint16_t v_end_width,
 			   ipu_di_signal_cfg_t sig)
 {
 	unsigned long lock_flags;
@@ -89,21 +89,23 @@ int32_t ipu_sdc_init_panel(ipu_panel_t panel,
 
 	dev_dbg(g_ipu_dev, "panel size = %d x %d\n", width, height);
 
-	if ((vSyncWidth == 0) || (h_sync_width == 0))
+	if ((v_sync_width == 0) || (h_sync_width == 0))
 		return EINVAL;
 
 	/* Init panel size and blanking periods */
 	reg =
 	    ((uint32_t) (h_sync_width - 1) << 26) |
-	    ((uint32_t) (width + h_start_width + h_end_width - 1) << 16);
+	    ((uint32_t) (width + h_sync_width + h_start_width + h_end_width - 1)
+	     << 16);
 	__raw_writel(reg, SDC_HOR_CONF);
 
-	reg = ((uint32_t) (vSyncWidth - 1) << 26) | SDC_V_SYNC_WIDTH_L |
-	    ((uint32_t) (height + v_start_width + v_end_width - 1) << 16);
+	reg = ((uint32_t) (v_sync_width - 1) << 26) | SDC_V_SYNC_WIDTH_L |
+	    ((uint32_t)
+	     (height + v_sync_width + v_start_width + v_end_width - 1) << 16);
 	__raw_writel(reg, SDC_VER_CONF);
 
-	g_h_start_width = h_start_width;
-	g_v_start_width = v_start_width;
+	g_h_start_width = h_start_width + h_sync_width;
+	g_v_start_width = v_start_width + v_sync_width;
 
 	switch (panel) {
 	case IPU_PANEL_SHARP_TFT:
diff --git a/drivers/video/mxc/Kconfig b/drivers/video/mxc/Kconfig
index 48be110..5a2c8c2 100644
--- a/drivers/video/mxc/Kconfig
+++ b/drivers/video/mxc/Kconfig
@@ -18,6 +18,11 @@ config FB_MXC_SYNC_PANEL
 	tristate "Synchronous Panel Framebuffer"
 	default y
 
+config FB_MXC_EPSON_VGA_SYNC_PANEL
+	depends on FB_MXC_SYNC_PANEL
+	tristate "Epson VGA Panel"
+	default n
+
 config FB_MXC_TVOUT
 	bool "TV Out Encoder"
 	depends on FB_MXC_SYNC_PANEL
diff --git a/drivers/video/mxc/Makefile b/drivers/video/mxc/Makefile
index c0ef8ad..6851ac0 100644
--- a/drivers/video/mxc/Makefile
+++ b/drivers/video/mxc/Makefile
@@ -10,3 +10,4 @@ else
 	obj-$(CONFIG_FB_MXC_TOSHIBA_QVGA_PANEL) += mxcfb_toshiba_qvga.o
 	obj-$(CONFIG_FB_MXC_SHARP_128_PANEL)    += mxcfb_sharp_128x128.o
 endif
+obj-$(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL)   += mxcfb_epson_vga.o
diff --git a/drivers/video/mxc/mxcfb.c b/drivers/video/mxc/mxcfb.c
index ba631c1..8bd0685 100644
--- a/drivers/video/mxc/mxcfb.c
+++ b/drivers/video/mxc/mxcfb.c
@@ -229,16 +229,18 @@ static int mxcfb_set_par(struct fb_info *fbi)
 				       IPU_PIX_FMT_BGR666 : IPU_PIX_FMT_RGB666,
 				       fbi->var.left_margin,
 				       fbi->var.hsync_len,
-				       fbi->var.right_margin +
-				       fbi->var.hsync_len,
+				       fbi->var.right_margin,
 				       fbi->var.upper_margin,
 				       fbi->var.vsync_len,
-				       fbi->var.lower_margin +
-				       fbi->var.vsync_len, sig_cfg) != 0) {
+				       fbi->var.lower_margin, sig_cfg) != 0) {
 			dev_err(fbi->device,
 				"mxcfb: Error initializing panel.\n");
 			return -EINVAL;
 		}
+
+		fbi->mode =
+		    (struct fb_videomode *)fb_match_mode(&fbi->var,
+							 &fbi->modelist);
 	}
 
 	ipu_sdc_set_window_pos(mxc_fbi->ipu_ch, 0, 0);
@@ -1473,4 +1475,5 @@ module_exit(mxcfb_exit);
 
 MODULE_AUTHOR("Freescale Semiconductor, Inc.");
 MODULE_DESCRIPTION("MXC framebuffer driver");
+MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("fb");
diff --git a/drivers/video/mxc/mxcfb_epson_vga.c b/drivers/video/mxc/mxcfb_epson_vga.c
new file mode 100644
index 0000000..276e861
--- /dev/null
+++ b/drivers/video/mxc/mxcfb_epson_vga.c
@@ -0,0 +1,245 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxcfb_epson_vga.c
+ *
+ * @brief MXC Frame buffer driver for SDC
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/spi/spi.h>
+#include <asm/arch/mxcfb.h>
+#include <asm/arch/pmic_power.h>
+
+static struct spi_device *lcd_spi;
+
+static void lcd_init(void);
+static void lcd_poweron(void);
+static void lcd_poweroff(void);
+
+static void (*lcd_reset) (void);
+
+static struct fb_videomode video_modes[] = {
+	{
+	 /* 480x640 @ 60 Hz */
+	 "Epson-VGA", 60, 480, 640, 41701, 0, 41, 10, 5, 20, 10,
+	 FB_SYNC_CLK_INVERT,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+};
+
+static void lcd_init_fb(struct fb_info *info)
+{
+	struct fb_var_screeninfo var;
+
+	memset(&var, 0, sizeof(var));
+
+	fb_videomode_to_var(&var, &video_modes[0]);
+
+	var.activate = FB_ACTIVATE_ALL;
+	var.yres_virtual = var.yres * 2;
+
+	acquire_console_sem();
+	info->flags |= FBINFO_MISC_USEREVENT;
+	fb_set_var(info, &var);
+	info->flags &= ~FBINFO_MISC_USEREVENT;
+	release_console_sem();
+}
+
+static int lcd_fb_event(struct notifier_block *nb, unsigned long val, void *v)
+{
+	struct fb_event *event = v;
+
+	if (strcmp(event->info->fix.id, "DISP3 BG")) {
+		return 0;
+	}
+
+	switch (val) {
+	case FB_EVENT_FB_REGISTERED:
+		lcd_init_fb(event->info);
+		lcd_poweron();
+		break;
+	case FB_EVENT_BLANK:
+		if ((event->info->var.xres != 480) ||
+		    (event->info->var.yres != 640)) {
+			break;
+		}
+		if (*((int *)event->data) == FB_BLANK_UNBLANK) {
+			lcd_poweron();
+		} else {
+			lcd_poweroff();
+		}
+		break;
+	}
+	return 0;
+}
+
+static struct notifier_block nb = {
+	.notifier_call = lcd_fb_event,
+};
+
+/*!
+ * This function is called whenever the SPI slave device is detected.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return 	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int __devinit lcd_spi_probe(struct spi_device *spi)
+{
+	int i;
+	t_regulator_voltage voltage;
+	t_regulator_lp_mode lpmode = LOW_POWER_CTRL_BY_PIN;
+
+	lcd_spi = spi;
+
+	/* open the VGEN of pmic to supply VDDI */
+	voltage.vgen = VGEN_1_8V;
+	pmic_power_regulator_set_voltage(REGU_VGEN, voltage);
+	pmic_power_regulator_set_lp_mode(REGU_VGEN, lpmode);
+	pmic_power_regulator_on(REGU_VGEN);
+
+	/* open the VMMC1 of pmic to supply VDDI */
+	voltage.vmmc1 = VMMC_2_8V;
+	pmic_power_regulator_set_voltage(REGU_VMMC1, voltage);
+	pmic_power_regulator_set_lp_mode(REGU_VMMC1, lpmode);
+	pmic_power_regulator_on(REGU_VMMC1);
+
+	if (spi->dev.platform_data) {
+		lcd_reset = (void (*)(void))spi->dev.platform_data;
+		lcd_reset();
+	}
+
+	spi->bits_per_word = 9;
+	spi_setup(spi);
+
+	lcd_init();
+
+	for (i = 0; i < num_registered_fb; i++) {
+		if (strcmp(registered_fb[i]->fix.id, "DISP3 BG") == 0) {
+			lcd_init_fb(registered_fb[i]);
+			fb_show_logo(registered_fb[i], 0);
+			lcd_poweron();
+		}
+	}
+
+	fb_register_client(&nb);
+
+	return 0;
+}
+
+static int __devexit lcd_spi_remove(struct spi_device *spi)
+{
+	fb_unregister_client(&nb);
+	lcd_poweroff();
+	return 0;
+}
+
+/*!
+ * spi driver structure for LTV350QV
+ */
+static struct spi_driver lcd_spi_dev_driver = {
+
+	.driver = {
+		   .name = "lcd_spi",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = lcd_spi_probe,
+	.remove = __devexit_p(lcd_spi_remove),
+};
+
+#define param(x) ((x) | 0x100)
+
+/*
+ * Send init commands to L4F00242T03
+ *
+ */
+static void lcd_init(void)
+{
+	const u16 cmd[] = { 0x36, param(0), 0x3A, param(0x60) };
+
+	dev_dbg(&lcd_spi->dev, "initializing LCD\n");
+	spi_write(lcd_spi, (const u8 *)cmd, ARRAY_SIZE(cmd));
+}
+
+static int lcd_on;
+/*
+ * Send Power On commands to L4F00242T03
+ *
+ */
+static void lcd_poweron(void)
+{
+	const u16 slpout = 0x11;
+	const u16 dison = 0x29;
+
+	if (lcd_on)
+		return;
+
+	dev_dbg(&lcd_spi->dev, "turning on LCD\n");
+	spi_write(lcd_spi, (const u8 *)&slpout, 1);
+	msleep(60);
+	spi_write(lcd_spi, (const u8 *)&dison, 1);
+	lcd_on = 1;
+}
+
+/*
+ * Send Power Off commands to L4F00242T03
+ *
+ */
+static void lcd_poweroff(void)
+{
+	const u16 slpin = 0x10;
+	const u16 disoff = 0x28;
+
+	if (!lcd_on)
+		return;
+
+	dev_dbg(&lcd_spi->dev, "turning off LCD\n");
+	spi_write(lcd_spi, (const u8 *)&disoff, 1);
+	msleep(60);
+	spi_write(lcd_spi, (const u8 *)&slpin, 1);
+	lcd_on = 0;
+}
+
+static int __init epson_lcd_init(void)
+{
+	return spi_register_driver(&lcd_spi_dev_driver);
+}
+
+static void __exit epson_lcd_exit(void)
+{
+	spi_unregister_driver(&lcd_spi_dev_driver);
+}
+
+module_init(epson_lcd_init);
+module_exit(epson_lcd_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Epson VGA LCD init driver");
+MODULE_LICENSE("GPL");
-- 
1.5.4.4

