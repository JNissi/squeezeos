From 85aa1c160e635458a6126014f529d030186836d8 Mon Sep 17 00:00:00 2001
From: Rob Herring <r.herring@freescale.com>
Date: Mon, 17 Mar 2008 11:06:39 -0500
Subject: [PATCH] ENGR00057358 Add IPUv3 driver with fb and v4l2 support

Add IPUv3 driver
Update framebuffer driver for IPUv3
Update V4L2 output driver for IPUv3

Signed-off-by: Rob Herring <r.herring@freescale.com>
---
 arch/arm/configs/imx31_3stack_defconfig          |    5 +-
 arch/arm/configs/imx31ads_defconfig              |    5 +-
 arch/arm/configs/imx37_3stack_defconfig          |  130 ++-
 arch/arm/configs/mxc30030evb_defconfig           |   16 +-
 arch/arm/mach-mx37/devices.c                     |    5 +-
 arch/arm/mach-mx37/mx37_3stack.c                 |   75 ++-
 drivers/media/video/mxc/output/mxc_v4l2_output.c |  109 ++-
 drivers/media/video/mxc/output/mxc_v4l2_output.h |    4 +-
 drivers/mxc/Kconfig                              |   12 +
 drivers/mxc/Makefile                             |    3 +-
 drivers/mxc/ipu/Kconfig                          |   16 +-
 drivers/mxc/ipu/Makefile                         |    2 +-
 drivers/mxc/ipu/pf/Kconfig                       |    2 +-
 drivers/mxc/ipu3/Kconfig                         |    3 +
 drivers/mxc/ipu3/Makefile                        |    4 +
 drivers/mxc/ipu3/ipu_common.c                    | 1331 ++++++++++++++++++++++
 drivers/mxc/ipu3/ipu_disp.c                      |  902 +++++++++++++++
 drivers/mxc/ipu3/ipu_ic.c                        |  550 +++++++++
 drivers/mxc/ipu3/ipu_param_mem.h                 |  315 +++++
 drivers/mxc/ipu3/ipu_prv.h                       |   76 ++
 drivers/mxc/ipu3/ipu_regs.h                      |  431 +++++++
 drivers/regulator/wm8350/reg-wm8350-i2c.c        |    2 +-
 drivers/video/backlight/Kconfig                  |    4 +-
 drivers/video/mxc/Kconfig                        |   17 -
 drivers/video/mxc/Makefile                       |    6 +-
 drivers/video/mxc/mxc_ipuv3_fb.c                 | 1126 ++++++++++++++++++
 drivers/video/mxc/mxcfb.c                        |    7 +-
 drivers/video/mxc/mxcfb_epson_vga.c              |   19 +-
 include/asm-arm/arch-mxc/ipu.h                   |  220 +++-
 include/asm-arm/arch-mxc/mx37.h                  |    1 +
 30 files changed, 5236 insertions(+), 162 deletions(-)

diff --git a/arch/arm/configs/imx31_3stack_defconfig b/arch/arm/configs/imx31_3stack_defconfig
index 7f1380c..a7c37ac 100644
--- a/arch/arm/configs/imx31_3stack_defconfig
+++ b/arch/arm/configs/imx31_3stack_defconfig
@@ -1293,11 +1293,8 @@ CONFIG_RTC_MXC=y
 #
 # MXC support drivers
 #
-
-#
-# MXC IPU
-#
 CONFIG_MXC_IPU=y
+CONFIG_MXC_IPU_V1=y
 CONFIG_MXC_IPU_PF=y
 
 #
diff --git a/arch/arm/configs/imx31ads_defconfig b/arch/arm/configs/imx31ads_defconfig
index 4127cd2..9edae21 100644
--- a/arch/arm/configs/imx31ads_defconfig
+++ b/arch/arm/configs/imx31ads_defconfig
@@ -1591,11 +1591,8 @@ CONFIG_RTC_MXC=y
 #
 # MXC support drivers
 #
-
-#
-# MXC IPU
-#
 CONFIG_MXC_IPU=y
+CONFIG_MXC_IPU_V1=y
 CONFIG_MXC_IPU_PF=y
 
 #
diff --git a/arch/arm/configs/imx37_3stack_defconfig b/arch/arm/configs/imx37_3stack_defconfig
index 212b7fb..d1efb8e 100644
--- a/arch/arm/configs/imx37_3stack_defconfig
+++ b/arch/arm/configs/imx37_3stack_defconfig
@@ -1,7 +1,6 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.24
-# Sat Mar 15 22:18:33 2008
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -776,7 +775,78 @@ CONFIG_SSB_POSSIBLE=y
 #
 # Multimedia devices
 #
-# CONFIG_VIDEO_DEV is not set
+CONFIG_VIDEO_DEV=y
+# CONFIG_VIDEO_V4L1 is not set
+# CONFIG_VIDEO_V4L1_COMPAT is not set
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+
+#
+# Encoders/decoders and other helper chips
+#
+
+#
+# Audio decoders
+#
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_TCM825X is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_MXC_CAMERA is not set
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_IPU_OUTPUT=y
+# CONFIG_VIDEO_MXC_OPL is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_RADIO_CADET is not set
+# CONFIG_RADIO_RTRACK is not set
+# CONFIG_RADIO_RTRACK2 is not set
+# CONFIG_RADIO_AZTECH is not set
+# CONFIG_RADIO_GEMTEK is not set
+# CONFIG_RADIO_SF16FMI is not set
+# CONFIG_RADIO_SF16FMR2 is not set
+# CONFIG_RADIO_TERRATEC is not set
+# CONFIG_RADIO_TRUST is not set
+# CONFIG_RADIO_TYPHOON is not set
+# CONFIG_RADIO_ZOLTRIX is not set
 # CONFIG_DVB_CORE is not set
 # CONFIG_DAB is not set
 
@@ -785,7 +855,35 @@ CONFIG_SSB_POSSIBLE=y
 #
 # CONFIG_VGASTATE is not set
 # CONFIG_VIDEO_OUTPUT_CONTROL is not set
-# CONFIG_FB is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_MXC=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL=y
+# CONFIG_FB_MXC_TVOUT is not set
+# CONFIG_FB_MXC_ASYNC_PANEL is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
 CONFIG_BACKLIGHT_LCD_SUPPORT=y
 CONFIG_LCD_CLASS_DEVICE=y
 # CONFIG_LCD_LTV350QV is not set
@@ -805,6 +903,24 @@ CONFIG_BACKLIGHT_WM8350=y
 # CONFIG_VGA_CONSOLE is not set
 # CONFIG_MDA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
 
 #
 # Sound
@@ -949,11 +1065,8 @@ CONFIG_RTC_DRV_MXC_V2=y
 #
 # MXC support drivers
 #
-
-#
-# MXC IPU
-#
-# CONFIG_MXC_IPU is not set
+CONFIG_MXC_IPU=y
+CONFIG_MXC_IPU_V3=y
 
 #
 # MXC SSI support
@@ -991,7 +1104,6 @@ CONFIG_RTC_DRV_MXC_V2=y
 # MXC HARDWARE EVENT
 #
 CONFIG_MXC_HWEVENT=y
-
 #
 # MXC VPU(Video Processing Unit) support
 #
diff --git a/arch/arm/configs/mxc30030evb_defconfig b/arch/arm/configs/mxc30030evb_defconfig
index b106925..24683a2 100644
--- a/arch/arm/configs/mxc30030evb_defconfig
+++ b/arch/arm/configs/mxc30030evb_defconfig
@@ -167,6 +167,7 @@ CONFIG_MACH_MXC30030EVB=y
 # CONFIG_MACH_MXC30030ADS is not set
 CONFIG_MXC_DSP_BRINGUP=y
 CONFIG_ARCH_HAS_EVTMON=y
+CONFIG_DMA_ZONE_SIZE=24
 
 #
 # Processor Type
@@ -413,12 +414,6 @@ CONFIG_FW_LOADER=m
 # CONFIG_SYS_HYPERVISOR is not set
 CONFIG_CONNECTOR=y
 CONFIG_PROC_EVENTS=y
-
-#
-# Power Management IC's
-#
-# CONFIG_PMIC is not set
-# CONFIG_PMIC_WM8350 is not set
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
 # CONFIG_MTD_CONCAT is not set
@@ -831,6 +826,7 @@ CONFIG_VIDEO_MXC_CAMERA=y
 CONFIG_VIDEO_MXC_IPU_CAMERA=y
 # CONFIG_MXC_CAMERA_MC521DA is not set
 CONFIG_MXC_CAMERA_MICRON111=y
+# CONFIG_MXC_CAMERA_OV2640 is not set
 CONFIG_MXC_IPU_PRP_VF_SDC=y
 CONFIG_MXC_IPU_PRP_ENC=y
 CONFIG_VIDEO_MXC_OUTPUT=y
@@ -969,7 +965,7 @@ CONFIG_SND_MXC_PMIC=y
 # SoC Audio support for SuperH
 #
 # CONFIG_SND_MXC_SOC is not set
-# CONFIG_SND_SOC_IMX37_3STACK_WM8350 is not set
+# CONFIG_SND_SOC_IMX_3STACK_WM8350 is not set
 
 #
 # Open Sound System
@@ -1197,15 +1193,13 @@ CONFIG_RTC_INTF_DEV=y
 # on-CPU RTC drivers
 #
 CONFIG_RTC_MXC=y
+# CONFIG_RTC_DRV_MXC_V2 is not set
 
 #
 # MXC support drivers
 #
-
-#
-# MXC IPU
-#
 CONFIG_MXC_IPU=y
+CONFIG_MXC_IPU_V1=y
 CONFIG_MXC_IPU_PF=y
 
 #
diff --git a/arch/arm/mach-mx37/devices.c b/arch/arm/mach-mx37/devices.c
index d534560..7b00b2b 100644
--- a/arch/arm/mach-mx37/devices.c
+++ b/arch/arm/mach-mx37/devices.c
@@ -152,7 +152,10 @@ static inline void mxc_init_wdt(void)
 }
 #endif
 
-#if defined(CONFIG_MXC_IPU) || defined(CONFIG_MXC_IPU_MODULE)
+#if defined(CONFIG_MXC_IPU_V3) || defined(CONFIG_MXC_IPU_V3_MODULE)
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 1,
+};
 
 static struct resource ipu_resources[] = {
 	{
diff --git a/arch/arm/mach-mx37/mx37_3stack.c b/arch/arm/mach-mx37/mx37_3stack.c
index cb61c40..392295a 100644
--- a/arch/arm/mach-mx37/mx37_3stack.c
+++ b/arch/arm/mach-mx37/mx37_3stack.c
@@ -13,6 +13,7 @@
 
 #include <linux/types.h>
 #include <linux/sched.h>
+#include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/init.h>
@@ -38,6 +39,7 @@
 #include <asm/arch/memory.h>
 #include <asm/arch/gpio.h>
 #include "board-mx37_3stack.h"
+#include "iomux.h"
 #include "crm_regs.h"
 
 /*!
@@ -129,6 +131,30 @@ static inline void mxc_init_nand_mtd(void)
 }
 #endif
 
+static void lcd_reset(void)
+{
+	static int first;
+
+	/* ensure that LCDIO(1.8V) has been turn on */
+	/* active reset line GPIO */
+	if (!first) {
+		mxc_request_iomux(MX37_PIN_GPIO1_5, IOMUX_CONFIG_GPIO);
+		first = 1;
+	}
+	mxc_set_gpio_dataout(MX37_PIN_GPIO1_5, 0);
+	mxc_set_gpio_direction(MX37_PIN_GPIO1_5, 0);
+	/* do reset */
+	msleep(10);		/* tRES >= 100us */
+	mxc_set_gpio_dataout(MX37_PIN_GPIO1_5, 1);
+	msleep(60);
+}
+
+static struct mxc_lcd_platform_data lcd_data = {
+	.core_reg = "LDO1",
+	.io_reg = "DCDC6",
+	.reset = lcd_reset,
+};
+
 static struct spi_board_info mxc_spi_board_info[] __initdata = {
 	{
 	 .modalias = "cpld_spi",
@@ -138,11 +164,52 @@ static struct spi_board_info mxc_spi_board_info[] __initdata = {
 	 },
 	{
 	 .modalias = "lcd_spi",
-	 .max_speed_hz = 500000,
-	 .bus_num = 1,
-	 .chip_select = 2,},
+	 .max_speed_hz = 5000000,
+	 .bus_num = 2,
+	 .platform_data = &lcd_data,
+	 .chip_select = 1,},
 };
 
+#if defined(CONFIG_FB_MXC_SYNC_PANEL) || defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
+static struct platform_device mxc_fb_device[] = {
+	{
+	 .name = "mxc_sdc_fb",
+	 .id = 0,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .coherent_dma_mask = 0xFFFFFFFF,
+		 },
+	 },
+	{
+	 .name = "mxc_sdc_fb",
+	 .id = 1,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .coherent_dma_mask = 0xFFFFFFFF,
+		 },
+	 },
+	{
+	 .name = "mxc_sdc_fb",
+	 .id = 2,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .coherent_dma_mask = 0xFFFFFFFF,
+		 },
+	 },
+};
+
+static void mxc_init_fb(void)
+{
+	(void)platform_device_register(&mxc_fb_device[0]);
+	(void)platform_device_register(&mxc_fb_device[1]);
+	(void)platform_device_register(&mxc_fb_device[2]);
+}
+#else
+static inline void mxc_init_fb(void)
+{
+}
+#endif
+
 /*lan9217 device*/
 #if defined(CONFIG_SMSC911X) || defined(CONFIG_SMSC911X_MODULE)
 static struct resource smsc911x_resources[] = {
@@ -219,6 +286,8 @@ static void __init mxc_board_init(void)
 	spi_register_board_info(mxc_spi_board_info,
 				ARRAY_SIZE(mxc_spi_board_info));
 	mxc_init_nand_mtd();
+
+	mxc_init_fb();
 }
 
 /*
diff --git a/drivers/media/video/mxc/output/mxc_v4l2_output.c b/drivers/media/video/mxc/output/mxc_v4l2_output.c
index 459a612..a1278a4 100644
--- a/drivers/media/video/mxc/output/mxc_v4l2_output.c
+++ b/drivers/media/video/mxc/output/mxc_v4l2_output.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -220,6 +220,22 @@ static u32 fmt_to_bpp(u32 pixelformat)
 	return bpp;
 }
 
+static u32 bpp_to_fmt(struct fb_info *fbi)
+{
+	if (fbi->var.nonstd)
+		return fbi->var.nonstd;
+
+	if (fbi->var.bits_per_pixel == 24)
+		return V4L2_PIX_FMT_BGR24;
+	else if (fbi->var.bits_per_pixel == 32)
+		return V4L2_PIX_FMT_BGR32;
+	else if (fbi->var.bits_per_pixel == 16)
+		return V4L2_PIX_FMT_RGB565;
+
+	return 0;
+}
+
+
 static void mxc_v4l2out_timer_handler(unsigned long arg)
 {
 	int index;
@@ -406,7 +422,8 @@ static int mxc_v4l2out_streamon(vout_data * vout)
 #ifdef CONFIG_FB_MXC_ASYNC_PANEL
 	if (vout->cur_disp_output < DISP3) {
 		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_OFF, 0);
-		if (vout->rotate < IPU_ROTATE_90_RIGHT) {
+		fbi = NULL;
+		if (ipu_can_rotate_in_place(vout->rotate)) {
 			dev_dbg(dev, "Using PP direct to ADC channel\n");
 			use_direct_adc = true;
 			vout->display_ch = MEM_PP_ADC;
@@ -519,11 +536,30 @@ static int mxc_v4l2out_streamon(vout_data * vout)
 		dev_dbg(dev, "Using SDC channel\n");
 
 		fbvar = fbi->var;
-		fbvar.xres = fbvar.xres_virtual = out_width;
-		fbvar.yres = out_height;
-		fbvar.yres_virtual = out_height * 2;
-		fbvar.bits_per_pixel = 16;
-		fb_set_var(fbi, &fbvar);
+
+		if (vout->cur_disp_output == 3) {
+			vout->display_ch = MEM_FG_SYNC;
+			fbvar.bits_per_pixel = 16;
+			fbvar.nonstd = IPU_PIX_FMT_UYVY;
+
+			fbvar.xres = fbvar.xres_virtual = out_width;
+			fbvar.yres = out_height;
+			fbvar.yres_virtual = out_height * 2;
+
+			fb_set_var(fbi, &fbvar);
+		} else if (vout->cur_disp_output == 5) {
+			vout->display_ch = MEM_DC_SYNC;
+			fbvar.bits_per_pixel = 16;
+			fbvar.nonstd = IPU_PIX_FMT_UYVY;
+
+			fbvar.xres = fbvar.xres_virtual = out_width;
+			fbvar.yres = out_height;
+			fbvar.yres_virtual = out_height * 2;
+
+			fb_set_var(fbi, &fbvar);
+		} else {
+			vout->display_ch = MEM_BG_SYNC;
+		}
 
 		fb_pos.x = vout->crop_current.left;
 		fb_pos.y = vout->crop_current.top;
@@ -536,12 +572,7 @@ static int mxc_v4l2out_streamon(vout_data * vout)
 		    (fbi->fix.line_length * fbi->var.yres);
 		vout->display_buf_size = vout->crop_current.width *
 		    vout->crop_current.height *
-		    fmt_to_bpp(SDC_FG_FB_FORMAT) / 8;
-
-		if (vout->cur_disp_output == 3)
-			vout->display_ch = MEM_SDC_FG;
-		else
-			vout->display_ch = MEM_SDC_BG;
+		    fbi->var.bits_per_pixel / 8;
 
 		vout->post_proc_ch = MEM_PP_MEM;
 	}
@@ -558,7 +589,10 @@ static int mxc_v4l2out_streamon(vout_data * vout)
 		params.mem_pp_mem.in_pixel_fmt = vout->v2f.fmt.pix.pixelformat;
 		params.mem_pp_mem.out_width = out_width;
 		params.mem_pp_mem.out_height = out_height;
-		params.mem_pp_mem.out_pixel_fmt = SDC_FG_FB_FORMAT;
+		if (vout->display_ch == ADC_SYS2)
+			params.mem_pp_mem.out_pixel_fmt = SDC_FG_FB_FORMAT;
+		else
+			params.mem_pp_mem.out_pixel_fmt = bpp_to_fmt(fbi);
 		if (ipu_init_channel(vout->post_proc_ch, &params) != 0) {
 			dev_err(dev, "Error initializing PP channel\n");
 			return -EINVAL;
@@ -582,7 +616,7 @@ static int mxc_v4l2out_streamon(vout_data * vout)
 			return -EINVAL;
 		}
 
-		if (vout->rotate >= IPU_ROTATE_90_RIGHT) {
+		if (!ipu_can_rotate_in_place(vout->rotate)) {
 			if (vout->rot_pp_bufs[0]) {
 				mxc_free_buffers(vout->rot_pp_bufs,
 						 vout->rot_pp_bufs_vaddr, 2,
@@ -629,8 +663,10 @@ static int mxc_v4l2out_streamon(vout_data * vout)
 			}
 
 			/* swap width and height */
-			out_width = vout->crop_current.width;
-			out_height = vout->crop_current.height;
+			if (vout->rotate >= IPU_ROTATE_90_RIGHT) {
+				out_width = vout->crop_current.width;
+				out_height = vout->crop_current.height;
+			}
 
 			if (ipu_init_channel_buffer(MEM_ROT_PP_MEM,
 						    IPU_OUTPUT_BUFFER,
@@ -687,8 +723,8 @@ static int mxc_v4l2out_streamon(vout_data * vout)
 		ipu_select_buffer(vout->post_proc_ch, IPU_OUTPUT_BUFFER, 1);
 
 		ipu_enable_channel(vout->post_proc_ch);
-		if ((vout->display_ch == MEM_SDC_FG) ||
-		    (vout->display_ch == MEM_SDC_BG)) {
+
+		if (fbi) {
 			acquire_console_sem();
 			fb_blank(fbi, FB_BLANK_UNBLANK);
 			release_console_sem();
@@ -740,7 +776,7 @@ static int mxc_v4l2out_streamoff(vout_data * vout)
 	spin_unlock_irqrestore(&g_lock, lockflag);
 
 	if (vout->post_proc_ch == MEM_PP_MEM) {	/* SDC or ADC with Rotation */
-		if (vout->rotate >= IPU_ROTATE_90_RIGHT) {
+		if (!ipu_can_rotate_in_place(vout->rotate)) {
 			ipu_unlink_channels(MEM_PP_MEM, MEM_ROT_PP_MEM);
 			ipu_unlink_channels(MEM_ROT_PP_MEM, vout->display_ch);
 			ipu_disable_channel(MEM_ROT_PP_MEM, true);
@@ -748,13 +784,15 @@ static int mxc_v4l2out_streamoff(vout_data * vout)
 			ipu_unlink_channels(MEM_PP_MEM, vout->display_ch);
 		}
 		ipu_disable_channel(MEM_PP_MEM, true);
-		if ((vout->display_ch != MEM_SDC_FG) &&
-		    (vout->display_ch != MEM_SDC_BG)) {
+
+		if (vout->display_ch == ADC_SYS2) {
 			ipu_disable_channel(vout->display_ch, true);
 			ipu_uninit_channel(vout->display_ch);
 		} else {
 			fbi->var.activate |= FB_ACTIVATE_FORCE;
 			fb_set_var(fbi, &fbi->var);
+			vout->display_bufs[0] = 0;
+			vout->display_bufs[1] = 0;
 		}
 
 		ipu_uninit_channel(MEM_PP_MEM);
@@ -1316,6 +1354,7 @@ mxc_v4l2out_do_ioctl(struct inode *inode, struct file *file,
 				retval = -EINVAL;
 				break;
 			}
+
 			cap->bounds = vout->crop_bounds[vout->cur_disp_output];
 			cap->defrect = vout->crop_bounds[vout->cur_disp_output];
 			retval = 0;
@@ -1408,8 +1447,10 @@ mxc_v4l2out_do_ioctl(struct inode *inode, struct file *file,
 	case VIDIOC_S_OUTPUT:
 		{
 			int *p_output_num = arg;
+			int fbnum;
+			struct v4l2_rect *b;
 
-			if ((*p_output_num >= 5) ||
+			if ((*p_output_num >= MXC_V4L2_OUT_NUM_OUTPUTS) ||
 			    (vout->output_enabled[*p_output_num] == false)) {
 				retval = -EINVAL;
 				break;
@@ -1421,8 +1462,18 @@ mxc_v4l2out_do_ioctl(struct inode *inode, struct file *file,
 			}
 
 			vout->cur_disp_output = *p_output_num;
-			vout->crop_current =
-			    vout->crop_bounds[vout->cur_disp_output];
+
+			/* Update bounds in case they have changed */
+			b = &vout->crop_bounds[vout->cur_disp_output];
+
+			fbnum = vout->output_fb_num[vout->cur_disp_output];
+			if (vout->cur_disp_output == 3)
+				fbnum = vout->output_fb_num[4];
+
+			b->width = registered_fb[fbnum]->var.xres;
+			b->height = registered_fb[fbnum]->var.yres;
+
+			vout->crop_current = *b;
 			break;
 		}
 	case VIDIOC_ENUM_FMT:
@@ -1610,9 +1661,11 @@ static int mxc_v4l2out_probe(struct platform_device *pdev)
 		char *idstr = registered_fb[i]->fix.id;
 		if (strncmp(idstr, "DISP", 4) == 0) {
 			int disp_num = idstr[4] - '0';
-			if ((disp_num == 3) &&
-			    (strncmp(idstr, "DISP3 BG", 8) == 0)) {
-				disp_num = 4;
+			if (disp_num == 3) {
+				if (strcmp(idstr, "DISP3 BG - DI1") == 0)
+					disp_num = 5;
+				else if (strncmp(idstr, "DISP3 BG", 8) == 0)
+					disp_num = 4;
 			}
 			vout->crop_bounds[disp_num].left = 0;
 			vout->crop_bounds[disp_num].top = 0;
diff --git a/drivers/media/video/mxc/output/mxc_v4l2_output.h b/drivers/media/video/mxc/output/mxc_v4l2_output.h
index 6fb6f5a..bb6da2b 100644
--- a/drivers/media/video/mxc/output/mxc_v4l2_output.h
+++ b/drivers/media/video/mxc/output/mxc_v4l2_output.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -36,7 +36,7 @@
 #define MIN_FRAME_NUM 2
 #define MAX_FRAME_NUM 30
 
-#define MXC_V4L2_OUT_NUM_OUTPUTS        5
+#define MXC_V4L2_OUT_NUM_OUTPUTS        6
 #define MXC_V4L2_OUT_2_SDC              0
 #define MXC_V4L2_OUT_2_ADC              1
 
diff --git a/drivers/mxc/Kconfig b/drivers/mxc/Kconfig
index f27a952..8b1633d 100644
--- a/drivers/mxc/Kconfig
+++ b/drivers/mxc/Kconfig
@@ -4,7 +4,19 @@ if ARCH_MXC
 
 menu "MXC support drivers"
 
+config MXC_IPU
+	bool "Image Processing Unit Driver"
+	depends on !ARCH_MX21
+	depends on !ARCH_MX27
+	select MXC_IPU_V1 if !ARCH_MX37
+	select MXC_IPU_V3 if ARCH_MX37
+	help
+	  If you plan to use the Image Processing unit, say
+	  Y here. IPU is needed by Framebuffer and V4L2 drivers.
+
 source "drivers/mxc/ipu/Kconfig"
+source "drivers/mxc/ipu3/Kconfig"
+
 source "drivers/mxc/ssi/Kconfig"
 source "drivers/mxc/dam/Kconfig"
 source "drivers/mxc/pmic/Kconfig"
diff --git a/drivers/mxc/Makefile b/drivers/mxc/Makefile
index 63eae15..b1d9a48 100644
--- a/drivers/mxc/Makefile
+++ b/drivers/mxc/Makefile
@@ -1,4 +1,5 @@
-obj-$(CONFIG_MXC_IPU)			+= ipu/
+obj-$(CONFIG_MXC_IPU_V1)			+= ipu/
+obj-$(CONFIG_MXC_IPU_V3)			+= ipu3/
 obj-$(CONFIG_MXC_SSI)               	+= ssi/
 obj-$(CONFIG_MXC_DAM)               	+= dam/
 
diff --git a/drivers/mxc/ipu/Kconfig b/drivers/mxc/ipu/Kconfig
index c0b61e1..a57f8ce 100644
--- a/drivers/mxc/ipu/Kconfig
+++ b/drivers/mxc/ipu/Kconfig
@@ -1,19 +1,5 @@
-menu "MXC IPU"
-
-config MXC_IPU
-	bool "MXC Image Processing Unit"
-	depends on ARCH_MXC
-	depends on !ARCH_MX21
-	depends on !ARCH_MX27
-	help
-	  If you plan to use the Image Processing unit in the MXC, say
-	  Y here. If unsure, select Y.
-
-config MXC_IPU_LPMC
+config MXC_IPU_V1
 	bool
-	depends on MXC_IPU
-	default y if ARCH_MXC91231
 
 source "drivers/mxc/ipu/pf/Kconfig"
 
-endmenu
diff --git a/drivers/mxc/ipu/Makefile b/drivers/mxc/ipu/Makefile
index f94f0eb..dc6d42a 100644
--- a/drivers/mxc/ipu/Makefile
+++ b/drivers/mxc/ipu/Makefile
@@ -1,4 +1,4 @@
-obj-$(CONFIG_MXC_IPU) += mxc_ipu.o
+obj-$(CONFIG_MXC_IPU_V1) = mxc_ipu.o
 
 mxc_ipu-objs := ipu_common.o ipu_sdc.o ipu_adc.o ipu_ic.o ipu_csi.o ipu_device.o
 
diff --git a/drivers/mxc/ipu/pf/Kconfig b/drivers/mxc/ipu/pf/Kconfig
index 02cda91..fa5a777 100644
--- a/drivers/mxc/ipu/pf/Kconfig
+++ b/drivers/mxc/ipu/pf/Kconfig
@@ -1,6 +1,6 @@
 config MXC_IPU_PF
 	tristate "MXC MPEG4/H.264 Post Filter Driver"
-	depends on MXC_IPU
+	depends on MXC_IPU_V1
     default y
 	help
         Driver for MPEG4 dering and deblock and H.264 deblock
diff --git a/drivers/mxc/ipu3/Kconfig b/drivers/mxc/ipu3/Kconfig
new file mode 100644
index 0000000..d484e94
--- /dev/null
+++ b/drivers/mxc/ipu3/Kconfig
@@ -0,0 +1,3 @@
+config MXC_IPU_V3
+	bool
+
diff --git a/drivers/mxc/ipu3/Makefile b/drivers/mxc/ipu3/Makefile
new file mode 100644
index 0000000..8b34e90
--- /dev/null
+++ b/drivers/mxc/ipu3/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_MXC_IPU_V3) = mxc_ipu.o
+
+mxc_ipu-objs := ipu_common.o ipu_ic.o ipu_disp.o
+
diff --git a/drivers/mxc/ipu3/ipu_common.c b/drivers/mxc/ipu3/ipu_common.c
new file mode 100644
index 0000000..02a21b6
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_common.c
@@ -0,0 +1,1331 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_common.c
+ *
+ * @brief This file contains the IPU driver common API functions.
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <asm/arch/ipu.h>
+#include <asm/arch/clock.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+struct ipu_irq_node {
+	irqreturn_t(*handler) (int, void *);	/*!< the ISR */
+	const char *name;	/*!< device associated with the interrupt */
+	void *dev_id;		/*!< some unique information for the ISR */
+	__u32 flags;		/*!< not used */
+};
+
+/* Globals */
+struct clk *g_ipu_clk;
+bool g_ipu_clk_enabled;
+struct clk *g_di_clk[2];
+struct clk *g_ipu_csi_clk;
+ipu_channel_t g_ipu_di_channel[2];
+int g_ipu_irq[2];
+int g_ipu_hw_rev;
+bool g_sec_chan_en[21];
+uint32_t g_channel_init_mask;
+DEFINE_SPINLOCK(ipu_lock);
+struct device *g_ipu_dev;
+
+static struct ipu_irq_node ipu_irq_list[IPU_IRQ_COUNT];
+static const char driver_name[] = "mxc_ipu";
+
+static int ipu_dc_use_count;
+static int ipu_dp_use_count;
+static int ipu_dmfc_use_count;
+static int ipu_ic_use_count;
+static int ipu_rot_use_count;
+static int ipu_di_use_count[2];
+
+u32 *ipu_cm_reg;
+u32 *ipu_idmac_reg;
+u32 *ipu_dp_reg;
+u32 *ipu_ic_reg;
+u32 *ipu_dc_reg;
+u32 *ipu_dc_tmpl_reg;
+u32 *ipu_dmfc_reg;
+u32 *ipu_di_reg[2];
+u32 *ipu_cpmem_base;
+u32 *ipu_tpmem_base;
+
+/* Static functions */
+static irqreturn_t ipu_irq_handler(int irq, void *desc);
+
+static inline uint32_t channel_2_dma(ipu_channel_t ch, ipu_buffer_t type)
+{
+	return ((uint32_t) ch >> (6 * type)) & 0x3F;
+};
+
+#define idma_is_valid(ch)	(ch != NO_DMA)
+#define idma_mask(ch)		(idma_is_valid(ch) ? (1UL << (ch & 0x1F)) : 0)
+#define idma_is_set(reg, dma)	(__raw_readl(reg(dma)) & idma_mask(dma))
+
+static int _di_clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	if (parent != g_ipu_clk)
+		return -EINVAL;
+
+	return 0;
+}
+
+static struct clk di_clk[] = {
+	{
+	 .name = "di_clk",
+	 .id = 0,
+	 .set_parent = _di_clk_set_parent},
+	{
+	 .name = "di_clk",
+	 .id = 1,
+	 .rate = 27000000,},
+};
+
+/*!
+ * This function is called by the driver framework to initialize the IPU
+ * hardware.
+ *
+ * @param	dev	The device structure for the IPU passed in by the
+ *			driver framework.
+ *
+ * @return      Returns 0 on success or negative error code on error
+ */
+static int ipu_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	unsigned long ipu_base;
+
+	spin_lock_init(&ipu_lock);
+
+	g_ipu_dev = &pdev->dev;
+
+	/* Register IPU interrupts */
+	g_ipu_irq[0] = platform_get_irq(pdev, 0);
+	if (g_ipu_irq[0] < 0)
+		return -EINVAL;
+
+	if (request_irq(g_ipu_irq[0], ipu_irq_handler, 0, pdev->name, 0) != 0) {
+		dev_err(g_ipu_dev, "request SYNC interrupt failed\n");
+		return -EBUSY;
+	}
+	/* Some platforms have 2 IPU interrupts */
+	g_ipu_irq[1] = platform_get_irq(pdev, 1);
+	if (g_ipu_irq[1] >= 0) {
+		if (request_irq
+		    (g_ipu_irq[1], ipu_irq_handler, 0, pdev->name, 0) != 0) {
+			dev_err(g_ipu_dev, "request ERR interrupt failed\n");
+			return -EBUSY;
+		}
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(res))
+		return -ENODEV;
+
+	ipu_base = res->start;
+	ipu_cm_reg = ioremap(ipu_base + IPU_CM_REG_BASE, PAGE_SIZE);
+	ipu_ic_reg = ioremap(ipu_base + IPU_IC_REG_BASE, PAGE_SIZE);
+	ipu_idmac_reg = ioremap(ipu_base + IPU_IDMAC_REG_BASE, PAGE_SIZE);
+	/* DP Registers are accessed thru the SRM */
+	ipu_dp_reg = ioremap(ipu_base + IPU_SRM_REG_BASE, PAGE_SIZE);
+	ipu_dc_reg = ioremap(ipu_base + IPU_DC_REG_BASE, PAGE_SIZE);
+	ipu_dmfc_reg = ioremap(ipu_base + IPU_DMFC_REG_BASE, PAGE_SIZE);
+	ipu_di_reg[0] = ioremap(ipu_base + IPU_DI0_REG_BASE, PAGE_SIZE);
+	ipu_di_reg[1] = ioremap(ipu_base + IPU_DI1_REG_BASE, PAGE_SIZE);
+	ipu_cpmem_base = ioremap(ipu_base + IPU_CPMEM_REG_BASE, PAGE_SIZE);
+	ipu_tpmem_base = ioremap(ipu_base + IPU_TPM_REG_BASE, SZ_64K);
+	ipu_dc_tmpl_reg = ioremap(ipu_base + IPU_DC_TMPL_REG_BASE, SZ_128K);
+
+	dev_dbg(g_ipu_dev, "IPU CM Regs = %p\n", ipu_cm_reg);
+	dev_dbg(g_ipu_dev, "IPU IC Regs = %p\n", ipu_ic_reg);
+	dev_dbg(g_ipu_dev, "IPU IDMAC Regs = %p\n", ipu_idmac_reg);
+	dev_dbg(g_ipu_dev, "IPU DP Regs = %p\n", ipu_dp_reg);
+	dev_dbg(g_ipu_dev, "IPU DC Regs = %p\n", ipu_dc_reg);
+	dev_dbg(g_ipu_dev, "IPU DMFC Regs = %p\n", ipu_dmfc_reg);
+	dev_dbg(g_ipu_dev, "IPU DI0 Regs = %p\n", ipu_di_reg[0]);
+	dev_dbg(g_ipu_dev, "IPU DI1 Regs = %p\n", ipu_di_reg[1]);
+	dev_dbg(g_ipu_dev, "IPU CPMem = %p\n", ipu_cpmem_base);
+	dev_dbg(g_ipu_dev, "IPU TPMem = %p\n", ipu_tpmem_base);
+	dev_dbg(g_ipu_dev, "IPU DC Template Mem = %p\n", ipu_dc_tmpl_reg);
+
+	/* Enable IPU and CSI clocks */
+	/* Get IPU clock freq */
+	g_ipu_clk = clk_get(&pdev->dev, "ipu_clk");
+	dev_dbg(g_ipu_dev, "ipu_clk = %lu\n", clk_get_rate(g_ipu_clk));
+
+	clk_enable(g_ipu_clk);
+
+	clk_register(&di_clk[0]);
+	g_di_clk[0] = &di_clk[0];
+	clk_set_parent(g_di_clk[0], g_ipu_clk);
+
+	clk_register(&di_clk[1]);
+	g_di_clk[1] = &di_clk[1];
+
+	__raw_writel(0x807FFFFF, IPU_MEM_RST);
+	while (__raw_readl(IPU_MEM_RST) & 0x80000000) ;
+
+	_ipu_init_dc_mappings();
+
+	/* Enable error interrupts by default */
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(5));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(6));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(9));
+	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(10));
+
+	/* DMFC Init */
+	__raw_writel(0x7, DMFC_IC_CTRL);
+	/* 1 - segment 0 and 1; 2, 1C and 2C unused */
+	__raw_writel(0x00000090, DMFC_WR_CHAN);
+	__raw_writel(0x20202000, DMFC_WR_CHAN_DEF);
+	/* 5B - segment 2 and 3; 5F - segment 4 and 5; */
+	/* 6B - segment 6; 6F - segment 7 */
+	__raw_writel(0x1F1E9492, DMFC_DP_CHAN);
+
+	/* Set sync refresh channels as high priority */
+	__raw_writel(0x18800000L, IDMAC_CHA_PRI(0));
+
+	clk_disable(g_ipu_clk);
+
+	return 0;
+}
+
+int ipu_remove(struct platform_device *pdev)
+{
+	if (g_ipu_irq[0])
+		free_irq(g_ipu_irq[0], 0);
+	if (g_ipu_irq[1])
+		free_irq(g_ipu_irq[1], 0);
+
+	clk_put(g_ipu_clk);
+
+	iounmap(ipu_cm_reg);
+	iounmap(ipu_ic_reg);
+	iounmap(ipu_idmac_reg);
+	iounmap(ipu_dc_reg);
+	iounmap(ipu_dp_reg);
+	iounmap(ipu_dmfc_reg);
+	iounmap(ipu_di_reg[0]);
+	iounmap(ipu_di_reg[1]);
+	iounmap(ipu_cpmem_base);
+	iounmap(ipu_tpmem_base);
+	iounmap(ipu_dc_tmpl_reg);
+
+	return 0;
+}
+
+void ipu_dump_registers(void)
+{
+	printk(KERN_DEBUG "IPU_CONF = \t0x%08X\n", __raw_readl(IPU_CONF));
+	printk(KERN_DEBUG "IPU_FS_PROC_FLOW1 = \t0x%08X\n",
+	       __raw_readl(IPU_FS_PROC_FLOW1));
+	printk(KERN_DEBUG "IPU_FS_PROC_FLOW2 = \t0x%08X\n",
+	       __raw_readl(IPU_FS_PROC_FLOW2));
+	printk(KERN_DEBUG "IPU_FS_PROC_FLOW3 = \t0x%08X\n",
+	       __raw_readl(IPU_FS_PROC_FLOW3));
+}
+
+/*!
+ * This function is called to initialize a logical IPU channel.
+ *
+ * @param       channel Input parameter for the logical channel ID to init.
+ *
+ * @param       params  Input parameter containing union of channel
+ *                      initialization parameters.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t *params)
+{
+	uint32_t ipu_conf;
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	dev_dbg(g_ipu_dev, "init channel = %d\n", IPU_CHAN_ID(channel));
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	ipu_conf = __raw_readl(IPU_CONF);
+	if (ipu_conf == 0) {
+		g_ipu_clk_enabled = true;
+		clk_enable(g_ipu_clk);
+	}
+
+	if (g_channel_init_mask & (1L << IPU_CHAN_ID(channel))) {
+		dev_err(g_ipu_dev, "Warning: channel already initialized %d\n",
+			IPU_CHAN_ID(channel));
+	}
+
+	switch (channel) {
+	case MEM_PRP_VF_MEM:
+		ipu_ic_use_count++;
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg | FS_VF_IN_VALID, IPU_FS_PROC_FLOW1);
+
+		if (params->mem_prp_vf_mem.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		_ipu_ic_init_prpvf(params, false);
+		break;
+	case MEM_ROT_VF_MEM:
+		ipu_ic_use_count++;
+		ipu_rot_use_count++;
+		_ipu_ic_init_rotate_vf(params);
+		break;
+	case MEM_PRP_ENC_MEM:
+		ipu_ic_use_count++;
+		reg = __raw_readl(IPU_FS_PROC_FLOW1);
+		__raw_writel(reg | FS_ENC_IN_VALID, IPU_FS_PROC_FLOW1);
+		_ipu_ic_init_prpenc(params, false);
+		break;
+	case MEM_ROT_ENC_MEM:
+		ipu_ic_use_count++;
+		ipu_rot_use_count++;
+		_ipu_ic_init_rotate_enc(params);
+		break;
+	case MEM_PP_MEM:
+		if (params->mem_pp_mem.graphics_combine_en)
+			g_sec_chan_en[IPU_CHAN_ID(channel)] = true;
+		_ipu_ic_init_pp(params);
+		ipu_ic_use_count++;
+		break;
+	case MEM_ROT_PP_MEM:
+		_ipu_ic_init_rotate_pp(params);
+		ipu_ic_use_count++;
+		ipu_rot_use_count++;
+		break;
+	case MEM_DC_SYNC:
+		g_ipu_di_channel[params->mem_dc_sync.di] = MEM_DC_SYNC;
+		_ipu_dc_init(1, params->mem_dc_sync.di,
+			     params->mem_dc_sync.interlaced);
+		ipu_di_use_count[params->mem_dc_sync.di]++;
+		ipu_dc_use_count++;
+		ipu_dmfc_use_count++;
+		break;
+	case MEM_BG_SYNC:
+		g_ipu_di_channel[params->mem_dp_bg_sync.di] = MEM_BG_SYNC;
+		_ipu_dp_init(channel, params->mem_dp_bg_sync.in_pixel_fmt,
+			     params->mem_dp_bg_sync.out_pixel_fmt);
+		_ipu_dc_init(5, params->mem_dp_bg_sync.di,
+			     params->mem_dp_bg_sync.interlaced);
+		ipu_di_use_count[params->mem_dp_bg_sync.di]++;
+		ipu_dc_use_count++;
+		ipu_dp_use_count++;
+		ipu_dmfc_use_count++;
+		break;
+	case MEM_FG_SYNC:
+		_ipu_dp_init(channel, params->mem_dp_fg_sync.in_pixel_fmt,
+			     params->mem_dp_fg_sync.out_pixel_fmt);
+		ipu_dc_use_count++;
+		ipu_dp_use_count++;
+		ipu_dmfc_use_count++;
+		break;
+	default:
+		dev_err(g_ipu_dev, "Missing channel initialization\n");
+		break;
+	}
+
+	/* Enable IPU sub module */
+	g_channel_init_mask |= 1L << IPU_CHAN_ID(channel);
+	if (ipu_ic_use_count == 1)
+		ipu_conf |= IPU_CONF_IC_EN;
+	if (ipu_rot_use_count == 1)
+		ipu_conf |= IPU_CONF_ROT_EN;
+	if (ipu_dc_use_count == 1)
+		ipu_conf |= IPU_CONF_DC_EN;
+	if (ipu_dp_use_count == 1)
+		ipu_conf |= IPU_CONF_DP_EN;
+	if (ipu_dmfc_use_count == 1)
+		ipu_conf |= IPU_CONF_DMFC_EN;
+	if (ipu_di_use_count[0] == 1)
+		ipu_conf |= IPU_CONF_DI0_EN;
+	if (ipu_di_use_count[1] == 1)
+		ipu_conf |= IPU_CONF_DI1_EN;
+
+	__raw_writel(ipu_conf, IPU_CONF);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_channel);
+
+/*!
+ * This function is called to uninitialize a logical IPU channel.
+ *
+ * @param       channel Input parameter for the logical channel ID to uninit.
+ */
+void ipu_uninit_channel(ipu_channel_t channel)
+{
+	unsigned long lock_flags;
+	uint32_t reg;
+	uint32_t in_dma, out_dma = 0;
+	uint32_t ipu_conf;
+
+	if ((g_channel_init_mask & (1L << IPU_CHAN_ID(channel))) == 0) {
+		dev_err(g_ipu_dev, "Channel already uninitialized %d\n",
+			IPU_CHAN_ID(channel));
+		return;
+	}
+
+	/* Make sure channel is disabled */
+	/* Get input and output dma channels */
+	in_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	out_dma = channel_2_dma(channel, IPU_VIDEO_IN_BUFFER);
+
+	if (idma_is_set(IDMAC_CHA_EN, in_dma) ||
+	    idma_is_set(IDMAC_CHA_EN, out_dma)) {
+		dev_err(g_ipu_dev,
+			"Channel %d is not disabled, disable first\n",
+			IPU_CHAN_ID(channel));
+		return;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	/* Reset the double buffer */
+	reg = __raw_readl(IPU_CHA_DB_MODE_SEL(in_dma));
+	__raw_writel(reg & ~idma_mask(in_dma), IPU_CHA_DB_MODE_SEL(in_dma));
+	reg = __raw_readl(IPU_CHA_DB_MODE_SEL(out_dma));
+	__raw_writel(reg & ~idma_mask(out_dma), IPU_CHA_DB_MODE_SEL(out_dma));
+
+	g_sec_chan_en[IPU_CHAN_ID(channel)] = false;
+
+	switch (channel) {
+	case MEM_PRP_VF_MEM:
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_prpvf();
+		break;
+	case MEM_ROT_VF_MEM:
+		ipu_rot_use_count--;
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_rotate_vf();
+		break;
+	case MEM_PRP_ENC_MEM:
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_prpenc();
+		break;
+	case MEM_ROT_ENC_MEM:
+		ipu_rot_use_count--;
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_rotate_enc();
+		break;
+	case MEM_PP_MEM:
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_pp();
+		break;
+	case MEM_ROT_PP_MEM:
+		ipu_rot_use_count--;
+		ipu_ic_use_count--;
+		_ipu_ic_uninit_rotate_pp();
+		break;
+	case MEM_DC_SYNC:
+		_ipu_dc_uninit(1);
+		if (g_ipu_di_channel[0] == MEM_DC_SYNC) {
+			g_ipu_di_channel[0] = CHAN_NONE;
+			ipu_di_use_count[0]--;
+		} else if (g_ipu_di_channel[1] == MEM_DC_SYNC) {
+			g_ipu_di_channel[1] = CHAN_NONE;
+			ipu_di_use_count[1]--;
+		}
+		ipu_dc_use_count--;
+		ipu_dmfc_use_count--;
+		break;
+	case MEM_BG_SYNC:
+		_ipu_dp_uninit(channel);
+		_ipu_dc_uninit(5);
+		if (g_ipu_di_channel[0] == MEM_BG_SYNC) {
+			g_ipu_di_channel[0] = CHAN_NONE;
+			ipu_di_use_count[0]--;
+		} else if (g_ipu_di_channel[1] == MEM_DC_SYNC) {
+			g_ipu_di_channel[1] = CHAN_NONE;
+			ipu_di_use_count[1]--;
+		}
+		ipu_dc_use_count--;
+		ipu_dp_use_count--;
+		ipu_dmfc_use_count--;
+		break;
+	case MEM_FG_SYNC:
+		_ipu_dp_uninit(channel);
+		ipu_dc_use_count--;
+		ipu_dp_use_count--;
+		ipu_dmfc_use_count--;
+		break;
+	default:
+		break;
+	}
+
+	g_channel_init_mask &= ~(1L << IPU_CHAN_ID(channel));
+
+	ipu_conf = __raw_readl(IPU_CONF);
+
+	if (ipu_ic_use_count == 0)
+		ipu_conf &= ~IPU_CONF_IC_EN;
+	if (ipu_rot_use_count == 0)
+		ipu_conf &= ~IPU_CONF_ROT_EN;
+	if (ipu_dc_use_count == 0)
+		ipu_conf &= ~IPU_CONF_DC_EN;
+	if (ipu_dp_use_count == 0)
+		ipu_conf &= ~IPU_CONF_DP_EN;
+	if (ipu_dmfc_use_count == 0)
+		ipu_conf &= ~IPU_CONF_DMFC_EN;
+	if (ipu_di_use_count[0] == 0)
+		ipu_conf &= ~IPU_CONF_DI0_EN;
+	if (ipu_di_use_count[1] == 0)
+		ipu_conf &= ~IPU_CONF_DI1_EN;
+
+	__raw_writel(ipu_conf, IPU_CONF);
+
+	if (ipu_conf == 0) {
+		clk_disable(g_ipu_clk);
+		g_ipu_clk_enabled = false;
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	WARN_ON(ipu_ic_use_count < 0);
+	WARN_ON(ipu_rot_use_count < 0);
+	WARN_ON(ipu_dc_use_count < 0);
+	WARN_ON(ipu_dp_use_count < 0);
+	WARN_ON(ipu_dmfc_use_count < 0);
+}
+EXPORT_SYMBOL(ipu_uninit_channel);
+
+/*!
+ * This function is called to initialize a buffer for logical IPU channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer.
+ *                              Pixel format is a FOURCC ASCII code.
+ *
+ * @param       width           Input parameter for width of buffer in pixels.
+ *
+ * @param       height          Input parameter for height of buffer in pixels.
+ *
+ * @param       stride          Input parameter for stride length of buffer
+ *                              in pixels.
+ *
+ * @param       rot_mode        Input parameter for rotation setting of buffer.
+ *                              A rotation setting other than
+ *                              IPU_ROTATE_VERT_FLIP
+ *                              should only be used for input buffers of
+ *                              rotation channels.
+ *
+ * @param       phyaddr_0       Input parameter buffer 0 physical address.
+ *
+ * @param       phyaddr_1       Input parameter buffer 1 physical address.
+ *                              Setting this to a value other than NULL enables
+ *                              double buffering mode.
+ *
+ * @param       u		private u offset for additional cropping,
+ *				zero if not used.
+ *
+ * @param       v		private v offset for additional cropping,
+ *				zero if not used.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				uint32_t u, uint32_t v)
+{
+	unsigned long lock_flags;
+	uint32_t reg;
+	uint32_t dma_chan;
+	uint32_t burst_size;
+
+	dma_chan = channel_2_dma(channel, type);
+	if (!idma_is_valid(dma_chan))
+		return -EINVAL;
+
+	if (stride < width * bytes_per_pixel(pixel_fmt))
+		stride = width * bytes_per_pixel(pixel_fmt);
+	if (stride % 4) {
+		dev_err(g_ipu_dev,
+			"Stride not 32-bit aligned, stride = %d\n", stride);
+		return -EINVAL;
+	}
+	/* IC channels' width must be multiple of 8 pixels     */
+	if ((IPU_CHAN_ID(channel) <= 6) && (width % 8)) {
+		dev_err(g_ipu_dev, "Width must be 8 pixel multiple\n");
+		return -EINVAL;
+	}
+
+	/* Build parameter memory data for DMA channel */
+	_ipu_ch_param_init(dma_chan, pixel_fmt, width, height, stride, u, v, 0,
+			   phyaddr_0, phyaddr_1);
+	if (rot_mode)
+		_ipu_ch_param_set_rotation(dma_chan, rot_mode);
+
+	/* IC and ROT channels have restriction of 8 or 16 pix burst length */
+	if ((channel == MEM_PRP_ENC_MEM) || (channel == MEM_PRP_VF_MEM) ||
+	    (channel == MEM_PP_MEM)) {
+		_ipu_ch_param_set_burst_size(dma_chan, 16);
+	} else if ((channel == MEM_ROT_ENC_MEM) ||
+		   (channel == MEM_ROT_VF_MEM) || (channel == MEM_ROT_PP_MEM)) {
+		_ipu_ch_param_set_burst_size(dma_chan, 8);
+		_ipu_ch_param_set_block_mode(dma_chan);
+	}
+
+	if (_ipu_chan_is_interlaced(channel))
+		_ipu_ch_param_set_interlaced_scan(dma_chan);
+
+	burst_size = _ipu_ch_param_get_burst_size(dma_chan);
+	_ipu_ic_idma_init(dma_chan, width, height, burst_size, rot_mode);
+
+	_ipu_ch_param_dump(dma_chan);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPU_CHA_DB_MODE_SEL(dma_chan));
+	if (phyaddr_1)
+		reg |= idma_mask(dma_chan);
+	else
+		reg &= ~idma_mask(dma_chan);
+	__raw_writel(reg, IPU_CHA_DB_MODE_SEL(dma_chan));
+
+	/* Reset to buffer 0 */
+	__raw_writel(idma_mask(dma_chan), IPU_CHA_CUR_BUF(dma_chan));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_channel_buffer);
+
+/*!
+ * This function is called to update the physical address of a buffer for
+ * a logical IPU channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       bufNum          Input parameter for buffer number to update.
+ *                              0 or 1 are the only valid values.
+ *
+ * @param       phyaddr         Input parameter buffer physical address.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail. This function will fail if the buffer is set to ready.
+ */
+int32_t ipu_update_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				  uint32_t bufNum, dma_addr_t phyaddr)
+{
+	uint32_t reg;
+	int ret = 0;
+	unsigned long lock_flags;
+	uint32_t dma_chan = channel_2_dma(channel, type);
+
+	if (dma_chan == IDMA_CHAN_INVALID)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (bufNum == 0)
+		reg = __raw_readl(IPU_CHA_BUF0_RDY(dma_chan));
+	else
+		reg = __raw_readl(IPU_CHA_BUF1_RDY(dma_chan));
+
+	if ((reg & idma_mask(dma_chan)) == 0)
+		_ipu_ch_param_set_buffer(dma_chan, bufNum, phyaddr);
+	else
+		ret = -EACCES;
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return ret;
+}
+EXPORT_SYMBOL(ipu_update_channel_buffer);
+
+/*!
+ * This function is called to set a channel's buffer as ready.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       bufNum          Input parameter for which buffer number set to
+ *                              ready state.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_select_buffer(ipu_channel_t channel, ipu_buffer_t type,
+			  uint32_t bufNum)
+{
+	uint32_t dma_chan = channel_2_dma(channel, type);
+
+	if (dma_chan == IDMA_CHAN_INVALID)
+		return -EINVAL;
+
+	if (bufNum == 0) {
+		/*Mark buffer 0 as ready. */
+		__raw_writel(idma_mask(dma_chan), IPU_CHA_BUF0_RDY(dma_chan));
+	} else {
+		/*Mark buffer 1 as ready. */
+		__raw_writel(idma_mask(dma_chan), IPU_CHA_BUF1_RDY(dma_chan));
+	}
+	return 0;
+}
+EXPORT_SYMBOL(ipu_select_buffer);
+
+static int proc_dest_sel[] =
+    { 0, 1, 2, 3, 5, 5, 4, 7, 8, 9, 10, 11, 12, 14, 15 };
+static int proc_src_sel[] = { 0, 6, 7, 6, 7, 8, 5, };
+static int disp_src_sel[] = { 0, 6, 7, 8, 3, 4, 5, };
+
+/*!
+ * This function links 2 channels together for automatic frame
+ * synchronization. The output of the source channel is linked to the input of
+ * the destination channel.
+ *
+ * @param       src_ch          Input parameter for the logical channel ID of
+ *                              the source channel.
+ *
+ * @param       dest_ch         Input parameter for the logical channel ID of
+ *                              the destination channel.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_link_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch)
+{
+	int retval = 0;
+	unsigned long lock_flags;
+	uint32_t fs_proc_flow1;
+	uint32_t fs_proc_flow2;
+	uint32_t fs_disp_flow1;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	fs_proc_flow1 = __raw_readl(IPU_FS_PROC_FLOW1);
+	fs_proc_flow2 = __raw_readl(IPU_FS_PROC_FLOW2);
+	fs_disp_flow1 = __raw_readl(IPU_FS_DISP_FLOW1);
+
+	switch (src_ch) {
+	case MEM_PP_MEM:
+		fs_proc_flow2 &= ~FS_PP_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PP_DEST_SEL_OFFSET;
+		break;
+	case MEM_ROT_PP_MEM:
+		fs_proc_flow2 &= ~FS_PP_ROT_DEST_SEL_MASK;
+		fs_proc_flow2 |=
+		    proc_dest_sel[IPU_CHAN_ID(dest_ch)] <<
+		    FS_PP_ROT_DEST_SEL_OFFSET;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	switch (dest_ch) {
+	case MEM_PP_MEM:
+		fs_proc_flow1 &= ~FS_PP_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] << FS_PP_SRC_SEL_OFFSET;
+		break;
+	case MEM_ROT_PP_MEM:
+		fs_proc_flow1 &= ~FS_PP_ROT_SRC_SEL_MASK;
+		fs_proc_flow1 |=
+		    proc_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_PP_ROT_SRC_SEL_OFFSET;
+		break;
+	case MEM_DC_SYNC:
+		fs_disp_flow1 &= ~FS_DC1_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] << FS_DC1_SRC_SEL_OFFSET;
+		break;
+	case MEM_BG_SYNC:
+		fs_disp_flow1 &= ~FS_DP_SYNC0_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_DP_SYNC0_SRC_SEL_OFFSET;
+		break;
+	case MEM_FG_SYNC:
+		fs_disp_flow1 &= ~FS_DP_SYNC1_SRC_SEL_MASK;
+		fs_disp_flow1 |=
+		    disp_src_sel[IPU_CHAN_ID(src_ch)] <<
+		    FS_DP_SYNC1_SRC_SEL_OFFSET;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	__raw_writel(fs_proc_flow1, IPU_FS_PROC_FLOW1);
+	__raw_writel(fs_proc_flow2, IPU_FS_PROC_FLOW2);
+	__raw_writel(fs_disp_flow1, IPU_FS_DISP_FLOW1);
+
+err:
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return retval;
+}
+EXPORT_SYMBOL(ipu_link_channels);
+
+/*!
+ * This function unlinks 2 channels and disables automatic frame
+ * synchronization.
+ *
+ * @param       src_ch          Input parameter for the logical channel ID of
+ *                              the source channel.
+ *
+ * @param       dest_ch         Input parameter for the logical channel ID of
+ *                              the destination channel.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_unlink_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch)
+{
+	int retval = 0;
+	unsigned long lock_flags;
+	uint32_t fs_proc_flow1;
+	uint32_t fs_proc_flow2;
+	uint32_t fs_disp_flow1;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	fs_proc_flow1 = __raw_readl(IPU_FS_PROC_FLOW1);
+	fs_proc_flow2 = __raw_readl(IPU_FS_PROC_FLOW2);
+	fs_disp_flow1 = __raw_readl(IPU_FS_DISP_FLOW1);
+
+	switch (src_ch) {
+	case MEM_PP_MEM:
+		fs_proc_flow2 &= ~FS_PP_DEST_SEL_MASK;
+		break;
+	case MEM_ROT_PP_MEM:
+		fs_proc_flow2 &= ~FS_PP_ROT_DEST_SEL_MASK;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	switch (dest_ch) {
+	case MEM_PP_MEM:
+		fs_proc_flow1 &= ~FS_PP_SRC_SEL_MASK;
+		break;
+	case MEM_ROT_PP_MEM:
+		fs_proc_flow1 &= ~FS_PP_ROT_SRC_SEL_MASK;
+		break;
+	case MEM_DC_SYNC:
+		fs_disp_flow1 &= ~FS_DC1_SRC_SEL_MASK;
+		break;
+	case MEM_BG_SYNC:
+		fs_disp_flow1 &= ~FS_DP_SYNC0_SRC_SEL_MASK;
+		break;
+	case MEM_FG_SYNC:
+		fs_disp_flow1 &= ~FS_DP_SYNC1_SRC_SEL_MASK;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err;
+	}
+
+	__raw_writel(fs_proc_flow1, IPU_FS_PROC_FLOW1);
+	__raw_writel(fs_proc_flow2, IPU_FS_PROC_FLOW2);
+	__raw_writel(fs_disp_flow1, IPU_FS_DISP_FLOW1);
+
+err:
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return retval;
+}
+EXPORT_SYMBOL(ipu_unlink_channels);
+
+/*!
+ * This function enables a logical channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_enable_channel(ipu_channel_t channel)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+	uint32_t in_dma;
+	uint32_t out_dma;
+
+	/* Get input and output dma channels */
+	out_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	in_dma = channel_2_dma(channel, IPU_VIDEO_IN_BUFFER);
+
+	if ((channel == MEM_DC_SYNC) || (channel == MEM_BG_SYNC) ||
+	    (channel == MEM_FG_SYNC))
+		_ipu_dp_dc_enable(channel);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (idma_is_valid(in_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(in_dma));
+		__raw_writel(reg | idma_mask(in_dma), IDMAC_CHA_EN(in_dma));
+	}
+	if (idma_is_valid(out_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(out_dma));
+		__raw_writel(reg | idma_mask(out_dma), IDMAC_CHA_EN(out_dma));
+	}
+
+	if (IPU_CHAN_ID(channel) <= IPU_CHAN_ID(MEM_PP_MEM))
+		_ipu_ic_enable_task(channel);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_enable_channel);
+
+/*!
+ * This function disables a logical channel.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       wait_for_stop   Flag to set whether to wait for channel end
+ *                              of frame or return immediately.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_disable_channel(ipu_channel_t channel, bool wait_for_stop)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+	uint32_t in_dma;
+	uint32_t out_dma;
+	uint32_t timeout;
+
+	/* Get input and output dma channels */
+	out_dma = channel_2_dma(channel, IPU_OUTPUT_BUFFER);
+	in_dma = channel_2_dma(channel, IPU_VIDEO_IN_BUFFER);
+
+	if (idma_is_valid(in_dma) && !idma_is_set(IDMAC_CHA_EN, in_dma))
+		return -EINVAL;
+	if (idma_is_valid(out_dma) && !idma_is_set(IDMAC_CHA_EN, out_dma))
+		return -EINVAL;
+
+	if ((channel == MEM_BG_SYNC) || (channel == MEM_FG_SYNC) ||
+	    (channel == MEM_DC_SYNC)) {
+		_ipu_dp_dc_disable(channel);
+	} else if (wait_for_stop) {
+		timeout = 40;
+		while (idma_is_set(IDMAC_CHA_BUSY, in_dma) ||
+		       idma_is_set(IDMAC_CHA_BUSY, out_dma) ||
+		       (_ipu_channel_status(channel) == TASK_STAT_ACTIVE)) {
+			timeout--;
+			msleep(10);
+			if (timeout == 0) {
+				ipu_dump_registers();
+				break;
+			}
+		}
+		dev_dbg(g_ipu_dev, "timeout = %d * 10ms\n", 40 - timeout);
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	/* Disable IC task */
+	if (IPU_CHAN_ID(channel) < IPU_CHAN_ID(MEM_DC_SYNC))
+		_ipu_ic_disable_task(channel);
+
+	/* Disable DMA channel(s) */
+	if (idma_is_valid(in_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(in_dma));
+		__raw_writel(reg & ~idma_mask(in_dma), IDMAC_CHA_EN(in_dma));
+		__raw_writel(idma_mask(in_dma), IPU_CHA_CUR_BUF(in_dma));
+	}
+	if (idma_is_valid(out_dma)) {
+		reg = __raw_readl(IDMAC_CHA_EN(out_dma));
+		__raw_writel(reg & ~idma_mask(out_dma), IDMAC_CHA_EN(out_dma));
+		__raw_writel(idma_mask(out_dma), IPU_CHA_CUR_BUF(out_dma));
+	}
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disable_channel);
+
+static irqreturn_t ipu_irq_handler(int irq, void *desc)
+{
+	int i;
+	uint32_t line;
+	irqreturn_t result = IRQ_NONE;
+	uint32_t int_stat;
+	const int err_reg[] = { 5, 6, 9, 10, 0 };
+	const int int_reg[] = { 1, 2, 3, 4, 11, 12, 13, 14, 15, 0 };
+
+	if (g_ipu_irq[1]) {
+		disable_irq(g_ipu_irq[0]);
+		disable_irq(g_ipu_irq[1]);
+	}
+
+	for (i = 0;; i++) {
+		if (err_reg[i] == 0)
+			break;
+		int_stat = __raw_readl(IPU_INT_STAT(err_reg[i]));
+		int_stat &= __raw_readl(IPU_INT_CTRL(err_reg[i]));
+		if (int_stat) {
+			__raw_writel(int_stat, IPU_INT_STAT(err_reg[i]));
+			dev_err(g_ipu_dev,
+				"IPU Error - IPU_INT_STAT_%d = 0x%08X\n",
+				err_reg[i], int_stat);
+
+			/* Disable interrupts so we only get error once */
+			int_stat =
+			    __raw_readl(IPU_INT_CTRL(err_reg[i])) & ~int_stat;
+			__raw_writel(int_stat, IPU_INT_CTRL(err_reg[i]));
+		}
+	}
+
+	for (i = 0;; i++) {
+		if (int_reg[i] == 0)
+			break;
+		int_stat = __raw_readl(IPU_INT_STAT(int_reg[i]));
+		int_stat &= __raw_readl(IPU_INT_CTRL(int_reg[i]));
+		__raw_writel(int_stat, IPU_INT_STAT(int_reg[i]));
+		while ((line = ffs(int_stat)) != 0) {
+			line--;
+			int_stat &= ~(1UL << line);
+			line += (int_reg[i] - 1) * 32;
+			result |=
+			    ipu_irq_list[line].handler(line,
+						       ipu_irq_list[line].
+						       dev_id);
+		}
+	}
+
+	if (g_ipu_irq[1]) {
+		enable_irq(g_ipu_irq[0]);
+		enable_irq(g_ipu_irq[1]);
+	}
+	return result;
+}
+
+/*!
+ * This function enables the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to enable interrupt for.
+ *
+ */
+void ipu_enable_irq(uint32_t irq)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPUIRQ_2_CTRLREG(irq));
+	reg |= IPUIRQ_2_MASK(irq);
+	__raw_writel(reg, IPUIRQ_2_CTRLREG(irq));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+}
+EXPORT_SYMBOL(ipu_enable_irq);
+
+/*!
+ * This function disables the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to disable interrupt for.
+ *
+ */
+void ipu_disable_irq(uint32_t irq)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(IPUIRQ_2_CTRLREG(irq));
+	reg &= ~IPUIRQ_2_MASK(irq);
+	__raw_writel(reg, IPUIRQ_2_CTRLREG(irq));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+}
+EXPORT_SYMBOL(ipu_disable_irq);
+
+/*!
+ * This function clears the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to clear interrupt for.
+ *
+ */
+void ipu_clear_irq(uint32_t irq)
+{
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	__raw_writel(IPUIRQ_2_MASK(irq), IPUIRQ_2_STATREG(irq));
+
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+}
+EXPORT_SYMBOL(ipu_clear_irq);
+
+/*!
+ * This function returns the current interrupt status for the specified
+ * interrupt line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @return      Returns true if the interrupt is pending/asserted or false if
+ *              the interrupt is not pending.
+ */
+bool ipu_get_irq_status(uint32_t irq)
+{
+	uint32_t reg;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	reg = __raw_readl(IPUIRQ_2_STATREG(irq));
+
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+
+	if (reg & IPUIRQ_2_MASK(irq))
+		return true;
+	else
+		return false;
+}
+EXPORT_SYMBOL(ipu_get_irq_status);
+
+/*!
+ * This function registers an interrupt handler function for the specified
+ * interrupt line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @param       handler         Input parameter for address of the handler
+ *                              function.
+ *
+ * @param       irq_flags       Flags for interrupt mode. Currently not used.
+ *
+ * @param       devname         Input parameter for string name of driver
+ *                              registering the handler.
+ *
+ * @param       dev_id          Input parameter for pointer of data to be
+ *                              passed to the handler.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int ipu_request_irq(uint32_t irq,
+		    irqreturn_t(*handler) (int, void *),
+		    uint32_t irq_flags, const char *devname, void *dev_id)
+{
+	unsigned long lock_flags;
+
+	BUG_ON(irq >= IPU_IRQ_COUNT);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (ipu_irq_list[irq].handler != NULL) {
+		dev_err(g_ipu_dev,
+			"handler already installed on irq %d\n", irq);
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -EINVAL;
+	}
+
+	ipu_irq_list[irq].handler = handler;
+	ipu_irq_list[irq].flags = irq_flags;
+	ipu_irq_list[irq].dev_id = dev_id;
+	ipu_irq_list[irq].name = devname;
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	ipu_enable_irq(irq);	/* enable the interrupt */
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_request_irq);
+
+/*!
+ * This function unregisters an interrupt handler for the specified interrupt
+ * line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @param       dev_id          Input parameter for pointer of data to be passed
+ *                              to the handler. This must match value passed to
+ *                              ipu_request_irq().
+ *
+ */
+void ipu_free_irq(uint32_t irq, void *dev_id)
+{
+	ipu_disable_irq(irq);	/* disable the interrupt */
+
+	if (ipu_irq_list[irq].dev_id == dev_id)
+		ipu_irq_list[irq].handler = NULL;
+}
+EXPORT_SYMBOL(ipu_free_irq);
+
+uint32_t _ipu_channel_status(ipu_channel_t channel)
+{
+	uint32_t stat = 0;
+	uint32_t task_stat_reg = __raw_readl(IPU_PROC_TASK_STAT);
+
+	switch (channel) {
+	case MEM_PRP_VF_MEM:
+		stat = (task_stat_reg & TSTAT_VF_MASK) >> TSTAT_VF_OFFSET;
+		break;
+	case MEM_ROT_VF_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_VF_ROT_MASK) >> TSTAT_VF_ROT_OFFSET;
+		break;
+	case MEM_PRP_ENC_MEM:
+		stat = (task_stat_reg & TSTAT_ENC_MASK) >> TSTAT_ENC_OFFSET;
+		break;
+	case MEM_ROT_ENC_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_ENC_ROT_MASK) >>
+		    TSTAT_ENC_ROT_OFFSET;
+		break;
+	case MEM_PP_MEM:
+		stat = (task_stat_reg & TSTAT_PP_MASK) >> TSTAT_PP_OFFSET;
+		break;
+	case MEM_ROT_PP_MEM:
+		stat =
+		    (task_stat_reg & TSTAT_PP_ROT_MASK) >> TSTAT_PP_ROT_OFFSET;
+		break;
+
+	default:
+		stat = TASK_STAT_IDLE;
+		break;
+	}
+	return stat;
+}
+
+uint32_t bytes_per_pixel(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_GENERIC:	/*generic data */
+	case IPU_PIX_FMT_RGB332:
+	case IPU_PIX_FMT_YUV420P:
+	case IPU_PIX_FMT_YUV422P:
+		return 1;
+		break;
+	case IPU_PIX_FMT_RGB565:
+	case IPU_PIX_FMT_YUYV:
+	case IPU_PIX_FMT_UYVY:
+		return 2;
+		break;
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+		return 3;
+		break;
+	case IPU_PIX_FMT_GENERIC_32:	/*generic data */
+	case IPU_PIX_FMT_BGR32:
+	case IPU_PIX_FMT_RGB32:
+	case IPU_PIX_FMT_ABGR32:
+		return 4;
+		break;
+	default:
+		return 1;
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(bytes_per_pixel);
+
+ipu_color_space_t format_to_colorspace(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_RGB666:
+	case IPU_PIX_FMT_RGB565:
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_BGR32:
+	case IPU_PIX_FMT_RGB32:
+		return RGB;
+		break;
+
+	default:
+		return YCbCr;
+		break;
+	}
+	return RGB;
+}
+
+static int ipu_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int ipu_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcipu_driver = {
+	.driver = {
+		   .name = "mxc_ipu",
+		   },
+	.probe = ipu_probe,
+	.remove = ipu_remove,
+	.suspend = ipu_suspend,
+	.resume = ipu_resume,
+};
+
+int32_t __init ipu_gen_init(void)
+{
+	int32_t ret;
+
+	ret = platform_driver_register(&mxcipu_driver);
+	return 0;
+}
+
+subsys_initcall(ipu_gen_init);
+
+static void __exit ipu_gen_uninit(void)
+{
+	platform_driver_unregister(&mxcipu_driver);
+}
+
+module_exit(ipu_gen_uninit);
+
diff --git a/drivers/mxc/ipu3/ipu_disp.c b/drivers/mxc/ipu3/ipu_disp.c
new file mode 100644
index 0000000..d64832a
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_disp.c
@@ -0,0 +1,902 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ipu_disp.c
+ *
+ * @brief IPU display submodule API functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+#include <asm/io.h>
+#include <asm/arch/ipu.h>
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+#define SYNC_WAVE 0
+
+static void _ipu_di_data_wave_config(int di,
+				     int wave_gen,
+				     int access_size, int component_size)
+{
+	u32 reg;
+	reg = (access_size << DI_DW_GEN_ACCESS_SIZE_OFFSET) |
+	    (component_size << DI_DW_GEN_COMPONENT_SIZE_OFFSET);
+	__raw_writel(reg, DI_DW_GEN(di, wave_gen));
+}
+
+static void _ipu_di_data_pin_config(int di, int wave_gen, int di_pin, int set,
+				    int up, int down)
+{
+	u32 reg;
+
+	reg = __raw_readl(DI_DW_GEN(di, wave_gen));
+	reg &= ~(0x3 << (di_pin * 2));
+	reg |= set << (di_pin * 2);
+	__raw_writel(reg, DI_DW_GEN(di, wave_gen));
+
+	__raw_writel((down << 16) | up, DI_DW_SET(di, wave_gen, set));
+}
+
+static void _ipu_di_sync_config(int di, int wave_gen,
+				int run_count, int run_src,
+				int offset_count, int offset_src,
+				int repeat_count, int cnt_clr_src,
+				int cnt_polarity_gen_en,
+				int cnt_polarity_clr_src,
+				int cnt_polarity_trigger_src,
+				int cnt_up, int cnt_down)
+{
+	u32 reg;
+	reg = (run_count << 19) | (++run_src << 16) |
+	    (offset_count << 3) | ++offset_src;
+	__raw_writel(reg, DI_SW_GEN0(di, wave_gen));
+	reg = (cnt_polarity_gen_en << 29) | (++cnt_clr_src << 25) |
+	    (++cnt_polarity_trigger_src << 12) | (++cnt_polarity_clr_src << 9);
+	reg |= (cnt_down << 16) | cnt_up;
+	if (repeat_count == 0) {
+		/* Enable auto reload */
+		reg |= 0x10000000;
+	}
+	__raw_writel(reg, DI_SW_GEN1(di, wave_gen));
+	reg = __raw_readl(DI_STP_REP(di, wave_gen));
+	reg &= ~(0xFFFF << (16 * ((wave_gen - 1) & 0x1)));
+	reg |= repeat_count << (16 * ((wave_gen - 1) & 0x1));
+	__raw_writel(reg, DI_STP_REP(di, wave_gen));
+}
+
+static void _ipu_dc_map_config(int map, int byte_num, int offset, int mask)
+{
+	int ptr = map * 3 + byte_num;
+	u32 reg;
+
+	reg = __raw_readl(DC_MAP_CONF_VAL(ptr));
+	reg &= ~(0xFFFF << (16 * (ptr & 0x1)));
+	reg |= ((offset << 8) | mask) << (16 * (ptr & 0x1));
+	__raw_writel(reg, DC_MAP_CONF_VAL(ptr));
+
+	reg = __raw_readl(DC_MAP_CONF_PTR(map));
+	reg &= ~(0x1F << ((16 * (map & 0x1)) + (5 * byte_num)));
+	reg |= ptr << ((16 * (map & 0x1)) + (5 * byte_num));
+	__raw_writel(reg, DC_MAP_CONF_PTR(map));
+}
+
+static void _ipu_dc_map_clear(int map)
+{
+	u32 reg = __raw_readl(DC_MAP_CONF_PTR(map));
+	__raw_writel(reg & ~(0xFFFF << (16 * (map & 0x1))),
+		     DC_MAP_CONF_PTR(map));
+}
+
+static void _ipu_dc_write_tmpl(int word, u32 opcode, u32 operand, int map,
+			       int wave, int glue, int sync)
+{
+	u32 reg;
+	int stop = 1;
+
+	reg = sync;
+	reg |= (glue << 4);
+	reg |= (++wave << 11);
+	reg |= (++map << 15);
+	reg |= (operand << 20) & 0xFFF00000;
+	__raw_writel(reg, ipu_dc_tmpl_reg + word * 2);
+
+	reg = (operand >> 12);
+	reg |= opcode << 4;
+	reg |= (stop << 9);
+	__raw_writel(reg, ipu_dc_tmpl_reg + word * 2 + 1);
+}
+
+static void _ipu_dc_link_event(int chan, int event, int addr, int priority)
+{
+	u32 reg;
+
+	reg = __raw_readl(DC_RL_CH(chan, event));
+	reg &= ~(0xFFFF << (16 * (event & 0x1)));
+	reg |= ((addr << 8) | priority) << (16 * (event & 0x1));
+	__raw_writel(reg, DC_RL_CH(chan, event));
+}
+
+/*     Y = R *  .299 + G *  .587 + B *  .114;
+       U = R * -.169 + G * -.332 + B *  .500 + 128.;
+       V = R *  .500 + G * -.419 + B * -.0813 + 128.;*/
+static const int rgb2ycbcr_coeff[5][3] = {
+	{153, 301, 58},
+	{-87, -170, 0x0100},
+	{0x100, -215, -42},
+	{0x0000, 0x0200, 0x0200},	/* B0, B1, B2 */
+	{0x2, 0x2, 0x2},	/* S0, S1, S2 */
+};
+
+/*     R = (1.164 * (Y - 16)) + (1.596 * (Cr - 128));
+       G = (1.164 * (Y - 16)) - (0.392 * (Cb - 128)) - (0.813 * (Cr - 128));
+       B = (1.164 * (Y - 16)) + (2.017 * (Cb - 128); */
+static const int ycbcr2rgb_coeff[5][3] = {
+	{0x095, 0x000, 0x0CC},
+	{0x095, 0x3CE, 0x398},
+	{0x095, 0x0FF, 0x000},
+	{0x3E42, 0x010A, 0x3DD6},	/*B0,B1,B2 */
+	{0x1, 0x1, 0x1},	/*S0,S1,S2 */
+};
+
+#define mask_a(a) ((u32)(a) & 0x3FF)
+#define mask_b(b) ((u32)(b) & 0x3FFF)
+
+static int _rgb_to_yuv(int n, int red, int green, int blue)
+{
+	int c;
+	c = red * rgb2ycbcr_coeff[n][0];
+	c += green * rgb2ycbcr_coeff[n][1];
+	c += blue * rgb2ycbcr_coeff[n][2];
+	c /= 16;
+	c += rgb2ycbcr_coeff[3][n] * 4;
+	c += 8;
+	c /= 16;
+	if (c < 0)
+		c = 0;
+	if (c > 255)
+		c = 255;
+	return c;
+}
+
+int _ipu_dp_init(ipu_channel_t channel, uint32_t in_pixel_fmt,
+		 uint32_t out_pixel_fmt)
+{
+	u32 reg;
+	int in_fmt, out_fmt;
+	int dp;
+	int partial = false;
+	const int (*coeff)[5][3];
+
+	if (channel == MEM_FG_SYNC) {
+		dp = DP_SYNC;
+		partial = true;
+	} else if (channel == MEM_BG_SYNC) {
+		dp = DP_SYNC;
+		partial = false;
+	} else if (channel == MEM_BG_ASYNC0) {
+		dp = DP_ASYNC0;
+		partial = false;
+	} else {
+		return -EINVAL;
+	}
+
+	in_fmt = format_to_colorspace(in_pixel_fmt);
+	out_fmt = format_to_colorspace(out_pixel_fmt);
+	if (in_fmt != out_fmt) {
+		reg = __raw_readl(DP_COM_CONF(dp));
+		if (reg & DP_COM_CONF_CSC_DEF_MASK) {
+			dev_err(g_ipu_dev, "DP CSC already in use.\n");
+			return -EBUSY;
+		}
+		reg &= ~DP_COM_CONF_CSC_DEF_MASK;
+		if (partial) {
+			dev_info(g_ipu_dev, "Enable DP CSC for FG\n");
+			reg |= DP_COM_CONF_CSC_DEF_FG;
+		} else {
+			dev_info(g_ipu_dev, "Enable DP CSC for BG\n");
+			reg |= DP_COM_CONF_CSC_DEF_BG;
+		}
+		__raw_writel(reg, DP_COM_CONF(dp));
+
+		if ((in_fmt == RGB) && (out_fmt == YCbCr))
+			coeff = &rgb2ycbcr_coeff;
+		else
+			coeff = &ycbcr2rgb_coeff;
+
+		__raw_writel(mask_a((*coeff)[0][0]) |
+			     (mask_a((*coeff)[0][1]) << 16), DP_CSC_A_0(dp));
+		__raw_writel(mask_a((*coeff)[0][2]) |
+			     (mask_a((*coeff)[1][0]) << 16), DP_CSC_A_1(dp));
+		__raw_writel(mask_a((*coeff)[1][1]) |
+			     (mask_a((*coeff)[1][2]) << 16), DP_CSC_A_2(dp));
+		__raw_writel(mask_a((*coeff)[2][0]) |
+			     (mask_a((*coeff)[2][1]) << 16), DP_CSC_A_3(dp));
+		__raw_writel(mask_a((*coeff)[2][2]) |
+			     (mask_b((*coeff)[3][0]) << 16) |
+			     ((*coeff)[4][0] << 30), DP_CSC_0(dp));
+		__raw_writel(mask_b((*coeff)[3][1]) | ((*coeff)[4][1] << 14) |
+			     (mask_b((*coeff)[3][2]) << 16) |
+			     ((*coeff)[4][2] << 30), DP_CSC_1(dp));
+	}
+
+	reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+	__raw_writel(reg, IPU_SRM_PRI2);
+
+	return 0;
+}
+
+void _ipu_dp_uninit(ipu_channel_t channel)
+{
+	u32 reg, csc;
+	int dp;
+	int partial = false;
+
+	if (channel == MEM_FG_SYNC) {
+		dp = DP_SYNC;
+		partial = true;
+	} else if (channel == MEM_BG_SYNC) {
+		dp = DP_SYNC;
+		partial = false;
+	} else if (channel == MEM_BG_ASYNC0) {
+		dp = DP_ASYNC0;
+		partial = false;
+	} else {
+		return;
+	}
+
+	reg = __raw_readl(DP_COM_CONF(dp));
+	csc = reg & DP_COM_CONF_CSC_DEF_MASK;
+	if (partial && (csc != DP_COM_CONF_CSC_DEF_FG))
+		return;
+	if (!partial && (csc != DP_COM_CONF_CSC_DEF_BG))
+		return;
+
+	dev_info(g_ipu_dev, "Disable DP CSC for %s\n", partial ? "FG" : "BG");
+	reg &= ~DP_COM_CONF_CSC_DEF_MASK;
+	__raw_writel(reg, DP_COM_CONF(dp));
+
+	reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+	__raw_writel(reg, IPU_SRM_PRI2);
+}
+
+void _ipu_dc_init(int dc_chan, int di, bool interlaced)
+{
+	u32 reg;
+
+	if ((dc_chan == 1) || (dc_chan == 5)) {
+		if (interlaced) {
+			reg = 0;
+			reg |= dc_chan << DC_UGDE_0_ID_CODED_OFFSET;
+			reg |= 1 << DC_UGDE_0_EV_PRIORITY_OFFSET;
+			reg |= DC_UGDE_0_ODD_EN;
+			__raw_writel(reg, DC_UGDE_0(0));
+
+			_ipu_dc_link_event(dc_chan, DC_EVT_NL, 0, 0);
+			_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 0, 0);
+			_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 0, 0);
+		} else {
+			_ipu_dc_link_event(dc_chan, DC_EVT_NL, 2, 3);
+			_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 3, 2);
+			_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 4, 1);
+		}
+		_ipu_dc_link_event(dc_chan, DC_EVT_NF, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NFIELD, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOF, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOFIELD, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR, 0, 0);
+	} else {
+		/* async channels */
+	}
+
+	reg = 0x9A;
+	reg |= di << 2;
+	if (interlaced)
+		reg |= DC_WR_CH_CONF_FIELD_MODE;
+
+	if (dc_chan == 1) {
+		__raw_writel(reg, DC_WR_CH_CONF_1);
+		__raw_writel(0x00000000, DC_WR_CH_ADDR_1);
+	} else if (dc_chan == 5) {
+		__raw_writel(reg, DC_WR_CH_CONF_5);
+		__raw_writel(0x00000000, DC_WR_CH_ADDR_5);
+	}
+	__raw_writel(0x00000044, DC_GEN);
+}
+
+void _ipu_dc_uninit(int dc_chan)
+{
+	if ((dc_chan == 1) || (dc_chan == 5)) {
+		__raw_writel(0, DC_UGDE_0(0));
+		_ipu_dc_link_event(dc_chan, DC_EVT_NL, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOL, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NF, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NFIELD, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOF, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_EOFIELD, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_CHAN, 0, 0);
+		_ipu_dc_link_event(dc_chan, DC_EVT_NEW_ADDR, 0, 0);
+	} else {
+		/* async channels */
+	}
+}
+
+int _ipu_chan_is_interlaced(ipu_channel_t channel)
+{
+	if (channel == MEM_DC_SYNC)
+		return !!(__raw_readl(DC_WR_CH_CONF_1) &
+			  DC_WR_CH_CONF_FIELD_MODE);
+	else if ((channel == MEM_BG_SYNC) || (channel == MEM_FG_SYNC))
+		return !!(__raw_readl(DC_WR_CH_CONF_5) &
+			  DC_WR_CH_CONF_FIELD_MODE);
+	return 0;
+}
+
+void _ipu_dp_dc_enable(ipu_channel_t channel)
+{
+	uint32_t reg;
+	uint32_t *dc_ch_conf;
+	int irq = 0;
+
+	if (channel == MEM_FG_SYNC)
+		irq = IPU_IRQ_DP_SF_END;
+	else if (channel == MEM_DC_SYNC)
+		dc_ch_conf = DC_WR_CH_CONF_1;
+	else if (channel == MEM_BG_SYNC)
+		dc_ch_conf = DC_WR_CH_CONF_5;
+	else
+		return;
+
+	if (channel == MEM_FG_SYNC) {
+		/* Enable FG channel */
+		reg = __raw_readl(DP_COM_CONF(DP_SYNC));
+		__raw_writel(reg | DP_COM_CONF_FG_EN, DP_COM_CONF(DP_SYNC));
+
+		reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+		__raw_writel(reg, IPU_SRM_PRI2);
+		return;
+	}
+
+	reg = __raw_readl(IPU_DISP_GEN);
+	if (g_ipu_di_channel[0] == channel)
+		reg |= DI0_COUNTER_RELEASE;
+	else if (g_ipu_di_channel[1] == channel)
+		reg |= DI1_COUNTER_RELEASE;
+	__raw_writel(reg, IPU_DISP_GEN);
+
+	reg = __raw_readl(dc_ch_conf);
+	reg |= 4 << DC_WR_CH_CONF_PROG_TYPE_OFFSET;
+	__raw_writel(reg, dc_ch_conf);
+}
+
+void _ipu_dp_dc_disable(ipu_channel_t channel)
+{
+	uint32_t lock_flags;
+	uint32_t reg;
+	uint32_t *dc_ch_conf;
+	int irq = 0;
+	int timeout = 30;
+
+	if (channel == MEM_FG_SYNC) {
+		dc_ch_conf = DC_WR_CH_CONF_5;
+		irq = IPU_IRQ_DP_SF_END;
+	} else if (channel == MEM_DC_SYNC) {
+		dc_ch_conf = DC_WR_CH_CONF_1;
+		irq = IPU_IRQ_DC_FC_1;
+	} else if (channel == MEM_BG_SYNC) {
+		dc_ch_conf = DC_WR_CH_CONF_5;
+		irq = IPU_IRQ_DP_SF_END;
+	} else {
+		return;
+	}
+
+	if (channel == MEM_FG_SYNC) {
+		/* Disable FG channel */
+		reg = __raw_readl(DP_COM_CONF(DP_SYNC));
+		__raw_writel(reg & ~DP_COM_CONF_FG_EN, DP_COM_CONF(DP_SYNC));
+
+		reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+		__raw_writel(reg, IPU_SRM_PRI2);
+	}
+
+	__raw_writel(IPUIRQ_2_MASK(irq), IPUIRQ_2_STATREG(irq));
+	while ((__raw_readl(IPUIRQ_2_STATREG(irq)) & IPUIRQ_2_MASK(irq)) == 0) {
+		timeout--;
+		msleep(1);
+		if (timeout == 0) {
+			ipu_dump_registers();
+			break;
+		}
+	}
+	dev_dbg(g_ipu_dev, "timeout = %d ms\n", (30 - timeout));
+
+	/* Wait for DI triple buffer to empty */
+	if (g_ipu_di_channel[0] == channel)
+		while ((__raw_readl(DC_STAT) & 0x00000002) != 0x00000002) ;
+	else if (g_ipu_di_channel[1] == channel)
+		while ((__raw_readl(DC_STAT) & 0x00000020) != 0x00000020) ;
+
+	udelay(50);
+
+	if (channel == MEM_FG_SYNC)
+		return;
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	reg = __raw_readl(dc_ch_conf);
+	reg &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;
+	__raw_writel(reg, dc_ch_conf);
+
+	reg = __raw_readl(IPU_DISP_GEN);
+	if (g_ipu_di_channel[0] == channel)
+		reg &= ~DI0_COUNTER_RELEASE;
+	else if (g_ipu_di_channel[1] == channel)
+		reg &= ~DI1_COUNTER_RELEASE;
+	__raw_writel(reg, IPU_DISP_GEN);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+}
+
+void _ipu_init_dc_mappings(void)
+{
+	/* IPU_PIX_FMT_RGB24 */
+	_ipu_dc_map_clear(0);
+	_ipu_dc_map_config(0, 0, 7, 0xFF);
+	_ipu_dc_map_config(0, 1, 15, 0xFF);
+	_ipu_dc_map_config(0, 2, 23, 0xFF);
+
+	/* IPU_PIX_FMT_RGB666 */
+	_ipu_dc_map_clear(1);
+	_ipu_dc_map_config(1, 0, 5, 0xFC);
+	_ipu_dc_map_config(1, 1, 11, 0xFC);
+	_ipu_dc_map_config(1, 2, 17, 0xFC);
+
+	/* IPU_PIX_FMT_YUV444 */
+	_ipu_dc_map_clear(2);
+	_ipu_dc_map_config(2, 0, 15, 0xFF);
+	_ipu_dc_map_config(2, 1, 23, 0xFF);
+	_ipu_dc_map_config(2, 2, 7, 0xFF);
+}
+
+int _ipu_pixfmt_to_map(uint32_t fmt)
+{
+	switch (fmt) {
+	case IPU_PIX_FMT_RGB24:
+		return 0;
+	case IPU_PIX_FMT_RGB666:
+		return 1;
+	case IPU_PIX_FMT_YUV444:
+		return 2;
+	}
+
+	return -1;
+}
+
+/*!
+ * This function is called to initialize a synchronous LCD panel.
+ *
+ * @param       disp            The DI the panel is attached to.
+ *
+ * @param       pixel_clk       Desired pixel clock frequency in Hz.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer.
+ *                              Pixel format is a FOURCC ASCII code.
+ *
+ * @param       width           The width of panel in pixels.
+ *
+ * @param       height          The height of panel in pixels.
+ *
+ * @param       hStartWidth     The number of pixel clocks between the HSYNC
+ *                              signal pulse and the start of valid data.
+ *
+ * @param       hSyncWidth      The width of the HSYNC signal in units of pixel
+ *                              clocks.
+ *
+ * @param       hEndWidth       The number of pixel clocks between the end of
+ *                              valid data and the HSYNC signal for next line.
+ *
+ * @param       vStartWidth     The number of lines between the VSYNC
+ *                              signal pulse and the start of valid data.
+ *
+ * @param       vSyncWidth      The width of the VSYNC signal in units of lines
+ *
+ * @param       vEndWidth       The number of lines between the end of valid
+ *                              data and the VSYNC signal for next frame.
+ *
+ * @param       sig             Bitfield of signal polarities for LCD interface.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int32_t ipu_init_sync_panel(int disp, uint32_t pixel_clk,
+			    uint16_t width, uint16_t height,
+			    uint32_t pixel_fmt,
+			    uint16_t h_start_width, uint16_t h_sync_width,
+			    uint16_t h_end_width, uint16_t v_start_width,
+			    uint16_t v_sync_width, uint16_t v_end_width,
+			    uint32_t v_to_h_sync, ipu_di_signal_cfg_t sig)
+{
+	unsigned long lock_flags;
+	uint32_t field0_offset = 0;
+	uint32_t field1_offset;
+	uint32_t reg;
+	uint32_t disp_gen, di_gen, vsync_cnt;
+	uint32_t div, up;
+	uint32_t h_total, v_total;
+	int map;
+
+	dev_dbg(g_ipu_dev, "panel size = %d x %d\n", width, height);
+
+	if ((v_sync_width == 0) || (h_sync_width == 0))
+		return EINVAL;
+
+	h_total = width + h_sync_width + h_start_width + h_end_width;
+	v_total = height + v_sync_width + v_start_width + v_end_width;
+
+	/* Init clocking */
+	dev_dbg(g_ipu_dev, "pixel clk = %d\n", pixel_clk);
+	div = (clk_get_rate(g_di_clk[disp]) * 16) / pixel_clk;
+	reg = __raw_readl(DI_GENERAL(disp));
+	if (sig.ext_clk) {
+		__raw_writel(reg | DI_GEN_DI_CLK_EXT, DI_GENERAL(disp));
+		if (div < 0x10)
+			div = 0x10;
+	} else {
+		__raw_writel(reg & ~DI_GEN_DI_CLK_EXT, DI_GENERAL(disp));
+		/* Calculate divider */
+		/* fractional part is 4 bits,
+		   so simply multiply by 2^4 to get fractional part */
+		if (div < 0x40) {	/* Divider less than 4 */
+			dev_dbg(g_ipu_dev, "Pixel clock divider less than 4\n");
+			div = 0x40;
+		}
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	disp_gen = __raw_readl(IPU_DISP_GEN);
+	disp_gen &= disp ? ~DI1_COUNTER_RELEASE : ~DI0_COUNTER_RELEASE;
+	__raw_writel(disp_gen, IPU_DISP_GEN);
+
+	__raw_writel(div, DI_BS_CLKGEN0(disp));
+
+	/* Setup pixel clock timing */
+	/* FIXME: needs to be more flexible */
+	if (disp) {
+		/* down time is half of period */
+		__raw_writel((div / 16) << 16, DI_BS_CLKGEN1(disp));
+	} else {
+		up = div / 16 - 2;
+		__raw_writel(((up * 2) << 16) | up, DI_BS_CLKGEN1(disp));
+	}
+	_ipu_di_data_wave_config(disp, SYNC_WAVE, div / 16 - 1, div / 16 - 1);
+	_ipu_di_data_pin_config(disp, SYNC_WAVE, DI_PIN15, 3, 0, div / 16 * 2);
+
+	div = div / 16;		/* Now divider is integer portion */
+
+	map = _ipu_pixfmt_to_map(pixel_fmt);
+	if (map < 0) {
+		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		return -EINVAL;
+	}
+
+	di_gen = 0;
+	if (sig.ext_clk)
+		di_gen |= DI_GEN_DI_CLK_EXT;
+
+	/* Setup internal HSYNC waveform */
+	_ipu_di_sync_config(disp, 1, h_total - 1, DI_SYNC_CLK,
+			    0, DI_SYNC_NONE, 0, DI_SYNC_NONE, 0, DI_SYNC_NONE,
+			    DI_SYNC_NONE, 0, 0);
+	if (sig.interlaced) {
+		field1_offset = v_sync_width + v_start_width + height / 2 +
+		    v_end_width;
+		if (sig.odd_field_first) {
+			field0_offset = field1_offset;
+			field1_offset = 0;
+		}
+		v_total += v_start_width + v_end_width;
+
+		/* Field 1 VSYNC waveform */
+		_ipu_di_sync_config(disp, 2, v_total - 1, 1,
+				    field0_offset,
+				    field0_offset ? 1 : DI_SYNC_NONE,
+				    0, DI_SYNC_NONE, 0,
+				    DI_SYNC_NONE, DI_SYNC_NONE, 0, 4);
+
+		/* Setup internal HSYNC waveform */
+		_ipu_di_sync_config(disp, 3, h_total - 1, DI_SYNC_CLK,
+				    0, DI_SYNC_NONE, 0, DI_SYNC_NONE, 0,
+				    DI_SYNC_NONE, DI_SYNC_NONE, 0, 4);
+
+		/* Active Field ? */
+		_ipu_di_sync_config(disp, 4,
+				    field0_offset ?
+				    field0_offset - 1 : field1_offset - 2,
+				    1, v_start_width + v_sync_width, 1, 2, 2,
+				    0, DI_SYNC_NONE, DI_SYNC_NONE, 0, 0);
+
+		/* Active Line */
+		_ipu_di_sync_config(disp, 5, 0, 1,
+				    0, DI_SYNC_NONE,
+				    height / 2, 4, 0, DI_SYNC_NONE,
+				    DI_SYNC_NONE, 0, 0);
+
+		/* Field 0 VSYNC waveform */
+		_ipu_di_sync_config(disp, 6, v_total - 1, 1,
+				    0, DI_SYNC_NONE,
+				    0, DI_SYNC_NONE, 0, DI_SYNC_NONE,
+				    DI_SYNC_NONE, 0, 0);
+
+		/* DC VSYNC waveform */
+		vsync_cnt = 7;
+		_ipu_di_sync_config(disp, 7, 0, 1,
+				    field1_offset,
+				    field1_offset ? 1 : DI_SYNC_NONE,
+				    1, 2, 0, DI_SYNC_NONE, DI_SYNC_NONE, 0, 0);
+
+		/* active pixel waveform */
+		_ipu_di_sync_config(disp, 8, 0, DI_SYNC_CLK,
+				    h_sync_width + h_start_width, DI_SYNC_CLK,
+				    width, 5, 0, DI_SYNC_NONE, DI_SYNC_NONE,
+				    0, 0);
+
+		/* ??? */
+		_ipu_di_sync_config(disp, 9, v_total - 1, 2,
+				    0, DI_SYNC_NONE,
+				    0, DI_SYNC_NONE, 6, DI_SYNC_NONE,
+				    DI_SYNC_NONE, 0, 0);
+
+		/* Init template microcode */
+		_ipu_dc_write_tmpl(0, WROD(0), 0, map, SYNC_WAVE, 0, 8);
+
+		__raw_writel(width - 1, DC_UGDE_3(0));
+		__raw_writel(v_start_width + v_end_width + height / 2 - 1,
+			     DI_SCR_CONF(disp));
+
+		if (sig.Hsync_pol)
+			di_gen |= DI_GEN_POLARITY_3;
+		if (sig.Vsync_pol)
+			di_gen |= DI_GEN_POLARITY_2;
+	} else {
+		/* Setup external (delayed) HSYNC waveform */
+		_ipu_di_sync_config(disp, DI_SYNC_HSYNC, h_total - 1,
+				    DI_SYNC_CLK, div * v_to_h_sync, DI_SYNC_CLK,
+				    0, DI_SYNC_NONE, 0, DI_SYNC_NONE,
+				    DI_SYNC_NONE, 0, div * h_sync_width * 2);
+		/* Setup VSYNC waveform */
+		vsync_cnt = DI_SYNC_VSYNC;
+		_ipu_di_sync_config(disp, DI_SYNC_VSYNC, v_total - 1,
+				    DI_SYNC_INT_HSYNC, 0, DI_SYNC_NONE, 0,
+				    DI_SYNC_NONE, 1, DI_SYNC_NONE,
+				    DI_SYNC_INT_HSYNC, 0, v_sync_width * 2);
+		__raw_writel(v_total - 1, DI_SCR_CONF(disp));
+
+		/* Setup active data waveform to sync with DC */
+		_ipu_di_sync_config(disp, 4, 0, DI_SYNC_HSYNC,
+				    v_start_width, DI_SYNC_HSYNC, height,
+				    DI_SYNC_VSYNC, 0, DI_SYNC_NONE,
+				    DI_SYNC_NONE, 0, 0);
+		_ipu_di_sync_config(disp, 5, 0, DI_SYNC_CLK,
+				    h_sync_width + h_start_width, DI_SYNC_CLK,
+				    width, 4, 0, DI_SYNC_NONE, DI_SYNC_NONE, 0,
+				    0);
+
+		/* Init template microcode */
+		_ipu_dc_write_tmpl(2, WROD(0), 0, map, SYNC_WAVE, 8, 5);
+		_ipu_dc_write_tmpl(3, WROD(0), 0, map, SYNC_WAVE, 4, 5);
+		_ipu_dc_write_tmpl(4, WROD(0), 0, map, SYNC_WAVE, 0, 5);
+
+		if (sig.Hsync_pol)
+			di_gen |= DI_GEN_POLARITY_2;
+		if (sig.Vsync_pol)
+			di_gen |= DI_GEN_POLARITY_3;
+	}
+
+	__raw_writel(di_gen, DI_GENERAL(disp));
+	__raw_writel((--vsync_cnt << DI_VSYNC_SEL_OFFSET) | 0x00000002,
+		     DI_SYNC_AS_GEN(disp));
+
+	reg = __raw_readl(DI_POL(disp));
+	reg &= ~(DI_POL_DRDY_DATA_POLARITY | DI_POL_DRDY_POLARITY_15);
+	if (sig.enable_pol)
+		reg |= DI_POL_DRDY_POLARITY_15;
+	if (sig.data_pol)
+		reg |= DI_POL_DRDY_DATA_POLARITY;
+	__raw_writel(reg, DI_POL(disp));
+
+	__raw_writel(width, DC_DISP_CONF2(3));
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_sync_panel);
+
+/*!
+ * This function sets the foreground and background plane global alpha blending
+ * modes.
+ *
+ * @param       enable          Boolean to enable or disable global alpha
+ *                              blending. If disabled, local blending is used.
+ *
+ * @param       alpha           Global alpha value.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_global_alpha(ipu_channel_t channel, bool enable,
+				  uint8_t alpha)
+{
+	uint32_t reg;
+	uint32_t flow;
+	unsigned long lock_flags;
+
+	if (channel == MEM_BG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_BG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (enable) {
+		reg = __raw_readl(DP_GRAPH_WIND_CTRL(flow)) & 0x00FFFFFFL;
+		__raw_writel(reg | ((uint32_t) alpha << 24),
+			     DP_GRAPH_WIND_CTRL(flow));
+
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg | DP_COM_CONF_GWAM, DP_COM_CONF(flow));
+	} else {
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg & ~DP_COM_CONF_GWAM, DP_COM_CONF(flow));
+	}
+
+	reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+	__raw_writel(reg, IPU_SRM_PRI2);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_global_alpha);
+
+/*!
+ * This function sets the transparent color key for SDC graphic plane.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       enable          Boolean to enable or disable color key
+ *
+ * @param       colorKey        24-bit RGB color for transparent color key.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_color_key(ipu_channel_t channel, bool enable,
+			       uint32_t color_key)
+{
+	uint32_t reg, flow;
+	int y, u, v;
+	int red, green, blue;
+	unsigned long lock_flags;
+
+	if (channel == MEM_BG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_BG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	/* Transform color key from rgb to yuv if CSC is enabled */
+	reg = __raw_readl(DP_COM_CONF(flow));
+	if ((reg & DP_COM_CONF_CSC_DEF_MASK) == DP_COM_CONF_CSC_DEF_BG) {
+		red = (color_key >> 16) & 0xFF;
+		green = (color_key >> 8) & 0xFF;
+		blue = color_key & 0xFF;
+
+		y = _rgb_to_yuv(0, red, green, blue);
+		u = _rgb_to_yuv(0, red, green, blue);
+		v = _rgb_to_yuv(0, red, green, blue);
+		color_key = (y << 16) | (u << 8) | v;
+	}
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	if (enable) {
+		reg = __raw_readl(DP_GRAPH_WIND_CTRL(flow)) & 0xFF000000L;
+		__raw_writel(reg | color_key, DP_GRAPH_WIND_CTRL(flow));
+
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg | DP_COM_CONF_GWCKE, DP_COM_CONF(flow));
+	} else {
+		reg = __raw_readl(DP_COM_CONF(flow));
+		__raw_writel(reg & ~DP_COM_CONF_GWCKE, DP_COM_CONF(flow));
+	}
+
+	reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+	__raw_writel(reg, IPU_SRM_PRI2);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_color_key);
+
+/*!
+ * This function sets the window position of the foreground or background plane.
+ * modes.
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       x_pos           The X coordinate position to place window at.
+ *                              The position is relative to the top left corner.
+ *
+ * @param       y_pos           The Y coordinate position to place window at.
+ *                              The position is relative to the top left corner.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_window_pos(ipu_channel_t channel, int16_t x_pos,
+				int16_t y_pos)
+{
+	u32 reg;
+	unsigned long lock_flags;
+	uint32_t flow = 0;
+
+	if (channel == MEM_FG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_FG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_FG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	if (!g_ipu_clk_enabled)
+		clk_enable(g_ipu_clk);
+
+	spin_lock_irqsave(&ipu_lock, lock_flags);
+
+	__raw_writel((x_pos << 16) | y_pos, DP_FG_POS(flow));
+
+	reg = __raw_readl(IPU_SRM_PRI2) | 0x8;
+	__raw_writel(reg, IPU_SRM_PRI2);
+
+	spin_unlock_irqrestore(&ipu_lock, lock_flags);
+	if (!g_ipu_clk_enabled)
+		clk_disable(g_ipu_clk);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_window_pos);
diff --git a/drivers/mxc/ipu3/ipu_ic.c b/drivers/mxc/ipu3/ipu_ic.c
new file mode 100644
index 0000000..197f98e
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_ic.c
@@ -0,0 +1,550 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_ic.c
+ *
+ * @brief IPU IC functions
+ *
+ * @ingroup IPU
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include <asm/arch/ipu.h>
+
+#include "ipu_prv.h"
+#include "ipu_regs.h"
+#include "ipu_param_mem.h"
+
+enum {
+	IC_TASK_VIEWFINDER,
+	IC_TASK_ENCODER,
+	IC_TASK_POST_PROCESSOR
+};
+
+static void _init_csc(uint8_t ic_task, ipu_color_space_t in_format,
+		      ipu_color_space_t out_format);
+static bool _calc_resize_coeffs(uint32_t inSize, uint32_t outSize,
+				uint32_t *resizeCoeff,
+				uint32_t *downsizeCoeff);
+
+void _ipu_ic_enable_task(ipu_channel_t channel)
+{
+	uint32_t ic_conf;
+
+	ic_conf = __raw_readl(IC_CONF);
+	switch (channel) {
+	case MEM_PRP_VF_MEM:
+		ic_conf |= IC_CONF_PRPVF_EN;
+		break;
+	case MEM_ROT_VF_MEM:
+		ic_conf |= IC_CONF_PRPVF_ROT_EN;
+		break;
+	case MEM_PRP_ENC_MEM:
+		ic_conf |= IC_CONF_PRPENC_EN;
+		break;
+	case MEM_ROT_ENC_MEM:
+		ic_conf |= IC_CONF_PRPENC_ROT_EN;
+		break;
+	case MEM_PP_MEM:
+		ic_conf |= IC_CONF_PP_EN;
+		break;
+	case MEM_ROT_PP_MEM:
+		ic_conf |= IC_CONF_PP_ROT_EN;
+		break;
+	default:
+		break;
+	}
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_disable_task(ipu_channel_t channel)
+{
+	uint32_t ic_conf;
+
+	ic_conf = __raw_readl(IC_CONF);
+	switch (channel) {
+	case MEM_PRP_VF_MEM:
+		ic_conf &= ~IC_CONF_PRPVF_EN;
+		break;
+	case MEM_ROT_VF_MEM:
+		ic_conf &= ~IC_CONF_PRPVF_ROT_EN;
+		break;
+	case MEM_PRP_ENC_MEM:
+		ic_conf &= ~IC_CONF_PRPENC_EN;
+		break;
+	case MEM_ROT_ENC_MEM:
+		ic_conf &= ~IC_CONF_PRPENC_ROT_EN;
+		break;
+	case MEM_PP_MEM:
+		ic_conf &= ~IC_CONF_PP_EN;
+		break;
+	case MEM_ROT_PP_MEM:
+		ic_conf &= ~IC_CONF_PP_ROT_EN;
+		break;
+	default:
+		break;
+	}
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_init_prpvf(ipu_channel_params_t *params, bool src_is_csi)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_prp_vf_mem.in_height,
+			    params->mem_prp_vf_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	_calc_resize_coeffs(params->mem_prp_vf_mem.in_width,
+			    params->mem_prp_vf_mem.out_width,
+			    &resizeCoeff, &downsizeCoeff);
+	reg |= (downsizeCoeff << 14) | resizeCoeff;
+
+	__raw_writel(reg, IC_PRP_VF_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_prp_vf_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_prp_vf_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+			/* Enable RGB->YCBCR CSC */
+			_init_csc(IC_TASK_VIEWFINDER, RGB, out_fmt);
+			ic_conf |= IC_CONF_PRPVF_CSC1;
+		}
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			/* Enable YCBCR->RGB CSC */
+			_init_csc(IC_TASK_VIEWFINDER, YCbCr, RGB);
+			ic_conf |= IC_CONF_PRPVF_CSC1;
+		} else {
+			/* TODO: Support YUV<->YCbCr conversion? */
+		}
+	}
+
+	if (params->mem_prp_vf_mem.graphics_combine_en) {
+		ic_conf |= IC_CONF_PRPVF_CMB;
+
+		/* need transparent CSC1 conversion */
+		_init_csc(IC_TASK_POST_PROCESSOR, RGB, RGB);
+		ic_conf |= IC_CONF_PRPVF_CSC1;	/* Enable RGB->RGB CSC */
+
+		if (params->mem_prp_vf_mem.global_alpha_en)
+			ic_conf |= IC_CONF_IC_GLB_LOC_A;
+		else
+			ic_conf &= ~IC_CONF_IC_GLB_LOC_A;
+
+		if (params->mem_prp_vf_mem.key_color_en)
+			ic_conf |= IC_CONF_KEY_COLOR_EN;
+		else
+			ic_conf &= ~IC_CONF_KEY_COLOR_EN;
+	} else {
+		ic_conf &= ~IC_CONF_PP_CMB;
+	}
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_prpvf(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPVF_EN | IC_CONF_PRPVF_CMB |
+		 IC_CONF_PRPVF_CSC2 | IC_CONF_PRPVF_CSC1);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_vf(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_vf(void)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~IC_CONF_PRPVF_ROT_EN;
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_prpenc(ipu_channel_params_t *params, bool src_is_csi)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_prp_enc_mem.in_height,
+			    params->mem_prp_enc_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	_calc_resize_coeffs(params->mem_prp_enc_mem.in_width,
+			    params->mem_prp_enc_mem.out_width,
+			    &resizeCoeff, &downsizeCoeff);
+	reg |= (downsizeCoeff << 14) | resizeCoeff;
+
+	__raw_writel(reg, IC_PRP_ENC_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_prp_enc_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_prp_enc_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+			/* Enable RGB->YCBCR CSC */
+			_init_csc(IC_TASK_ENCODER, RGB, out_fmt);
+			ic_conf |= IC_CONF_PRPENC_CSC1;
+		}
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			/* Enable YCBCR->RGB CSC */
+			_init_csc(IC_TASK_ENCODER, YCbCr, RGB);
+			ic_conf |= IC_CONF_PRPENC_CSC1;
+		} else {
+			/* TODO: Support YUV<->YCbCr conversion? */
+		}
+	}
+
+	if (src_is_csi)
+		ic_conf &= ~IC_CONF_RWS_EN;
+	else
+		ic_conf |= IC_CONF_RWS_EN;
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_prpenc(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPENC_EN | IC_CONF_PRPENC_CSC1);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_enc(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_enc(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PRPENC_ROT_EN);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_pp(ipu_channel_params_t *params)
+{
+	uint32_t reg, ic_conf;
+	uint32_t downsizeCoeff, resizeCoeff;
+	ipu_color_space_t in_fmt, out_fmt;
+
+	/* Setup vertical resizing */
+	_calc_resize_coeffs(params->mem_pp_mem.in_height,
+			    params->mem_pp_mem.out_height,
+			    &resizeCoeff, &downsizeCoeff);
+	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
+
+	/* Setup horizontal resizing */
+	_calc_resize_coeffs(params->mem_pp_mem.in_width,
+			    params->mem_pp_mem.out_width,
+			    &resizeCoeff, &downsizeCoeff);
+	reg |= (downsizeCoeff << 14) | resizeCoeff;
+
+	__raw_writel(reg, IC_PP_RSC);
+
+	ic_conf = __raw_readl(IC_CONF);
+
+	/* Setup color space conversion */
+	in_fmt = format_to_colorspace(params->mem_pp_mem.in_pixel_fmt);
+	out_fmt = format_to_colorspace(params->mem_pp_mem.out_pixel_fmt);
+	if (in_fmt == RGB) {
+		if ((out_fmt == YCbCr) || (out_fmt == YUV)) {
+			/* Enable RGB->YCBCR CSC */
+			_init_csc(IC_TASK_POST_PROCESSOR, RGB, out_fmt);
+			ic_conf |= IC_CONF_PP_CSC2;
+		}
+	}
+	if ((in_fmt == YCbCr) || (in_fmt == YUV)) {
+		if (out_fmt == RGB) {
+			/* Enable YCBCR->RGB CSC */
+			_init_csc(IC_TASK_POST_PROCESSOR, YCbCr, RGB);
+			ic_conf |= IC_CONF_PP_CSC1;
+		} else {
+			/* TODO: Support YUV<->YCbCr conversion? */
+		}
+	}
+
+	if (params->mem_pp_mem.graphics_combine_en) {
+		ic_conf |= IC_CONF_PP_CMB;
+
+		/* need transparent CSC1 conversion */
+		_init_csc(IC_TASK_POST_PROCESSOR, RGB, RGB);
+		ic_conf |= IC_CONF_PP_CSC1;	/* Enable RGB->RGB CSC */
+
+		if (params->mem_pp_mem.global_alpha_en)
+			ic_conf |= IC_CONF_IC_GLB_LOC_A;
+		else
+			ic_conf &= ~IC_CONF_IC_GLB_LOC_A;
+
+		if (params->mem_pp_mem.key_color_en)
+			ic_conf |= IC_CONF_KEY_COLOR_EN;
+		else
+			ic_conf &= ~IC_CONF_KEY_COLOR_EN;
+	} else {
+		ic_conf &= ~IC_CONF_PP_CMB;
+	}
+
+	__raw_writel(ic_conf, IC_CONF);
+}
+
+void _ipu_ic_uninit_pp(void)
+{
+	uint32_t reg;
+
+	reg = __raw_readl(IC_CONF);
+	reg &= ~(IC_CONF_PP_EN | IC_CONF_PP_CSC1 | IC_CONF_PP_CSC2 |
+		 IC_CONF_PP_CMB);
+	__raw_writel(reg, IC_CONF);
+}
+
+void _ipu_ic_init_rotate_pp(ipu_channel_params_t *params)
+{
+}
+
+void _ipu_ic_uninit_rotate_pp(void)
+{
+	uint32_t reg;
+	reg = __raw_readl(IC_CONF);
+	reg &= ~IC_CONF_PP_ROT_EN;
+	__raw_writel(reg, IC_CONF);
+}
+
+int _ipu_ic_idma_init(int dma_chan, uint16_t width, uint16_t height,
+		      int burst_size, ipu_rotate_mode_t rot)
+{
+	u32 ic_idmac_1, ic_idmac_2, ic_idmac_3;
+	u32 temp_rot = bitrev8(rot) >> 5;
+
+	if ((burst_size != 8) && (burst_size != 16)) {
+		dev_dbg(g_ipu_dev, "Illegal burst length for IC\n");
+		return -EINVAL;
+	}
+
+	width--;
+	height--;
+
+	ic_idmac_1 = __raw_readl(IC_IDMAC_1);
+	ic_idmac_2 = __raw_readl(IC_IDMAC_2);
+	ic_idmac_3 = __raw_readl(IC_IDMAC_3);
+	if (dma_chan == 22) {	/* PP output - CB2 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB2_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB2_BURST_16;
+
+		ic_idmac_2 &= ~IC_IDMAC_2_PP_HEIGHT_MASK;
+		ic_idmac_2 |= height << IC_IDMAC_2_PP_HEIGHT_OFFSET;
+
+		ic_idmac_3 &= ~IC_IDMAC_3_PP_WIDTH_MASK;
+		ic_idmac_3 |= width << IC_IDMAC_3_PP_WIDTH_OFFSET;
+
+	} else if (dma_chan == 11) {	/* PP Input - CB5 */
+		if (burst_size == 16)
+			ic_idmac_1 |= IC_IDMAC_1_CB5_BURST_16;
+		else
+			ic_idmac_1 &= ~IC_IDMAC_1_CB5_BURST_16;
+	} else if (dma_chan == 47) {	/* PP Rot input */
+		ic_idmac_1 &= ~IC_IDMAC_1_PP_ROT_MASK;
+		ic_idmac_1 |= temp_rot << IC_IDMAC_1_PP_ROT_OFFSET;
+	}
+	__raw_writel(ic_idmac_1, IC_IDMAC_1);
+	__raw_writel(ic_idmac_2, IC_IDMAC_2);
+	__raw_writel(ic_idmac_3, IC_IDMAC_3);
+
+	return 0;
+}
+
+static void _init_csc(uint8_t ic_task, ipu_color_space_t in_format,
+		      ipu_color_space_t out_format)
+{
+
+/*     Y = R *  .299 + G *  .587 + B *  .114;
+       U = R * -.169 + G * -.332 + B *  .500 + 128.;
+       V = R *  .500 + G * -.419 + B * -.0813 + 128.;*/
+	static const uint32_t rgb2ycbcr_coeff[4][3] = {
+		{0x004D, 0x0096, 0x001D},
+		{0x01D5, 0x01AB, 0x0080},
+		{0x0080, 0x0195, 0x01EB},
+		{0x0000, 0x0200, 0x0200},	/* A0, A1, A2 */
+	};
+
+	/* transparent RGB->RGB matrix for combining
+	 */
+	static const uint32_t rgb2rgb_coeff[4][3] = {
+		{0x0080, 0x0000, 0x0000},
+		{0x0000, 0x0080, 0x0000},
+		{0x0000, 0x0000, 0x0080},
+		{0x0000, 0x0000, 0x0000},	/* A0, A1, A2 */
+	};
+
+/*     R = (1.164 * (Y - 16)) + (1.596 * (Cr - 128));
+       G = (1.164 * (Y - 16)) - (0.392 * (Cb - 128)) - (0.813 * (Cr - 128));
+       B = (1.164 * (Y - 16)) + (2.017 * (Cb - 128); */
+	static const uint32_t ycbcr2rgb_coeff[4][3] = {
+		{149, 0, 204},
+		{149, 462, 408},
+		{149, 255, 0},
+		{8192 - 446, 266, 8192 - 554},	/* A0, A1, A2 */
+	};
+
+	uint32_t param;
+	uint32_t *base = NULL;
+
+	if (ic_task == IC_TASK_VIEWFINDER) {
+		base = ipu_tpmem_base + 0x2008 / 4;
+	} else if (ic_task == IC_TASK_ENCODER) {
+		base = ipu_tpmem_base + 0x4028 / 4;
+	} else if (ic_task == IC_TASK_POST_PROCESSOR) {
+		base = ipu_tpmem_base + 0x6060 / 4;
+	} else {
+		BUG();
+	}
+
+	if ((in_format == YCbCr) && (out_format == RGB)) {
+		/* Init CSC1 (YCbCr->RGB) */
+		param = (ycbcr2rgb_coeff[3][0] << 27) |
+			(ycbcr2rgb_coeff[0][0] << 18) |
+			(ycbcr2rgb_coeff[1][1] << 9) | ycbcr2rgb_coeff[2][2];
+		__raw_writel(param, base++);
+		/* scale = 2, sat = 0 */
+		param = (ycbcr2rgb_coeff[3][0] >> 5) | (2L << (40 - 32));
+		__raw_writel(param, base++);
+
+		param = (ycbcr2rgb_coeff[3][1] << 27) |
+			(ycbcr2rgb_coeff[0][1] << 18) |
+			(ycbcr2rgb_coeff[1][0] << 9) | ycbcr2rgb_coeff[2][0];
+		__raw_writel(param, base++);
+		param = (ycbcr2rgb_coeff[3][1] >> 5);
+		__raw_writel(param, base++);
+
+		param = (ycbcr2rgb_coeff[3][2] << 27) |
+			(ycbcr2rgb_coeff[0][2] << 18) |
+			(ycbcr2rgb_coeff[1][2] << 9) | ycbcr2rgb_coeff[2][1];
+		__raw_writel(param, base++);
+		param = (ycbcr2rgb_coeff[3][2] >> 5);
+		__raw_writel(param, base++);
+	} else if ((in_format == RGB) && (out_format == YCbCr)) {
+		/* Init CSC1 (RGB->YCbCr) */
+		param = (rgb2ycbcr_coeff[3][0] << 27) |
+			(rgb2ycbcr_coeff[0][0] << 18) |
+			(rgb2ycbcr_coeff[1][1] << 9) | rgb2ycbcr_coeff[2][2];
+		__raw_writel(param, base++);
+		/* scale = 1, sat = 0 */
+		param = (rgb2ycbcr_coeff[3][0] >> 5) | (1UL << 8);
+		__raw_writel(param, base++);
+
+		param = (rgb2ycbcr_coeff[3][1] << 27) |
+			(rgb2ycbcr_coeff[0][1] << 18) |
+			(rgb2ycbcr_coeff[1][0] << 9) | rgb2ycbcr_coeff[2][0];
+		__raw_writel(param, base++);
+		param = (rgb2ycbcr_coeff[3][1] >> 5);
+		__raw_writel(param, base++);
+
+		param = (rgb2ycbcr_coeff[3][2] << 27) |
+			(rgb2ycbcr_coeff[0][2] << 18) |
+			(rgb2ycbcr_coeff[1][2] << 9) | rgb2ycbcr_coeff[2][1];
+		__raw_writel(param, base++);
+		param = (rgb2ycbcr_coeff[3][2] >> 5);
+		__raw_writel(param, base++);
+	} else if ((in_format == RGB) && (out_format == RGB)) {
+		/* Init CSC1 */
+		param =
+		    (rgb2rgb_coeff[3][0] << 27) | (rgb2rgb_coeff[0][0] << 18) |
+		    (rgb2rgb_coeff[1][1] << 9) | rgb2rgb_coeff[2][2];
+		__raw_writel(param, base++);
+		/* scale = 2, sat = 0 */
+		param = (rgb2rgb_coeff[3][0] >> 5) | (2UL << 8);
+		__raw_writel(param, base++);
+
+		param =
+		    (rgb2rgb_coeff[3][1] << 27) | (rgb2rgb_coeff[0][1] << 18) |
+		    (rgb2rgb_coeff[1][0] << 9) | rgb2rgb_coeff[2][0];
+		__raw_writel(param, base++);
+		param = (rgb2rgb_coeff[3][1] >> 5);
+		__raw_writel(param, base++);
+
+		param =
+		    (rgb2rgb_coeff[3][2] << 27) | (rgb2rgb_coeff[0][2] << 18) |
+		    (rgb2rgb_coeff[1][2] << 9) | rgb2rgb_coeff[2][1];
+		__raw_writel(param, base++);
+		param = (rgb2rgb_coeff[3][2] >> 5);
+		__raw_writel(param, base++);
+	} else {
+		dev_err(g_ipu_dev, "Unsupported color space conversion\n");
+	}
+}
+
+static bool _calc_resize_coeffs(uint32_t inSize, uint32_t outSize,
+				uint32_t *resizeCoeff,
+				uint32_t *downsizeCoeff)
+{
+	uint32_t tempSize;
+	uint32_t tempDownsize;
+
+	/* Cannot downsize more than 8:1 */
+	if ((outSize << 3) < inSize)
+		return false;
+
+	/* compute downsizing coefficient */
+	tempDownsize = 0;
+	tempSize = inSize;
+	while ((tempSize >= outSize * 2) && (tempDownsize < 2)) {
+		tempSize >>= 1;
+		tempDownsize++;
+	}
+	*downsizeCoeff = tempDownsize;
+
+	/* compute resizing coefficient using the following equation:
+	   resizeCoeff = M*(SI -1)/(SO - 1)
+	   where M = 2^13, SI - input size, SO - output size    */
+	*resizeCoeff = (8192L * (tempSize - 1)) / (outSize - 1);
+	if (*resizeCoeff >= 16384L) {
+		dev_err(g_ipu_dev, "Warning! Overflow on resize coeff.\n");
+		*resizeCoeff = 0x3FFF;
+	}
+
+	dev_dbg(g_ipu_dev, "resizing from %u -> %u pixels, "
+		"downsize=%u, resize=%u.%lu (reg=%u)\n", inSize, outSize,
+		*downsizeCoeff, (*resizeCoeff >= 8192L) ? 1 : 0,
+		((*resizeCoeff & 0x1FFF) * 10000L) / 8192L, *resizeCoeff);
+
+	return true;
+}
diff --git a/drivers/mxc/ipu3/ipu_param_mem.h b/drivers/mxc/ipu3/ipu_param_mem.h
new file mode 100644
index 0000000..b520892
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_param_mem.h
@@ -0,0 +1,315 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __INCLUDE_IPU_PARAM_MEM_H__
+#define __INCLUDE_IPU_PARAM_MEM_H__
+
+#include <linux/types.h>
+#include <linux/bitrev.h>
+
+extern u32 *ipu_cpmem_base;
+
+struct ipu_ch_param_word {
+	uint32_t data[5];
+	uint32_t res[3];
+};
+
+struct ipu_ch_param {
+	struct ipu_ch_param_word word[2];
+};
+
+#define ipu_ch_param_addr(ch) (((struct ipu_ch_param *)ipu_cpmem_base) + (ch))
+
+#define _param_word(base, w) \
+	(((struct ipu_ch_param *)(base))->word[(w)].data)
+
+#define ipu_ch_param_set_field(base, w, bit, size, v) { \
+	int i = (bit) / 32; \
+	int off = (bit) % 32; \
+	_param_word(base, w)[i] |= (v) << off; \
+	if (((bit)+(size)-1)/32 > i) { \
+		_param_word(base, w)[i + 1] |= (v) >> (off ? (32 - off) : 0); \
+	} \
+}
+
+#define ipu_ch_param_mod_field(base, w, bit, size, v) { \
+	int i = (bit) / 32; \
+	int off = (bit) % 32; \
+	u32 mask = (1UL << size) - 1; \
+	u32 temp = _param_word(base, w)[i]; \
+	temp &= ~(mask << off); \
+	_param_word(base, w)[i] = temp | (v) << off; \
+	if (((bit)+(size)-1)/32 > i) { \
+		temp = _param_word(base, w)[i + 1]; \
+		temp &= ~(mask >> (32 - off)); \
+		_param_word(base, w)[i + 1] = \
+			temp | ((v) >> (off ? (32 - off) : 0)); \
+	} \
+}
+
+#define ipu_ch_param_read_field(base, w, bit, size) ({ \
+	u32 temp2; \
+	int i = (bit) / 32; \
+	int off = (bit) % 32; \
+	u32 mask = (1UL << size) - 1; \
+	u32 temp1 = _param_word(base, w)[i]; \
+	temp1 = mask & (temp1 >> off); \
+	if (((bit)+(size)-1)/32 > i) { \
+		temp2 = _param_word(base, w)[i + 1]; \
+		temp2 &= mask >> (off ? (32 - off) : 0); \
+		temp1 |= temp2 << (off ? (32 - off) : 0); \
+	} \
+	temp1; \
+})
+
+static inline void _ipu_ch_params_set_packing(struct ipu_ch_param *p,
+					      int red_width, int red_offset,
+					      int green_width, int green_offset,
+					      int blue_width, int blue_offset,
+					      int alpha_width, int alpha_offset)
+{
+	/* Setup red width and offset */
+	ipu_ch_param_set_field(p, 1, 116, 3, red_width - 1);
+	ipu_ch_param_set_field(p, 1, 128, 5, red_offset);
+	/* Setup green width and offset */
+	ipu_ch_param_set_field(p, 1, 119, 3, green_width - 1);
+	ipu_ch_param_set_field(p, 1, 133, 5, green_offset);
+	/* Setup blue width and offset */
+	ipu_ch_param_set_field(p, 1, 122, 3, blue_width - 1);
+	ipu_ch_param_set_field(p, 1, 138, 5, blue_offset);
+	/* Setup alpha width and offset */
+	ipu_ch_param_set_field(p, 1, 125, 3, alpha_width - 1);
+	ipu_ch_param_set_field(p, 1, 143, 5, alpha_offset);
+}
+
+static inline void _ipu_ch_param_dump(int ch)
+{
+	struct ipu_ch_param *p = ipu_ch_param_addr(ch);
+	pr_debug("ch %d word 0 - %08X %08X %08X %08X %08X\n", ch,
+		 p->word[0].data[0], p->word[0].data[1], p->word[0].data[2],
+		 p->word[0].data[3], p->word[0].data[4]);
+	pr_debug("ch %d word 1 - %08X %08X %08X %08X %08X\n", ch,
+		 p->word[1].data[0], p->word[1].data[1], p->word[1].data[2],
+		 p->word[1].data[3], p->word[1].data[4]);
+	pr_debug("PFS 0x%x, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 85, 4));
+	pr_debug("BPP 0x%x, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 0, 107, 3));
+	pr_debug("NPB 0x%x\n",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 78, 7));
+
+	pr_debug("FW %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 0, 125, 13));
+	pr_debug("FH %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 0, 138, 12));
+	pr_debug("Stride %d\n",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 102, 14));
+
+	pr_debug("Width0 %d+1, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 116, 3));
+	pr_debug("Width1 %d+1, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 119, 3));
+	pr_debug("Width2 %d+1, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 122, 3));
+	pr_debug("Width3 %d+1, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 125, 3));
+	pr_debug("Offset0 %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 128, 5));
+	pr_debug("Offset1 %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 133, 5));
+	pr_debug("Offset2 %d, ",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 138, 5));
+	pr_debug("Offset3 %d\n",
+		 ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 143, 5));
+}
+
+static inline void _ipu_ch_param_init(int ch,
+				      uint32_t pixel_fmt, uint32_t width,
+				      uint32_t height, uint32_t stride,
+				      uint32_t u, uint32_t v,
+				      uint32_t uv_stride, dma_addr_t addr0,
+				      dma_addr_t addr1)
+{
+	uint32_t u_offset = 0;
+	uint32_t v_offset = 0;
+	struct ipu_ch_param params;
+
+	memset(&params, 0, sizeof(params));
+
+	ipu_ch_param_set_field(&params, 0, 125, 13, width - 1);
+	ipu_ch_param_set_field(&params, 0, 138, 12, height - 1);
+	ipu_ch_param_set_field(&params, 1, 102, 14, stride - 1);
+
+	ipu_ch_param_set_field(&params, 1, 0, 29, addr0 >> 3);
+	ipu_ch_param_set_field(&params, 1, 29, 29, addr1 >> 3);
+
+	switch (pixel_fmt) {
+	case IPU_PIX_FMT_GENERIC:
+		/*Represents 8-bit Generic data */
+		ipu_ch_param_set_field(&params, 0, 107, 3, 5);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 6);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 63);	/* burst size */
+		break;
+	case IPU_PIX_FMT_GENERIC_32:
+		/*Represents 32-bit Generic data */
+		break;
+	case IPU_PIX_FMT_RGB565:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 5, 0, 6, 5, 5, 11, 1, 16);
+		break;
+	case IPU_PIX_FMT_BGR24:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 1);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 19);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 0, 8, 8, 8, 16, 1, 24);
+		break;
+	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_YUV444:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 1);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 19);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 16, 8, 8, 8, 0, 1, 24);
+		break;
+	case IPU_PIX_FMT_BGRA32:
+	case IPU_PIX_FMT_BGR32:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 0);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 15);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 8, 8, 16, 8, 24, 8, 0);
+		break;
+	case IPU_PIX_FMT_RGBA32:
+	case IPU_PIX_FMT_RGB32:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 0);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 15);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 24, 8, 16, 8, 8, 8, 0);
+		break;
+	case IPU_PIX_FMT_ABGR32:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 0);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 7);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 15);	/* burst size */
+
+		_ipu_ch_params_set_packing(&params, 8, 24, 8, 16, 8, 8, 8, 0);
+		break;
+	case IPU_PIX_FMT_UYVY:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 0xA);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 15);	/* burst size */
+		break;
+	case IPU_PIX_FMT_YUYV:
+		ipu_ch_param_set_field(&params, 0, 107, 3, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 0x8);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 15);	/* burst size */
+		break;
+	case IPU_PIX_FMT_YUV420P2:
+	case IPU_PIX_FMT_YUV420P:
+		ipu_ch_param_set_field(&params, 1, 85, 4, 2);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		u_offset = stride * height;
+		v_offset = u_offset + (uv_stride * height / 2);
+		break;
+	case IPU_PIX_FMT_YVU422P:
+		/* BPP & pixel format */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 1);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		v_offset = (v == 0) ? stride * height : v;
+		u_offset = (u == 0) ? v_offset + v_offset / 2 : u;
+		break;
+	case IPU_PIX_FMT_YUV422P:
+		/* BPP & pixel format */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 1);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+
+		if (uv_stride < stride / 2)
+			uv_stride = stride / 2;
+
+		u_offset = (u == 0) ? stride * height : u;
+		v_offset = (v == 0) ? u_offset + u_offset / 2 : v;
+		break;
+	default:
+		dev_err(g_ipu_dev, "mxc ipu: unimplemented pixel format\n");
+		break;
+	}
+
+	if (uv_stride)
+		ipu_ch_param_set_field(&params, 1, 128, 14, uv_stride - 1);
+
+	if (u > u_offset)
+		u_offset = u;
+
+	if (v > v_offset)
+		v_offset = v;
+
+	ipu_ch_param_set_field(&params, 0, 46, 22, u_offset / 8);
+	ipu_ch_param_set_field(&params, 0, 68, 22, v_offset / 8);
+
+	pr_debug("initializing idma ch %d @ %p\n", ch, ipu_ch_param_addr(ch));
+	memcpy(ipu_ch_param_addr(ch), &params, sizeof(params));
+};
+
+static inline void _ipu_ch_param_set_burst_size(uint32_t ch,
+						uint16_t burst_pixels)
+{
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 78, 7,
+			       burst_pixels - 1);
+};
+
+static inline int _ipu_ch_param_get_burst_size(uint32_t ch)
+{
+	return ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 78, 7) + 1;
+};
+
+static inline void _ipu_ch_param_set_buffer(uint32_t ch, int bufNum,
+					    dma_addr_t phyaddr)
+{
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 29 * bufNum, 29,
+			       phyaddr / 8);
+};
+
+static inline void _ipu_ch_param_set_rotation(uint32_t ch,
+					      ipu_rotate_mode_t rot)
+{
+	u32 temp_rot = bitrev8(rot) >> 5;
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 0, 119, 3, temp_rot);
+};
+
+static inline void _ipu_ch_param_set_block_mode(uint32_t ch)
+{
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 0, 117, 2, 1);
+};
+
+static inline void _ipu_ch_param_set_interlaced_scan(uint32_t ch)
+{
+	u32 stride;
+	ipu_ch_param_set_field(ipu_ch_param_addr(ch), 0, 113, 1, 1);
+	stride = ipu_ch_param_read_field(ipu_ch_param_addr(ch), 1, 102, 14) + 1;
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 58, 20, stride / 8);
+	stride *= 2;
+	ipu_ch_param_mod_field(ipu_ch_param_addr(ch), 1, 102, 14, stride - 1);
+};
+
+#endif
diff --git a/drivers/mxc/ipu3/ipu_prv.h b/drivers/mxc/ipu3/ipu_prv.h
new file mode 100644
index 0000000..bc7424e
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_prv.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __INCLUDE_IPU_PRV_H__
+#define __INCLUDE_IPU_PRV_H__
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <asm/arch/hardware.h>
+
+/* Globals */
+extern struct device *g_ipu_dev;
+extern spinlock_t ipu_lock;
+extern bool g_ipu_clk_enabled;
+extern struct clk *g_ipu_clk;
+extern struct clk *g_di_clk[2];
+extern struct clk *g_ipu_csi_clk;
+extern ipu_channel_t g_ipu_di_channel[2];
+
+#define IDMA_CHAN_INVALID	0xFF
+
+struct ipu_channel {
+	u8 video_in_dma;
+	u8 alpha_in_dma;
+	u8 graph_in_dma;
+	u8 out_dma;
+};
+
+int register_ipu_device(void);
+ipu_color_space_t format_to_colorspace(uint32_t fmt);
+
+void ipu_dump_registers(void);
+
+uint32_t _ipu_channel_status(ipu_channel_t channel);
+
+void _ipu_init_dc_mappings(void);
+int _ipu_dp_init(ipu_channel_t channel, uint32_t in_pixel_fmt,
+		 uint32_t out_pixel_fmt);
+void _ipu_dp_uninit(ipu_channel_t channel);
+void _ipu_dc_init(int dc_chan, int di, bool interlaced);
+void _ipu_dc_uninit(int dc_chan);
+void _ipu_dp_dc_enable(ipu_channel_t channel);
+void _ipu_dp_dc_disable(ipu_channel_t channel);
+int _ipu_chan_is_interlaced(ipu_channel_t channel);
+
+void _ipu_ic_enable_task(ipu_channel_t channel);
+void _ipu_ic_disable_task(ipu_channel_t channel);
+void _ipu_ic_init_prpvf(ipu_channel_params_t *params, bool src_is_csi);
+void _ipu_ic_uninit_prpvf(void);
+void _ipu_ic_init_rotate_vf(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_vf(void);
+void _ipu_ic_init_csi(ipu_channel_params_t *params);
+void _ipu_ic_uninit_csi(void);
+void _ipu_ic_init_prpenc(ipu_channel_params_t *params, bool src_is_csi);
+void _ipu_ic_uninit_prpenc(void);
+void _ipu_ic_init_rotate_enc(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_enc(void);
+void _ipu_ic_init_pp(ipu_channel_params_t *params);
+void _ipu_ic_uninit_pp(void);
+void _ipu_ic_init_rotate_pp(ipu_channel_params_t *params);
+void _ipu_ic_uninit_rotate_pp(void);
+int _ipu_ic_idma_init(int dma_chan, uint16_t width, uint16_t height,
+		      int burst_size, ipu_rotate_mode_t rot);
+
+#endif				/* __INCLUDE_IPU_PRV_H__ */
diff --git a/drivers/mxc/ipu3/ipu_regs.h b/drivers/mxc/ipu3/ipu_regs.h
new file mode 100644
index 0000000..ae41d69
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_regs.h
@@ -0,0 +1,431 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_regs.h
+ *
+ * @brief IPU Register definitions
+ *
+ * @ingroup IPU
+ */
+#ifndef __IPU_REGS_INCLUDED__
+#define __IPU_REGS_INCLUDED__
+
+#define IPU_CM_REG_BASE		0x1E000000
+#define IPU_IDMAC_REG_BASE	0x1E008000
+#define IPU_ISP_REG_BASE	0x1E010000
+#define IPU_DP_REG_BASE		0x1E018000
+#define IPU_IC_REG_BASE		0x1E020000
+#define IPU_IRT_REG_BASE	0x1E028000
+#define IPU_CSI0_REG_BASE	0x1E030000
+#define IPU_CSI1_REG_BASE	0x1E038000
+#define IPU_DI0_REG_BASE	0x1E040000
+#define IPU_DI1_REG_BASE	0x1E048000
+#define IPU_SMFC_REG_BASE	0x1E050000
+#define IPU_DC_REG_BASE		0x1E058000
+#define IPU_DMFC_REG_BASE	0x1E060000
+#define IPU_CPMEM_REG_BASE	0x1F000000
+#define IPU_LUT_REG_BASE	0x1F020000
+#define IPU_SRM_REG_BASE	0x1F040000
+#define IPU_TPM_REG_BASE	0x1F060000
+#define IPU_DC_TMPL_REG_BASE	0x1F080000
+#define IPU_ISP_TBPR_REG_BASE	0x1F0C0000
+
+extern u32 *ipu_cm_reg;
+extern u32 *ipu_idmac_reg;
+extern u32 *ipu_dp_reg;
+extern u32 *ipu_ic_reg;
+extern u32 *ipu_dc_reg;
+extern u32 *ipu_dc_tmpl_reg;
+extern u32 *ipu_dmfc_reg;
+extern u32 *ipu_di_reg[];
+extern u32 *ipu_tpmem_base;
+
+/* Register addresses */
+/* IPU Common registers */
+#define IPU_CONF		(ipu_cm_reg)
+
+#define IPU_SRM_PRI1		(ipu_cm_reg + 0x00A0/4)
+#define IPU_SRM_PRI2		(ipu_cm_reg + 0x00A4/4)
+#define IPU_FS_PROC_FLOW1	(ipu_cm_reg + 0x00A8/4)
+#define IPU_FS_PROC_FLOW2	(ipu_cm_reg + 0x00AC/4)
+#define IPU_FS_PROC_FLOW3	(ipu_cm_reg + 0x00B0/4)
+#define IPU_FS_DISP_FLOW1	(ipu_cm_reg + 0x00B4/4)
+#define IPU_FS_DISP_FLOW2	(ipu_cm_reg + 0x00B8/4)
+#define IPU_SKIP		(ipu_cm_reg + 0x00BC/4)
+#define IPU_DISP_ALT_CONF	(ipu_cm_reg + 0x00C0/4)
+#define IPU_DISP_GEN		(ipu_cm_reg + 0x00C4/4)
+#define IPU_DISP_ALT1		(ipu_cm_reg + 0x00C8/4)
+#define IPU_DISP_ALT2		(ipu_cm_reg + 0x00CC/4)
+#define IPU_DISP_ALT3		(ipu_cm_reg + 0x00D0/4)
+#define IPU_DISP_ALT4		(ipu_cm_reg + 0x00D4/4)
+#define IPU_SNOOP		(ipu_cm_reg + 0x00D8/4)
+#define IPU_MEM_RST		(ipu_cm_reg + 0x00DC/4)
+#define IPU_PM			(ipu_cm_reg + 0x00E0/4)
+#define IPU_GPR			(ipu_cm_reg + 0x00E4/4)
+#define IPU_CHA_CUR_BUF(ch)	(ipu_cm_reg + 0x0124/4 + (ch / 32))
+#define IPU_ALT_CUR_BUF0	(ipu_cm_reg + 0x012C/4)
+#define IPU_ALT_CUR_BUF1	(ipu_cm_reg + 0x0130/4)
+#define IPU_SRM_STAT		(ipu_cm_reg + 0x0134/4)
+#define IPU_PROC_TASK_STAT	(ipu_cm_reg + 0x0138/4)
+#define IPU_DISP_TASK_STAT	(ipu_cm_reg + 0x013C/4)
+#define IPU_CHA_BUF0_RDY(ch)	(ipu_cm_reg + 0x0140/4 + (ch / 32))
+#define IPU_CHA_BUF1_RDY(ch)	(ipu_cm_reg + 0x0148/4 + (ch / 32))
+#define IPU_CHA_DB_MODE_SEL(ch)	(ipu_cm_reg + 0x0150/4 + (ch / 32))
+#define IPU_ALT_CHA_BUF0_RDY(ch) (ipu_cm_reg + 0x0158/4 + (ch / 32))
+#define IPU_ALT_CHA_BUF1_RDY(ch) (ipu_cm_reg + 0x0160/4 + (ch / 32))
+#define IPU_ALT_CHA_DB_MODE_SEL(ch) (ipu_cm_reg + 0x0168/4 + (ch / 32))
+
+#define IPU_INT_CTRL(n)		(ipu_cm_reg + 0x003C/4 + ((n) - 1))
+#define IPU_INT_CTRL_IRQ(irq)	IPU_INT_CTRL(((irq) / 32))
+#define IPU_INT_STAT(n)		(ipu_cm_reg + 0x00E8/4 + ((n) - 1))
+#define IPU_INT_STAT_IRQ(irq)	IPU_INT_STAT(((irq) / 32))
+
+#define IPUIRQ_2_STATREG(irq)	(IPU_INT_STAT(1) + ((irq) / 32))
+#define IPUIRQ_2_CTRLREG(irq)	(IPU_INT_CTRL(1) + ((irq) / 32))
+#define IPUIRQ_2_MASK(irq)	(1UL << ((irq) & 0x1F))
+
+/* CMOS Sensor Interface Registers */
+
+/* Image Converter Registers */
+#define IC_CONF			(ipu_ic_reg)
+#define IC_PRP_ENC_RSC		(ipu_ic_reg + 0x0004/4)
+#define IC_PRP_VF_RSC		(ipu_ic_reg + 0x0008/4)
+#define IC_PP_RSC		(ipu_ic_reg + 0x000C/4)
+#define IC_CMBP_1		(ipu_ic_reg + 0x0010/4)
+#define IC_CMBP_2		(ipu_ic_reg + 0x0014/4)
+#define IC_IDMAC_1		(ipu_ic_reg + 0x0018/4)
+#define IC_IDMAC_2		(ipu_ic_reg + 0x001C/4)
+#define IC_IDMAC_3		(ipu_ic_reg + 0x0020/4)
+#define IC_IDMAC_4		(ipu_ic_reg + 0x0024/4)
+
+#define IDMAC_CONF		(ipu_idmac_reg + 0x0000)
+#define IDMAC_CHA_EN(ch)	(ipu_idmac_reg + 0x0004/4 + (ch/32))
+#define IDMAC_SEP_ALPHA		(ipu_idmac_reg + 0x000C)
+#define IDMAC_ALT_SEP_ALPHA	(ipu_idmac_reg + 0x0010)
+#define IDMAC_CHA_PRI(ch)	(ipu_idmac_reg + 0x0014/4 + (ch/32))
+#define IDMAC_WM_EN(ch)		(ipu_idmac_reg + 0x001C/4 + (ch/32))
+#define IDMAC_CH_LOCK_EN_2	(ipu_idmac_reg + 0x0024/4)
+#define IDMAC_SUB_ADDR_0	(ipu_idmac_reg + 0x0028/4)
+#define IDMAC_SUB_ADDR_1	(ipu_idmac_reg + 0x002C/4)
+#define IDMAC_SUB_ADDR_2	(ipu_idmac_reg + 0x0030/4)
+#define IDMAC_BAND_EN(ch)	(ipu_idmac_reg + 0x0034/4 + (ch/32))
+#define IDMAC_CHA_BUSY(ch)	(ipu_idmac_reg + 0x0040/4 + (ch/32))
+
+#define DI_GENERAL(di)		(ipu_di_reg[di])
+#define DI_BS_CLKGEN0(di)	(ipu_di_reg[di] + 0x0004/4)
+#define DI_BS_CLKGEN1(di)	(ipu_di_reg[di] + 0x0008/4)
+
+#define DI_SW_GEN0(di, gen)	(ipu_di_reg[di] + 0x000C/4 + (gen - 1))
+#define DI_SW_GEN1(di, gen)	(ipu_di_reg[di] + 0x0030/4 + (gen - 1))
+#define DI_STP_REP(di, gen)	(ipu_di_reg[di] + 0x0148/4 + (gen - 1)/2)
+#define DI_SYNC_AS_GEN(di)	(ipu_di_reg[di] + 0x0054/4)
+#define DI_DW_GEN(di, gen)	(ipu_di_reg[di] + 0x0058/4 + gen)
+#define DI_DW_SET(di, gen, set)	(ipu_di_reg[di] + 0x0088/4 + gen + 0xC*set)
+#define DI_SER_CONF(di)		(ipu_di_reg[di] + 0x015C/4)
+#define DI_SSC(di)		(ipu_di_reg[di] + 0x0160/4)
+#define DI_POL(di)		(ipu_di_reg[di] + 0x0164/4)
+#define DI_AW0(di)		(ipu_di_reg[di] + 0x0168/4)
+#define DI_AW1(di)		(ipu_di_reg[di] + 0x016C/4)
+#define DI_SCR_CONF(di)		(ipu_di_reg[di] + 0x0170/4)
+#define DI_STAT(di)		(ipu_di_reg[di] + 0x0174/4)
+
+#define DMFC_RD_CHAN		(ipu_dmfc_reg)
+#define DMFC_WR_CHAN		(ipu_dmfc_reg + 0x0004/4)
+#define DMFC_WR_CHAN_DEF	(ipu_dmfc_reg + 0x0008/4)
+#define DMFC_DP_CHAN		(ipu_dmfc_reg + 0x000C/4)
+#define DMFC_DP_CHAN_DEF	(ipu_dmfc_reg + 0x0010/4)
+#define DMFC_GENERAL1		(ipu_dmfc_reg + 0x0014/4)
+#define DMFC_GENERAL2		(ipu_dmfc_reg + 0x0018/4)
+#define DMFC_IC_CTRL		(ipu_dmfc_reg + 0x001C/4)
+
+#define DC_MAP_CONF_PTR(n)	(ipu_dc_reg + 0x0108/4 + n/2)
+#define DC_MAP_CONF_VAL(n)	(ipu_dc_reg + 0x0144/4 + n/2)
+
+#define _RL_CH_2_OFFSET(ch)	((ch == 0) ? 8 : ( \
+				 (ch == 1) ? 0x24 : ( \
+				 (ch == 2) ? 0x40 : ( \
+				 (ch == 5) ? 0x64 : ( \
+				 (ch == 6) ? 0x80 : ( \
+				 (ch == 8) ? 0x9C : ( \
+				 (ch == 9) ? 0xBC : (-1))))))))
+#define DC_RL_CH(ch, evt)	(ipu_dc_reg + _RL_CH_2_OFFSET(ch)/4 + evt/2)
+
+#define DC_EVT_NF		0
+#define DC_EVT_NL		1
+#define DC_EVT_EOF		2
+#define DC_EVT_NFIELD		3
+#define DC_EVT_EOL		4
+#define DC_EVT_EOFIELD		5
+#define DC_EVT_NEW_ADDR		6
+#define DC_EVT_NEW_CHAN		7
+#define DC_EVT_NEW_DATA		8
+
+#define DC_WR_CH_CONF_1		(ipu_dc_reg + 0x001C/4)
+#define DC_WR_CH_ADDR_1		(ipu_dc_reg + 0x0020/4)
+#define DC_WR_CH_CONF_5		(ipu_dc_reg + 0x005C/4)
+#define DC_WR_CH_ADDR_5		(ipu_dc_reg + 0x0060/4)
+#define DC_GEN			(ipu_dc_reg + 0x00D4/4)
+#define DC_DISP_CONF1(disp)	(ipu_dc_reg + 0x00D8/4 + disp)
+#define DC_DISP_CONF2(disp)	(ipu_dc_reg + 0x00E8/4 + disp)
+#define DC_STAT			(ipu_dc_reg + 0x01C8/4)
+#define DC_UGDE_0(evt)		(ipu_dc_reg + 0x0174/4 + evt*4)
+#define DC_UGDE_1(evt)		(ipu_dc_reg + 0x0178/4 + evt*4)
+#define DC_UGDE_2(evt)		(ipu_dc_reg + 0x017C/4 + evt*4)
+#define DC_UGDE_3(evt)		(ipu_dc_reg + 0x0180/4 + evt*4)
+
+#define DP_SYNC 0
+#define DP_ASYNC0 0x60
+#define DP_ASYNC1 0xBC
+#define DP_COM_CONF(flow)	(ipu_dp_reg + flow/4)
+#define DP_GRAPH_WIND_CTRL(flow) (ipu_dp_reg + 0x0004/4 + flow/4)
+#define DP_FG_POS(flow)		(ipu_dp_reg + 0x0008/4 + flow/4)
+#define DP_CSC_A_0(flow)	(ipu_dp_reg + 0x0044/4 + flow/4)
+#define DP_CSC_A_1(flow)	(ipu_dp_reg + 0x0048/4 + flow/4)
+#define DP_CSC_A_2(flow)	(ipu_dp_reg + 0x004C/4 + flow/4)
+#define DP_CSC_A_3(flow)	(ipu_dp_reg + 0x0050/4 + flow/4)
+#define DP_CSC_0(flow)		(ipu_dp_reg + 0x0054/4 + flow/4)
+#define DP_CSC_1(flow)		(ipu_dp_reg + 0x0058/4 + flow/4)
+
+enum {
+	IPU_CONF_CSI0_EN = 0x00000001,
+	IPU_CONF_CSI1_EN = 0x00000002,
+	IPU_CONF_IC_EN = 0x00000004,
+	IPU_CONF_ROT_EN = 0x00000008,
+	IPU_CONF_DP_EN = 0x00000020,
+	IPU_CONF_DI0_EN = 0x00000040,
+	IPU_CONF_DI1_EN = 0x00000080,
+	IPU_CONF_DMFC_EN = 0x00000400,
+	IPU_CONF_DC_EN = 0x00000200,
+	IPU_CONF_IDMAC_DIS = 0x00400000,
+	IPU_CONF_IC_DMFC_SEL = 0x02000000,
+	IPU_CONF_IC_DMFC_SYNC = 0x04000000,
+
+	DI0_COUNTER_RELEASE = 0x01000000,
+	DI1_COUNTER_RELEASE = 0x02000000,
+
+	FS_PRPVF_ROT_SRC_SEL_MASK = 0x00000F00,
+	FS_PRPVF_ROT_SRC_SEL_OFFSET = 8,
+	FS_PRPENC_ROT_SRC_SEL_MASK = 0x0000000F,
+	FS_PRPENC_ROT_SRC_SEL_OFFSET = 0,
+	FS_PP_ROT_SRC_SEL_MASK = 0x000F0000,
+	FS_PP_ROT_SRC_SEL_OFFSET = 16,
+	FS_PP_SRC_SEL_MASK = 0x0000F000,
+	FS_PP_SRC_SEL_OFFSET = 12,
+	FS_PRP_SRC_SEL_MASK = 0x0F000000,
+	FS_PRP_SRC_SEL_OFFSET = 24,
+	FS_VF_IN_VALID = 0x80000000,
+	FS_ENC_IN_VALID = 0x40000000,
+
+	FS_PRPENC_DEST_SEL_MASK = 0x0000000F,
+	FS_PRPENC_DEST_SEL_OFFSET = 0,
+	FS_PRPVF_DEST_SEL_MASK = 0x000000F0,
+	FS_PRPVF_DEST_SEL_OFFSET = 4,
+	FS_PRPVF_ROT_DEST_SEL_MASK = 0x000000F0,
+	FS_PRPVF_ROT_DEST_SEL_OFFSET = 8,
+	FS_PP_DEST_SEL_MASK = 0x0000F000,
+	FS_PP_DEST_SEL_OFFSET = 12,
+	FS_PP_ROT_DEST_SEL_MASK = 0x000F0000,
+	FS_PP_ROT_DEST_SEL_OFFSET = 16,
+	FS_PRPENC_ROT_DEST_SEL_MASK = 0x00F00000,
+	FS_PRPENC_ROT_DEST_SEL_OFFSET = 20,
+
+	FS_DC1_SRC_SEL_MASK = 0x00F00000,
+	FS_DC1_SRC_SEL_OFFSET = 20,
+	FS_DC2_SRC_SEL_MASK = 0x000F0000,
+	FS_DC2_SRC_SEL_OFFSET = 16,
+	FS_DP_SYNC0_SRC_SEL_MASK = 0x0000000F,
+	FS_DP_SYNC0_SRC_SEL_OFFSET = 0,
+	FS_DP_SYNC1_SRC_SEL_MASK = 0x000000F0,
+	FS_DP_SYNC1_SRC_SEL_OFFSET = 4,
+
+	FS_AUTO_REF_PER_MASK = 0,
+	FS_AUTO_REF_PER_OFFSET = 16,
+
+	TSTAT_VF_MASK = 0x0000000C,
+	TSTAT_VF_OFFSET = 2,
+	TSTAT_VF_ROT_MASK = 0x00000300,
+	TSTAT_VF_ROT_OFFSET = 8,
+	TSTAT_ENC_MASK = 0x00000003,
+	TSTAT_ENC_OFFSET = 0,
+	TSTAT_ENC_ROT_MASK = 0x000000C0,
+	TSTAT_ENC_ROT_OFFSET = 6,
+	TSTAT_PP_MASK = 0x00000030,
+	TSTAT_PP_OFFSET = 4,
+	TSTAT_PP_ROT_MASK = 0x00000C00,
+	TSTAT_PP_ROT_OFFSET = 10,
+
+	TASK_STAT_IDLE = 0,
+	TASK_STAT_ACTIVE = 1,
+	TASK_STAT_WAIT4READY = 2,
+
+	/* Register bits */
+	SDC_COM_TFT_COLOR = 0x00000001UL,
+	SDC_COM_FG_EN = 0x00000010UL,
+	SDC_COM_GWSEL = 0x00000020UL,
+	SDC_COM_GLB_A = 0x00000040UL,
+	SDC_COM_KEY_COLOR_G = 0x00000080UL,
+	SDC_COM_BG_EN = 0x00000200UL,
+	SDC_COM_SHARP = 0x00001000UL,
+
+	SDC_V_SYNC_WIDTH_L = 0x00000001UL,
+
+	ADC_CONF_PRP_EN = 0x00000001L,
+	ADC_CONF_PP_EN = 0x00000002L,
+	ADC_CONF_MCU_EN = 0x00000004L,
+
+	ADC_DISP_CONF_SL_MASK = 0x00000FFFL,
+	ADC_DISP_CONF_TYPE_MASK = 0x00003000L,
+	ADC_DISP_CONF_TYPE_XY = 0x00002000L,
+
+	ADC_DISP_VSYNC_D0_MODE_MASK = 0x00000003L,
+	ADC_DISP_VSYNC_D0_WIDTH_MASK = 0x003F0000L,
+	ADC_DISP_VSYNC_D12_MODE_MASK = 0x0000000CL,
+	ADC_DISP_VSYNC_D12_WIDTH_MASK = 0x3F000000L,
+
+	/* Image Converter Register bits */
+	IC_CONF_PRPENC_EN = 0x00000001,
+	IC_CONF_PRPENC_CSC1 = 0x00000002,
+	IC_CONF_PRPENC_ROT_EN = 0x00000004,
+	IC_CONF_PRPVF_EN = 0x00000100,
+	IC_CONF_PRPVF_CSC1 = 0x00000200,
+	IC_CONF_PRPVF_CSC2 = 0x00000400,
+	IC_CONF_PRPVF_CMB = 0x00000800,
+	IC_CONF_PRPVF_ROT_EN = 0x00001000,
+	IC_CONF_PP_EN = 0x00010000,
+	IC_CONF_PP_CSC1 = 0x00020000,
+	IC_CONF_PP_CSC2 = 0x00040000,
+	IC_CONF_PP_CMB = 0x00080000,
+	IC_CONF_PP_ROT_EN = 0x00100000,
+	IC_CONF_IC_GLB_LOC_A = 0x10000000,
+	IC_CONF_KEY_COLOR_EN = 0x20000000,
+	IC_CONF_RWS_EN = 0x40000000,
+	IC_CONF_CSI_MEM_WR_EN = 0x80000000,
+
+	IC_IDMAC_1_CB0_BURST_16 = 0x00000001,
+	IC_IDMAC_1_CB1_BURST_16 = 0x00000002,
+	IC_IDMAC_1_CB2_BURST_16 = 0x00000004,
+	IC_IDMAC_1_CB3_BURST_16 = 0x00000008,
+	IC_IDMAC_1_CB4_BURST_16 = 0x00000010,
+	IC_IDMAC_1_CB5_BURST_16 = 0x00000020,
+	IC_IDMAC_1_CB6_BURST_16 = 0x00000040,
+	IC_IDMAC_1_CB7_BURST_16 = 0x00000080,
+	IC_IDMAC_1_PRPENC_ROT_MASK = 0x00003800,
+	IC_IDMAC_1_PRPENC_ROT_OFFSET = 11,
+	IC_IDMAC_1_PRPVF_ROT_MASK = 0x0001C000,
+	IC_IDMAC_1_PRPVF_ROT_OFFSET = 14,
+	IC_IDMAC_1_PP_ROT_MASK = 0x000E0000,
+	IC_IDMAC_1_PP_ROT_OFFSET = 17,
+	IC_IDMAC_1_PP_FLIP_RS = 0x00400000,
+	IC_IDMAC_1_PRPVF_FLIP_RS = 0x00200000,
+	IC_IDMAC_1_PRPENC_FLIP_RS = 0x00100000,
+
+	IC_IDMAC_2_PRPENC_HEIGHT_MASK = 0x000003FF,
+	IC_IDMAC_2_PRPENC_HEIGHT_OFFSET = 0,
+	IC_IDMAC_2_PRPVF_HEIGHT_MASK = 0x000FFC00,
+	IC_IDMAC_2_PRPVF_HEIGHT_OFFSET = 10,
+	IC_IDMAC_2_PP_HEIGHT_MASK = 0x3FF00000,
+	IC_IDMAC_2_PP_HEIGHT_OFFSET = 20,
+
+	IC_IDMAC_3_PRPENC_WIDTH_MASK = 0x000003FF,
+	IC_IDMAC_3_PRPENC_WIDTH_OFFSET = 0,
+	IC_IDMAC_3_PRPVF_WIDTH_MASK = 0x000FFC00,
+	IC_IDMAC_3_PRPVF_WIDTH_OFFSET = 10,
+	IC_IDMAC_3_PP_WIDTH_MASK = 0x3FF00000,
+	IC_IDMAC_3_PP_WIDTH_OFFSET = 20,
+
+	CSI_SENS_CONF_DATA_FMT_SHIFT = 8,
+	CSI_SENS_CONF_DATA_FMT_RGB_YUV444 = 0x00000000L,
+	CSI_SENS_CONF_DATA_FMT_YUV422 = 0x00000200L,
+	CSI_SENS_CONF_DATA_FMT_BAYER = 0x00000300L,
+
+	CSI_SENS_CONF_VSYNC_POL_SHIFT = 0,
+	CSI_SENS_CONF_HSYNC_POL_SHIFT = 1,
+	CSI_SENS_CONF_DATA_POL_SHIFT = 2,
+	CSI_SENS_CONF_PIX_CLK_POL_SHIFT = 3,
+	CSI_SENS_CONF_SENS_PRTCL_SHIFT = 4,
+	CSI_SENS_CONF_SENS_CLKSRC_SHIFT = 7,
+	CSI_SENS_CONF_DATA_WIDTH_SHIFT = 10,
+	CSI_SENS_CONF_EXT_VSYNC_SHIFT = 15,
+	CSI_SENS_CONF_DIVRATIO_SHIFT = 16,
+
+	PF_CONF_TYPE_MASK = 0x00000007,
+	PF_CONF_TYPE_SHIFT = 0,
+	PF_CONF_PAUSE_EN = 0x00000010,
+	PF_CONF_RESET = 0x00008000,
+	PF_CONF_PAUSE_ROW_MASK = 0x00FF0000,
+	PF_CONF_PAUSE_ROW_SHIFT = 16,
+
+	DI_DW_GEN_ACCESS_SIZE_OFFSET = 24,
+	DI_DW_GEN_COMPONENT_SIZE_OFFSET = 16,
+
+	DI_GEN_DI_CLK_EXT = 0x100000,
+	DI_GEN_POLARITY_1 = 0x00000001,
+	DI_GEN_POLARITY_2 = 0x00000002,
+	DI_GEN_POLARITY_3 = 0x00000004,
+	DI_GEN_POLARITY_4 = 0x00000008,
+	DI_GEN_POLARITY_5 = 0x00000008,
+	DI_GEN_POLARITY_6 = 0x00000008,
+	DI_GEN_POLARITY_7 = 0x00000008,
+	DI_GEN_POLARITY_8 = 0x00000008,
+
+	DI_POL_DRDY_DATA_POLARITY = 0x00000080,
+	DI_POL_DRDY_POLARITY_15 = 0x00000010,
+
+	DI_VSYNC_SEL_OFFSET = 13,
+
+	DC_WR_CH_CONF_FIELD_MODE = 0x00000200,
+	DC_WR_CH_CONF_PROG_TYPE_OFFSET = 5,
+	DC_WR_CH_CONF_PROG_TYPE_MASK = 0x000000E0,
+
+	DC_UGDE_0_ODD_EN = 0x02000000,
+	DC_UGDE_0_ID_CODED_MASK = 0x00000007,
+	DC_UGDE_0_ID_CODED_OFFSET = 0,
+	DC_UGDE_0_EV_PRIORITY_MASK = 0x00000078,
+	DC_UGDE_0_EV_PRIORITY_OFFSET = 3,
+
+	DP_COM_CONF_FG_EN = 0x00000001,
+	DP_COM_CONF_GWSEL = 0x00000002,
+	DP_COM_CONF_GWAM = 0x00000004,
+	DP_COM_CONF_GWCKE = 0x00000008,
+	DP_COM_CONF_CSC_DEF_MASK = 0x00000300,
+	DP_COM_CONF_CSC_DEF_OFFSET = 8,
+	DP_COM_CONF_CSC_DEF_FG = 0x00000300,
+	DP_COM_CONF_CSC_DEF_BG = 0x00000200,
+	DP_COM_CONF_CSC_DEF_BOTH = 0x00000100,
+};
+
+enum di_pins {
+	DI_PIN11 = 0,
+	DI_PIN12 = 1,
+	DI_PIN13 = 2,
+	DI_PIN14 = 3,
+	DI_PIN15 = 4,
+	DI_PIN16 = 5,
+	DI_PIN17 = 6,
+	DI_PIN_CS = 7,
+};
+
+enum di_sync_wave {
+	DI_SYNC_NONE = -1,
+	DI_SYNC_CLK = 0,
+	DI_SYNC_INT_HSYNC = 1,
+	DI_SYNC_HSYNC = 2,
+	DI_SYNC_VSYNC = 3,
+	DI_SYNC_DE = 5,
+};
+
+/* DC template opcodes */
+#define WROD(lf)		(0x18 | (lf << 1))
+
+#endif
diff --git a/drivers/regulator/wm8350/reg-wm8350-i2c.c b/drivers/regulator/wm8350/reg-wm8350-i2c.c
index d8ca643..e2bbf8d 100644
--- a/drivers/regulator/wm8350/reg-wm8350-i2c.c
+++ b/drivers/regulator/wm8350/reg-wm8350-i2c.c
@@ -169,7 +169,7 @@ static void __exit wm8350_pmic_exit(void)
 	i2c_del_driver(&wm8350_i2c_driver);
 }
 
-module_init(wm8350_pmic_init);
+subsys_initcall(wm8350_pmic_init);
 module_exit(wm8350_pmic_exit);
 
 MODULE_AUTHOR("Liam Girdwood");
diff --git a/drivers/video/backlight/Kconfig b/drivers/video/backlight/Kconfig
index cf90367..697faa5 100644
--- a/drivers/video/backlight/Kconfig
+++ b/drivers/video/backlight/Kconfig
@@ -101,7 +101,7 @@ menuconfig BACKLIGHT_MXC
 
 config BACKLIGHT_MXC_IPU
 	tristate "IPU PWM Backlight Driver"
-	depends on BACKLIGHT_MXC && MXC_IPU
+	depends on BACKLIGHT_MXC && MXC_IPU_V1
 	default y
 
 config BACKLIGHT_MXC_LCDC
@@ -113,7 +113,7 @@ config BACKLIGHT_MXC_PMIC
 	tristate "PMIC Backlight Driver"
 	depends on BACKLIGHT_MXC && MXC_MC13783_LIGHT && MXC_MC13783_POWER
 	default y
-    
+
 config BACKLIGHT_WM8350
     tristate "WM8350 Backlight Driver"
     depends on BACKLIGHT_MXC && REGULATOR_WM8350
diff --git a/drivers/video/mxc/Kconfig b/drivers/video/mxc/Kconfig
index 4c8df8b..c7c28d8 100644
--- a/drivers/video/mxc/Kconfig
+++ b/drivers/video/mxc/Kconfig
@@ -54,23 +54,6 @@ config FB_MXC_EPSON_PANEL
 	default n
 	bool "Epson 176x220 Panel"
 
-if MACH_I30030ADS
-config FB_MXC_EPSON_QVGA_PANEL
-    depends on FB_MXC_ASYNC_PANEL
-	default y
-	bool "Epson 240x320 Panel"
-endif
-
-if (MACH_MXC30030ADS || MACH_MXC30031ADS)
-config FB_MXC_TOSHIBA_QVGA_PANEL
-    depends on FB_MXC_ASYNC_PANEL
-	bool "Toshiba 240x320 Panel"
-
-config FB_MXC_SHARP_128_PANEL
-    depends on FB_MXC_ASYNC_PANEL
-	bool "Sharp 128x128 Panel"
-endif
-
 endmenu
 
 choice
diff --git a/drivers/video/mxc/Makefile b/drivers/video/mxc/Makefile
index db1f9b8..ef64833 100644
--- a/drivers/video/mxc/Makefile
+++ b/drivers/video/mxc/Makefile
@@ -3,8 +3,12 @@ ifeq ($(CONFIG_ARCH_MX21)$(CONFIG_ARCH_MX27),y)
 	obj-$(CONFIG_FB_MXC_SYNC_PANEL)         += mx2fb.o mxcfb_modedb.o
 	obj-$(CONFIG_FB_MXC_EPSON_PANEL)        += mx2fb_epson.o
 else
-	obj-$(CONFIG_FB_MXC_TVOUT)              += fs453.o
+ifeq ($(CONFIG_MXC_IPU_V1),y)
 	obj-$(CONFIG_FB_MXC_SYNC_PANEL)         += mxcfb.o mxcfb_modedb.o
+else
+	obj-$(CONFIG_FB_MXC_SYNC_PANEL)         += mxc_ipuv3_fb.o
+endif
+	obj-$(CONFIG_FB_MXC_TVOUT)              += fs453.o
 	obj-$(CONFIG_FB_MXC_EPSON_PANEL)        += mxcfb_epson.o
 	obj-$(CONFIG_FB_MXC_EPSON_QVGA_PANEL)   += mxcfb_epson_qvga.o
 	obj-$(CONFIG_FB_MXC_TOSHIBA_QVGA_PANEL) += mxcfb_toshiba_qvga.o
diff --git a/drivers/video/mxc/mxc_ipuv3_fb.c b/drivers/video/mxc/mxc_ipuv3_fb.c
new file mode 100644
index 0000000..c3dd8ee
--- /dev/null
+++ b/drivers/video/mxc/mxc_ipuv3_fb.c
@@ -0,0 +1,1126 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxcfb.c
+ *
+ * @brief MXC Frame buffer driver for SDC
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/console.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+#include <asm/uaccess.h>
+#include <asm/arch/ipu.h>
+#include <asm/arch/mxcfb.h>
+
+/*
+ * Driver name
+ */
+#define MXCFB_NAME      "mxc_sdc_fb"
+/*!
+ * Structure containing the MXC specific framebuffer information.
+ */
+struct mxcfb_info {
+	int blank;
+	ipu_channel_t ipu_ch;
+	int ipu_di;
+	bool overlay;
+	uint32_t ipu_ch_irq;
+	uint32_t cur_ipu_buf;
+
+	u32 pseudo_palette[16];
+
+	struct semaphore flip_sem;
+	struct completion vsync_complete;
+};
+
+struct mxcfb_alloc_list {
+	struct list_head list;
+	dma_addr_t phy_addr;
+	void *cpu_addr;
+	u32 size;
+};
+
+static char *fb_mode;
+static unsigned long default_bpp = 16;
+#ifdef CONFIG_FB_MXC_INTERNAL_MEM
+static struct clk *iram_clk;
+#endif
+LIST_HEAD(fb_alloc_list);
+
+static uint32_t bpp_to_pixfmt(struct fb_info *fbi)
+{
+	uint32_t pixfmt = 0;
+
+	if (fbi->var.nonstd)
+		return fbi->var.nonstd;
+
+	switch (fbi->var.bits_per_pixel) {
+	case 24:
+		pixfmt = IPU_PIX_FMT_BGR24;
+		break;
+	case 32:
+		pixfmt = IPU_PIX_FMT_BGR32;
+		break;
+	case 16:
+		pixfmt = IPU_PIX_FMT_RGB565;
+		break;
+	}
+	return pixfmt;
+}
+
+static irqreturn_t mxcfb_irq_handler(int irq, void *dev_id);
+static int mxcfb_blank(int blank, struct fb_info *info);
+static int mxcfb_map_video_memory(struct fb_info *fbi, bool use_internal_ram);
+static int mxcfb_unmap_video_memory(struct fb_info *fbi);
+
+/*
+ * Set fixed framebuffer parameters based on variable settings.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_fix(struct fb_info *info)
+{
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+
+	fix->line_length = var->xres_virtual * var->bits_per_pixel / 8;
+
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->accel = FB_ACCEL_NONE;
+	fix->visual = FB_VISUAL_TRUECOLOR;
+	fix->xpanstep = 1;
+	fix->ypanstep = 1;
+
+	return 0;
+}
+
+/*
+ * Set framebuffer parameters and change the operating mode.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_par(struct fb_info *fbi)
+{
+	int retval;
+	bool use_iram = false;
+	u32 mem_len;
+	ipu_di_signal_cfg_t sig_cfg;
+	ipu_channel_params_t params;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+	dev_dbg(fbi->device, "Reconfiguring framebuffer\n");
+
+	ipu_disable_irq(mxc_fbi->ipu_ch_irq);
+	ipu_disable_channel(mxc_fbi->ipu_ch, true);
+	ipu_uninit_channel(mxc_fbi->ipu_ch);
+	ipu_clear_irq(mxc_fbi->ipu_ch_irq);
+	mxcfb_set_fix(fbi);
+
+	mem_len = fbi->var.yres_virtual * fbi->fix.line_length;
+	if (mem_len > fbi->fix.smem_len) {
+		if (fbi->fix.smem_start)
+			mxcfb_unmap_video_memory(fbi);
+
+#ifdef CONFIG_FB_MXC_INTERNAL_MEM
+		if (mxc_fbi->ipu_ch == MEM_BG_SYNC)
+			use_iram = true;
+#endif
+		if (mxcfb_map_video_memory(fbi, use_iram) < 0)
+			return -ENOMEM;
+	}
+#ifdef CONFIG_MXC_IPU_V1
+	ipu_init_channel(mxc_fbi->ipu_ch, NULL);
+#else
+	memset(&params, 0, sizeof(params));
+	params.mem_dp_bg_sync.di = mxc_fbi->ipu_di;
+
+	/* Assuming interlaced means YUV output */
+	if (fbi->var.vmode & FB_VMODE_INTERLACED) {
+		params.mem_dp_bg_sync.interlaced = true;
+		params.mem_dp_bg_sync.out_pixel_fmt = IPU_PIX_FMT_YUV444;
+	} else {
+		params.mem_dp_bg_sync.out_pixel_fmt = IPU_PIX_FMT_RGB666;
+	}
+	params.mem_dp_bg_sync.in_pixel_fmt = bpp_to_pixfmt(fbi);
+	ipu_init_channel(mxc_fbi->ipu_ch, &params);
+#endif
+
+	if (!mxc_fbi->overlay) {
+		memset(&sig_cfg, 0, sizeof(sig_cfg));
+		if (fbi->var.vmode & FB_VMODE_INTERLACED)
+			sig_cfg.interlaced = true;
+		if (fbi->var.vmode & FB_VMODE_ODD_FLD_FIRST) /* PAL */
+			sig_cfg.odd_field_first = true;
+		if (fbi->var.sync & FB_SYNC_EXT)
+			sig_cfg.ext_clk = true;
+		if (fbi->var.sync & FB_SYNC_HOR_HIGH_ACT)
+			sig_cfg.Hsync_pol = true;
+		if (fbi->var.sync & FB_SYNC_VERT_HIGH_ACT)
+			sig_cfg.Vsync_pol = true;
+		if (fbi->var.sync & FB_SYNC_CLK_INVERT)
+			sig_cfg.clk_pol = true;
+		if (fbi->var.sync & FB_SYNC_DATA_INVERT)
+			sig_cfg.data_pol = true;
+		if (fbi->var.sync & FB_SYNC_OE_ACT_HIGH)
+			sig_cfg.enable_pol = true;
+		if (fbi->var.sync & FB_SYNC_CLK_IDLE_EN)
+			sig_cfg.clkidle_en = true;
+
+		dev_dbg(fbi->device, "pixclock = %ul Hz\n",
+			(u32) (PICOS2KHZ(fbi->var.pixclock) * 1000UL));
+
+#ifdef CONFIG_MXC_IPU_V1
+		if (ipu_sdc_init_panel(mode,
+				       (PICOS2KHZ(fbi->var.pixclock)) * 1000UL,
+				       fbi->var.xres, fbi->var.yres,
+				       (fbi->var.sync & FB_SYNC_SWAP_RGB) ?
+				       IPU_PIX_FMT_BGR666 : IPU_PIX_FMT_RGB666,
+				       fbi->var.left_margin,
+				       fbi->var.hsync_len,
+				       fbi->var.right_margin,
+				       fbi->var.upper_margin,
+				       fbi->var.vsync_len,
+				       fbi->var.lower_margin, sig_cfg) != 0) {
+#else
+		if (ipu_init_sync_panel(mxc_fbi->ipu_di,
+					(PICOS2KHZ(fbi->var.pixclock)) * 1000UL,
+					fbi->var.xres, fbi->var.yres,
+					params.mem_dp_bg_sync.out_pixel_fmt,
+					fbi->var.left_margin,
+					fbi->var.hsync_len,
+					fbi->var.right_margin,
+					fbi->var.upper_margin,
+					fbi->var.vsync_len,
+					fbi->var.lower_margin,
+					480, sig_cfg) != 0) {
+#endif
+			dev_err(fbi->device,
+				"mxcfb: Error initializing panel.\n");
+			return -EINVAL;
+		}
+
+		fbi->mode =
+		    (struct fb_videomode *)fb_match_mode(&fbi->var,
+							 &fbi->modelist);
+	}
+
+	ipu_disp_set_window_pos(mxc_fbi->ipu_ch, 0, 0);
+
+	mxc_fbi->cur_ipu_buf = 0;
+	sema_init(&mxc_fbi->flip_sem, 1);
+
+	retval = ipu_init_channel_buffer(mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
+					 bpp_to_pixfmt(fbi),
+					 fbi->var.xres, fbi->var.yres,
+					 fbi->fix.line_length,
+					 IPU_ROTATE_NONE,
+					 fbi->fix.smem_start,
+					 fbi->fix.smem_start +
+					 (fbi->fix.line_length * fbi->var.yres),
+					 0, 0);
+	if (retval) {
+		dev_err(fbi->device,
+			"ipu_init_channel_buffer error %d\n", retval);
+		return retval;
+	}
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK) {
+		ipu_select_buffer(mxc_fbi->ipu_ch, IPU_INPUT_BUFFER, 0);
+		ipu_enable_channel(mxc_fbi->ipu_ch);
+	}
+
+	return 0;
+}
+
+/*
+ * Check framebuffer variable parameters and adjust to valid values.
+ *
+ * @param       var      framebuffer variable parameters
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	u32 vtotal;
+	u32 htotal;
+
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+#ifdef CONFIG_FB_MXC_INTERNAL_MEM
+	if ((info->fix.smem_start == FB_RAM_BASE_ADDR) &&
+	    ((var->yres_virtual * var->xres_virtual * var->bits_per_pixel / 8) >
+	     FB_RAM_SIZE))
+		return -EINVAL;
+#endif
+
+	if ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 24) &&
+	    (var->bits_per_pixel != 16))
+		var->bits_per_pixel = default_bpp;
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		var->red.length = 5;
+		var->red.offset = 11;
+		var->red.msb_right = 0;
+
+		var->green.length = 6;
+		var->green.offset = 5;
+		var->green.msb_right = 0;
+
+		var->blue.length = 5;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 24:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 32:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 8;
+		var->transp.offset = 24;
+		var->transp.msb_right = 0;
+		break;
+	}
+
+	if (var->pixclock < 1000) {
+		htotal = var->xres + var->right_margin + var->hsync_len +
+		    var->left_margin;
+		vtotal = var->yres + var->lower_margin + var->vsync_len +
+		    var->upper_margin;
+		var->pixclock = (vtotal * htotal * 6UL) / 100UL;
+		var->pixclock = KHZ2PICOS(var->pixclock);
+		dev_dbg(info->device,
+			"pixclock set for 60Hz refresh = %u ps\n",
+			var->pixclock);
+	}
+
+	var->height = -1;
+	var->width = -1;
+	var->grayscale = 0;
+
+	return 0;
+}
+
+static inline u_int _chan_to_field(u_int chan, struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int mxcfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			   u_int trans, struct fb_info *fbi)
+{
+	unsigned int val;
+	int ret = 1;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (fbi->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+				      7471 * blue) >> 16;
+	switch (fbi->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = fbi->pseudo_palette;
+
+			val = _chan_to_field(red, &fbi->var.red);
+			val |= _chan_to_field(green, &fbi->var.green);
+			val |= _chan_to_field(blue, &fbi->var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * Function to handle custom ioctls for MXC framebuffer.
+ *
+ * @param       inode   inode struct
+ *
+ * @param       file    file struct
+ *
+ * @param       cmd     Ioctl command to handle
+ *
+ * @param       arg     User pointer to command arguments
+ *
+ * @param       fbi     framebuffer information pointer
+ */
+static int mxcfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	int __user *argp = (void __user *)arg;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+	switch (cmd) {
+	case MXCFB_SET_GBL_ALPHA:
+		{
+			struct mxcfb_gbl_alpha ga;
+			if (copy_from_user(&ga, (void *)arg, sizeof(ga))) {
+				retval = -EFAULT;
+				break;
+			}
+			retval =
+			    ipu_disp_set_global_alpha(MEM_BG_SYNC,
+						      (bool) ga.enable,
+						      ga.alpha);
+			dev_dbg(fbi->device, "Set global alpha to %d\n",
+				ga.alpha);
+			break;
+		}
+	case MXCFB_SET_CLR_KEY:
+		{
+			struct mxcfb_color_key key;
+			if (copy_from_user(&key, (void *)arg, sizeof(key))) {
+				retval = -EFAULT;
+				break;
+			}
+			retval = ipu_disp_set_color_key(MEM_BG_SYNC, key.enable,
+							key.color_key);
+			dev_dbg(fbi->device, "Set color key to 0x%08X\n",
+				key.color_key);
+			break;
+		}
+	case MXCFB_WAIT_FOR_VSYNC:
+		{
+			init_completion(&mxc_fbi->vsync_complete);
+
+			down(&mxc_fbi->flip_sem);
+			ipu_enable_irq(mxc_fbi->ipu_ch_irq);
+			retval = wait_for_completion_interruptible_timeout(
+				&mxc_fbi->vsync_complete, 1 * HZ);
+			if (retval > 0) {
+				dev_err(fbi->device,
+					"MXCFB_WAIT_FOR_VSYNC: timeout\n");
+				retval = -ETIME;
+			}
+			break;
+		}
+	case FBIO_ALLOC:
+		{
+			int size;
+			struct mxcfb_alloc_list *mem;
+
+			mem = kzalloc(sizeof(*mem), GFP_KERNEL);
+			if (mem == NULL)
+				return -ENOMEM;
+
+			if (get_user(size, argp))
+				return -EFAULT;
+
+			mem->size = PAGE_ALIGN(size);
+
+			mem->cpu_addr = dma_alloc_coherent(fbi->device, size,
+							   &mem->phy_addr,
+							   GFP_DMA);
+			if (mem->cpu_addr == NULL) {
+				kfree(mem);
+				return -ENOMEM;
+			}
+
+			list_add(&mem->list, &fb_alloc_list);
+
+			dev_dbg(fbi->device, "allocated %d bytes @ 0x%08X\n",
+				mem->size, mem->phy_addr);
+
+			if (put_user(mem->phy_addr, argp))
+				return -EFAULT;
+
+			break;
+		}
+	case FBIO_FREE:
+		{
+			unsigned long offset;
+			struct mxcfb_alloc_list *mem;
+
+			if (get_user(offset, argp))
+				return -EFAULT;
+
+			retval = -EINVAL;
+			list_for_each_entry(mem, &fb_alloc_list, list) {
+				if (mem->phy_addr == offset) {
+					list_del(&mem->list);
+					dma_free_coherent(fbi->device,
+							  mem->size,
+							  mem->cpu_addr,
+							  mem->phy_addr);
+					kfree(mem);
+					retval = 0;
+					break;
+				}
+			}
+
+			break;
+		}
+	case MXCFB_SET_OVERLAY_POS:
+		{
+			struct mxcfb_pos pos;
+			if (copy_from_user(&pos, (void *)arg, sizeof(pos))) {
+				retval = -EFAULT;
+				break;
+			}
+			retval = ipu_disp_set_window_pos(mxc_fbi->ipu_ch,
+							 pos.x, pos.y);
+			break;
+		}
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+/*
+ * mxcfb_blank():
+ *      Blank the display.
+ */
+static int mxcfb_blank(int blank, struct fb_info *info)
+{
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+
+	dev_dbg(info->device, "blank = %d\n", blank);
+
+	if (mxc_fbi->blank == blank)
+		return 0;
+
+	mxc_fbi->blank = blank;
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		ipu_disable_channel(mxc_fbi->ipu_ch, true);
+		ipu_uninit_channel(mxc_fbi->ipu_ch);
+		break;
+	case FB_BLANK_UNBLANK:
+		mxcfb_set_par(info);
+		break;
+	}
+	return 0;
+}
+
+/*
+ * Pan or Wrap the Display
+ *
+ * This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag
+ *
+ * @param               var     Variable screen buffer information
+ * @param               info    Framebuffer information pointer
+ */
+static int
+mxcfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+	u_int y_bottom;
+	unsigned long base;
+
+	if (var->xoffset > 0) {
+		dev_dbg(info->device, "x panning not supported\n");
+		return -EINVAL;
+	}
+
+	if ((info->var.xoffset == var->xoffset) &&
+	    (info->var.yoffset == var->yoffset))
+		return 0;	/* No change, do nothing */
+
+	y_bottom = var->yoffset;
+
+	if (!(var->vmode & FB_VMODE_YWRAP))
+		y_bottom += var->yres;
+
+	if (y_bottom > info->var.yres_virtual)
+		return -EINVAL;
+
+	base = (var->yoffset * var->xres_virtual + var->xoffset);
+	base *= (var->bits_per_pixel) / 8;
+	base += info->fix.smem_start;
+
+	dev_dbg(info->device, "Updating SDC BG buf %d address=0x%08lX\n",
+		mxc_fbi->cur_ipu_buf, base);
+
+	mxc_fbi->cur_ipu_buf = !mxc_fbi->cur_ipu_buf;
+	if (ipu_update_channel_buffer(mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
+				      mxc_fbi->cur_ipu_buf, base) == 0) {
+		ipu_select_buffer(mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
+				  mxc_fbi->cur_ipu_buf);
+		ipu_clear_irq(mxc_fbi->ipu_ch_irq);
+		ipu_enable_irq(mxc_fbi->ipu_ch_irq);
+	} else {
+		dev_err(info->device,
+			"Error updating SDC buf %d to address=0x%08lX\n",
+			mxc_fbi->cur_ipu_buf, base);
+	}
+
+	dev_dbg(info->device, "Update complete\n");
+
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+
+	if (var->vmode & FB_VMODE_YWRAP)
+		info->var.vmode |= FB_VMODE_YWRAP;
+	else
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+
+	return 0;
+}
+
+/*
+ * Function to handle custom mmap for MXC framebuffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @param       vma     Pointer to vm_area_struct
+ */
+static int mxcfb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)
+{
+	bool found = false;
+	u32 len;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	struct mxcfb_alloc_list *mem;
+
+	if (offset < fbi->fix.smem_len) {
+		/* mapping framebuffer memory */
+		len = fbi->fix.smem_len - offset;
+		vma->vm_pgoff = (fbi->fix.smem_start + offset) >> PAGE_SHIFT;
+	} else {
+		list_for_each_entry(mem, &fb_alloc_list, list) {
+			if (offset == mem->phy_addr) {
+				found = true;
+				len = mem->size;
+				break;
+			}
+		}
+		if (!found)
+			return -EINVAL;
+	}
+
+	len = PAGE_ALIGN(len);
+	if (vma->vm_end - vma->vm_start > len)
+		return -EINVAL;
+
+	/* make buffers write-thru cacheable */
+	vma->vm_page_prot = __pgprot(pgprot_val(vma->vm_page_prot) &
+				     ~L_PTE_BUFFERABLE);
+
+	vma->vm_flags |= VM_IO | VM_RESERVED;
+
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+			    vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+		dev_dbg(fbi->device, "mmap remap_pfn_range failed\n");
+		return -ENOBUFS;
+	}
+
+	return 0;
+}
+
+/*!
+ * This structure contains the pointers to the control functions that are
+ * invoked by the core framebuffer driver to perform operations like
+ * blitting, rectangle filling, copy regions and cursor definition.
+ */
+static struct fb_ops mxcfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_set_par = mxcfb_set_par,
+	.fb_check_var = mxcfb_check_var,
+	.fb_setcolreg = mxcfb_setcolreg,
+	.fb_pan_display = mxcfb_pan_display,
+	.fb_ioctl = mxcfb_ioctl,
+	.fb_mmap = mxcfb_mmap,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_blank = mxcfb_blank,
+};
+
+static irqreturn_t mxcfb_irq_handler(int irq, void *dev_id)
+{
+	struct fb_info *fbi = dev_id;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	complete(&mxc_fbi->vsync_complete);
+	up(&mxc_fbi->flip_sem);
+	ipu_disable_irq(irq);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Suspends the framebuffer and blanks the screen. Power management support
+ */
+static int mxcfb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct fb_info *fbi = platform_get_drvdata(pdev);
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+#ifdef CONFIG_FB_MXC_LOW_PWR_DISPLAY
+	void *fbmem;
+#endif
+
+	acquire_console_sem();
+	fb_set_suspend(fbi, 1);
+	release_console_sem();
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK) {
+#ifdef CONFIG_FB_MXC_LOW_PWR_DISPLAY
+		if (drv_data->fbi->fix.smem_start != FB_RAM_BASE_ADDR) {
+			fbmem = ioremap(FB_RAM_BASE_ADDR, FB_RAM_SIZE);
+			memcpy(fbmem, drv_data->fbi->screen_base, FB_RAM_SIZE);
+			iounmap(fbmem);
+			mxc_fbi->cur_ipu_buf = !mxc_fbi->cur_ipu_buf;
+			ipu_update_channel_buffer(MEM_SDC_BG, IPU_INPUT_BUFFER,
+						  mxc_fbi->cur_ipu_buf,
+						  FB_RAM_BASE_ADDR);
+			ipu_select_buffer(MEM_SDC_BG, IPU_INPUT_BUFFER,
+					  mxc_fbi->cur_ipu_buf);
+		}
+		ipu_lowpwr_display_enable();
+#else
+		ipu_disable_channel(mxc_fbi->ipu_ch, true);
+#endif
+	}
+	return 0;
+}
+
+/*
+ * Resumes the framebuffer and unblanks the screen. Power management support
+ */
+static int mxcfb_resume(struct platform_device *pdev)
+{
+	struct fb_info *fbi = platform_get_drvdata(pdev);
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK) {
+#ifdef CONFIG_FB_MXC_LOW_PWR_DISPLAY
+		ipu_lowpwr_display_disable();
+		if (drv_data->fbi->fix.smem_start != FB_RAM_BASE_ADDR) {
+			mxc_fbi->cur_ipu_buf = !mxc_fbi->cur_ipu_buf;
+			ipu_update_channel_buffer(MEM_SDC_BG, IPU_INPUT_BUFFER,
+						  mxc_fbi->cur_ipu_buf,
+						  drv_data->fbi->fix.
+						  smem_start);
+			ipu_select_buffer(MEM_SDC_BG, IPU_INPUT_BUFFER,
+					  mxc_fbi->cur_ipu_buf);
+		}
+#else
+		ipu_enable_channel(MEM_BG_SYNC);
+#endif
+	}
+
+	acquire_console_sem();
+	fb_set_suspend(fbi, 0);
+	release_console_sem();
+
+	return 0;
+}
+
+/*
+ * Main framebuffer functions
+ */
+
+/*!
+ * Allocates the DRAM memory for the frame buffer.      This buffer is remapped
+ * into a non-cached, non-buffered, memory region to allow palette and pixel
+ * writes to occur without flushing the cache.  Once this area is remapped,
+ * all virtual memory access to the video memory should occur at the new region.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @param       use_internal_ram flag on whether to use internal RAM for memory
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_map_video_memory(struct fb_info *fbi, bool use_internal_ram)
+{
+	int retval = 0;
+
+#ifdef CONFIG_FB_MXC_INTERNAL_MEM
+	if (use_internal_ram) {
+		fbi->fix.smem_len = FB_RAM_SIZE;
+		fbi->fix.smem_start = FB_RAM_BASE_ADDR;
+		if (fbi->fix.smem_len <
+		    (fbi->var.yres_virtual * fbi->fix.line_length)) {
+			dev_err(fbi->device,
+				"Not enough internal RAM for fb config\n");
+			retval = -EINVAL;
+			goto err0;
+		}
+
+		if (request_mem_region(fbi->fix.smem_start, fbi->fix.smem_len,
+				       fbi->device->driver->name) == NULL) {
+			dev_err(fbi->device,
+				"Unable to request internal RAM\n");
+			retval = -ENOMEM;
+			goto err0;
+		}
+
+		fbi->screen_base = ioremap(fbi->fix.smem_start,
+					   fbi->fix.smem_len);
+		if (!fbi->screen_base) {
+			dev_err(fbi->device,
+				"Unable to map fb memory to virtual address\n");
+			release_mem_region(fbi->fix.smem_start,
+					   fbi->fix.smem_len);
+			retval = -EIO;
+			goto err0;
+		}
+
+		iram_clk = clk_get(NULL, "iram_clk");
+		clk_enable(iram_clk);
+	} else
+#endif
+	{
+		fbi->fix.smem_len = fbi->var.yres_virtual *
+		    fbi->fix.line_length;
+		fbi->screen_base =
+		    dma_alloc_writecombine(fbi->device,
+					   fbi->fix.smem_len,
+					   (dma_addr_t *) &fbi->fix.smem_start,
+					   GFP_DMA);
+
+		if (fbi->screen_base == 0) {
+			dev_err(fbi->device,
+				"Unable to allocate framebuffer memory\n");
+			retval = -EBUSY;
+			goto err0;
+		}
+	}
+
+	dev_dbg(fbi->device, "allocated fb @ paddr=0x%08X, size=%d.\n",
+		(uint32_t) fbi->fix.smem_start, fbi->fix.smem_len);
+
+	fbi->screen_size = fbi->fix.smem_len;
+
+	/* Clear the screen */
+	memset((char *)fbi->screen_base, 0, fbi->fix.smem_len);
+
+	return 0;
+
+err0:
+	fbi->fix.smem_len = 0;
+	fbi->fix.smem_start = 0;
+	fbi->screen_base = NULL;
+	return retval;
+}
+
+/*!
+ * De-allocates the DRAM memory for the frame buffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_unmap_video_memory(struct fb_info *fbi)
+{
+#ifdef CONFIG_FB_MXC_INTERNAL_MEM
+	if (fbi->fix.smem_start == FB_RAM_BASE_ADDR) {
+		iounmap(fbi->screen_base);
+		release_mem_region(fbi->fix.smem_start, fbi->fix.smem_len);
+		fbi->fix.smem_start = 0;
+		fbi->fix.smem_len = 0;
+		clk_disable(iram_clk);
+	} else
+#endif
+	{
+		dma_free_writecombine(fbi->device, fbi->fix.smem_len,
+				      fbi->screen_base, fbi->fix.smem_start);
+	}
+	fbi->screen_base = 0;
+	fbi->fix.smem_start = 0;
+	fbi->fix.smem_len = 0;
+	return 0;
+}
+
+/*!
+ * Initializes the framebuffer information pointer. After allocating
+ * sufficient memory for the framebuffer structure, the fields are
+ * filled with custom information passed in from the configurable
+ * structures.  This includes information such as bits per pixel,
+ * color maps, screen width/height and RGBA offsets.
+ *
+ * @return      Framebuffer structure initialized with our information
+ */
+static struct fb_info *mxcfb_init_fbinfo(struct device *dev, struct fb_ops *ops)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxcfbi;
+
+	/*
+	 * Allocate sufficient memory for the fb structure
+	 */
+	fbi = framebuffer_alloc(sizeof(struct mxcfb_info), dev);
+	if (!fbi)
+		return NULL;
+
+	mxcfbi = (struct mxcfb_info *)fbi->par;
+
+	fbi->var.activate = FB_ACTIVATE_NOW;
+
+	fbi->fbops = ops;
+	fbi->flags = FBINFO_FLAG_DEFAULT;
+	fbi->pseudo_palette = mxcfbi->pseudo_palette;
+
+	/*
+	 * Allocate colormap
+	 */
+	fb_alloc_cmap(&fbi->cmap, 16, 0);
+
+	return fbi;
+}
+
+/*!
+ * Probe routine for the framebuffer driver. It is called during the
+ * driver binding process.      The following functions are performed in
+ * this routine: Framebuffer initialization, Memory allocation and
+ * mapping, Framebuffer registration, IPU initialization.
+ *
+ * @return      Appropriate error code to the kernel common code
+ */
+static int mxcfb_probe(struct platform_device *pdev)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxcfbi;
+	int ret = 0;
+
+	/*
+	 * Initialize FB structures
+	 */
+	fbi = mxcfb_init_fbinfo(&pdev->dev, &mxcfb_ops);
+	if (!fbi) {
+		ret = -ENOMEM;
+		goto err0;
+	}
+	mxcfbi = (struct mxcfb_info *)fbi->par;
+
+	if (pdev->id == 0) {
+		mxcfbi->ipu_ch_irq = IPU_IRQ_BG_SYNC_EOF;
+		mxcfbi->ipu_ch = MEM_BG_SYNC;
+		mxcfbi->ipu_di = pdev->id;
+		ipu_disp_set_global_alpha(MEM_BG_SYNC, true, 0x80);
+		ipu_disp_set_color_key(MEM_BG_SYNC, false, 0);
+
+		strcpy(fbi->fix.id, "DISP3 BG");
+	} else if (pdev->id == 1) {
+		mxcfbi->ipu_ch_irq = IPU_IRQ_DC_SYNC_EOF;
+		mxcfbi->ipu_ch = MEM_DC_SYNC;
+		mxcfbi->ipu_di = pdev->id;
+
+		strcpy(fbi->fix.id, "DISP3 BG - DI1");
+	} else if (pdev->id == 2) {	/* Overlay */
+		mxcfbi->ipu_ch_irq = IPU_IRQ_FG_SYNC_EOF;
+		mxcfbi->ipu_ch = MEM_FG_SYNC;
+		mxcfbi->ipu_di = -1;
+		mxcfbi->overlay = true;
+
+		strcpy(fbi->fix.id, "DISP3 FG");
+	}
+
+	if (ipu_request_irq(mxcfbi->ipu_ch_irq, mxcfb_irq_handler, 0,
+			    MXCFB_NAME, fbi) != 0) {
+		dev_err(&pdev->dev, "Error registering BG irq handler.\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+	ipu_disable_irq(mxcfbi->ipu_ch_irq);
+
+	/* Default Y virtual size is 2x panel size */
+#ifndef CONFIG_FB_MXC_INTERNAL_MEM
+	fbi->var.yres_virtual = fbi->var.yres * 2;
+#endif
+
+	mxcfbi->blank = FB_BLANK_UNBLANK;
+
+	/* Need dummy values until real panel is configured */
+	fbi->var.xres = 240;
+	fbi->var.yres = 320;
+
+	mxcfb_check_var(&fbi->var, fbi);
+	mxcfb_set_fix(fbi);
+
+	ret = register_framebuffer(fbi);
+	if (ret < 0)
+		goto err2;
+
+	platform_set_drvdata(pdev, fbi);
+
+	dev_err(&pdev->dev, "fb registered, using mode %s\n", fb_mode);
+	return 0;
+
+err2:
+	ipu_free_irq(mxcfbi->ipu_ch_irq, fbi);
+err1:
+	fb_dealloc_cmap(&fbi->cmap);
+	framebuffer_release(fbi);
+err0:
+	return ret;
+}
+
+static int mxcfb_remove(struct platform_device *pdev)
+{
+	struct fb_info *fbi = platform_get_drvdata(pdev);
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	if (!fbi)
+		return 0;
+
+	mxcfb_blank(FB_BLANK_POWERDOWN, fbi);
+	ipu_free_irq(mxc_fbi->ipu_ch_irq, fbi);
+	mxcfb_unmap_video_memory(fbi);
+
+	if (&fbi->cmap)
+		fb_dealloc_cmap(&fbi->cmap);
+
+	unregister_framebuffer(fbi);
+	framebuffer_release(fbi);
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcfb_driver = {
+	.driver = {
+		   .name = MXCFB_NAME,
+		   },
+	.probe = mxcfb_probe,
+	.remove = mxcfb_remove,
+	.suspend = mxcfb_suspend,
+	.resume = mxcfb_resume,
+};
+
+/*
+ * Parse user specified options (`video=trident:')
+ * example:
+ * 	video=trident:800x600,bpp=16,noaccel
+ */
+int mxcfb_setup(char *options)
+{
+	char *opt;
+	if (!options || !*options)
+		return 0;
+	while ((opt = strsep(&options, ",")) != NULL) {
+		if (!*opt)
+			continue;
+		if (!strncmp(opt, "bpp=", 4))
+			default_bpp = simple_strtoul(opt + 4, NULL, 0);
+		else
+			fb_mode = opt;
+	}
+	return 0;
+}
+
+/*!
+ * Main entry function for the framebuffer. The function registers the power
+ * management callback functions with the kernel and also registers the MXCFB
+ * callback functions with the core Linux framebuffer driver \b fbmem.c
+ *
+ * @return      Error code indicating success or failure
+ */
+int __init mxcfb_init(void)
+{
+	int ret = 0;
+#ifndef MODULE
+	char *option = NULL;
+#endif
+
+#ifndef MODULE
+	if (fb_get_options("mxcfb", &option))
+		return -ENODEV;
+	mxcfb_setup(option);
+#endif
+
+	ret = platform_driver_register(&mxcfb_driver);
+	return ret;
+}
+
+void mxcfb_exit(void)
+{
+	platform_driver_unregister(&mxcfb_driver);
+}
+
+module_init(mxcfb_init);
+module_exit(mxcfb_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC framebuffer driver");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("fb");
diff --git a/drivers/video/mxc/mxcfb.c b/drivers/video/mxc/mxcfb.c
index 8bd0685..a1c5d63 100644
--- a/drivers/video/mxc/mxcfb.c
+++ b/drivers/video/mxc/mxcfb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -371,9 +371,8 @@ static int mxcfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 	var->width = -1;
 	var->grayscale = 0;
 
-	/* Copy nonstd field to/from sync for fbset usage */
-	var->sync |= var->nonstd;
-	var->nonstd |= var->sync;
+	/* nonstd used for YUV formats, but only RGB supported */
+	var->nonstd = 0;
 
 	return 0;
 }
diff --git a/drivers/video/mxc/mxcfb_epson_vga.c b/drivers/video/mxc/mxcfb_epson_vga.c
index b2338ee..6622deb 100644
--- a/drivers/video/mxc/mxcfb_epson_vga.c
+++ b/drivers/video/mxc/mxcfb_epson_vga.c
@@ -51,7 +51,7 @@ static struct fb_videomode video_modes[] = {
 	{
 	 /* 480x640 @ 60 Hz */
 	 "Epson-VGA", 60, 480, 640, 41701, 0, 41, 10, 5, 20, 10,
-	 FB_SYNC_CLK_INVERT,
+	 FB_SYNC_CLK_INVERT | FB_SYNC_OE_ACT_HIGH,
 	 FB_VMODE_NONINTERLACED,
 	 0,},
 };
@@ -121,16 +121,21 @@ static int __devinit lcd_spi_probe(struct spi_device *spi)
 	lcd_spi = spi;
 
 	if (plat) {
+		io_reg = regulator_get(&spi->dev, plat->io_reg);
+		if (!IS_ERR(io_reg)) {
+			regulator_set_voltage(io_reg, 1800000);
+			regulator_enable(io_reg);
+		}
+		core_reg = regulator_get(&spi->dev, plat->core_reg);
+		if (!IS_ERR(core_reg)) {
+			regulator_set_voltage(core_reg, 2800000);
+			regulator_enable(core_reg);
+		}
+
 		lcd_reset = plat->reset;
 		if (lcd_reset)
 			lcd_reset();
 
-		io_reg = regulator_get(&spi->dev, plat->io_reg);
-		regulator_set_voltage(io_reg, 1800000);
-		regulator_enable(io_reg);
-		core_reg = regulator_get(&spi->dev, plat->core_reg);
-		regulator_set_voltage(core_reg, 2800000);
-		regulator_enable(core_reg);
 	}
 
 	spi->bits_per_word = 9;
diff --git a/include/asm-arm/arch-mxc/ipu.h b/include/asm-arm/arch-mxc/ipu.h
index 0b7786f..3677cb2 100644
--- a/include/asm-arm/arch-mxc/ipu.h
+++ b/include/asm-arm/arch-mxc/ipu.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -72,7 +72,7 @@ typedef enum {
 
 /*  IPU Pixel format definitions */
 /*  Four-character-code (FOURCC) */
-#define ipu_fourcc(a,b,c,d)\
+#define fourcc(a, b, c, d)\
         (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
 
 /*!
@@ -85,53 +85,66 @@ typedef enum {
 /*! @{ */
 /*! @name Generic or Raw Data Formats */
 /*! @{ */
-#define IPU_PIX_FMT_GENERIC ipu_fourcc('I','P','U','0')	/*!< IPU Generic Data */
-#define IPU_PIX_FMT_GENERIC_32 ipu_fourcc('I','P','U','1')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC fourcc('I', 'P', 'U', '0')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC_32 fourcc('I', 'P', 'U', '1')	/*!< IPU Generic Data */
 /*! @} */
 /*! @name RGB Formats */
 /*! @{ */
-#define IPU_PIX_FMT_RGB332  ipu_fourcc('R','G','B','1')	/*!<  8  RGB-3-3-2     */
-#define IPU_PIX_FMT_RGB555  ipu_fourcc('R','G','B','O')	/*!< 16  RGB-5-5-5     */
-#define IPU_PIX_FMT_RGB565  ipu_fourcc('R','G','B','P')	/*!< 16  RGB-5-6-5     */
-#define IPU_PIX_FMT_RGB666  ipu_fourcc('R','G','B','6')	/*!< 18  RGB-6-6-6     */
-#define IPU_PIX_FMT_BGR666  ipu_fourcc('B','G','R','6')	/*!< 18  BGR-6-6-6     */
-#define IPU_PIX_FMT_BGR24   ipu_fourcc('B','G','R','3')	/*!< 24  BGR-8-8-8     */
-#define IPU_PIX_FMT_RGB24   ipu_fourcc('R','G','B','3')	/*!< 24  RGB-8-8-8     */
-#define IPU_PIX_FMT_BGR32   ipu_fourcc('B','G','R','4')	/*!< 32  BGR-8-8-8-8   */
-#define IPU_PIX_FMT_BGRA32  ipu_fourcc('B','G','R','A')	/*!< 32  BGR-8-8-8-8   */
-#define IPU_PIX_FMT_RGB32   ipu_fourcc('R','G','B','4')	/*!< 32  RGB-8-8-8-8   */
-#define IPU_PIX_FMT_RGBA32  ipu_fourcc('R','G','B','A')	/*!< 32  RGB-8-8-8-8   */
-#define IPU_PIX_FMT_ABGR32  ipu_fourcc('A','B','G','R')	/*!< 32  ABGR-8-8-8-8  */
+#define IPU_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*!<  8  RGB-3-3-2    */
+#define IPU_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*!< 16  RGB-5-5-5    */
+#define IPU_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
+#define IPU_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*!< 18  RGB-6-6-6    */
+#define IPU_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*!< 18  BGR-6-6-6    */
+#define IPU_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define IPU_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define IPU_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
 /*! @} */
 /*! @name YUV Interleaved Formats */
 /*! @{ */
-#define IPU_PIX_FMT_YUYV    ipu_fourcc('Y','U','Y','V')	/*!< 16  YUV 4:2:2     */
-#define IPU_PIX_FMT_UYVY    ipu_fourcc('U','Y','V','Y')	/*!< 16  YUV 4:2:2     */
-#define IPU_PIX_FMT_Y41P    ipu_fourcc('Y','4','1','P')	/*!< 12  YUV 4:1:1     */
+#define IPU_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_Y41P    fourcc('Y', '4', '1', 'P')	/*!< 12 YUV 4:1:1 */
+#define IPU_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
 /*! @} */
 /*! @name YUV Planar Formats */
 /*! @{ */
-#define IPU_PIX_FMT_GREY    ipu_fourcc('G','R','E','Y')	/*!< 8  Greyscale     */
-#define IPU_PIX_FMT_YVU410P ipu_fourcc('Y','V','U','9')	/*!< 9  YVU 4:1:0     */
-#define IPU_PIX_FMT_YUV410P ipu_fourcc('Y','U','V','9')	/*!< 9  YUV 4:1:0     */
-#define IPU_PIX_FMT_YVU420P ipu_fourcc('Y','V','1','2')	/*!< 12  YVU 4:2:0     */
-#define IPU_PIX_FMT_YUV420P ipu_fourcc('I','4','2','0')	/*!< 12  YUV420 planar */
-#define IPU_PIX_FMT_YUV420P2 ipu_fourcc('Y','U','1','2')	/*!< 12  YUV 4:2:0 planar */
-#define IPU_PIX_FMT_YVU422P ipu_fourcc('Y','V','1','6')	/*!< 16  YVU422 planar */
-#define IPU_PIX_FMT_YUV422P ipu_fourcc('4','2','2','P')	/*!< 16  YUV422 planar */
+#define IPU_PIX_FMT_GREY    fourcc('G', 'R', 'E', 'Y')	/*!< 8  Greyscale */
+#define IPU_PIX_FMT_YVU410P fourcc('Y', 'V', 'U', '9')	/*!< 9  YVU 4:1:0 */
+#define IPU_PIX_FMT_YUV410P fourcc('Y', 'U', 'V', '9')	/*!< 9  YUV 4:1:0 */
+#define IPU_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define IPU_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define IPU_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
 /*! @} */
 
-/*#define IPU_PIX_FMT_YUV411P ipu_fourcc('4','1','1','P')  16  YVU411 planar */
-/*#define IPU_PIX_FMT_YYUV    ipu_fourcc('Y','Y','U','V')  16  YUV 4:2:2     */
-
 /* IPU Driver channels definitions.	*/
 /* Note these are different from IDMA channels */
+#ifdef CONFIG_MXC_IPU_V1
 #define _MAKE_CHAN(num, in, out, sec)    ((num << 24) | (sec << 16) | (out << 8) | in)
 #define IPU_CHAN_ID(ch)         (ch >> 24)
 #define IPU_CHAN_SEC_DMA(ch)    ((uint32_t) (ch >> 16) & 0xFF)
 #define IPU_CHAN_OUT_DMA(ch)    ((uint32_t) (ch >> 8) & 0xFF)
 #define IPU_CHAN_IN_DMA(ch)     ((uint32_t) (ch & 0xFF))
 
+#else
+#define IPU_MAX_CH	32
+#define _MAKE_CHAN(num, v_in, g_in, a_in, out) \
+	((num << 24) | (v_in << 18) | (g_in << 12) | (a_in << 6) | out)
+#define _MAKE_ALT_CHAN(ch)		(ch | (IPU_MAX_CH << 24))
+#define IPU_CHAN_ID(ch)			(ch >> 24)
+#define IPU_CHAN_ALT(ch)		(ch & 0x02000000)
+#define IPU_CHAN_ALPHA_IN_DMA(ch)	((uint32_t) (ch >> 6) & 0x3F)
+#define IPU_CHAN_GRAPH_IN_DMA(ch)	((uint32_t) (ch >> 12) & 0x3F)
+#define IPU_CHAN_VIDEO_IN_DMA(ch)	((uint32_t) (ch >> 18) & 0x3F)
+#define IPU_CHAN_OUT_DMA(ch)		((uint32_t) (ch & 0x3F))
+#define NO_DMA 0x3F
+#define ALT	1
+#endif
 /*!
  * Enumeration of IPU logical channels. An IPU logical channel is defined as a
  * combination of an input (memory to IPU), output (IPU to memory), and/or
@@ -139,6 +152,8 @@ typedef enum {
  * Some channels consist of only an input or output.
  */
 typedef enum {
+	CHAN_NONE = -1,
+#ifdef CONFIG_MXC_IPU_V1
 	CSI_MEM = _MAKE_CHAN(1, 0xFF, 7, 0xFF),	/*!< CSI raw sensor data to memory */
 
 	CSI_PRP_ENC_MEM = _MAKE_CHAN(2, 0xFF, 0, 0xFF),	/*!< CSI to IC Encoder PreProcessing to Memory */
@@ -159,6 +174,9 @@ typedef enum {
 	MEM_SDC_FG = _MAKE_CHAN(15, 15, 0xFF, 0xFF),	/*!< Memory to SDC Foreground plane */
 	MEM_SDC_MASK = _MAKE_CHAN(16, 16, 0xFF, 0xFF),	/*!< Memory to SDC Mask */
 
+	MEM_BG_SYNC = MEM_SDC_BG,
+	MEM_FG_SYNC = MEM_SDC_FG,
+
 	ADC_SYS1 = _MAKE_CHAN(17, 18, 22, 20),	/*!< Memory to ADC System Channel 1 */
 	ADC_SYS2 = _MAKE_CHAN(18, 19, 23, 21),	/*!< Memory to ADC System Channel 2 */
 
@@ -166,16 +184,42 @@ typedef enum {
 	MEM_PF_U_MEM = _MAKE_CHAN(20, 27, 30, 25),	/*!< U and PF Memory to Post-filter to U Memory */
 	MEM_PF_V_MEM = _MAKE_CHAN(21, 28, 31, 0xFF),	/*!< V Memory to Post-filter to V Memory */
 
-	CHAN_NONE = 0xFFFFFFFF,
+	MEM_DC_SYNC = CHAN_NONE,
+#else
+	MEM_ROT_ENC_MEM = _MAKE_CHAN(1, 45, NO_DMA, NO_DMA, 48),
+	MEM_ROT_VF_MEM = _MAKE_CHAN(2, 46, NO_DMA, NO_DMA, 49),
+	MEM_ROT_PP_MEM = _MAKE_CHAN(3, 47, NO_DMA, NO_DMA, 50),
+
+	MEM_PRP_ENC_MEM = _MAKE_CHAN(4, 12, 14, 17, 20),
+	MEM_PRP_VF_MEM = _MAKE_CHAN(5, 12, 14, 17, 21),
+	MEM_PP_MEM = _MAKE_CHAN(6, 11, 15, 18, 22),
+
+	MEM_DC_SYNC = _MAKE_CHAN(7, 28, NO_DMA, NO_DMA, NO_DMA),
+	MEM_DC_ASYNC = _MAKE_CHAN(8, 41, NO_DMA, NO_DMA, NO_DMA),
+	MEM_BG_SYNC = _MAKE_CHAN(9, 23, NO_DMA, 51, NO_DMA),
+	MEM_FG_SYNC = _MAKE_CHAN(10, 27, NO_DMA, 31, NO_DMA),
+
+	MEM_BG_ASYNC0 = _MAKE_CHAN(11, 24, NO_DMA, 52, NO_DMA),
+	MEM_FG_ASYNC0 = _MAKE_CHAN(12, 29, NO_DMA, 33, NO_DMA),
+	MEM_BG_ASYNC1 = _MAKE_ALT_CHAN(MEM_BG_ASYNC0),
+	MEM_FG_ASYNC1 = _MAKE_ALT_CHAN(MEM_FG_ASYNC0),
+
+	MEM_PP_ADC = CHAN_NONE,
+	ADC_SYS2 = CHAN_NONE,
+#endif
+
 } ipu_channel_t;
 
 /*!
  * Enumeration of types of buffers for a logical channel.
  */
 typedef enum {
-	IPU_INPUT_BUFFER,	/*!< Buffer for input to IPU */
-	IPU_OUTPUT_BUFFER,	/*!< Buffer for output from IPU */
-	IPU_SEC_INPUT_BUFFER,	/*!< Buffer for second input to IPU */
+	IPU_OUTPUT_BUFFER = 0,	/*!< Buffer for output from IPU */
+	IPU_ALPHA_IN_BUFFER = 1,	/*!< Buffer for input to IPU */
+	IPU_GRAPH_IN_BUFFER = 2,	/*!< Buffer for input to IPU */
+	IPU_VIDEO_IN_BUFFER = 3,	/*!< Buffer for input to IPU */
+	IPU_INPUT_BUFFER = IPU_VIDEO_IN_BUFFER,
+	IPU_SEC_INPUT_BUFFER = IPU_GRAPH_IN_BUFFER,
 } ipu_buffer_t;
 
 /*!
@@ -189,17 +233,6 @@ typedef enum {
 } display_port_t;
 
 /*!
- * Enumeration of ADC channels.
-typedef enum
-{
-        PRPCHAN,
-        PPCHAN,
-        SYSCHAN1,
-        SYSCHAN2
-}sys_channel_t;
- */
-
-/*!
  * Enumeration of ADC channel operation mode.
  */
 typedef enum {
@@ -323,18 +356,31 @@ typedef union {
 		uint32_t out_left;
 		uint32_t out_top;
 	} mem_pp_adc;
-
 	struct {
 		pf_operation_t operation;
 	} mem_pf_mem;
-
+	struct {
+		uint32_t di;
+		bool interlaced;
+	} mem_dc_sync;
 	struct {
 		uint32_t temp;
 	} mem_sdc_fg;
 	struct {
+		uint32_t di;
+		uint32_t in_pixel_fmt;
+		uint32_t out_pixel_fmt;
+		bool interlaced;
+	} mem_dp_bg_sync;
+	struct {
 		uint32_t temp;
 	} mem_sdc_bg;
 	struct {
+		uint32_t di;
+		uint32_t in_pixel_fmt;
+		uint32_t out_pixel_fmt;
+	} mem_dp_fg_sync;
+	struct {
 		display_port_t disp;
 		mcu_mode_t ch_mode;
 		uint32_t out_left;
@@ -352,6 +398,7 @@ typedef union {
  * Enumeration of IPU interrupt sources.
  */
 enum ipu_irq_line {
+#ifdef CONFIG_MXC_IPU_V1
 	IPU_IRQ_PRP_ENC_OUT_EOF = 0,
 	IPU_IRQ_PRP_VF_OUT_EOF = 1,
 	IPU_IRQ_PP_OUT_EOF = 2,
@@ -366,8 +413,10 @@ enum ipu_irq_line {
 	IPU_IRQ_PRP_VF_ROT_IN_EOF = 11,
 	IPU_IRQ_PP_ROT_OUT_EOF = 12,
 	IPU_IRQ_PP_ROT_IN_EOF = 13,
-	IPU_IRQ_SDC_BG_EOF = 14,
-	IPU_IRQ_SDC_FG_EOF = 15,
+	IPU_IRQ_BG_SYNC_EOF = 14,
+	IPU_IRQ_SDC_BG_EOF = IPU_IRQ_BG_SYNC_EOF,
+	IPU_IRQ_FG_SYNC_EOF = 15,
+	IPU_IRQ_SDC_FG_EOF = IPU_IRQ_FG_SYNC_EOF,
 	IPU_IRQ_SDC_MASK_EOF = 16,
 	IPU_IRQ_SDC_BG_PART_EOF = 17,
 	IPU_IRQ_ADC_SYS1_WR_EOF = 18,
@@ -482,6 +531,49 @@ enum ipu_irq_line {
 	IPU_IRQ_DI_LLA_LOCK_ERR = 141,
 	IPU_IRQ_AHB_M1_ERR = 142,
 	IPU_IRQ_AHB_M12_ERR = 143,
+#else
+	IPU_IRQ_PP_IN_EOF = 11,
+	IPU_IRQ_PRP_IN_EOF = 12,
+	IPU_IRQ_PRP_GRAPH_IN_EOF = 14,
+	IPU_IRQ_PP_GRAPH_IN_EOF = 15,
+	IPU_IRQ_PRP_ALPHA_IN_EOF = 17,
+	IPU_IRQ_PP_ALPHA_IN_EOF = 18,
+	IPU_IRQ_PRP_ENC_OUT_EOF = 20,
+	IPU_IRQ_PRP_VF_OUT_EOF = 21,
+	IPU_IRQ_PP_OUT_EOF = 22,
+	IPU_IRQ_BG_SYNC_EOF = 23,
+	IPU_IRQ_BG_ASYNC_EOF = 24,
+	IPU_IRQ_FG_SYNC_EOF = 27,
+	IPU_IRQ_DC_SYNC_EOF = 28,
+	IPU_IRQ_FG_ASYNC_EOF = 29,
+	IPU_IRQ_FG_ALPHA_SYNC_EOF = 31,
+
+	IPU_IRQ_FG_ALPHA_ASYNC_EOF = 33,
+	IPU_IRQ_DC_READ_EOF = 40,
+	IPU_IRQ_DC_ASYNC_EOF = 41,
+	IPU_IRQ_DC_CMD1_EOF = 42,
+	IPU_IRQ_DC_CMD2_EOF = 43,
+	IPU_IRQ_DC_MASK_EOF = 44,
+	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 45,
+	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 46,
+	IPU_IRQ_PP_ROT_OUT_EOF = 47,
+	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 48,
+	IPU_IRQ_PRP_VF_ROT_IN_EOF = 49,
+	IPU_IRQ_PP_ROT_IN_EOF = 50,
+	IPU_IRQ_BG_ALPHA_SYNC_EOF = 51,
+	IPU_IRQ_BG_ALPHA_ASYNC_EOF = 52,
+
+	IPU_IRQ_DP_SF_START = 448 + 2,
+	IPU_IRQ_DP_SF_END = 448 + 3,
+	IPU_IRQ_DC_FC_0 = 448 + 8,
+	IPU_IRQ_DC_FC_1 = 448 + 9,
+	IPU_IRQ_DC_FC_2 = 448 + 10,
+	IPU_IRQ_DC_FC_3 = 448 + 11,
+	IPU_IRQ_DC_FC_4 = 448 + 12,
+	IPU_IRQ_DC_FC_6 = 448 + 13,
+	IPU_IRQ_VSYNC_PRE_0 = 448 + 14,
+	IPU_IRQ_VSYNC_PRE_1 = 448 + 15,
+#endif
 
 	IPU_IRQ_COUNT
 };
@@ -491,6 +583,9 @@ enum ipu_irq_line {
  */
 typedef struct {
 	unsigned datamask_en:1;
+	unsigned ext_clk:1;
+	unsigned interlaced:1;
+	unsigned odd_field_first:1;
 	unsigned clksel_en:1;
 	unsigned clkidle_en:1;
 	unsigned data_pol:1;	/* true = inverted */
@@ -672,6 +767,15 @@ typedef struct {
 int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t * params);
 void ipu_uninit_channel(ipu_channel_t channel);
 
+static inline bool ipu_can_rotate_in_place(ipu_rotate_mode_t rot)
+{
+#ifdef CONFIG_MXC_IPU_V1
+	return (rot < IPU_ROTATE_90_RIGHT);
+#else
+	return (rot < IPU_ROTATE_HORIZ_FLIP);
+#endif
+}
+
 int32_t ipu_init_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
 				uint32_t pixel_fmt,
 				uint16_t width, uint16_t height,
@@ -713,6 +817,7 @@ int32_t ipu_sdc_init_panel(ipu_panel_t panel,
 			   uint16_t hEndWidth, uint16_t vStartWidth,
 			   uint16_t vSyncWidth, uint16_t vEndWidth,
 			   ipu_di_signal_cfg_t sig);
+
 int32_t ipu_sdc_set_window_pos(ipu_channel_t channel, int16_t x_pos,
 			       int16_t y_pos);
 int32_t ipu_sdc_set_global_alpha(bool enable, uint8_t alpha);
@@ -720,6 +825,22 @@ int32_t ipu_sdc_set_color_key(ipu_channel_t channel, bool enable,
 			      uint32_t colorKey);
 int32_t ipu_sdc_set_brightness(uint8_t value);
 
+int32_t ipu_init_sync_panel(int disp,
+			    uint32_t pixel_clk,
+			    uint16_t width, uint16_t height,
+			    uint32_t pixel_fmt,
+			    uint16_t h_start_width, uint16_t h_sync_width,
+			    uint16_t h_end_width, uint16_t v_start_width,
+			    uint16_t v_sync_width, uint16_t v_end_width,
+			    uint32_t v_to_h_sync, ipu_di_signal_cfg_t sig);
+
+int32_t ipu_disp_set_window_pos(ipu_channel_t channel, int16_t x_pos,
+				int16_t y_pos);
+int32_t ipu_disp_set_global_alpha(ipu_channel_t channel, bool enable,
+				  uint8_t alpha);
+int32_t ipu_disp_set_color_key(ipu_channel_t channel, bool enable,
+			       uint32_t colorKey);
+
 /* ADC API */
 int32_t ipu_adc_write_template(display_port_t disp, uint32_t * pCmd,
 			       bool write);
@@ -771,7 +892,6 @@ int32_t ipu_pf_set_pause_row(uint32_t pause_row);
 uint32_t bytes_per_pixel(uint32_t fmt);
 
 /* New added for IPU-lib functionality*/
-
 int ipu_open(void);
 int ipu_register_generic_isr(int irq, void *dev);
 void ipu_close(void);
diff --git a/include/asm-arm/arch-mxc/mx37.h b/include/asm-arm/arch-mxc/mx37.h
index 2eccc15..28b7c93 100644
--- a/include/asm-arm/arch-mxc/mx37.h
+++ b/include/asm-arm/arch-mxc/mx37.h
@@ -226,6 +226,7 @@
 /*
  * Memory regions and CS
  */
+#define IPU_CTRL_BASE_ADDR	0x80000000
 #define CSD0_BASE_ADDR          0x40000000
 #define CSD1_BASE_ADDR          0x50000000
 
-- 
1.5.4.4

