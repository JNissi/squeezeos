From e6e1ab66cb1ca604746e1c9e6a19d8799afbf44f Mon Sep 17 00:00:00 2001
From: Thomas Gleixner <tglx@linutronix.de>
Date: Fri, 18 Jul 2008 17:27:28 +0200
Subject: [PATCH] nohz: prevent tick stop outside of the idle loop

Jack Ren and Eric Miao tracked down the following long standing
problem in the NOHZ code:

	scheduler switch to idle task
	enable interrupts

Window starts here

	----> interrupt happens (does not set NEED_RESCHED)
	      	irq_exit() stops the tick

	----> interrupt happens (does set NEED_RESCHED)

	return from schedule()

	cpu_idle(): preempt_disable();

Window ends here

The interrupts can happen at any point inside the race window. The
first interrupt stops the tick, the second one causes the scheduler to
rerun and switch away from idle again and we end up with the tick
disabled.

The fact that it needs two interrupts where the first one does not set
NEED_RESCHED and the second one does made the bug obscure and extremly
hard to reproduce and analyse. Kudos to Jack and Eric.

Solution: Limit the NOHZ functionality to the idle loop to make sure
that we can not run into such a situation ever again.

cpu_idle()
{
	preempt_disable();

	while(1) {
		 tick_nohz_stop_sched_tick(1); <- tell NOHZ code that we
		 			          are in the idle loop

		 while (!need_resched())
		       halt();

		 tick_nohz_restart_sched_tick(); <- disables NOHZ mode
		 preempt_enable_no_resched();
		 schedule();
		 preempt_disable();
	}
}

In hindsight we should have done this forever, but ...

/me grabs a large brown paperbag.

Debugged-by: Jack Ren <jack.ren@marvell.com>,
Debugged-by: eric miao <eric.y.miao@gmail.com>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 5f5c18a777fca4dbb58b6b16ca06c8517c7075fb)
---
 arch/arm/kernel/process.c              |    2 +-
 arch/avr32/kernel/process.c            |    2 ++
 arch/mips/kernel/process.c             |    2 +-
 arch/powerpc/kernel/idle.c             |    2 +-
 arch/powerpc/platforms/iseries/setup.c |    4 ++--
 arch/sh/kernel/process.c               |    2 +-
 arch/sparc64/kernel/process.c          |    2 +-
 arch/um/kernel/process.c               |    2 +-
 arch/x86/kernel/process_32.c           |    2 +-
 arch/x86/kernel/process_64.c           |    2 +-
 include/linux/tick.h                   |    5 +++--
 kernel/softirq.c                       |    2 +-
 kernel/time/tick-sched.c               |   12 +++++++++++-
 13 files changed, 27 insertions(+), 14 deletions(-)

Index: linux-2.6.24/arch/arm/kernel/process.c
===================================================================
--- linux-2.6.24.orig/arch/arm/kernel/process.c	2009-01-24 20:51:34.000000000 +0100
+++ linux-2.6.24/arch/arm/kernel/process.c	2009-01-24 21:01:57.000000000 +0100
@@ -165,7 +165,7 @@ void cpu_idle(void)
 		if (!idle)
 			idle = default_idle;
 		leds_event(led_idle_start);
-		tick_nohz_stop_sched_tick();
+		tick_nohz_stop_sched_tick(1);
 		while (!need_resched())
 			idle();
 		leds_event(led_idle_end);
Index: linux-2.6.24/arch/avr32/kernel/process.c
===================================================================
--- linux-2.6.24.orig/arch/avr32/kernel/process.c	2009-01-24 20:51:34.000000000 +0100
+++ linux-2.6.24/arch/avr32/kernel/process.c	2009-01-24 21:01:57.000000000 +0100
@@ -30,8 +30,10 @@ void cpu_idle(void)
 {
 	/* endless idle loop with no priority at all */
 	while (1) {
+		tick_nohz_stop_sched_tick(1);
 		while (!need_resched())
 			cpu_idle_sleep();
+		tick_nohz_restart_sched_tick();
 		preempt_enable_no_resched();
 		schedule();
 		preempt_disable();
Index: linux-2.6.24/arch/mips/kernel/process.c
===================================================================
--- linux-2.6.24.orig/arch/mips/kernel/process.c	2009-01-24 20:51:34.000000000 +0100
+++ linux-2.6.24/arch/mips/kernel/process.c	2009-01-24 21:01:57.000000000 +0100
@@ -53,7 +53,7 @@ void __noreturn cpu_idle(void)
 {
 	/* endless idle loop with no priority at all */
 	while (1) {
-		tick_nohz_stop_sched_tick();
+		tick_nohz_stop_sched_tick(1);
 		while (!need_resched()) {
 #ifdef CONFIG_SMTC_IDLE_HOOK_DEBUG
 			extern void smtc_idle_loop_hook(void);
Index: linux-2.6.24/arch/powerpc/kernel/idle.c
===================================================================
--- linux-2.6.24.orig/arch/powerpc/kernel/idle.c	2009-01-24 20:51:34.000000000 +0100
+++ linux-2.6.24/arch/powerpc/kernel/idle.c	2009-01-24 21:01:57.000000000 +0100
@@ -60,7 +60,7 @@ void cpu_idle(void)
 
 	set_thread_flag(TIF_POLLING_NRFLAG);
 	while (1) {
-		tick_nohz_stop_sched_tick();
+		tick_nohz_stop_sched_tick(1);
 		while (!need_resched() && !cpu_should_die()) {
 			ppc64_runlatch_off();
 
Index: linux-2.6.24/arch/powerpc/platforms/iseries/setup.c
===================================================================
--- linux-2.6.24.orig/arch/powerpc/platforms/iseries/setup.c	2009-01-24 20:51:34.000000000 +0100
+++ linux-2.6.24/arch/powerpc/platforms/iseries/setup.c	2009-01-24 21:01:57.000000000 +0100
@@ -563,7 +563,7 @@ static void yield_shared_processor(void)
 static void iseries_shared_idle(void)
 {
 	while (1) {
-		tick_nohz_stop_sched_tick();
+		tick_nohz_stop_sched_tick(1);
 		while (!need_resched() && !hvlpevent_is_pending()) {
 			local_irq_disable();
 			ppc64_runlatch_off();
@@ -593,7 +593,7 @@ static void iseries_dedicated_idle(void)
 	set_thread_flag(TIF_POLLING_NRFLAG);
 
 	while (1) {
-		tick_nohz_stop_sched_tick();
+		tick_nohz_stop_sched_tick(1);
 		if (!need_resched()) {
 			while (!need_resched()) {
 				ppc64_runlatch_off();
Index: linux-2.6.24/arch/sh/kernel/process.c
===================================================================
--- linux-2.6.24.orig/arch/sh/kernel/process.c	2009-01-24 20:51:34.000000000 +0100
+++ linux-2.6.24/arch/sh/kernel/process.c	2009-01-24 21:01:57.000000000 +0100
@@ -85,7 +85,7 @@ void cpu_idle(void)
 		if (!idle)
 			idle = default_idle;
 
-		tick_nohz_stop_sched_tick();
+		tick_nohz_stop_sched_tick(1);
 		while (!need_resched())
 			idle();
 		tick_nohz_restart_sched_tick();
Index: linux-2.6.24/arch/sparc64/kernel/process.c
===================================================================
--- linux-2.6.24.orig/arch/sparc64/kernel/process.c	2009-01-24 20:51:34.000000000 +0100
+++ linux-2.6.24/arch/sparc64/kernel/process.c	2009-01-24 21:01:57.000000000 +0100
@@ -93,7 +93,7 @@ void cpu_idle(void)
 	set_thread_flag(TIF_POLLING_NRFLAG);
 
 	while(1) {
-		tick_nohz_stop_sched_tick();
+		tick_nohz_stop_sched_tick(1);
 
 		while (!need_resched() && !cpu_is_offline(cpu))
 			sparc64_yield(cpu);
Index: linux-2.6.24/arch/um/kernel/process.c
===================================================================
--- linux-2.6.24.orig/arch/um/kernel/process.c	2009-01-24 20:51:34.000000000 +0100
+++ linux-2.6.24/arch/um/kernel/process.c	2009-01-24 21:01:57.000000000 +0100
@@ -247,7 +247,7 @@ void default_idle(void)
 		if (need_resched())
 			schedule();
 
-		tick_nohz_stop_sched_tick();
+		tick_nohz_stop_sched_tick(1);
 		nsecs = disable_timer();
 		idle_sleep(nsecs);
 		tick_nohz_restart_sched_tick();
Index: linux-2.6.24/arch/x86/kernel/process_32.c
===================================================================
--- linux-2.6.24.orig/arch/x86/kernel/process_32.c	2009-01-24 20:51:34.000000000 +0100
+++ linux-2.6.24/arch/x86/kernel/process_32.c	2009-01-24 21:01:57.000000000 +0100
@@ -177,7 +177,7 @@ void cpu_idle(void)
 
 	/* endless idle loop with no priority at all */
 	while (1) {
-		tick_nohz_stop_sched_tick();
+		tick_nohz_stop_sched_tick(1);
 		while (!need_resched()) {
 			void (*idle)(void);
 
Index: linux-2.6.24/arch/x86/kernel/process_64.c
===================================================================
--- linux-2.6.24.orig/arch/x86/kernel/process_64.c	2009-01-24 20:52:55.000000000 +0100
+++ linux-2.6.24/arch/x86/kernel/process_64.c	2009-01-24 21:01:57.000000000 +0100
@@ -212,7 +212,7 @@ void cpu_idle (void)
 	current_thread_info()->status |= TS_POLLING;
 	/* endless idle loop with no priority at all */
 	while (1) {
-		tick_nohz_stop_sched_tick();
+		tick_nohz_stop_sched_tick(1);
 		while (!need_resched()) {
 			void (*idle)(void);
 
Index: linux-2.6.24/include/linux/tick.h
===================================================================
--- linux-2.6.24.orig/include/linux/tick.h	2009-01-24 20:51:35.000000000 +0100
+++ linux-2.6.24/include/linux/tick.h	2009-01-24 21:01:57.000000000 +0100
@@ -47,6 +47,7 @@ struct tick_sched {
 	unsigned long			check_clocks;
 	enum tick_nohz_mode		nohz_mode;
 	ktime_t				idle_tick;
+	int				inidle;
 	int				tick_stopped;
 	unsigned long			idle_jiffies;
 	unsigned long			idle_calls;
@@ -99,12 +100,12 @@ static inline int tick_check_oneshot_cha
 #endif /* !CONFIG_GENERIC_CLOCKEVENTS */
 
 # ifdef CONFIG_NO_HZ
-extern void tick_nohz_stop_sched_tick(void);
+extern void tick_nohz_stop_sched_tick(int inidle);
 extern void tick_nohz_restart_sched_tick(void);
 extern void tick_nohz_update_jiffies(void);
 extern ktime_t tick_nohz_get_sleep_length(void);
 # else
-static inline void tick_nohz_stop_sched_tick(void) { }
+static inline void tick_nohz_stop_sched_tick(int inidle) { }
 static inline void tick_nohz_restart_sched_tick(void) { }
 static inline void tick_nohz_update_jiffies(void) { }
 static inline ktime_t tick_nohz_get_sleep_length(void)
Index: linux-2.6.24/kernel/softirq.c
===================================================================
--- linux-2.6.24.orig/kernel/softirq.c	2009-01-24 20:51:34.000000000 +0100
+++ linux-2.6.24/kernel/softirq.c	2009-01-24 21:01:57.000000000 +0100
@@ -305,7 +305,7 @@ void irq_exit(void)
 #ifdef CONFIG_NO_HZ
 	/* Make sure that timer wheel updates are propagated */
 	if (!in_interrupt() && idle_cpu(smp_processor_id()) && !need_resched())
-		tick_nohz_stop_sched_tick();
+		tick_nohz_stop_sched_tick(0);
 #endif
 	preempt_enable_no_resched();
 }
Index: linux-2.6.24/kernel/time/tick-sched.c
===================================================================
--- linux-2.6.24.orig/kernel/time/tick-sched.c	2009-01-24 20:51:34.000000000 +0100
+++ linux-2.6.24/kernel/time/tick-sched.c	2009-01-24 21:01:57.000000000 +0100
@@ -150,7 +150,7 @@ void tick_nohz_update_jiffies(void)
  * Called either from the idle loop or from irq_exit() when an idle period was
  * just interrupted by an interrupt which did not cause a reschedule.
  */
-void tick_nohz_stop_sched_tick(void)
+void tick_nohz_stop_sched_tick(int inidle)
 {
 	unsigned long seq, last_jiffies, next_jiffies, delta_jiffies, flags;
 	struct tick_sched *ts;
@@ -178,6 +178,11 @@ void tick_nohz_stop_sched_tick(void)
 	if (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))
 		goto end;
 
+	if (!inidle && !ts->inidle)
+		goto end;
+
+	ts->inidle = 1;
+
 	if (need_resched())
 		goto end;
 
@@ -335,7 +340,12 @@ void tick_nohz_restart_sched_tick(void)
 	ktime_t now, delta;
 
 	if (!ts->tick_stopped)
+	if (!ts->inidle || !ts->tick_stopped) {
+		ts->inidle = 0;
 		return;
+	}
+
+	ts->inidle = 0;
 
 	/* Update jiffies first */
 	now = ktime_get();
