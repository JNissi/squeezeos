From 94cc54acc5f68cbb3e97b51c295575ad6709ee67 Mon Sep 17 00:00:00 2001
From: Aditya Shankar M.C <adityas@freescale.com>
Date: Tue, 22 Jan 2008 15:30:04 -0600
Subject: [PATCH] ENGR00042906 IRAM Support For Audio

This patch adds support for IRAM usage for Audio buffers.The IRAM
will replace the DDR as the DMA buffer.
---
 arch/arm/mach-mx3/Kconfig                     |   18 ++
 arch/arm/mach-mx3/dma.c                       |   22 +-
 arch/arm/mach-mx3/mm.c                        |    6 +-
 arch/arm/plat-mxc/sdma/iapi/include/iapiLow.h |    2 -
 arch/arm/plat-mxc/sdma/iapi/include/iapiOS.h  |   14 +-
 arch/arm/plat-mxc/sdma/iapi/src/iapiHigh.c    |    2 +-
 arch/arm/plat-mxc/sdma/iapi/src/iapiLowMcu.c  |    4 +-
 arch/arm/plat-mxc/sdma/iapi/src/iapiMiddle.c  |   24 +-
 arch/arm/plat-mxc/sdma/iapi/src/iapiOS.c      |    3 +
 arch/arm/plat-mxc/sdma/sdma.c                 |    8 +
 arch/arm/plat-mxc/sdma/sdma_malloc.c          |  148 +++++++++
 include/asm-arm/arch-mxc/mx31.h               |   15 +-
 include/asm-arm/arch-mxc/sdma.h               |   10 +
 include/asm-arm/pgtable.h                     |    2 +-
 sound/arm/Kconfig                             |   13 +
 sound/arm/mxc-alsa-pmic.c                     |  400 ++++++++++++++++++++++---
 16 files changed, 628 insertions(+), 63 deletions(-)

diff --git a/arch/arm/mach-mx3/Kconfig b/arch/arm/mach-mx3/Kconfig
index cc52847..735ac86 100644
--- a/arch/arm/mach-mx3/Kconfig
+++ b/arch/arm/mach-mx3/Kconfig
@@ -27,6 +27,24 @@ config MXC_SDMA_API
            This selects the Freescale MXC SDMA API.
            If unsure, say N.
 
+menu "SDMA options"
+        depends on MXC_SDMA_API
+
+config SDMA_IRAM
+        bool "Use Internal RAM for SDMA transfer"
+        default n
+	help
+           Support Internal RAM as SDMA buffer or control structures
+
+config SDMA_IRAM_SIZE
+        hex "Reserved bytes of IRAM for SDMA (0x800-0x2000)"
+        range 0x800 0x2000
+        depends on SDMA_IRAM
+        default "0x1000"
+        help
+           Set the size of IRAM for SDMA. It must be multiple of 512bytes.
+endmenu
+
 config ARCH_MXC_HAS_NFC_V1
         bool "MXC NFC Hardware Version 1"
 	depends on !(MACH_MX31ADS && XIP_KERNEL)
diff --git a/arch/arm/mach-mx3/dma.c b/arch/arm/mach-mx3/dma.c
index afd0f19..d2fa288 100644
--- a/arch/arm/mach-mx3/dma.c
+++ b/arch/arm/mach-mx3/dma.c
@@ -29,6 +29,12 @@
 #define MXC_SSI_RXFIFO_WML        0x6
 #define MXC_FIRI_WML              16
 
+#ifdef CONFIG_SDMA_IRAM
+#define trans_type  int_2_per
+#else
+#define trans_type emi_2_per
+#endif
+
 typedef struct mxc_sdma_info_entry_s {
 	mxc_dma_device_t device;
 	mxc_sdma_channel_params_t *chnl_info;
@@ -421,7 +427,7 @@ static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
 			.watermark_level = MXC_SSI_TXFIFO_WML,
 			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
 			.peripheral_type = SSI_SP,
-			.transfer_type = emi_2_per,
+			.transfer_type = trans_type,
 			.event_id = DMA_REQ_SSI2_TX1,
 			.bd_number = 32,
 			.word_size = TRANSFER_8BIT,
@@ -449,7 +455,7 @@ static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
 			.watermark_level = MXC_SSI_TXFIFO_WML,
 			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
 			.peripheral_type = SSI_SP,
-			.transfer_type = emi_2_per,
+			.transfer_type = trans_type,
 			.event_id = DMA_REQ_SSI2_TX1,
 			.bd_number = 32,
 			.word_size = TRANSFER_16BIT,
@@ -477,7 +483,7 @@ static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
 			.watermark_level = MXC_SSI_TXFIFO_WML,
 			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
 			.peripheral_type = SSI_SP,
-			.transfer_type = emi_2_per,
+			.transfer_type = trans_type,
 			.event_id = DMA_REQ_SSI2_TX1,
 			.bd_number = 32,
 			.word_size = TRANSFER_32BIT,
@@ -505,7 +511,7 @@ static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
 			.watermark_level = MXC_SSI_TXFIFO_WML,
 			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
 			.peripheral_type = SSI_SP,
-			.transfer_type = emi_2_per,
+			.transfer_type = trans_type,
 			.event_id = DMA_REQ_SSI2_TX2,
 			.bd_number = 32,
 			.word_size = TRANSFER_8BIT,
@@ -533,7 +539,7 @@ static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
 			.watermark_level = MXC_SSI_TXFIFO_WML,
 			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
 			.peripheral_type = SSI_SP,
-			.transfer_type = emi_2_per,
+			.transfer_type = trans_type,
 			.event_id = DMA_REQ_SSI2_TX2,
 			.bd_number = 32,
 			.word_size = TRANSFER_16BIT,
@@ -714,7 +720,11 @@ mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
  */
 void mxc_get_static_channels(mxc_dma_channel_t * chnl)
 {
-	/* No channels statically allocated for MX31 */
+#ifdef CONFIG_SDMA_IRAM
+	int i;
+	for (i = MXC_DMA_CHANNEL_IRAM; i < MAX_DMA_CHANNELS; i++)
+		chnl[i].dynamic = 0;
+#endif				/*CONFIG_SDMA_IRAM */
 }
 
 EXPORT_SYMBOL(mxc_sdma_get_channel_params);
diff --git a/arch/arm/mach-mx3/mm.c b/arch/arm/mach-mx3/mm.c
index 4510fef..46f7bca 100644
--- a/arch/arm/mach-mx3/mm.c
+++ b/arch/arm/mach-mx3/mm.c
@@ -41,9 +41,9 @@
  */
 static struct map_desc mxc_io_desc[] __initdata = {
 	{
-	 .virtual = IRAM_BASE_ADDR_VIRT,
-	 .pfn = __phys_to_pfn(IRAM_BASE_ADDR),
-	 .length = IRAM_SIZE,
+	 .virtual = IRAM_BASE_ADDR_VIRT & 0xFFF00000,
+	 .pfn = __phys_to_pfn(IRAM_BASE_ADDR & 0xFFF00000),
+	 .length = SZ_1M,
 	 .type = MT_NONSHARED_DEVICE},
 	{
 	 .virtual = X_MEMC_BASE_ADDR_VIRT,
diff --git a/arch/arm/plat-mxc/sdma/iapi/include/iapiLow.h b/arch/arm/plat-mxc/sdma/iapi/include/iapiLow.h
index 2fb54ae..43aff7a 100644
--- a/arch/arm/plat-mxc/sdma/iapi/include/iapiLow.h
+++ b/arch/arm/plat-mxc/sdma/iapi/include/iapiLow.h
@@ -56,8 +56,6 @@
 /* ****************************************************************************
  * Macro-command Section
  *****************************************************************************/
-#define MALLOC(x) (* iapi_Malloc)(x)
-#define FREE(x)   if (x!=NULL) (* iapi_Free)(x)
 
 #define GOTO_SLEEP(x) (iapi_GotoSleep)(x)
 #define INIT_SLEEP(x) (iapi_InitSleep)(x)
diff --git a/arch/arm/plat-mxc/sdma/iapi/include/iapiOS.h b/arch/arm/plat-mxc/sdma/iapi/include/iapiOS.h
index 82b6349..17186da 100644
--- a/arch/arm/plat-mxc/sdma/iapi/include/iapiOS.h
+++ b/arch/arm/plat-mxc/sdma/iapi/include/iapiOS.h
@@ -54,8 +54,14 @@
 /* ****************************************************************************
  * Macro-command Section
  *****************************************************************************/
-#define MALLOC(x) (* iapi_Malloc)(x)
-#define FREE(x)   if (x!=NULL) (* iapi_Free)(x)
+#define SDMA_ERAM 0
+#define SDMA_IRAM 1
+#ifdef CONFIG_SDMA_IRAM
+#define MALLOC(x, s) (s == SDMA_ERAM)? (* iapi_Malloc)(x):(* iapi_iram_Malloc)(x)
+#else /*CONFIG_SDMA_IRAM */
+#define MALLOC(x, s) (* iapi_Malloc)(x)
+#endif /*CONFIG_SDMA_IRAM */
+#define FREE(x)   if (x!=NULL)  (* iapi_Free)(x)
 
 #define GOTO_SLEEP(x) (iapi_GotoSleep)(x)
 #define INIT_SLEEP(x) (iapi_InitSleep)(x)
@@ -64,6 +70,10 @@
  * Public Function Prototype Section
  *****************************************************************************/
 
+#ifdef CONFIG_SDMA_IRAM
+extern void*(* iapi_iram_Malloc) (size_t size);
+#endif /*CONFIG_SDMA_IRAM*/
+
 extern void*(* iapi_Malloc) (size_t size);
 extern void (* iapi_Free) (void * ptr);
 
diff --git a/arch/arm/plat-mxc/sdma/iapi/src/iapiHigh.c b/arch/arm/plat-mxc/sdma/iapi/src/iapiHigh.c
index 426497e..9fa7d4a 100644
--- a/arch/arm/plat-mxc/sdma/iapi/src/iapiHigh.c
+++ b/arch/arm/plat-mxc/sdma/iapi/src/iapiHigh.c
@@ -406,7 +406,7 @@ iapi_Open (channelDescriptor * cd_p, unsigned char channelNumber)
     }
     /* Whole channel control block data structure */
     ccb_p = (channelControlBlock *)
-      MALLOC(CH_NUM*sizeof(channelControlBlock));
+      MALLOC(CH_NUM*sizeof(channelControlBlock), SDMA_IRAM);
     if (ccb_p == NULL){
       result = IAPI_ERR_CCB_ALLOC_FAILED |
                IAPI_ERR_CH_AVAILABLE | channelNumber;
diff --git a/arch/arm/plat-mxc/sdma/iapi/src/iapiLowMcu.c b/arch/arm/plat-mxc/sdma/iapi/src/iapiLowMcu.c
index 4e0ff7c..ea8d007 100644
--- a/arch/arm/plat-mxc/sdma/iapi/src/iapiLowMcu.c
+++ b/arch/arm/plat-mxc/sdma/iapi/src/iapiLowMcu.c
@@ -96,7 +96,7 @@ iapi_Channel0Command( channelDescriptor * cd_p, void * buf,
   }
 
   /* Allocation of buffer descriptors */
-  bd_p = (bufferDescriptor *)MALLOC(sizeof( bufferDescriptor ));
+  bd_p = (bufferDescriptor *)MALLOC(sizeof( bufferDescriptor ), SDMA_ERAM);
   if (bd_p != NULL) {
 	ccb_p->baseBDptr = (bufferDescriptor *)iapi_Virt2Phys(bd_p);
   } else {
@@ -437,7 +437,7 @@ iapi_lowAssignScript(channelDescriptor * cd_p, script_data * data_p)
    }
 
    /* Allocate context and initialize PC to required script start adress*/
-   chContext  = (contextData *) MALLOC(sizeof(contextData));
+   chContext  = (contextData *) MALLOC(sizeof(contextData), SDMA_ERAM);
    if (chContext == NULL)
    {
       result = IAPI_ERR_B_ALLOC_FAILED | cd_p->channelNumber;
diff --git a/arch/arm/plat-mxc/sdma/iapi/src/iapiMiddle.c b/arch/arm/plat-mxc/sdma/iapi/src/iapiMiddle.c
index dc25570..3b8d7a7 100644
--- a/arch/arm/plat-mxc/sdma/iapi/src/iapiMiddle.c
+++ b/arch/arm/plat-mxc/sdma/iapi/src/iapiMiddle.c
@@ -67,9 +67,19 @@ iapi_AllocBD (channelControlBlock * ccb_p)
   bufferDescriptor * ptrBD = NULL;
 
   if (ccb_p->channelDescriptor->bufferDescNumber != 0){
-     ptrBD = (bufferDescriptor *)
-       MALLOC( ccb_p->channelDescriptor->bufferDescNumber *
-           sizeof(bufferDescriptor));
+#ifdef CONFIG_SDMA_IRAM
+     channelDescriptor * cd_p = ccb_p->channelDescriptor;
+     if(cd_p->channelNumber >= MXC_DMA_CHANNEL_IRAM) {
+         ptrBD = (bufferDescriptor *)
+           MALLOC( ccb_p->channelDescriptor->bufferDescNumber *
+               sizeof(bufferDescriptor), SDMA_IRAM);
+     } else
+#endif /*CONFIG_SDMA_IRAM*/
+     {
+     	ptrBD = (bufferDescriptor *)
+       		MALLOC( ccb_p->channelDescriptor->bufferDescNumber * 
+           		sizeof(bufferDescriptor), SDMA_ERAM);   
+     }
   }
   if (ptrBD != NULL) {
    ptrBD->mode.command = 0;
@@ -103,7 +113,7 @@ iapi_AllocContext(contextData ** ctxd_p, unsigned char channel)
    return -result;
   }
 
-  ctxData = (contextData *)MALLOC(sizeof(contextData));
+  ctxData = (contextData *)MALLOC(sizeof(contextData), SDMA_ERAM);
 
   if (ctxData !=NULL) {
    *ctxd_p = ctxData;
@@ -148,7 +158,7 @@ iapi_AllocChannelDesc (channelDescriptor ** cd_p, unsigned char channel)
    return -result;
   }
 
-  tmpCDptr = (channelDescriptor *)MALLOC(sizeof(channelDescriptor));
+  tmpCDptr = (channelDescriptor *)MALLOC(sizeof(channelDescriptor), SDMA_ERAM);
 
   if (tmpCDptr != NULL){
    iapi_memcpy(tmpCDptr, &iapi_ChannelDefaults, sizeof (channelDescriptor));
@@ -579,7 +589,7 @@ iapi_InitializeMemory (channelControlBlock * ccb_p)
         iapi_SetBufferDescriptor(bd_p,
                       (unsigned char)ccb_p->channelDescriptor->dataSize,
                       BD_CONT|BD_EXTD, ccb_p->channelDescriptor->bufferSize,
-                      MALLOC(ccb_p->channelDescriptor->bufferSize), NULL);
+                      MALLOC(ccb_p->channelDescriptor->bufferSize, SDMA_ERAM), NULL);
       }
      }
      bd_p++;
@@ -600,7 +610,7 @@ iapi_InitializeMemory (channelControlBlock * ccb_p)
                     (unsigned char)ccb_p->channelDescriptor->dataSize,
                     BD_EXTD|BD_WRAP|BD_INTR,
                     ccb_p->channelDescriptor->bufferSize,
-                    MALLOC(ccb_p->channelDescriptor->bufferSize), NULL);
+                    MALLOC(ccb_p->channelDescriptor->bufferSize, SDMA_ERAM), NULL);
      }
    }
   }
diff --git a/arch/arm/plat-mxc/sdma/iapi/src/iapiOS.c b/arch/arm/plat-mxc/sdma/iapi/src/iapiOS.c
index 3fe5062..643cab5 100644
--- a/arch/arm/plat-mxc/sdma/iapi/src/iapiOS.c
+++ b/arch/arm/plat-mxc/sdma/iapi/src/iapiOS.c
@@ -40,6 +40,9 @@
 /**
  * Function Section
  */
+#ifdef CONFIG_SDMA_IRAM
+void*(* iapi_iram_Malloc) (size_t size);
+#endif /*CONFIG_SDMA_IRAM*/
 
 void*(* iapi_Malloc) (size_t size);
 void (* iapi_Free) (void * ptr);
diff --git a/arch/arm/plat-mxc/sdma/sdma.c b/arch/arm/plat-mxc/sdma/sdma.c
index 36baf6d..72e6895 100644
--- a/arch/arm/plat-mxc/sdma/sdma.c
+++ b/arch/arm/plat-mxc/sdma/sdma.c
@@ -577,6 +577,11 @@ int mxc_request_dma(int *channel, const char *devicename)
 	/* Dynamic allocation */
 	if (*channel == 0) {
 		for (i = MAX_DMA_CHANNELS - 1; i > 0; i--) {
+#ifdef CONFIG_SDMA_IRAM
+			/*TODO:It will be removed after DPTC used UDMA interface */
+			if (i >= MXC_DMA_CHANNEL_IRAM)
+				continue;
+#endif				/*CONFIG_SDMA_IRAM */
 			if (!sdma_data[i].in_use) {
 				*channel = i;
 				break;
@@ -1039,6 +1044,9 @@ static void __init init_iapi_struct(void)
 	printk(KERN_INFO "Using SDMA I.API\n");
 
 	iapi_Malloc = &sdma_malloc;
+#ifdef CONFIG_SDMA_IRAM
+	iapi_iram_Malloc = &sdma_iram_malloc;
+#endif				/*CONFIG_SDMA_IRAM */
 
 	iapi_Free = &sdma_free;
 	iapi_Virt2Phys = (void *(*)(void *))&sdma_virt_to_phys;
diff --git a/arch/arm/plat-mxc/sdma/sdma_malloc.c b/arch/arm/plat-mxc/sdma/sdma_malloc.c
index 408b749..4a7714e 100644
--- a/arch/arm/plat-mxc/sdma/sdma_malloc.c
+++ b/arch/arm/plat-mxc/sdma/sdma_malloc.c
@@ -39,11 +39,41 @@
 #define DPRINTK(fmt, args...)
 #endif
 
+#ifdef CONFIG_SDMA_IRAM
+#define IRAM_VIRT_BASE  IRAM_BASE_ADDR_VIRT
+#define IRAM_PHYS_BASE  IRAM_BASE_ADDR
+#if (CONFIG_SDMA_IRAM_SIZE&0x3FF)
+#error  "IRAM size of SDMA should be multiple of 1Kbytes"
+#else
+#define IRAM_SDMA_SIZE  CONFIG_SDMA_IRAM_SIZE	/* 4K */
+#endif
+#define IRAM_UNIT_SIZE  512
+#define IRAM_POOL_SIZE  (IRAM_SDMA_SIZE/IRAM_UNIT_SIZE)
+
+#define IS_IRAM_VIRT(x) (((x)<IRAM_VIRT_BASE)?0:\
+                                (((x) - IRAM_VIRT_BASE)>IRAM_SDMA_SIZE)?0:1)
+
+#define IS_IRAM_PHYS(x) (((x)<IRAM_PHYS_BASE)?0:\
+                                (((x) - IRAM_PHYS_BASE)>IRAM_SDMA_SIZE)?0:1)
+#endif				/*CONFIG_SDMA_IRAM */
+
 /*!
  * Defines SDMA non-cacheable buffers pool
  */
 static struct dma_pool *pool;
 
+#ifdef CONFIG_SDMA_IRAM
+typedef struct iram_head_s {
+	struct list_head list;
+} iram_head_t;
+
+static spinlock_t iram_pool_lock = SPIN_LOCK_UNLOCKED;
+static struct list_head iram_free_list;
+static unsigned char iram_pool_flag[IRAM_POOL_SIZE];
+
+static void sdma_iram_free(void *buf);
+#endif				/*CONFIG_SDMA_IRAM */
+
 /*!
  * SDMA memory conversion hashing structure
  */
@@ -142,6 +172,16 @@ unsigned long sdma_virt_to_phys(void *buf)
 
 	DPRINTK("searching for vaddr 0x%p\n", buf);
 
+#ifdef CONFIG_SDMA_IRAM
+	if (IS_IRAM_VIRT((unsigned long)buf)) {
+		if ((unsigned long)buf & (IRAM_UNIT_SIZE - 1)) {
+			printk(KERN_WARNING "%s buffer offset = %ld\n",
+			       __FUNCTION__, (unsigned long)buf);
+		}
+		return (unsigned long)buf + IRAM_PHYS_BASE - IRAM_VIRT_BASE;
+	}
+#endif				/*CONFIG_SDMA_IRAM */
+
 	list_for_each_entry(p, &buf_map, node) {
 		if ((u32) p->virt == ((u32) buf & PAGE_MASK)) {
 			return p->phys | offset;
@@ -169,6 +209,16 @@ void *sdma_phys_to_virt(unsigned long buf)
 	u32 offset = buf & (~PAGE_MASK);
 	virt_phys_struct *p;
 
+#ifdef CONFIG_SDMA_IRAM
+	if (IS_IRAM_PHYS((unsigned long)buf)) {
+		if (buf & (IRAM_UNIT_SIZE - 1)) {
+			printk(KERN_WARNING "%s buffer offset = %ld\n",
+			       __FUNCTION__, (unsigned long)buf);
+		}
+		return (void *)buf + IRAM_VIRT_BASE - IRAM_PHYS_BASE;
+	}
+#endif				/*CONFIG_SDMA_IRAM */
+
 	list_for_each_entry(p, &buf_map, node) {
 		if (p->phys == (buf & PAGE_MASK)) {
 			return (void *)((u32) p->virt | offset);
@@ -221,15 +271,113 @@ void *sdma_malloc(size_t size)
  */
 void sdma_free(void *buf)
 {
+#ifdef CONFIG_SDMA_IRAM
+	if (IS_IRAM_VIRT((unsigned long)buf)) {
+		sdma_iram_free(buf);
+		return;
+	}
+#endif				/*CONFIG_SDMA_IRAM */
+
 	dma_pool_free(pool, buf, sdma_virt_to_phys(buf));
 	delete_entry(buf);
 }
 
+#ifdef CONFIG_SDMA_IRAM
+/*!
+ * Allocates uncacheable buffer from IRAM
+ */
+void *sdma_iram_malloc(size_t size)
+{
+	void *buf;
+	int index = -1;
+	unsigned long flags;
+	if (size > IRAM_UNIT_SIZE) {
+		printk(KERN_WARNING
+		       "size in sdma_iram_malloc is more than %d bytes\n",
+		       IRAM_UNIT_SIZE);
+	} else {
+		spin_lock_irqsave(&iram_pool_lock, flags);
+		if (!list_empty(&iram_free_list)) {
+			buf =
+			    list_entry(iram_free_list.next, iram_head_t, list);
+			list_del(iram_free_list.next);
+			index =
+			    ((unsigned long)buf -
+			     IRAM_VIRT_BASE) / IRAM_UNIT_SIZE;
+			if (index < 0 || index >= IRAM_POOL_SIZE) {
+				spin_unlock_irqrestore(&iram_pool_lock, flags);
+				printk(KERN_ERR "The iram pool has crashed\n");
+				return NULL;
+			}
+			if (iram_pool_flag[index]) {
+				spin_unlock_irqrestore(&iram_pool_lock, flags);
+				printk(KERN_WARNING
+				       "iram block %d  already has been allocated \n",
+				       index);
+			}
+			iram_pool_flag[index] = 1;
+		}
+		spin_unlock_irqrestore(&iram_pool_lock, flags);
+		if ((unsigned long)buf & (IRAM_UNIT_SIZE - 1)) {
+			printk(KERN_WARNING
+			       "the start address is not align of %d, buffer offset %ld\n",
+			       IRAM_UNIT_SIZE, (unsigned long)buf);
+
+			buf = (unsigned long)buf & (~(IRAM_UNIT_SIZE - 1));
+		}
+	}
+	return buf;
+}
+
+/*!
+ * Free uncacheable buffer into IRAM.
+ */
+static void sdma_iram_free(void *buf)
+{
+	iram_head_t *p;
+	int index;
+	unsigned long flags;
+	/* The check of parameter will be done in sdma_free */
+	index = ((unsigned long)buf - IRAM_VIRT_BASE) / IRAM_UNIT_SIZE;
+	spin_lock_irqsave(&iram_pool_lock, flags);
+	p = (iram_head_t *) ((unsigned long)buf & (~(IRAM_UNIT_SIZE - 1)));
+	list_add_tail(&(p->list), &iram_free_list);
+	if (iram_pool_flag[index]) {
+		iram_pool_flag[index] = 0;
+		spin_unlock_irqrestore(&iram_pool_lock, flags);
+	} else {
+		printk(KERN_WARNING
+		       "Free %p which IRAM block %d is already freed\n", buf,
+		       index);
+		spin_unlock_irqrestore(&iram_pool_lock, flags);
+	}
+}
+
+/*!
+ * Initialized the free list of IRAM.
+ */
+static void iram_pool_init(void)
+{
+	int i;
+	iram_head_t *p;
+	memset(iram_pool_flag, 0, IRAM_POOL_SIZE);
+	INIT_LIST_HEAD(&iram_free_list);
+	for (i = 0; i < IRAM_POOL_SIZE; i++) {
+		p = (iram_head_t *) (IRAM_VIRT_BASE + i * IRAM_UNIT_SIZE);
+		list_add_tail(&(p->list), &iram_free_list);
+	}
+}
+#endif				/*CONFIG_SDMA_IRAM */
+
 /*!
  * SDMA buffers pool initialization function
  */
 void __init init_sdma_pool(void)
 {
+#ifdef CONFIG_SDMA_IRAM
+	iram_pool_init();
+#endif				/*CONFIG_SDMA_IRAM */
+
 	pool = dma_pool_create("SDMA", NULL, SDMA_POOL_SIZE, 0, 0);
 
 	INIT_LIST_HEAD(&buf_map);
diff --git a/include/asm-arm/arch-mxc/mx31.h b/include/asm-arm/arch-mxc/mx31.h
index c772284..ae8e3c7 100644
--- a/include/asm-arm/arch-mxc/mx31.h
+++ b/include/asm-arm/arch-mxc/mx31.h
@@ -86,7 +86,7 @@
  * IRAM
  */
 #define IRAM_BASE_ADDR		0x1FFC0000	/* internal ram */
-#define IRAM_BASE_ADDR_VIRT	0xF8000000
+#define IRAM_BASE_ADDR_VIRT	0xF80C0000
 #define IRAM_SIZE		SZ_16K
 
 /*
@@ -158,6 +158,11 @@
 /*!
  * Defines for modules using static and dynamic DMA channels
  */
+
+#ifdef CONFIG_SDMA_IRAM
+#define MXC_DMA_CHANNEL_IRAM         30
+#endif				/*CONFIG_SDMA_IRAM */
+
 #define MXC_DMA_CHANNEL_UART1_RX  MXC_DMA_DYNAMIC_CHANNEL
 #define MXC_DMA_CHANNEL_UART1_TX  MXC_DMA_DYNAMIC_CHANNEL
 #define MXC_DMA_CHANNEL_UART2_RX  MXC_DMA_DYNAMIC_CHANNEL
@@ -170,10 +175,16 @@
 #define MXC_DMA_CHANNEL_UART5_TX  MXC_DMA_DYNAMIC_CHANNEL
 #define MXC_DMA_CHANNEL_MMC1  MXC_DMA_DYNAMIC_CHANNEL
 #define MXC_DMA_CHANNEL_MMC2  MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_SSI1_RX  MXC_DMA_DYNAMIC_CHANNEL
 #define MXC_DMA_CHANNEL_SSI1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_RX  MXC_DMA_DYNAMIC_CHANNEL
 #define MXC_DMA_CHANNEL_SSI2_RX  MXC_DMA_DYNAMIC_CHANNEL
+
+#ifdef CONFIG_SDMA_IRAM
+#define MXC_DMA_CHANNEL_SSI2_TX  (MXC_DMA_CHANNEL_IRAM + 1)
+#else				/*CONFIG_SDMA_IRAM */
 #define MXC_DMA_CHANNEL_SSI2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#endif				/*CONFIG_SDMA_IRAM */
+
 #define MXC_DMA_CHANNEL_FIR_RX  MXC_DMA_DYNAMIC_CHANNEL
 #define MXC_DMA_CHANNEL_FIR_TX  MXC_DMA_DYNAMIC_CHANNEL
 #define MXC_DMA_CHANNEL_CSPI1_RX  MXC_DMA_DYNAMIC_CHANNEL
diff --git a/include/asm-arm/arch-mxc/sdma.h b/include/asm-arm/arch-mxc/sdma.h
index a34ba6f..f259008 100644
--- a/include/asm-arm/arch-mxc/sdma.h
+++ b/include/asm-arm/arch-mxc/sdma.h
@@ -391,6 +391,16 @@ void mxc_dma_set_callback(int channel, dma_callback_t callback, void *arg);
  */
 void *sdma_malloc(size_t size);
 
+#ifdef CONFIG_SDMA_IRAM
+/*!
+ * Allocates uncachable buffer from IRAM..
+ *
+ * @param   size    size of allocated buffer
+ * @return  pointer to buffer
+ */
+void *sdma_iram_malloc(size_t size);
+#endif				/*CONFIG_SDMA_IRAM */
+
 /*!
  * Frees uncachable buffer. Uses hash table.
  */
diff --git a/include/asm-arm/pgtable.h b/include/asm-arm/pgtable.h
index 74ad08d..ea2510a 100644
--- a/include/asm-arm/pgtable.h
+++ b/include/asm-arm/pgtable.h
@@ -294,7 +294,7 @@ PTE_BIT_FUNC(mkyoung,   |= L_PTE_YOUNG);
 /* Extended configurations for inner writeback cacheable */
 #define pgprot_writealloc(prot) __pgprot((pgprot_val(prot) | L_PTE_EXTENDED) & ~L_PTE_CACHEABLE)
 #define pgprot_outer_wrthru(prot) __pgprot((pgprot_val(prot) | L_PTE_EXTENDED) & ~L_PTE_BUFFERABLE)
-#define pgprot_outer_noncached(prot) __pgprot(pgprot_val(prot) | L_PTE_EXTENDED & ~(L_PTE_CACHEABLE | L_PTE_BUFFERABLE))
+#define pgprot_outer_noncached(prot) __pgprot((pgprot_val(prot) | L_PTE_EXTENDED) & ~(L_PTE_CACHEABLE | L_PTE_BUFFERABLE))
 
 
 #define pmd_none(pmd)		(!pmd_val(pmd))
diff --git a/sound/arm/Kconfig b/sound/arm/Kconfig
index 473d0ef..abac8a9 100644
--- a/sound/arm/Kconfig
+++ b/sound/arm/Kconfig
@@ -68,4 +68,17 @@ config HEADSET_DETECT_ENABLE
         help
         Say Y here to enable Headset Detect Feature.
 
+config SND_MXC_PMIC_IRAM
+        bool "MXC PMIC sound system supports IRAM"
+        depends on SND_MXC_PMIC && SDMA_IRAM
+        default n
+        select SND_PCM
+        help
+          It will use IRAM as the DMA buffer of ALSA playback.
+
+
+
+
+
+
 endmenu
diff --git a/sound/arm/mxc-alsa-pmic.c b/sound/arm/mxc-alsa-pmic.c
index 221ae25..1f745f3 100644
--- a/sound/arm/mxc-alsa-pmic.c
+++ b/sound/arm/mxc-alsa-pmic.c
@@ -84,6 +84,38 @@
 #define MASK_1_TS_REC				0xfffffffe
 #define SOUND_CARD_NAME				"MXC"
 
+#ifdef CONFIG_SND_MXC_PMIC_IRAM
+#define MAX_IRAM_SIZE   (IRAM_SIZE - CONFIG_SDMA_IRAM_SIZE)
+#define DMA_IRAM_SIZE   (4*1024)
+#define ADMA_BASE_PADDR (IRAM_BASE_ADDR + CONFIG_SDMA_IRAM_SIZE)
+#define ADMA_BASE_VADDR (IRAM_BASE_ADDR_VIRT + CONFIG_SDMA_IRAM_SIZE)
+
+#if (MAX_IRAM_SIZE + CONFIG_SDMA_IRAM_SIZE) > IRAM_SIZE
+#error  "The IRAM size required has beyond the limitation of IC spec"
+#endif
+
+#if (MAX_IRAM_SIZE&(DMA_IRAM_SIZE-1))
+#error "The IRAM size for DMA ring buffer should be multiples of dma buffer size"
+#endif
+
+#endif				/* CONFIG_SND_MXC_PMIC_IRAM */
+
+#ifdef CONFIG_SND_MXC_PMIC_IRAM
+#define MAX_IRAM_SIZE   (IRAM_SIZE - CONFIG_SDMA_IRAM_SIZE)
+#define DMA_IRAM_SIZE   (4*1024)
+#define ADMA_BASE_PADDR (IRAM_BASE_ADDR + CONFIG_SDMA_IRAM_SIZE)
+#define ADMA_BASE_VADDR (IRAM_BASE_ADDR_VIRT + CONFIG_SDMA_IRAM_SIZE)
+
+#if (MAX_IRAM_SIZE + CONFIG_SDMA_IRAM_SIZE) > IRAM_SIZE
+#error  "The IRAM size required has beyond the limitation of IC spec"
+#endif
+
+#if (MAX_IRAM_SIZE&(DMA_IRAM_SIZE-1))
+#error "The IRAM size for DMA ring buffer should be multiples of dma buffer size"
+#endif
+
+#endif				/* CONFIG_SND_MXC_PMIC_IRAM */
+
 /*!
  * These defines enable DMA chaining for playback
  * and capture respectively.
@@ -408,6 +440,46 @@ static struct snd_pcm_hw_constraint_list hw_playback_rates_stereo = {
 	.mask = 0,
 };
 
+#ifdef CONFIG_SND_MXC_PMIC_IRAM
+static spinlock_t g_audio_iram_lock = SPIN_LOCK_UNLOCKED;
+static int g_audio_iram_en = 1;
+static int g_device_opened = 0;
+extern void flush_cache_range(struct vm_area_struct *vma, unsigned long start,
+			      unsigned long end);
+
+static inline int mxc_snd_enable_iram(int enable)
+{
+	int ret = -EBUSY;
+	unsigned long flags;
+	spin_lock_irqsave(&g_audio_iram_lock, flags);
+	if (!g_device_opened) {
+		g_audio_iram_en = (enable != 0);
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&g_audio_iram_lock, flags);
+	return ret;
+}
+
+static inline void mxc_snd_pcm_iram_get(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&g_audio_iram_lock, flags);
+	g_audio_iram_en++;
+	spin_unlock_irqrestore(&g_audio_iram_lock, flags);
+}
+
+static inline void mxc_snd_pcm_iram_put(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&g_audio_iram_lock, flags);
+	g_audio_iram_en--;
+	spin_unlock_irqrestore(&g_audio_iram_lock, flags);
+}
+
+struct snd_dma_buffer g_iram_dmab;
+
+#endif				/* CONFIG_SND_MXC_PMIC_IRAM */
+
 /*!
   * this structure represents the sample rates supported
   * by PMIC for playback operations on Voice codec.
@@ -1922,8 +1994,8 @@ static void audio_playback_dma(audio_stream_t * s)
 	int ret = 0;
 	mxc_dma_requestbuf_t dma_request;
 #ifdef CONFIG_SND_MXC_PLAYBACK_MIXING
-	unsigned int dma_size1 = 0, offset1;
-	mxc_dma_requestbuf_t dma_request1;
+	unsigned int dma_size_mix = 0, offset_mix;
+	mxc_dma_requestbuf_t dma_request_mix;
 	int ret1 = 0;
 #endif
 	int device;
@@ -1950,7 +2022,7 @@ static void audio_playback_dma(audio_stream_t * s)
 	if (stream_id == 2) {
 		memset(&dma_request, 0, sizeof(mxc_dma_requestbuf_t));
 	} else if (stream_id == 3) {
-		memset(&dma_request1, 0, sizeof(mxc_dma_requestbuf_t));
+		memset(&dma_request_mix, 0, sizeof(mxc_dma_requestbuf_t));
 	}
 #endif
 	if (s->active) {
@@ -1970,13 +2042,19 @@ static void audio_playback_dma(audio_stream_t * s)
 
 		offset = dma_size * s->period;
 		snd_assert(dma_size <= DMA_BUF_SIZE,);
+#ifdef CONFIG_SND_MXC_PMIC_IRAM
 
-		dma_request.src_addr = (dma_addr_t) (dma_map_single(NULL,
-								    runtime->
-								    dma_area +
-								    offset,
-								    dma_size,
-								    DMA_TO_DEVICE));
+		if (g_audio_iram_en && stream_id == 0) {
+			dma_request.src_addr = ADMA_BASE_PADDR + offset;
+		} else
+#endif				/*CONFIG_SND_MXC_PMIC_IRAM */
+		{
+
+			dma_request.src_addr =
+			    (dma_addr_t) (dma_map_single
+					  (NULL, runtime->dma_area + offset,
+					   dma_size, DMA_TO_DEVICE));
+		}
 		if (stream_id == 0) {
 			dma_request.dst_addr =
 			    (dma_addr_t) get_ssi_fifo_addr(s->ssi, 1);
@@ -1985,8 +2063,8 @@ static void audio_playback_dma(audio_stream_t * s)
 			    (dma_addr_t) get_ssi_fifo_addr(s->ssi, 1);
 		}
 		dma_request.num_of_bytes = dma_size;
-		pr_debug("MXC: Start DMA offset (%d) size (%d)\n", offset,
-			 runtime->dma_bytes);
+		pr_debug("MXC: Start DMA offset (%d) size (%d)\n",
+			 offset, runtime->dma_bytes);
 
 		mxc_dma_config(s->dma_wchannel, &dma_request, 1,
 			       MXC_DMA_MODE_WRITE);
@@ -2042,7 +2120,7 @@ static void audio_playback_dma(audio_stream_t * s)
 
 		} else if (stream_id == 3) {
 
-			dma_size1 =
+			dma_size_mix =
 			    frames_to_bytes(runtime, runtime->period_size);
 			pr_debug("s->period (%x) runtime->periods (%d)\n",
 				 s->period, runtime->periods);
@@ -2050,20 +2128,20 @@ static void audio_playback_dma(audio_stream_t * s)
 				 (unsigned int)runtime->period_size,
 				 runtime->dma_bytes);
 
-			offset1 = dma_size1 * s->period;
-			snd_assert(dma_size1 <= DMA_BUF_SIZE,);
-			dma_request1.src_addr =
+			offset_mix = dma_size_mix * s->period;
+			snd_assert(dma_size_mix <= DMA_BUF_SIZE,);
+			dma_request_mix.src_addr =
 			    (dma_addr_t) (dma_map_single
 					  (NULL, runtime->dma_area + offset1,
 					   dma_size1, DMA_TO_DEVICE));
-			dma_request1.dst_addr =
+			dma_request_mix.dst_addr =
 			    (dma_addr_t) get_ssi_fifo_addr(s->ssi, 1);
-			dma_request1.num_of_bytes = dma_size1;
+			dma_request_mix.num_of_bytes = dma_size_mix;
 
 			pr_debug("MXC: Start DMA offset (%d) size (%d)\n",
-				 offset1, runtime->dma_bytes);
+				 offset_mix, runtime->dma_bytes);
 
-			mxc_dma_config(s->dma_wchannel, &dma_request1, 1,
+			mxc_dma_config(s->dma_wchannel, &dma_request_mix, 1,
 				       MXC_DMA_MODE_WRITE);
 			ret1 = mxc_dma_enable(s->dma_wchannel);
 			ssi_transmit_enable(s->ssi, true);
@@ -2113,29 +2191,39 @@ static void audio_playback_dma(audio_stream_t * s)
 
 #ifndef CONFIG_SND_MXC_PLAYBACK_MIXING
 		offset = dma_size * s->period;
-		dma_request.src_addr = (dma_addr_t) (dma_map_single(NULL,
-								    runtime->
-								    dma_area +
-								    offset,
-								    dma_size,
-								    DMA_TO_DEVICE));
+#ifdef CONFIG_SND_MXC_PMIC_IRAM
+		if (g_audio_iram_en && stream_id == 0) {
+			dma_request.src_addr = ADMA_BASE_PADDR + offset;
+		} else
+#endif				/*CONFIG_SND_MXC_PMIC_IRAM */
+		{
+
+			dma_request.src_addr =
+			    (dma_addr_t) (dma_map_single
+					  (NULL, runtime->dma_area + offset,
+					   dma_size, DMA_TO_DEVICE));
+		}
 		mxc_dma_config(s->dma_wchannel, &dma_request, 1,
 			       MXC_DMA_MODE_WRITE);
 #else
 		if (stream_id == 3) {
-			offset1 = dma_size1 * s->period;
+			offset_mix = dma_size_mix * s->period;
 			dma_request.src_addr =
 			    (dma_addr_t) (dma_map_single
-					  (NULL, runtime->dma_area + offset1,
-					   dma_size1, DMA_TO_DEVICE));
-			mxc_dma_config(s->dma_wchannel, &dma_request1, 1,
+					  (NULL,
+					   runtime->dma_area + offset_mix,
+					   dma_size, DMA_TO_DEVICE));
+
+			mxc_dma_config(s->dma_wchannel, &dma_request_mix, 1,
 				       MXC_DMA_MODE_WRITE);
 		} else {
 			offset = dma_size * s->period;
 			dma_request.src_addr =
 			    (dma_addr_t) (dma_map_single
-					  (NULL, runtime->dma_area + offset,
+					  (NULL,
+					   runtime->dma_area + offset,
 					   dma_size, DMA_TO_DEVICE));
+
 			mxc_dma_config(s->dma_wchannel, &dma_request, 1,
 				       MXC_DMA_MODE_WRITE);
 		}
@@ -2765,30 +2853,37 @@ static int snd_card_mxc_audio_playback_open(struct snd_pcm_substream *substream)
 
 	else if (stream_id == 3) {
 		runtime->hw = snd_mxc_pmic_playback_mono;
+
 		if ((err = snd_pcm_hw_constraint_list(runtime, 0,
 						      SNDRV_PCM_HW_PARAM_RATE,
 						      &hw_playback_rates_mono))
 		    < 0)
 			return err;
 	}
+#ifdef CONFIG_SND_MXC_PMIC_IRAM
+	if (g_audio_iram_en && stream_id == 0) {
+		runtime->hw.buffer_bytes_max = MAX_IRAM_SIZE;
+		runtime->hw.period_bytes_max = DMA_IRAM_SIZE;
+	}
+#endif				/*CONFIG_SND_MXC_PMIC_IRAM */
 
 	if ((err = snd_pcm_hw_constraint_integer(runtime,
 						 SNDRV_PCM_HW_PARAM_PERIODS)) <
 	    0)
-		return err;
+		goto exit_err;
 	if (stream_id == 0) {
 		if ((err = snd_pcm_hw_constraint_list(runtime, 0,
 						      SNDRV_PCM_HW_PARAM_RATE,
 						      &hw_playback_rates_stereo))
 		    < 0)
-			return err;
+			goto exit_err;
 
 	} else if (stream_id == 2) {
 		if ((err = snd_pcm_hw_constraint_list(runtime, 0,
 						      SNDRV_PCM_HW_PARAM_RATE,
 						      &hw_playback_rates_mono))
 		    < 0)
-			return err;
+			goto exit_err;
 	}
 	msleep(10);
 
@@ -2797,9 +2892,15 @@ static int snd_card_mxc_audio_playback_open(struct snd_pcm_substream *substream)
 	     configure_write_channel(&mxc_audio->s[stream_id],
 				     audio_playback_dma_callback,
 				     stream_id)) < 0)
-		return err;
-
+		goto exit_err;
 	return 0;
+      exit_err:
+#ifdef CONFIG_SND_MXC_PMIC_IRAM
+	if (stream_id == 0)
+		mxc_snd_pcm_iram_put();
+#endif				/*CONFIG_SND_MXC_PMIC_IRAM */
+	return err;
+
 }
 
 /*!
@@ -2863,6 +2964,11 @@ static int snd_card_mxc_audio_playback_close(struct snd_pcm_substream
 	chip->s[stream_id].stream = NULL;
       End:
 	audio_mixer_control.mixing_active = 0;
+#ifdef CONFIG_SND_MXC_PMIC_IRAM
+	if (stream_id == 0)
+		mxc_snd_pcm_iram_put();
+#endif				/*CONFIG_SND_MXC_PMIC_IRAM */
+
 	return 0;
 }
 
@@ -2916,16 +3022,50 @@ static int snd_mxc_audio_hw_params(struct snd_pcm_substream *substream,
 				   struct snd_pcm_hw_params *hw_params)
 {
 	struct snd_pcm_runtime *runtime;
-	int ret;
+	int ret = 0, size;
+	int device, stream_id = -1;
+#ifdef CONFIG_SND_MXC_PMIC_IRAM
+	struct snd_dma_buffer *dmab;
+#endif				/*CONFIG_SND_MXC_PMIC_IRAM */
 
 	runtime = substream->runtime;
 	ret =
 	    snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 	if (ret < 0)
 		return ret;
+	size = params_buffer_bytes(hw_params);
+	device = substream->pcm->device;
+	if (device == 0)
+		stream_id = 0;
+	else if (device == 1)
+		stream_id = 2;
 
 	runtime->dma_addr = virt_to_phys(runtime->dma_area);
 
+#ifdef CONFIG_SND_MXC_PMIC_IRAM
+	if ((substream->stream == SNDRV_PCM_STREAM_PLAYBACK) && g_audio_iram_en
+	    && stream_id == 0) {
+		if (runtime->dma_buffer_p
+		    && (runtime->dma_buffer_p != &g_iram_dmab)) {
+			snd_pcm_lib_free_pages(substream);
+		}
+		dmab = &g_iram_dmab;
+		dmab->dev = substream->dma_buffer.dev;
+		dmab->area = (char *)ADMA_BASE_VADDR;
+		dmab->addr = ADMA_BASE_PADDR;
+		dmab->bytes = size;
+		snd_pcm_set_runtime_buffer(substream, dmab);
+		runtime->dma_bytes = size;
+	} else
+#endif				/* CONFIG_SND_MXC_PMIC_IRAM */
+	{
+		ret = snd_pcm_lib_malloc_pages(substream, size);
+		if (ret < 0)
+			return ret;
+
+		runtime->dma_addr = virt_to_phys(runtime->dma_area);
+	}
+
 	pr_debug("MXC: snd_mxc_audio_hw_params runtime->dma_addr 0x(%x)\n",
 		 (unsigned int)runtime->dma_addr);
 	pr_debug("MXC: snd_mxc_audio_hw_params runtime->dma_area 0x(%x)\n",
@@ -2945,7 +3085,16 @@ static int snd_mxc_audio_hw_params(struct snd_pcm_substream *substream,
   */
 static int snd_mxc_audio_hw_free(struct snd_pcm_substream *substream)
 {
-	return snd_pcm_lib_free_pages(substream);
+#ifdef  CONFIG_SND_MXC_PMIC_IRAM
+	if (substream->runtime->dma_buffer_p == &g_iram_dmab) {
+		snd_pcm_set_runtime_buffer(substream, NULL);
+		return 0;
+	} else
+#endif				/* CONFIG_SND_MXC_PMIC_IRAM */
+	{
+		return snd_pcm_lib_free_pages(substream);
+	}
+	return 0;
 }
 
 /*!
@@ -3063,6 +3212,180 @@ static int snd_card_mxc_audio_capture_open(struct snd_pcm_substream *substream)
 	return 0;
 }
 
+#ifdef CONFIG_SND_MXC_PMIC_IRAM
+static struct page *snd_mxc_audio_playback_nopage(struct vm_area_struct *area,
+						  unsigned long address,
+						  int *type)
+{
+	struct snd_pcm_substream *substream = area->vm_private_data;
+	struct snd_pcm_runtime *runtime;
+	unsigned long offset;
+	struct page *page;
+	void *vaddr;
+	size_t dma_bytes;
+
+	if (substream == NULL)
+		return NOPAGE_OOM;
+	runtime = substream->runtime;
+	if (g_audio_iram_en) {
+		return NOPAGE_SIGBUS;
+	}
+	offset = area->vm_pgoff << PAGE_SHIFT;
+	offset += address - area->vm_start;
+	snd_assert((offset % PAGE_SIZE) == 0, return NOPAGE_OOM);
+	dma_bytes = PAGE_ALIGN(runtime->dma_bytes);
+	if (offset > dma_bytes - PAGE_SIZE)
+		return NOPAGE_SIGBUS;
+	if (substream->ops->page) {
+		page = substream->ops->page(substream, offset);
+		if (!page)
+			return NOPAGE_OOM;
+	} else {
+		vaddr = runtime->dma_area + offset;
+		page = virt_to_page(vaddr);
+	}
+	get_page(page);
+	if (type)
+		*type = VM_FAULT_MINOR;
+	return page;
+}
+
+static struct vm_operations_struct snd_mxc_audio_playback_vm_ops = {
+	.open = snd_pcm_mmap_data_open,
+	.close = snd_pcm_mmap_data_close,
+	.nopage = snd_mxc_audio_playback_nopage,
+};
+
+#ifdef CONFIG_ARCH_MX3
+static inline int snd_mxc_set_pte_attr(struct mm_struct *mm,
+				       pmd_t * pmd,
+				       unsigned long addr, unsigned long end)
+{
+
+	pte_t *pte;
+	spinlock_t *ptl;
+	pte = pte_alloc_map_lock(mm, pmd, addr, &ptl);
+
+	if (!pte)
+		return -ENOMEM;
+	do {
+		BUG_ON(pte_none(*pte));	//The mapping is created. It should not be none.
+		*(pte - 512) |= 0x83;	//Directly modify to non-shared device
+	} while (pte++, addr += PAGE_SIZE, addr != end);
+
+	pte_unmap_unlock(pte - 1, ptl);
+
+	return 0;
+
+}
+
+static int snd_mxc_set_pmd_attr(struct mm_struct *mm,
+				pud_t * pud,
+				unsigned long addr, unsigned long end)
+{
+
+	pmd_t *pmd;
+	unsigned long next;
+	pmd = pmd_alloc(mm, pud, addr);
+
+	if (!pmd)
+		return -ENOMEM;
+	do {
+
+		next = pmd_addr_end(addr, end);
+		if (snd_mxc_set_pte_attr(mm, pmd, addr, next))
+			return -ENOMEM;
+
+	} while (pmd++, addr = next, addr != end);
+
+	return 0;
+
+}
+
+static int snd_mxc_set_pud_attr(struct mm_struct *mm,
+				pgd_t * pgd,
+				unsigned long addr, unsigned long end)
+{
+
+	pud_t *pud;
+	unsigned long next;
+	pud = pud_alloc(mm, pgd, addr);
+
+	if (!pud)
+		return -ENOMEM;
+	do {
+
+		next = pud_addr_end(addr, end);
+		if (snd_mxc_set_pmd_attr(mm, pud, addr, next))
+			return -ENOMEM;
+
+	} while (pud++, addr = next, addr != end);
+
+	return 0;
+
+}
+
+static inline int snd_mxc_set_pgd_attr(struct vm_area_struct *area)
+{
+
+	int ret = 0;
+	pgd_t *pgd;
+	struct mm_struct *mm = current->mm;
+	unsigned long next, addr = area->vm_start;
+
+	pgd = pgd_offset(mm, addr);
+	flush_cache_range(area, addr, area->vm_end);
+
+	do {
+		if (!pgd_present(*pgd))
+			return -1;
+
+		next = pgd_addr_end(addr, area->vm_end);
+		if ((ret = snd_mxc_set_pud_attr(mm, pgd, addr, next)))
+			break;
+
+	} while (pgd++, addr = next, addr != area->vm_end);
+
+	return ret;
+
+}
+
+#else
+#define snd_mxc_set_page_attr()  (0)
+#endif
+
+static int snd_mxc_audio_playback_mmap(struct snd_pcm_substream *substream,
+				       struct vm_area_struct *area)
+{
+	int ret = 0;
+	area->vm_ops = &snd_mxc_audio_playback_vm_ops;
+	area->vm_private_data = substream;
+	if (g_audio_iram_en) {
+		unsigned long off = area->vm_pgoff << PAGE_SHIFT;
+		unsigned long phys = ADMA_BASE_PADDR + off;
+		unsigned long size = area->vm_end - area->vm_start;
+		if (off + size > MAX_IRAM_SIZE) {
+			return -EINVAL;
+		}
+		area->vm_page_prot = pgprot_nonshareddev(area->vm_page_prot);
+		area->vm_flags |= VM_IO;
+		ret =
+		    remap_pfn_range(area, area->vm_start, phys >> PAGE_SHIFT,
+				    size, area->vm_page_prot);
+		if (ret == 0) {
+			ret = snd_mxc_set_pgd_attr(area);
+		}
+
+	} else {
+		area->vm_flags |= VM_RESERVED;
+	}
+	if (ret == 0)
+		area->vm_ops->open(area);
+	return ret;
+}
+
+#endif				/*CONFIG_SND_MXC_PMIC_IRAM */
+
 /*!
   * This structure is the list of operation that the driver
   * must provide for the capture interface
@@ -3091,6 +3414,9 @@ static struct snd_pcm_ops snd_card_mxc_audio_playback_ops = {
 	.prepare = snd_mxc_audio_playback_prepare,
 	.trigger = snd_mxc_audio_playback_trigger,
 	.pointer = snd_mxc_audio_playback_pointer,
+#ifdef CONFIG_SND_MXC_PMIC_IRAM
+	.mmap = snd_mxc_audio_playback_mmap,
+#endif				/*CONFIG_SND_MXC_PMIC_IRAM */
 };
 
 /*!
-- 
1.5.4.4

