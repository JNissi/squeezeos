From 280f7db8d13611ffbc61b42f9a4cd0b281627ca1 Mon Sep 17 00:00:00 2001
From: Xinyu Chen <muddog@muddog-desktop.(none)>
Date: Thu, 3 Apr 2008 10:44:39 +0800
Subject: [PATCH] ENGR00058723 MX35 IPU and LCD

Change IPU internal RAM param base address. Enable CLAA WVGA LCD

Signed-off-by: Xinyu Chen <xinyu.chen@freescale.com>
---
 arch/arm/configs/imx35_3stack_defconfig |   84 +++++++++++-
 arch/arm/mach-mx35/devices.c            |    2 +-
 arch/arm/mach-mx35/mx35_3stack.c        |   69 ++++++++++
 arch/arm/mach-mx35/mx35_3stack_gpio.c   |   41 ++++++
 drivers/mxc/ipu/ipu_ic.c                |   29 +++-
 drivers/video/mxc/Kconfig               |    4 +
 drivers/video/mxc/Makefile              |    1 +
 drivers/video/mxc/mxcfb_claa_wvga.c     |  219 +++++++++++++++++++++++++++++++
 8 files changed, 435 insertions(+), 14 deletions(-)

diff --git a/arch/arm/configs/imx35_3stack_defconfig b/arch/arm/configs/imx35_3stack_defconfig
index a20afa8..64b7ea9 100644
--- a/arch/arm/configs/imx35_3stack_defconfig
+++ b/arch/arm/configs/imx35_3stack_defconfig
@@ -660,7 +660,10 @@ CONFIG_INPUT=y
 #
 # Character devices
 #
-# CONFIG_VT is not set
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
 # CONFIG_FM_SI4702 is not set
 # CONFIG_MXC_MU is not set
@@ -783,7 +786,24 @@ CONFIG_SSB_POSSIBLE=y
 #
 # Multimedia devices
 #
-# CONFIG_VIDEO_DEV is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_PMS is not set
+# CONFIG_VIDEO_MXC_CAMERA is not set
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_IPU_OUTPUT=y
+# CONFIG_VIDEO_MXC_OPL is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_TUNER_3036 is not set
+# CONFIG_RADIO_ADAPTERS is not set
 # CONFIG_DVB_CORE is not set
 # CONFIG_DAB is not set
 
@@ -792,8 +812,43 @@ CONFIG_SSB_POSSIBLE=y
 #
 # CONFIG_VGASTATE is not set
 # CONFIG_VIDEO_OUTPUT_CONTROL is not set
-# CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_MXC=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+# CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL is not set
+CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL=y
+# CONFIG_FB_MXC_TVOUT is not set
+# CONFIG_FB_MXC_TVOUT_CH7024 is not set
+# CONFIG_FB_MXC_ASYNC_PANEL is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_CORGI is not set
+CONFIG_BACKLIGHT_MXC=y
+CONFIG_BACKLIGHT_MXC_IPU=y
 
 #
 # Display device support
@@ -801,6 +856,23 @@ CONFIG_SSB_POSSIBLE=y
 # CONFIG_DISPLAY_SUPPORT is not set
 
 #
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
 # Sound
 #
 # CONFIG_SOUND is not set
@@ -888,7 +960,9 @@ CONFIG_RTC_MXC=y
 #
 # MXC support drivers
 #
-# CONFIG_MXC_IPU is not set
+CONFIG_MXC_IPU=y
+CONFIG_MXC_IPU_V1=y
+CONFIG_MXC_IPU_PF=y
 
 #
 # MXC SSI support
diff --git a/arch/arm/mach-mx35/devices.c b/arch/arm/mach-mx35/devices.c
index 0af8ff0..6e64864 100644
--- a/arch/arm/mach-mx35/devices.c
+++ b/arch/arm/mach-mx35/devices.c
@@ -138,7 +138,7 @@ static inline void mxc_init_wdt(void)
 
 #if defined(CONFIG_MXC_IPU) || defined(CONFIG_MXC_IPU_MODULE)
 static struct mxc_ipu_config mxc_ipu_data = {
-	.rev = 1,
+	.rev = 2,
 };
 
 static struct resource ipu_resources[] = {
diff --git a/arch/arm/mach-mx35/mx35_3stack.c b/arch/arm/mach-mx35/mx35_3stack.c
index 8f81d41..202f56a 100644
--- a/arch/arm/mach-mx35/mx35_3stack.c
+++ b/arch/arm/mach-mx35/mx35_3stack.c
@@ -188,6 +188,71 @@ static inline void mxc_init_nand_mtd(void)
 }
 #endif
 
+static struct mxc_lcd_platform_data lcd_data = {
+	.io_reg = "LCD"
+};
+
+static struct platform_device lcd_dev = {
+	.name = "lcd_claa",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = (void *)&lcd_data,
+		},
+};
+
+static void mxc_init_lcd(void)
+{
+	platform_device_register(&lcd_dev);
+}
+
+#if defined(CONFIG_FB_MXC_SYNC_PANEL) || defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
+/* mxc lcd driver */
+static struct platform_device mxc_fb_device = {
+	.name = "mxc_sdc_fb",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.coherent_dma_mask = 0xFFFFFFFF,
+		},
+};
+
+static void mxc_init_fb(void)
+{
+	(void)platform_device_register(&mxc_fb_device);
+}
+#else
+static inline void mxc_init_fb(void)
+{
+}
+#endif
+
+#if defined(CONFIG_BACKLIGHT_MXC)
+static struct platform_device mxcbl_devices[] = {
+#if defined(CONFIG_BACKLIGHT_MXC_IPU) || defined(CONFIG_BACKLIGHT_MXC_IPU_MODULE)
+	{
+	 .name = "mxc_ipu_bl",
+	 .id = 0,
+	 .dev = {
+		 .platform_data = (void *)3,	/* DISP # for this backlight */
+		 },
+	 }
+#endif
+};
+
+static inline void mxc_init_bl(void)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(mxcbl_devices); i++) {
+		platform_device_register(&mxcbl_devices[i]);
+	}
+}
+#else
+static inline void mxc_init_bl(void)
+{
+}
+#endif
+
 static struct i2c_board_info mxc_i2c_board_info[] __initdata = {
 	{
 	 .driver_name = "mc9sdz60",
@@ -280,6 +345,10 @@ static void __init mxc_board_init(void)
 	mxc_init_nor_mtd();
 	mxc_init_nand_mtd();
 
+	mxc_init_lcd();
+	mxc_init_fb();
+	mxc_init_bl();
+
 	i2c_register_board_info(0, mxc_i2c_board_info,
 				ARRAY_SIZE(mxc_i2c_board_info));
 }
diff --git a/arch/arm/mach-mx35/mx35_3stack_gpio.c b/arch/arm/mach-mx35/mx35_3stack_gpio.c
index 084d622..bc98a09 100644
--- a/arch/arm/mach-mx35/mx35_3stack_gpio.c
+++ b/arch/arm/mach-mx35/mx35_3stack_gpio.c
@@ -337,3 +337,44 @@ void gpio_spi_inactive(int cspi_mod)
 }
 
 EXPORT_SYMBOL(gpio_spi_inactive);
+
+/*!
+ * Setup GPIO for LCD to be active
+ */
+void gpio_lcd_active(void)
+{
+	mxc_request_iomux(MX35_PIN_LD0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD3, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD4, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD5, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD6, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD7, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD8, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD9, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD10, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD11, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD12, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD13, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD14, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD15, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD16, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_LD17, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_D3_VSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_D3_HSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_D3_FPSHIFT, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_D3_DRDY, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_CONTRAST, MUX_CONFIG_FUNC);
+}
+
+EXPORT_SYMBOL(gpio_lcd_active);
+
+/*!
+ * Setup GPIO for LCD to be inactive
+ */
+void gpio_lcd_inactive(void)
+{
+}
+
+EXPORT_SYMBOL(gpio_lcd_inactive);
diff --git a/drivers/mxc/ipu/ipu_ic.c b/drivers/mxc/ipu/ipu_ic.c
index 83fc349..70f4108 100644
--- a/drivers/mxc/ipu/ipu_ic.c
+++ b/drivers/mxc/ipu/ipu_ic.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -35,6 +35,7 @@ enum {
 	IC_TASK_POST_PROCESSOR
 };
 
+extern int g_ipu_hw_rev;
 static void _init_csc(uint8_t ic_task, ipu_color_space_t in_format,
 		      ipu_color_space_t out_format);
 static bool _calc_resize_coeffs(uint32_t inSize, uint32_t outSize,
@@ -421,14 +422,26 @@ static void _init_csc(uint8_t ic_task, ipu_color_space_t in_format,
 	uint32_t param[2];
 	uint32_t address = 0;
 
-	if (ic_task == IC_TASK_VIEWFINDER) {
-		address = 0x5A5 << 3;
-	} else if (ic_task == IC_TASK_ENCODER) {
-		address = 0x2D1 << 3;
-	} else if (ic_task == IC_TASK_POST_PROCESSOR) {
-		address = 0x87C << 3;
+	if (g_ipu_hw_rev > 1) {
+		if (ic_task == IC_TASK_VIEWFINDER) {
+			address = 0x645 << 3;
+		} else if (ic_task == IC_TASK_ENCODER) {
+			address = 0x321 << 3;
+		} else if (ic_task == IC_TASK_POST_PROCESSOR) {
+			address = 0x96C << 3;
+		} else {
+			BUG();
+		}
 	} else {
-		BUG();
+		if (ic_task == IC_TASK_VIEWFINDER) {
+			address = 0x5a5 << 3;
+		} else if (ic_task == IC_TASK_ENCODER) {
+			address = 0x2d1 << 3;
+		} else if (ic_task == IC_TASK_POST_PROCESSOR) {
+			address = 0x87c << 3;
+		} else {
+			BUG();
+		}
 	}
 
 	if ((in_format == YCbCr) && (out_format == RGB)) {
diff --git a/drivers/video/mxc/Kconfig b/drivers/video/mxc/Kconfig
index aeaf4ba..70cbbca 100644
--- a/drivers/video/mxc/Kconfig
+++ b/drivers/video/mxc/Kconfig
@@ -28,6 +28,10 @@ config FB_MXC_TVOUT_TVE
 	depends on FB_MXC_SYNC_PANEL
 	depends on MXC_IPU_V3
 
+config FB_MXC_CLAA_WVGA_SYNC_PANEL
+	depends on FB_MXC_SYNC_PANEL
+	tristate "CLAA WVGA Panel"
+
 config FB_MXC_TVOUT
 	bool "FS453 TV Out Encoder"
 	depends on FB_MXC_SYNC_PANEL
diff --git a/drivers/video/mxc/Makefile b/drivers/video/mxc/Makefile
index 0799d99..4b70421 100644
--- a/drivers/video/mxc/Makefile
+++ b/drivers/video/mxc/Makefile
@@ -15,6 +15,7 @@ endif
 	obj-$(CONFIG_FB_MXC_SHARP_128_PANEL)    += mxcfb_sharp_128x128.o
 endif
 obj-$(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL)   += mxcfb_epson_vga.o
+obj-$(CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL)   += mxcfb_claa_wvga.o
 obj-$(CONFIG_FB_MXC_TVOUT_CH7024)           += ch7024.o
 obj-$(CONFIG_FB_MXC_TVOUT_TVE)              += tve.o
 
diff --git a/drivers/video/mxc/mxcfb_claa_wvga.c b/drivers/video/mxc/mxcfb_claa_wvga.c
new file mode 100644
index 0000000..9ce25d4
--- /dev/null
+++ b/drivers/video/mxc/mxcfb_claa_wvga.c
@@ -0,0 +1,219 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxcfb_claa_wvga.c
+ *
+ * @brief MXC Frame buffer driver for SDC
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/regulator.h>
+#include <asm/arch/mxcfb.h>
+
+static void lcd_poweron(void);
+static void lcd_poweroff(void);
+
+static struct platform_device *plcd_dev;
+static struct regulator *io_reg;
+static int lcd_on;
+
+static struct fb_videomode video_modes[] = {
+	{
+	 /* 800x480 @ 55 Hz , pixel clk @ 25MHz */
+	 "CLAA-WVGA", 55, 800, 480, 40000, 80, 0, 10, 0, 20, 10,
+	 FB_SYNC_OE_ACT_HIGH,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+};
+
+static void lcd_init_fb(struct fb_info *info)
+{
+	struct fb_var_screeninfo var;
+
+	memset(&var, 0, sizeof(var));
+
+	fb_videomode_to_var(&var, &video_modes[0]);
+
+	var.activate = FB_ACTIVATE_ALL;
+	var.yres_virtual = var.yres * 2;
+
+	acquire_console_sem();
+	info->flags |= FBINFO_MISC_USEREVENT;
+	fb_set_var(info, &var);
+	info->flags &= ~FBINFO_MISC_USEREVENT;
+	release_console_sem();
+}
+
+static int lcd_fb_event(struct notifier_block *nb, unsigned long val, void *v)
+{
+	struct fb_event *event = v;
+
+	if (strcmp(event->info->fix.id, "DISP3 BG")) {
+		return 0;
+	}
+
+	switch (val) {
+	case FB_EVENT_FB_REGISTERED:
+		lcd_init_fb(event->info);
+		lcd_poweron();
+		break;
+	case FB_EVENT_BLANK:
+		if ((event->info->var.xres != 800) ||
+		    (event->info->var.yres != 480)) {
+			break;
+		}
+		if (*((int *)event->data) == FB_BLANK_UNBLANK) {
+			lcd_poweron();
+		} else {
+			lcd_poweroff();
+		}
+		break;
+	}
+	return 0;
+}
+
+static struct notifier_block nb = {
+	.notifier_call = lcd_fb_event,
+};
+
+/*!
+ * This function is called whenever the SPI slave device is detected.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return 	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int __devinit lcd_probe(struct platform_device *pdev)
+{
+	int i;
+	struct mxc_lcd_platform_data *plat = pdev->dev.platform_data;
+
+	if (plat) {
+		if (plat->reset)
+			plat->reset();
+
+		io_reg = regulator_get(&pdev->dev, plat->io_reg);
+		regulator_enable(io_reg);
+	}
+
+	for (i = 0; i < num_registered_fb; i++) {
+		if (strcmp(registered_fb[i]->fix.id, "DISP3 BG") == 0) {
+			lcd_init_fb(registered_fb[i]);
+			fb_show_logo(registered_fb[i], 0);
+			lcd_poweron();
+		} else if (strcmp(registered_fb[i]->fix.id, "DISP3 FG") == 0) {
+			lcd_init_fb(registered_fb[i]);
+		}
+	}
+
+	fb_register_client(&nb);
+
+	plcd_dev = pdev;
+
+	return 0;
+}
+
+static int __devexit lcd_remove(struct platform_device *pdev)
+{
+	fb_unregister_client(&nb);
+	lcd_poweroff();
+	regulator_put(io_reg, &pdev->dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lcd_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int lcd_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define lcd_suspend NULL
+#define lcd_resume NULL
+#endif
+
+/*!
+ * platform driver structure for CLAA WVGA
+ */
+static struct platform_driver lcd_driver = {
+	.driver = {
+		   .name = "lcd_claa"},
+	.probe = lcd_probe,
+	.remove = __devexit_p(lcd_remove),
+	.suspend = lcd_suspend,
+	.resume = lcd_resume,
+};
+
+/*
+ * Send Power On commands to L4F00242T03
+ *
+ */
+static void lcd_poweron(void)
+{
+	if (lcd_on)
+		return;
+
+	dev_dbg(&plcd_dev->dev, "turning on LCD\n");
+	regulator_enable(io_reg);
+	lcd_on = 1;
+}
+
+/*
+ * Send Power Off commands to L4F00242T03
+ *
+ */
+static void lcd_poweroff(void)
+{
+	lcd_on = 0;
+	dev_dbg(&plcd_dev->dev, "turning off LCD\n");
+	regulator_disable(io_reg);
+}
+
+static int __init claa_lcd_init(void)
+{
+	return platform_driver_register(&lcd_driver);
+}
+
+static void __exit claa_lcd_exit(void)
+{
+	platform_driver_unregister(&lcd_driver);
+}
+
+module_init(claa_lcd_init);
+module_exit(claa_lcd_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("CLAA WVGA LCD init driver");
+MODULE_LICENSE("GPL");
-- 
1.5.4.4

