From 9bf06e211f31b13b46c678ff838426b9cb638e96 Mon Sep 17 00:00:00 2001
From: Wallace Wang <r59996@freescale.com>
Date: Sun, 18 May 2008 15:22:43 +0800
Subject: [PATCH] ENGR00058756 MX35: ALSA sound driver

Soc - machine layer and platform layer

Signed-off-by: Wallace Wang <r59996@freescale.com>
---
 arch/arm/configs/imx35_3stack_defconfig |   70 ++++++-
 arch/arm/mach-mx35/clock.c              |    4 +-
 arch/arm/mach-mx35/devices.c            |   23 ++
 arch/arm/mach-mx35/dma.c                |  367 ++++++++++++++++++++++++++++
 arch/arm/mach-mx35/mx35_3stack_gpio.c   |   23 ++
 arch/arm/mach-mx35/mx35_pins.h          |    4 +-
 include/asm-arm/arch-mxc/mx35.h         |   11 +
 include/asm-arm/arch-mxc/mxc.h          |    1 +
 sound/soc/imx/Kconfig                   |    7 +
 sound/soc/imx/Makefile                  |    2 +
 sound/soc/imx/imx-3stack-ak4647.c       |  394 +++++++++++++++++++++++++++++++
 11 files changed, 900 insertions(+), 6 deletions(-)

diff --git a/arch/arm/configs/imx35_3stack_defconfig b/arch/arm/configs/imx35_3stack_defconfig
index 5e8b775..eb64395 100644
--- a/arch/arm/configs/imx35_3stack_defconfig
+++ b/arch/arm/configs/imx35_3stack_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.24
-# Tue May  6 21:11:57 2008
+# Sun May 18 15:25:43 2008
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -952,7 +952,72 @@ CONFIG_LOGO_LINUX_CLUT224=y
 #
 # Sound
 #
-# CONFIG_SOUND is not set
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+# CONFIG_SND_MXC_SPDIF is not set
+
+#
+# SPI devices
+#
+
+#
+# USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+
+#
+# PCMCIA devices
+#
+# CONFIG_SND_VXPOCKET is not set
+# CONFIG_SND_PDAUDIOCF is not set
+
+#
+# System on Chip audio support
+#
+CONFIG_SND_SOC=y
+
+#
+# SoC Audio support for SuperH
+#
+CONFIG_SND_MXC_SOC=y
+CONFIG_SND_MXC_SOC_SSI=y
+# CONFIG_SND_MXC_SOC_IRAM is not set
+# CONFIG_SND_SOC_IMX_3STACK_WM8350 is not set
+CONFIG_SND_SOC_IMX_3STACK_AK4647=y
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
 CONFIG_HID_SUPPORT=y
 CONFIG_HID=m
 # CONFIG_HID_DEBUG is not set
@@ -1113,6 +1178,7 @@ CONFIG_MMC_BLOCK_BOUNCE=y
 # CONFIG_MMC_SPI is not set
 # CONFIG_MMC_MXC is not set
 CONFIG_MMC_IMX_ESDHCI=m
+# CONFIG_MMC_IMX_ESDHCI_PIO_MODE is not set
 # CONFIG_NEW_LEDS is not set
 CONFIG_RTC_LIB=y
 CONFIG_RTC_CLASS=y
diff --git a/arch/arm/mach-mx35/clock.c b/arch/arm/mach-mx35/clock.c
index 6860f3a..bda0212 100644
--- a/arch/arm/mach-mx35/clock.c
+++ b/arch/arm/mach-mx35/clock.c
@@ -1466,8 +1466,8 @@ int __init mxc_clocks_init(void)
 	__raw_writel(MXC_CCM_CGR1_GPIO1_MASK | MXC_CCM_CGR1_GPIO2_MASK |
 		     MXC_CCM_CGR1_GPIO3_MASK | MXC_CCM_CGR1_GPT_MASK |
 		     MXC_CCM_CGR1_IOMUXC_MASK, MXC_CCM_CGR1);
-	__raw_writel(MXC_CCM_CGR2_MAX_MASK | MXC_CCM_CGR2_SPBA_MASK,
-		     MXC_CCM_CGR2_AUDMUX_MASK | MXC_CCM_CGR2_MAX_ENABLE |
+	__raw_writel(MXC_CCM_CGR2_MAX_MASK | MXC_CCM_CGR2_SPBA_MASK |
+		     MXC_CCM_CGR2_AUDMUX_MASK | MXC_CCM_CGR2_MAX_ENABLE,
 		     MXC_CCM_CGR2);
 	__raw_writel(MXC_CCM_CGR3_IIM_MASK, MXC_CCM_CGR3);
 
diff --git a/arch/arm/mach-mx35/devices.c b/arch/arm/mach-mx35/devices.c
index 6b7cd06..a49f3ca 100644
--- a/arch/arm/mach-mx35/devices.c
+++ b/arch/arm/mach-mx35/devices.c
@@ -24,6 +24,7 @@
 
 #include "iomux.h"
 #include "sdma_script_code.h"
+#include "board-mx35_3stack.h"
 
 extern void gpio_spdif_active(void);
 
@@ -472,6 +473,27 @@ static inline void mxc_init_spdif(void)
 	platform_device_register(&mxc_alsa_spdif_device);
 }
 
+static struct mxc_audio_platform_data mxc_audio_data;
+
+static struct platform_device mxc_alsa_device = {
+	.name = "ak4647-imx-3stack-audio",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_audio_data,
+		},
+
+};
+
+static void mxc_init_audio(void)
+{
+	mxc_audio_data.ssi_num = 1;
+	mxc_audio_data.src_port = 1;
+	mxc_audio_data.ext_port = 4;
+	mxc_audio_data.intr_id_hp = MXC_PSEUDO_IRQ_HEADPHONE;
+	platform_device_register(&mxc_alsa_device);
+}
+
 static int __init mxc_init_devices(void)
 {
 	mxc_init_wdt();
@@ -481,6 +503,7 @@ static int __init mxc_init_devices(void)
 	mxc_init_rtc();
 	mxc_init_dma();
 	mxc_init_spdif();
+	mxc_init_audio();
 
 	/* SPBA configuration for SSI2 - SDMA and MCU are set */
 	spba_take_ownership(SPBA_SSI2, SPBA_MASTER_C | SPBA_MASTER_A);
diff --git a/arch/arm/mach-mx35/dma.c b/arch/arm/mach-mx35/dma.c
index 0a850a0..a4f81ab 100644
--- a/arch/arm/mach-mx35/dma.c
+++ b/arch/arm/mach-mx35/dma.c
@@ -22,6 +22,13 @@
 #define MXC_SPDIF_TX_REG          0x2C
 #define MXC_SPDIF_RX_REG          0x14
 
+#define MXC_SSI_TX0_REG           0x0
+#define MXC_SSI_TX1_REG           0x4
+#define MXC_SSI_RX0_REG           0x8
+#define MXC_SSI_RX1_REG           0xC
+#define MXC_SSI_TXFIFO_WML        0x4
+#define MXC_SSI_RXFIFO_WML        0x6
+
 struct mxc_sdma_info_entry_s {
 	mxc_dma_device_t device;
 	mxc_sdma_channel_params_t *chnl_info;
@@ -164,6 +171,342 @@ static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
 	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
 };
 
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
 static struct mxc_sdma_info_entry_s mxc_sdma_active_dma_info[] = {
 	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
 	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
@@ -174,6 +517,30 @@ static struct mxc_sdma_info_entry_s mxc_sdma_active_dma_info[] = {
 	{MXC_DMA_SPDIF_16BIT_TX, &mxc_sdma_spdif_16bit_tx_params},
 	{MXC_DMA_SPDIF_32BIT_TX, &mxc_sdma_spdif_32bit_tx_params},
 	{MXC_DMA_SPDIF_32BIT_RX, &mxc_sdma_spdif_32bit_rx_params},
+	{MXC_DMA_SSI1_8BIT_RX0, &mxc_sdma_ssi1_8bit_rx0_params},
+	{MXC_DMA_SSI1_8BIT_TX0, &mxc_sdma_ssi1_8bit_tx0_params},
+	{MXC_DMA_SSI1_16BIT_RX0, &mxc_sdma_ssi1_16bit_rx0_params},
+	{MXC_DMA_SSI1_16BIT_TX0, &mxc_sdma_ssi1_16bit_tx0_params},
+	{MXC_DMA_SSI1_24BIT_RX0, &mxc_sdma_ssi1_24bit_rx0_params},
+	{MXC_DMA_SSI1_24BIT_TX0, &mxc_sdma_ssi1_24bit_tx0_params},
+	{MXC_DMA_SSI1_8BIT_RX1, &mxc_sdma_ssi1_8bit_rx1_params},
+	{MXC_DMA_SSI1_8BIT_TX1, &mxc_sdma_ssi1_8bit_tx1_params},
+	{MXC_DMA_SSI1_16BIT_RX1, &mxc_sdma_ssi1_16bit_rx1_params},
+	{MXC_DMA_SSI1_16BIT_TX1, &mxc_sdma_ssi1_16bit_tx1_params},
+	{MXC_DMA_SSI1_24BIT_RX1, &mxc_sdma_ssi1_24bit_rx1_params},
+	{MXC_DMA_SSI1_24BIT_TX1, &mxc_sdma_ssi1_24bit_tx1_params},
+	{MXC_DMA_SSI2_8BIT_RX0, &mxc_sdma_ssi2_8bit_rx0_params},
+	{MXC_DMA_SSI2_8BIT_TX0, &mxc_sdma_ssi2_8bit_tx0_params},
+	{MXC_DMA_SSI2_16BIT_RX0, &mxc_sdma_ssi2_16bit_rx0_params},
+	{MXC_DMA_SSI2_16BIT_TX0, &mxc_sdma_ssi2_16bit_tx0_params},
+	{MXC_DMA_SSI2_24BIT_RX0, &mxc_sdma_ssi2_24bit_rx0_params},
+	{MXC_DMA_SSI2_24BIT_TX0, &mxc_sdma_ssi2_24bit_tx0_params},
+	{MXC_DMA_SSI2_8BIT_RX1, &mxc_sdma_ssi2_8bit_rx1_params},
+	{MXC_DMA_SSI2_8BIT_TX1, &mxc_sdma_ssi2_8bit_tx1_params},
+	{MXC_DMA_SSI2_16BIT_RX1, &mxc_sdma_ssi2_16bit_rx1_params},
+	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
+	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
+	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
 	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
 };
 
diff --git a/arch/arm/mach-mx35/mx35_3stack_gpio.c b/arch/arm/mach-mx35/mx35_3stack_gpio.c
index 45e6c3b..0797abe 100644
--- a/arch/arm/mach-mx35/mx35_3stack_gpio.c
+++ b/arch/arm/mach-mx35/mx35_3stack_gpio.c
@@ -733,3 +733,26 @@ void gpio_spdif_inactive(void)
 }
 
 EXPORT_SYMBOL(gpio_spdif_inactive);
+
+/*!
+ * This function activates DAM ports 3 to enable
+ * audio I/O.
+ */
+void gpio_activate_audio_ports(void)
+{
+	unsigned int pad_val;
+
+	mxc_request_iomux(MX35_PIN_STXD4, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_SRXD4, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_SCK4, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX35_PIN_STXFS4, MUX_CONFIG_FUNC);
+
+	pad_val = PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PU |
+	    PAD_CTL_PUE_PUD;
+	mxc_iomux_set_pad(MX35_PIN_STXD4, pad_val);
+	mxc_iomux_set_pad(MX35_PIN_SRXD4, pad_val);
+	mxc_iomux_set_pad(MX35_PIN_SCK4, pad_val);
+	mxc_iomux_set_pad(MX35_PIN_STXFS4, pad_val);
+}
+
+EXPORT_SYMBOL(gpio_activate_audio_ports);
diff --git a/arch/arm/mach-mx35/mx35_pins.h b/arch/arm/mach-mx35/mx35_pins.h
index f28673a..90fcb84 100644
--- a/arch/arm/mach-mx35/mx35_pins.h
+++ b/arch/arm/mach-mx35/mx35_pins.h
@@ -190,11 +190,11 @@ enum iomux_pins {
 	MX35_PIN_STXD4 = _MXC_BUILD_GPIO_PIN(1, 28, 0x120, 0x564),
 	MX35_PIN_SRXD4 = _MXC_BUILD_GPIO_PIN(1, 29, 0x124, 0x568),
 	MX35_PIN_SCK4 = _MXC_BUILD_GPIO_PIN(1, 30, 0x128, 0x56C),
-	MX35_PIN_SXFS4 = _MXC_BUILD_GPIO_PIN(1, 31, 0x12C, 0x570),
+	MX35_PIN_STXFS4 = _MXC_BUILD_GPIO_PIN(1, 31, 0x12C, 0x570),
 	MX35_PIN_STXD5 = _MXC_BUILD_GPIO_PIN(0, 0, 0x130, 0x574),
 	MX35_PIN_SRXD5 = _MXC_BUILD_GPIO_PIN(0, 1, 0x134, 0x578),
 	MX35_PIN_SCK5 = _MXC_BUILD_GPIO_PIN(0, 2, 0x138, 0x57C),
-	MX35_PIN_SXFS5 = _MXC_BUILD_GPIO_PIN(0, 3, 0x13C, 0x580),
+	MX35_PIN_STXFS5 = _MXC_BUILD_GPIO_PIN(0, 3, 0x13C, 0x580),
 
 	MX35_PIN_SCKR = _MXC_BUILD_GPIO_PIN(0, 4, 0x140, 0x584),
 	MX35_PIN_FSR = _MXC_BUILD_GPIO_PIN(0, 5, 0x144, 0x588),
diff --git a/include/asm-arm/arch-mxc/mx35.h b/include/asm-arm/arch-mxc/mx35.h
index fa14d85..6ee1e02 100644
--- a/include/asm-arm/arch-mxc/mx35.h
+++ b/include/asm-arm/arch-mxc/mx35.h
@@ -70,6 +70,17 @@
 #define IRAM_BASE_ADDR_VIRT	0xF8400000
 #define IRAM_SIZE		SZ_128K
 
+#ifndef CONFIG_SDMA_IRAM
+#define CONFIG_SDMA_IRAM_SIZE 0
+#endif
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+#define SND_RAM_SIZE 0x3000
+#else
+#define SND_RAM_SIZE 0
+#endif
+
+#define SND_RAM_BASE_ADDR       (IRAM_BASE_ADDR + CONFIG_SDMA_IRAM_SIZE)
+
 /*
  * L2CC
  */
diff --git a/include/asm-arm/arch-mxc/mxc.h b/include/asm-arm/arch-mxc/mxc.h
index e93ca53..7752418 100644
--- a/include/asm-arm/arch-mxc/mxc.h
+++ b/include/asm-arm/arch-mxc/mxc.h
@@ -82,6 +82,7 @@ struct mxc_audio_platform_data {
 	int ssi_num;
 	int src_port;
 	int ext_port;
+	int intr_id_hp;
 	struct clk *ssi_clk[2];
 	char *regulator1;
 	char *regulator2;
diff --git a/sound/soc/imx/Kconfig b/sound/soc/imx/Kconfig
index f1b0f02..954d7a8 100644
--- a/sound/soc/imx/Kconfig
+++ b/sound/soc/imx/Kconfig
@@ -24,3 +24,10 @@ config SND_SOC_IMX_3STACK_WM8350
    Say Y if you want to add support for SoC audio on IMX 3STACK
    with the WM8350.
 
+config SND_SOC_IMX_3STACK_AK4647
+ tristate "SoC Audio support for IMX - AK4647"
+ select SND_MXC_SOC_SSI
+ select SND_SOC_AK4647
+ help
+   Say Y if you want to add support for SoC audio on IMX 3STACK
+   with the AK4647.
diff --git a/sound/soc/imx/Makefile b/sound/soc/imx/Makefile
index a0305bf..c9a7735 100644
--- a/sound/soc/imx/Makefile
+++ b/sound/soc/imx/Makefile
@@ -8,3 +8,5 @@ obj-$(CONFIG_SND_MXC_SOC_SSI) += snd-soc-imx-ssi.o
 # i.MX Machine Support
 snd-soc-imx-3stack-wm8350-objs := imx-3stack-wm8350.o
 obj-$(CONFIG_SND_SOC_IMX_3STACK_WM8350) += snd-soc-imx-3stack-wm8350.o
+snd-soc-imx-3stack-ak4647-objs := imx-3stack-ak4647.o
+obj-$(CONFIG_SND_SOC_IMX_3STACK_AK4647) += snd-soc-imx-3stack-ak4647.o
diff --git a/sound/soc/imx/imx-3stack-ak4647.c b/sound/soc/imx/imx-3stack-ak4647.c
new file mode 100644
index 0000000..bb93817
--- /dev/null
+++ b/sound/soc/imx/imx-3stack-ak4647.c
@@ -0,0 +1,394 @@
+/*
+ * imx-3stack-ak4647.c  --  SoC audio for imx_3stack
+ *
+ * Copyright 2008 Freescale  Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mxc.h>
+#include <asm/arch/pmic_external.h>
+
+#include "imx-pcm.h"
+#include "imx-ssi.h"
+
+#define AK4647_SSI_MASTER	1
+
+extern void gpio_activate_audio_ports(void);
+extern const char ak4647_codec[SND_SOC_CODEC_NAME_SIZE];
+extern const char ak4647_hifi_dai[SND_SOC_CODEC_NAME_SIZE];
+
+static void headphone_detect_handler(struct work_struct *work);
+static DECLARE_WORK(hp_event, headphone_detect_handler);
+static struct snd_soc_machine *imx_3stack_mach;
+
+static void imx_3stack_init_dam(int ssi_port, int dai_port)
+{
+	/* AK4647 uses SSI1 or SSI2 via AUDMUX port dai_port for audio */
+
+	/* reset port ssi_port & dai_port */
+	DAM_PTCR(ssi_port) = 0;
+	DAM_PDCR(ssi_port) = 0;
+	DAM_PTCR(dai_port) = 0;
+	DAM_PDCR(dai_port) = 0;
+
+	/* set to synchronous */
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_SYN;
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_SYN;
+
+#if AK4647_SSI_MASTER
+	/* set Rx sources ssi_port <--> dai_port */
+	DAM_PDCR(ssi_port) |= AUDMUX_PDCR_RXDSEL(dai_port);
+	DAM_PDCR(dai_port) |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+	/* set Tx frame direction and source  dai_port--> ssi_port output */
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TFSDIR;
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, dai_port);
+
+	/* set Tx Clock direction and source dai_port--> ssi_port output */
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TCLKDIR;
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, dai_port);
+#else
+	/* set Rx sources ssi_port <--> dai_port */
+	DAM_PDCR(ssi_port) |= AUDMUX_PDCR_RXDSEL(dai_port);
+	DAM_PDCR(dai_port) |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+	/* set Tx frame direction and source  ssi_port --> dai_port output */
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TFSDIR;
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, ssi_port);
+
+	/* set Tx Clock direction and source ssi_port--> dai_port output */
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TCLKDIR;
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, ssi_port);
+#endif
+}
+
+static int imx_3stack_hifi_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_link *pcm_link = substream->private_data;
+	struct mxc_audio_platform_data *dev_data = pcm_link->private_data;
+	struct snd_soc_dai *cpu_dai = pcm_link->cpu_dai;
+	struct snd_soc_dai *codec_dai = pcm_link->codec_dai;
+	unsigned int channels = params_channels(params);
+	unsigned int rate = params_rate(params);
+	u32 dai_format;
+
+	imx_3stack_init_dam(dev_data->src_port, dev_data->ext_port);
+
+#if AK4647_SSI_MASTER
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	    SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_SYNC;
+#else
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	    SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_SYNC;
+#endif
+	if (channels == 2)
+		dai_format |= SND_SOC_DAIFMT_TDM;
+
+	/* set codec DAI configuration */
+	codec_dai->ops->set_fmt(codec_dai, dai_format);
+
+	/* set cpu DAI configuration */
+	cpu_dai->ops->set_fmt(cpu_dai, dai_format);
+
+	/* set i.MX active slot mask */
+	cpu_dai->ops->set_tdm_slot(cpu_dai,
+				   channels == 1 ? 0xfffffffe : 0xfffffffc,
+				   channels);
+
+	/* set the SSI system clock as input (unused) */
+	cpu_dai->ops->set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0, SND_SOC_CLOCK_IN);
+
+	codec_dai->ops->set_sysclk(codec_dai, 0, rate, 0);
+
+	/* set codec BCLK division for sample rate */
+	codec_dai->ops->set_clkdiv(codec_dai, 0, 0);
+
+	return 0;
+}
+
+/*
+ * imx_3stack ak4647 HiFi DAI opserations.
+ */
+static struct snd_soc_ops imx_3stack_hifi_ops = {
+	.hw_params = imx_3stack_hifi_hw_params,
+};
+
+static int hifi_pcm_new(struct snd_soc_pcm_link *pcm_link)
+{
+	int ret;
+	pcm_link->audio_ops = &imx_3stack_hifi_ops;
+	ret = snd_soc_pcm_new(pcm_link, 1, 1);
+	if (ret < 0) {
+		pr_err("%s: Failed to create hifi pcm\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+struct snd_soc_pcm_link_ops hifi_pcm = {
+	.new = hifi_pcm_new,
+};
+
+/* imx_3stack machine dapm widgets */
+static const struct snd_soc_dapm_widget imx_3stack_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("Mic1 Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+	SND_SOC_DAPM_LINE("Line Out Jack", NULL),
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+};
+
+/* example machine audio_mapnections */
+static const char *audio_map[][3] = {
+
+	/* mic is connected to mic1 - with bias */
+	{"LIN2", NULL, "Mic1 Jack"},
+	{"Mic Bias", NULL, "Mic1 Jack"},
+
+	/* Line in jack */
+	{"LIN1", NULL, "Line In Jack"},
+	{"RIN1", NULL, "Line In Jack"},
+
+	/* Headphone jack */
+	{"Headphone Jack", NULL, "HPL"},
+	{"Headphone Jack", NULL, "HPR"},
+
+	/* Line out jack */
+	{"Line Out Jack", NULL, "ROUT"},
+	{"Line Out Jack", NULL, "LOUT"},
+
+	{NULL, NULL, NULL},
+
+};
+
+static void headphone_detect_handler(struct work_struct *work)
+{
+
+	unsigned int value;
+
+	pmic_gpio_get_designation_bit_val(0, &value);
+	if (value == 0) {
+		snd_soc_dapm_set_endpoint(imx_3stack_mach, "Headphone Jack", 0);
+		snd_soc_dapm_set_endpoint(imx_3stack_mach, "Line Out Jack", 1);
+		pmic_gpio_set_bit_val(MCU_GPIO_REG_GPIO_CONTROL_1, 0, 1);
+	} else {
+		snd_soc_dapm_set_endpoint(imx_3stack_mach, "Line Out Jack", 0);
+		snd_soc_dapm_set_endpoint(imx_3stack_mach, "Headphone Jack", 1);
+		pmic_gpio_set_bit_val(MCU_GPIO_REG_GPIO_CONTROL_1, 0, 0);
+	}
+
+}
+
+static irqreturn_t imx_headphone_detect_handler(int irq, void *dev_id)
+{
+	schedule_work(&hp_event);
+	return IRQ_HANDLED;
+
+}
+
+static int imx_3stack_mach_probe(struct snd_soc_machine
+				 *machine)
+{
+	struct snd_soc_codec *codec;
+	struct snd_soc_pcm_link *pcm_link;
+	int i, ret;
+	unsigned int value;
+
+	pcm_link = list_first_entry(&machine->active_list,
+				    struct snd_soc_pcm_link, active_list);
+	codec = pcm_link->codec;
+
+	codec->ops->io_probe(codec, machine);
+
+	snd_soc_dapm_set_endpoint(machine, "RIN2", 0);
+
+	/* Add imx_3stack specific widgets */
+	for (i = 0; i < ARRAY_SIZE(imx_3stack_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(machine, codec,
+					 &imx_3stack_dapm_widgets[i]);
+	}
+	/* set up imx_3stack specific audio path audio_mapnects */
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(machine,
+					   audio_map[i][0],
+					   audio_map[i][1], audio_map[i][2]);
+	}
+
+	pmic_gpio_get_designation_bit_val(0, &value);
+
+	snd_soc_dapm_set_endpoint(machine, "Mic1 Jack", 1);
+	snd_soc_dapm_set_endpoint(machine, "Line In Jack", 1);
+	if (value == 0)
+		snd_soc_dapm_set_endpoint(machine, "Line Out Jack", 1);
+	else
+		snd_soc_dapm_set_endpoint(machine, "Headphone Jack", 1);
+
+	snd_soc_dapm_set_policy(machine, SND_SOC_DAPM_POLICY_STREAM);
+
+	/* register card with ALSA upper layers */
+	ret = snd_soc_register_card(machine);
+	if (ret < 0) {
+		pr_err("%s: failed to register sound card\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+struct snd_soc_machine_ops imx_3stack_mach_ops = {
+	.mach_probe = imx_3stack_mach_probe,
+};
+
+/*
+ * This function will register the snd_soc_pcm_link drivers.
+ * It also registers devices for platform DMA, I2S, SSP and registers an
+ * I2C driver to probe the codec.
+ */
+static int __init imx_3stack_ak4647_probe(struct platform_device *pdev)
+{
+	struct snd_soc_machine *machine;
+	struct mxc_audio_platform_data *dev_data = pdev->dev.platform_data;
+	struct snd_soc_pcm_link *hifi;
+	const char *ssi_port;
+	int ret;
+
+	machine = kzalloc(sizeof(struct snd_soc_machine), GFP_KERNEL);
+	if (machine == NULL)
+		return -ENOMEM;
+
+	machine->owner = THIS_MODULE;
+	machine->pdev = pdev;
+	machine->name = "imx_3stack";
+	machine->longname = "ak4647";
+	machine->ops = &imx_3stack_mach_ops;
+	pdev->dev.driver_data = machine;
+
+	/* register card */
+	imx_3stack_mach = machine;
+	ret =
+	    snd_soc_new_card(machine, 1, SNDRV_DEFAULT_IDX1,
+			     SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		pr_err("%s: failed to create stereo sound card\n", __func__);
+		goto err;
+	}
+
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_RESET_2, 1, 0);
+	msleep(1);
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_RESET_2, 1, 1);
+
+	/* imx_3stack ak4647 hifi interface */
+	if (dev_data->src_port == 1)
+		ssi_port = imx_ssi_1;
+	else
+		ssi_port = imx_ssi_3;
+	hifi =
+	    snd_soc_pcm_link_new(machine,
+				 "imx_3stack-hifi", &hifi_pcm,
+				 imx_pcm, ak4647_codec,
+				 ak4647_hifi_dai, ssi_port);
+	if (hifi == NULL) {
+		pr_err("Failed to create HiFi PCM link\n");
+		goto err;
+	}
+	ret = snd_soc_pcm_link_attach(hifi);
+	hifi->private_data = dev_data;
+	if (ret < 0)
+		goto link_err;
+
+	/* Configure audio port 3 */
+	gpio_activate_audio_ports();
+
+	if (request_irq
+	    (dev_data->intr_id_hp, imx_headphone_detect_handler, 0,
+	     "headphone", machine))
+		goto link_err;
+
+	return ret;
+      link_err:
+	snd_soc_machine_free(machine);
+      err:
+	kfree(machine);
+	return ret;
+}
+
+static int __devexit imx_3stack_ak4647_remove(struct platform_device *pdev)
+{
+	struct snd_soc_machine *machine = pdev->dev.driver_data;
+
+	imx_3stack_mach = NULL;
+	kfree(machine);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int imx_3stack_ak4647_suspend(struct platform_device
+				     *pdev, pm_message_t state)
+{
+	struct snd_soc_machine *machine = pdev->dev.driver_data;
+	return snd_soc_suspend(machine, state);
+}
+
+static int imx_3stack_ak4647_resume(struct platform_device
+				    *pdev)
+{
+	struct snd_soc_machine *machine = pdev->dev.driver_data;
+	return snd_soc_resume(machine);
+}
+
+#else
+#define imx_3stack_ak4647_suspend NULL
+#define imx_3stack_ak4647_resume  NULL
+#endif
+
+static struct platform_driver imx_3stack_ak4647_driver = {
+	.probe = imx_3stack_ak4647_probe,
+	.remove = __devexit_p(imx_3stack_ak4647_remove),
+	.suspend = imx_3stack_ak4647_suspend,
+	.resume = imx_3stack_ak4647_resume,
+	.driver = {
+		   .name = "ak4647-imx-3stack-audio",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init imx_3stack_asoc_init(void)
+{
+	return platform_driver_register(&imx_3stack_ak4647_driver);
+}
+
+static void __exit imx_3stack_asoc_exit(void)
+{
+	platform_driver_unregister(&imx_3stack_ak4647_driver);
+}
+
+module_init(imx_3stack_asoc_init);
+module_exit(imx_3stack_asoc_exit);
+
+/* Module information */
+MODULE_DESCRIPTION("ALSA SoC ak4647 imx_3stack");
+MODULE_LICENSE("GPL");
-- 
1.5.4.4

