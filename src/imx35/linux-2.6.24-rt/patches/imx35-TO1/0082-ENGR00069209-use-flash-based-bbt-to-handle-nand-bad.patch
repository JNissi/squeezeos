From a3495a29fe2e22a8ed7646ac451575a456f5cbe5 Mon Sep 17 00:00:00 2001
From: Jason Liu <r64343@freescale.com>
Date: Wed, 19 Mar 2008 02:30:20 -0500
Subject: [PATCH] ENGR00069209 use flash based bbt to handle nand bad block information

use flash based bad block table(bbt) to handle bad block information
and give up the BI swap mechanism for bad block management.
This will remove all the bi swap related function in nand driver
and enable flash based bad block management in our linux driver.

Signed-off-by: Jason Liu <r64343@freescale.com>
---
 drivers/mtd/nand/mxc_nd.c  |   31 ++++++++++++++++++++++++++-
 drivers/mtd/nand/mxc_nd2.c |   48 ++++---------------------------------------
 drivers/mtd/nand/mxc_nd2.h |   18 ----------------
 3 files changed, 34 insertions(+), 63 deletions(-)

diff --git a/drivers/mtd/nand/mxc_nd.c b/drivers/mtd/nand/mxc_nd.c
index d7d8aa7..3eba30a 100644
--- a/drivers/mtd/nand/mxc_nd.c
+++ b/drivers/mtd/nand/mxc_nd.c
@@ -1066,6 +1066,31 @@ static struct nand_bbt_descr largepage_memorybased = {
 	.pattern = scan_ff_pattern
 };
 
+/* Generic flash bbt decriptors
+*/
+static uint8_t bbt_pattern[] = { 'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = { '1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
 static int mxc_nand_scan_bbt(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
@@ -1087,8 +1112,10 @@ static int mxc_nand_scan_bbt(struct mtd_info *mtd)
 
 	if (is2k_Pagesize)
 		this->ecc.layout = &nand_hw_eccoob_2k;
-	this->bbt_td = NULL;
-	this->bbt_md = NULL;
+
+	/* use flash based bbt */
+	this->bbt_td = &bbt_main_descr;
+	this->bbt_md = &bbt_mirror_descr;
 
 	if (!this->badblock_pattern) {
 		if (mtd->writesize == 2048)
diff --git a/drivers/mtd/nand/mxc_nd2.c b/drivers/mtd/nand/mxc_nd2.c
index 2840d4c..182cfae 100644
--- a/drivers/mtd/nand/mxc_nd2.c
+++ b/drivers/mtd/nand/mxc_nd2.c
@@ -32,8 +32,6 @@
 /* Global address Variables */
 static u32 nfc_axi_base, nfc_ip_base;
 
-static void mxc_swap_2k_bi_main_sp(void);
-
 struct mxc_mtd_s {
 	struct mtd_info mtd;
 	struct nand_chip nand;
@@ -601,8 +599,7 @@ static int mxc_nand_verify_buf(struct mtd_info *mtd, const u_char * buf,
 	volatile u32 *mainBuf = (u32 *) MAIN_AREA0;
 	/* check for 32-bit alignment? */
 	uint32_t *p = (uint32_t *) buf;
-	if (IS_2K_PAGE_NAND)
-		mxc_swap_2k_bi_main_sp();
+
 	for (; len > 0; len -= 4) {
 		if (*p++ != *mainBuf++) {
 			return -EFAULT;
@@ -691,8 +688,6 @@ static void read_full_page(struct mtd_info *mtd, int page_addr)
 	if (IS_LARGE_PAGE_NAND) {
 		send_cmd(NAND_CMD_READSTART, false);
 		READ_PAGE();
-		if (IS_2K_PAGE_NAND)
-			mxc_swap_2k_bi_main_sp();
 	} else {
 		send_read_page(0);
 	}
@@ -899,28 +894,6 @@ static int mxc_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
 	return 0;
 }
 
-/*
- * This function does the trick of swapping the 464th byte in the last RAM
- * buffer in the main area with the 0th byte in the spare area. This seems
- * to be the optimal way of addressing the NFC imcompatibility problem with
- * the NAND flash out of factory in terms of BI field.
- * Note: this function only operates on the NFC's internal RAM buffers and
- *       for 2K page only.
- */
-static void mxc_swap_2k_bi_main_sp(void)
-{
-	u16 tmp1, tmp2, new_tmp1;
-
-	tmp1 = __raw_readw(BAD_BLK_MARKER_MA);
-	tmp2 = __raw_readw(BAD_BLK_MARKER_SP);
-	new_tmp1 = (tmp1 & 0xFF00) | (tmp2 >> 8);
-	tmp2 = (tmp1 << 8) | (tmp2 & 0xFF);
-	__raw_writew(new_tmp1, BAD_BLK_MARKER_MA);
-	__raw_writew(tmp2, BAD_BLK_MARKER_SP);
-
-}
-
-/* Kevin: This is solid but need to optimize the nfc_memcpy */
 static int mxc_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,
 			      uint8_t * buf)
 {
@@ -936,10 +909,6 @@ static int mxc_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,
 			pr_debug("%d Symbol Correctable RS-ECC Error\n", stat);
 	}
 
-	if (IS_2K_PAGE_NAND) {
-		mxc_swap_2k_bi_main_sp();
-	}
-
 	nfc_memcpy((void *)buf, (void *)MAIN_AREA0, mtd->writesize);
 
 	return 0;
@@ -950,10 +919,6 @@ static void mxc_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
 				const uint8_t * buf)
 {
 	memcpy((void *)MAIN_AREA0, buf, mtd->writesize);
-
-	if (IS_2K_PAGE_NAND) {
-		mxc_swap_2k_bi_main_sp();
-	}
 }
 
 /* Define some generic bad / good block scan pattern which are used
@@ -1021,13 +986,10 @@ static int mxc_nand_scan_bbt(struct mtd_info *mtd)
 	/* jffs2 not write oob */
 	mtd->flags &= ~MTD_OOB_WRITEABLE;
 
-	if (IS_4K_PAGE_NAND) {
-		this->bbt_td = &bbt_main_descr;
-		this->bbt_md = &bbt_mirror_descr;
-	} else {
-		this->bbt_td = NULL;
-		this->bbt_md = NULL;
-	}
+	/* use flash based bbt */
+	this->bbt_td = &bbt_main_descr;
+	this->bbt_md = &bbt_mirror_descr;
+
 	if (!this->badblock_pattern) {
 		this->badblock_pattern = (mtd->writesize > 512) ?
 		    &largepage_memorybased : &smallpage_memorybased;
diff --git a/drivers/mtd/nand/mxc_nd2.h b/drivers/mtd/nand/mxc_nd2.h
index 3f702c8..5bf05dc 100644
--- a/drivers/mtd/nand/mxc_nd2.h
+++ b/drivers/mtd/nand/mxc_nd2.h
@@ -110,10 +110,6 @@
 #define SPAS_MASK			0xFF00FFFF
 #define IS_4BIT_ECC			\
 	((raw_read(NFC_CONFIG2) & NFC_ECC_MODE_4) >> 6)
-/* Dummy define for compilation. Not used */
-#define BAD_BLK_MARKER_MA		0
-/* Dummy define for compilation. Not used */
-#define BAD_BLK_MARKER_SP		0
 
 #define SET_SPAS(v)			\
 	raw_write(((raw_read(NFC_CONFIG2) & SPAS_MASK) | ((v) << 16)), NFC_CONFIG2)
@@ -295,11 +291,6 @@
 #define SPARE_COUNT       4
 #define SPARE_SIZE        (SPARE_LEN * SPARE_COUNT)
 
-/* read column 464-465 byte but only 464 for bad block marker */
-#define BAD_BLK_MARKER_MA	IO_ADDRESS(NFC_BASE_ADDR + 0x600 + 464)
-/* read column 0-1 byte, but only 1 is used for swapped main area data */
-#define BAD_BLK_MARKER_SP	IO_ADDRESS(NFC_BASE_ADDR + 0x800)
-
 #define IS_4BIT_ECC       1
 #define SET_SPAS(v)
 #define SET_ECC_MODE(v)
@@ -395,13 +386,4 @@ do {                     \
 
 #endif
 
-#ifndef BAD_BLK_MARKER_MA
-#define BAD_BLK_OFFSET_MA	(0x600 + 464)
-#define BAD_BLK_OFFSET_SP	0x800
-/* read column 464-465 byte but only 464 for bad block marker */
-#define BAD_BLK_MARKER_MA	IO_ADDRESS(NFC_BASE_ADDR_AXI + BAD_BLK_OFFSET_MA)
-/* read column 0-1 byte, but only 1 is used for swapped main area data */
-#define BAD_BLK_MARKER_SP	IO_ADDRESS(NFC_BASE_ADDR_AXI + BAD_BLK_OFFSET_SP)
-#endif
-
 #endif				/* __MXC_ND2_H__ */
-- 
1.5.4.4

