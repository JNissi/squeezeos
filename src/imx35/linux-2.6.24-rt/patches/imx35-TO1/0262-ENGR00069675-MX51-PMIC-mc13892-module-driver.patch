From c7d7dcb208424e2033130fab66addd88e0735370 Mon Sep 17 00:00:00 2001
From: Shen Yong <b00984@freescale.com>
Date: Thu, 17 Jul 2008 15:57:08 +0800
Subject: [PATCH] ENGR00069675 MX51: PMIC mc13892 module driver

Implement PMIC I2C core
Implement PMIC regulator API

Signed-off-by: Kevin Shen <b00984@freescale.com>
---
 arch/arm/configs/imx51_3stack_defconfig  |   17 +-
 arch/arm/mach-mx51/mx51_3stack.c         |    6 +
 arch/arm/mach-mx51/mx51_3stack_gpio.c    |   36 +
 drivers/mxc/pmic/Kconfig                 |   17 +-
 drivers/mxc/pmic/Makefile                |    1 +
 drivers/mxc/pmic/core/Makefile           |    8 +-
 drivers/mxc/pmic/core/mc13892.c          |  112 ++
 drivers/mxc/pmic/core/pmic_core_i2c.c    |  287 +++++
 drivers/regulator/Kconfig                |    5 +
 drivers/regulator/Makefile               |    2 +
 drivers/regulator/mc13892/Makefile       |    5 +
 drivers/regulator/mc13892/reg-mc13892.c  | 1848 ++++++++++++++++++++++++++++++
 drivers/regulator/reg-core.c             |  156 ++-
 include/asm-arm/arch-mxc/pmic_external.h |  116 ++-
 14 files changed, 2549 insertions(+), 67 deletions(-)

diff --git a/arch/arm/configs/imx51_3stack_defconfig b/arch/arm/configs/imx51_3stack_defconfig
index 2ef0ae1..37ad72d 100644
--- a/arch/arm/configs/imx51_3stack_defconfig
+++ b/arch/arm/configs/imx51_3stack_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.24
-# Mon Jul 14 10:13:21 2008
+# Wed Jul 16 16:41:37 2008
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -473,7 +473,11 @@ CONFIG_MTD_NAND_MXC_V3=y
 #
 # Voltage and Current regulators
 #
-# CONFIG_REGULATOR is not set
+CONFIG_REGULATOR_API=y
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+CONFIG_REGULATOR_MC13892=y
+# CONFIG_REGULATOR_WM8350 is not set
 # CONFIG_PARPORT is not set
 # CONFIG_PNP is not set
 CONFIG_BLK_DEV=y
@@ -840,7 +844,14 @@ CONFIG_RTC_LIB=y
 #
 # CONFIG_MXC_SPI_PMIC_CORE is not set
 # CONFIG_MXC_I2C_MCU_PMIC_CORE is not set
-# CONFIG_MXC_PMIC is not set
+CONFIG_MXC_I2C_PMIC_CORE=y
+CONFIG_MXC_PMIC=y
+# CONFIG_MXC_PMIC_CHARDEV is not set
+
+#
+# MXC PMIC Client Drivers
+#
+CONFIG_MXC_PMIC_MC13892=y
 
 #
 # Advanced Power Management devices
diff --git a/arch/arm/mach-mx51/mx51_3stack.c b/arch/arm/mach-mx51/mx51_3stack.c
index d5564d9..9f8e6da 100644
--- a/arch/arm/mach-mx51/mx51_3stack.c
+++ b/arch/arm/mach-mx51/mx51_3stack.c
@@ -228,6 +228,12 @@ static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
 
 #ifdef CONFIG_I2C_MXC_SELECT2
 static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
+	{
+	 .driver_name = "mc13892",
+	 .addr = 0x08,
+	 .platform_data = (void *)MXC_INT_GPIO1_INT5,
+	 },
+
 };
 #endif
 
diff --git a/arch/arm/mach-mx51/mx51_3stack_gpio.c b/arch/arm/mach-mx51/mx51_3stack_gpio.c
index cba6fae..17c7a3d 100644
--- a/arch/arm/mach-mx51/mx51_3stack_gpio.c
+++ b/arch/arm/mach-mx51/mx51_3stack_gpio.c
@@ -122,6 +122,7 @@ void gpio_uart_active(int port, int no_irda)
 		break;
 	}
 }
+
 EXPORT_SYMBOL(gpio_uart_active);
 
 /*!
@@ -171,6 +172,7 @@ void gpio_uart_inactive(int port, int no_irda)
 		break;
 	}
 }
+
 EXPORT_SYMBOL(gpio_uart_inactive);
 
 /*!
@@ -182,6 +184,7 @@ void config_uartdma_event(int port)
 {
 
 }
+
 EXPORT_SYMBOL(config_uartdma_event);
 
 /*!
@@ -274,6 +277,7 @@ void gpio_spi_active(int cspi_mod)
 		break;
 	}
 }
+
 EXPORT_SYMBOL(gpio_spi_active);
 
 /*!
@@ -314,6 +318,7 @@ void gpio_spi_inactive(int cspi_mod)
 	}
 
 }
+
 EXPORT_SYMBOL(gpio_spi_inactive);
 
 /*!
@@ -323,6 +328,7 @@ void gpio_owire_active(void)
 {
 
 }
+
 EXPORT_SYMBOL(gpio_owire_active);
 
 /*!
@@ -332,6 +338,7 @@ void gpio_owire_inactive(void)
 {
 
 }
+
 EXPORT_SYMBOL(gpio_owire_inactive);
 
 /*!
@@ -402,6 +409,7 @@ void gpio_i2c_active(int i2c_num)
 		break;
 	}
 }
+
 EXPORT_SYMBOL(gpio_i2c_active);
 
 /*!
@@ -446,8 +454,17 @@ void gpio_i2c_inactive(int i2c_num)
 		break;
 	}
 }
+
 EXPORT_SYMBOL(gpio_i2c_inactive);
 
+void gpio_pmic_active(void)
+{
+	mxc_request_iomux(MX51_PIN_GPIO1_5, IOMUX_CONFIG_GPIO);
+	mxc_set_gpio_direction(MX51_PIN_GPIO1_5, 1);
+}
+
+EXPORT_SYMBOL(gpio_pmic_active);
+
 /*!
  * This function activates DAM ports 4 & 5 to enable
  * audio I/O.
@@ -455,6 +472,7 @@ EXPORT_SYMBOL(gpio_i2c_inactive);
 void gpio_activate_audio_ports(void)
 {
 }
+
 EXPORT_SYMBOL(gpio_activate_audio_ports);
 
 /*!
@@ -465,6 +483,7 @@ EXPORT_SYMBOL(gpio_activate_audio_ports);
 void gpio_sdhc_active(int module)
 {
 }
+
 EXPORT_SYMBOL(gpio_sdhc_active);
 
 /*!
@@ -475,6 +494,7 @@ EXPORT_SYMBOL(gpio_sdhc_active);
 void gpio_sdhc_inactive(int module)
 {
 }
+
 EXPORT_SYMBOL(gpio_sdhc_inactive);
 
 /*
@@ -484,6 +504,7 @@ int sdhc_get_card_det_status(struct device *dev)
 {
 	return 0;
 }
+
 EXPORT_SYMBOL(sdhc_get_card_det_status);
 
 /*
@@ -493,6 +514,7 @@ int sdhc_init_card_det(int id)
 {
 	return 0;
 }
+
 EXPORT_SYMBOL(sdhc_init_card_det);
 
 /*!
@@ -534,6 +556,7 @@ void gpio_sensor_select(int sensor)
 void gpio_sensor_active(void)
 {
 }
+
 EXPORT_SYMBOL(gpio_sensor_active);
 
 /*!
@@ -543,6 +566,7 @@ EXPORT_SYMBOL(gpio_sensor_active);
 void gpio_sensor_inactive(void)
 {
 }
+
 EXPORT_SYMBOL(gpio_sensor_inactive);
 
 /*!
@@ -552,6 +576,7 @@ EXPORT_SYMBOL(gpio_sensor_inactive);
 void gpio_ata_active(void)
 {
 }
+
 EXPORT_SYMBOL(gpio_ata_active);
 
 /*!
@@ -561,6 +586,7 @@ EXPORT_SYMBOL(gpio_ata_active);
 void gpio_ata_inactive(void)
 {
 }
+
 EXPORT_SYMBOL(gpio_ata_inactive);
 
 /*!
@@ -583,6 +609,7 @@ void gpio_keypad_active(void)
 	mxc_request_iomux(MX51_PIN_KEY_ROW2, IOMUX_CONFIG_ALT0);
 	mxc_request_iomux(MX51_PIN_KEY_ROW3, IOMUX_CONFIG_ALT0);
 }
+
 EXPORT_SYMBOL(gpio_keypad_active);
 
 /*!
@@ -613,6 +640,7 @@ void gpio_keypad_inactive(void)
 	mxc_free_iomux(MX51_PIN_KEY_ROW2, IOMUX_CONFIG_GPIO);
 	mxc_free_iomux(MX51_PIN_KEY_ROW3, IOMUX_CONFIG_GPIO);
 }
+
 EXPORT_SYMBOL(gpio_keypad_inactive);
 
 /*
@@ -622,11 +650,13 @@ int gpio_usbotg_hs_active(void)
 {
 	return 0;
 }
+
 EXPORT_SYMBOL(gpio_usbotg_hs_active);
 
 void gpio_usbotg_hs_inactive(void)
 {
 }
+
 EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
 
 /*!
@@ -636,6 +666,7 @@ EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
 void gpio_pcmcia_active(void)
 {
 }
+
 EXPORT_SYMBOL(gpio_pcmcia_active);
 
 /*!
@@ -644,6 +675,7 @@ EXPORT_SYMBOL(gpio_pcmcia_active);
 void gpio_pcmcia_inactive(void)
 {
 }
+
 EXPORT_SYMBOL(gpio_pcmcia_inactive);
 
 /*!
@@ -652,6 +684,7 @@ EXPORT_SYMBOL(gpio_pcmcia_inactive);
 void gpio_fec_active(void)
 {
 }
+
 EXPORT_SYMBOL(gpio_fec_active);
 
 /*!
@@ -660,15 +693,18 @@ EXPORT_SYMBOL(gpio_fec_active);
 void gpio_fec_inactive(void)
 {
 }
+
 EXPORT_SYMBOL(gpio_fec_inactive);
 
 void gpio_spdif_active(void)
 {
 }
+
 EXPORT_SYMBOL(gpio_spdif_active);
 
 void gpio_spdif_inactive(void)
 {
 
 }
+
 EXPORT_SYMBOL(gpio_spdif_inactive);
diff --git a/drivers/mxc/pmic/Kconfig b/drivers/mxc/pmic/Kconfig
index f319434..85f3a5d 100644
--- a/drivers/mxc/pmic/Kconfig
+++ b/drivers/mxc/pmic/Kconfig
@@ -20,9 +20,16 @@ config MXC_I2C_MCU_PMIC_CORE
         ---help---
         This is the PMIC core/protocol driver for the MX35 3DS MCU PMIC
 
+config MXC_I2C_PMIC_CORE
+        tristate "PMIC Protocol support (I2C interface)"
+        depends on ARCH_MXC
+        default n
+        ---help---
+        This is the PMIC core/protocol driver for the MX51 3DS PMIC
+	
 config MXC_PMIC
 	boolean
-	default (MXC_SPI_PMIC_CORE || MXC_I2C_MCU_PMIC_CORE)
+	default (MXC_SPI_PMIC_CORE || MXC_I2C_MCU_PMIC_CORE || MXC_I2C_PMIC_CORE)
 
 config MXC_PMIC_CHARDEV
 	tristate "MXC PMIC device interface"
@@ -44,6 +51,14 @@ config MXC_PMIC_MC13783
 	This is the MXC MC13783(PMIC) client drivers support. It include
 	ADC, Audio, Battery, Connectivity, Light, Power and RTC.
 
+config MXC_PMIC_MC13892
+	tristate "MC13892 Client Drivers"
+	depends on MXC_I2C_PMIC_CORE
+	default n
+	---help---
+	This is the MXC MC13892(PMIC) client drivers support. It include
+	ADC, Battery, Connectivity, Light, Power and RTC.
+
 source "drivers/mxc/pmic/mc13783/Kconfig"
 
 config MXC_PMIC_SC55112
diff --git a/drivers/mxc/pmic/Makefile b/drivers/mxc/pmic/Makefile
index 89fb672..b4b1076 100644
--- a/drivers/mxc/pmic/Makefile
+++ b/drivers/mxc/pmic/Makefile
@@ -4,5 +4,6 @@
 
 obj-y				+= core/
 obj-$(CONFIG_MXC_PMIC_MC13783)	+= mc13783/
+#obj-$(CONFIG_MXC_PMIC_MC13892)	+= mc13892/
 obj-$(CONFIG_MXC_PMIC_MC9SDZ60) += mc9sdz60/
 
diff --git a/drivers/mxc/pmic/core/Makefile b/drivers/mxc/pmic/core/Makefile
index 2945dd3..57e5612 100644
--- a/drivers/mxc/pmic/core/Makefile
+++ b/drivers/mxc/pmic/core/Makefile
@@ -5,12 +5,16 @@ obj-$(CONFIG_MXC_SPI_PMIC_CORE) += pmic_core_spi_mod.o
 
 obj-$(CONFIG_MXC_I2C_MCU_PMIC_CORE) += pmic_core_i2c_mod.o
 
-pmic_core_i2c_mod-objs := pmic_external.o pmic_event.o mcu_pmic_core.o
+obj-$(CONFIG_MXC_I2C_PMIC_CORE) += pmic_core_mc13892_mod.o
 
-obj-$(CONFIG_MXC_PMIC_CHARDEV)	+= pmic-dev.o
+pmic_core_mc13892_mod-objs := pmic_external.o pmic_event.o pmic_core_i2c.o mc13892.o
+
+pmic_core_i2c_mod-objs := pmic_external.o pmic_event.o mcu_pmic_core.o
 
 pmic_core_spi_mod-objs := pmic_external.o pmic_event.o pmic_core_spi.o
 
+obj-$(CONFIG_MXC_PMIC_CHARDEV)	+= pmic-dev.o
+
 ifeq ($(CONFIG_MXC_PMIC_MC13783),y)
 pmic_core_spi_mod-objs += mc13783.o
 endif
diff --git a/drivers/mxc/pmic/core/mc13892.c b/drivers/mxc/pmic/core/mc13892.c
new file mode 100644
index 0000000..ff88728
--- /dev/null
+++ b/drivers/mxc/pmic/core/mc13892.c
@@ -0,0 +1,112 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic/core/mc13892.c
+ * @brief This file contains MC13892 specific PMIC code. This implementaion
+ * may differ for each PMIC chip.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+
+#include <asm/uaccess.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/pmic_external.h>
+#include <asm/arch/pmic_status.h>
+
+#include "pmic.h"
+
+/*
+ * Defines
+ */
+
+int pmic_i2c_24bit_read(struct i2c_client *client, unsigned int reg_num)
+{
+	char buf[3];
+	int ret;
+
+	memset(buf, 0, 3);
+	ret = i2c_smbus_read_i2c_block_data(client, reg_num, 3, buf);
+
+	if (ret == 3) {
+		ret = buf[0] << 16 | buf[1] << 8 | buf[2];
+		return ret;
+	} else {
+		printk(KERN_ERR "24bit read error, ret = %d\n", ret);
+		return -1;	/* return -1 on failure */
+	}
+}
+
+int pmic_i2c_24bit_write(struct i2c_client *client,
+			 unsigned int reg_num, unsigned int reg_val)
+{
+	char buf[3];
+
+	buf[0] = (reg_val >> 16) & 0xff;
+	buf[1] = (reg_val >> 8) & 0xff;
+	buf[2] = (reg_val) & 0xff;
+
+	return i2c_smbus_write_i2c_block_data(client, reg_num, 3, buf);
+}
+
+int pmic_read(int reg_num, unsigned int *reg_val)
+{
+	if (mc13892_client == NULL)
+		return PMIC_ERROR;
+
+	*reg_val = pmic_i2c_24bit_read(mc13892_client, reg_num);
+
+	if (*reg_val == -1)
+		return PMIC_ERROR;
+
+	return PMIC_SUCCESS;
+}
+
+int pmic_write(int reg_num, const unsigned int reg_val)
+{
+	if (mc13892_client == NULL)
+		return PMIC_ERROR;
+
+	return pmic_i2c_24bit_write(mc13892_client, reg_num, reg_val);
+}
+
+int pmic_init_registers(void)
+{
+	return PMIC_SUCCESS;
+}
+
+unsigned int pmic_get_active_events(unsigned int *active_events)
+{
+	return 0;
+}
+
+int pmic_event_unmask(type_event event)
+{
+	return 0;
+}
+
+int pmic_event_mask(type_event event)
+{
+	return 0;
+}
diff --git a/drivers/mxc/pmic/core/pmic_core_i2c.c b/drivers/mxc/pmic/core/pmic_core_i2c.c
new file mode 100644
index 0000000..5720892
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_core_i2c.c
@@ -0,0 +1,287 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_core_i2c.c
+ * @brief This is the main file for the PMIC Core/Protocol driver. i2c
+ * should be providing the interface between the PMIC and the MCU.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/i2c.h>
+
+#include <asm/uaccess.h>
+#include <asm/arch/gpio.h>
+
+#include <asm/arch/pmic_external.h>
+#include <asm/arch/pmic_status.h>
+#include "pmic.h"
+
+#define MC13892_GENERATION_ID_LSH	6
+#define MC13892_IC_ID_LSH		13
+
+#define MC13892_GENERATION_ID_WID	3
+#define MC13892_IC_ID_WID		6
+
+#define MC13892_GEN_ID_VALUE	0x7
+#define MC13892_IC_ID_VALUE		1
+
+/*
+ * Global variables
+ */
+static pmic_version_t mxc_pmic_version;
+unsigned int active_events[MAX_ACTIVE_EVENTS];
+struct i2c_client *mc13892_client;
+
+void pmic_bh_handler(struct work_struct *work);
+
+/*!
+ * Bottom half handler of PMIC event handling.
+ */
+DECLARE_WORK(pmic_ws, pmic_bh_handler);
+
+/*!
+ * This function is called when pmic interrupt occurs on the processor.
+ * It is the interrupt handler for the pmic module.
+ *
+ * @param        irq        the irq number
+ * @param        dev_id     the pointer on the device
+ *
+ * @return       The function returns IRQ_HANDLED when handled.
+ */
+static irqreturn_t pmic_irq_handler(int irq, void *dev_id)
+{
+	/* prepare a task */
+	schedule_work(&pmic_ws);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is the bottom half handler of the PMIC interrupt.
+ * It checks for active events and launches callback for the
+ * active events.
+ */
+void pmic_bh_handler(struct work_struct *work)
+{
+	unsigned int loop;
+	unsigned int count = 0;
+
+	count = pmic_get_active_events(active_events);
+
+	for (loop = 0; loop < count; loop++)
+		pmic_event_callback(active_events[loop]);
+
+	return;
+}
+
+pmic_version_t pmic_get_version(void)
+{
+	return mxc_pmic_version;
+}
+
+EXPORT_SYMBOL(pmic_get_version);
+
+static int __devinit is_chip_onboard(struct i2c_client *client)
+{
+	int ret = 0;
+
+	/*bind the right device to the driver */
+	ret = pmic_i2c_24bit_read(client, REG_IDENTIFICATION);
+	dev_err(&client->dev, "identification %x\n", ret);
+
+	if (MC13892_GEN_ID_VALUE != BITFEXT(ret, MC13892_GENERATION_ID)) {
+		/*compare the address value */
+		dev_err(&client->dev,
+			"read generation ID 0x%x is not equal to 0x%x!\n",
+			BITFEXT(ret, MC13892_GENERATION_ID),
+			MC13892_GEN_ID_VALUE);
+		return -1;
+	}
+	dev_err(&client->dev, "chip on board!\n");
+
+	return 0;
+}
+
+static ssize_t mc13892_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	int i, value;
+	int offset = (REG_TEST4 + 1) / 4;
+
+	for (i = 0; i < offset; i++) {
+		pmic_read(i, &value);
+		printk(KERN_INFO "reg%02d: %06x\t\t", i, value);
+		pmic_read(i + offset, &value);
+		printk(KERN_INFO "reg%02d: %06x\t\t", i + offset, value);
+		pmic_read(i + offset * 2, &value);
+		printk(KERN_INFO "reg%02d: %06x\t\t", i + offset * 2, value);
+		pmic_read(i + offset * 3, &value);
+		printk(KERN_INFO "reg%02d: %06x\n", i + offset * 3, value);
+	}
+
+	return 0;
+}
+
+static ssize_t mc13892_store(struct device *dev,
+			     struct device_attribute *attr, const char *buf,
+			     size_t count)
+{
+	int reg, value, ret;
+	char *p;
+
+	reg = simple_strtoul(buf, NULL, 10);
+
+	p = NULL;
+	p = memchr(buf, ' ', count);
+
+	if (p == NULL) {
+		pmic_read(reg, &value);
+		printk(KERN_INFO "reg%02d: %06x\n", reg, value);
+		return count;
+	}
+
+	p += 1;
+
+	value = simple_strtoul(p, NULL, 16);
+
+	ret = pmic_write(reg, value);
+	if (ret == 0)
+		printk(KERN_INFO "write reg%02d: %06x\n", reg, value);
+	else
+		printk(KERN_INFO "register update failed\n");
+
+	return count;
+}
+
+static struct device_attribute mc13892_dev_attr = {
+	.attr = {
+		 .name = "mc13892_ctl",
+		 .mode = S_IRUSR | S_IWUSR,
+		 },
+	.show = mc13892_show,
+	.store = mc13892_store,
+};
+
+static int __devinit pmic_probe(struct i2c_client *client)
+{
+	int ret = 0;
+	int pmic_irq;
+
+	printk(KERN_INFO "start probe pmic 13892\n");
+
+	ret = is_chip_onboard(client);
+
+	if (ret == -1)
+		return -ENODEV;
+
+	/* so far, we got matched chip on board */
+
+	mc13892_client = client;
+
+	/* Initialize the PMIC event handling */
+	pmic_event_list_init();
+
+	/* Initialize GPIO for PMIC Interrupt */
+	gpio_pmic_active();
+
+	/* Initialize the PMIC parameters */
+	ret = pmic_init_registers();
+	if (ret != PMIC_SUCCESS)
+		return PMIC_ERROR;
+
+	/* Set and install PMIC IRQ handler */
+	pmic_irq = (int)(client->dev.platform_data);
+	if (pmic_irq == 0)
+		return PMIC_ERROR;
+
+	set_irq_type(pmic_irq, IRQF_TRIGGER_RISING);
+	ret = request_irq(pmic_irq, pmic_irq_handler, 0, "PMIC_IRQ", 0);
+	if (ret) {
+		dev_err(&client->dev, "request irq %d error!\n", pmic_irq);
+		return ret;
+	}
+
+	reg_mc13892_probe();
+
+	ret = device_create_file(&client->dev, &mc13892_dev_attr);
+	if (ret)
+		dev_err(&client->dev, "create device file failed!\n");
+
+	printk(KERN_INFO "Device %s probed\n", client->dev.bus_id);
+
+	return PMIC_SUCCESS;
+}
+
+static int pmic_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static int pmic_suspend(struct i2c_client *client, pm_message_t state)
+{
+	return 0;
+}
+
+static int pmic_resume(struct i2c_client *client)
+{
+	return 0;
+}
+
+static struct i2c_driver pmic_driver = {
+	.driver = {
+		   .name = "mc13892",
+		   .bus = NULL,
+		   },
+	.probe = pmic_probe,
+	.remove = pmic_remove,
+	.suspend = pmic_suspend,
+	.resume = pmic_resume,
+};
+
+static int __init pmic_init(void)
+{
+	printk(KERN_INFO "Registering the PMIC Protocol Driver\n");
+	return i2c_add_driver(&pmic_driver);
+}
+
+static void __exit pmic_exit(void)
+{
+	printk(KERN_INFO "Unregistering the PMIC Protocol Driver\n");
+	return i2c_del_driver(&pmic_driver);
+}
+
+/*
+ * Module entry points
+ */
+/* subsys_initcall_sync(pmic_init); */
+module_init(pmic_init);
+module_exit(pmic_exit);
+
+MODULE_DESCRIPTION("Core/Protocol driver for PMIC");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 9b703aa..7c3de61 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -22,6 +22,11 @@ config REGULATOR_MC13783
         depends on REGULATOR
         depends on MXC_PMIC_MC13783
 
+config REGULATOR_MC13892
+    tristate "MC13892 Regulator Support"
+        depends on REGULATOR
+        depends on MXC_PMIC_MC13892
+	
 config REGULATOR_WM8350
     tristate "WM8350 Regulator Support"
         depends on REGULATOR
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index b78ca53..cfb08ca 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -11,3 +11,5 @@ endif
 obj-$(CONFIG_REGULATOR_MC13783)  += mc13783/
 obj-$(CONFIG_REGULATOR_WM8350)  += wm8350/
 obj-$(CONFIG_REGULATOR_MAX8660) += max8660/
+obj-$(CONFIG_REGULATOR_MC13892) += mc13892/
+
diff --git a/drivers/regulator/mc13892/Makefile b/drivers/regulator/mc13892/Makefile
new file mode 100644
index 0000000..e920ff4
--- /dev/null
+++ b/drivers/regulator/mc13892/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for regulator driver for MC13892.
+#
+
+obj-$(CONFIG_REGULATOR_MC13892) += reg-mc13892.o
diff --git a/drivers/regulator/mc13892/reg-mc13892.c b/drivers/regulator/mc13892/reg-mc13892.c
new file mode 100644
index 0000000..5abc4d6
--- /dev/null
+++ b/drivers/regulator/mc13892/reg-mc13892.c
@@ -0,0 +1,1848 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/regulator/regulator-platform.h>
+#include <linux/regulator/regulator-drv.h>
+#include <asm/ioctl.h>
+#include <linux/platform_device.h>
+#include <asm/arch/pmic_status.h>
+#include <asm/arch/pmic_external.h>
+
+enum {
+	MC13892_SW1 = 0,
+	MC13892_SW2,
+	MC13892_SW3,
+	MC13892_SW4,
+	MC13892_SWBST,
+	MC13892_VIOHI,
+	MC13892_VPLL,
+	MC13892_VDIG,
+	MC13892_VSD,
+	MC13892_VUSB2,
+	MC13892_VVIDEO,
+	MC13892_VAUDIO,
+	MC13892_VCAM,
+	MC13892_VGEN1,
+	MC13892_VGEN2,
+	MC13892_VGEN3,
+	MC13892_VUSB,
+	MC13892_GPO1,
+	MC13892_GPO2,
+	MC13892_GPO3,
+	MC13892_GPO4,
+	MC13892_REG_NUM,
+} MC13892_regulator;
+
+enum {
+	VDIG_1_05V = 0,
+	VDIG_1_25V,
+	VDIG_1_65V,
+	VDIG_1_80V,
+} regulator_voltage_vdig;
+
+enum {
+	VPLL_1_05V = 0,
+	VPLL_1_25V,
+	VPLL_1_65V,
+	VPLL_1_80V,
+} regulator_voltage_vpll;
+
+enum {
+	VGEN1_1_2V = 0,
+	VGEN1_1_5V,
+	VGEN1_1_8V,
+	VGEN1_2_775V,
+} regulator_voltage_vgen1;
+
+enum {
+	VGEN2_1_2V = 0,
+	VGEN2_1_5V,
+	VGEN2_1_6V,
+	VGEN2_1_8V,
+	VGEN2_2_7V,
+	VGEN2_2_8V,
+	VGEN2_2_9V,
+	VGEN2_3_0V,
+} regulator_voltage_vgen2;
+
+enum {
+	VGEN3_1_8V = 0,
+	VGEN3_2_9V,
+} regulator_voltage_vgen3;
+
+enum {
+	VSD_1_8V = 0,
+	VSD_2_0V,
+	VSD_2_6V,
+	VSD_2_7V,
+	VSD_2_8V,
+	VSD_2_9V,
+	VSD_3_0V,
+	VSD_3_15V,
+} regulator_voltage_vsd;
+
+enum {
+	VCAM_1_8V,
+	VCAM_2_5V,
+	VCAM_2_6V,
+	VCAM_2_75V,
+} regulator_voltage_vcam;
+
+enum {
+	VAUDIO_2_3V,
+	VAUDIO_2_5V,
+	VAUDIO_2_7V,
+	VAUDIO_2_775V,
+} regulator_voltage_vaudio;
+
+enum {
+	VUSB2_2_4V,
+	VUSB2_2_6V,
+	VUSB2_2_7V,
+	VUSB2_2_775V,
+} regulator_voltage_vusb2;
+
+enum {
+	VVIDEO_2_7V,
+	VVIDEO_2_775V,
+	VVIDEO_2_5V,
+	VVIDEO_2_6V,
+} regulator_voltage_vvideo;
+
+#define VAUDIO_LSH	4
+#define VAUDIO_WID	2
+#define VAUDIO_EN_LSH	15
+#define VAUDIO_EN_WID	1
+#define VAUDIO_EN_ENABLE	1
+#define VAUDIO_EN_DISABLE	0
+
+#define VUSB2_LSH	11
+#define VUSB2_WID	2
+#define VUSB2_EN_LSH	18
+#define VUSB2_EN_WID	1
+#define VUSB2_EN_ENABLE	1
+#define VUSB2_EN_DISABLE	0
+
+#define VVIDEO_LSH	2
+#define VVIDEO_WID	2
+#define VVIDEO_EN_LSH	12
+#define VVIDEO_EN_WID	1
+#define VVIDEO_EN_ENABLE	1
+#define VVIDEO_EN_DISABLE	0
+
+#define SWBST_EN_LSH	20
+#define SWBST_EN_WID	1
+#define SWBST_EN_ENABLE	1
+#define SWBST_EN_DISABLE	0
+
+#define VIOHI_EN_LSH	3
+#define VIOHI_EN_WID	1
+#define VIOHI_EN_ENABLE	1
+#define VIOHI_EN_DISABLE	0
+
+#define VDIG_LSH	4
+#define VDIG_WID	2
+#define VDIG_EN_LSH	9
+#define VDIG_EN_WID	1
+#define VDIG_EN_ENABLE	1
+#define VDIG_EN_DISABLE	0
+
+#define VPLL_LSH	9
+#define VPLL_WID	2
+#define VPLL_EN_LSH	15
+#define VPLL_EN_WID	1
+#define VPLL_EN_ENABLE	1
+#define VPLL_EN_DISABLE	0
+
+#define VGEN1_LSH	0
+#define VGEN1_WID	2
+#define VGEN1_EN_LSH	0
+#define VGEN1_EN_WID	1
+#define VGEN1_EN_ENABLE	1
+#define VGEN1_EN_DISABLE	0
+
+#define VGEN2_LSH	6
+#define VGEN2_WID	3
+#define VGEN2_EN_LSH	12
+#define VGEN2_EN_WID	1
+#define VGEN2_EN_ENABLE	1
+#define VGEN2_EN_DISABLE	0
+
+#define VGEN3_LSH	14
+#define VGEN3_WID	1
+#define VGEN3_EN_LSH	0
+#define VGEN3_EN_WID	1
+#define VGEN3_EN_ENABLE	1
+#define VGEN3_EN_DISABLE	0
+
+#define VSD_LSH	6
+#define VSD_WID	3
+#define VSD_EN_LSH	18
+#define VSD_EN_WID	1
+#define VSD_EN_ENABLE	1
+#define VSD_EN_DISABLE	0
+
+#define VCAM_LSH	16
+#define VCAM_WID	2
+#define VCAM_EN_LSH	6
+#define VCAM_EN_WID	1
+#define VCAM_EN_ENABLE	1
+#define VCAM_EN_DISABLE	0
+
+#define SW1_LSH		0
+#define SW1_WID		5
+#define SW1_DVS_LSH	5
+#define SW1_DVS_WID	5
+#define SW1_STDBY_LSH	10
+#define SW1_STDBY_WID	5
+
+#define SW2_LSH		0
+#define SW2_WID		5
+#define SW2_DVS_LSH	5
+#define SW2_DVS_WID	5
+#define SW2_STDBY_LSH	10
+#define SW2_STDBY_WID	5
+
+#define SW3_LSH		0
+#define SW3_WID		5
+#define SW3_STDBY_LSH	10
+#define SW3_STDBY_WID	5
+
+#define SW4_LSH		0
+#define SW4_WID		5
+#define SW4_STDBY_LSH	10
+#define SW4_STDBY_WID	5
+
+#define VUSB_EN_LSH	3
+#define VUSB_EN_WID	1
+#define VUSB_EN_ENABLE	1
+#define VUSB_EN_DISABLE	0
+
+#define GPO1_EN_LSH	6
+#define GPO1_EN_WID	1
+#define GPO1_EN_ENABLE	1
+#define GPO1_EN_DISABLE	0
+
+#define GPO2_EN_LSH	8
+#define GPO2_EN_WID	1
+#define GPO2_EN_ENABLE	1
+#define GPO2_EN_DISABLE	0
+
+#define GPO3_EN_LSH	10
+#define GPO3_EN_WID	1
+#define GPO3_EN_ENABLE	1
+#define GPO3_EN_DISABLE	0
+
+#define GPO4_EN_LSH	12
+#define GPO4_EN_WID	1
+#define GPO4_EN_ENABLE	1
+#define GPO4_EN_DISABLE	0
+
+static int mc13892_get_sw_hi_bit(int sw)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int reg = 0;
+
+	switch (sw) {
+	case MC13892_SW1:
+		reg = REG_SW_0;
+		break;
+	case MC13892_SW2:
+		reg = REG_SW_1;
+		break;
+	case MC13892_SW3:
+		reg = REG_SW_2;
+		break;
+	case MC13892_SW4:
+		reg = REG_SW_3;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	CHECK_ERROR(pmic_read_reg(reg, &register_val, PMIC_ALL_BITS));
+	return register_val & 0x800000;
+}
+
+static int mc13892_get_voltage_value(int hi, int mV)
+{
+	int voltage;
+
+	if (mV < 600)
+		mV = 600;
+	if (mV > 1850)
+		mV = 1850;
+
+	if (hi == 0) {
+		if (mV > 1375)
+			mV = 1375;
+		voltage = (mV - 600) / 25;
+	} else {
+		if (mV < 1100)
+			mV = 1100;
+		voltage = (mV - 1100) / 25;
+	}
+
+	return voltage;
+}
+
+static int mc13892_get_voltage_mV(int hi, int voltage)
+{
+	int mV;
+
+	if (hi == 0)
+		mV = voltage * 25 + 600;
+	else
+		mV = voltage * 25 + 1100;
+
+	return mV;
+}
+
+static int mc13892_sw_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1 = 0;
+	int voltage, sw = reg->id, mV = uV / 1000, hi;
+
+	hi = mc13892_get_sw_hi_bit(sw);
+	voltage = mc13892_get_voltage_value(hi, mV);
+
+	switch (sw) {
+	case MC13892_SW1:
+		register1 = REG_SW_0;
+		register_val = BITFVAL(SW1, voltage);
+		register_mask = BITFMASK(SW1);
+		break;
+	case MC13892_SW2:
+		register1 = REG_SW_1;
+		register_val = BITFVAL(SW2, voltage);
+		register_mask = BITFMASK(SW2);
+		break;
+	case MC13892_SW3:
+		register1 = REG_SW_2;
+		register_val = BITFVAL(SW3, voltage);
+		register_mask = BITFMASK(SW3);
+		break;
+	case MC13892_SW4:
+		register1 = REG_SW_3;
+		register_val = BITFVAL(SW4, voltage);
+		register_mask = BITFMASK(SW4);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_sw_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0, sw = reg->id, hi;
+
+	switch (sw) {
+	case MC13892_SW1:
+		CHECK_ERROR(pmic_read_reg(REG_SW_0,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW1);
+		break;
+	case MC13892_SW2:
+		CHECK_ERROR(pmic_read_reg(REG_SW_1,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW2);
+		break;
+	case MC13892_SW3:
+		CHECK_ERROR(pmic_read_reg(REG_SW_2,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW3);
+		break;
+	case MC13892_SW4:
+		CHECK_ERROR(pmic_read_reg(REG_SW_3,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW4);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	hi = mc13892_get_sw_hi_bit(sw);
+	mV = mc13892_get_voltage_mV(hi, voltage);
+
+	return mV;
+}
+
+static int mc13892_sw_stby_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1 = 0;
+	int voltage, sw = reg->id, mV = uV / 1000, hi;
+
+	hi = mc13892_get_sw_hi_bit(sw);
+	voltage = mc13892_get_voltage_value(hi, mV);
+
+	switch (sw) {
+	case MC13892_SW1:
+		register1 = REG_SW_0;
+		register_val = BITFVAL(SW1_STDBY, voltage);
+		register_mask = BITFMASK(SW1_STDBY);
+		break;
+	case MC13892_SW2:
+		register1 = REG_SW_1;
+		register_val = BITFVAL(SW2_STDBY, voltage);
+		register_mask = BITFMASK(SW2_STDBY);
+		break;
+	case MC13892_SW3:
+		register1 = REG_SW_2;
+		register_val = BITFVAL(SW3_STDBY, voltage);
+		register_mask = BITFMASK(SW3_STDBY);
+		break;
+	case MC13892_SW4:
+		register1 = REG_SW_3;
+		register_val = BITFVAL(SW4_STDBY, voltage);
+		register_mask = BITFMASK(SW4_STDBY);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_sw_stby_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0, sw = reg->id, hi;
+
+	switch (sw) {
+	case MC13892_SW1:
+		CHECK_ERROR(pmic_read_reg(REG_SW_0,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW1_STDBY);
+		break;
+	case MC13892_SW2:
+		CHECK_ERROR(pmic_read_reg(REG_SW_1,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW2_STDBY);
+		break;
+	case MC13892_SW3:
+		CHECK_ERROR(pmic_read_reg(REG_SW_2,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW3_STDBY);
+		break;
+	case MC13892_SW4:
+		CHECK_ERROR(pmic_read_reg(REG_SW_3,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW4_STDBY);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	hi = mc13892_get_sw_hi_bit(sw);
+	mV = mc13892_get_voltage_mV(hi, voltage);
+
+	return mV;
+}
+
+static int mc13892_sw_dvs_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1 = 0;
+	int voltage, sw = reg->id, mV = uV / 1000, hi;
+
+	hi = mc13892_get_sw_hi_bit(sw);
+	voltage = mc13892_get_voltage_value(hi, mV);
+
+	switch (sw) {
+	case MC13892_SW1:
+		register1 = REG_SW_0;
+		register_val = BITFVAL(SW1_DVS, voltage);
+		register_mask = BITFMASK(SW1_DVS);
+		break;
+	case MC13892_SW2:
+		register1 = REG_SW_1;
+		register_val = BITFVAL(SW2_DVS, voltage);
+		register_mask = BITFMASK(SW2_DVS);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_sw_dvs_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0, sw = reg->id, hi;
+
+	switch (sw) {
+	case MC13892_SW1:
+		CHECK_ERROR(pmic_read_reg(REG_SW_0,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW1_DVS);
+		break;
+	case MC13892_SW2:
+		CHECK_ERROR(pmic_read_reg(REG_SW_1,
+					  &register_val, PMIC_ALL_BITS));
+		voltage = BITFEXT(register_val, SW2_DVS);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	hi = mc13892_get_sw_hi_bit(sw);
+	mV = mc13892_get_voltage_mV(hi, voltage);
+
+	return mV;
+}
+
+static int mc13892_swbst_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(SWBST_EN, SWBST_EN_ENABLE);
+	register_mask = BITFMASK(SWBST_EN);
+	register1 = REG_SW_5;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_swbst_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(SWBST_EN, SWBST_EN_DISABLE);
+	register_mask = BITFMASK(SWBST_EN);
+	register1 = REG_SW_5;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_viohi_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VIOHI_EN, VIOHI_EN_ENABLE);
+	register_mask = BITFMASK(VIOHI_EN);
+	register1 = REG_MODE_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_viohi_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VIOHI_EN, VIOHI_EN_DISABLE);
+	register_mask = BITFMASK(VIOHI_EN);
+	register1 = REG_MODE_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vusb_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VUSB_EN, VUSB_EN_ENABLE);
+	register_mask = BITFMASK(VUSB_EN);
+	register1 = REG_USB1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vusb_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VUSB_EN, VUSB_EN_DISABLE);
+	register_mask = BITFMASK(VUSB_EN);
+	register1 = REG_USB1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vdig_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1050) && (mV < 1250))
+		voltage = VDIG_1_05V;
+	else if ((mV >= 1250) && (mV < 1650))
+		voltage = VDIG_1_25V;
+	else if ((mV >= 1650) && (mV < 1800))
+		voltage = VDIG_1_65V;
+	else
+		voltage = VDIG_1_80V;
+
+	register_val = BITFVAL(VDIG, voltage);
+	register_mask = BITFMASK(VDIG);
+	register1 = REG_SETTING_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vdig_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VDIG);
+
+	switch (voltage) {
+	case VDIG_1_05V:
+		mV = 1050;
+		break;
+	case VDIG_1_25V:
+		mV = 1250;
+		break;
+	case VDIG_1_65V:
+		mV = 1650;
+		break;
+	case VDIG_1_80V:
+		mV = 1800;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vdig_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VDIG_EN, VDIG_EN_ENABLE);
+	register_mask = BITFMASK(VDIG_EN);
+	register1 = REG_MODE_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vdig_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VDIG_EN, VDIG_EN_DISABLE);
+	register_mask = BITFMASK(VDIG_EN);
+	register1 = REG_MODE_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vpll_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1050) && (mV < 1250))
+		voltage = VPLL_1_05V;
+	else if ((mV >= 1250) && (mV < 1650))
+		voltage = VPLL_1_25V;
+	else if ((mV >= 1650) && (mV < 1800))
+		voltage = VPLL_1_65V;
+	else
+		voltage = VPLL_1_80V;
+
+	register_val = BITFVAL(VPLL, voltage);
+	register_mask = BITFMASK(VPLL);
+	register1 = REG_SETTING_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vpll_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VPLL);
+
+	switch (voltage) {
+	case VPLL_1_05V:
+		mV = 1050;
+		break;
+	case VPLL_1_25V:
+		mV = 1250;
+		break;
+	case VPLL_1_65V:
+		mV = 1650;
+		break;
+	case VPLL_1_80V:
+		mV = 1800;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vpll_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VPLL_EN, VPLL_EN_ENABLE);
+	register_mask = BITFMASK(VPLL_EN);
+	register1 = REG_MODE_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vpll_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VPLL_EN, VPLL_EN_DISABLE);
+	register_mask = BITFMASK(VPLL_EN);
+	register1 = REG_MODE_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vaudio_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 2300) && (mV < 2500))
+		voltage = VAUDIO_2_3V;
+	else if ((mV >= 2500) && (mV < 2700))
+		voltage = VAUDIO_2_5V;
+	else if ((mV >= 2700) && (mV < 2775))
+		voltage = VAUDIO_2_7V;
+	else
+		voltage = VAUDIO_2_775V;
+
+	register_val = BITFVAL(VAUDIO, voltage);
+	register_mask = BITFMASK(VAUDIO);
+	register1 = REG_SETTING_1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vaudio_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_1, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VAUDIO);
+
+	switch (voltage) {
+	case VAUDIO_2_3V:
+		mV = 2300;
+		break;
+	case VAUDIO_2_5V:
+		mV = 2500;
+		break;
+	case VAUDIO_2_7V:
+		mV = 2700;
+		break;
+	case VAUDIO_2_775V:
+		mV = 2775;
+		break;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vaudio_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VAUDIO_EN, VAUDIO_EN_ENABLE);
+	register_mask = BITFMASK(VAUDIO_EN);
+	register1 = REG_MODE_1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vaudio_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VAUDIO_EN, VAUDIO_EN_DISABLE);
+	register_mask = BITFMASK(VAUDIO_EN);
+	register1 = REG_MODE_1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vusb2_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 2400) && (mV < 2600))
+		voltage = VUSB2_2_4V;
+	else if ((mV >= 2600) && (mV < 2700))
+		voltage = VUSB2_2_6V;
+	else if ((mV >= 2700) && (mV < 2775))
+		voltage = VUSB2_2_7V;
+	else
+		voltage = VUSB2_2_775V;
+
+	register_val = BITFVAL(VUSB2, voltage);
+	register_mask = BITFMASK(VUSB2);
+	register1 = REG_SETTING_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vusb2_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VUSB2);
+
+	switch (voltage) {
+	case VUSB2_2_4V:
+		mV = 2400;
+		break;
+	case VUSB2_2_6V:
+		mV = 2600;
+		break;
+	case VUSB2_2_7V:
+		mV = 2700;
+		break;
+	case VUSB2_2_775V:
+		mV = 2775;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vusb2_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VUSB2_EN, VUSB2_EN_ENABLE);
+	register_mask = BITFMASK(VUSB2_EN);
+	register1 = REG_MODE_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vusb2_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VUSB2_EN, VUSB2_EN_DISABLE);
+	register_mask = BITFMASK(VUSB2_EN);
+	register1 = REG_MODE_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vvideo_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 2500) && (mV < 2600))
+		voltage = VVIDEO_2_5V;
+	else if ((mV >= 2600) && (mV < 2700))
+		voltage = VVIDEO_2_6V;
+	else if ((mV >= 2700) && (mV < 2775))
+		voltage = VVIDEO_2_7V;
+	else
+		voltage = VVIDEO_2_775V;
+
+	register_val = BITFVAL(VVIDEO, voltage);
+	register_mask = BITFMASK(VVIDEO);
+	register1 = REG_SETTING_1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vvideo_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_1, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VVIDEO);
+
+	switch (voltage) {
+	case VVIDEO_2_5V:
+		mV = 2500;
+		break;
+	case VVIDEO_2_6V:
+		mV = 2600;
+		break;
+	case VVIDEO_2_7V:
+		mV = 2700;
+		break;
+	case VVIDEO_2_775V:
+		mV = 2775;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vvideo_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VVIDEO_EN, VVIDEO_EN_ENABLE);
+	register_mask = BITFMASK(VVIDEO_EN);
+	register1 = REG_MODE_1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vvideo_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VVIDEO_EN, VVIDEO_EN_DISABLE);
+	register_mask = BITFMASK(VVIDEO_EN);
+	register1 = REG_MODE_1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vsd_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1800) && (mV < 2000))
+		voltage = VSD_1_8V;
+	else if ((mV >= 2000) && (mV < 2600))
+		voltage = VSD_2_0V;
+	else if ((mV >= 2600) && (mV < 2700))
+		voltage = VSD_2_6V;
+	else if ((mV >= 2700) && (mV < 2800))
+		voltage = VSD_2_7V;
+	else if ((mV >= 2800) && (mV < 2900))
+		voltage = VSD_2_8V;
+	else if ((mV >= 2900) && (mV < 3000))
+		voltage = VSD_2_9V;
+	else if ((mV >= 3000) && (mV < 3150))
+		voltage = VSD_3_0V;
+	else
+		voltage = VSD_3_15V;
+
+	register_val = BITFVAL(VSD, voltage);
+	register_mask = BITFMASK(VSD);
+	register1 = REG_SETTING_1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vsd_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_1, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VSD);
+
+	switch (voltage) {
+	case VSD_1_8V:
+		mV = 1800;
+		break;
+	case VSD_2_0V:
+		mV = 2000;
+		break;
+	case VSD_2_6V:
+		mV = 2600;
+		break;
+	case VSD_2_7V:
+		mV = 2700;
+		break;
+	case VSD_2_8V:
+		mV = 2800;
+		break;
+	case VSD_2_9V:
+		mV = 2900;
+		break;
+	case VSD_3_0V:
+		mV = 3000;
+		break;
+	case VSD_3_15V:
+		mV = 3150;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vsd_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VSD_EN, VSD_EN_ENABLE);
+	register_mask = BITFMASK(VSD_EN);
+	register1 = REG_MODE_1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vsd_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VSD_EN, VSD_EN_DISABLE);
+	register_mask = BITFMASK(VSD_EN);
+	register1 = REG_MODE_1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vcam_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1800) && (mV < 2500))
+		voltage = VCAM_1_8V;
+	else if ((mV >= 2500) && (mV < 2600))
+		voltage = VCAM_2_5V;
+	else if ((mV >= 2600) && (mV < 2750))
+		voltage = VCAM_2_6V;
+	else
+		voltage = VCAM_2_75V;
+
+	register_val = BITFVAL(VCAM, voltage);
+	register_mask = BITFMASK(VCAM);
+	register1 = REG_SETTING_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vcam_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VCAM);
+
+	switch (voltage) {
+	case VCAM_1_8V:
+		mV = 1800;
+		break;
+	case VCAM_2_5V:
+		mV = 2500;
+		break;
+	case VCAM_2_6V:
+		mV = 2600;
+		break;
+	case VCAM_2_75V:
+		mV = 2750;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vcam_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VCAM_EN, VCAM_EN_ENABLE);
+	register_mask = BITFMASK(VCAM_EN);
+	register1 = REG_MODE_1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vcam_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VCAM_EN, VCAM_EN_DISABLE);
+	register_mask = BITFMASK(VCAM_EN);
+	register1 = REG_MODE_1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vgen1_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1200) && (mV < 1500))
+		voltage = VGEN1_1_2V;
+	else if ((mV >= 1500) && (mV < 1800))
+		voltage = VGEN1_1_5V;
+	else if ((mV >= 1800) && (mV < 2775))
+		voltage = VGEN1_1_8V;
+	else
+		voltage = VGEN1_2_775V;
+
+	register_val = BITFVAL(VGEN1, voltage);
+	register_mask = BITFMASK(VGEN1);
+	register1 = REG_SETTING_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vgen1_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VGEN1);
+
+	switch (voltage) {
+	case VGEN1_1_2V:
+		mV = 1200;
+		break;
+	case VGEN1_1_5V:
+		mV = 1500;
+		break;
+	case VGEN1_1_8V:
+		mV = 1800;
+		break;
+	case VGEN1_2_775V:
+		mV = 2775;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vgen1_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN1_EN, VGEN1_EN_ENABLE);
+	register_mask = BITFMASK(VGEN1_EN);
+	register1 = REG_MODE_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vgen1_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN1_EN, VGEN1_EN_DISABLE);
+	register_mask = BITFMASK(VGEN1_EN);
+	register1 = REG_MODE_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vgen2_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1200) && (mV < 1500))
+		voltage = VGEN2_1_2V;
+	else if ((mV >= 1500) && (mV < 1600))
+		voltage = VGEN2_1_5V;
+	else if ((mV >= 1600) && (mV < 1800))
+		voltage = VGEN2_1_6V;
+	else if ((mV >= 1800) && (mV < 2700))
+		voltage = VGEN2_1_8V;
+	else if ((mV >= 2700) && (mV < 2800))
+		voltage = VGEN2_2_7V;
+	else if ((mV >= 2800) && (mV < 2900))
+		voltage = VGEN2_2_8V;
+	else if ((mV >= 2900) && (mV < 3000))
+		voltage = VGEN2_2_9V;
+	else
+		voltage = VGEN2_3_0V;
+
+	register_val = BITFVAL(VGEN2, voltage);
+	register_mask = BITFMASK(VGEN2);
+	register1 = REG_SETTING_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vgen2_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VGEN2);
+
+	switch (voltage) {
+	case VGEN2_1_2V:
+		mV = 1200;
+		break;
+	case VGEN2_1_5V:
+		mV = 1500;
+		break;
+	case VGEN2_1_6V:
+		mV = 1600;
+		break;
+	case VGEN2_1_8V:
+		mV = 1800;
+		break;
+	case VGEN2_2_7V:
+		mV = 2700;
+		break;
+	case VGEN2_2_8V:
+		mV = 2800;
+		break;
+	case VGEN2_2_9V:
+		mV = 2900;
+		break;
+	case VGEN2_3_0V:
+		mV = 3000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vgen2_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN2_EN, VGEN2_EN_ENABLE);
+	register_mask = BITFMASK(VGEN2_EN);
+	register1 = REG_MODE_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vgen2_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN2_EN, VGEN2_EN_DISABLE);
+	register_mask = BITFMASK(VGEN2_EN);
+	register1 = REG_MODE_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vgen3_set_voltage(struct regulator *reg, int uV)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int voltage, mV = uV / 1000;
+
+	if ((mV >= 1800) && (mV < 2900))
+		voltage = VGEN3_1_8V;
+	else
+		voltage = VGEN3_2_9V;
+
+	register_val = BITFVAL(VGEN3, voltage);
+	register_mask = BITFMASK(VGEN3);
+	register1 = REG_SETTING_0;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vgen3_get_voltage(struct regulator *reg)
+{
+	unsigned int register_val = 0;
+	int voltage = 0, mV = 0;
+
+	CHECK_ERROR(pmic_read_reg(REG_SETTING_0, &register_val, PMIC_ALL_BITS));
+	voltage = BITFEXT(register_val, VGEN3);
+
+	switch (voltage) {
+	case VGEN3_1_8V:
+		mV = 1800;
+		break;
+	case VGEN3_2_9V:
+		mV = 2900;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mV * 1000;
+}
+
+static int mc13892_vgen3_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN3_EN, VGEN3_EN_ENABLE);
+	register_mask = BITFMASK(VGEN3_EN);
+	register1 = REG_MODE_1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_vgen3_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+
+	register_val = BITFVAL(VGEN3_EN, VGEN3_EN_DISABLE);
+	register_mask = BITFMASK(VGEN3_EN);
+	register1 = REG_MODE_1;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_gpo_enable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int gpo = reg->id;
+
+	switch (gpo) {
+	case MC13892_GPO1:
+		register_val = BITFVAL(GPO1_EN, GPO1_EN_ENABLE);
+		register_mask = BITFMASK(GPO1_EN);
+		break;
+	case MC13892_GPO2:
+		register_val = BITFVAL(GPO2_EN, GPO2_EN_ENABLE);
+		register_mask = BITFMASK(GPO2_EN);
+		break;
+	case MC13892_GPO3:
+		register_val = BITFVAL(GPO3_EN, GPO3_EN_ENABLE);
+		register_mask = BITFMASK(GPO3_EN);
+		break;
+	case MC13892_GPO4:
+		register_val = BITFVAL(GPO4_EN, GPO4_EN_ENABLE);
+		register_mask = BITFMASK(GPO4_EN);
+		break;
+	default:
+		return -EINVAL;
+	};
+
+	register1 = REG_POWER_MISC;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static int mc13892_gpo_disable(struct regulator *reg)
+{
+	unsigned int register_val = 0, register_mask = 0;
+	unsigned int register1;
+	int gpo = reg->id;
+
+	switch (gpo) {
+	case MC13892_GPO1:
+		register_val = BITFVAL(GPO1_EN, GPO1_EN_DISABLE);
+		register_mask = BITFMASK(GPO1_EN);
+		break;
+	case MC13892_GPO2:
+		register_val = BITFVAL(GPO2_EN, GPO2_EN_DISABLE);
+		register_mask = BITFMASK(GPO2_EN);
+		break;
+	case MC13892_GPO3:
+		register_val = BITFVAL(GPO3_EN, GPO3_EN_DISABLE);
+		register_mask = BITFMASK(GPO3_EN);
+		break;
+	case MC13892_GPO4:
+		register_val = BITFVAL(GPO4_EN, GPO4_EN_DISABLE);
+		register_mask = BITFMASK(GPO4_EN);
+		break;
+	default:
+		return -EINVAL;
+	};
+
+	register1 = REG_POWER_MISC;
+
+	return (pmic_write_reg(register1, register_val, register_mask));
+}
+
+static struct regulator_ops mc13892_sw_ops = {
+	.set_voltage = mc13892_sw_set_voltage,
+	.get_voltage = mc13892_sw_get_voltage,
+};
+
+struct regulation_constraints sw_constraints = {
+	.min_uV = mV_to_uV(1100),
+	.max_uV = mV_to_uV(1850),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+static struct regulator_ops mc13892_sw_stby_ops = {
+	.set_voltage = mc13892_sw_stby_set_voltage,
+	.get_voltage = mc13892_sw_stby_get_voltage,
+};
+
+struct regulation_constraints sw_stby_constraints = {
+	.min_uV = mV_to_uV(600),
+	.max_uV = mV_to_uV(1375),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+static struct regulator_ops mc13892_sw_dvs_ops = {
+	.set_voltage = mc13892_sw_dvs_set_voltage,
+	.get_voltage = mc13892_sw_dvs_get_voltage,
+};
+
+static struct regulator_ops mc13892_swbst_ops = {
+	.enable = mc13892_swbst_enable,
+	.disable = mc13892_swbst_disable,
+};
+
+static struct regulator_ops mc13892_viohi_ops = {
+	.enable = mc13892_viohi_enable,
+	.disable = mc13892_viohi_disable,
+};
+
+static struct regulator_ops mc13892_vusb_ops = {
+	.enable = mc13892_vusb_enable,
+	.disable = mc13892_vusb_disable,
+};
+
+static struct regulator_ops mc13892_vdig_ops = {
+	.set_voltage = mc13892_vdig_set_voltage,
+	.get_voltage = mc13892_vdig_get_voltage,
+	.enable = mc13892_vdig_enable,
+	.disable = mc13892_vdig_disable,
+};
+
+struct regulation_constraints vdig_regulation_constraints = {
+	.min_uV = mV_to_uV(1050),
+	.max_uV = mV_to_uV(1800),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+static struct regulator_ops mc13892_vpll_ops = {
+	.set_voltage = mc13892_vpll_set_voltage,
+	.get_voltage = mc13892_vpll_get_voltage,
+	.enable = mc13892_vpll_enable,
+	.disable = mc13892_vpll_disable,
+};
+
+struct regulation_constraints vpll_regulation_constraints = {
+	.min_uV = mV_to_uV(1050),
+	.max_uV = mV_to_uV(1800),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+static struct regulator_ops mc13892_vusb2_ops = {
+	.set_voltage = mc13892_vusb2_set_voltage,
+	.get_voltage = mc13892_vusb2_get_voltage,
+	.enable = mc13892_vusb2_enable,
+	.disable = mc13892_vusb2_disable,
+};
+
+struct regulation_constraints vusb2_regulation_constraints = {
+	.min_uV = mV_to_uV(2400),
+	.max_uV = mV_to_uV(2775),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+static struct regulator_ops mc13892_vvideo_ops = {
+	.set_voltage = mc13892_vvideo_set_voltage,
+	.get_voltage = mc13892_vvideo_get_voltage,
+	.enable = mc13892_vvideo_enable,
+	.disable = mc13892_vvideo_disable,
+};
+
+struct regulation_constraints vvideo_regulation_constraints = {
+	.min_uV = mV_to_uV(2500),
+	.max_uV = mV_to_uV(2775),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+static struct regulator_ops mc13892_vaudio_ops = {
+	.set_voltage = mc13892_vaudio_set_voltage,
+	.get_voltage = mc13892_vaudio_get_voltage,
+	.enable = mc13892_vaudio_enable,
+	.disable = mc13892_vaudio_disable,
+};
+
+struct regulation_constraints vaudio_regulation_constraints = {
+	.min_uV = mV_to_uV(2300),
+	.max_uV = mV_to_uV(2775),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+static struct regulator_ops mc13892_vsd_ops = {
+	.set_voltage = mc13892_vsd_set_voltage,
+	.get_voltage = mc13892_vsd_get_voltage,
+	.enable = mc13892_vsd_enable,
+	.disable = mc13892_vsd_disable,
+};
+
+struct regulation_constraints vsd_regulation_constraints = {
+	.min_uV = mV_to_uV(1800),
+	.max_uV = mV_to_uV(3150),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+static struct regulator_ops mc13892_vcam_ops = {
+	.set_voltage = mc13892_vcam_set_voltage,
+	.get_voltage = mc13892_vcam_get_voltage,
+	.enable = mc13892_vcam_enable,
+	.disable = mc13892_vcam_disable,
+};
+
+struct regulation_constraints vcam_regulation_constraints = {
+	.min_uV = mV_to_uV(1800),
+	.max_uV = mV_to_uV(2750),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+static struct regulator_ops mc13892_vgen1_ops = {
+	.set_voltage = mc13892_vgen1_set_voltage,
+	.get_voltage = mc13892_vgen1_get_voltage,
+	.enable = mc13892_vgen1_enable,
+	.disable = mc13892_vgen1_disable,
+};
+
+struct regulation_constraints vgen1_regulation_constraints = {
+	.min_uV = mV_to_uV(1200),
+	.max_uV = mV_to_uV(2775),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+static struct regulator_ops mc13892_vgen2_ops = {
+	.set_voltage = mc13892_vgen2_set_voltage,
+	.get_voltage = mc13892_vgen2_get_voltage,
+	.enable = mc13892_vgen2_enable,
+	.disable = mc13892_vgen2_disable,
+};
+
+struct regulation_constraints vgen2_regulation_constraints = {
+	.min_uV = mV_to_uV(1200),
+	.max_uV = mV_to_uV(3000),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+static struct regulator_ops mc13892_vgen3_ops = {
+	.set_voltage = mc13892_vgen3_set_voltage,
+	.get_voltage = mc13892_vgen3_get_voltage,
+	.enable = mc13892_vgen3_enable,
+	.disable = mc13892_vgen3_disable,
+};
+
+struct regulation_constraints vgen3_regulation_constraints = {
+	.min_uV = mV_to_uV(1800),
+	.max_uV = mV_to_uV(2900),
+	.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+};
+
+static struct regulator_ops mc13892_gpo_ops = {
+	.enable = mc13892_gpo_enable,
+	.disable = mc13892_gpo_disable,
+};
+
+struct mc13892_regulator {
+	struct regulator regulator;
+};
+
+static struct mc13892_regulator reg_mc13892[] = {
+	{
+	 .regulator = {
+		       .name = "SW1",
+		       .id = MC13892_SW1,
+		       .ops = &mc13892_sw_ops,
+		       .constraints = &sw_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "SW2",
+		       .id = MC13892_SW2,
+		       .ops = &mc13892_sw_ops,
+		       .constraints = &sw_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "SW3",
+		       .id = MC13892_SW3,
+		       .ops = &mc13892_sw_ops,
+		       .constraints = &sw_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "SW4",
+		       .id = MC13892_SW4,
+		       .ops = &mc13892_sw_ops,
+		       .constraints = &sw_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "SW1_STBY",
+		       .id = MC13892_SW1,
+		       .ops = &mc13892_sw_stby_ops,
+		       .constraints = &sw_stby_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "SW2_STBY",
+		       .id = MC13892_SW2,
+		       .ops = &mc13892_sw_stby_ops,
+		       .constraints = &sw_stby_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "SW3_STBY",
+		       .id = MC13892_SW3,
+		       .ops = &mc13892_sw_stby_ops,
+		       .constraints = &sw_stby_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "SW4_STBY",
+		       .id = MC13892_SW4,
+		       .ops = &mc13892_sw_stby_ops,
+		       .constraints = &sw_stby_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "SW1_DVS",
+		       .id = MC13892_SW1,
+		       .ops = &mc13892_sw_dvs_ops,
+		       .constraints = &sw_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "SW2_DVS",
+		       .id = MC13892_SW2,
+		       .ops = &mc13892_sw_dvs_ops,
+		       .constraints = &sw_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "SWBST",
+		       .id = MC13892_SWBST,
+		       .ops = &mc13892_swbst_ops,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "VIOHI",
+		       .id = MC13892_VIOHI,
+		       .ops = &mc13892_viohi_ops,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "VPLL",
+		       .id = MC13892_VPLL,
+		       .ops = &mc13892_vpll_ops,
+		       .constraints = &vpll_regulation_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "VDIG",
+		       .id = MC13892_VDIG,
+		       .ops = &mc13892_vdig_ops,
+		       .constraints = &vdig_regulation_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "VSD",
+		       .id = MC13892_VSD,
+		       .ops = &mc13892_vsd_ops,
+		       .constraints = &vsd_regulation_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "VUSB2",
+		       .id = MC13892_VUSB2,
+		       .ops = &mc13892_vusb2_ops,
+		       .constraints = &vusb2_regulation_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "VVIDEO",
+		       .id = MC13892_VVIDEO,
+		       .ops = &mc13892_vvideo_ops,
+		       .constraints = &vvideo_regulation_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "VAUDIO",
+		       .id = MC13892_VAUDIO,
+		       .ops = &mc13892_vaudio_ops,
+		       .constraints = &vaudio_regulation_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "VCAM",
+		       .id = MC13892_VCAM,
+		       .ops = &mc13892_vcam_ops,
+		       .constraints = &vcam_regulation_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "VGEN1",
+		       .id = MC13892_VGEN1,
+		       .ops = &mc13892_vgen1_ops,
+		       .constraints = &vgen1_regulation_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "VGEN2",
+		       .id = MC13892_VGEN2,
+		       .ops = &mc13892_vgen2_ops,
+		       .constraints = &vgen2_regulation_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "VGEN3",
+		       .id = MC13892_VGEN3,
+		       .ops = &mc13892_vgen3_ops,
+		       .constraints = &vgen3_regulation_constraints,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "USB",
+		       .id = MC13892_VUSB,
+		       .ops = &mc13892_vusb_ops,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "GPO1",
+		       .id = MC13892_GPO1,
+		       .ops = &mc13892_gpo_ops,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "GPO2",
+		       .id = MC13892_GPO2,
+		       .ops = &mc13892_gpo_ops,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "GPO3",
+		       .id = MC13892_GPO3,
+		       .ops = &mc13892_gpo_ops,
+		       },
+	 },
+	{
+	 .regulator = {
+		       .name = "GPO4",
+		       .id = MC13892_GPO4,
+		       .ops = &mc13892_gpo_ops,
+		       },
+	 },
+};
+
+int reg_mc13892_probe(void)
+{
+	int ret11 = 0;
+	int i = 0;
+
+	for (i = 0; i < ARRAY_SIZE(reg_mc13892); i++) {
+		ret11 = regulator_register(&reg_mc13892[i].regulator);
+		regulator_set_platform_constraints(reg_mc13892[i].regulator.
+						   name,
+						   reg_mc13892[i].regulator.
+						   constraints);
+		if (ret11 < 0) {
+			printk(KERN_ERR "%s: failed to register %s err %d\n",
+			       __func__, reg_mc13892[i].regulator.name, ret11);
+			i--;
+			for (; i >= 0; i--)
+				regulator_unregister(&reg_mc13892[i].regulator);
+
+			return ret11;
+		}
+	}
+
+	printk(KERN_INFO "MC13892 regulator successfully probed\n");
+
+	return 0;
+}
+
+EXPORT_SYMBOL(reg_mc13892_probe);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MC13892 Regulator driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/regulator/reg-core.c b/drivers/regulator/reg-core.c
index 0f0f7f8..ff9c233 100644
--- a/drivers/regulator/reg-core.c
+++ b/drivers/regulator/reg-core.c
@@ -67,7 +67,7 @@ static int constraint_check_voltage(struct regulator *regulator, int uV)
 	if (!regulator->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)
 		return -EPERM;
 	if (uV > regulator->constraints->max_uV ||
-		uV < regulator->constraints->min_uV)
+	    uV < regulator->constraints->min_uV)
 		return -EINVAL;
 	return 0;
 }
@@ -79,7 +79,7 @@ static int constraint_check_current(struct regulator *regulator, int uA)
 	if (!regulator->constraints->valid_ops_mask & REGULATOR_CHANGE_CURRENT)
 		return -EPERM;
 	if (uA > regulator->constraints->max_uA ||
-		uA < regulator->constraints->min_uA)
+	    uA < regulator->constraints->min_uA)
 		return -EINVAL;
 	return 0;
 }
@@ -105,7 +105,7 @@ static int constraint_check_drms(struct regulator *regulator)
 }
 
 static ssize_t dev_load_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
+			     struct device_attribute *attr, char *buf)
 {
 	struct regulator_load *load;
 
@@ -123,6 +123,23 @@ static ssize_t regulator_uV_show(struct class_device *cdev, char *buf)
 	return sprintf(buf, "%d\n", regulator_get_voltage(regulator));
 }
 
+static ssize_t regulator_uV_store(struct class_device *cdev,
+				  const char *buf, size_t count)
+{
+	struct regulator *regulator = to_regulator(cdev);
+	int mV, ret;
+
+	mV = simple_strtoul(buf, NULL, 10);
+
+	ret = regulator_set_voltage(regulator, mV * 1000);
+	if (ret == 0)
+		printk(KERN_INFO "set voltage %d mV\n", mV);
+	else
+		printk(KERN_INFO "set voltage failed\n");
+
+	return count;
+}
+
 static ssize_t regulator_uA_show(struct class_device *cdev, char *buf)
 {
 	struct regulator *regulator = to_regulator(cdev);
@@ -170,7 +187,7 @@ regulator_constraint_uA_show(struct class_device *cdev, char *buf)
 		return sprintf(buf, "no constraints\n");
 
 	return sprintf(buf, "%d %d\n", regulator->constraints->min_uA,
-		regulator->constraints->max_uA);
+		       regulator->constraints->max_uA);
 }
 
 static ssize_t
@@ -182,7 +199,7 @@ regulator_constraint_uV_show(struct class_device *cdev, char *buf)
 		return sprintf(buf, "no constraints\n");
 
 	return sprintf(buf, "%d %d\n", regulator->constraints->min_uV,
-		regulator->constraints->max_uV);
+		       regulator->constraints->max_uV);
 }
 
 static ssize_t
@@ -225,23 +242,23 @@ static ssize_t regulator_enabled_use_count(struct class_device *cdev, char *buf)
 }
 
 static ssize_t regulator_ctl(struct class_device *cdev,
-	const char *buf, size_t count)
+			     const char *buf, size_t count)
 {
 	struct regulator *regulator = to_regulator(cdev);
 	if (buf[0] == '0') {
-		printk(KERN_WARNING"disable regulator.\n");
+		printk(KERN_WARNING "disable regulator.\n");
 		if (regulator_disable(regulator))
-			printk(KERN_ERR"disable regulator failed.\n");
+			printk(KERN_ERR "disable regulator failed.\n");
 	} else {
-		printk(KERN_WARNING"enable regulator.\n");
+		printk(KERN_WARNING "enable regulator.\n");
 		if (regulator_enable(regulator))
-			printk(KERN_ERR"enable regulator failed.\n");
+			printk(KERN_ERR "enable regulator failed.\n");
 	}
 	return count;
 }
 
 static struct class_device_attribute regulator_dev_attrs[] = {
-	__ATTR(uV, 0444, regulator_uV_show, NULL),
+	__ATTR(uV, 0666, regulator_uV_show, regulator_uV_store),
 	__ATTR(uA, 0444, regulator_uA_show, NULL),
 	__ATTR(mode, 0444, regulator_mode_show, NULL),
 	__ATTR(state, 0444, regulator_state_show, NULL),
@@ -254,16 +271,18 @@ static struct class_device_attribute regulator_dev_attrs[] = {
 	__ATTR_NULL,
 };
 
-static void regulator_dev_release(struct class_device *class_dev) {}
+static void regulator_dev_release(struct class_device *class_dev)
+{
+}
 
 struct class regulator_class = {
-	.name			= "regulator",
-	.release		= regulator_dev_release,
-	.class_dev_attrs	= regulator_dev_attrs,
+	.name = "regulator",
+	.release = regulator_dev_release,
+	.class_dev_attrs = regulator_dev_attrs,
 };
 
 static struct regulator_load *create_load_dev(struct regulator *regulator,
-	struct device *dev)
+					      struct device *dev)
 {
 	struct regulator_load *load;
 	char buf[32];
@@ -283,19 +302,19 @@ static struct regulator_load *create_load_dev(struct regulator *regulator,
 	err = device_create_file(dev, &load->dev_attr);
 	if (err < 0) {
 		printk(KERN_WARNING "%s: could not add regulator load"
-		" sysfs\n", __func__);
+		       " sysfs\n", __func__);
 		goto err_out;
 	}
 	err = sysfs_create_link(&regulator->cdev.kobj, &dev->kobj,
-		kobject_name(&dev->kobj));
+				kobject_name(&dev->kobj));
 	if (err) {
 		printk
-		(KERN_WARNING "%s : could not add device link %s err %d\n",
-			__func__, kobject_name(&dev->kobj), err);
+		    (KERN_WARNING "%s : could not add device link %s err %d\n",
+		     __func__, kobject_name(&dev->kobj), err);
 		goto err_out;
 	}
 	return load;
-err_out:
+      err_out:
 	kfree(load->dev_attr.attr.name);
 	kfree(load);
 	return NULL;
@@ -312,18 +331,17 @@ struct regulator *regulator_get(struct device *dev, const char *id)
 	mutex_lock(&list_mutex);
 
 	list_for_each_entry(r, &regulators, list) {
-		if (strcmp(id, r->name) == 0 &&
-			try_module_get(r->owner)) {
+		if (strcmp(id, r->name) == 0 && try_module_get(r->owner)) {
 			regulator = r;
 			goto found;
 		}
 	}
 	printk
-	(KERN_WARNING "regulator: Unable to get requested regulator: %s\n",
-	id);
+	    (KERN_WARNING "regulator: Unable to get requested regulator: %s\n",
+	     id);
 	mutex_unlock(&list_mutex);
 	return regulator;
-found:
+      found:
 	if (dev) {
 		load = create_load_dev(regulator, dev);
 		if (load == NULL) {
@@ -335,6 +353,7 @@ found:
 	mutex_unlock(&list_mutex);
 	return regulator;
 }
+
 EXPORT_SYMBOL_GPL(regulator_get);
 
 void regulator_put(struct regulator *regulator, struct device *dev)
@@ -355,10 +374,11 @@ void regulator_put(struct regulator *regulator, struct device *dev)
 		kfree(load);
 		goto put;
 	}
-put:
+      put:
 	module_put(regulator->owner);
 	mutex_unlock(&list_mutex);
 }
+
 EXPORT_SYMBOL_GPL(regulator_put);
 
 static int __regulator_disable(struct regulator *regulator);
@@ -387,7 +407,7 @@ static int __regulator_enable(struct regulator *regulator)
 		}
 	}
 	regulator->use_count++;
-out:
+      out:
 	return ret;
 }
 
@@ -400,6 +420,7 @@ int regulator_enable(struct regulator *regulator)
 	mutex_unlock(&regulator->mutex);
 	return ret;
 }
+
 EXPORT_SYMBOL_GPL(regulator_enable);
 
 static int __regulator_disable(struct regulator *regulator)
@@ -415,7 +436,7 @@ static int __regulator_disable(struct regulator *regulator)
 		if (regulator->parent)
 			__regulator_disable(regulator->parent);
 	}
-out:
+      out:
 	return ret;
 }
 
@@ -428,6 +449,7 @@ int regulator_disable(struct regulator *regulator)
 	mutex_unlock(&regulator->mutex);
 	return ret;
 }
+
 EXPORT_SYMBOL_GPL(regulator_disable);
 
 int regulator_is_enabled(struct regulator *regulator)
@@ -443,10 +465,11 @@ int regulator_is_enabled(struct regulator *regulator)
 	}
 
 	ret = regulator->ops->is_enabled(regulator);
-out:
+      out:
 	mutex_unlock(&regulator->mutex);
 	return ret;
 }
+
 EXPORT_SYMBOL_GPL(regulator_is_enabled);
 
 int regulator_set_voltage(struct regulator *regulator, int uV)
@@ -467,10 +490,11 @@ int regulator_set_voltage(struct regulator *regulator, int uV)
 		goto out;
 
 	ret = regulator->ops->set_voltage(regulator, uV);
-out:
+      out:
 	mutex_unlock(&regulator->mutex);
 	return ret;
 }
+
 EXPORT_SYMBOL_GPL(regulator_set_voltage);
 
 int regulator_get_voltage(struct regulator *regulator)
@@ -486,10 +510,11 @@ int regulator_get_voltage(struct regulator *regulator)
 	}
 
 	ret = regulator->ops->get_voltage(regulator);
-out:
+      out:
 	mutex_unlock(&regulator->mutex);
 	return ret;
 }
+
 EXPORT_SYMBOL_GPL(regulator_get_voltage);
 
 int regulator_set_current(struct regulator *regulator, int uA)
@@ -510,10 +535,11 @@ int regulator_set_current(struct regulator *regulator, int uA)
 		goto out;
 
 	ret = regulator->ops->set_current(regulator, uA);
-out:
+      out:
 	mutex_unlock(&regulator->mutex);
 	return ret;
 }
+
 EXPORT_SYMBOL_GPL(regulator_set_current);
 
 int regulator_get_current(struct regulator *regulator)
@@ -529,10 +555,11 @@ int regulator_get_current(struct regulator *regulator)
 	}
 
 	ret = regulator->ops->get_current(regulator);
-out:
+      out:
 	mutex_unlock(&regulator->mutex);
 	return ret;
 }
+
 EXPORT_SYMBOL_GPL(regulator_get_current);
 
 int regulator_set_mode(struct regulator *regulator, unsigned int mode)
@@ -553,10 +580,11 @@ int regulator_set_mode(struct regulator *regulator, unsigned int mode)
 		goto out;
 
 	ret = regulator->ops->set_mode(regulator, mode);
-out:
+      out:
 	mutex_unlock(&regulator->mutex);
 	return ret;
 }
+
 EXPORT_SYMBOL_GPL(regulator_set_mode);
 
 unsigned int regulator_get_mode(struct regulator *regulator)
@@ -572,14 +600,16 @@ unsigned int regulator_get_mode(struct regulator *regulator)
 	}
 
 	ret = regulator->ops->get_mode(regulator);
-out:
+      out:
 	mutex_unlock(&regulator->mutex);
 	return ret;
 }
+
 EXPORT_SYMBOL_GPL(regulator_get_mode);
 
 unsigned int regulator_get_optimum_mode(struct regulator *regulator,
-	int input_uV, int output_uV, int load_uA)
+					int input_uV, int output_uV,
+					int load_uA)
 {
 	int ret;
 
@@ -592,32 +622,36 @@ unsigned int regulator_get_optimum_mode(struct regulator *regulator,
 	}
 
 	ret = regulator->ops->get_optimum_mode(regulator,
-		input_uV, output_uV, load_uA);
-out:
+					       input_uV, output_uV, load_uA);
+      out:
 	mutex_unlock(&regulator->mutex);
 	return ret;
 }
+
 EXPORT_SYMBOL_GPL(regulator_get_optimum_mode);
 
 int regulator_register_client(struct regulator *regulator,
-	struct notifier_block *nb)
+			      struct notifier_block *nb)
 {
 	return blocking_notifier_chain_register(&regulator->notifier, nb);
 }
+
 EXPORT_SYMBOL_GPL(regulator_register_client);
 
 int regulator_unregister_client(struct regulator *regulator,
-	struct notifier_block *nb)
+				struct notifier_block *nb)
 {
 	return blocking_notifier_chain_unregister(&regulator->notifier, nb);
 }
+
 EXPORT_SYMBOL_GPL(regulator_unregister_client);
 
 int regulator_notifier_call_chain(struct regulator *regulator,
-	unsigned long event, void *data)
+				  unsigned long event, void *data)
 {
 	return blocking_notifier_call_chain(&regulator->notifier, event, data);
 }
+
 EXPORT_SYMBOL_GPL(regulator_notifier_call_chain);
 
 int regulator_register(struct regulator *regulator)
@@ -641,9 +675,9 @@ int regulator_register(struct regulator *regulator)
 	regulator->cdev.class = &regulator_class;
 	class_device_initialize(&regulator->cdev);
 	snprintf(regulator->cdev.class_id, sizeof(regulator->cdev.class_id),
-		"regulator-%ld-%s",
-		(unsigned long) atomic_inc_return(&regulator_no) - 1,
-		regulator->name);
+		 "regulator-%ld-%s",
+		 (unsigned long)atomic_inc_return(&regulator_no) - 1,
+		 regulator->name);
 
 	ret = class_device_add(&regulator->cdev);
 	if (ret == 0)
@@ -651,6 +685,7 @@ int regulator_register(struct regulator *regulator)
 	mutex_unlock(&list_mutex);
 	return ret;
 }
+
 EXPORT_SYMBOL_GPL(regulator_register);
 
 void regulator_unregister(struct regulator *regulator)
@@ -665,10 +700,11 @@ void regulator_unregister(struct regulator *regulator)
 	class_device_unregister(&regulator->cdev);
 	mutex_unlock(&list_mutex);
 }
+
 EXPORT_SYMBOL_GPL(regulator_unregister);
 
 int regulator_set_platform_source(struct regulator *regulator,
-	struct regulator *parent)
+				  struct regulator *parent)
 {
 	int err;
 
@@ -681,14 +717,16 @@ int regulator_set_platform_source(struct regulator *regulator,
 	mutex_lock(&list_mutex);
 	regulator->parent = parent;
 	err = sysfs_create_link(&regulator->cdev.kobj, &parent->cdev.kobj,
-		"source");
+				"source");
 	if (err)
-	printk(KERN_WARNING "%s : could not add device link %s err %d\n",
-			__func__, kobject_name(&parent->cdev.kobj), err);
+		printk(KERN_WARNING
+		       "%s : could not add device link %s err %d\n", __func__,
+		       kobject_name(&parent->cdev.kobj), err);
 	mutex_unlock(&list_mutex);
 
 	return 0;
 }
+
 EXPORT_SYMBOL_GPL(regulator_set_platform_source);
 
 struct regulator *regulator_get_platform_source(struct regulator *regulator)
@@ -697,10 +735,12 @@ struct regulator *regulator_get_platform_source(struct regulator *regulator)
 		return ERR_PTR(-EINVAL);
 	return regulator->parent;
 }
+
 EXPORT_SYMBOL_GPL(regulator_get_platform_source);
 
 int regulator_set_platform_constraints(const char *regulator_name,
-	struct regulation_constraints *constraints)
+				       struct regulation_constraints
+				       *constraints)
 {
 	struct regulator *regulator;
 
@@ -720,10 +760,11 @@ int regulator_set_platform_constraints(const char *regulator_name,
 	mutex_unlock(&list_mutex);
 	return -ENODEV;
 }
+
 EXPORT_SYMBOL_GPL(regulator_set_platform_constraints);
 
 static void load_change(struct regulator *regulator,
-	struct regulator_load *load, int uA)
+			struct regulator_load *load, int uA)
 {
 	struct regulator_load *l;
 	int current_uA = 0, output_uV, input_uV, err;
@@ -732,7 +773,7 @@ static void load_change(struct regulator *regulator,
 	load->uA_load = uA;
 	err = constraint_check_drms(regulator);
 	if (err < 0 || !regulator->ops->get_optimum_mode ||
-		!regulator->ops->get_voltage || !regulator->ops->set_mode)
+	    !regulator->ops->get_voltage || !regulator->ops->set_mode)
 		return;
 
 	/* get output voltage */
@@ -741,16 +782,16 @@ static void load_change(struct regulator *regulator,
 	/* get input voltage */
 	if (regulator->parent && regulator->parent->ops->get_voltage)
 		input_uV =
-		regulator->parent->ops->get_voltage(regulator->parent);
+		    regulator->parent->ops->get_voltage(regulator->parent);
 	else
 		input_uV = regulator->constraints->input_uV;
 
 	/* calc total requested load */
 	list_for_each_entry(l, &regulator->user_list, list)
-		current_uA += l->uA_load;
+	    current_uA += l->uA_load;
 
 	mode = regulator->ops->get_optimum_mode(regulator, input_uV,
-		output_uV, current_uA);
+						output_uV, current_uA);
 	err = constraint_check_mode(regulator, mode);
 	if (err < 0)
 		return;
@@ -759,7 +800,7 @@ static void load_change(struct regulator *regulator,
 }
 
 void regulator_drms_notify_load(struct regulator *regulator,
-	struct device *dev, int uA)
+				struct device *dev, int uA)
 {
 	struct regulator_load *load;
 
@@ -772,18 +813,21 @@ void regulator_drms_notify_load(struct regulator *regulator,
 	}
 	mutex_unlock(&regulator->mutex);
 }
+
 EXPORT_SYMBOL_GPL(regulator_drms_notify_load);
 
 void *regulator_get_drvdata(struct regulator *regulator)
 {
 	return regulator->reg_data;
 }
+
 EXPORT_SYMBOL_GPL(regulator_get_drvdata);
 
 void regulator_set_drvdata(struct regulator *regulator, void *data)
 {
 	regulator->reg_data = data;
 }
+
 EXPORT_SYMBOL_GPL(regulator_set_drvdata);
 
 static int __init regulator_init(void)
diff --git a/include/asm-arm/arch-mxc/pmic_external.h b/include/asm-arm/arch-mxc/pmic_external.h
index 518d30f..3b86457 100644
--- a/include/asm-arm/arch-mxc/pmic_external.h
+++ b/include/asm-arm/arch-mxc/pmic_external.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -41,7 +41,8 @@
  */
 typedef enum {
 	PMIC_MC13783 = 1,	/*!< MC13783 */
-	PMIC_SC55112 = 2	/*!< SC55112 */
+	PMIC_SC55112 = 2,	/*!< SC55112 */
+	PMIC_MC13892 = 3
 } pmic_id_t;
 
 /*!
@@ -800,6 +801,99 @@ typedef struct {
 
 #endif				/*CONFIG_MXC_PMIC_MC13783 */
 
+#if defined(CONFIG_MXC_PMIC_MC13892_MODULE) || defined(CONFIG_MXC_PMIC_MC13892)
+enum {
+	REG_INT_STATUS0 = 0,
+	REG_INT_MASK0,
+	REG_INT_SENSE0,
+	REG_INT_STATUS1,
+	REG_INT_MASK1,
+	REG_INT_SENSE1,
+	REG_PU_MODE_S,
+	REG_IDENTIFICATION,
+	REG_UNUSED0,
+	REG_ACC0,
+	REG_ACC1,		/*10 */
+	REG_UNUSED1,
+	REG_UNUSED2,
+	REG_POWER_CTL0,
+	REG_POWER_CTL1,
+	REG_POWER_CTL2,
+	REG_REGEN_ASSIGN,
+	REG_UNUSED3,
+	REG_MEM_A,
+	REG_MEM_B,
+	REG_RTC_TIME,		/*20 */
+	REG_RTC_ALARM,
+	REG_RTC_DAY,
+	REG_RTC_DAY_ALARM,
+	REG_SW_0,
+	REG_SW_1,
+	REG_SW_2,
+	REG_SW_3,
+	REG_SW_4,
+	REG_SW_5,
+	REG_SETTING_0,		/*30 */
+	REG_SETTING_1,
+	REG_MODE_0,
+	REG_MODE_1,
+	REG_POWER_MISC,
+	REG_UNUSED4,
+	REG_UNUSED5,
+	REG_UNUSED6,
+	REG_UNUSED7,
+	REG_UNUSED8,
+	REG_UNUSED9,		/*40 */
+	REG_UNUSED10,
+	REG_UNUSED11,
+	REG_ADC0,
+	REG_ADC1,
+	REG_ADC2,
+	REG_ADC3,
+	REG_ADC4,
+	REG_CHARGE,
+	REG_USB0,
+	REG_USB1,		/*50 */
+	REG_LED_CTL0,
+	REG_LED_CTL1,
+	REG_LED_CTL2,
+	REG_LED_CTL3,
+	REG_UNUSED12,
+	REG_UNUSED13,
+	REG_TRIM0,
+	REG_TRIM1,
+	REG_TEST0,
+	REG_TEST1,		/*60 */
+	REG_TEST2,
+	REG_TEST3,
+	REG_TEST4,
+	REG_ARBITRATION_SWITCHERS,	/*for compile */
+	REG_INTERRUPT_MASK_1,
+	REG_SWITCHERS_4,
+	REG_POWER_MISCELLANEOUS,
+};
+
+typedef enum {
+	place_holder1,
+} type_event;
+
+typedef enum {
+	place_holder2,
+} t_sensor;
+
+typedef enum {
+	place_holder3,
+} t_sensor_bits;
+
+extern struct i2c_client *mc13892_client;
+int pmic_i2c_24bit_read(struct i2c_client *client, unsigned int reg_num);
+int pmic_read(int reg_num, unsigned int *reg_val);
+int pmic_write(int reg_num, const unsigned int reg_val);
+void gpio_pmic_active(void);
+void pmic_event_list_init(void);
+
+#endif
+
 #ifdef CONFIG_MXC_PMIC_MC9SDZ60
 
 typedef enum {
@@ -892,7 +986,6 @@ typedef enum {
 #endif				/* MXC_PMIC_MC9SDZ60 */
 
 /* EXPORTED FUNCTIONS */
-#if defined(CONFIG_MXC_PMIC_MC13783) || defined(CONFIG_MXC_PMIC_MC9SDZ60)
 #ifdef __KERNEL__
 
 /*!
@@ -944,6 +1037,8 @@ PMIC_STATUS pmic_event_subscribe(type_event event,
 */
 PMIC_STATUS pmic_event_unsubscribe(type_event event,
 				   pmic_event_callback_t callback);
+PMIC_STATUS pmic_event_unsubscribe(type_event event,
+				   pmic_event_callback_t callback);
 /*!
 * This function is called to read all sensor bits of PMIC.
 *
@@ -963,6 +1058,9 @@ bool pmic_check_sensor(t_sensor sensor);
 */
 PMIC_STATUS pmic_get_sensors(t_sensor_bits * sensor_bits);
 
+void pmic_event_callback(type_event event);
+void pmic_event_list_init(void);
+
 #ifdef CONFIG_MXC_PMIC_MC9SDZ60
 PMIC_STATUS pmic_gpio_set_bit_val(t_mcu_gpio_reg reg, unsigned int bit,
 				  unsigned int val);
@@ -971,7 +1069,7 @@ PMIC_STATUS pmic_gpio_get_bit_val(t_mcu_gpio_reg reg, unsigned int bit,
 				  unsigned int *val);
 
 PMIC_STATUS pmic_gpio_get_designation_bit_val(unsigned int bit,
-						unsigned int *val);
+					      unsigned int *val);
 
 #endif
 
@@ -988,8 +1086,16 @@ static inline int reg_mc13783_probe(void)
 	return 0;
 };
 #endif
-#endif				/* __KERNEL__ */
+
+#ifdef CONFIG_REGULATOR_MC13892
+int reg_mc13892_probe(void);
+#else
+static inline int reg_mc13892_probe(void)
+{
+	return 0;
+};
 #endif
+#endif				/* __KERNEL__ */
 /* CONFIG_MXC_PMIC_MC13783 || CONFIG_MXC_PMIC_MC9SDZ60 */
 
 #endif				/* __ASM_ARCH_MXC_PMIC_EXTERNAL_H__ */
-- 
1.5.4.4

