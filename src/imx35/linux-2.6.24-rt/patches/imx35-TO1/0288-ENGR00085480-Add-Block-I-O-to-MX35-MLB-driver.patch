From 60e036f2791c13f438af76158dd787b1c4b27ad1 Mon Sep 17 00:00:00 2001
From: Xinyu Chen <xinyu.chen@freescale.com>
Date: Mon, 28 Jul 2008 10:07:28 +0800
Subject: [PATCH] ENGR00085480 Add Block I/O to MX35 MLB driver

Add block I/O function to MX35 MLB driver

Signed-off-by: Xinyu Chen <xinyu.chen@freescale.com>
---
 drivers/mxc/mlb/mxc_mlb.c |   58 ++++++++++++++++++++++++++++++++++++++-------
 1 files changed, 49 insertions(+), 9 deletions(-)

diff --git a/drivers/mxc/mlb/mxc_mlb.c b/drivers/mxc/mlb/mxc_mlb.c
index 7872bb7..ac9dfd2 100644
--- a/drivers/mxc/mlb/mxc_mlb.c
+++ b/drivers/mxc/mlb/mxc_mlb.c
@@ -148,7 +148,8 @@ struct mlb_dev_info {
 	/* device open count */
 	atomic_t opencnt;
 	/* wait queue head for channel */
-	wait_queue_head_t wait;
+	wait_queue_head_t rd_wq;
+	wait_queue_head_t wt_wq;
 	/* spinlock for event access */
 	spinlock_t event_lock;
 };
@@ -175,7 +176,8 @@ static struct mlb_dev_info mlb_devinfo[MLB_MINOR_DEVICES] = {
 		      },
 	 .on = ATOMIC_INIT(0),
 	 .opencnt = ATOMIC_INIT(0),
-	 .wait = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[0].wait),
+	 .rd_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[0].rd_wq),
+	 .wt_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[0].wt_wq),
 	 .event_lock = __SPIN_LOCK_UNLOCKED(mlb_devinfo[0].event_lock),
 	 },
 	{
@@ -199,7 +201,8 @@ static struct mlb_dev_info mlb_devinfo[MLB_MINOR_DEVICES] = {
 		      },
 	 .on = ATOMIC_INIT(0),
 	 .opencnt = ATOMIC_INIT(0),
-	 .wait = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[1].wait),
+	 .rd_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[1].rd_wq),
+	 .wt_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[1].wt_wq),
 	 .event_lock = __SPIN_LOCK_UNLOCKED(mlb_devinfo[1].event_lock),
 	 },
 };
@@ -334,6 +337,8 @@ void mlb_tx_isr(int minor, unsigned int cis)
 		write_lock(&chinfo->buf_lock);
 		chinfo->buf_ptr = chinfo->buf_head;
 		write_unlock(&chinfo->buf_lock);
+		/* wake up the writer */
+		wake_up_interruptible(&mlb_devinfo[minor].wt_wq);
 	}
 }
 
@@ -382,6 +387,9 @@ void mlb_rx_isr(int minor, unsigned int cis)
 			/* update the ring wpos */
 			mlb_devinfo[minor].wtpos = (wpos + 1) % RX_RING_NODES;
 
+			/* wake up the reader */
+			wake_up_interruptible(&mlb_devinfo[minor].rd_wq);
+
 			pr_debug("recv package, len:%d, rdpos: %d, wtpos: %d\n",
 				 len, rpos, mlb_devinfo[minor].wtpos);
 		} else {
@@ -616,7 +624,7 @@ static int mxc_mlb_ioctl(struct inode *inode, struct file *filp,
 static ssize_t mxc_mlb_read(struct file *filp, char __user *buf,
 			    size_t count, loff_t *f_pos)
 {
-	int minor;
+	int minor, ret;
 	int size, rdpos;
 	struct mlb_rx_ringnode *rxbuf;
 
@@ -626,8 +634,16 @@ static ssize_t mxc_mlb_read(struct file *filp, char __user *buf,
 	rxbuf = mlb_devinfo[minor].rx_bufs;
 
 	/* check the current rx buffer is available or not */
-	if (rdpos == mlb_devinfo[minor].wtpos)
-		return -EAGAIN;
+	if (rdpos == mlb_devinfo[minor].wtpos) {
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		/* if !O_NONBLOCK, we wait for recv packet */
+		ret = wait_event_interruptible(mlb_devinfo[minor].rd_wq,
+						(mlb_devinfo[minor].wtpos !=
+						rdpos));
+		if (ret < 0)
+			return ret;
+	}
 
 	size = rxbuf[rdpos].size;
 	if (size > count) {
@@ -677,9 +693,32 @@ static ssize_t mxc_mlb_write(struct file *filp, const char __user *buf,
 	/* check the current tx buffer is used or not */
 	write_lock_irqsave(&_get_txchan(minor).buf_lock, flags);
 	if (_get_txchan(minor).buf_ptr != _get_txchan(minor).buf_head) {
+		write_unlock_irqrestore(&_get_txchan(minor).buf_lock, flags);
+
 		/* there's already some datas being transmit now */
-		ret = -EAGAIN;
-		goto out;
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		/* if !O_NONBLOCK, we wait for transmit finish */
+		DEFINE_WAIT(__wait);
+		for (;;) {
+			prepare_to_wait(&mlb_devinfo[minor].wt_wq,
+					&__wait, TASK_INTERRUPTIBLE);
+
+			write_lock_irqsave(&_get_txchan(minor).buf_lock, flags);
+			if (_get_txchan(minor).buf_ptr ==
+			    _get_txchan(minor).buf_head)
+				break;
+
+			write_unlock_irqrestore(&_get_txchan(minor).buf_lock,
+						flags);
+			if (!signal_pending(current)) {
+				schedule();
+				continue;
+			}
+			return -ERESTARTSYS;
+		}
+		finish_wait(&mlb_devinfo[minor].wt_wq, &__wait);
 	}
 
 	/* copy user buffer to tx buffer */
@@ -709,7 +748,8 @@ static unsigned int mxc_mlb_poll(struct file *filp,
 
 	minor = MINOR(filp->f_dentry->d_inode->i_rdev);
 
-	poll_wait(filp, &mlb_devinfo[minor].wait, wait);
+	poll_wait(filp, &mlb_devinfo[minor].rd_wq, wait);
+	poll_wait(filp, &mlb_devinfo[minor].wt_wq, wait);
 
 	/* check the tx buffer is avaiable or not */
 	read_lock_irqsave(&_get_txchan(minor).buf_lock, flags);
-- 
1.5.4.4

