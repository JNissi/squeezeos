From cb42292c0695a3fe804dc9b1b5cd5786a921f7b4 Mon Sep 17 00:00:00 2001
From: Raj Rajasekaran <b10872@freescale.com>
Date: Fri, 30 Jan 2009 17:22:58 -0600
Subject: [PATCH] ENGR00106663 DryIce: Add support for DryIce.

Added support for DryIce Security component.

Signed-off-by: Raj Rajasekaran <b10872@freescale.com>

Acked-by: Rob Herring <r.herring@freecale.com>
---
 drivers/mxc/security/Kconfig                       |    8 +
 drivers/mxc/security/Makefile                      |    1 +
 drivers/mxc/security/dryice-regs.h                 |  207 +
 drivers/mxc/security/dryice.c                      | 1121 +++++
 drivers/mxc/security/dryice.h                      |  287 ++
 drivers/mxc/security/mxc_scc.c                     |  168 +-
 drivers/mxc/security/mxc_scc_internals.h           |  179 +-
 drivers/mxc/security/rng/Makefile                  |    7 +-
 drivers/mxc/security/rng/des_key.c                 |  385 ++
 drivers/mxc/security/rng/fsl_shw_hash.c            |   84 +
 drivers/mxc/security/rng/fsl_shw_hmac.c            |   83 +
 drivers/mxc/security/rng/fsl_shw_rand.c            |  122 +
 drivers/mxc/security/rng/fsl_shw_sym.c             |  317 ++
 drivers/mxc/security/rng/fsl_shw_wrap.c            | 1301 ++++++
 drivers/mxc/security/rng/include/rng_driver.h      |   17 +-
 drivers/mxc/security/rng/include/rng_internals.h   |  164 +-
 drivers/mxc/security/rng/include/rng_rngc.h        |  213 +-
 drivers/mxc/security/rng/include/shw_driver.h      |  461 ++-
 drivers/mxc/security/rng/include/shw_hash.h        |   96 +
 drivers/mxc/security/rng/include/shw_hmac.h        |   82 +
 drivers/mxc/security/rng/include/shw_internals.h   |    6 +-
 drivers/mxc/security/rng/rng_driver.c              |  183 +-
 drivers/mxc/security/rng/shw_driver.c              |  653 ++--
 drivers/mxc/security/rng/shw_dryice.c              |  204 +
 drivers/mxc/security/rng/shw_hash.c                |  328 ++
 drivers/mxc/security/rng/shw_hmac.c                |  145 +
 drivers/mxc/security/sahara2/fsl_shw_auth.c        |  287 +-
 drivers/mxc/security/sahara2/fsl_shw_keystore.c    |   84 +-
 drivers/mxc/security/sahara2/fsl_shw_wrap.c        |  101 +-
 drivers/mxc/security/sahara2/include/diagnostic.h  |   17 +-
 .../mxc/security/sahara2/include/fsl_platform.h    |   36 +-
 drivers/mxc/security/sahara2/include/fsl_shw.h     | 4273 ++++++++++----------
 .../security/sahara2/include/fsl_shw_keystore.h    |  235 +-
 drivers/mxc/security/sahara2/include/linux_port.h  |  777 ++--
 drivers/mxc/security/sahara2/include/portable_os.h |  524 +--
 drivers/mxc/security/sahara2/include/sah_kernel.h  |    3 +-
 drivers/mxc/security/sahara2/include/sahara.h      |  311 +-
 drivers/mxc/security/sahara2/include/sf_util.h     |    4 +-
 drivers/mxc/security/sahara2/km_adaptor.c          |   24 +-
 .../mxc/security/sahara2/sah_driver_interface.c    | 1276 +++---
 drivers/mxc/security/scc2_driver.c                 |   37 +-
 include/asm-arm/arch-mxc/mxc_scc2_driver.h         |   64 +-
 include/asm-arm/arch-mxc/mxc_scc_driver.h          |  112 +-
 43 files changed, 10386 insertions(+), 4601 deletions(-)

diff --git a/drivers/mxc/security/Kconfig b/drivers/mxc/security/Kconfig
index 2d566f3..ee3e1ea 100644
--- a/drivers/mxc/security/Kconfig
+++ b/drivers/mxc/security/Kconfig
@@ -48,6 +48,14 @@ config MXC_RNG_DEBUG
         ---help---
          This is an option for use by developers; most people should
          say N here. This enables RNG module debugging.
+ 
+config MXC_DRYICE
+        tristate "MXC DryIce Driver"
+        depends on ARCH_MX25
+        default n
+        ---help---
+          This module contains the core API's for accessing the DryIce module.
+          If you are unsure about this, say N here.
 
 config MXC_SECURITY_CORE
 	tristate
diff --git a/drivers/mxc/security/Makefile b/drivers/mxc/security/Makefile
index 3edef52..c2a1064 100644
--- a/drivers/mxc/security/Makefile
+++ b/drivers/mxc/security/Makefile
@@ -15,3 +15,4 @@ obj-$(CONFIG_MXC_SECURITY_SCC) += mxc_scc.o
 obj-$(CONFIG_MXC_SECURITY_RNG) += rng/
 obj-$(CONFIG_MXC_SECURITY_CORE) += mxc_sec_mod.o
 obj-$(CONFIG_MXC_SAHARA) += sahara2/
+obj-$(CONFIG_MXC_DRYICE) += dryice.o
diff --git a/drivers/mxc/security/dryice-regs.h b/drivers/mxc/security/dryice-regs.h
new file mode 100644
index 0000000..b8d3858
--- /dev/null
+++ b/drivers/mxc/security/dryice-regs.h
@@ -0,0 +1,207 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+#ifndef __DRYICE_REGS_H__
+#define __DRYICE_REGS_H__
+
+/***********************************************************************
+ * DryIce Register Definitions
+ ***********************************************************************/
+
+/* DryIce Time Counter MSB Reg */
+#define DTCMR   0x00
+
+/* DryIce Time Counter LSB Reg */
+#define DTCLR   0x04
+
+/* DryIce Clock Alarm MSB Reg */
+#define DCAMR   0x08
+
+/* DryIce Clock Alarm LSB Reg */
+#define DCALR   0x0c
+
+/* DryIce Control Reg */
+#define DCR     0x10
+#define DCR_TDCHL   (1 << 30)  /* Tamper Detect Config Hard Lock */
+#define DCR_TDCSL   (1 << 29)  /* Tamper Detect COnfig Soft Lock */
+#define DCR_KSHL    (1 << 28)  /* Key Select Hard Lock */
+#define DCR_KSSL    (1 << 27)  /* Key Select Soft Lock */
+#define DCR_RKHL    (1 << 26)  /* Random Key Hard Lock */
+#define DCR_RKSL    (1 << 25)  /* Random Key Soft Lock */
+#define DCR_PKRHL   (1 << 24)  /* Programmed Key Read Hard Lock */
+#define DCR_PKRSL   (1 << 23)  /* Programmed Key Read Soft Lock */
+#define DCR_PKWHL   (1 << 22)  /* Programmed Key Write Hard Lock */
+#define DCR_PKWSL   (1 << 21)  /* Programmed Key Write Soft Lock */
+#define DCR_MCHL    (1 << 20)  /* Monotonic Counter Hard Lock */
+#define DCR_MCSL    (1 << 19)  /* Monotonic Counter Soft Lock */
+#define DCR_TCHL    (1 << 18)  /* Time Counter Hard Lock */
+#define DCR_TCSL    (1 << 17)  /* Time Counter Soft Lock */
+#define DCR_FSHL    (1 << 16)  /* Failure State Hard Lock */
+#define DCR_NSA     (1 << 15)  /* Non-Secure Access */
+#define DCR_OSCB    (1 << 14)  /* Oscillator Bypass */
+#define DCR_APE     (1 << 4)   /* Alarm Pin Enable */
+#define DCR_TCE     (1 << 3)   /* Time Counter Enable */
+#define DCR_MCE     (1 << 2)   /* Monotonic Counter Enable */
+#define DCR_SWR     (1 << 0)   /* Software Reset (w/o) */
+
+/* DryIce Status Reg */
+#define DSR     0x14
+#define DSR_WTD     (1 << 23)  /* Wire-mesh Tampering Detected */
+#define DSR_ETBD    (1 << 22)  /* External Tampering B Detected */
+#define DSR_ETAD    (1 << 21)  /* External Tampering A Detected */
+#define DSR_EBD     (1 << 20)  /* External Boot Detected */
+#define DSR_SAD     (1 << 19)  /* Security Alarm Detected */
+#define DSR_TTD     (1 << 18)  /* Temperature Tampering Detected */
+#define DSR_CTD     (1 << 17)  /* Clock Tampering Detected */
+#define DSR_VTD     (1 << 16)  /* Voltage Tampering Detected */
+#define DSR_KBF     (1 << 11)  /* Key Busy Flag */
+#define DSR_WBF     (1 << 10)  /* Write Busy Flag */
+#define DSR_WNF     (1 << 9)   /* Write Next Flag */
+#define DSR_WCF     (1 << 8)   /* Write Complete Flag */
+#define DSR_WEF     (1 << 7)   /* Write Error Flag */
+#define DSR_RKE     (1 << 6)   /* Random Key Error */
+#define DSR_RKV     (1 << 5)   /* Random Key Valid */
+#define DSR_CAF     (1 << 4)   /* Clock Alarm Flag */
+#define DSR_MCO     (1 << 3)   /* Monotonic Counter Overflow */
+#define DSR_TCO     (1 << 2)   /* Time Counter Overflow */
+#define DSR_NVF     (1 << 1)   /* Non-Valid Flag */
+#define DSR_SVF     (1 << 0)   /* Security Violation Flag */
+
+#define DSR_TAMPER_BITS (DSR_WTD | DSR_ETBD | DSR_ETAD | DSR_EBD | DSR_SAD | \
+			 DSR_TTD | DSR_CTD | DSR_VTD | DSR_MCO | DSR_TCO)
+
+/* ensure that external tamper defs match register bits */
+#if DSR_WTD != DI_TAMPER_EVENT_WTD
+#error "Mismatch between DSR_WTD and DI_TAMPER_EVENT_WTD"
+#endif
+#if DSR_ETBD != DI_TAMPER_EVENT_ETBD
+#error "Mismatch between DSR_ETBD and DI_TAMPER_EVENT_ETBD"
+#endif
+#if DSR_ETAD != DI_TAMPER_EVENT_ETAD
+#error "Mismatch between DSR_ETAD and DI_TAMPER_EVENT_ETAD"
+#endif
+#if DSR_EBD != DI_TAMPER_EVENT_EBD
+#error "Mismatch between DSR_EBD and DI_TAMPER_EVENT_EBD"
+#endif
+#if DSR_SAD != DI_TAMPER_EVENT_SAD
+#error "Mismatch between DSR_SAD and DI_TAMPER_EVENT_SAD"
+#endif
+#if DSR_TTD != DI_TAMPER_EVENT_TTD
+#error "Mismatch between DSR_TTD and DI_TAMPER_EVENT_TTD"
+#endif
+#if DSR_CTD != DI_TAMPER_EVENT_CTD
+#error "Mismatch between DSR_CTD and DI_TAMPER_EVENT_CTD"
+#endif
+#if DSR_VTD != DI_TAMPER_EVENT_VTD
+#error "Mismatch between DSR_VTD and DI_TAMPER_EVENT_VTD"
+#endif
+#if DSR_MCO != DI_TAMPER_EVENT_MCO
+#error "Mismatch between DSR_MCO and DI_TAMPER_EVENT_MCO"
+#endif
+#if DSR_TCO != DI_TAMPER_EVENT_TCO
+#error "Mismatch between DSR_TCO and DI_TAMPER_EVENT_TCO"
+#endif
+
+/* DryIce Interrupt Enable Reg */
+#define DIER    0x18
+#define DIER_WNIE   (1 << 9)   /* Write Next Interrupt Enable */
+#define DIER_WCIE   (1 << 8)   /* Write Complete Interrupt Enable */
+#define DIER_WEIE   (1 << 7)   /* Write Error Interrupt Enable */
+#define DIER_RKIE   (1 << 5)   /* Random Key Interrupt Enable */
+#define DIER_CAIE   (1 << 4)   /* Clock Alarm Interrupt Enable */
+#define DIER_MOIE   (1 << 3)   /* Monotonic Overflow Interrupt En */
+#define DIER_TOIE   (1 << 2)   /* Time Overflow Interrupt Enable */
+#define DIER_SVIE   (1 << 0)   /* Security Violation Interrupt En */
+
+/* DryIce Monotonic Counter Reg */
+#define DMCR    0x1c
+
+/* DryIce Key Select Reg */
+#define DKSR    0x20
+#define DKSR_IIM_KEY           0x0
+#define DKSR_PROG_KEY          0x4
+#define DKSR_RAND_KEY          0x5
+#define DKSR_PROG_XOR_IIM_KEY  0x6
+#define DKSR_RAND_XOR_IIM_KEY  0x7
+
+/* DryIce Key Control Reg */
+#define DKCR    0x24
+#define DKCR_LRK    (1 << 0)   /* Load Random Key */
+
+/* DryIce Tamper Configuration Reg */
+#define DTCR    0x28
+#define DTCR_ETGFB_SHIFT  27   /* Ext Tamper Glitch Filter B */
+#define DTCR_ETGFB_MASK   0xf8000000
+#define DTCR_ETGFA_SHIFT  22   /* Ext Tamper Glitch Filter A */
+#define DTCR_ETGFA_MASK   0x07c00000
+#define DTCR_WTGF_SHIFT   17   /* Wire-mesh Tamper Glitch Filter */
+#define DTCR_WTGF_MASK    0x003e0000
+#define DTCR_WGFE   (1 << 16)  /* Wire-mesh Glitch Filter Enable */
+#define DTCR_SAOE   (1 << 15)  /* Security Alarm Output Enable */
+#define DTCR_MOE    (1 << 9)   /* Monotonic Overflow Enable */
+#define DTCR_TOE    (1 << 8)   /* Time Overflow Enable */
+#define DTCR_WTE    (1 << 7)   /* Wire-mesh Tampering Enable */
+#define DTCR_ETBE   (1 << 6)   /* External Tampering B Enable */
+#define DTCR_ETAE   (1 << 5)   /* External Tampering A Enable */
+#define DTCR_EBE    (1 << 4)   /* External Boot Enable */
+#define DTCR_SAIE   (1 << 3)   /* Security Alarm Input Enable */
+#define DTCR_TTE    (1 << 2)   /* Temperature Tamper Enable */
+#define DTCR_CTE    (1 << 1)   /* Clock Tamper Enable */
+#define DTCR_VTE    (1 << 0)   /* Voltage Tamper Enable */
+
+/* DryIce Analog Configuration Reg */
+#define DACR    0x2c
+#define DACR_VRC_SHIFT    6    /* Voltage Reference Configuration */
+#define DACR_VRC_MASK     0x000001c0
+#define DACR_HTDC_SHIFT   3    /* High Temperature Detect Configuration */
+#define DACR_HTDC_MASK    0x00000038
+#define DACR_LTDC_SHIFT   0    /* Low Temperature Detect Configuration */
+#define DACR_LTDC_MASK    0x00000007
+
+/* DryIce General Purpose Reg */
+#define DGPR    0x3c
+
+/* DryIce Programmed Key0-7 Regs */
+#define DPKR0   0x40
+#define DPKR1   0x44
+#define DPKR2   0x48
+#define DPKR3   0x4c
+#define DPKR4   0x50
+#define DPKR5   0x54
+#define DPKR6   0x58
+#define DPKR7   0x5c
+
+/* DryIce Random Key0-7 Regs */
+#define DRKR0   0x60
+#define DRKR1   0x64
+#define DRKR2   0x68
+#define DRKR3   0x6c
+#define DRKR4   0x70
+#define DRKR5   0x74
+#define DRKR6   0x78
+#define DRKR7   0x7c
+
+#define DI_ADDRESS_RANGE  (DRKR7 + 4)
+
+/*
+ * this doesn't really belong here but the
+ * portability layer doesn't include it
+ */
+#ifdef LINUX_KERNEL
+#define EXTERN_SYMBOL(symbol)  EXPORT_SYMBOL(symbol)
+#else
+#define EXTERN_SYMBOL(symbol)  do {} while (0)
+#endif
+
+#endif /* __DRYICE_REGS_H__ */
diff --git a/drivers/mxc/security/dryice.c b/drivers/mxc/security/dryice.c
new file mode 100644
index 0000000..9483613
--- /dev/null
+++ b/drivers/mxc/security/dryice.c
@@ -0,0 +1,1121 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+#undef DI_DEBUG        /* enable debug messages */
+#undef DI_DEBUG_REGIO  /* show register read/write */
+#undef DI_TESTING      /* include test code */
+
+#ifdef DI_DEBUG
+#define di_debug(fmt, arg...) os_printk(KERN_INFO fmt, ##arg)
+#else
+#define di_debug(fmt, arg...) do {} while (0)
+#endif
+
+#define di_info(fmt, arg...) os_printk(KERN_INFO fmt, ##arg)
+#define di_warn(fmt, arg...) os_printk(KERN_WARNING fmt, ##arg)
+
+#include <sahara2/include/portable_os.h>
+#include "dryice.h"
+#include "dryice-regs.h"
+
+/* mask of the lock-related function flags */
+#define DI_FUNC_LOCK_FLAGS  (DI_FUNC_FLAG_READ_LOCK  | \
+			     DI_FUNC_FLAG_WRITE_LOCK | \
+			     DI_FUNC_FLAG_HARD_LOCK)
+
+/*
+ * dryice hardware states
+ */
+enum di_states {
+	DI_STATE_VALID = 0,
+	DI_STATE_NON_VALID,
+	DI_STATE_FAILURE,
+};
+
+/*
+ * todo list actions
+ */
+enum todo_actions {
+	TODO_ACT_WRITE_VAL,
+	TODO_ACT_WRITE_PTR,
+	TODO_ACT_WRITE_PTR32,
+	TODO_ACT_ASSIGN,
+	TODO_ACT_WAIT_RKG,
+};
+
+/*
+ * todo list status
+ */
+enum todo_status {
+	TODO_ST_LOADING,
+	TODO_ST_READY,
+	TODO_ST_PEND_WCF,
+	TODO_ST_PEND_RKG,
+	TODO_ST_DONE,
+};
+
+OS_DEV_INIT_DCL(dryice_init)
+OS_DEV_SHUTDOWN_DCL(dryice_exit)
+OS_DEV_ISR_DCL(dryice_norm_irq)
+OS_WAIT_OBJECT(done_queue);
+OS_WAIT_OBJECT(exit_queue);
+
+struct dryice_data {
+	int busy;               /* enforce exclusive access */
+	os_lock_t busy_lock;
+	int exit_flag;          /* don't start new operations */
+
+	uint32_t baseaddr;      /* physical base address */
+	void *ioaddr;           /* virtual base address */
+
+	/* interrupt handling */
+	struct irq_struct {
+		os_interrupt_id_t irq;
+		int set;
+	} irq_norm, irq_sec;
+
+	struct clk *clk;        /* clock control */
+
+	int key_programmed;     /* key has been programmed */
+	int key_selected;       /* key has been selected */
+
+	/* callback function and cookie */
+	void (*cb_func)(di_return_t rc, unsigned long cookie);
+	unsigned long cb_cookie;
+} *di = NULL;
+
+#define TODO_LIST_LEN	12
+static struct {
+	struct td {
+		enum todo_actions action;
+		uint32_t src;
+		uint32_t dst;
+		int num;
+	} list[TODO_LIST_LEN];
+	int cur;                /* current todo pointer */
+	int num;		/* number of todo's on the list */
+	int async;              /* non-zero if list is async */
+	int status;             /* current status of the list */
+	di_return_t rc;         /* return code generated by the list */
+} todo;
+
+/*
+ * dryice register read/write functions
+ */
+#ifdef DI_DEBUG_REGIO
+static uint32_t di_read(int reg)
+{
+	uint32_t val = os_read32(di->ioaddr + (reg));
+	di_info("di_read(0x%02x) = 0x%08x\n", reg, val);
+
+	return val;
+}
+
+static void di_write(uint32_t val, int reg)
+{
+	di_info("dryice_write_reg(0x%08x, 0x%02x)\n", val, reg);
+	os_write32(di->ioaddr + (reg), val);
+}
+#else
+#define di_read(reg)        os_read32(di->ioaddr + (reg))
+#define di_write(val, reg)  os_write32(di->ioaddr + (reg), val);
+#endif
+
+/*
+ * set the dryice busy flag atomically, allowing
+ * for case where the driver is trying to exit.
+ */
+static int di_busy_set(void)
+{
+	os_lock_context_t context;
+	int rc = 0;
+
+	os_lock_save_context(di->busy_lock, context);
+	if (di->exit_flag || di->busy)
+		rc = 1;
+	else
+		di->busy = 1;
+	os_unlock_restore_context(di->busy_lock, context);
+
+	return rc;
+}
+
+/*
+ * clear the dryice busy flag
+ */
+static inline void di_busy_clear(void)
+{
+	/* don't acquire the lock because the race is benign */
+	di->busy = 0;
+
+	if (di->exit_flag)
+		os_wake_sleepers(exit_queue);
+}
+
+/*
+ * return the current state of dryice
+ * (valid, non-valid, or failure)
+ */
+static enum di_states di_state(void)
+{
+	enum di_states state = DI_STATE_VALID;
+	uint32_t dsr = di_read(DSR);
+
+	if (dsr & DSR_NVF)
+		state = DI_STATE_NON_VALID;
+	else if (dsr & DSR_SVF)
+		state = DI_STATE_FAILURE;
+
+	return state;
+}
+
+#define DI_WRITE_LOOP_CNT 0x1000
+/*
+ * the write-error flag is something that shouldn't get set
+ * during normal operation.  if it's set something is terribly
+ * wrong.  the best we can do is try to clear the bit and hope
+ * that dryice will recover.  this situation is similar to an
+ * unexpected bus fault in terms of severity.
+ */
+static void try_to_clear_wef(void)
+{
+	int cnt;
+
+	while (1) {
+		di_write(DSR_WEF, DSR);
+		for (cnt = 0; cnt < DI_WRITE_LOOP_CNT; cnt++) {
+			if ((di_read(DSR) & DSR_WEF) == 0)
+				break;
+		}
+		di_warn("WARNING: DryIce cannot clear DSR_WEF "
+			"(Write Error Flag)!\n");
+	}
+}
+
+/*
+ * write a dryice register and loop, waiting for it
+ * to complete. use only during driver initialization.
+ * returns 0 on success or 1 on write failure.
+ */
+static int di_write_loop(uint32_t val, int reg)
+{
+	int rc = 0;
+	int cnt;
+
+	di_debug("FUNC: %s\n", __func__);
+	di_write(val, reg);
+
+	for (cnt = 0; cnt < DI_WRITE_LOOP_CNT; cnt++) {
+		uint32_t dsr = di_read(DSR);
+		if (dsr & DSR_WEF) {
+			try_to_clear_wef();
+			rc = 1;
+		}
+		if (dsr & DSR_WCF)
+			break;
+	}
+	di_debug("wait_write_loop looped %d times\n", cnt);
+	if (cnt == DI_WRITE_LOOP_CNT)
+		rc = 1;
+
+	if (rc)
+		di_warn("DryIce wait_write_done: WRITE ERROR!\n");
+	return rc;
+}
+
+/*
+ * initialize the todo list. must be called
+ * before adding items to the list.
+ */
+static void todo_init(int async_flag)
+{
+	di_debug("FUNC: %s\n", __func__);
+	todo.cur = 0;
+	todo.num = 0;
+	todo.async = async_flag;
+	todo.rc = 0;
+	todo.status = TODO_ST_LOADING;
+}
+
+/*
+ * perform the current action on the todo list
+ */
+#define TC  todo.list[todo.cur]
+void todo_cur(void)
+{
+	di_debug("FUNC: %s[%d]\n", __func__, todo.cur);
+	switch (TC.action) {
+	case TODO_ACT_WRITE_VAL:
+		di_debug("  TODO_ACT_WRITE_VAL\n");
+		/* enable the write-completion interrupt */
+		todo.status = TODO_ST_PEND_WCF;
+		di_write(di_read(DIER) | DIER_WCIE, DIER);
+
+		di_write(TC.src, TC.dst);
+		break;
+
+	case TODO_ACT_WRITE_PTR32:
+		di_debug("  TODO_ACT_WRITE_PTR32\n");
+		/* enable the write-completion interrupt */
+		todo.status = TODO_ST_PEND_WCF;
+		di_write(di_read(DIER) | DIER_WCIE, DIER);
+
+		di_write(*(uint32_t *)TC.src, TC.dst);
+		break;
+
+	case TODO_ACT_WRITE_PTR:
+		{
+			uint8_t *p = (uint8_t *)TC.src;
+			uint32_t val = 0;
+			int num = TC.num;
+
+			di_debug("  TODO_ACT_WRITE_PTR\n");
+			while (num--)
+				val = (val << 8) | *p++;
+
+			/* enable the write-completion interrupt */
+			todo.status = TODO_ST_PEND_WCF;
+			di_write(di_read(DIER) | DIER_WCIE, DIER);
+
+			di_write(val, TC.dst);
+		}
+		break;
+
+	case TODO_ACT_ASSIGN:
+		di_debug("  TODO_ACT_ASSIGN\n");
+		switch (TC.num) {
+		case 1:
+			*(uint8_t *)TC.dst = TC.src;
+			break;
+		case 2:
+			*(uint16_t *)TC.dst = TC.src;
+			break;
+		case 4:
+			*(uint32_t *)TC.dst = TC.src;
+			break;
+		default:
+			di_warn("Unexpected size in TODO_ACT_ASSIGN\n");
+			break;
+		}
+		break;
+
+	case TODO_ACT_WAIT_RKG:
+		di_debug("  TODO_ACT_WAIT_RKG\n");
+		/* enable the random-key interrupt */
+		todo.status = TODO_ST_PEND_RKG;
+		di_write(di_read(DIER) | DIER_RKIE, DIER);
+		break;
+
+	default:
+		di_debug("  TODO_ACT_NOOP\n");
+		break;
+	}
+}
+
+/*
+ * called when done with the todo list.
+ * if async, it does the callback.
+ * if blocking, it wakes up the caller.
+ */
+static void todo_done(di_return_t rc)
+{
+	todo.rc = rc;
+	todo.status = TODO_ST_DONE;
+	if (todo.async) {
+		di_busy_clear();
+		if (di->cb_func)
+			di->cb_func(rc, di->cb_cookie);
+	} else
+		os_wake_sleepers(done_queue);
+}
+
+/*
+ * performs the actions sequentially from the todo list
+ * until it encounters an item that isn't ready.
+ */
+static void todo_run(void)
+{
+	di_debug("FUNC: %s\n", __func__);
+	while (todo.status == TODO_ST_READY) {
+		if (todo.cur == todo.num) {
+			todo_done(0);
+			break;
+		}
+		todo_cur();
+		if (todo.status != TODO_ST_READY)
+			break;
+		todo.cur++;
+	}
+}
+
+/*
+ * kick off the todo list by making it ready
+ */
+static void todo_start(void)
+{
+	di_debug("FUNC: %s\n", __func__);
+	todo.status = TODO_ST_READY;
+	todo_run();
+}
+
+/*
+ * blocking callers sleep here until the todo list is done
+ */
+static int todo_wait_done(void)
+{
+	di_debug("FUNC: %s\n", __func__);
+	os_sleep(done_queue, todo.status == TODO_ST_DONE, 0);
+
+	return todo.rc;
+}
+
+/*
+ * add a dryice register write to the todo list.
+ * the value to be written is supplied.
+ */
+#define todo_write_val(val, reg) \
+		todo_add(TODO_ACT_WRITE_VAL, val, reg, 0)
+
+/*
+ * add a dryice register write to the todo list.
+ * "size" bytes pointed to by addr will be written.
+ */
+#define todo_write_ptr(addr, reg, size) \
+		todo_add(TODO_ACT_WRITE_PTR, (uint32_t)addr, reg, size)
+
+/*
+ * add a dryice register write to the todo list.
+ * the word pointed to by addr will be written.
+ */
+#define todo_write_ptr32(addr, reg) \
+		todo_add(TODO_ACT_WRITE_PTR32, (uint32_t)addr, reg, 0)
+
+/*
+ * add a dryice memory write to the todo list.
+ * object can only have a size of 1, 2, or 4 bytes.
+ */
+#define todo_assign(var, val) \
+		todo_add(TODO_ACT_ASSIGN, val, (uint32_t)&(var), sizeof(var))
+
+#define todo_wait_rkg() \
+		todo_add(TODO_ACT_WAIT_RKG, 0, 0, 0)
+
+static void todo_add(int action, uint32_t src, uint32_t dst, int num)
+{
+	struct td *p = &todo.list[todo.num];
+
+	di_debug("FUNC: %s\n", __func__);
+	if (todo.num == TODO_LIST_LEN) {
+		di_warn("WARNING: DryIce todo-list overflow!\n");
+		return;
+	}
+	p->action = action;
+	p->src = src;
+	p->dst = dst;
+	p->num = num;
+	todo.num++;
+}
+
+#if defined(DI_DEBUG) || defined(DI_TESTING)
+/*
+ * print out the contents of the dryice status register
+ * with all the bits decoded
+ */
+static void show_dsr(const char *heading)
+{
+	uint32_t dsr = di_read(DSR);
+
+	di_info("%s\n", heading);
+	if (dsr & DSR_TAMPER_BITS) {
+		if (dsr & DSR_WTD)
+			di_info("Wire-mesh Tampering Detected\n");
+		if (dsr & DSR_ETBD)
+			di_info("External Tampering B Detected\n");
+		if (dsr & DSR_ETAD)
+			di_info("External Tampering A Detected\n");
+		if (dsr & DSR_EBD)
+			di_info("External Boot Detected\n");
+		if (dsr & DSR_SAD)
+			di_info("Security Alarm Detected\n");
+		if (dsr & DSR_TTD)
+			di_info("Temperature Tampering Detected\n");
+		if (dsr & DSR_CTD)
+			di_info("Clock Tampering Detected\n");
+		if (dsr & DSR_VTD)
+			di_info("Voltage Tampering Detected\n");
+		if (dsr & DSR_MCO)
+			di_info("Monotonic Counter Overflow\n");
+		if (dsr & DSR_TCO)
+			di_info("Time Counter Overflow\n");
+	} else
+		di_info("No Tamper Events Detected\n");
+
+	di_info("%d Key Busy Flag\n",           !!(dsr & DSR_KBF));
+	di_info("%d Write Busy Flag\n",         !!(dsr & DSR_WBF));
+	di_info("%d Write Next Flag\n",         !!(dsr & DSR_WNF));
+	di_info("%d Write Complete Flag\n",     !!(dsr & DSR_WCF));
+	di_info("%d Write Error Flag\n",        !!(dsr & DSR_WEF));
+	di_info("%d Random Key Error\n",        !!(dsr & DSR_RKE));
+	di_info("%d Random Key Valid\n",        !!(dsr & DSR_RKV));
+	di_info("%d Clock Alarm Flag\n",        !!(dsr & DSR_CAF));
+	di_info("%d Non-Valid Flag\n",          !!(dsr & DSR_NVF));
+	di_info("%d Security Violation Flag\n", !!(dsr & DSR_SVF));
+}
+
+/*
+ * print out a key in hex
+ */
+static void print_key(const char *tag, uint8_t *key, int bits)
+{
+	int bytes = (bits + 7) / 8;
+
+	di_info("%s", tag);
+	while (bytes--)
+		os_printk("%02x", *key++);
+	os_printk("\n");
+}
+#endif  /* defined(DI_DEBUG) || defined(DI_TESTING) */
+
+/*
+ * dryice normal interrupt service routine
+ */
+OS_DEV_ISR(dryice_norm_irq)
+{
+	/* save dryice status register */
+	uint32_t dsr = di_read(DSR);
+
+	if (dsr & DSR_WCF) {
+		/* disable the write-completion interrupt */
+		di_write(di_read(DIER) & ~DIER_WCIE, DIER);
+
+		if (todo.status == TODO_ST_PEND_WCF) {
+			if (dsr & DSR_WEF) {
+				try_to_clear_wef();
+				todo_done(DI_ERR_WRITE);
+			} else {
+				todo.cur++;
+				todo.status = TODO_ST_READY;
+				todo_run();
+			}
+		}
+	} else if (dsr & (DSR_RKV | DSR_RKE)) {
+		/* disable the random-key-gen interrupt */
+		di_write(di_read(DIER) & ~DIER_RKIE, DIER);
+
+		if (todo.status == TODO_ST_PEND_RKG) {
+			if (dsr & DSR_RKE)
+				todo_done(DI_ERR_FAIL);
+			else {
+				todo.cur++;
+				todo.status = TODO_ST_READY;
+				todo_run();
+			}
+		}
+	} else
+		di_warn("unexpected interrupt\n");
+	os_dev_isr_return(1);
+}
+
+/* write loop with error handling -- for init only */
+#define di_write_loop_goto(val, reg, rc, label) \
+		do {if (di_write_loop(val, reg)) \
+		{rc = OS_ERROR_FAIL_S; goto label; } } while (0)
+
+/*
+ * dryice driver initialization
+ */
+OS_DEV_INIT(dryice_init)
+{
+	di_return_t rc = 0;
+
+	di_info("MXC DryIce driver\n");
+
+	/* allocate memory */
+	di = os_alloc_memory(sizeof(*di), GFP_KERNEL);
+	if (di == NULL) {
+		rc = OS_ERROR_NO_MEMORY_S;
+		goto err_alloc;
+	}
+	memset(di, 0, sizeof(*di));
+	di->baseaddr = DRYICE_BASE_ADDR;
+	di->irq_norm.irq = MXC_INT_DRYICE_NORM;
+	di->irq_sec.irq = MXC_INT_DRYICE_SEC;
+
+	/* map i/o registers */
+	di->ioaddr = os_map_device(di->baseaddr, DI_ADDRESS_RANGE);
+	if (di->ioaddr == NULL) {
+		rc = OS_ERROR_FAIL_S;
+		goto err_iomap;
+	}
+
+	/* allocate locks */
+	di->busy_lock = os_lock_alloc_init();
+	if (di->busy_lock == NULL) {
+		rc = OS_ERROR_NO_MEMORY_S;
+		goto err_locks;
+	}
+
+	/* enable clocks (is there a portable way to do this?) */
+	di->clk = clk_get(NULL, "dryice_clk");
+	clk_enable(di->clk);
+
+	/* register for interrupts */
+	rc = os_register_interrupt("dry_ice", di->irq_norm.irq,
+				   OS_DEV_ISR_REF(dryice_norm_irq));
+	if (rc)
+		goto err_irqs;
+	else
+		di->irq_norm.set = 1;
+
+	/*
+	 * DRYICE HARDWARE INIT
+	 */
+
+#ifdef DI_DEBUG
+	show_dsr("DSR Pre-Initialization State");
+#endif
+
+	if (di_state() == DI_STATE_NON_VALID) {
+		uint32_t dsr = di_read(DSR);
+
+		di_debug("initializing from non-valid state\n");
+
+		/* clear security violation flag */
+		if (dsr & DSR_SVF)
+			di_write_loop_goto(DSR_SVF, DSR, rc, err_write);
+
+		/* clear tamper detect flags */
+		if (dsr & DSR_TAMPER_BITS)
+			di_write_loop_goto(DSR_TAMPER_BITS, DSR, rc, err_write);
+
+		/* initialize timers */
+		di_write_loop_goto(0, DTCLR, rc, err_write);
+		di_write_loop_goto(0, DTCMR, rc, err_write);
+		di_write_loop_goto(0, DMCR, rc, err_write);
+
+		/* clear non-valid flag */
+		di_write_loop_goto(DSR_NVF, DSR, rc, err_write);
+	}
+
+	/* set tamper events we are interested in watching */
+	di_write_loop_goto(DTCR_WTE | DTCR_ETBE | DTCR_ETAE, DTCR, rc,
+			   err_write);
+#ifdef DI_DEBUG
+	show_dsr("DSR Post-Initialization State");
+#endif
+	os_dev_init_return(OS_ERROR_OK_S);
+
+err_write:
+	/* unregister interrupts */
+	if (di->irq_norm.set)
+		os_deregister_interrupt(di->irq_norm.irq);
+	if (di->irq_sec.set)
+		os_deregister_interrupt(di->irq_sec.irq);
+
+	/* turn off clocks (is there a portable way to do this?) */
+	clk_disable(di->clk);
+	clk_put(di->clk);
+
+err_irqs:
+	/* unallocate locks */
+	os_lock_deallocate(di->busy_lock);
+
+err_locks:
+	/* unmap i/o registers */
+	os_unmap_device(di->ioaddr, DI_ADDRESS_RANGE);
+
+err_iomap:
+	/* free the dryice struct */
+	os_free_memory(di);
+
+err_alloc:
+	os_dev_init_return(rc);
+}
+
+/*
+ * dryice driver exit routine
+ */
+OS_DEV_SHUTDOWN(dryice_exit)
+{
+	/* don't allow new operations */
+	di->exit_flag = 1;
+
+	/* wait for the current operation to complete */
+	os_sleep(exit_queue, di->busy == 0, 0);
+
+	/* unregister interrupts */
+	if (di->irq_norm.set)
+		os_deregister_interrupt(di->irq_norm.irq);
+	if (di->irq_sec.set)
+		os_deregister_interrupt(di->irq_sec.irq);
+
+	/* turn off clocks (is there a portable way to do this?) */
+	clk_disable(di->clk);
+	clk_put(di->clk);
+
+	/* unallocate locks */
+	os_lock_deallocate(di->busy_lock);
+
+	/* unmap i/o registers */
+	os_unmap_device(di->ioaddr, DI_ADDRESS_RANGE);
+
+	/* free the dryice struct */
+	os_free_memory(di);
+
+	os_dev_shutdown_return(OS_ERROR_OK_S);
+}
+
+di_return_t dryice_set_programmed_key(const void *key_data, int key_bits,
+				      int flags)
+{
+	uint32_t dcr;
+	int key_bytes, reg;
+	di_return_t rc = 0;
+
+	if (di_busy_set())
+		return DI_ERR_BUSY;
+
+	if (key_data == NULL) {
+		rc = DI_ERR_INVAL;
+		goto err;
+	}
+	if (key_bits < 0 || key_bits > MAX_KEY_LEN || key_bits % 8) {
+		rc = DI_ERR_INVAL;
+		goto err;
+	}
+	if (flags & DI_FUNC_FLAG_WORD_KEY) {
+		if (key_bits % 32 || (uint32_t)key_data & 0x3) {
+			rc = DI_ERR_INVAL;
+			goto err;
+		}
+	}
+	if (di->key_programmed) {
+		rc = DI_ERR_INUSE;
+		goto err;
+	}
+	if (di_state() == DI_STATE_FAILURE) {
+		rc = DI_ERR_STATE;
+		goto err;
+	}
+	dcr = di_read(DCR);
+	if (dcr & DCR_PKWHL) {
+		rc = DI_ERR_HLOCK;
+		goto err;
+	}
+	if (dcr & DCR_PKWSL) {
+		rc = DI_ERR_SLOCK;
+		goto err;
+	}
+	key_bytes = key_bits / 8;
+
+	todo_init((flags & DI_FUNC_FLAG_ASYNC) != 0);
+
+	/* accomodate busses that can only do 32-bit transfers */
+	if (flags & DI_FUNC_FLAG_WORD_KEY) {
+		uint32_t *keyp = (void *)key_data;
+
+		for (reg = 0; reg < MAX_KEY_WORDS; reg++) {
+			if (reg < MAX_KEY_WORDS - key_bytes / 4)
+				todo_write_val(0, DPKR7 - reg * 4);
+			else {
+				todo_write_ptr32(keyp, DPKR7 - reg * 4);
+				keyp++;
+			}
+		}
+	} else {
+		uint8_t *keyp = (void *)key_data;
+
+		for (reg = 0; reg < MAX_KEY_WORDS; reg++) {
+			int size = key_bytes - (MAX_KEY_WORDS - reg - 1) * 4;
+			if (size <= 0)
+				todo_write_val(0, DPKR7 - reg * 4);
+			else {
+				if (size > 4)
+					size = 4;
+				todo_write_ptr(keyp, DPKR7 - reg * 4, size);
+				keyp += size;
+			}
+		}
+	}
+	todo_assign(di->key_programmed, 1);
+
+	if (flags & DI_FUNC_LOCK_FLAGS) {
+		dcr = di_read(DCR);
+		if (flags & DI_FUNC_FLAG_READ_LOCK) {
+			if (flags & DI_FUNC_FLAG_HARD_LOCK)
+				dcr |= DCR_PKRHL;
+			else
+				dcr |= DCR_PKRSL;
+		}
+		if (flags & DI_FUNC_FLAG_WRITE_LOCK) {
+			if (flags & DI_FUNC_FLAG_HARD_LOCK)
+				dcr |= DCR_PKWHL;
+			else
+				dcr |= DCR_PKWSL;
+		}
+		todo_write_val(dcr, DCR);
+	}
+	todo_start();
+
+	if (flags & DI_FUNC_FLAG_ASYNC)
+		return 0;
+
+	rc = todo_wait_done();
+err:
+	di_busy_clear();
+	return rc;
+}
+EXTERN_SYMBOL(dryice_set_programmed_key);
+
+di_return_t dryice_get_programmed_key(uint8_t *key_data, int key_bits)
+{
+	int reg, byte, key_bytes;
+	uint32_t dcr, dpkr;
+	di_return_t rc = 0;
+
+	if (di_busy_set())
+		return DI_ERR_BUSY;
+
+	if (key_data == NULL) {
+		rc = DI_ERR_INVAL;
+		goto err;
+	}
+	if (key_bits < 0 || key_bits > MAX_KEY_LEN || key_bits % 8) {
+		rc = DI_ERR_INVAL;
+		goto err;
+	}
+	#if 0
+	if (!di->key_programmed) {
+		rc = DI_ERR_UNSET;
+		goto err;
+	}
+	#endif
+	if (di_state() == DI_STATE_FAILURE) {
+		rc = DI_ERR_STATE;
+		goto err;
+	}
+	dcr = di_read(DCR);
+	if (dcr & DCR_PKRHL) {
+		rc = DI_ERR_HLOCK;
+		goto err;
+	}
+	if (dcr & DCR_PKRSL) {
+		rc = DI_ERR_SLOCK;
+		goto err;
+	}
+	key_bytes = key_bits / 8;
+
+	/* read key */
+	for (reg = 0; reg < MAX_KEY_WORDS; reg++) {
+		if (reg < (MAX_KEY_BYTES - key_bytes) / 4)
+			continue;
+		dpkr = di_read(DPKR7 - reg * 4);
+
+		for (byte = 0; byte < 4; byte++) {
+			if (reg * 4 + byte >= MAX_KEY_BYTES - key_bytes) {
+				int shift = 24 - byte * 8;
+				*key_data++ = (dpkr >> shift) & 0xff;
+			}
+		}
+		dpkr = 0;	/* cleared for security */
+	}
+err:
+	di_busy_clear();
+	return rc;
+}
+EXTERN_SYMBOL(dryice_get_programmed_key);
+
+di_return_t dryice_release_programmed_key(void)
+{
+	uint32_t dcr;
+	di_return_t rc = 0;
+
+	if (di_busy_set())
+		return DI_ERR_BUSY;
+
+	if (!di->key_programmed) {
+		rc = DI_ERR_UNSET;
+		goto err;
+	}
+	dcr = di_read(DCR);
+	if (dcr & DCR_PKWHL) {
+		rc = DI_ERR_HLOCK;
+		goto err;
+	}
+	if (dcr & DCR_PKWSL) {
+		rc = DI_ERR_SLOCK;
+		goto err;
+	}
+	di->key_programmed = 0;
+
+err:
+	di_busy_clear();
+	return rc;
+}
+EXTERN_SYMBOL(dryice_release_programmed_key);
+
+di_return_t dryice_set_random_key(int flags)
+{
+	uint32_t dcr;
+	di_return_t rc = 0;
+
+	if (di_busy_set())
+		return DI_ERR_BUSY;
+
+	if (di_state() == DI_STATE_FAILURE) {
+		rc = DI_ERR_STATE;
+		goto err;
+	}
+	dcr = di_read(DCR);
+	if (dcr & DCR_RKHL) {
+		rc = DI_ERR_HLOCK;
+		goto err;
+	}
+	if (dcr & DCR_RKSL) {
+		rc = DI_ERR_SLOCK;
+		goto err;
+	}
+	todo_init((flags & DI_FUNC_FLAG_ASYNC) != 0);
+
+	/* clear Random Key Error bit, if set */
+	if (di_read(DSR) & DSR_RKE)
+		todo_write_val(DSR_RKE, DCR);
+
+	/* load random key */
+	todo_write_val(DKCR_LRK, DKCR);
+
+	/* wait for RKV (valid) or RKE (error) */
+	todo_wait_rkg();
+
+	if (flags & DI_FUNC_LOCK_FLAGS) {
+		dcr = di_read(DCR);
+		if (flags & DI_FUNC_FLAG_WRITE_LOCK) {
+			if (flags & DI_FUNC_FLAG_HARD_LOCK)
+				dcr |= DCR_RKHL;
+			else
+				dcr |= DCR_RKSL;
+		}
+		todo_write_val(dcr, DCR);
+	}
+	todo_start();
+
+	if (flags & DI_FUNC_FLAG_ASYNC)
+		return 0;
+
+	rc = todo_wait_done();
+err:
+	di_busy_clear();
+	return rc;
+}
+EXTERN_SYMBOL(dryice_set_random_key);
+
+di_return_t dryice_select_key(di_key_t key, int flags)
+{
+	uint32_t dcr, dksr;
+	di_return_t rc = 0;
+
+	if (di_busy_set())
+		return DI_ERR_BUSY;
+
+	switch (key) {
+	case DI_KEY_FK:
+		dksr = DKSR_IIM_KEY;
+		break;
+	case DI_KEY_PK:
+		dksr = DKSR_PROG_KEY;
+		break;
+	case DI_KEY_RK:
+		dksr = DKSR_RAND_KEY;
+		break;
+	case DI_KEY_FPK:
+		dksr = DKSR_PROG_XOR_IIM_KEY;
+		break;
+	case DI_KEY_FRK:
+		dksr = DKSR_RAND_XOR_IIM_KEY;
+		break;
+	default:
+		rc = DI_ERR_INVAL;
+		goto err;
+	}
+	if (di->key_selected) {
+		rc = DI_ERR_INUSE;
+		goto err;
+	}
+	if (di_state() != DI_STATE_VALID) {
+		rc = DI_ERR_STATE;
+		goto err;
+	}
+	dcr = di_read(DCR);
+	if (dcr & DCR_KSHL) {
+		rc = DI_ERR_HLOCK;
+		goto err;
+	}
+	if (dcr & DCR_KSSL) {
+		rc = DI_ERR_SLOCK;
+		goto err;
+	}
+	todo_init((flags & DI_FUNC_FLAG_ASYNC) != 0);
+
+	/* select key */
+	todo_write_val(dksr, DKSR);
+
+	todo_assign(di->key_selected, 1);
+
+	if (flags & DI_FUNC_LOCK_FLAGS) {
+		dcr = di_read(DCR);
+		if (flags & DI_FUNC_FLAG_WRITE_LOCK) {
+			if (flags & DI_FUNC_FLAG_HARD_LOCK)
+				dcr |= DCR_KSHL;
+			else
+				dcr |= DCR_KSSL;
+		}
+		todo_write_val(dcr, DCR);
+	}
+	todo_start();
+
+	if (flags & DI_FUNC_FLAG_ASYNC)
+		return 0;
+
+	rc = todo_wait_done();
+err:
+	di_busy_clear();
+	return rc;
+}
+EXTERN_SYMBOL(dryice_select_key);
+
+di_return_t dryice_check_key(di_key_t *key)
+{
+	uint32_t dksr;
+	di_return_t rc = 0;
+
+	if (di_busy_set())
+		return DI_ERR_BUSY;
+
+	if (key == NULL) {
+		rc = DI_ERR_INVAL;
+		goto err;
+	}
+
+	dksr = di_read(DKSR);
+
+	if (di_state() != DI_STATE_VALID) {
+		dksr = DKSR_IIM_KEY;
+		rc = DI_ERR_STATE;
+	} else if (dksr == DI_KEY_RK || dksr == DI_KEY_FRK) {
+		if (!(di_read(DSR) & DSR_RKV)) {
+			dksr = DKSR_IIM_KEY;
+			rc = DI_ERR_UNSET;
+		}
+	}
+	switch (dksr) {
+	case DKSR_IIM_KEY:
+		*key = DI_KEY_FK;
+		break;
+	case DKSR_PROG_KEY:
+		*key = DI_KEY_PK;
+		break;
+	case DKSR_RAND_KEY:
+		*key = DI_KEY_RK;
+		break;
+	case DKSR_PROG_XOR_IIM_KEY:
+		*key = DI_KEY_FPK;
+		break;
+	case DKSR_RAND_XOR_IIM_KEY:
+		*key = DI_KEY_FRK;
+		break;
+	}
+err:
+	di_busy_clear();
+	return rc;
+}
+EXTERN_SYMBOL(dryice_check_key);
+
+di_return_t dryice_release_key_selection(void)
+{
+	uint32_t dcr;
+	di_return_t rc = 0;
+
+	if (di_busy_set())
+		return DI_ERR_BUSY;
+
+	if (!di->key_selected) {
+		rc = DI_ERR_UNSET;
+		goto err;
+	}
+	dcr = di_read(DCR);
+	if (dcr & DCR_KSHL) {
+		rc = DI_ERR_HLOCK;
+		goto err;
+	}
+	if (dcr & DCR_KSSL) {
+		rc = DI_ERR_SLOCK;
+		goto err;
+	}
+	di->key_selected = 0;
+
+err:
+	di_busy_clear();
+	return rc;
+}
+EXTERN_SYMBOL(dryice_release_key_selection);
+
+di_return_t dryice_get_tamper_event(uint32_t *events, uint32_t *timestamp,
+				    int flags)
+{
+	di_return_t rc = 0;
+
+	if (di_busy_set())
+		return DI_ERR_BUSY;
+
+	if (di_state() == DI_STATE_VALID) {
+		rc = DI_ERR_STATE;
+		goto err;
+	}
+	if (events == NULL) {
+		rc = DI_ERR_INVAL;
+		goto err;
+	}
+		*events = di_read(DSR) & DSR_TAMPER_BITS;
+	if (timestamp) {
+		if (di_state() == DI_STATE_NON_VALID)
+			*timestamp = di_read(DTCMR);
+		else
+			*timestamp = 0;
+	}
+err:
+	di_busy_clear();
+	return rc;
+}
+EXTERN_SYMBOL(dryice_get_tamper_event);
+
+di_return_t dryice_register_callback(void (*func)(di_return_t,
+						  unsigned long cookie),
+				     unsigned long cookie)
+{
+	di_return_t rc = 0;
+
+	if (di_busy_set())
+		return DI_ERR_BUSY;
+
+	di->cb_func = func;
+	di->cb_cookie = cookie;
+
+	di_busy_clear();
+	return rc;
+}
+EXTERN_SYMBOL(dryice_register_callback);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("DryIce");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/security/dryice.h b/drivers/mxc/security/dryice.h
new file mode 100644
index 0000000..8334b50
--- /dev/null
+++ b/drivers/mxc/security/dryice.h
@@ -0,0 +1,287 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+#ifndef __DRYICE_H__
+#define __DRYICE_H__
+
+
+/*!
+ * @file dryice.h
+ * @brief Definition of DryIce API.
+ */
+
+/*! @page dryice_api DryIce API
+ *
+ * Definition of the DryIce API.
+ *
+ * The DryIce API implements a software interface to the DryIce hardware
+ * block. Methods are provided to store, retrieve, generate, and  manage
+ * cryptographic keys and to monitor security tamper events.
+ *
+ * See @ref dryice_api for the DryIce API.
+ */
+
+/*!
+ * This defines the SCC key length (in bits)
+ */
+#define SCC_KEY_LEN     168
+
+/*!
+ * This defines the maximum key length (in bits)
+ */
+#define MAX_KEY_LEN     256
+#define MAX_KEY_BYTES	((MAX_KEY_LEN) / 8)
+#define MAX_KEY_WORDS	((MAX_KEY_LEN) / 32)
+
+/*!
+ * @name DryIce Function Flags
+ */
+/*@{*/
+#define DI_FUNC_FLAG_ASYNC       0x01  /*!< do not block */
+#define DI_FUNC_FLAG_READ_LOCK   0x02  /*!< set read lock for this resource */
+#define DI_FUNC_FLAG_WRITE_LOCK  0x04  /*!< set write lock for resource */
+#define DI_FUNC_FLAG_HARD_LOCK   0x08  /*!< locks will be hard (default soft) */
+#define DI_FUNC_FLAG_WORD_KEY    0x10  /*!< key provided as 32-bit words */
+/*@}*/
+
+/*!
+ * @name DryIce Tamper Events
+ */
+/*@{*/
+#define DI_TAMPER_EVENT_WTD   (1 << 23)  /*!< wire-mesh tampering det */
+#define DI_TAMPER_EVENT_ETBD  (1 << 22)  /*!< ext tampering det: input B */
+#define DI_TAMPER_EVENT_ETAD  (1 << 21)  /*!< ext tampering det: input A */
+#define DI_TAMPER_EVENT_EBD   (1 << 20)  /*!< external boot detected */
+#define DI_TAMPER_EVENT_SAD   (1 << 19)  /*!< security alarm detected */
+#define DI_TAMPER_EVENT_TTD   (1 << 18)  /*!< temperature tampering det */
+#define DI_TAMPER_EVENT_CTD   (1 << 17)  /*!< clock tampering det */
+#define DI_TAMPER_EVENT_VTD   (1 << 16)  /*!< voltage tampering det */
+#define DI_TAMPER_EVENT_MCO   (1 <<  3)  /*!< monotonic counter overflow */
+#define DI_TAMPER_EVENT_TCO   (1 <<  2)  /*!< time counter overflow */
+/*@}*/
+
+/*!
+ * DryIce Key Sources
+ */
+typedef enum di_key {
+	DI_KEY_FK,   /*!< the fused (IIM) key */
+	DI_KEY_PK,   /*!< the programmed key */
+	DI_KEY_RK,   /*!< the random key */
+	DI_KEY_FPK,  /*!< the programmed key XORed with the fused key */
+	DI_KEY_FRK,  /*!< the random key XORed with the fused key */
+} di_key_t;
+
+/*!
+ * DryIce Error Codes
+ */
+typedef enum dryice_return {
+	DI_SUCCESS = 0,  /*!< operation was successful */
+	DI_ERR_BUSY,     /*!< device or resource busy */
+	DI_ERR_STATE,    /*!< dryice is in incompatible state */
+	DI_ERR_INUSE,    /*!< resource is already in use */
+	DI_ERR_UNSET,    /*!< resource has not been initialized */
+	DI_ERR_WRITE,    /*!< error occurred during register write */
+	DI_ERR_INVAL,    /*!< invalid argument */
+	DI_ERR_FAIL,     /*!< operation failed */
+	DI_ERR_HLOCK,    /*!< resource is hard locked */
+	DI_ERR_SLOCK,    /*!< resource is soft locked */
+	DI_ERR_NOMEM,    /*!< out of memory */
+} di_return_t;
+
+/*!
+ * These functions define the DryIce API.
+ */
+
+/*!
+ * Write a given key to the Programmed Key registers in DryIce, and
+ * optionally lock the Programmed Key against either reading or further
+ * writing. The value is held until a call to the release_programmed_key
+ * interface is made, or until the appropriate HW reset if the write-lock
+ * flags are used.  Unused key bits will be zeroed.
+ *
+ * @param[in]  key_data   A pointer to the key data to be programmed, with
+ *                        the most significant byte or word first.  This
+ *                        will be interpreted as a byte pointer unless the
+ *                        WORD_KEY flag is set, in which case it will be
+ *                        treated as a word pointer and the key data will be
+ *                        read a word at a time, starting with the MSW.
+ *                        When called asynchronously, the data pointed to by
+ *                        key_data must persist until the operation completes.
+ *
+ * @param[in]  key_bits   The number of bits in the key to be stored.
+ *                        This must be a multiple of 8 and within the
+ *                        range of 0 and MAX_KEY_LEN.
+ *
+ * @param[in]  flags      This is a bit-wise OR of the flags to be passed
+ *                        to the function.  Flags can include:
+ *                        ASYNC, READ_LOCK, WRITE_LOCK, HARD_LOCK, and
+ *                        WORD_KEY.
+ *
+ * @return                Returns SUCCESS (0), BUSY if DryIce is busy, INVAL
+ *                        on invalid arguments, INUSE if key has already been
+ *                        programmed, STATE if DryIce is in the wrong state,
+ *                        HLOCK or SLOCK if the key registers are locked for
+ *                        writing, and WRITE if a write error occurs
+ *                        (See #di_return_t).
+ */
+extern di_return_t dryice_set_programmed_key(const void *key_data, int key_bits,
+					     int flags);
+
+/*!
+ * Read the Programmed Key registers and write the contents into a buffer.
+ *
+ * @param[out] key_data   A byte pointer to where the key data will be written,
+ *                        with the most significant byte being written first.
+ *
+ * @param[in]  key_bits   The number of bits of the key to be retrieved.
+ *                        This must be a multiple of 8 and within the
+ *                        range of 0 and MAX_KEY_LEN.
+ *
+ * @return                Returns SUCCESS (0), BUSY if DryIce is busy, INVAL
+ *                        on invalid arguments, UNSET if key has not been
+ *                        programmed, STATE if DryIce is in the wrong state,
+ *                        and HLOCK or SLOCK if the key registers are locked for
+ *                        reading (See #di_return_t).
+ */
+extern di_return_t dryice_get_programmed_key(uint8_t *key_data, int key_bits);
+
+/*!
+ * Allow the set_programmed_key interface to be used to write a new
+ * Programmed Key to DryIce. Note that this interface does not overwrite
+ * the value in the Programmed Key registers.
+ *
+ * @return                Returns SUCCESS (0), BUSY if DryIce is busy,
+ *                        UNSET if the key has not been previously set, and
+ *                        HLOCK or SLOCK if the key registers are locked for
+ *                        writing (See #di_return_t).
+ */
+extern di_return_t dryice_release_programmed_key(void);
+
+/*!
+ * Generate and load a new Random Key in DryIce, and optionally lock the
+ * Random Key against further change.
+ *
+ * @param[in]  flags      This is a bit-wise OR of the flags to be passed
+ *                        to the function.  Flags can include:
+ *                        ASYNC, READ_LOCK, WRITE_LOCK, and HARD_LOCK.
+ *
+ * @return                Returns SUCCESS (0), BUSY if DryIce is busy, STATE
+ *                        if DryIce is in the wrong state, FAIL if the key gen
+ *                        failed, HLOCK or SLOCK if the key registers are
+ *                        locked, and WRITE if a write error occurs
+ *                        (See #di_return_t).
+ */
+extern di_return_t dryice_set_random_key(int flags);
+
+/*!
+ * Set the key selection in DryIce to determine the key used by an
+ * encryption module such as SCC. The selection is held until a call to the
+ * Release Selected Key interface is made, or until the appropriate HW
+ * reset if the LOCK flags are used.
+ *
+ * @param[in]   key       The source of the key to be used by the SCC
+ *                        (See #di_key_t).
+ *
+ * @param[in]  flags      This is a bit-wise OR of the flags to be passed
+ *                        to the function.  Flags can include:
+ *                        ASYNC, WRITE_LOCK, and HARD_LOCK.
+ *
+ * @return                Returns SUCCESS (0), BUSY if DryIce is busy, INVAL
+ *                        on invalid arguments, INUSE if a selection has already
+ *                        been made, STATE if DryIce is in the wrong state,
+ *                        HLOCK or SLOCK if the selection register is locked,
+ *                        and WRITE if a write error occurs
+ */
+extern di_return_t dryice_select_key(di_key_t key, int flags);
+
+/*!
+ * Check which key will be used in the SCC. This is needed because in some
+ * DryIce states, the Key Select Register is overridden by a default value
+ * (the Fused/IIM key).
+ *
+ * @param[out] key        The source of the key that is currently selected for
+ *                        use by the SCC.  This may be different from the key
+ *                        specified by the dryice_select_key function
+ *                        (See #di_key_t).  This value is set even if an error
+ *                        code (except for BUSY) is returned.
+ *
+ * @return                Returns SUCCESS (0), BUSY if DryIce is busy, STATE if
+ *                        DryIce is in the wrong state, INVAL on invalid
+ *                        arguments, or UNSET if no key has been selected
+ *                        (See #di_return_t).
+ */
+extern di_return_t dryice_check_key(di_key_t *key);
+
+/*!
+ * Allow the dryice_select_key interface to be used to set a new key selection
+ * in DryIce. Note that this interface does not overwrite the value in DryIce.
+ *
+ * @return                Returns SUCCESS (0), BUSY if DryIce is busy, UNSET
+ *                        if the no selection has been made previously, and
+ *                        HLOCK or SLOCK if the selection register is locked
+ *                        (See #di_return_t).
+ */
+extern di_return_t dryice_release_key_selection(void);
+
+/*!
+ * Returns tamper-detection status bits. Also an optional timestamp when
+ * DryIce is in the Non-valid state. If DryIce is not in Failure or Non-valid
+ * state, this interface returns a failure code.
+ *
+ * @param[out] events     This is a bit-wise OR of the following events:
+ *                        WTD (Wire Mesh), ETBD (External Tamper B),
+ *                        ETAD (External Tamper A), EBD (External Boot),
+ *                        SAD (Security Alarm), TTD (Temperature Tamper),
+ *                        CTD (Clock Tamper), VTD (Voltage Tamper),
+ *                        MCO (Monolithic Counter Overflow), and
+ *                        TCO (Time Counter Overflow).
+ *
+ * @param[out] timestamp  This is the value of the time counter in seconds
+ *                        when the tamper occurred.  A timestamp will not be
+ *                        returned if a NULL pointer is specified.  If DryIce
+ *                        is not in the Non-valid state the time cannot be
+ *                        read, so a timestamp of 0 will be returned.
+ *
+ * @param[in]  flags      This is a bit-wise OR of the flags to be passed
+ *                        to the function.  Flags is ignored currently by
+ *                        this function.
+ *
+ * @return                Returns SUCCESS (0), BUSY if DryIce is busy, and
+ *                        INVAL on invalid arguments (See #di_return_t).
+ */
+extern di_return_t
+dryice_get_tamper_event(uint32_t *events, uint32_t *timestamp, int flags);
+
+/*!
+ * Provide a callback function to be called upon the completion of DryIce calls
+ * that are executed asynchronously.
+ *
+ * @param[in]  func       This is a pointer to a function of type:
+ *                        void callback(di_return_t rc, unsigned long cookie)
+ *                        The return code of the async function is passed
+ *                        back in "rc" along with the cookie provided when
+ *                        registering the callback.
+ *
+ * @param[in]  cookie     This is an "opaque" cookie of type unsigned long that
+ *                        is returned on subsequent callbacks.  It may be of any
+ *                        value.
+ *
+ * @return                Returns SUCCESS (0), or BUSY if DryIce is busy
+ *                        (See #di_return_t).
+ */
+extern di_return_t dryice_register_callback(void (*func)(di_return_t rc,
+							 unsigned long cookie),
+					    unsigned long cookie);
+
+#endif /* __DRYICE_H__ */
diff --git a/drivers/mxc/security/mxc_scc.c b/drivers/mxc/security/mxc_scc.c
index dfe5fdb..3da2d62 100644
--- a/drivers/mxc/security/mxc_scc.c
+++ b/drivers/mxc/security/mxc_scc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -14,7 +14,7 @@
 /*!
  * @file mxc_scc.c
  *
- * @brief This is the driver code for the Security Controller (SCC).  It has no device
+ * This is the driver code for the Security Controller (SCC).  It has no device
  * driver interface, so no user programs may access it.  Its interaction with
  * the Linux kernel is from calls to #scc_init() when the driver is loaded, and
  * #scc_cleanup() should the driver be unloaded.  The driver uses locking and
@@ -47,6 +47,7 @@
  *
  * @ingroup MXCSCC
 */
+#include "sahara2/include/fsl_platform.h"
 #include "sahara2/include/portable_os.h"
 #include "mxc_scc_internals.h"
 
@@ -65,7 +66,7 @@
 
 #endif
 
-/**
+/*!
  * This is the set of errors which signal that access to the SCM RAM has
  * failed or will fail.
  */
@@ -108,7 +109,7 @@ static void (*scc_callbacks[SCC_CALLBACK_SIZE]) (void);
 /*! Structure returned by #scc_get_configuration() */
 static scc_config_t scc_configuration = {
 	.driver_major_version = SCC_DRIVER_MAJOR_VERSION_1,
-	.driver_minor_version = SCC_DRIVER_MINOR_VERSION_6,
+	.driver_minor_version = SCC_DRIVER_MINOR_VERSION_8,
 	.scm_version = -1,
 	.smn_version = -1,
 	.block_size_bytes = -1,
@@ -155,9 +156,12 @@ static uint32_t scc_memory_size_bytes;
 static uint32_t scm_highest_memory_address;
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18))
-/** Pointer to SCC's clock information.  Initialized during scc_init(). */
+#ifndef SCC_CLOCK_NOT_GATED
+/*! Pointer to SCC's clock information.  Initialized during scc_init(). */
 static struct clk *scc_clk = NULL;
 #endif
+#endif
+
 /*! The lookup table for an 8-bit value.  Calculated once
  * by #scc_init_ccitt_crc().
  */
@@ -264,7 +268,7 @@ static int scc_init(void)
 				if (scc_availability == SCC_STATUS_OK) {
 					if (setup_interrupt_handling() != 0) {
 						unsigned condition;
-			/**
+			/*!
 			 * The error could be only that the SCM interrupt was
 			 * not set up.  This interrupt is always masked, so
 			 * that is not an issue.
@@ -392,11 +396,6 @@ static void scc_cleanup(void)
 
 }				/* scc_cleanup */
 
-/*static void scc_cleanup(void)
-{
-	 platform_driver_unregister(&mxc_scc_driver);
-}*/
-
 /*****************************************************************************/
 /* fn scc_get_configuration()                                                */
 /*****************************************************************************/
@@ -410,7 +409,7 @@ scc_config_t *scc_get_configuration(void)
 		scc_init();
 	}
 
-    /**
+  /*!
      * If there is no SCC, yet the driver exists, the value -1 will be in
      * the #scc_config_t fields for other than the driver versions.
      */
@@ -473,10 +472,12 @@ scc_return_t scc_zeroize_memories(void)
 /* fn scc_crypt()                                                            */
 /*****************************************************************************/
 scc_return_t
-scc_crypt(unsigned long count_in_bytes, uint8_t * data_in,
-	  uint8_t * init_vector, scc_enc_dec_t direction,
-	  scc_crypto_mode_t crypto_mode, scc_verify_t check_mode,
-	  uint8_t * data_out, unsigned long *count_out_bytes)
+scc_crypt(unsigned long count_in_bytes, const uint8_t * data_in,
+	  const uint8_t * init_vector,
+	  scc_enc_dec_t direction, scc_crypto_mode_t crypto_mode,
+	  scc_verify_t check_mode, uint8_t * data_out,
+	  unsigned long *count_out_bytes)
+
 {
 	scc_return_t return_code = SCC_RET_FAIL;
 
@@ -500,6 +501,24 @@ scc_crypt(unsigned long count_in_bytes, uint8_t * data_in,
 		count_in_bytes % SCC_BLOCK_SIZE_BYTES() != 0)
 	    || (check_mode != SCC_VERIFY_MODE_NONE &&
 		check_mode != SCC_VERIFY_MODE_CCITT_CRC)) {
+		pr_debug
+		    ("SCC: scc_crypt() count_in_bytes_ok = %d; data_in_ok = %d;"
+		     " data_out_ok = %d; iv_ok = %d\n", !(count_in_bytes == 0),
+		     !(data_in == 0), !(data_out == 0),
+		     !(crypto_mode == SCC_CBC_MODE && init_vector == NULL));
+		pr_debug("SCC: scc_crypt() mode_ok=%d; direction_ok=%d;"
+			 " size_ok=%d, check_mode_ok=%d\n",
+			 !(crypto_mode != SCC_CBC_MODE
+			   && crypto_mode != SCC_ECB_MODE),
+			 !(direction != SCC_ENCRYPT
+			   && direction != SCC_DECRYPT),
+			 !((check_mode == SCC_VERIFY_MODE_NONE
+			    && count_in_bytes % SCC_BLOCK_SIZE_BYTES() != 0)
+			   || (direction == SCC_DECRYPT
+			       && count_in_bytes % SCC_BLOCK_SIZE_BYTES() !=
+			       0)), !(check_mode != SCC_VERIFY_MODE_NONE
+				      && check_mode !=
+				      SCC_VERIFY_MODE_CCITT_CRC));
 		pr_debug("SCC: scc_crypt() detected bad argument\n");
 	} else {
 		/* Start settings for write to SCM_CONTROL register  */
@@ -951,7 +970,7 @@ copy_to_scc(const uint8_t * from, uint32_t to, unsigned long count_bytes,
 	for (i = 0; i < count_bytes; i++) {
 		uint8_t byte = *from++;	/* value from plaintext */
 
-#ifdef __BIG_ENDIAN
+#if defined(__BIG_ENDIAN) || defined(FSL_HAVE_DRYICE)
 		scm_word = (scm_word << 8) | byte;	/* add byte to SCM word */
 #else
 		scm_word = (byte << 24) | (scm_word >> 8);
@@ -1038,7 +1057,7 @@ copy_from_scc(const uint32_t from, uint8_t * to, unsigned long count_bytes,
 
 	/* If necessary, move the 'first' byte into place */
 	if (SCC_BYTE_OFFSET(running_from) != 0) {
-#ifdef __BIG_ENDIAN
+#if defined(__BIG_ENDIAN) || defined(FSL_HAVE_DRYICE)
 		scm_word <<= 8 * SCC_BYTE_OFFSET(running_from);
 #else
 		scm_word >>= 8 * SCC_BYTE_OFFSET(running_from);
@@ -1049,7 +1068,7 @@ copy_from_scc(const uint32_t from, uint8_t * to, unsigned long count_bytes,
 	while (count_bytes--) {
 		uint8_t byte;	/* value from plaintext */
 
-#ifdef __BIG_ENDIAN
+#if defined(__BIG_ENDIAN) || defined(FSL_HAVE_DRYICE)
 		byte = (scm_word & 0xff000000) >> 24;	/* pull byte out of SCM word */
 		scm_word <<= 8;	/* shift over to remove the just-pulled byte */
 #else
@@ -1446,8 +1465,10 @@ static uint32_t scc_do_crypto(int byte_count, uint32_t scm_control)
  * @param[in,out] count_out_bytes Number of bytes available at @c data_out
  */
 static scc_return_t
-scc_encrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
+scc_encrypt(uint32_t count_in_bytes, const uint8_t * data_in,
+	    uint32_t scm_control,
 	    uint8_t * data_out, int add_crc, unsigned long *count_out_bytes)
+
 {
 	scc_return_t return_code = SCC_RET_FAIL;	/* initialised for failure */
 	uint32_t input_bytes_left = count_in_bytes;	/* local copy */
@@ -1455,11 +1476,19 @@ scc_encrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
 	uint32_t bytes_to_process;	/* multi-purpose byte counter */
 	uint16_t crc = CRC_CCITT_START;	/* running CRC value */
 	crc_t *crc_ptr = NULL;	/* Reset if CRC required */
-	uint32_t scm_location = SCM_RED_MEMORY + SCM_NON_RESERVED_OFFSET;	/* byte address  into SCM RAM */
-	uint32_t scm_bytes_remaining = scc_memory_size_bytes;	/* free RED RAM */
-	uint8_t padding_buffer[PADDING_BUFFER_MAX_BYTES];	/* CRC+padding holder */
+	/* byte address  into SCM RAM */
+	uint32_t scm_location = SCM_RED_MEMORY + SCM_NON_RESERVED_OFFSET;
+	/* free RED RAM */
+	uint32_t scm_bytes_remaining = scc_memory_size_bytes;
+	/* CRC+padding holder */
+	uint8_t padding_buffer[PADDING_BUFFER_MAX_BYTES];
 	unsigned padding_byte_count = 0;	/* Reset if padding required */
 	uint32_t scm_error_status = 0;	/* No known SCM error initially */
+	uint32_t i; 	/* Counter for clear data loop */
+	uint32_t dirty_bytes;	/* Number of bytes of memory used
+					   temporarily during encryption,
+					   which need to be wiped after
+					   completion of the operation. */
 
 	/* Set location of CRC and prepare padding bytes if required */
 	if (add_crc != 0) {
@@ -1536,6 +1565,16 @@ scc_encrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
 		scm_bytes_remaining = scc_memory_size_bytes;
 
 	}			/* input_bytes_left > 0 */
+	/* Clear all red and black memory used during ephemeral encryption */
+	dirty_bytes = (count_in_bytes > scc_memory_size_bytes) ?
+			scc_memory_size_bytes : count_in_bytes;
+	
+	for (i = 0; i < dirty_bytes; i += 4) {
+		SCC_WRITE_REGISTER(SCM_RED_MEMORY + SCM_NON_RESERVED_OFFSET + i,
+					   0);
+		SCC_WRITE_REGISTER(SCM_BLACK_MEMORY + SCM_NON_RESERVED_OFFSET +
+					   i, 0);
+	}
 
 	/* If no SCM error, set OK status and save ouput byte count */
 	if (scm_error_status == 0) {
@@ -1563,7 +1602,8 @@ scc_encrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
 
  */
 static scc_return_t
-scc_decrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
+scc_decrypt(uint32_t count_in_bytes, const uint8_t * data_in,
+	    uint32_t scm_control,
 	    uint8_t * data_out, int verify_crc, unsigned long *count_out_bytes)
 {
 	scc_return_t return_code = SCC_RET_FAIL;
@@ -1571,10 +1611,16 @@ scc_decrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
 	uint32_t bytes_copied = 0;	/* running total of bytes going to user */
 	uint32_t bytes_to_copy = 0;	/* Number in this encryption 'chunk' */
 	uint16_t crc = CRC_CCITT_START;	/* running CRC value */
-	uint32_t scm_location = SCM_BLACK_MEMORY + SCM_NON_RESERVED_OFFSET;	/* next target for  ctext */
+	/* next target for	ctext */
+	uint32_t scm_location = SCM_BLACK_MEMORY + SCM_NON_RESERVED_OFFSET;
 	unsigned padding_byte_count;	/* number of bytes of padding stripped */
 	uint8_t last_two_blocks[2 * SCC_BLOCK_SIZE_BYTES()];	/* temp */
 	uint32_t scm_error_status = 0;	/* register value */
+	uint32_t i; 	/* Counter for clear data loop */
+	uint32_t dirty_bytes;	/* Number of bytes of memory used
+					   temporarily during decryption,
+					   which need to be wiped after
+					   completion of the operation. */
 
 	scm_control |= SCM_DECRYPT_MODE;
 
@@ -1713,6 +1759,16 @@ scc_decrypt(uint32_t count_in_bytes, uint8_t * data_in, uint32_t scm_control,
 	}
 
 	/* scm_error_status == 0 */
+	/* Clear all red and black memory used during ephemeral decryption */
+	dirty_bytes = (count_in_bytes > scc_memory_size_bytes) ?
+	    scc_memory_size_bytes : count_in_bytes;
+
+	for (i = 0; i < dirty_bytes; i += 4) {
+		SCC_WRITE_REGISTER(SCM_RED_MEMORY + SCM_NON_RESERVED_OFFSET + i,
+				   0);
+		SCC_WRITE_REGISTER(SCM_BLACK_MEMORY + SCM_NON_RESERVED_OFFSET +
+				   i, 0);
+	}
 	return return_code;
 }				/* scc_decrypt */
 
@@ -1741,8 +1797,8 @@ scc_alloc_slot(uint32_t value_size_bytes, uint64_t owner_id, uint32_t * slot)
 	/* ACQUIRE LOCK to prevent others from using SCC crypto */
 	spin_lock_irqsave(&scc_crypto_lock, irq_flags);
 
-	pr_debug("SCC: Allocating %d-byte slot for 0x%Lx\n", value_size_bytes,
-		 owner_id);
+	pr_debug("SCC: Allocating %d-byte slot for 0x%Lx\n",
+		 value_size_bytes, owner_id);
 
 	if ((value_size_bytes != 0) && (value_size_bytes <= SCC_MAX_KEY_SIZE)) {
 		int i;
@@ -1775,8 +1831,8 @@ scc_alloc_slot(uint32_t value_size_bytes, uint64_t owner_id, uint32_t * slot)
 /*****************************************************************************/
 /* fn verify_slot_access()                                                   */
 /*****************************************************************************/
-static inline scc_return_t verify_slot_access(uint64_t owner_id, uint32_t slot,
-					      uint32_t access_len)
+inline static scc_return_t
+verify_slot_access(uint64_t owner_id, uint32_t slot, uint32_t access_len)
 {
 	scc_return_t status = SCC_RET_FAIL;
 	if (scc_availability != SCC_STATUS_OK) {
@@ -1860,7 +1916,7 @@ scc_return_t scc_dealloc_slot(uint64_t owner_id, uint32_t slot)
  * if @c key_length exceeds the size of the slot.
  */
 scc_return_t
-scc_load_slot(uint64_t owner_id, uint32_t slot, uint8_t * key_data,
+scc_load_slot(uint64_t owner_id, uint32_t slot, const uint8_t * key_data,
 	      uint32_t key_length)
 {
 	scc_return_t status;
@@ -1886,6 +1942,17 @@ scc_load_slot(uint64_t owner_id, uint32_t slot, uint8_t * key_data,
 				pr_debug("SCC: RED copy_to_scc() failed for"
 					 " scc_load_slot()\n");
 			} else {
+				if ((key_length % 4) != 0) {
+					uint32_t zeros = 0;
+
+					/* zero-pad to get remainder bytes in correct place */
+					copy_to_scc((uint8_t *) & zeros,
+						    SCM_RED_MEMORY
+						    +
+						    scc_key_info[slot].offset +
+						    key_length,
+						    4 - (key_length % 4), NULL);
+				}
 				status = SCC_RET_OK;
 			}
 		}
@@ -1896,11 +1963,47 @@ scc_load_slot(uint64_t owner_id, uint32_t slot, uint8_t * key_data,
 	return status;
 }				/* scc_load_slot */
 
+scc_return_t
+scc_read_slot(uint64_t owner_id, uint32_t slot, uint32_t key_length,
+	      uint8_t * key_data)
+{
+	scc_return_t status;
+	unsigned long irq_flags;
+
+	/* ACQUIRE LOCK to prevent others from using SCC crypto */
+	spin_lock_irqsave(&scc_crypto_lock, irq_flags);
+
+	status = verify_slot_access(owner_id, slot, key_length);
+	if ((status == SCC_RET_OK) && (key_data != NULL)) {
+		status = SCC_RET_FAIL;	/* reset expectations */
+
+		if (key_length > SCC_KEY_SLOT_SIZE) {
+			pr_debug
+			    ("SCC: scc_read_slot() rejecting key of %d bytes.\n",
+			     key_length);
+			status = SCC_RET_INSUFFICIENT_SPACE;
+		} else {
+			if (copy_from_scc
+			    (SCM_RED_MEMORY + scc_key_info[slot].offset,
+			     key_data, key_length, NULL)) {
+				pr_debug("SCC: RED copy_from_scc() failed for"
+					 " scc_read_slot()\n");
+			} else {
+				status = SCC_RET_OK;
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(&scc_crypto_lock, irq_flags);
+
+	return status;
+}				/* scc_read_slot */
+
 /*****************************************************************************/
 /* fn scc_encrypt_slot()                                                     */
 /*****************************************************************************/
 /*!
- * Allocate a key slot to fit the requested size.
+ * Encrypt the key data stored in a slot.
  *
  * @param owner_id      Value of owner of slot
  * @param slot          Handle of slot
@@ -2064,7 +2167,7 @@ scc_get_slot_info(uint64_t owner_id, uint32_t slot, uint32_t * address,
  *
  * @internal
  *
- * Crypto under 230 or so bytes is done after the first loop, all
+ * On a Tahiti, crypto under 230 or so bytes is done after the first loop, all
  * the way up to five sets of spins for 1024 bytes.  (8- and 16-byte functions
  * are done when we first look.  Zeroizing takes one pass around.
  */
@@ -2074,7 +2177,6 @@ static void scc_wait_completion(void)
 
 	/* check for completion by polling */
 	while (!is_cipher_done() && (i++ < SCC_CIPHER_MAX_POLL_COUNT)) {
-		/* kill time if loop not optimized away */
 		udelay(10);
 	}
 	pr_debug("SCC: Polled DONE %d times\n", i);
diff --git a/drivers/mxc/security/mxc_scc_internals.h b/drivers/mxc/security/mxc_scc_internals.h
index ad318c0..ce583cd 100644
--- a/drivers/mxc/security/mxc_scc_internals.h
+++ b/drivers/mxc/security/mxc_scc_internals.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -32,7 +32,7 @@
  *
  * @ingroup MXCSCC
  */
-
+#if 0
 #include <linux/version.h>	/* Current version Linux kernel */
 #include <linux/module.h>	/* Basic support for loadable modules,
 				   printk */
@@ -42,35 +42,81 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>	/* IRQ / interrupt definitions */
 #include <asm/io.h>		/* ioremap() */
+#endif
 #include <asm/arch/mxc_scc_driver.h>
 
 /* Get handle on certain per-platform symbols */
+#ifdef TAHITI
+#include <asm/arch/mx2.h>
+
+/*
+ * Mark the SCC as always there... as Tahiti is not officially supported by
+ * driver.  Porting opportunity.
+ */
+#define SCC_ENABLED() (1)
+
+#elif defined(MXC)
 
 #include <asm/arch/iim.h>
 #include <asm/arch/mxc_scc.h>
 
-/*!
+#ifdef SCC_FUSE
+
+/*
  * This macro is used to determine whether the SCC is enabled/available
  * on the platform.  This macro may need to be ported.
  */
-#define SCC_FUSE IO_ADDRESS(IIM_BASE_ADDR + MXC_IIMHWV1)
 #define SCC_ENABLED() ((SCC_FUSE & MXC_IIMHWV1_SCC_DISABLE) == 0)
 
+#else
+
+#warning SCC_FUSE not defined, assuming the SCC is enabled.
+#define SCC_ENABLED() (1)
+
+#endif
+
+#else				/* neither TAHITI nor MXC */
+
+#error Do not understand target architecture
+
+#endif				/* TAHITI */
+
+/* Temporarily define compile-time flags to make Doxygen happy. */
+#ifdef DOXYGEN_HACK
+/*! @addtogroup scccompileflags */
+/*! @{ */
+
+/*! @def NO_SMN_INTERRUPT
+ * The SMN interrupt is not wired to the CPU at all.
+ */
+#define NO_SMN_INTERRUPT
+
+/*!
+ * Register an interrupt handler for the SMN as well as
+ * the SCM.  In some implementations, the SMN is not connected at all (see
+ * #NO_SMN_INTERRUPT), and in others, it is on the same interrupt line as the
+ * SCM.  When defining this flag, the SMN interrupt should be on a separate
+ * line from the SCM interrupt.
+ */
+
+#define USE_SMN_INTERRUPT
+
 /*!
  * Turn on generation of run-time operational, debug, and error messages
  */
+#define SCC_DEBUG
 
 /*!
  * Turn on generation of run-time logging of access to the SCM and SMN
  * registers.
  */
-//#define SCC_REGISTER_DEBUG
+#define SCC_REGISTER_DEBUG
 
 /*!
  * Turn on generation of run-time logging of access to the SCM Red and
  * Black memories.  Will only work if #SCC_REGISTER_DEBUG is also defined.
  */
-//#define SCC_RAM_DEBUG
+#define SCC_RAM_DEBUG
 
 /*!
  *  If the driver finds the SCC in HEALTH_CHECK state, go ahead and
@@ -79,6 +125,66 @@
 #define SCC_BRINGUP
 
 /*!
+ * Expected to come from platform header files or compile command line.
+ * This symbol must be the address of the SCC
+ */
+#define SCC_BASE
+
+/*!
+ *  This must be the interrupt line number of the SCM interrupt.
+ */
+#define INT_SCM
+
+/*!
+ *  if #USE_SMN_INTERRUPT is defined, this must be the interrupt line number of
+ *  the SMN interrupt.
+ */
+#define INT_SMN
+
+/*!
+ * Define the number of Stored Keys which the SCC driver will make available.
+ * Value shall be from 0 to 20.  Default is zero (0).
+ */
+#define SCC_KEY_SLOTS 
+
+/*!
+ * Make sure that this flag is defined if compiling for a Little-Endian
+ * platform.  Linux Kernel builds provide this flag.
+ */
+#define __LITTLE_ENDIAN
+
+/*!
+ * Make sure that this flag is defined if compiling for a Big-Endian platform.
+ * Linux Kernel builds provide this flag.
+ */
+#define __BIG_ENDIAN
+
+/*!
+ * Read a 32-bit register value from a 'peripheral'.  Standard Linux/Unix
+ * macro.
+ *
+ * @param offset   Bus address of register to be read
+ *
+ * @return The value of the register
+ */
+#define readl(offset)
+
+/*!
+ * Write a 32-bit value to a register in a 'peripheral'.  Standard Linux/Unix
+ * macro.
+ *
+ * @param value    The 32-bit value to store
+ * @param offset   Bus address of register to be written
+ *
+ * return (none)
+ */
+#define writel(value,offset)
+
+	   /*! @} *//* end group scccompileflags */
+
+#endif				/* DOXYGEN_HACK */
+
+/*!
  * Define the number of Stored Keys which the SCC driver will make available.
  * Value shall be from 0 to 20.  Default is zero (0).
  */
@@ -93,8 +199,6 @@
 #error Bad value for SCC_KEY_SLOTS
 #endif
 
-#endif
-
 /*!
  * Maximum length of key/secret value which can be stored in SCC.
  */
@@ -112,6 +216,8 @@
  */
 #define SCM_NON_RESERVED_OFFSET (SCC_KEY_SLOTS * SCC_KEY_SLOT_SIZE)
 
+#endif
+
 /* These come for free with Linux, but may need to be set in a port. */
 #ifndef __BIG_ENDIAN
 #ifndef __LITTLE_ENDIAN
@@ -133,6 +239,22 @@
 /*! Initial CRC value for CCITT-CRC calculation. */
 #define CRC_CCITT_START 0xFFFF
 
+#ifdef TAHITI
+
+/*!
+ * The SCC_BASE has to be SMN_BASE_ADDR on TAHITI, as the banks of
+ * registers are swapped in place.
+ */
+#define SCC_BASE       SMN_BASE_ADDR
+
+/*! The interrupt number for the SCC (SCM only!) on Tahiti */
+#define INT_SCC_SCM       62
+
+/*! Tahiti does not have the SMN interrupt wired to the CPU.  */
+#define NO_SMN_INTERRUPT
+
+#endif				/* TAHITI */
+
 /*! Number of times to spin between polling of SCC while waiting for cipher
  *  or zeroizing function to complete. See also #SCC_CIPHER_MAX_POLL_COUNT. */
 #define SCC_SPIN_COUNT 1000
@@ -144,7 +266,7 @@
 /*!
  * @def SCC_READ_REGISTER
  * Read a 32-bit value from an SCC register.  Macro which depends upon
- * #scc_base.  Linux __raw_readl()/__raw_writel() macros operate on 32-bit quantities, as
+ * #scc_base.  Linux readl()/writel() macros operate on 32-bit quantities, as
  * do SCC register reads/writes.
  *
  * @param     offset  Register offset within SCC.
@@ -230,6 +352,23 @@
 /*! Name of the driver.  Used (on Linux, anyway) when registering interrupts */
 #define SCC_DRIVER_NAME "scc"
 
+/* Port -- these symbols are defined in Linux 2.6 and later.  They are defined
+ * here for backwards compatibility because this started life as a 2.4
+ * driver, and as a guide to portation to other platforms.
+ */
+
+#if !defined(LINUX_VERSION_CODE) || LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+
+#define irqreturn_t void	/* Return type of an interrupt handler */
+
+#define IRQ_HANDLED		/* Would be '1' for handled -- as in return IRQ_HANDLED; */
+
+#define IRQ_NONE		/* would be '0' for not handled -- as in return IRQ_NONE; */
+
+#define IRQ_RETVAL(x)		/* Return x==0 (not handled) or non-zero (handled) */
+
+#endif				/* LINUX earlier than 2.5 */
+
 /* These are nice to have around */
 #ifndef FALSE
 #define FALSE 0
@@ -254,10 +393,10 @@ enum scc_status {
  * Information about a key slot.
  */
 struct scc_key_slot {
-	uint64_t owner_id;	/**< Access control value. */
-	uint32_t length;	/**< Length of value in slot. */
-	uint32_t offset;	/**< Offset of value from start of each RAM. */
-	uint32_t status;	/**< 0 = unassigned, 1 = assigned. */
+	uint64_t owner_id;	/*!< Access control value. */
+	uint32_t length;	/*!< Length of value in slot. */
+	uint32_t offset;	/*!< Offset of value from start of each RAM. */
+	uint32_t status;	/*!< 0 = unassigned, 1 = assigned. */
 };
 
 /* Forward-declare a number routines which are not part of user api */
@@ -266,7 +405,7 @@ static void scc_cleanup(void);
 
 /* Forward defines of internal functions */
 OS_DEV_ISR(scc_irq);
-/** Perform callbacks registered by #scc_monitor_security_failure().
+/*! Perform callbacks registered by #scc_monitor_security_failure().
  *
  *  Make sure callbacks only happen once...  Since there may be some reason why
  *  the interrupt isn't generated, this routine could be called from base(task)
@@ -285,7 +424,7 @@ static uint32_t scc_update_state(void);
 static void scc_init_ccitt_crc(void);
 static uint32_t scc_grab_config_values(void);
 static int setup_interrupt_handling(void);
-/**
+/*!
  * Perform an encryption on the input.  If @c verify_crc is true, a CRC must be
  * calculated on the plaintext, and appended, with padding, before computing
  * the ciphertext.
@@ -297,10 +436,12 @@ static int setup_interrupt_handling(void);
  * @param[in]     add_crc         Flag for computing CRC - 0 no, else yes
  * @param[in,out] count_out_bytes Number of bytes available at @c data_out
  */
-static scc_return_t scc_encrypt(uint32_t count_in_bytes, uint8_t * data_in,
+static scc_return_t scc_encrypt(uint32_t count_in_bytes,
+				const uint8_t * data_in,
 				uint32_t scm_control, uint8_t * data_out,
 				int add_crc, unsigned long *count_out_bytes);
-/**
+
+/*!
  * Perform a decryption on the input.  If @c verify_crc is true, the last block
  * (maybe the two last blocks) is special - it should contain a CRC and
  * padding.  These must be stripped and verified.
@@ -313,9 +454,11 @@ static scc_return_t scc_encrypt(uint32_t count_in_bytes, uint8_t * data_in,
  * @param[in,out] count_out_bytes Number of bytes available at @c data_out
 
  */
-static scc_return_t scc_decrypt(uint32_t count_in_bytes, uint8_t * data_in,
+static scc_return_t scc_decrypt(uint32_t count_in_bytes,
+				const uint8_t * data_in,
 				uint32_t scm_control, uint8_t * data_out,
 				int verify_crc, unsigned long *count_out_bytes);
+
 static void scc_wait_completion(void);
 static int is_cipher_done(void);
 static scc_return_t check_register_accessible(uint32_t offset,
diff --git a/drivers/mxc/security/rng/Makefile b/drivers/mxc/security/rng/Makefile
index 9f54a92..aaf6ace 100644
--- a/drivers/mxc/security/rng/Makefile
+++ b/drivers/mxc/security/rng/Makefile
@@ -26,7 +26,10 @@ endif
 EXTRA_CFLAGS += -Idrivers/mxc/security/rng/include -Idrivers/mxc/security/sahara2/include
 
 obj-$(CONFIG_MXC_SECURITY_RNG)	+= shw.o
-shw-objs := shw_driver.o shw_memory_mapper.o ../sahara2/fsl_shw_keystore.o
-
+#shw-objs := shw_driver.o shw_memory_mapper.o ../sahara2/fsl_shw_keystore.o
+shw-objs := shw_driver.o shw_memory_mapper.o ../sahara2/fsl_shw_keystore.o  \
+            fsl_shw_sym.o  fsl_shw_wrap.o shw_dryice.o  des_key.o           \
+            shw_hash.o  shw_hmac.o
+            
 obj-$(CONFIG_MXC_SECURITY_RNG)	+= rng.o
 rng-objs :=	rng_driver.o
diff --git a/drivers/mxc/security/rng/des_key.c b/drivers/mxc/security/rng/des_key.c
new file mode 100644
index 0000000..741a800
--- /dev/null
+++ b/drivers/mxc/security/rng/des_key.c
@@ -0,0 +1,385 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+/*!
+ * @file des_key.c
+ *
+ * This file implements the function #fsl_shw_permute1_bytes().
+ *
+ * The code was lifted from crypto++ v5.5.2, which is public domain code.  The
+ * code to handle words instead of bytes was extensively modified from the byte
+ * version and then converted to handle one to three keys at once.
+ *
+ */
+
+#include "shw_driver.h"
+#ifdef DIAG_SECURITY_FUNC
+#include "apihelp.h"
+#endif
+
+#ifndef __KERNEL__
+#include <asm/types.h>
+#include <linux/byteorder/little_endian.h>	/* or whichever is proper for target arch */
+#endif
+
+#ifdef DEBUG
+#undef DEBUG			/* TEMPORARY */
+#endif
+
+#if defined(DEBUG) || defined(SELF_TEST)
+static void DUMP_BYTES(const char *label, const uint8_t * data, int len)
+{
+	int i;
+
+	printf("%s: ", label);
+	for (i = 0; i < len; i++) {
+		printf("%02X", data[i]);
+		if ((i % 8 == 0) && (i != 0)) {
+			printf("_");	/* key separator */
+		}
+	}
+	printf("\n");
+}
+
+static void DUMP_WORDS(const char *label, const uint32_t * data, int len)
+{
+	int i, j;
+
+	printf("%s: ", label);
+	/* Dump the words in reverse order, so that they are intelligible */
+	for (i = len - 1; i >= 0; i--) {
+		for (j = 3; j >= 0; j--) {
+			uint32_t word = data[i];
+			printf("%02X", (word >> ((j * 8)) & 0xff));
+			if ((i != 0) && ((((i) * 4 + 5 + j) % 7) == 5))
+				printf("_");	/* key separator */
+		}
+		printf("|");	/* word separator */
+	}
+	printf("\n");
+}
+#else
+#define DUMP_BYTES(label, data,len)
+#define DUMP_WORDS(label, data,len)
+#endif
+
+/*!
+ * permuted choice table (key)
+ *
+ * Note that this table has had one subtracted from each element so that the
+ * code doesn't have to do it.
+ */
+static const uint8_t pc1[] = {
+	56, 48, 40, 32, 24, 16, 8,
+	0, 57, 49, 41, 33, 25, 17,
+	9, 1, 58, 50, 42, 34, 26,
+	18, 10, 2, 59, 51, 43, 35,
+	62, 54, 46, 38, 30, 22, 14,
+	6, 61, 53, 45, 37, 29, 21,
+	13, 5, 60, 52, 44, 36, 28,
+	20, 12, 4, 27, 19, 11, 3,
+};
+
+/*! bit 0 is left-most in byte */
+static const int bytebit[] = {
+	0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
+};
+
+/*!
+ * Convert a 3-key 3DES key into the first-permutation 168-bit version.
+ *
+ * This is the format of the input key:
+ *
+ * @verbatim
+   BIT:  |191                                 128|127                                  64|63                                    0|
+   BYTE: |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 |
+   KEY:  |                   0                   |                   1                   |                   2                   |
+  @endverbatim
+ *
+ * This is the format of the output key:
+ *
+ * @verbatim
+   BIT:  |167                            112|111                             56|55                               0|
+   BYTE: |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 |
+   KEY:  |                 1                |                 2                |                 3                |
+  @endverbatim
+ * 
+ * @param[in]   key          bytes of 3DES key
+ * @param[out] permuted_key  21 bytes of permuted key
+ * @param[in]  key_count     How many DES keys (2 or 3)
+ */
+void fsl_shw_permute1_bytes(const uint8_t * key, uint8_t * permuted_key,
+			    int key_count)
+{
+	int i;
+	int j;
+	int l;
+	int m;
+
+	DUMP_BYTES("Input key", key, 8 * key_count);
+
+	/* For each individual sub-key */
+	for (i = 0; i < 3; i++) {
+		DUMP_BYTES("(key)", key, 8);
+		memset(permuted_key, 0, 7);
+		/* For each bit of key */
+		for (j = 0; j < 56; j++) {	/* convert pc1 to bits of key */
+			l = pc1[j];	/* integer bit location  */
+			m = l & 07;	/* find bit              */
+			permuted_key[j >> 3] |= (((key[l >> 3] &	/* find which key byte l is in */
+						   bytebit[m])	/* and which bit of that byte */
+						  ? 0x80 : 0) >> (j % 8));	/* and store 1-bit result */
+		}
+		switch (i) {
+		case 0:
+			if (key_count != 1)
+				key += 8;	/* move on to second key */
+			break;
+		case 1:
+			if (key_count == 2)
+				key -= 8;	/* go back to first key */
+			else if (key_count == 3)
+				key += 8;	/* move on to third key */
+			break;
+		default:
+			break;
+		}
+		permuted_key += 7;
+	}
+	DUMP_BYTES("Output key (bytes)", permuted_key - 21, 21);
+}
+
+#ifdef SELF_TEST
+const uint8_t key1_in[] = {
+	/* FE01FE01FE01FE01_01FE01FE01FE01FE_FEFE0101FEFE0101 */
+	0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01,
+	0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE,
+	0xFE, 0xFE, 0x01, 0x01, 0xFE, 0xFE, 0x01, 0x01
+};
+
+const uint32_t key1_word_in[] = {
+	0xFE01FE01, 0xFE01FE01,
+	0x01FE01FE, 0x01FE01FE,
+	0xFEFE0101, 0xFEFE0101
+};
+
+uint8_t exp_key1_out[] = {
+	0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
+	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
+	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33
+};
+
+uint32_t exp_word_key1_out[] = {
+	0x33333333, 0xAA333333, 0xAAAAAAAA, 0x5555AAAA,
+	0x55555555, 0x00000055,
+};
+
+const uint8_t key2_in[] = {
+	0xEF, 0x10, 0xBB, 0xA4, 0x23, 0x49, 0x42, 0x58,
+	0x01, 0x28, 0x01, 0x4A, 0x10, 0xE4, 0x03, 0x59,
+	0xFE, 0x84, 0x30, 0x29, 0x8E, 0xF1, 0x10, 0x5A
+};
+
+const uint32_t key2_word_in[] = {
+	0xEF10BBA4, 0x23494258,
+	0x0128014A, 0x10E40359,
+	0xFE843029, 0x8EF1105A
+};
+
+uint8_t exp_key2_out[] = {
+	0x0D, 0xE1, 0x1D, 0x85, 0x50, 0x9A, 0x56, 0x20,
+	0xA8, 0x22, 0x94, 0x82, 0x08, 0xA0, 0x33, 0xA1,
+	0x2D, 0xE9, 0x11, 0x39, 0x95
+};
+
+uint32_t exp_word_key2_out[] = {
+	0xE9113995, 0xA033A12D, 0x22948208, 0x9A5620A8,
+	0xE11D8550, 0x0000000D
+};
+
+const uint8_t key3_in[] = {
+	0x3F, 0xE9, 0x49, 0x4B, 0x67, 0x57, 0x07, 0x3C,
+	0x89, 0x77, 0x73, 0x0C, 0xA0, 0x05, 0x41, 0x69,
+	0xB3, 0x7C, 0x98, 0xD8, 0xC9, 0x35, 0x57, 0x19
+};
+
+const uint32_t key3_word_in[] = {
+	0xEF10BBA4, 0x23494258,
+	0x0128014A, 0x10E40359,
+	0xFE843029, 0x8EF1105A
+};
+
+uint8_t exp_key3_out[] = {
+	0x02, 0x3E, 0x93, 0xA7, 0x9F, 0x18, 0xF1, 0x11,
+	0xC6, 0x96, 0x00, 0x62, 0xA8, 0x96, 0x02, 0x3E,
+	0x93, 0xA7, 0x9F, 0x18, 0xF1
+};
+
+uint32_t exp_word_key3_out[] = {
+	0xE9113995, 0xA033A12D, 0x22948208, 0x9A5620A8,
+	0xE11D8550, 0x0000000D
+};
+
+const uint8_t key4_in[] = {
+	0x3F, 0xE9, 0x49, 0x4B, 0x67, 0x57, 0x07, 0x3C,
+	0x89, 0x77, 0x73, 0x0C, 0xA0, 0x05, 0x41, 0x69,
+};
+
+const uint32_t key4_word_in[] = {
+	0xEF10BBA4, 0x23494258,
+	0x0128014A, 0x10E40359,
+	0xFE843029, 0x8EF1105A
+};
+
+const uint8_t key5_in[] = {
+	0x3F, 0xE9, 0x49, 0x4B, 0x67, 0x57, 0x07, 0x3C,
+	0x89, 0x77, 0x73, 0x0C, 0xA0, 0x05, 0x41, 0x69,
+	0x3F, 0xE9, 0x49, 0x4B, 0x67, 0x57, 0x07, 0x3C,
+};
+
+uint8_t exp_key4_out[] = {
+	0x0D, 0xE1, 0x1D, 0x85, 0x50, 0x9A, 0x56, 0x20,
+	0xA8, 0x22, 0x94, 0x82, 0x08, 0xA0, 0x33, 0xA1,
+	0x2D, 0xE9, 0x11, 0x39, 0x95
+};
+
+uint32_t exp_word_key4_out[] = {
+	0xE9113995, 0xA033A12D, 0x22948208, 0x9A5620A8,
+	0xE11D8550, 0x0000000D
+};
+
+const uint8_t key6_in[] = {
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
+};
+
+uint8_t exp_key6_out[] = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+uint32_t exp_word_key6_out[] = {
+	0x00000000, 0x0000000, 0x0000000, 0x00000000,
+	0x00000000, 0x0000000
+};
+
+const uint8_t key7_in[] = {
+	/* 01FE01FE01FE01FE_FE01FE01FE01FE01_0101FEFE0101FEFE */
+	/*  0101FEFE0101FEFE_FE01FE01FE01FE01_01FE01FE01FE01FE */
+	0x01, 0x01, 0xFE, 0xFE, 0x01, 0x01, 0xFE, 0xFE,
+	0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01,
+	0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE,
+};
+
+uint8_t exp_key7_out[] = {
+	0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x55,
+	0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa,
+	0xaa, 0xaa, 0xaa, 0xaa, 0xaa
+};
+
+uint32_t exp_word_key7_out[] = {
+	0xcccccccc, 0x55cccccc, 0x55555555, 0xaaaa5555,
+	0xaaaaaaaa, 0x000000aa
+};
+
+int run_test(const uint8_t * key_in,
+	     const int key_count,
+	     const uint32_t * key_word_in,
+	     const uint8_t * exp_bytes_key_out,
+	     const uint32_t * exp_word_key_out)
+{
+	uint8_t key_out[22];
+	uint32_t word_key_out[6];
+	int failed = 0;
+
+	memset(key_out, 0x42, 22);
+	fsl_shw_permute1_bytes(key_in, key_out, key_count);
+	if (memcmp(key_out, exp_bytes_key_out, 21) != 0) {
+		printf("bytes_to_bytes: ERROR: \n");
+		DUMP_BYTES("key_in", key_in, 8 * key_count);
+		DUMP_BYTES("key_out", key_out, 21);
+		DUMP_BYTES("exp_out", exp_bytes_key_out, 21);
+		failed |= 1;
+	} else if (key_out[21] != 0x42) {
+		printf("bytes_to_bytes: ERROR: Buffer overflow 0x%02x\n",
+		       (int)key_out[21]);
+	} else {
+		printf("bytes_to_bytes: OK\n");
+	}
+#if 0
+	memset(word_key_out, 0x42, 21);
+	fsl_shw_permute1_bytes_to_words(key_in, word_key_out, key_count);
+	if (memcmp(word_key_out, exp_word_key_out, 21) != 0) {
+		printf("bytes_to_words: ERROR: \n");
+		DUMP_BYTES("key_in", key_in, 8 * key_count);
+		DUMP_WORDS("key_out", word_key_out, 6);
+		DUMP_WORDS("exp_out", exp_word_key_out, 6);
+		failed |= 1;
+	} else {
+		printf("bytes_to_words: OK\n");
+	}
+
+	if (key_word_in != NULL) {
+		memset(word_key_out, 0x42, 21);
+		fsl_shw_permute1_words_to_words(key_word_in, word_key_out);
+		if (memcmp(word_key_out, exp_word_key_out, 21) != 0) {
+			printf("words_to_words: ERROR: \n");
+			DUMP_BYTES("key_in", key_in, 24);
+			DUMP_WORDS("key_out", word_key_out, 6);
+			DUMP_WORDS("exp_out", exp_word_key_out, 6);
+			failed |= 1;
+		} else {
+			printf("words_to_words: OK\n");
+		}
+	}
+#endif
+
+	return failed;
+}				/* end fn run_test */
+
+int main()
+{
+	int failed = 0;
+
+	printf("key1\n");
+	failed |=
+	    run_test(key1_in, 3, key1_word_in, exp_key1_out, exp_word_key1_out);
+	printf("\nkey2\n");
+	failed |=
+	    run_test(key2_in, 3, key2_word_in, exp_key2_out, exp_word_key2_out);
+	printf("\nkey3\n");
+	failed |= run_test(key3_in, 3, NULL, exp_key3_out, exp_word_key3_out);
+	printf("\nkey4\n");
+	failed |= run_test(key4_in, 2, NULL, exp_key4_out, exp_word_key4_out);
+	printf("\nkey5\n");
+	failed |= run_test(key5_in, 3, NULL, exp_key4_out, exp_word_key4_out);
+	printf("\nkey6 - 3\n");
+	failed |= run_test(key6_in, 3, NULL, exp_key6_out, exp_word_key6_out);
+	printf("\nkey6 - 2\n");
+	failed |= run_test(key6_in, 2, NULL, exp_key6_out, exp_word_key6_out);
+	printf("\nkey6 - 1\n");
+	failed |= run_test(key6_in, 1, NULL, exp_key6_out, exp_word_key6_out);
+	printf("\nkey7\n");
+	failed |= run_test(key7_in, 3, NULL, exp_key7_out, exp_word_key7_out);
+	printf("\n");
+
+	if (failed != 0) {
+		printf("TEST FAILED\n");
+	}
+	return failed;
+}
+
+#endif				/* SELF_TEST */
diff --git a/drivers/mxc/security/rng/fsl_shw_hash.c b/drivers/mxc/security/rng/fsl_shw_hash.c
new file mode 100644
index 0000000..6057286
--- /dev/null
+++ b/drivers/mxc/security/rng/fsl_shw_hash.c
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+/*!
+ * @file fsl_shw_hash.c
+ *
+ * This file implements Cryptographic Hashing functions of the FSL SHW API
+ * for Sahara.  This does not include HMAC.
+ */
+
+#include "shw_driver.h"
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-005 */
+/*!
+ * Hash a stream of data with a cryptographic hash algorithm.
+ *
+ * The flags in the @a hash_ctx control the operation of this function.
+ *
+ * Hashing functions work on 64 octets of message at a time.  Therefore, when
+ * any partial hashing of a long message is performed, the message @a length of
+ * each segment must be a multiple of 64.  When ready to
+ * #FSL_HASH_FLAGS_FINALIZE the hash, the @a length may be any value.
+ *
+ * With the #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_FINALIZE flags on, a
+ * one-shot complete hash, including padding, will be performed.  The @a length
+ * may be any value.
+ *
+ * The first octets of a data stream can be hashed by setting the
+ * #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_SAVE flags.  The @a length must be
+ * a multiple of 64.
+ *
+ * The flag #FSL_HASH_FLAGS_LOAD is used to load a context previously saved by
+ * #FSL_HASH_FLAGS_SAVE.  The two in combination will allow a (multiple-of-64
+ * octets) 'middle sequence' of the data stream to be hashed with the
+ * beginning.  The @a length must again be a multiple of 64.
+ *
+ * Since the flag #FSL_HASH_FLAGS_LOAD is used to load a context previously
+ * saved by #FSL_HASH_FLAGS_SAVE, the #FSL_HASH_FLAGS_LOAD and
+ * #FSL_HASH_FLAGS_FINALIZE flags, used together, can be used to finish the
+ * stream.  The @a length may be any value.
+ *
+ * If the user program wants to do the padding for the hash, it can leave off
+ * the #FSL_HASH_FLAGS_FINALIZE flag.  The @a length must then be a multiple of
+ * 64 octets.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param[in,out] hash_ctx Hashing algorithm and state of the cipher.
+ * @param      msg       Pointer to the data to be hashed.
+ * @param      length    Length, in octets, of the @a msg.
+ * @param[out] result    If not null, pointer to where to store the hash
+ *                       digest.
+ * @param      result_len Number of octets to store in @a result.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t * user_ctx,
+			      fsl_shw_hco_t * hash_ctx,
+			      const uint8_t * msg,
+			      uint32_t length,
+			      uint8_t * result, uint32_t result_len)
+{
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+
+	/* Unused */
+	(void)user_ctx;
+	(void)hash_ctx;
+	(void)msg;
+	(void)length;
+	(void)result;
+	(void)result_len;
+
+	return ret;
+}
diff --git a/drivers/mxc/security/rng/fsl_shw_hmac.c b/drivers/mxc/security/rng/fsl_shw_hmac.c
new file mode 100644
index 0000000..4d2a104
--- /dev/null
+++ b/drivers/mxc/security/rng/fsl_shw_hmac.c
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+/*!
+ * @file fsl_shw_hmac.c
+ *
+ * This file implements Hashed Message Authentication Code functions of the FSL
+ * SHW API.
+ */
+
+#include "shw_driver.h"
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-001 */
+/*!
+ * Get the precompute information
+ *
+ *
+ * @param   user_ctx
+ * @param   key_info
+ * @param   hmac_ctx
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t * user_ctx,
+					 fsl_shw_sko_t * key_info,
+					 fsl_shw_hmco_t * hmac_ctx)
+{
+	fsl_shw_return_t status = FSL_RETURN_ERROR_S;
+
+	/* Unused */
+	(void)user_ctx;
+	(void)key_info;
+	(void)hmac_ctx;
+
+	return status;
+}
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-002 */
+/*!
+ * Get the hmac
+ *
+ *
+ * @param         user_ctx    Info for acquiring memory
+ * @param         key_info
+ * @param         hmac_ctx
+ * @param         msg
+ * @param         length
+ * @param         result
+ * @param         result_len
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t * user_ctx,
+			      fsl_shw_sko_t * key_info,
+			      fsl_shw_hmco_t * hmac_ctx,
+			      const uint8_t * msg,
+			      uint32_t length,
+			      uint8_t * result, uint32_t result_len)
+{
+	fsl_shw_return_t status = FSL_RETURN_ERROR_S;
+
+	/* Unused */
+	(void)user_ctx;
+	(void)key_info;
+	(void)hmac_ctx;
+	(void)msg;
+	(void)length;
+	(void)result;
+	(void)result_len;
+
+	return status;
+}
diff --git a/drivers/mxc/security/rng/fsl_shw_rand.c b/drivers/mxc/security/rng/fsl_shw_rand.c
new file mode 100644
index 0000000..aa4d426
--- /dev/null
+++ b/drivers/mxc/security/rng/fsl_shw_rand.c
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+/*!
+ * @file fsl_shw_rand.c
+ *
+ * This file implements Random Number Generation functions of the FSL SHW API
+ * in USER MODE for talking to a standalone RNGA/RNGC device driver.
+ *
+ * It contains the fsl_shw_get_random() and fsl_shw_add_entropy() functions.
+ *
+ * These routines will build a request block and pass it to the SHW driver.
+ */
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/fcntl.h>
+#include <sys/ioctl.h>
+#include <signal.h>
+
+#ifdef FSL_DEBUG
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+#endif				/* FSL_DEBUG */
+
+#include "shw_driver.h"
+
+extern fsl_shw_return_t validate_uco(fsl_shw_uco_t * uco);
+
+#if defined(FSL_HAVE_RNGA) || defined(FSL_HAVE_RNGB) || defined(FSL_HAVE_RNGC)
+
+/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
+fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx,
+				    uint32_t length, uint8_t * data)
+{
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+
+	/* perform a sanity check / update uco */
+	ret = validate_uco(user_ctx);
+	if (ret == FSL_RETURN_OK_S) {
+		struct get_random_req *req = malloc(sizeof(*req));
+
+		if (req == NULL) {
+			ret = FSL_RETURN_NO_RESOURCE_S;
+		} else {
+
+			init_req(&req->hdr, user_ctx);
+			req->size = length;
+			req->random = data;
+
+			ret =
+			    send_req(SHW_USER_REQ_GET_RANDOM, &req->hdr,
+				     user_ctx);
+		}
+	}
+
+	return ret;
+}
+
+fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx,
+				     uint32_t length, uint8_t * data)
+{
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+
+	/* perform a sanity check on the uco */
+	ret = validate_uco(user_ctx);
+	if (ret == FSL_RETURN_OK_S) {
+		struct add_entropy_req *req = malloc(sizeof(*req));
+
+		if (req == NULL) {
+			ret = FSL_RETURN_NO_RESOURCE_S;
+		} else {
+			init_req(&req->hdr, user_ctx);
+			req->size = length;
+			req->entropy = data;
+
+			ret =
+			    send_req(SHW_USER_REQ_ADD_ENTROPY, &req->hdr,
+				     user_ctx);
+		}
+	}
+
+	return ret;
+}
+
+#else				/* no H/W RNG block */
+
+fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx,
+				    uint32_t length, uint8_t * data)
+{
+
+	(void)user_ctx;
+	(void)length;
+	(void)data;
+
+	return FSL_RETURN_ERROR_S;
+}
+
+fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx,
+				     uint32_t length, uint8_t * data)
+{
+
+	(void)user_ctx;
+	(void)length;
+	(void)data;
+
+	return FSL_RETURN_ERROR_S;
+}
+#endif
diff --git a/drivers/mxc/security/rng/fsl_shw_sym.c b/drivers/mxc/security/rng/fsl_shw_sym.c
new file mode 100644
index 0000000..3808861
--- /dev/null
+++ b/drivers/mxc/security/rng/fsl_shw_sym.c
@@ -0,0 +1,317 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+/*!
+ * @file fsl_shw_sym.c
+ *
+ * This file implements the Symmetric Cipher functions of the FSL SHW API. Its
+ * features are limited to what can be done with the combination of SCC and
+ * DryIce.
+ */
+#include "fsl_platform.h"
+#include "shw_driver.h"
+
+#if defined(__KERNEL__) && defined(FSL_HAVE_DRYICE)
+
+#include <../dryice.h>
+#include <asm/arch/mxc_scc_driver.h>
+#ifdef DIAG_SECURITY_FUNC
+#include "apihelp.h"
+#endif*/
+
+#include <diagnostic.h>
+
+#define SYM_DECRYPT 0
+#define SYM_ENCRYPT 1
+
+extern fsl_shw_return_t shw_convert_pf_key(fsl_shw_pf_key_t shw_pf_key,
+					   di_key_t * di_keyp);
+
+/*! 'Initial' IV for presence of FSL_SYM_CTX_LOAD flag */
+static uint8_t zeros[8] = {
+	0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/*!
+ * Common function for encryption and decryption
+ *
+ * This is for a device with DryIce.
+ *
+ * A key must either refer to a 'pure' HW key, or, if PRG or PRG_IIM,
+ * established, then that key will be programmed.  Then, the HW_key in the
+ * object will be selected.  After this setup, the ciphering will be performed
+ * by calling the SCC driver..
+ *
+ * The function 'releases' the reservations before it completes.
+ */
+fsl_shw_return_t do_symmetric(fsl_shw_uco_t * user_ctx,
+			      fsl_shw_sko_t * key_info,
+			      fsl_shw_scco_t * sym_ctx,
+			      int encrypt,
+			      uint32_t length,
+			      const uint8_t * in, uint8_t * out)
+{
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+	int key_selected = 0;
+	uint8_t *iv = NULL;
+	unsigned long count_out = length;
+	di_key_t di_key = DI_KEY_PK;	/* default for user key */
+	di_key_t di_key_orig;	/* currently selected key */
+	di_key_t selected_key = -1;
+	di_return_t di_code;
+	scc_return_t scc_code;
+
+	/* For now, only blocking mode calls are supported */
+	if (!(user_ctx->flags & FSL_UCO_BLOCKING_MODE)) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	/* No software keys allowed */
+	if (key_info->flags & FSL_SKO_KEY_SW_KEY) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+	}
+
+	/* The only algorithm the SCC supports */
+	if (key_info->algorithm != FSL_KEY_ALG_TDES) {
+		ret = FSL_RETURN_BAD_ALGORITHM_S;
+		goto out;
+	}
+
+	/* Validate key length */
+	if ((key_info->key_length != 16)
+	    && (key_info->key_length != 21)
+	    && (key_info->key_length != 24)) {
+		ret = FSL_RETURN_BAD_KEY_LENGTH_S;
+		goto out;
+	}
+
+	/* Validate data is multiple of DES/TDES block */
+	if ((length & 7) != 0) {
+		ret = FSL_RETURN_BAD_DATA_LENGTH_S;
+		goto out;
+	}
+
+	/* Do some setup according to where the key lives */
+	if (key_info->flags & FSL_SKO_KEY_ESTABLISHED) {
+		if ((key_info->pf_key != FSL_SHW_PF_KEY_PRG)
+		    && (key_info->pf_key != FSL_SHW_PF_KEY_IIM_PRG)) {
+			ret = FSL_RETURN_ERROR_S;
+		}
+	} else if (key_info->flags & FSL_SKO_KEY_PRESENT) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+	} else if (key_info->flags & FSL_SKO_KEY_SELECT_PF_KEY) {
+		/*
+		 * No key present or established, just refer to HW
+		 * as programmed.
+		 */
+	} else {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	/* Now make proper selection */
+	ret = shw_convert_pf_key(key_info->pf_key, &di_key);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	/* Determine the current DI key selection */
+	di_code = dryice_check_key(&di_key_orig);
+	if (di_code != DI_SUCCESS) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("Could not save current DI key state: %s\n",
+					  di_error_string(di_code));
+#endif
+		ret = FSL_RETURN_ERROR_S;
+		goto out;
+	}
+	
+	/* If the requested DI key is already selected, don't re-select it. */
+	if (di_key != di_key_orig) {
+	   di_code = dryice_select_key(di_key, 0);
+	   if (di_code != DI_SUCCESS) {
+#ifdef DIAG_SECURITY_FUNC
+		  LOG_DIAG_ARGS("Error from select_key: %s\n",
+			      di_error_string(di_code));
+#endif
+		  ret = FSL_RETURN_INTERNAL_ERROR_S;
+		  goto out;
+	   }
+	}
+	key_selected = 1;
+
+	/* Verify that we are using the key we want */
+	di_code = dryice_check_key(&selected_key);
+	if (di_code != DI_SUCCESS) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("Error from check_key: %s\n",
+			      di_error_string(di_code));
+#endif
+		ret = FSL_RETURN_INTERNAL_ERROR_S;
+		goto out;
+	}
+
+	if (di_key != selected_key) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("Wrong key in use: %d instead of %d\n\n",
+			      selected_key, di_key);
+#endif
+		ret = FSL_RETURN_ERROR_S;
+		goto out;
+	}
+
+	if (sym_ctx->mode == FSL_SYM_MODE_CBC) {
+		if ((sym_ctx->flags & FSL_SYM_CTX_LOAD)
+		    && !(sym_ctx->flags & FSL_SYM_CTX_INIT)) {
+			iv = sym_ctx->context;
+		} else if ((sym_ctx->flags & FSL_SYM_CTX_INIT)
+			   && !(sym_ctx->flags & FSL_SYM_CTX_LOAD)) {
+			iv = zeros;
+		} else {
+			/* Exactly one must be set! */
+			ret = FSL_RETURN_BAD_FLAG_S;
+			goto out;
+		}
+	}
+
+	/* Now run the data through the SCC */
+	scc_code = scc_crypt(length, in, iv,
+			     encrypt ? SCC_ENCRYPT : SCC_DECRYPT,
+			     (sym_ctx->mode == FSL_SYM_MODE_ECB)
+			     ? SCC_ECB_MODE : SCC_CBC_MODE,
+			     SCC_VERIFY_MODE_NONE, out, &count_out);
+	if (scc_code != SCC_RET_OK) {
+		ret = FSL_RETURN_INTERNAL_ERROR_S;
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("scc_code from scc_crypt() is %d\n", scc_code);
+#endif
+		goto out;
+	}
+
+	if ((sym_ctx->mode == FSL_SYM_MODE_CBC)
+	    && (sym_ctx->flags & FSL_SYM_CTX_SAVE)) {
+		/* Save the context for the caller */
+		if (encrypt) {
+			/* Last ciphertext block ... */
+			memcpy(sym_ctx->context, out + length - 8, 8);
+		} else {
+			/* Last ciphertext block ... */
+			memcpy(sym_ctx->context, in + length - 8, 8);
+		}
+	}
+
+	ret = FSL_RETURN_OK_S;
+
+      out:
+	if (key_selected) {
+		(void)dryice_release_key_selection();
+	}
+
+	return ret;
+}
+
+EXPORT_SYMBOL(fsl_shw_symmetric_encrypt);
+/*!
+ * Compute symmetric encryption
+ *
+ *
+ * @param    user_ctx
+ * @param    key_info
+ * @param    sym_ctx
+ * @param    length
+ * @param    pt
+ * @param    ct
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
+					   fsl_shw_sko_t * key_info,
+					   fsl_shw_scco_t * sym_ctx,
+					   uint32_t length,
+					   const uint8_t * pt, uint8_t * ct)
+{
+	fsl_shw_return_t ret;
+
+	ret = do_symmetric(user_ctx, key_info, sym_ctx, SYM_ENCRYPT,
+			   length, pt, ct);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(fsl_shw_symmetric_decrypt);
+/*!
+ * Compute symmetric decryption
+ *
+ *
+ * @param    user_ctx
+ * @param    key_info
+ * @param    sym_ctx
+ * @param    length
+ * @param    pt
+ * @param    ct
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t * user_ctx,
+					   fsl_shw_sko_t * key_info,
+					   fsl_shw_scco_t * sym_ctx,
+					   uint32_t length,
+					   const uint8_t * ct, uint8_t * pt)
+{
+	fsl_shw_return_t ret;
+
+	ret = do_symmetric(user_ctx, key_info, sym_ctx, SYM_DECRYPT,
+			   length, ct, pt);
+
+	return ret;
+}
+
+#else				/* __KERNEL__ && DRYICE */
+
+fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
+					   fsl_shw_sko_t * key_info,
+					   fsl_shw_scco_t * sym_ctx,
+					   uint32_t length,
+					   const uint8_t * pt, uint8_t * ct)
+{
+	/* Unused */
+	(void)user_ctx;
+	(void)key_info;
+	(void)sym_ctx;
+	(void)length;
+	(void)pt;
+	(void)ct;
+
+	return FSL_RETURN_ERROR_S;
+}
+
+fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t * user_ctx,
+					   fsl_shw_sko_t * key_info,
+					   fsl_shw_scco_t * sym_ctx,
+					   uint32_t length,
+					   const uint8_t * ct, uint8_t * pt)
+{
+	/* Unused */
+	(void)user_ctx;
+	(void)key_info;
+	(void)sym_ctx;
+	(void)length;
+	(void)ct;
+	(void)pt;
+
+	return FSL_RETURN_ERROR_S;
+}
+
+#endif				/* __KERNEL__ and DRYICE */
diff --git a/drivers/mxc/security/rng/fsl_shw_wrap.c b/drivers/mxc/security/rng/fsl_shw_wrap.c
new file mode 100644
index 0000000..18bd55e
--- /dev/null
+++ b/drivers/mxc/security/rng/fsl_shw_wrap.c
@@ -0,0 +1,1301 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file fsl_shw_wrap.c
+ *
+ * This file implements Key-Wrap (Black Key) and Key Establishment functions of
+ * the FSL SHW API for the SHW (non-SAHARA) driver.
+ *
+ * This is the Black Key information:
+ *
+ * <ul>
+ * <li> Ownerid is an 8-byte, user-supplied, value to keep KEY
+ *      confidential.</li>
+ * <li> KEY is a 1-32 byte value which starts in SCC RED RAM before
+ *     wrapping, and ends up there on unwrap.  Length is limited because of
+ *    size of SCC1 RAM.</li>
+ * <li> KEY' is the encrypted KEY</li>
+ * <li> LEN is a 1-byte (for now) byte-length of KEY</li>
+ * <li> ALG is a 1-byte value for the algorithm which which the key is
+ *    associated.  Values are defined by the FSL SHW API</li>
+ * <li> FLAGS is a 1-byte value contain information like "this key is for
+ *    software" (TBD)</li>
+ * <li> Ownerid, LEN, and ALG come from the user's "key_info" object, as does
+ *    the slot number where KEY already is/will be.</li>
+ * <li> T is a Nonce</li>
+ * <li> T' is the encrypted T</li>
+ * <li> KEK is a Key-Encryption Key for the user's Key</li>
+ * <li> ICV is the "Integrity Check Value" for the wrapped key</li>
+ * <li> Black Key is the string of bytes returned as the wrapped key</li>
+ * <li> Wrap Key is the user's choice for encrypting the nonce.  One of
+ *      the Fused Key, the Random Key, or the XOR of the two.
+ * </ul>
+<table border="0">
+<tr><TD align="right">BLACK_KEY <TD width="3">=<TD>ICV | T' | LEN | ALG |
+     FLAGS | KEY'</td></tr>
+<tr><td>&nbsp;</td></tr>
+
+<tr><th>To Wrap</th></tr>
+<tr><TD align="right">T</td> <TD width="3">=</td> <TD>RND()<sub>16</sub>
+    </td></tr>
+<tr><TD align="right">KEK</td><TD width="3">=</td><TD>HASH<sub>sha256</sub>(T |
+     Ownerid)<sub>16</sub></td></tr>
+<tr><TD align="right">KEY'<TD width="3">=</td><TD>
+     TDES<sub>cbc-enc</sub>(Key=KEK, Data=KEY, IV=Ownerid)</td></tr>
+<tr><TD align="right">ICV</td><TD width="3">=</td><td>HMAC<sub>sha256</sub>
+     (Key=T, Data=Ownerid | LEN | ALG | FLAGS | KEY')<sub>16</sub></td></tr>
+<tr><TD align="right">T'</td><TD width="3">=</td><TD>TDES<sub>ecb-enc</sub>
+     (Key=Wrap_Key, IV=Ownerid, Data=T)</td></tr>
+
+<tr><td>&nbsp;</td></tr>
+
+<tr><th>To Unwrap</th></tr>
+<tr><TD align="right">T</td><TD width="3">=</td><TD>TDES<sub>ecb-dec</sub>
+    (Key=Wrap_Key, IV=Ownerid, Data=T')</td></tr>
+<tr><TD align="right">ICV</td><TD width="3">=</td><td>HMAC<sub>sha256</sub>
+    (Key=T, Data=Ownerid | LEN | ALG | FLAGS | KEY')<sub>16</sub></td></tr>
+<tr><TD align="right">KEK</td><TD width="3">=</td><td>HASH<sub>sha256</sub>
+    (T | Ownerid)<sub>16</sub></td></tr>
+<tr><TD align="right">KEY<TD width="3">=</td><TD>TDES<sub>cbc-dec</sub>
+    (Key=KEK, Data=KEY', IV=Ownerid)</td></tr>
+</table>
+
+ * This code supports two types of keys: Software Keys and keys destined for
+ * (or residing in) the DryIce Programmed Key Register.
+ *
+ * Software Keys go to / from the keystore.
+ *
+ * PK keys go to / from the DryIce Programmed Key Register.
+ *
+ * This code only works on a platform with DryIce.  "software" keys go into
+ * the keystore.  "Program" keys go to the DryIce Programmed Key Register.
+ * As far as this code is concerned, the size of that register is 21 bytes,
+ * the size of a 3DES key with parity stripped.
+ *
+ * The maximum key size supported for wrapped/unwrapped keys depends upon
+ * LENGTH_LENGTH.  Currently, it is one byte, so the maximum key size is
+ * 255 bytes.  However, key objects cannot currently hold a key of this
+ * length, so a smaller key size is the max.
+ */
+
+#include "fsl_platform.h"
+	 
+/* This code only works in kernel mode */
+
+#include "shw_driver.h"
+#ifdef DIAG_SECURITY_FUNC
+#include "apihelp.h"
+#endif
+
+#if defined(__KERNEL__) && defined(FSL_HAVE_DRYICE)
+
+#include <../dryice.h>
+#include <asm/arch/mxc_scc_driver.h>
+
+#include "portable_os.h"
+#include "fsl_shw_keystore.h"
+
+#include <diagnostic.h>
+
+#include "shw_hmac.h"
+#include "shw_hash.h"
+
+#define ICV_LENGTH 16
+#define T_LENGTH 16
+#define KEK_LENGTH 21
+#define LENGTH_LENGTH 1
+#define ALGORITHM_LENGTH 1
+#define FLAGS_LENGTH 1
+
+/* ICV | T' | LEN | ALG | FLAGS | KEY' */
+#define ICV_OFFSET       0
+#define T_PRIME_OFFSET   (ICV_OFFSET + ICV_LENGTH)
+#define LENGTH_OFFSET    (T_PRIME_OFFSET + T_LENGTH)
+#define ALGORITHM_OFFSET (LENGTH_OFFSET + LENGTH_LENGTH)
+#define FLAGS_OFFSET     (ALGORITHM_OFFSET + ALGORITHM_LENGTH)
+#define KEY_PRIME_OFFSET (FLAGS_OFFSET + FLAGS_LENGTH)
+
+#define FLAGS_SW_KEY     0x01
+
+#define LENGTH_PATCH  8
+#define LENGTH_PATCH_MASK  (LENGTH_PATCH - 1)
+
+/*! rounded up from 168 bits to the next word size */
+#define HW_KEY_LEN_WORDS_BITS 192
+
+/*!
+ * Round a key length up to the TDES block size
+ *
+ * @param len         Length of key, in bytes
+ *
+ * @return Length rounded up, if necessary
+ */
+#define ROUND_LENGTH(len)                                                  \
+({                                                                         \
+    uint32_t orig_len = len;                                               \
+    uint32_t new_len;                                                      \
+                                                                           \
+   if ((orig_len & LENGTH_PATCH_MASK) != 0) {                              \
+       new_len = (orig_len + LENGTH_PATCH                                  \
+            - (orig_len & LENGTH_PATCH_MASK));                             \
+   }                                                                       \
+   else {                                                                  \
+       new_len = orig_len;                                                 \
+   }                                                                       \
+                                                                           \
+   new_len;                                                                \
+})
+
+/* This is the system keystore object */
+extern fsl_shw_kso_t system_keystore;
+
+#ifdef DIAG_SECURITY_FUNC
+static void dump(const char *name, const uint8_t * data, unsigned int len)
+{
+	os_printk("%s: ", name);
+	while (len > 0) {
+		os_printk("%02x ", (unsigned)*data++);
+		len--;
+	}
+	os_printk("\n");
+}
+#endif
+
+/*
+ * For testing of the algorithm implementation,, the DO_REPEATABLE_WRAP flag
+ * causes the T_block to go into the T field during a wrap operation.  This
+ * will make the black key value repeatable (for a given SCC secret key, or
+ * always if the default key is in use).
+ *
+ * Normally, a random sequence is used.
+ */
+#ifdef DO_REPEATABLE_WRAP
+/*!
+ * Block of zeroes which is maximum Symmetric block size, used for
+ * initializing context register, etc.
+ */
+static uint8_t T_block[16] = {
+	0x42, 0, 0, 0x42, 0x42, 0, 0, 0x42,
+	0x42, 0, 0, 0x42, 0x42, 0, 0, 0x42
+};
+#endif
+
+EXPORT_SYMBOL(fsl_shw_establish_key);
+EXPORT_SYMBOL(fsl_shw_read_key);
+EXPORT_SYMBOL(fsl_shw_extract_key);
+EXPORT_SYMBOL(fsl_shw_release_key);
+
+extern fsl_shw_return_t alloc_slot(fsl_shw_uco_t * user_ctx,
+				   fsl_shw_sko_t * key_info);
+
+extern fsl_shw_return_t load_slot(fsl_shw_uco_t * user_ctx,
+				  fsl_shw_sko_t * key_info,
+				  const uint8_t * key);
+
+extern fsl_shw_return_t dealloc_slot(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info);
+
+/*!
+ * Initalialize SKO and SCCO used for T <==> T' cipher operation
+ *
+ * @param wrap_key  Which wrapping key user wants
+ * @param key_info  Key object for selecting wrap key
+ * @param wrap_ctx  Sym Context object for doing the cipher op
+ */
+static inline void init_wrap_key(fsl_shw_pf_key_t wrap_key,
+				 fsl_shw_sko_t * key_info,
+				 fsl_shw_scco_t * wrap_ctx)
+{
+	fsl_shw_sko_init_pf_key(key_info, FSL_KEY_ALG_TDES, wrap_key);
+	fsl_shw_scco_init(wrap_ctx, FSL_KEY_ALG_TDES, FSL_SYM_MODE_ECB);
+}
+
+/*!
+ * Insert descriptors to calculate ICV = HMAC(key=T, data=LEN|ALG|KEY')
+ *
+ * @param  user_ctx      A user context from #fsl_shw_register_user().
+ * @param  T             Location of nonce (length is T_LENGTH bytes)
+ * @param  userid        Location of userid/ownerid
+ * @param  userid_len    Length, in bytes of @c userid
+ * @param  black_key     Beginning of Black Key region
+ * @param  key_length    Number of bytes of key' there are in @c black_key
+ * @param[out] hmac      Location to store ICV.  Will be tagged "USES" so
+ *                       sf routines will not try to free it.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+static fsl_shw_return_t calc_icv(const uint8_t * T,
+				 const uint8_t * userid,
+				 unsigned int userid_len,
+				 const uint8_t * black_key,
+				 uint32_t key_length, uint8_t * hmac)
+{
+	fsl_shw_return_t code;
+	shw_hmac_state_t hmac_state;
+
+	/* Load up T as key for the HMAC */
+	code = shw_hmac_init(&hmac_state, T, T_LENGTH);
+	if (code != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	/* Previous step loaded key; Now set up to hash the data */
+
+	/* Input - start with ownerid */
+	code = shw_hmac_update(&hmac_state, userid, userid_len);
+	if (code != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	/* Still input  - Append black-key fields len, alg, key' */
+	code = shw_hmac_update(&hmac_state,
+			       (void *)black_key + LENGTH_OFFSET,
+			       (LENGTH_LENGTH
+				+ ALGORITHM_LENGTH
+				+ FLAGS_LENGTH + key_length));
+	if (code != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	/* Output - computed ICV/HMAC */
+	code = shw_hmac_final(&hmac_state, hmac, ICV_LENGTH);
+	if (code != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+      out:
+
+	return code;
+}				/* calc_icv */
+
+/*!
+ * Compute and return the KEK (Key Encryption Key) from the inputs
+ *
+ * @param userid      The user's 'secret' for the key
+ * @param userid_len  Length, in bytes of @c userid
+ * @param T           The nonce
+ * @param[out] kek    Location to store the computed KEK. It will
+ *                    be 21 bytes long.
+ *
+ * @return the usual error code
+ */
+static fsl_shw_return_t calc_kek(const uint8_t * userid,
+				 unsigned int userid_len,
+				 const uint8_t * T, uint8_t * kek)
+{
+	fsl_shw_return_t code = FSL_RETURN_INTERNAL_ERROR_S;
+	shw_hash_state_t hash_state;
+
+	code = shw_hash_init(&hash_state, FSL_HASH_ALG_SHA256);
+	if (code != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+	LOG_DIAG_ARGS("Hash init failed: %s\n", fsl_error_string(code));
+#endif
+		goto out;
+	}
+
+	code = shw_hash_update(&hash_state, T, T_LENGTH);
+	if (code != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+	LOG_DIAG_ARGS("Hash for T failed: %s\n",
+			      fsl_error_string(code));
+#endif
+		goto out;
+	}
+
+	code = shw_hash_update(&hash_state, userid, userid_len);
+	if (code != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("Hash for userid failed: %s\n",
+			      fsl_error_string(code));
+#endif
+		goto out;
+	}
+
+	code = shw_hash_final(&hash_state, kek, KEK_LENGTH);
+	if (code != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("Could not extract kek: %s\n",
+			      fsl_error_string(code));
+#endif
+		goto out;
+	}
+
+#if KEK_LENGTH != 21
+	{
+		uint8_t permuted_kek[21];
+
+		fsl_shw_permute1_bytes(kek, permuted_kek, KEK_LENGTH / 8);
+		memcpy(kek, permuted_kek, 21);
+		memset(permuted_kek, 0, sizeof(permuted_kek));
+	}
+#endif
+
+#ifdef DIAG_SECURITY_FUNC
+	dump("kek", kek, 21);
+#endif
+
+      out:
+
+	return code;
+}				/* end fn calc_kek */
+
+/*!
+ * Validate user's wrap key selection
+ *
+ * @param wrap_key   The user's desired wrapping key
+ */
+static fsl_shw_return_t check_wrap_key(fsl_shw_pf_key_t wrap_key)
+{
+	/* unable to use desired key */
+	fsl_shw_return_t ret = FSL_RETURN_NO_RESOURCE_S;
+
+	if ((wrap_key != FSL_SHW_PF_KEY_IIM) &&
+	    (wrap_key != FSL_SHW_PF_KEY_RND) &&
+	    (wrap_key != FSL_SHW_PF_KEY_IIM_RND)) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Invalid wrap_key in key wrap/unwrap attempt");
+#endif
+		goto out;
+	}
+	ret = FSL_RETURN_OK_S;
+
+      out:
+	return ret;
+}				/* end fn check_wrap_key */
+
+/*!
+ * Perform unwrapping of a black key into a RED slot
+ *
+ * @param         user_ctx      A user context from #fsl_shw_register_user().
+ * @param[in,out] key_info      The information about the key to be which will
+ *                              be unwrapped... key length, slot info, etc.
+ * @param         black_key     Encrypted key
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+static fsl_shw_return_t unwrap(fsl_shw_uco_t * user_ctx,
+			       fsl_shw_sko_t * key_info,
+			       const uint8_t * black_key)
+{
+	fsl_shw_return_t ret;
+	uint8_t hmac[ICV_LENGTH];
+	uint8_t T[T_LENGTH];
+	uint8_t kek[KEK_LENGTH + 20];
+	int key_length = black_key[LENGTH_OFFSET];
+	int rounded_key_length = ROUND_LENGTH(key_length);
+	uint8_t key[rounded_key_length];
+	fsl_shw_sko_t t_key_info;
+	fsl_shw_scco_t t_key_ctx;
+	fsl_shw_sko_t kek_key_info;
+	fsl_shw_scco_t kek_ctx;
+	int unwrapping_sw_key = key_info->flags & FSL_SKO_KEY_SW_KEY;
+	int pk_needs_restoration = 0;	/* bool */
+	unsigned original_key_length = key_info->key_length;
+	int pk_was_held = 0;
+	uint8_t current_pk[21];
+	di_return_t di_code;
+
+	ret = check_wrap_key(user_ctx->wrap_key);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	if (black_key == NULL) {
+		ret = FSL_RETURN_ERROR_S;
+		goto out;
+	}
+#ifdef DIAG_SECURITY_FUNC
+	dump("black", black_key, KEY_PRIME_OFFSET + key_length);
+#endif
+	/* Validate SW flags to prevent misuse */
+		if ((key_info->flags & FSL_SKO_KEY_SW_KEY)
+			&& !(black_key[FLAGS_OFFSET] & FLAGS_SW_KEY)) {
+			ret = FSL_RETURN_BAD_FLAG_S;
+			goto out;
+		}
+
+	/* Compute T = 3des-dec-ecb(wrap_key, T') */
+	init_wrap_key(user_ctx->wrap_key, &t_key_info, &t_key_ctx);
+	ret = fsl_shw_symmetric_decrypt(user_ctx, &t_key_info, &t_key_ctx,
+					T_LENGTH,
+					black_key + T_PRIME_OFFSET, T);
+	if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Recovery of nonce (T) failed");
+#endif				/*DIAG_SECURITY_FUNC */
+		goto out;
+	}
+
+	/* Compute ICV = HMAC(T, ownerid | len | alg | flags | key' */
+	ret = calc_icv(T, (uint8_t *) & key_info->userid,
+		       sizeof(key_info->userid),
+		       black_key, original_key_length, hmac);
+
+	if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Calculation of ICV failed");
+#endif				/*DIAG_SECURITY_FUNC */
+		goto out;
+	}
+#ifdef DIAG_SECURITY_FUNC
+	LOG_DIAG("Validating MAC of wrapped key");
+#endif
+
+	/* Check computed ICV against value in Black Key */
+	if (memcmp(black_key + ICV_OFFSET, hmac, ICV_LENGTH) != 0) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Computed ICV fails validation\n");
+#endif
+		ret = FSL_RETURN_AUTH_FAILED_S;
+		goto out;
+	}
+
+	/* Compute KEK = SHA256(T | ownerid). */
+	ret = calc_kek((uint8_t *) & key_info->userid, sizeof(key_info->userid),
+		       T, kek);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	if (unwrapping_sw_key) {
+		di_code = dryice_get_programmed_key(current_pk, 8 * 21);
+		if (di_code != DI_SUCCESS) {
+#ifdef DIAG_SECURITY_FUNC
+			LOG_DIAG_ARGS("Could not save current PK: %s\n",
+				      di_error_string(di_code));
+#endif
+			ret = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+	}
+
+	/*
+	 * "Establish" the KEK in the PK.  If the PK was held and unwrapping a
+	 * software key, then release it and try again, but remember that we need
+	 * to leave it 'held' if we are unwrapping a software key.
+	 *
+	 * If the PK is held while we are unwrapping a key for the PK, then
+	 * the user didn't call release, so gets an error.
+	 */
+	di_code = dryice_set_programmed_key(kek, 8 * 21, 0);
+	if ((di_code == DI_ERR_INUSE) && unwrapping_sw_key) {
+		/* Temporarily reprogram the PK out from under the user */
+		pk_was_held = 1;
+		dryice_release_programmed_key();
+		di_code = dryice_set_programmed_key(kek, 8 * 21, 0);
+	}
+	if (di_code != DI_SUCCESS) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("Could not program KEK: %s\n",
+			      di_error_string(di_code));
+#endif
+		ret = FSL_RETURN_ERROR_S;
+		goto out;
+	}
+
+	if (unwrapping_sw_key) {
+		pk_needs_restoration = 1;
+	}
+	dryice_release_programmed_key();	/* Because of previous 'set' */
+
+	/* Compute KEY = TDES-decrypt(KEK, KEY') */
+	fsl_shw_sko_init_pf_key(&kek_key_info, FSL_KEY_ALG_TDES,
+				FSL_SHW_PF_KEY_PRG);
+	fsl_shw_sko_set_key_length(&kek_key_info, KEK_LENGTH);
+
+	fsl_shw_scco_init(&kek_ctx, FSL_KEY_ALG_TDES, FSL_SYM_MODE_CBC);
+	fsl_shw_scco_set_flags(&kek_ctx, FSL_SYM_CTX_LOAD);
+	fsl_shw_scco_set_context(&kek_ctx, (uint8_t *) & key_info->userid);
+#ifdef DIAG_SECURITY_FUNC
+	dump("KEY'", black_key + KEY_PRIME_OFFSET, rounded_key_length);
+#endif
+	ret = fsl_shw_symmetric_decrypt(user_ctx, &kek_key_info, &kek_ctx,
+					rounded_key_length,
+					black_key + KEY_PRIME_OFFSET, key);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+#ifdef DIAG_SECURITY_FUNC
+	dump("KEY", key, original_key_length);
+#endif
+	/* Now either put key into PK or into a slot */
+	if (key_info->flags & FSL_SKO_KEY_SW_KEY) {
+		ret = load_slot(user_ctx, key_info, key);
+	} else {
+		/*
+		 * Since we have just unwrapped a program key, it had
+		 * to have been wrapped as a program key, so it must
+		 * be 168 bytes long and permuted ...
+		 */
+		ret = dryice_set_programmed_key(key, 8 * key_length, 0);
+		if (ret != FSL_RETURN_OK_S) {
+			goto out;
+		}
+	}
+
+      out:
+	key_info->key_length = original_key_length;
+
+	if (pk_needs_restoration) {
+		di_code = dryice_set_programmed_key(current_pk, 8 * 21, 0);
+	}
+
+	if (!pk_was_held) {
+		dryice_release_programmed_key();
+	}
+
+	/* Erase tracks of confidential data */
+	memset(T, 0, T_LENGTH);
+	memset(key, 0, rounded_key_length);
+	memset(current_pk, 0, sizeof(current_pk));
+	memset(&t_key_info, 0, sizeof(t_key_info));
+	memset(&t_key_ctx, 0, sizeof(t_key_ctx));
+	memset(&kek_key_info, 0, sizeof(kek_key_info));
+	memset(&kek_ctx, 0, sizeof(kek_ctx));
+	memset(kek, 0, KEK_LENGTH);
+
+	return ret;
+}				/* unwrap */
+
+/*!
+ * Perform wrapping of a black key from a RED slot (or the PK register)
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param[in,out] key_info      The information about the key to be which will
+ *                              be wrapped... key length, slot info, etc.
+ * @param      black_key        Place to store encrypted key
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+static fsl_shw_return_t wrap(fsl_shw_uco_t * user_ctx,
+			     fsl_shw_sko_t * key_info, uint8_t * black_key)
+{
+	fsl_shw_return_t ret = FSL_RETURN_OK_S;
+	fsl_shw_sko_t t_key_info;	/* for holding T */
+	fsl_shw_scco_t t_key_ctx;
+	fsl_shw_sko_t kek_key_info;
+	fsl_shw_scco_t kek_ctx;
+	unsigned original_key_length = key_info->key_length;
+	unsigned rounded_key_length;
+	uint8_t T[T_LENGTH];
+	uint8_t kek[KEK_LENGTH + 20];
+	uint8_t *red_key = 0;
+	int red_key_malloced = 0;	/* bool */
+	int pk_was_held = 0;	/* bool */
+	uint8_t saved_pk[21];
+	uint8_t pk_needs_restoration;	/* bool */
+	di_return_t di_code;
+
+	ret = check_wrap_key(user_ctx->wrap_key);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	if (black_key == NULL) {
+		ret = FSL_RETURN_ERROR_S;
+		goto out;
+	}
+
+	if (key_info->flags & FSL_SKO_KEY_SELECT_PF_KEY) {
+		if ((key_info->pf_key != FSL_SHW_PF_KEY_PRG)
+		    && (key_info->pf_key != FSL_SHW_PF_KEY_IIM_PRG)) {
+			ret = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+	} else {
+		if (!(key_info->flags & FSL_SKO_KEY_ESTABLISHED)) {
+			ret = FSL_RETURN_BAD_FLAG_S;	/* not established! */
+			goto out;
+		}
+	}
+
+	black_key[ALGORITHM_OFFSET] = key_info->algorithm;
+
+#ifndef DO_REPEATABLE_WRAP
+	/* Compute T = RND() */
+	ret = fsl_shw_get_random(user_ctx, T_LENGTH, T);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+#else
+	memcpy(T, T_block, T_LENGTH);
+#endif
+
+	/* Compute KEK = SHA256(T | ownerid). */
+	ret = calc_kek((uint8_t *) & key_info->userid, sizeof(key_info->userid),
+		       T, kek);
+	if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Calculation of KEK failed\n");
+#endif				/*DIAG_SECURITY_FUNC */
+		goto out;
+	}
+
+	rounded_key_length = ROUND_LENGTH(original_key_length);
+
+	di_code = dryice_get_programmed_key(saved_pk, 8 * 21);
+	if (di_code != DI_SUCCESS) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("Could not save current PK: %s\n",
+			      di_error_string(di_code));
+#endif
+		ret = FSL_RETURN_ERROR_S;
+		goto out;
+	}
+
+	/*
+	 * Load KEK into DI PKR.  Note that we are NOT permuting it before loading,
+	 * so we are using it as though it is a 168-bit key ready for the SCC.
+	 */
+	di_code = dryice_set_programmed_key(kek, 8 * 21, 0);
+	if (di_code == DI_ERR_INUSE) {
+		/* Temporarily reprogram the PK out from under the user */
+		pk_was_held = 1;
+		dryice_release_programmed_key();
+		di_code = dryice_set_programmed_key(kek, 8 * 21, 0);
+	}
+	if (di_code != DI_SUCCESS) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("Could not program KEK: %s\n",
+			      di_error_string(di_code));
+#endif
+		ret = FSL_RETURN_ERROR_S;
+		goto out;
+	}
+	pk_needs_restoration = 1;
+	dryice_release_programmed_key();
+
+	/* Find red key */
+	if (key_info->flags & FSL_SKO_KEY_SELECT_PF_KEY) {
+		black_key[LENGTH_OFFSET] = 21;
+		rounded_key_length = 24;
+
+		red_key = saved_pk;
+	} else {
+		black_key[LENGTH_OFFSET] = key_info->key_length;
+
+		red_key = os_alloc_memory(key_info->key_length, 0);
+		if (red_key == NULL) {
+			ret = FSL_RETURN_NO_RESOURCE_S;
+			goto out;
+		}
+		red_key_malloced = 1;
+
+		ret = fsl_shw_read_key(user_ctx, key_info, red_key);
+		if (ret != FSL_RETURN_OK_S) {
+			goto out;
+		}
+	}
+
+#ifdef DIAG_SECURITY_FUNC
+	dump("KEY", red_key, black_key[LENGTH_OFFSET]);
+#endif
+	/* Compute KEY' = TDES-encrypt(KEK, KEY) */
+	fsl_shw_sko_init_pf_key(&kek_key_info, FSL_KEY_ALG_TDES,
+				FSL_SHW_PF_KEY_PRG);
+	fsl_shw_sko_set_key_length(&kek_key_info, KEK_LENGTH);
+
+	fsl_shw_scco_init(&kek_ctx, FSL_KEY_ALG_TDES, FSL_SYM_MODE_CBC);
+	fsl_shw_scco_set_flags(&kek_ctx, FSL_SYM_CTX_LOAD);
+	fsl_shw_scco_set_context(&kek_ctx, (uint8_t *) & key_info->userid);
+	ret = fsl_shw_symmetric_encrypt(user_ctx, &kek_key_info, &kek_ctx,
+					rounded_key_length,
+					red_key, black_key + KEY_PRIME_OFFSET);
+	if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Encryption of KEY failed\n");
+#endif				/*DIAG_SECURITY_FUNC */
+		goto out;
+	}
+
+	/* Set up flags info */
+	black_key[FLAGS_OFFSET] = 0;
+	if (key_info->flags & FSL_SKO_KEY_SW_KEY) {
+		black_key[FLAGS_OFFSET] |= FLAGS_SW_KEY;
+	}
+#ifdef DIAG_SECURITY_FUNC
+	dump("KEY'", black_key + KEY_PRIME_OFFSET, rounded_key_length);
+#endif
+	/* Compute and store ICV into Black Key */
+	ret = calc_icv(T,
+		       (uint8_t *) & key_info->userid,
+		       sizeof(key_info->userid),
+		       black_key, original_key_length, black_key + ICV_OFFSET);
+	if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Calculation of ICV failed\n");
+#endif				/*DIAG_SECURITY_FUNC */
+		goto out;
+	}
+
+	/* Compute T' = 3des-enc-ecb(wrap_key, T); Result goes to Black Key */
+	init_wrap_key(user_ctx->wrap_key, &t_key_info, &t_key_ctx);
+	ret = fsl_shw_symmetric_encrypt(user_ctx, &t_key_info, &t_key_ctx,
+					T_LENGTH,
+					T, black_key + T_PRIME_OFFSET);
+	if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Encryption of nonce failed");
+#endif
+		goto out;
+	}
+#ifdef DIAG_SECURITY_FUNC
+	dump("black", black_key, KEY_PRIME_OFFSET + black_key[LENGTH_OFFSET]);
+#endif
+
+      out:
+	if (pk_needs_restoration) {
+		dryice_set_programmed_key(saved_pk, 8 * 21, 0);
+	}
+
+	if (!pk_was_held) {
+		dryice_release_programmed_key();
+	}
+
+	if (red_key_malloced) {
+		memset(red_key, 0, key_info->key_length);
+		os_free_memory(red_key);
+	}
+
+	key_info->key_length = original_key_length;
+
+	/* Erase tracks of confidential data */
+	memset(T, 0, T_LENGTH);
+	memset(&t_key_info, 0, sizeof(t_key_info));
+	memset(&t_key_ctx, 0, sizeof(t_key_ctx));
+	memset(&kek_key_info, 0, sizeof(kek_key_info));
+	memset(&kek_ctx, 0, sizeof(kek_ctx));
+	memset(kek, 0, sizeof(kek));
+	memset(saved_pk, 0, sizeof(saved_pk));
+
+	return ret;
+}				/* wrap */
+
+static fsl_shw_return_t create(fsl_shw_uco_t * user_ctx,
+			       fsl_shw_sko_t * key_info)
+{
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+	unsigned key_length = key_info->key_length;
+	di_return_t di_code;
+
+	if (!(key_info->flags & FSL_SKO_KEY_SW_KEY)) {
+		/* Must be creating key for PK */
+		if ((key_info->algorithm != FSL_KEY_ALG_TDES) ||
+		    ((key_info->key_length != 16)
+		     && (key_info->key_length != 21)	/* permuted 168-bit key */
+		     &&(key_info->key_length != 24))) {
+			ret = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+
+		key_length = 21;	/* 168-bit PK */
+	}
+
+	/* operational block */
+	{
+		uint8_t key_value[key_length];
+
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Creating random key\n");
+#endif
+		ret = fsl_shw_get_random(user_ctx, key_length, key_value);
+		if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+			LOG_DIAG("get_random for CREATE KEY failed\n");
+#endif
+			goto out;
+		}
+
+		if (key_info->flags & FSL_SKO_KEY_SW_KEY) {
+			ret = load_slot(user_ctx, key_info, key_value);
+		} else {
+			di_code =
+			    dryice_set_programmed_key(key_value, 8 * key_length,
+						      0);
+			if (di_code != 0) {
+#ifdef DIAG_SECURITY_FUNC
+				LOG_DIAG_ARGS("di set_pk failed: %s\n",
+					      di_error_string(di_code));
+#endif
+				ret = FSL_RETURN_ERROR_S;
+				goto out;
+			}
+			ret = FSL_RETURN_OK_S;
+		}
+		memset(key_value, 0, key_length);
+	}			/* end operational block */
+
+#ifdef DIAG_SECURITY_FUNC
+	if (ret != FSL_RETURN_OK_S) {
+		LOG_DIAG("Loading random key failed");
+	}
+#endif
+
+      out:
+
+	return ret;
+}				/* end fn create */
+
+static fsl_shw_return_t accept(fsl_shw_uco_t * user_ctx,
+			       fsl_shw_sko_t * key_info, const uint8_t * key)
+{
+	uint8_t permuted_key[21];
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+
+	if (key == NULL) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("ACCEPT:  Red Key is NULL");
+#endif
+		ret = FSL_RETURN_ERROR_S;
+		goto out;
+	}
+#ifdef DIAG_SECURITY_FUNC
+	dump("red", key, key_info->key_length);
+#endif
+	/* Only SW keys go into the keystore */
+	if (key_info->flags & FSL_SKO_KEY_SW_KEY) {
+
+		/* Copy in safe number of bytes of Red key */
+		ret = load_slot(user_ctx, key_info, key);
+	} else {		/* not SW key */
+		di_return_t di_ret;
+
+		/* Only 3DES PGM key types can be established */
+		if (((key_info->pf_key != FSL_SHW_PF_KEY_PRG)
+		     && (key_info->pf_key != FSL_SHW_PF_KEY_IIM_PRG))
+		    || (key_info->algorithm != FSL_KEY_ALG_TDES)) {
+#ifdef DIAG_SECURITY_FUNC
+			LOG_DIAG_ARGS
+			    ("ACCEPT:  Failed trying to establish non-PRG"
+			     " or invalid 3DES Key: iim%d, iim_prg%d, alg%d\n",
+			     (key_info->pf_key != FSL_SHW_PF_KEY_PRG),
+			     (key_info->pf_key != FSL_SHW_PF_KEY_IIM_PRG),
+			     (key_info->algorithm != FSL_KEY_ALG_TDES));
+#endif
+			ret = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+		if ((key_info->key_length != 16)
+		    && (key_info->key_length != 21)
+		    && (key_info->key_length != 24)) {
+#ifdef DIAG_SECURITY_FUNC
+			LOG_DIAG_ARGS("ACCEPT:  Failed trying to establish"
+				      " invalid 3DES Key: len=%d (%d)\n",
+				      key_info->key_length,
+				      ((key_info->key_length != 16)
+				       && (key_info->key_length != 21)
+				       && (key_info->key_length != 24)));
+#endif
+			ret = FSL_RETURN_BAD_KEY_LENGTH_S;
+			goto out;
+		}
+
+		/* Convert key into 168-bit value and put it into PK */
+		if (key_info->key_length != 21) {
+			fsl_shw_permute1_bytes(key, permuted_key,
+					       key_info->key_length / 8);
+			di_ret =
+			    dryice_set_programmed_key(permuted_key, 168, 0);
+		} else {
+			/* Already permuted ! */
+			di_ret = dryice_set_programmed_key(key, 168, 0);
+		}
+		if (di_ret != DI_SUCCESS) {
+#ifdef DIAG_SECURITY_FUNC
+			LOG_DIAG_ARGS
+			    ("ACCEPT:  DryIce error setting Program Key: %s",
+			     di_error_string(di_ret));
+#endif
+			ret = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+	}
+
+	ret = FSL_RETURN_OK_S;
+
+      out:
+	memset(permuted_key, 0, 21);
+
+	return ret;
+}				/* end fn accept */
+
+/*!
+ * Place a key into a protected location for use only by cryptographic
+ * algorithms.
+ *
+ * This only needs to be used to a) unwrap a key, or b) set up a key which
+ * could be wrapped by calling #fsl_shw_extract_key() at some later time).
+ *
+ * The protected key will not be available for use until this operation
+ * successfully completes.
+ *
+ * @bug This whole discussion needs review.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param[in,out] key_info      The information about the key to be which will
+ *                              be established.  In the create case, the key
+ *                              length must be set.
+ * @param      establish_type   How @a key will be interpreted to establish a
+ *                              key for use.
+ * @param key                   If @a establish_type is #FSL_KEY_WRAP_UNWRAP,
+ *                              this is the location of a wrapped key.  If
+ *                              @a establish_type is #FSL_KEY_WRAP_CREATE, this
+ *                              parameter can be @a NULL.  If @a establish_type
+ *                              is #FSL_KEY_WRAP_ACCEPT, this is the location
+ *                              of a plaintext key.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
+				       fsl_shw_sko_t * key_info,
+				       fsl_shw_key_wrap_t establish_type,
+				       const uint8_t * key)
+{
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+	unsigned original_key_length = key_info->key_length;
+	unsigned rounded_key_length;
+	unsigned slot_allocated = 0;
+
+	/* For now, only blocking mode calls are supported */
+	if (!(user_ctx->flags & FSL_UCO_BLOCKING_MODE)) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("%s: Non-blocking call not supported\n",
+			      __FUNCTION__);
+#endif
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	/*
+	   HW keys are always 'established', but otherwise do not allow user
+	   * to establish over the top of an established key.
+	 */
+	if ((key_info->flags & FSL_SKO_KEY_ESTABLISHED)
+	    && !(key_info->flags & FSL_SKO_KEY_SELECT_PF_KEY)) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("%s: Key already established\n", __FUNCTION__);
+#endif
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	/* @bug VALIDATE KEY flags here -- SW or PRG/IIM_PRG */
+
+	/* Write operations into SCC memory require word-multiple number of
+	 * bytes.  For ACCEPT and CREATE functions, the key length may need
+	 * to be rounded up.  Calculate. */
+	if (LENGTH_PATCH && (original_key_length & LENGTH_PATCH_MASK) != 0) {
+		rounded_key_length = original_key_length + LENGTH_PATCH
+		    - (original_key_length & LENGTH_PATCH_MASK);
+	} else {
+		rounded_key_length = original_key_length;
+	}
+
+	/* SW keys need a place to live */
+	if (key_info->flags & FSL_SKO_KEY_SW_KEY) {
+		ret = alloc_slot(user_ctx, key_info);
+		if (ret != FSL_RETURN_OK_S) {
+#ifdef DIAG_SECURITY_FUNC
+			LOG_DIAG("Slot allocation failed\n");
+#endif
+			goto out;
+		}
+		slot_allocated = 1;
+	}
+
+	switch (establish_type) {
+	case FSL_KEY_WRAP_CREATE:
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Creating random key\n");
+#endif
+		ret = create(user_ctx, key_info);
+		break;
+
+	case FSL_KEY_WRAP_ACCEPT:
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Accepting plaintext key\n");
+#endif
+		ret = accept(user_ctx, key_info, key);
+		break;
+
+	case FSL_KEY_WRAP_UNWRAP:
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Unwrapping wrapped key\n");
+#endif
+		ret = unwrap(user_ctx, key_info, key);
+		break;
+
+	default:
+		ret = FSL_RETURN_BAD_FLAG_S;
+		break;
+	}			/* switch */
+
+      out:
+	if (ret != FSL_RETURN_OK_S) {
+		if (slot_allocated) {
+			(void)dealloc_slot(user_ctx, key_info);
+		}
+		key_info->flags &= ~FSL_SKO_KEY_ESTABLISHED;
+	} else {
+		key_info->flags |= FSL_SKO_KEY_ESTABLISHED;
+	}
+
+	return ret;
+}				/* end fn fsl_shw_establish_key */
+
+/*!
+ * Wrap a key and retrieve the wrapped value.
+ *
+ * A wrapped key is a key that has been cryptographically obscured.  It is
+ * only able to be used with #fsl_shw_establish_key().
+ *
+ * This function will also release a software  key (see #fsl_shw_release_key())
+ * so it must be re-established before reuse. This is not true of PGM keys.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      key_info         The information about the key to be deleted.
+ * @param[out] covered_key      The location to store the 48-octet wrapped key.
+ *                              (This size is based upon the maximum key size
+ *                              of 32 octets).
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info,
+				     uint8_t * covered_key)
+{
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+
+	/* For now, only blocking mode calls are supported */
+	if (!(user_ctx->flags & FSL_UCO_BLOCKING_MODE)) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+#ifdef DIAG_SECURITY_FUNC
+	LOG_DIAG("Wrapping a key\n");
+#endif
+
+	if (!(key_info->flags & FSL_SKO_KEY_ESTABLISHED)) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("%s: Key not established\n", __FUNCTION__);
+#endif
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+	/* Verify that a SW key info really belongs to a SW key */
+	if (key_info->flags & FSL_SKO_KEY_SW_KEY) {
+	/*	  ret = FSL_RETURN_BAD_FLAG_S;
+		  goto out;*/
+	}
+
+	ret = wrap(user_ctx, key_info, covered_key);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
+	}
+
+	if (key_info->flags & FSL_SKO_KEY_SW_KEY) {
+		/* Need to deallocate on successful extraction */
+		(void)dealloc_slot(user_ctx, key_info);
+		/* Mark key not available in the flags */
+		key_info->flags &=
+		    ~(FSL_SKO_KEY_ESTABLISHED | FSL_SKO_KEY_PRESENT);
+		memset(key_info->key, 0, sizeof(key_info->key));
+	}
+
+      out:
+	return ret;
+}				/* end fn fsl_shw_extract_key */
+
+/*!
+ * De-establish a key so that it can no longer be accessed.
+ *
+ * The key will need to be re-established before it can again be used.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      key_info         The information about the key to be deleted.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info)
+{
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+
+	/* For now, only blocking mode calls are supported */
+	if (!(user_ctx->flags & FSL_UCO_BLOCKING_MODE)) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Not in blocking mode\n");
+#endif
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+#ifdef DIAG_SECURITY_FUNC
+	LOG_DIAG("Releasing a key\n");
+#endif
+
+	if (!(key_info->flags & FSL_SKO_KEY_ESTABLISHED)) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Key not established\n");
+#endif
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	if (key_info->flags & FSL_SKO_KEY_SW_KEY) {
+		(void)dealloc_slot(user_ctx, key_info);
+		/* Turn off 'established' flag */
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("dealloc_slot() called\n");
+#endif
+		key_info->flags &= ~FSL_SKO_KEY_ESTABLISHED;
+		ret = FSL_RETURN_OK_S;
+		goto out;
+	}
+
+	if ((key_info->pf_key == FSL_SHW_PF_KEY_PRG)
+	    || (key_info->pf_key == FSL_SHW_PF_KEY_IIM_PRG)) {
+		di_return_t di_ret;
+
+		di_ret = dryice_release_programmed_key();
+		if (di_ret != DI_SUCCESS) {
+#ifdef DIAG_SECURITY_FUNC
+			LOG_DIAG_ARGS
+			    ("dryice_release_programmed_key() failed: %d\n",
+			     di_ret);
+#endif
+			ret = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+	} else {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG("Neither SW nor HW key\n");
+#endif
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	ret = FSL_RETURN_OK_S;
+
+      out:
+	return ret;
+}				/* end fn fsl_shw_release_key */
+
+fsl_shw_return_t fsl_shw_read_key(fsl_shw_uco_t * user_ctx,
+				  fsl_shw_sko_t * key_info, uint8_t * key)
+{
+	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
+
+	/* Only blocking mode calls are supported */
+	if (!(user_ctx->flags & FSL_UCO_BLOCKING_MODE)) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+	printk("Reading a key\n");
+#ifdef DIAG_SECURITY_FUNC
+	LOG_DIAG("Reading a key");
+#endif
+	if (key_info->flags & FSL_SKO_KEY_PRESENT) {
+		memcpy(key_info->key, key, key_info->key_length);
+		ret = FSL_RETURN_OK_S;
+	} else if (key_info->flags & FSL_SKO_KEY_ESTABLISHED) {
+	printk("key established\n");
+		if (key_info->keystore == NULL) {
+			printk("keystore is null\n");
+			/* First verify that the key access is valid */
+			ret =
+			    system_keystore.slot_verify_access(system_keystore.
+							       user_data,
+							       key_info->userid,
+							       key_info->
+							       handle);
+
+			printk("key in system keystore\n");
+
+			/* Key is in system keystore */
+			ret = keystore_slot_read(&system_keystore,
+						 key_info->userid,
+						 key_info->handle,
+						 key_info->key_length, key);
+		} else {
+		printk("key goes in user keystore.\n");
+			/* Key goes in user keystore */
+			ret = keystore_slot_read(key_info->keystore,
+						 key_info->userid,
+						 key_info->handle,
+						 key_info->key_length, key);
+		}
+	}
+
+      out:
+	return ret;
+}				/* end fn fsl_shw_read_key */
+
+#else				/* __KERNEL__ && DRYICE */
+
+/* User mode -- these functions are unsupported */
+
+fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
+				       fsl_shw_sko_t * key_info,
+				       fsl_shw_key_wrap_t establish_type,
+				       const uint8_t * key)
+{
+	(void)user_ctx;
+	(void)key_info;
+	(void)establish_type;
+	(void)key;
+
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info,
+				     uint8_t * covered_key)
+{
+	(void)user_ctx;
+	(void)key_info;
+	(void)covered_key;
+
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info)
+{
+	(void)user_ctx;
+	(void)key_info;
+
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t fsl_shw_read_key(fsl_shw_uco_t * user_ctx,
+				  fsl_shw_sko_t * key_info, uint8_t * key)
+{
+	(void)user_ctx;
+	(void)key_info;
+	(void)key;
+
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+#endif				/* __KERNEL__ && DRYICE */
diff --git a/drivers/mxc/security/rng/include/rng_driver.h b/drivers/mxc/security/rng/include/rng_driver.h
index 01e2b55..7d6d24d 100644
--- a/drivers/mxc/security/rng/include/rng_driver.h
+++ b/drivers/mxc/security/rng/include/rng_driver.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -38,26 +38,25 @@
 
 #include "rng_rnga.h"
 
-#elif defined(FSL_HAVE_RNGC)
+#elif defined(FSL_HAVE_RNGB) || defined(FSL_HAVE_RNGC)
 
 #include "rng_rngc.h"
 
-#else				/* neither RNGA nor RNGC */
+#else				/* neither RNGA,  RNGB,  nor  RNGC */
 
 #error NO_RNG_TYPE_IDENTIFIED
 
 #endif
 
-/*!****************************************************************************
+/*****************************************************************************
  * Enumerations
  *****************************************************************************/
 
 /*! Values from Version ID register  */
 enum rng_type {
-	/*! Type RNGA. Really is unused bits from the Control Register of the
-	   RNGA. */
+	/*! Type RNGA. */
 	RNG_TYPE_RNGA = 0,
-	/*! Type B.  Unsupported by this driver. */
+	/*! Type RNGB. */
 	RNG_TYPE_RNGB = 1,
 	/*! Type RNGC */
 	RNG_TYPE_RNGC = 2
@@ -71,7 +70,7 @@ typedef enum rng_return {
 	RNG_RET_FAIL		/*!< Non-specific failure */
 } rng_return_t;
 
-/*!****************************************************************************
+/*****************************************************************************
  * Data Structures
  *****************************************************************************/
 /*!
@@ -89,7 +88,7 @@ typedef struct rng_work_entry {
 	unsigned completed;	/*!< Non-zero if job is done.  */
 } rng_work_entry_t;
 
-/*!****************************************************************************
+/*****************************************************************************
  * Function Prototypes
  *****************************************************************************/
 
diff --git a/drivers/mxc/security/rng/include/rng_internals.h b/drivers/mxc/security/rng/include/rng_internals.h
index b781ab3..0843d90 100644
--- a/drivers/mxc/security/rng/include/rng_internals.h
+++ b/drivers/mxc/security/rng/include/rng_internals.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -207,7 +207,7 @@ typedef enum rng_status {
 
 static shw_queue_t rng_work_queue;
 
-/*!****************************************************************************
+/*****************************************************************************
  *
  *  Function Declarations
  *
@@ -255,12 +255,25 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
  */
 #define RNG_CHECK_WRITE 1
 
-/*! Interrupt number for driver. */
-#define INT_RNG MXC_INT_RNG
-
 /* Define different helper symbols based on RNG type */
 #ifdef FSL_HAVE_RNGA
 
+/******************************************************************************
+ *
+ *  RNGA support
+ *
+ *****************************************************************************/
+
+/*! Interrupt number for driver. */
+#if defined(MXC_INT_RNG)
+/* Most modern definition */
+#define INT_RNG MXC_INT_RNG
+#elif defined(MXC_INT_RNGA)
+#define INT_RNG MXC_INT_RNGA
+#else
+#define INT_RNG INT_RNGA
+#endif
+
 /*! Base (bus?) address of RNG component. */
 #define RNG_BASE_ADDR RNGA_BASE_ADDR
 
@@ -272,7 +285,8 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
 /* Put RNG for Seed Generation */
 #define RNG_SEED_GEN()
 /*!
- * Return RNG Type value.  Should be RNG_TYPE_RNGA or RNG_TYPE_RNGC.
+ * Return RNG Type value.  Should be RNG_TYPE_RNGA, RNG_TYPE_RNGB,
+ * or RNG_TYPE_RNGC.
  */
 #define RNG_GET_RNG_TYPE()                                                \
     ((RNG_READ_REGISTER(RNGA_CONTROL) & RNGA_CONTROL_RNG_TYPE_MASK)       \
@@ -312,35 +326,35 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
 #define RNG_READ_FIFO()                                                  \
     RNG_READ_REGISTER(RNGA_OUTPUT_FIFO)
 
-/** Put entropy into the RNG's algorithm.
+/*! Put entropy into the RNG's algorithm.
  *  @param value  32-bit value to add to RNG's entropy.
  **/
 #define RNG_ADD_ENTROPY(value)                                           \
     RNG_WRITE_REGISTER(RNGA_ENTROPY, (value))
-/** Return non-zero in case of Error during Self Test */
+/*! Return non-zero in case of Error during Self Test */
 #define RNG_CHECK_SELF_ERR() 0
-/** Return non-zero in case of Error during Seed Generation */
+/*! Return non-zero in case of Error during Seed Generation */
 #define RNG_CHECK_SEED_ERR() 0
-/** Get the RNG started at generating output. */
+/*! Get the RNG started at generating output. */
 #define RNG_GO()                                                         \
 {                                                                        \
     register uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);         \
     RNG_WRITE_REGISTER(RNGA_CONTROL, control | RNGA_CONTROL_GO);         \
 }
-/** To clear all Error Bits in Error Status Register */
+/*! To clear all Error Bits in Error Status Register */
 #define RNG_CLEAR_ERR()
-/** Put RNG into High Assurance mode */
+/*! Put RNG into High Assurance mode */
 #define RNG_SET_HIGH_ASSURANCE()                                              \
 {                                                                             \
     register uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);              \
     RNG_WRITE_REGISTER(RNGA_CONTROL, control | RNGA_CONTROL_HIGH_ASSURANCE);  \
 }
 
-/** Return non-zero if the RNG is in High Assurance mode. */
+/*! Return non-zero if the RNG is in High Assurance mode. */
 #define RNG_GET_HIGH_ASSURANCE()                                              \
     (RNG_READ_REGISTER(RNGA_CONTROL) & RNGA_CONTROL_HIGH_ASSURANCE)
 
-/** Clear all status, error and otherwise. */
+/*! Clear all status, error and otherwise. */
 #define RNG_CLEAR_ALL_STATUS()                                                \
 {                                                                             \
     register uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);              \
@@ -349,45 +363,45 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
 /* Return non-zero if RESEED Required */
 #define RNG_RESEED() 1
 
-/** Return non-zero if Seeding is done */
+/*! Return non-zero if Seeding is done */
 #define RNG_SEED_DONE()  1
 
-/** Return non-zero if everything seems OK with the RNG. */
+/*! Return non-zero if everything seems OK with the RNG. */
 #define RNG_WORKING()                                                    \
     ((RNG_READ_REGISTER(RNGA_STATUS)                                     \
       & (RNGA_STATUS_SLEEP | RNGA_STATUS_SECURITY_VIOLATION              \
          | RNGA_STATUS_ERROR_INTERRUPT | RNGA_STATUS_FIFO_UNDERFLOW      \
          | RNGA_STATUS_LAST_READ_STATUS )) == 0)
 
-/** Put the RNG into sleep (low-power) mode. */
+/*! Put the RNG into sleep (low-power) mode. */
 #define RNG_SLEEP()                                                      \
 {                                                                        \
     register uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);         \
     RNG_WRITE_REGISTER(RNGA_CONTROL, control | RNGA_CONTROL_SLEEP);      \
 }
 
-/** Wake the RNG from sleep (low-power) mode. */
+/*! Wake the RNG from sleep (low-power) mode. */
 #define RNG_WAKE()                                                       \
 {                                                                        \
     uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);                  \
      RNG_WRITE_REGISTER(RNGA_CONTROL, control & ~RNGA_CONTROL_SLEEP);    \
 }
 
-/** Mask interrupts so that the driver/OS will not see them. */
+/*! Mask interrupts so that the driver/OS will not see them. */
 #define RNG_MASK_ALL_INTERRUPTS()                                             \
 {                                                                             \
     register uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);              \
     RNG_WRITE_REGISTER(RNGA_CONTROL, control | RNGA_CONTROL_MASK_INTERRUPTS); \
 }
 
-/** Unmask interrupts so that the driver/OS will see them. */
+/*! Unmask interrupts so that the driver/OS will see them. */
 #define RNG_UNMASK_ALL_INTERRUPTS()                                           \
 {                                                                             \
     register uint32_t control = RNG_READ_REGISTER(RNGA_CONTROL);              \
     RNG_WRITE_REGISTER(RNGA_CONTROL, control & ~RNGA_CONTROL_MASK_INTERRUPTS);\
 }
 
-/**
+/*!
  * @def RNG_PUT_RNG_TO_SLEEP()
  *
  * If compiled with #RNG_USE_LOW_POWER_MODE, this routine will put the RNG
@@ -395,7 +409,7 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
  *
  * @return none
  */
-/**
+/*!
  * @def RNG_WAKE_RNG_FROM_SLEEP()
  *
  * If compiled with #RNG_USE_LOW_POWER_MODE, this routine will wake the RNG
@@ -419,78 +433,118 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
 
 #endif				/* Use low-power mode */
 
-#else				/* FSL_HAVE_RNGC */
+#else				/* FSL_HAVE_RNGB or FSL_HAVE_RNGC */
+
+/******************************************************************************
+ *
+ *  RNGB and RNGC support
+ *
+ *****************************************************************************/
+/*
+ * The operational interfaces for RNGB and RNGC are almost identical, so
+ * the defines for RNGC work fine for both.  There are minor differences
+ * which will be treated within this conditional block.
+ */
+
+/*! Interrupt number for driver. */
+#if defined(MXC_INT_RNG)
+/* Most modern definition */
+#define INT_RNG MXC_INT_RNG
+#elif defined(MXC_INT_RNGC)
+#define INT_RNG MXC_INT_RNGC
+#elif defined(MXC_INT_RNGB)
+#define INT_RNG MXC_INT_RNGB
+#elif defined(INT_RNGC)
+#define INT_RNG INT_RNGC
+#else
+#error NO_INTERRUPT_DEFINED
+#endif
 
-/** Base (bus?) address of RNG component. */
+/*! Base address of RNG component. */
+#ifdef FSL_HAVE_RNGB
+#define RNG_BASE_ADDR RNGB_BASE_ADDR
+#else
 #define RNG_BASE_ADDR RNGC_BASE_ADDR
+#endif
 
-/** Read and return the status register. */
+/*! Read and return the status register. */
 #define RNG_GET_STATUS()                                                 \
     RNG_READ_REGISTER(RNGC_ERROR)
 
-/**
+/*!
  * Return RNG Type value.  Should be RNG_TYPE_RNGA or RNG_TYPE_RNGC.
  */
 #define RNG_GET_RNG_TYPE()                                                \
     ((RNG_READ_REGISTER(RNGC_VERSION_ID) & RNGC_VERID_RNG_TYPE_MASK)      \
      >> RNGC_VERID_RNG_TYPE_SHIFT)
 
-/**
+/*!
  * Verify Type value of RNG.
  *
  * Returns true of OK, false if not.
  */
+#ifdef FSL_HAVE_RNGB
+#define RNG_VERIFY_TYPE(type)                                             \
+    ((type) == RNG_TYPE_RNGB)
+#else				/* RNGC */
 #define RNG_VERIFY_TYPE(type)                                             \
     ((type) == RNG_TYPE_RNGC)
+#endif
 
-/** Returns non-zero if RNG device is reporting an error. */
+/*! Returns non-zero if RNG device is reporting an error. */
 #define RNG_HAS_ERROR()                                                   \
     (RNG_READ_REGISTER(RNGC_STATUS) & RNGC_STATUS_ERROR)
-/** Returns non-zero if Bad Key is selected */
+/*! Returns non-zero if Bad Key is selected */
 #define RNG_HAS_BAD_KEY()                                                 \
      (RNG_READ_REGISTER(RNGC_ERROR) & RNGC_ERROR_STATUS_BAD_KEY)
-/** Returns non-zero if RNG ring oscillators have failed. */
+/*! Returns non-zero if RNG ring oscillators have failed. */
 #define RNG_OSCILLATOR_FAILED()                                           \
     (RNG_READ_REGISTER(RNGC_ERROR) & RNGC_ERROR_STATUS_OSC_ERR)
 
-/** Returns maximum number of 32-bit words in the RNG's output fifo. */
+/*! Returns maximum number of 32-bit words in the RNG's output fifo. */
 #define RNG_GET_FIFO_SIZE()                                               \
     ((RNG_READ_REGISTER(RNGC_STATUS) & RNGC_STATUS_FIFO_SIZE_MASK)        \
      >> RNGC_STATUS_FIFO_SIZE_SHIFT)
 
-/** Returns number of 32-bit words currently in the RNG's output fifo. */
+/*! Returns number of 32-bit words currently in the RNG's output fifo. */
 #define RNG_GET_WORDS_IN_FIFO()                                           \
     ((RNG_READ_REGISTER(RNGC_STATUS) & RNGC_STATUS_FIFO_LEVEL_MASK)       \
      >> RNGC_STATUS_FIFO_LEVEL_SHIFT)
 
-/** Get a random value from the RNG's output FIFO. */
+/*! Get a random value from the RNG's output FIFO. */
 #define RNG_READ_FIFO()                                                   \
     RNG_READ_REGISTER(RNGC_FIFO)
 
-/** Put entropy into the RNG's algorithm.
+/*! Put entropy into the RNG's algorithm.
  *  @param value  32-bit value to add to RNG's entropy.
  **/
+#ifdef FSL_HAVE_RNGB
+#define RNG_ADD_ENTROPY(value)                                             \
+    RNG_WRITE_REGISTER(RNGB_ENTROPY, value)
+#else				/* RNGC does not have Entropy register */
 #define RNG_ADD_ENTROPY(value)
-/** Wake the RNG from sleep (low-power) mode. */
+#endif
+/*! Wake the RNG from sleep (low-power) mode. */
 #define RNG_WAKE()  1
-/** Get the RNG started at generating output. */
+/*! Get the RNG started at generating output. */
 #define RNG_GO()
-/** Put RNG into High Assurance mode. */
+/*! Put RNG into High Assurance mode. */
 #define RNG_SET_HIGH_ASSURANCE()
-/** Returns non-zero in case of Error during Self Test       */
+/*! Returns non-zero in case of Error during Self Test       */
 #define RNG_CHECK_SELF_ERR()                                                 \
-	(RNG_READ_REGISTER(RNGC_ERROR) & RNGC_ERROR_STATUS_ST_ERR)
-/** Return non-zero in case of Error during Seed Generation */
+        (RNG_READ_REGISTER(RNGC_ERROR) & RNGC_ERROR_STATUS_ST_ERR)
+/*! Return non-zero in case of Error during Seed Generation */
 #define RNG_CHECK_SEED_ERR()                                                 \
         (RNG_READ_REGISTER(RNGC_ERROR) & RNGC_ERROR_STATUS_STAT_ERR)
 
+/*! Configure RNG for Self Test */
 #define RNG_SELF_TEST()                                                       \
 {                                                                             \
     register uint32_t command = RNG_READ_REGISTER(RNGC_COMMAND);              \
     RNG_WRITE_REGISTER(RNGC_COMMAND, command                                  \
                                     | RNGC_COMMAND_SELF_TEST);                \
 }
-/** Clearing the Error bits in Error Status Register */
+/*! Clearing the Error bits in Error Status Register */
 #define RNG_CLEAR_ERR()                                                       \
 {                                                                             \
     register uint32_t command = RNG_READ_REGISTER(RNGC_COMMAND);              \
@@ -498,7 +552,7 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
                                     | RNGC_COMMAND_CLEAR_ERROR);              \
 }
 
-/** Return non-zero if Self Test Done */
+/*! Return non-zero if Self Test Done */
 #define RNG_SELF_TEST_DONE()                                                  \
          (RNG_READ_REGISTER(RNGC_STATUS) & RNGC_STATUS_ST_DONE)
 /* Put RNG for SEED Generation */
@@ -512,31 +566,32 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
 #define RNG_RESEED()                                                          \
     (RNG_READ_REGISTER(RNGC_STATUS) & RNGC_STATUS_RESEED)
 
-/** Return non-zero if the RNG is in High Assurance mode. */
-#define RNG_GET_HIGH_ASSURANCE()   1
+/*! Return non-zero if the RNG is in High Assurance mode. */
+#define RNG_GET_HIGH_ASSURANCE() (RNG_READ_REGISTER(RNGC_STATUS) &            \
+                                  RNGC_STATUS_SEC_STATE)
 
-/** Clear all status, error and otherwise. */
+/*! Clear all status, error and otherwise. */
 #define RNG_CLEAR_ALL_STATUS()                                                \
     RNG_WRITE_REGISTER(RNGC_COMMAND,                                          \
                        RNGC_COMMAND_CLEAR_INTERRUPT                           \
                        | RNGC_COMMAND_CLEAR_ERROR)
 
-/** Return non-zero if everything seems OK with the RNG. */
+/*! Return non-zero if everything seems OK with the RNG. */
 #define RNG_WORKING()                                                         \
     ((RNG_READ_REGISTER(RNGC_ERROR)                                           \
       & (RNGC_ERROR_STATUS_STAT_ERR | RNGC_ERROR_STATUS_RAND_ERR              \
        | RNGC_ERROR_STATUS_FIFO_ERR | RNGC_ERROR_STATUS_ST_ERR |              \
          RNGC_ERROR_STATUS_OSC_ERR  | RNGC_ERROR_STATUS_LFSR_ERR )) == 0)
-/** Return Non zero if SEEDING is DONE */
+/*! Return Non zero if SEEDING is DONE */
 #define RNG_SEED_DONE()                                                       \
      ((RNG_READ_REGISTER(RNGC_STATUS) & RNGC_STATUS_SEED_DONE) != 0)
 
-/** Put the RNG into sleep (low-power) mode. */
+/*! Put the RNG into sleep (low-power) mode. */
 #define RNG_SLEEP()
 
-/** Wake the RNG from sleep (low-power) mode. */
+/*! Wake the RNG from sleep (low-power) mode. */
 
-/** Mask interrupts so that the driver/OS will not see them. */
+/*! Mask interrupts so that the driver/OS will not see them. */
 #define RNG_MASK_ALL_INTERRUPTS()                                             \
 {                                                                             \
     register uint32_t control = RNG_READ_REGISTER(RNGC_CONTROL);              \
@@ -544,7 +599,7 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
                                     | RNGC_CONTROL_MASK_DONE                  \
                                     | RNGC_CONTROL_MASK_ERROR);               \
 }
-/** Configuring RNGC for self Test. */
+/*! Configuring RNGC for self Test. */
 
 #define RNG_AUTO_SEED()                                                       \
 {                                                                             \
@@ -553,7 +608,7 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
                                     | RNGC_CONTROL_AUTO_SEED);                \
 }
 
-/** Unmask interrupts so that the driver/OS will see them. */
+/*! Unmask interrupts so that the driver/OS will see them. */
 #define RNG_UNMASK_ALL_INTERRUPTS()                                           \
 {                                                                             \
     register uint32_t control = RNG_READ_REGISTER(RNGC_CONTROL);              \
@@ -561,10 +616,10 @@ inline static void RNG_ADD_WORK_ENTRY(rng_work_entry_t * work)
                 control & ~(RNGC_CONTROL_MASK_DONE|RNGC_CONTROL_MASK_ERROR)); \
 }
 
-/** Put RNG to sleep if appropriate. */
+/*! Put RNG to sleep if appropriate. */
 #define RNG_PUT_RNG_TO_SLEEP()
 
-/** Wake RNG from sleep if necessary. */
+/*! Wake RNG from sleep if necessary. */
 #define RNG_WAKE_FROM_SLEEP()
 
 #endif				/* RNG TYPE */
@@ -602,6 +657,7 @@ EXPORT_SYMBOL(rng_write_register);
 #endif				/* DEBUG_RNG_REGISTERS */
 
 
+
 MODULE_AUTHOR("Freescale Semiconductor");
 MODULE_DESCRIPTION("Device Driver for RNG");
 
diff --git a/drivers/mxc/security/rng/include/rng_rngc.h b/drivers/mxc/security/rng/include/rng_rngc.h
index 12ead80..336b5fd 100644
--- a/drivers/mxc/security/rng/include/rng_rngc.h
+++ b/drivers/mxc/security/rng/include/rng_rngc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -10,199 +10,226 @@
  * http://www.opensource.org/licenses/gpl-license.html
  * http://www.gnu.org/copyleft/gpl.html
  */
+/*!
+  * @file rng_rngc.h
+  *
+  * Definition of the registers for the RNGB and RNGC.	The names start with
+  * RNGC where they are in common or relate only to the RNGC;  the RNGB-only
+  * definitions begin with RNGB.
+  *
+  */
 
 #ifndef RNG_RNGC_H
 #define RNG_RNGC_H
 
 #define RNGC_VERSION_MAJOR3 3
 
-/** RNGC Version ID Register R/W */
+/*! @defgroup rngcregs RNGB/RNGC Registers 
+ * These are the definitions for the RNG registers and their offsets
+ * within the RNG.  They are used in the @c register_offset parameter of
+ * #rng_read_register() and #rng_write_register().
+ *
+ *  @ingroup RNG
+ */
+/*! @addtogroup rngcregs */
+/*! @{ */
+
+/*! RNGC Version ID Register R/W */
 #define RNGC_VERSION_ID 0x0000
-/** RNGC Command Register R/W */
+/*! RNGC Command Register R/W */
 #define RNGC_COMMAND 0x0004
-/** RNGC Control Register R/W */
+/*! RNGC Control Register R/W */
 #define RNGC_CONTROL 0x0008
-/** RNGC Status Register R */
+/*! RNGC Status Register R */
 #define RNGC_STATUS 0x000C
-/** RNGC Error Status Register R */
+/*! RNGC Error Status Register R */
 #define RNGC_ERROR 0x0010
-/** RNGC FIFO Register W */
+/*! RNGC FIFO Register W */
 #define RNGC_FIFO 0x0014
-/** RNGC Verification Control Register1 R/W */
+/*! Undefined */
+#define RNGC_UNDEF_18 0x0018
+/*! RNGB Entropy Register W */
+#define RNGB_ENTROPY 0x0018
+/*! Undefined */
+#define RNGC_UNDEF_1C 0x001C
+/*! RNGC Verification Control Register1 R/W */
 #define RNGC_VERIFICATION_CONTROL 0x0020
-/** RNGC Oscillator Counter Control Register1 R/W */
-#define RNGC_OSCILLATOR_CONTROL_COUNTER 0x0028
-/** RNGC Oscillator Counter Register1 R */
+/*! Undefined */
+#define RNGC_UNDEF_24 0x0024
+/*! RNGB XKEY Data Register R */
+#define RNGB_XKEY 0x0024
+/*! RNGC Oscillator Counter Control Register1 R/W */
+#define RNGC_OSC_COUNTER_CONTROL 0x0028
+/*! RNGC Oscillator Counter Register1 R */
 #define RNGC_OSC_COUNTER 0x002C
-/** RNGC Oscillator Counter Status Register1 R */
+/*! RNGC Oscillator Counter Status Register1 R */
 #define RNGC_OSC_COUNTER_STATUS 0x0030
-/** @} */
+/*! @} */
 
-/** @defgroup rngcveridreg RNGC Version ID Register Definitions
+/*! @defgroup rngcveridreg RNGB/RNGC Version ID Register Definitions
  *  @ingroup RNG
  */
-/** @addtogroup rngcveridreg */
-/** @{ */
-/** These bits are unimplemented or reserved */
+/*! @addtogroup rngcveridreg */
+/*! @{ */
+/*! These bits are unimplemented or reserved */
 #define RNGC_VERID_ZEROS_MASK          0x0f000000
-/** Mask for RNG TYPE */
+/*! Mask for RNG TYPE */
 #define RNGC_VERID_RNG_TYPE_MASK       0xf0000000
-/** Shift to make RNG TYPE be LSB */
+/*! Shift to make RNG TYPE be LSB */
 #define RNGC_VERID_RNG_TYPE_SHIFT      28
-/** Mask for RNG Chip Version */
+/*! Mask for RNG Chip Version */
 #define RNGC_VERID_CHIP_VERSION_MASK   0x00ff0000
-/** Shift to make RNG Chip version be LSB */
+/*! Shift to make RNG Chip version be LSB */
 #define RNGC_VERID_CHIP_VERSION_SHIFT  16
-/** Mask for RNG Major Version */
+/*! Mask for RNG Major Version */
 #define RNGC_VERID_VERSION_MAJOR_MASK  0x0000ff00
-/** Shift to make RNG Major version be LSB */
+/*! Shift to make RNG Major version be LSB */
 #define RNGC_VERID_VERSION_MAJOR_SHIFT 8
-/** Mask for RNG Minor Version */
+/*! Mask for RNG Minor Version */
 #define RNGC_VERID_VERSION_MINOR_MASK  0x000000ff
-/** Shift to make RNG Minor version be LSB */
+/*! Shift to make RNG Minor version be LSB */
 #define RNGC_VERID_VERSION_MINOR_SHIFT 0
-/** @} */
+/*! @} */
 
-/** @defgroup rngccommandreg RNGC Command Register Definitions
+/*! @defgroup rngccommandreg RNGB/RNGC Command Register Definitions
  *  @ingroup RNG
  */
-/** @addtogroup rngccommandreg */
-/** @{ */
-/** These bits are unimplemented or reserved. */
+/*! @addtogroup rngccommandreg */
+/*! @{ */
+/*! These bits are unimplemented or reserved. */
 #define RNGC_COMMAND_ZEROS_MASK      0xffffff8c
-/** Perform a software reset of the RNGC. */
+/*! Perform a software reset of the RNGC. */
 #define RNGC_COMMAND_SOFTWARE_RESET          0x00000040
-/** Clear error from Error Status register (and interrupt). */
+/*! Clear error from Error Status register (and interrupt). */
 #define RNGC_COMMAND_CLEAR_ERROR             0x00000020
-/** Clear interrupt & status. */
+/*! Clear interrupt & status. */
 #define RNGC_COMMAND_CLEAR_INTERRUPT         0x00000010
-/** Start RNGC seed generation. */
+/*! Start RNGC seed generation. */
 #define RNGC_COMMAND_SEED                    0x00000002
-/** Perform a self test of (and reset) the RNGC. */
+/*! Perform a self test of (and reset) the RNGC. */
 #define RNGC_COMMAND_SELF_TEST               0x00000001
-/** @} */
+/*! @} */
 
-/** @defgroup rngccontrolreg RNGC Control Register Definitions
+/*! @defgroup rngccontrolreg RNGB/RNGC Control Register Definitions
  *  @ingroup RNG
  */
-/** @addtogroup rngccontrolreg */
-/** @{ */
-/** These bits are unimplemented or reserved */
+/*! @addtogroup rngccontrolreg */
+/*! @{ */
+/*! These bits are unimplemented or reserved */
 #define RNGC_CONTROL_ZEROS_MASK       0xfffffc8c
-/** Allow access to verification registers. */
+/*! Allow access to verification registers. */
 #define RNGC_CONTROL_CTL_ACC          0x00000200
-/** Put RNGC into deterministic verifcation mode. */
+/*! Put RNGC into deterministic verifcation mode. */
 #define RNGC_CONTROL_VERIF_MODE       0x00000100
-/** Prevent RNGC from generating interrupts caused by errors. */
+/*! Prevent RNGC from generating interrupts caused by errors. */
 #define RNGC_CONTROL_MASK_ERROR       0x00000040
 
-/**
- * Prevent RNGC from generating interrupts after Seed Done or Self Test Mode
- * completion.
+/*!
+ * Prevent RNGB/RNGC from generating interrupts after Seed Done or Self Test
+ * Mode completion.
  */
 #define RNGC_CONTROL_MASK_DONE        0x00000020
-/** Allow RNGC to generate a new seed whenever it is needed. */
+/*! Allow RNGC to generate a new seed whenever it is needed. */
 #define RNGC_CONTROL_AUTO_SEED        0x00000010
-/** Set FIFO Underflow Response.*/
+/*! Set FIFO Underflow Response.*/
 #define RNGC_CONTROL_FIFO_UFLOW_MASK  0x00000003
-/** Shift value to make FIFO Underflow Response be LSB. */
+/*! Shift value to make FIFO Underflow Response be LSB. */
 #define RNGC_CONTROL_FIFO_UFLOW_SHIFT 0
 
-/** @} */
+/*! @} */
 
-/** @{  */
-/** FIFO Underflow should cause ... */
+/*! @{  */
+/*! FIFO Underflow should cause ... */
 #define RNGC_CONTROL_FIFO_UFLOW_ZEROS_ERROR 0
-/** FIFO Underflow should cause ... */
+/*! FIFO Underflow should cause ... */
 #define RNGC_CONTROL_FIFO_UFLOW_ZEROS_ERROR2 1
-/** FIFO Underflow should cause ... */
+/*! FIFO Underflow should cause ... */
 #define RNGC_CONTROL_FIFO_UFLOW_BUS_XFR     2
-/** FIFO Underflow should cause ... */
+/*! FIFO Underflow should cause ... */
 #define RNGC_CONTROL_FIFO_UFLOW_ZEROS_INTR  3
-/** @} */
+/*! @} */
 
-/** @defgroup rngcstatusreg RNGC Status Register Definitions
+/*! @defgroup rngcstatusreg RNGB/RNGC Status Register Definitions
  *  @ingroup RNG
  */
-/** @addtogroup rngcstatusreg */
-/** @{ */
-/** Unused or MBZ.  */
+/*! @addtogroup rngcstatusreg */
+/*! @{ */
+/*! Unused or MBZ.  */
 #define RNGC_STATUS_ZEROS_MASK              0x003e0080
-/**
+/*!
  * Statistical tests pass-fail.  Individual bits on indicate failure of a
  * particular test.
  */
 #define RNGC_STATUS_STAT_TEST_PF_MASK       0xff000000
-/** Mask to get Statistical PF to be LSB. */
+/*! Mask to get Statistical PF to be LSB. */
 #define RNGC_STATUS_STAT_TEST_PF_SHIFT      24
-/**
+/*!
  * Self tests pass-fail.  Individual bits on indicate failure of a
  * particular test.
  */
 #define RNGC_STATUS_ST_PF_MASK              0x00c00000
-/** Shift value to get Self Test PF field to be LSB. */
+/*! Shift value to get Self Test PF field to be LSB. */
 #define RNGC_STATUS_ST_PF_SHIFT             22
 /* TRNG Self test pass-fail */
 #define RNGC_STATUS_ST_PF_TRNG              0x00800000
 /* PRNG Self test pass-fail */
 #define RNGC_STATUS_ST_PF_PRNG              0x00400000
-/** Error detected in RNGC.  See Error Status register. */
+/*! Error detected in RNGC.  See Error Status register. */
 #define RNGC_STATUS_ERROR                   0x00010000
-/** Size of the internal FIFO in 32-bit words. */
+/*! Size of the internal FIFO in 32-bit words. */
 #define RNGC_STATUS_FIFO_SIZE_MASK          0x0000f000
-/** Shift value to get FIFO Size to be LSB. */
+/*! Shift value to get FIFO Size to be LSB. */
 #define RNGC_STATUS_FIFO_SIZE_SHIFT         12
-/** The level (available data) of the internal FIFO in 32-bit words. */
+/*! The level (available data) of the internal FIFO in 32-bit words. */
 #define RNGC_STATUS_FIFO_LEVEL_MASK         0x00000f00
-/** Shift value to get FIFO Level to be LSB. */
+/*! Shift value to get FIFO Level to be LSB. */
 #define RNGC_STATUS_FIFO_LEVEL_SHIFT        8
-/** A new seed is ready for use. */
+/*! A new seed is ready for use. */
 #define RNGC_STATUS_NEXT_SEED_DONE          0x00000040
-/** The first seed has been generated. */
+/*! The first seed has been generated. */
 #define RNGC_STATUS_SEED_DONE               0x00000020
-/** Self Test has been completed. */
+/*! Self Test has been completed. */
 #define RNGC_STATUS_ST_DONE                 0x00000010
-/** Reseed is necessary. */
+/*! Reseed is necessary. */
 #define RNGC_STATUS_RESEED                  0x00000008
-/** RNGC is sleeping. */
+/*! RNGC is sleeping. */
 #define RNGC_STATUS_SLEEP                   0x00000004
-/** RNGC is currently generating numbers, seeding, generating next seed, or
+/*! RNGC is currently generating numbers, seeding, generating next seed, or
     performing a self test. */
 #define RNGC_STATUS_BUSY                    0x00000002
-/** RNGC is in secure state. */
+/*! RNGC is in secure state. */
 #define RNGC_STATUS_SEC_STATE               0x00000001
 
-/** @} */
+/*! @} */
 
-/** @defgroup rngcerrstatusreg RNGC Error Status Register Definitions
+/*! @defgroup rngcerrstatusreg RNGB/RNGC Error Status Register Definitions
  *  @ingroup RNG
  */
-/** @addtogroup rngcerrstatusreg */
-/** @{ */
-/** Unused or MBZ. */
-#define RNGC_ERROR_STATUS_ZEROS_MASK        0xffffffc0
-/** Bad Key Error Status */
+/*! @addtogroup rngcerrstatusreg */
+/*! @{ */
+/*! Unused or MBZ. */
+#define RNGC_ERROR_STATUS_ZEROS_MASK        0xffffff80
+/*! Bad Key Error Status */
 #define RNGC_ERROR_STATUS_BAD_KEY          0x00000040
-/** Random Compare Error.  Previous number matched the current number. */
+/*! Random Compare Error.  Previous number matched the current number. */
 #define RNGC_ERROR_STATUS_RAND_ERR          0x00000020
-/** FIFO Underflow.  FIFO was read while empty. */
+/*! FIFO Underflow.  FIFO was read while empty. */
 #define RNGC_ERROR_STATUS_FIFO_ERR          0x00000010
-/** Statistic Error Statistic Test failed for the last seed. */
+/*! Statistic Error Statistic Test failed for the last seed. */
 #define RNGC_ERROR_STATUS_STAT_ERR          0x00000008
-/** Self-test error.  Some self test has failed. */
+/*! Self-test error.  Some self test has failed. */
 #define RNGC_ERROR_STATUS_ST_ERR            0x00000004
-/**
+/*!
  * Oscillator Error.  The oscillator may be broken.  Clear by hard or soft
  * reset.
  */
 #define RNGC_ERROR_STATUS_OSC_ERR           0x00000002
-/** LFSR Error.  Clear by hard or soft reset. */
+/*! LFSR Error.  Clear by hard or soft reset. */
 #define RNGC_ERROR_STATUS_LFSR_ERR          0x00000001
 
-/** @} */
+/*! @} */
 
-/** Total address space of the RNGC, in bytes */
+/*! Total address space of the RNGB/RNGC registers, in bytes */
 #define RNG_ADDRESS_RANGE 0x34
 
-
-#endif
+#endif /* RNG_RNGC_H */
diff --git a/drivers/mxc/security/rng/include/shw_driver.h b/drivers/mxc/security/rng/include/shw_driver.h
index 7c29909..5c2280c 100644
--- a/drivers/mxc/security/rng/include/shw_driver.h
+++ b/drivers/mxc/security/rng/include/shw_driver.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -28,7 +28,7 @@
 #include "../../sahara2/include/fsl_platform.h"
 
 /*! @file shw_driver.h
-
+ *
  * @brief Header file to use the SHW driver.
  *
  * The SHW driver is used in two modes: By a user, from the FSL SHW API in user
@@ -38,9 +38,8 @@
  *
  * Testing is performed by using the apitest and kernel api test routines
  * developed for the Sahara2 driver.
- *  @ingroup RNG
- */
-
+  */
+/*#define DIAG_SECURITY_FUNC*/
 /*! Perform a security function.  */
 #define SHW_IOCTL_REQUEST 21
 
@@ -50,41 +49,41 @@
 #define copy_bytes(out, in, len) memcpy(out, in, len)
 
 
-/**
+/*!
  * This is part of the IOCTL request type passed between kernel and user space.
  * It is added to #SHW_IOCTL_REQUEST to generate the actual value.
  */
 typedef enum shw_user_request_t {
-    SHW_USER_REQ_REGISTER_USER,    /**< Initialize user-kernel discussion. */
-    SHW_USER_REQ_DEREGISTER_USER,  /**< Terminate user-kernel discussion. */
-    SHW_USER_REQ_GET_RESULTS,      /**< Get information on outstanding
+    SHW_USER_REQ_REGISTER_USER,    /*!< Initialize user-kernel discussion. */
+    SHW_USER_REQ_DEREGISTER_USER,  /*!< Terminate user-kernel discussion. */
+    SHW_USER_REQ_GET_RESULTS,      /*!< Get information on outstanding
                                       results. */
-    SHW_USER_REQ_GET_CAPABILITIES, /**< Get information on hardware support. */
-    SHW_USER_REQ_GET_RANDOM,       /**< Get random data from RNG. */
-    SHW_USER_REQ_ADD_ENTROPY,      /**< Add entropy to hardware RNG. */
-    SHW_USER_REQ_DROP_PERMS,       /**< Diminish the permissions of a block of
+    SHW_USER_REQ_GET_CAPABILITIES, /*!< Get information on hardware support. */
+    SHW_USER_REQ_GET_RANDOM,       /*!< Get random data from RNG. */
+    SHW_USER_REQ_ADD_ENTROPY,      /*!< Add entropy to hardware RNG. */
+    SHW_USER_REQ_DROP_PERMS,       /*!< Diminish the permissions of a block of
                                       secure memory */
-    SHW_USER_REQ_SSTATUS,          /**< Check the status of a block of secure 
+    SHW_USER_REQ_SSTATUS,          /*!< Check the status of a block of secure 
                                       memory */
-    SHW_USER_REQ_SFREE,            /**< Free a block of secure memory */
-    SHW_USER_REQ_SCC_ENCRYPT,      /**< Encrypt a region of user-owned secure
+    SHW_USER_REQ_SFREE,            /*!< Free a block of secure memory */
+    SHW_USER_REQ_SCC_ENCRYPT,      /*!< Encrypt a region of user-owned secure
                                      memory */
-    SHW_USER_REQ_SCC_DECRYPT,     /**< Decrypt a region of user-owned secure
+    SHW_USER_REQ_SCC_DECRYPT,     /*!< Decrypt a region of user-owned secure
                                      memory */
 } shw_user_request_t;
 
 
-/**
+/*!
  * @typedef scc_partition_status_t
  */
 /** Partition status information. */
 typedef enum fsl_shw_partition_status_t {
-    FSL_PART_S_UNUSABLE,          /**< Partition not implemented */
-    FSL_PART_S_UNAVAILABLE,       /**< Partition owned by other host */
-    FSL_PART_S_AVAILABLE,         /**< Partition available */
-    FSL_PART_S_ALLOCATED,         /**< Partition owned by host but not engaged
+    FSL_PART_S_UNUSABLE,          /*!< Partition not implemented */
+    FSL_PART_S_UNAVAILABLE,       /*!< Partition owned by other host */
+    FSL_PART_S_AVAILABLE,         /*!< Partition available */
+    FSL_PART_S_ALLOCATED,         /*!< Partition owned by host but not engaged
                                    */
-    FSL_PART_S_ENGAGED,           /**< Partition owned by host and engaged */
+    FSL_PART_S_ENGAGED,           /*!< Partition owned by host and engaged */
 } fsl_shw_partition_status_t;
 
 
@@ -92,57 +91,57 @@ typedef enum fsl_shw_partition_status_t {
  * Structure passed during user ioctl() calls to manage secure partitions.
  */
 typedef struct scc_partition_info_t {
-    uint32_t user_base;            /**< Userspace pointer to base of partition */
-    uint32_t permissions;          /**< Permissions to give the partition (only
+    uint32_t user_base;            /*!< Userspace pointer to base of partition */
+    uint32_t permissions;          /*!< Permissions to give the partition (only
                                         used in call to _DROP_PERMS) */
-    fsl_shw_partition_status_t status;  /**< Status of the partition */
+    fsl_shw_partition_status_t status;  /*!< Status of the partition */
 } scc_partition_info_t;
 
 
 /******************************************************************************
  * Enumerations
  *****************************************************************************/
-/**
+/*!
  * Flags for the state of the User Context Object (#fsl_shw_uco_t).
  */
 typedef enum fsl_shw_user_ctx_flags_t
 {
-    /**
+  /*!
      * API will block the caller until operation completes.  The result will be
      * available in the return code.  If this is not set, user will have to get
      * results using #fsl_shw_get_results().
      */
     FSL_UCO_BLOCKING_MODE = 0x01,
-    /**
+  /*!
      * User wants callback (at the function specified with
      * #fsl_shw_uco_set_callback()) when the operation completes.  This flag is
      * valid only if #FSL_UCO_BLOCKING_MODE is not set.
      */
     FSL_UCO_CALLBACK_MODE = 0x02,
-    /** Do not free descriptor chain after driver (adaptor) finishes */
+    /*! Do not free descriptor chain after driver (adaptor) finishes */
     FSL_UCO_SAVE_DESC_CHAIN = 0x04,
-    /**
+  /*!
      * User has made at least one request with callbacks requested, so API is
      * ready to handle others.
      */
     FSL_UCO_CALLBACK_SETUP_COMPLETE = 0x08,
-    /**
+  /*!
      * (virtual) pointer to descriptor chain is completely linked with physical
      * (DMA) addresses, ready for the hardware.  This flag should not be used
      * by FSL SHW API programs.
      */
     FSL_UCO_CHAIN_PREPHYSICALIZED = 0x10,
-    /**
+  /*!
      * The user has changed the context but the changes have not been copied to
      * the kernel driver.
      */
     FSL_UCO_CONTEXT_CHANGED = 0x20,
-    /** Internal Use.  This context belongs to a user-mode API user. */
+    /*! Internal Use.  This context belongs to a user-mode API user. */
     FSL_UCO_USERMODE_USER = 0x40,
 } fsl_shw_user_ctx_flags_t;
 
 
-/**
+/*!
  * Return code for FSL_SHW library.
  *
  * These codes may be returned from a function call.  In non-blocking mode,
@@ -151,63 +150,63 @@ typedef enum fsl_shw_user_ctx_flags_t
 /* REQ-FSLSHW-ERR-001 */
 typedef enum fsl_shw_return_t
 {
-    /**
+  /*!
      * No error.  As a function return code in Non-blocking mode, this may
      * simply mean that the operation was accepted for eventual execution.
      */
     FSL_RETURN_OK_S = 0,
-    /** Failure for non-specific reason. */
+   	/*! Failure for non-specific reason. */
     FSL_RETURN_ERROR_S,
-   /**
+ /*!
     * Operation failed because some resource was not able to be allocated.
     */
     FSL_RETURN_NO_RESOURCE_S,
-    /** Crypto algorithm unrecognized or improper. */
+    /*! Crypto algorithm unrecognized or improper. */
     FSL_RETURN_BAD_ALGORITHM_S,
-    /** Crypto mode unrecognized or improper. */
+    /*! Crypto mode unrecognized or improper. */
     FSL_RETURN_BAD_MODE_S,
-    /** Flag setting unrecognized or inconsistent. */
+    /*! Flag setting unrecognized or inconsistent. */
     FSL_RETURN_BAD_FLAG_S,
-    /** Improper or unsupported key length for algorithm. */
+    /*! Improper or unsupported key length for algorithm. */
     FSL_RETURN_BAD_KEY_LENGTH_S,
-    /** Improper parity in a (DES, TDES) key. */
+    /*! Improper parity in a (DES, TDES) key. */
     FSL_RETURN_BAD_KEY_PARITY_S,
-    /**
+  /*!
      * Improper or unsupported data length for algorithm or internal buffer.
      */
     FSL_RETURN_BAD_DATA_LENGTH_S,
-    /** Authentication / Integrity Check code check failed. */
+    /*! Authentication / Integrity Check code check failed. */
     FSL_RETURN_AUTH_FAILED_S,
-    /** A memory error occurred. */
+    /*! A memory error occurred. */
     FSL_RETURN_MEMORY_ERROR_S,
-    /** An error internal to the hardware occurred. */
+    /*! An error internal to the hardware occurred. */
     FSL_RETURN_INTERNAL_ERROR_S,
-    /** ECC detected Point at Infinity */
+    /*! ECC detected Point at Infinity */
     FSL_RETURN_POINT_AT_INFINITY_S,
-    /** ECC detected No Point at Infinity */
+    /*! ECC detected No Point at Infinity */
     FSL_RETURN_POINT_NOT_AT_INFINITY_S,
-    /** GCD is One */
+    /*! GCD is One */
     FSL_RETURN_GCD_IS_ONE_S,
-    /** GCD is not One */
+    /*! GCD is not One */
     FSL_RETURN_GCD_IS_NOT_ONE_S,
-    /** Candidate is Prime */
+    /*! Candidate is Prime */
     FSL_RETURN_PRIME_S,
-    /** Candidate is not Prime */
+    /*! Candidate is not Prime */
     FSL_RETURN_NOT_PRIME_S,
-    /** N register loaded improperly with even value */
+    /*! N register loaded improperly with even value */
     FSL_RETURN_EVEN_MODULUS_ERROR_S,
-    /** Divisor is zero. */
+    /*! Divisor is zero. */
     FSL_RETURN_DIVIDE_BY_ZERO_ERROR_S,
-    /** Bad Exponent or Scalar value for Point Multiply */
+    /*! Bad Exponent or Scalar value for Point Multiply */
     FSL_RETURN_BAD_EXPONENT_ERROR_S,
-    /** RNG hardware problem. */
+    /*! RNG hardware problem. */
     FSL_RETURN_OSCILLATOR_ERROR_S,
-    /** RNG hardware problem. */
+    /*! RNG hardware problem. */
     FSL_RETURN_STATISTICS_ERROR_S,
 } fsl_shw_return_t;
 
 
-/**
+/*!
  * Algorithm Identifier.
  *
  * Selection of algorithm will determine how large the block size of the
@@ -216,28 +215,28 @@ typedef enum fsl_shw_return_t
  */
 typedef enum fsl_shw_key_alg_t
 {
-    /**
+  /*!
      * Key will be used to perform an HMAC.  Key size is 1 to 64 octets.  Block
      * size is 64 octets.
      */
     FSL_KEY_ALG_HMAC,
-    /**
+  /*!
      * Advanced Encryption Standard (Rijndael).  Block size is 16 octets.  Key
      * size is 16 octets.  (The single choice of key size is a Sahara platform
      * limitation.)
      */
     FSL_KEY_ALG_AES,
-    /**
+  /*!
      * Data Encryption Standard.  Block size is 8 octets.  Key size is 8
      * octets.
      */
     FSL_KEY_ALG_DES,
-    /**
+  /*!
      * 2- or 3-key Triple DES.  Block size is 8 octets.  Key size is 16 octets
      * for 2-key Triple DES, and 24 octets for 3-key.
      */
     FSL_KEY_ALG_TDES,
-    /**
+  /*!
      * ARC4.  No block size.  Context size is 259 octets.  Allowed key size is
      * 1-16 octets.  (The choices for key size are a Sahara platform
      * limitation.)
@@ -246,7 +245,7 @@ typedef enum fsl_shw_key_alg_t
 } fsl_shw_key_alg_t;
 
 
-/**
+/*!
  * Mode selector for Symmetric Ciphers.
  *
  * The selection of mode determines how a cryptographic algorithm will be
@@ -265,28 +264,28 @@ typedef enum fsl_shw_key_alg_t
  */
 typedef enum fsl_shw_sym_mode_t
 {
-    /**
+  /*!
      * Stream.  There is no associated block size.  Any request to process data
      * may be of any length.  This mode is only for ARC4 operations, and is
      * also the only mode used for ARC4.
      */
     FSL_SYM_MODE_STREAM,
 
-    /**
+  /*!
      * Electronic Codebook.  Each block of data is encrypted/decrypted.  The
      * length of the data stream must be a multiple of the block size.  This
      * mode may be used for DES, 3DES, and AES.  The block size is determined
      * by the algorithm.
      */
     FSL_SYM_MODE_ECB,
-    /**
+  /*!
      * Cipher-Block Chaining.  Each block of data is encrypted/decrypted and
      * then "chained" with the previous block by an XOR function.  Requires
      * context to start the XOR (previous block).  This mode may be used for
      * DES, 3DES, and AES.  The block size is determined by the algorithm.
      */
     FSL_SYM_MODE_CBC,
-    /**
+  /*!
      * Counter.  The counter is encrypted, then XORed with a block of data.
      * The counter is then incremented (using modulus arithmetic) for the next
      * block. The final operation may be non-multiple of block size.  This mode
@@ -296,7 +295,7 @@ typedef enum fsl_shw_sym_mode_t
 } fsl_shw_sym_mode_t;
 
 
-/**
+/*!
  * Algorithm selector for Cryptographic Hash functions.
  *
  * Selection of algorithm determines how large the context and digest will be.
@@ -305,27 +304,27 @@ typedef enum fsl_shw_sym_mode_t
  */
 typedef enum fsl_shw_hash_alg_t
 {
-    FSL_HASH_ALG_MD5,           /**< MD5 algorithm.  Digest is 16 octets. */
-    FSL_HASH_ALG_SHA1,          /**< SHA-1 (aka SHA or SHA-160) algorithm.
+    FSL_HASH_ALG_MD5,           /*!< MD5 algorithm.  Digest is 16 octets. */
+    FSL_HASH_ALG_SHA1,          /*!< SHA-1 (aka SHA or SHA-160) algorithm.
                                    Digest is 20 octets. */
-    FSL_HASH_ALG_SHA224,        /**< SHA-224 algorithm.  Digest is 28 octets,
+    FSL_HASH_ALG_SHA224,        /*!< SHA-224 algorithm.  Digest is 28 octets,
                                    though context is 32 octets. */
-    FSL_HASH_ALG_SHA256         /**< SHA-256 algorithm.  Digest is 32
+    FSL_HASH_ALG_SHA256         /*!< SHA-256 algorithm.  Digest is 32
                                    octets. */
 } fsl_shw_hash_alg_t;
 
 
-/**
+/*!
  * The type of Authentication-Cipher function which will be performed.
  */
 typedef enum fsl_shw_acc_mode_t
 {
-    /**
+  /*!
      * CBC-MAC for Counter.  Requires context and modulus.  Final operation may
      * be non-multiple of block size.  This mode may be used for AES.
      */
     FSL_ACC_MODE_CCM,
-    /**
+  /*!
      * SSL mode.  Not supported.  Combines HMAC and encrypt (or decrypt).
      * Needs one key object for encryption, another for the HMAC.  The usual
      * hashing and symmetric encryption algorithms are supported.
@@ -335,29 +334,29 @@ typedef enum fsl_shw_acc_mode_t
 
 
 /* REQ-FSLSHW-PINTFC-COA-HCO-001 */
-/**
+/*!
  * Flags which control a Hash operation.
  */
 typedef enum fsl_shw_hash_ctx_flags_t
 {
-    FSL_HASH_FLAGS_INIT = 0x01,     /**< Context is empty.  Hash is started
+    FSL_HASH_FLAGS_INIT = 0x01,     /*!< Context is empty.  Hash is started
                                        from scratch, with a message-processed
                                        count of zero. */
-    FSL_HASH_FLAGS_SAVE = 0x02,     /**< Retrieve context from hardware after
+    FSL_HASH_FLAGS_SAVE = 0x02,     /*!< Retrieve context from hardware after
                                        hashing.  If used with the
                                        #FSL_HASH_FLAGS_FINALIZE flag, the final
                                        digest value will be saved in the
                                        object. */
-    FSL_HASH_FLAGS_LOAD = 0x04,     /**< Place context into hardware before
+    FSL_HASH_FLAGS_LOAD = 0x04,     /*!< Place context into hardware before
                                        hashing. */
-    FSL_HASH_FLAGS_FINALIZE = 0x08, /**< PAD message and perform final digest
+    FSL_HASH_FLAGS_FINALIZE = 0x08, /*!< PAD message and perform final digest
                                        operation.  If user message is
                                        pre-padded, this flag should not be
                                        used. */
 } fsl_shw_hash_ctx_flags_t;
 
 
-/**
+/*!
  * Flags which control an HMAC operation.
  *
  * These may be combined by ORing them together.  See #fsl_shw_hmco_set_flags()
@@ -427,15 +426,19 @@ typedef enum fsl_shw_sym_ctx_flags_t
  */
 typedef enum fsl_shw_key_flags_t
 {
-    FSL_SKO_KEY_IGNORE_PARITY = 1, /**< If algorithm is DES or 3DES, do not
+    FSL_SKO_KEY_IGNORE_PARITY = 1, /*!< If algorithm is DES or 3DES, do not
                                       validate the key parity bits. */
-    FSL_SKO_KEY_PRESENT = 2,       /**< Clear key is present in the object. */
-    FSL_SKO_KEY_ESTABLISHED = 4,   /**< Key has been established for use.  This
+    FSL_SKO_KEY_PRESENT = 2,       /*!< Clear key is present in the object. */
+    FSL_SKO_KEY_ESTABLISHED = 4,   /*!< Key has been established for use.  This
                                        feature is not available for all
                                        platforms, nor for all algorithms and
                                        modes.*/
-    FSL_SKO_USE_SECRET_KEY = 8,    /**< Use device-unique key.  Not always
+    FSL_SKO_USE_SECRET_KEY = 8,    /*!< Use device-unique key.  Not always
                                        available. */
+    FSL_SKO_KEY_SW_KEY = 16,	/*!< Clear key can be provided to the user */
+	FSL_SKO_KEY_SELECT_PF_KEY = 32,	/*!< Internal flag to show that this key
+					   references one of the hardware keys, and
+					   its value is in pf_key. */
 } fsl_shw_key_flags_t;
 
 
@@ -545,26 +548,59 @@ typedef enum fsl_shw_permission_t
     FSL_PERM_OT_X =             0x00000001,
 } fsl_shw_permission_t;
 
-
+/*!
+ * Select the cypher mode to use for partition cover/uncover operations.
+ *
+ * They currently map directly to the values used in the SCC2 driver, but this
+ * is not guarinteed behavior.
+ */
 typedef enum fsl_shw_cypher_mode_t
 {
-    FSL_SHW_CYPHER_MODE_ECB = 1,       /**< ECB mode */
-    FSL_SHW_CYPHER_MODE_CBC = 2,       /**< CBC mode */
+    FSL_SHW_CYPHER_MODE_ECB = 1,       /*!< ECB mode */
+    FSL_SHW_CYPHER_MODE_CBC = 2,       /*!< CBC mode */
 } fsl_shw_cypher_mode_t;
 
+/*!
+ * Which platform key should be presented for cryptographic use.
+ */
+typedef enum fsl_shw_pf_key_t {
+	FSL_SHW_PF_KEY_IIM,	/*!< Present fused IIM key */
+	FSL_SHW_PF_KEY_PRG,	/*!< Present Program key */
+	FSL_SHW_PF_KEY_IIM_PRG,	/*!< Present IIM ^ Program key */
+	FSL_SHW_PF_KEY_IIM_RND,	/*!< Present Random key */
+	FSL_SHW_PF_KEY_RND,	/*!< Present IIM ^ Random key */
+} fsl_shw_pf_key_t;
+
+/*!
+ * The various security tamper events
+ */
+typedef enum fsl_shw_tamper_t {
+	FSL_SHW_TAMPER_NONE,	/*!< No error detected */
+	FSL_SHW_TAMPER_WTD,	/*!< wire-mesh tampering det */
+	FSL_SHW_TAMPER_ETBD,	/*!< ext tampering det: input B */
+	FSL_SHW_TAMPER_ETAD,	/*!< ext tampering det: input A */
+	FSL_SHW_TAMPER_EBD,	/*!< external boot detected */
+	FSL_SHW_TAMPER_SAD,	/*!< security alarm detected */
+	FSL_SHW_TAMPER_TTD,	/*!< temperature tampering det */
+	FSL_SHW_TAMPER_CTD,	/*!< clock tampering det */
+	FSL_SHW_TAMPER_VTD,	/*!< voltage tampering det */
+	FSL_SHW_TAMPER_MCO,	/*!< monotonic counter overflow */
+	FSL_SHW_TAMPER_TCO,	/*!< time counter overflow */
+} fsl_shw_tamper_t;
 
 /*
  * Structure passed during user ioctl() calls to manage data stored in secure
  * partitions.
  */
+
 typedef struct scc_region_t {
-    uint32_t            partition_base;
-    uint32_t            offset;
-    uint32_t            length;
-    uint8_t*            black_data;
-    uint64_t            owner_id;
-    fsl_shw_cypher_mode_t   cypher_mode;
-    uint32_t            IV[4];
+	uint32_t partition_base;	/*!< Base address of partition */
+	uint32_t offset;	/*!< Byte offset into partition */
+	uint32_t length;	/*!< Number of bytes in request */
+	uint8_t *black_data;	/*!< Address of cipher text */
+	uint64_t owner_id;	/*!< user's secret */
+	fsl_shw_cypher_mode_t cypher_mode;	/*!< ECB or CBC */
+	uint32_t IV[4];		/*!< IV for CBC mode */
 } scc_region_t;
 
 /******************************************************************************
@@ -641,6 +677,7 @@ typedef struct fsl_shw_uco_t
     struct fsl_shw_uco_t* next; /**< To allow user-mode chaining of contexts,
                                  for signalling and in kernel, to link user
                                  contexts.  */
+    fsl_shw_pf_key_t wrap_key;	/*!< What key for ciphering T */
 } fsl_shw_uco_t;
 
 
@@ -699,6 +736,11 @@ typedef struct fsl_shw_sko_t
     uint16_t          key_length;  /**< Length of stored key, in bytes. */
     uint8_t           key[64];  /**< Bytes of stored key. */
     struct fsl_shw_kso_t*   keystore;   /**< If present, key is in keystore */
+	fsl_shw_pf_key_t pf_key;	/*!< What key to select for use when this key
+					   is doing ciphering.  If FSL_SHW_PF_KEY_PRG
+					   or FSL_SHW_PF_KEY_PRG_IIM is the value, then
+					   a 'present' or 'established' key will be
+					   programed into the PK. */
 } fsl_shw_sko_t;
 
 
@@ -738,7 +780,7 @@ typedef struct fsl_shw_pco_t
             int partition_size_bytes;   /**< Number of bytes in each partition */
             int partition_count;        /**< Number of partitions on this platform */
         } scc2_info;
-    };
+    } u;
 } fsl_shw_pco_t;
 
 
@@ -791,8 +833,8 @@ typedef struct fsl_shw_scco_t
     /* Could put modulus plus 16-octet context in union with arc4
        sbox+ptrs... */
     fsl_shw_ctr_mod_t       modulus_exp; /**< Exponent value for CTR modulus */
-    uint8_t                 context[259]; /**< Stored context.  Large enough
-                                             for ARC4.  */
+    uint8_t                 context[8]; /**< Stored context.  Large enough
+                                             for 3DES.  */
 } fsl_shw_scco_t;
 
 
@@ -976,9 +1018,13 @@ do {                                                                          \
  *
  * @return 0 if combination is not supported, non-zero if supported.
  */
+#if defined(FSL_HAVE_DRYICE) && defined(__KERNEL__)
+#define fsl_shw_pco_check_sym_supported(pcobject, pcalg, pcmode)              \
+    ((pcobject)->sym_support[pcalg][pcmode])
+#else
 #define fsl_shw_pco_check_sym_supported(pcobject, pcalg, pcmode)              \
     0
-
+#endif
 
 /**
  * Determine whether a given Encryption-Authentication mode is supported.
@@ -999,11 +1045,46 @@ do {                                                                          \
  *
  * @return 0 if wrapping is not supported, non-zero if supported.
  */
+#if defined(FSL_HAVE_DRYICE) && defined(__KERNEL__)
+#define fsl_shw_pco_check_black_key_supported(pcobject)                       \
+    1
+#else
 #define fsl_shw_pco_check_black_key_supported(pcobject)                       \
     0
 
+#endif
 
-/**
+/*!
+ * Determine whether Programmed Key features are available
+ *
+ * @param pcobject          The Platform Capabilities Object to query.
+ *
+ * @return  1 if Programmed Key features are available, otherwise zero.
+ */
+#if defined(FSL_HAVE_DRYICE) && defined(__KERNEL__)
+#define fsl_shw_pco_check_pk_supported(pcobject)        \
+    1
+#else
+#define fsl_shw_pco_check_pk_supported(pcobject)        \
+    0
+#endif
+
+/*!
+ * Determine whether Software Key features are available
+ *
+ * @param pc_info          The Platform Capabilities Object to query.
+ *
+ * @return  1 if Software key features are available, otherwise zero.
+ */
+#if defined(FSL_HAVE_DRYICE) && defined(__KERNEL__)
+#define fsl_shw_pco_check_sw_keys_supported(pcobject)        \
+    1
+#else
+#define fsl_shw_pco_check_sw_keys_supported(pcobject)        \
+    0
+#endif
+
+/*!
  * Get FSL SHW SCC driver version
  *
  * @param      pcobject  The Platform Capababilities Object to query.
@@ -1061,8 +1142,8 @@ do {                                                                          \
 #define fsl_shw_pco_get_smn_size(pcobject, black_size, red_size)              \
 {                                                                             \
     if ((pcobject)->scm_version == 1) {                                       \
-        *(black_size) = (pcobject)->scc_info.black_ram_size_blocks;           \
-        *(red_size)   = (pcobject)->scc_info.red_ram_size_blocks;             \
+        *(black_size) = (pcobject)->u.scc_info.black_ram_size_blocks;           \
+        *(red_size)   = (pcobject)->u.scc_info.red_ram_size_blocks;             \
     } else {                                                                  \
         *(black_size) = 0;                                                    \
         *(red_size)   = 0;                                                    \
@@ -1090,7 +1171,7 @@ do {                                                                          \
  */
 #define fsl_shw_pco_get_spo_size_bytes(pcobject)                            \
     (((pcobject)->scm_version == 2) ?                                       \
-        ((pcobject)->scc2_info.partition_size_bytes) : 0 )                  \
+        ((pcobject)->u.scc2_info.partition_size_bytes) : 0 )                  \
 
 
 /**
@@ -1104,10 +1185,10 @@ do {                                                                          \
  */
 #define fsl_shw_pco_get_spo_count(pcobject)                                 \
     (((pcobject)->scm_version == 2) ?                                       \
-        ((pcobject)->scc2_info.partition_count) : 0 )                       \
+        ((pcobject)->u.scc2_info.partition_count) : 0 )                       \
 
 
-/**
+/*!
  * Initialize a Secret Key Object.
  *
  * This function must be called before performing any other operation with
@@ -1117,15 +1198,49 @@ do {                                                                          \
  * @param skalgorithm  DES, AES, etc.
  *
  */
-#define fsl_shw_sko_init(skobject,skalgorithm)                               \
-{                                                                            \
-       (skobject)->algorithm = skalgorithm;                                  \
-       (skobject)->flags = 0;                                                \
-       (skobject)->keystore = NULL;                                          \
+#define fsl_shw_sko_init(skobject,skalgorithm)                          \
+{                                                                       \
+    fsl_shw_sko_t* skop = skobject;                                     \
+                                                                        \
+    skop->algorithm = skalgorithm;                                      \
+    skop->flags = 0;                                                    \
+    skop->keystore = NULL;                                              \
+    skop->pf_key = FSL_SHW_PF_KEY_PRG;                                  \
 }
 
+/*!
+ * Initialize a Secret Key Object to use a Platform Key register.
+ *
+ * This function must be called before performing any other operation with
+ * the Object.
+ *
+ * @param skobject     The Secret Key Object to be initialized.
+ * @param skalgorithm  DES, AES, etc.
+ * @param skhwkey      one of the fsl_shw_pf_key_t values.
+ *
+ */
+#define fsl_shw_sko_init_pf_key(skobject,skalgorithm,skhwkey)           \
+{                                                                       \
+    fsl_shw_sko_t* skop = skobject;                                     \
+    fsl_shw_key_alg_t alg = skalgorithm;                                \
+    fsl_shw_pf_key_t key = skhwkey;                                     \
+                                                                        \
+    skop->algorithm = alg;                                              \
+    if (alg == FSL_KEY_ALG_TDES) {                                      \
+        skop->key_length = 21;                                          \
+    }                                                                   \
+    skop->keystore = NULL;                                              \
+    skop->flags = FSL_SKO_KEY_SELECT_PF_KEY;                            \
+    skop->pf_key = key;                                                 \
+    if ((key == FSL_SHW_PF_KEY_IIM) || (key == FSL_SHW_PF_KEY_PRG)      \
+        || (key == FSL_SHW_PF_KEY_IIM_PRG)                              \
+        || (key == FSL_SHW_PF_KEY_IIM_RND)                              \
+        || (key == FSL_SHW_PF_KEY_RND)) {                               \
+        skop->flags |= FSL_SKO_KEY_ESTABLISHED;                         \
+    }                                                                   \
+}
 
-/**
+/*!
  * Store a cleartext key in the key object.
  *
  * This has the side effect of setting the #FSL_SKO_KEY_PRESENT flag and
@@ -1245,7 +1360,7 @@ do {                                                                          \
 }
 
 
-/**
+/*!
  * Determine the size of a wrapped key based upon the cleartext key's length.
  *
  * This function can be used to calculate the number of octets that
@@ -1258,17 +1373,22 @@ do {                                                                          \
  * @param      wkeylen          Location to store the length of a wrapped
  *                              version of the key in @a key_info.
  */
-#define fsl_shw_sko_calculate_wrapped_size(wkeyinfo, wkeylen)                 \
-{                                                                             \
-     if ((wkeyinfo)->key_length > 32) {                                       \
-         *(wkeylen) = 0;                                                      \
-     } else {                                                                 \
-         *(wkeylen) = 66;                                                     \
-     }                                                                        \
+#define fsl_shw_sko_calculate_wrapped_size(wkeyinfo, wkeylen)           \
+{                                                                       \
+    register fsl_shw_sko_t* kp = wkeyinfo;                              \
+    register uint32_t kl = kp->key_length;                              \
+    int key_blocks;                                                     \
+    int base_size = 35; /* ICV + T' + ALG + LEN + FLAGS */              \
+                                                                        \
+    if (kp->flags & FSL_SKO_KEY_SELECT_PF_KEY) {                        \
+        kl = 21;  /* 168-bit 3DES key */                                \
+    }                                                                   \
+    key_blocks = (kl + 7) / 8;                                          \
+    /* Round length up to 3DES block size for CBC mode */               \
+    *(wkeylen) = base_size + 8 * key_blocks;                            \
 }
 
-
-/**
+/*!
  * Set some flags in the key object.
  *
  * Turns on the flags specified in @a flags.  Other flags are untouched.
@@ -1324,6 +1444,7 @@ do {                                                                          \
     (uco)->openfd = -1;                                                       \
     (uco)->callback = NULL;                                                   \
     (uco)->partition = NULL;                                                  \
+    (uco)->wrap_key = FSL_SHW_PF_KEY_IIM;                                     \
 } while (0)
 
 #else /* __KERNEL__ */
@@ -1336,6 +1457,7 @@ do {                                                                          \
     (uco)->flags = FSL_UCO_BLOCKING_MODE | FSL_UCO_CONTEXT_CHANGED;           \
     (uco)->openfd = -1;                                                       \
     (uco)->callback = NULL;                                                   \
+    (uco)->wrap_key = FSL_SHW_PF_KEY_IIM;                                     \
 } while (0)
 
 #endif /* __KERNEL__ */
@@ -2036,6 +2158,21 @@ extern fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t* user_ctx,
                                 fsl_shw_sko_t* key_info,
                                 uint8_t* covered_key);
 
+/*!
+ * Read the key value from a key object.
+ *
+ * Only a key marked as a software key (#FSL_SKO_KEY_SW_KEY) can be read with
+ * this call.  It has no effect on the status of the key store.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      key_info         The referenced key.
+ * @param[out] key              The location to store the key value.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_read_key(fsl_shw_uco_t * user_ctx,
+					 fsl_shw_sko_t * key_info,
+					 uint8_t * key);
 
 /**
  * De-establish a key so that it can no longer be accessed.
@@ -2533,6 +2670,59 @@ extern fsl_shw_return_t fsl_shw_auth_decrypt(
                                 const uint8_t* auth_value,
                                 uint8_t* payload);
 
+/*!
+ * Cause the hardware to create a new random key for secure memory use.
+ *
+ * Have the hardware use the secure hardware random number generator to load a
+ * new secret key into the hardware random key register.  It will not be made
+ * active without a call to #fsl_shw_select_pf_key().
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+#ifdef __KERNEL__
+
+extern fsl_shw_return_t fsl_shw_gen_random_pf_key(fsl_shw_uco_t * user_ctx);
+
+#else
+
+#define fsl_shw_gen_random_pf_key(user_ctx) FSL_RETURN_NO_RESOURCE_S
+
+#endif				/* __KERNEL__ */
+
+/*!
+ * Retrieve the detected tamper event.
+ *
+ * Note that if more than one event was detected, this routine will only ever
+ * return one of them.
+ *
+ * @param[in]  user_ctx         A user context from #fsl_shw_register_user().
+ * @param[out] tamperp          Location to store the tamper information.
+ * @param[out] timestampp       Locate to store timestamp from hardwhare when
+ *                              an event was detected.
+ *
+ *
+ * @return    A return code of type #fsl_shw_return_t (for instance, if the platform
+ *            is not in a fail state.
+ */
+#ifdef __KERNEL__
+
+extern fsl_shw_return_t fsl_shw_read_tamper_event(fsl_shw_uco_t * user_ctx,
+						  fsl_shw_tamper_t * tamperp,
+						  uint64_t * timestampp);
+#else
+
+#define fsl_shw_read_tamper_event(user_ctx,tamperp,timestampp)         \
+    FSL_RETURN_NO_RESOURCE_S
+
+#endif				/* __KERNEL__ */
+
+/*****************************************************************************
+ *
+ * Functions internal to SHW driver.
+ *
+*****************************************************************************/
 
 fsl_shw_return_t 
 do_scc_encrypt_region(fsl_shw_uco_t* user_ctx,
@@ -2546,6 +2736,7 @@ do_scc_decrypt_region(fsl_shw_uco_t* user_ctx,
                       uint32_t byte_count, const uint8_t* black_data,
                       uint32_t* IV, fsl_shw_cypher_mode_t cypher_mode);
 
+
 /*****************************************************************************
  *
  * Functions available to other SHW-family drivers.
@@ -2753,4 +2944,28 @@ inline static fsl_shw_return_t send_req(shw_user_request_t type,
 
 #endif				/* no __KERNEL__ */
 
+#if defined(FSL_HAVE_DRYICE)
+/* Some kernel functions */
+void fsl_shw_permute1_bytes(const uint8_t * key, uint8_t * permuted_key,
+			    int key_count);
+void fsl_shw_permute1_bytes_to_words(const uint8_t * key,
+				     uint32_t * permuted_key, int key_count);
+
+#define PFKEY_TO_STR(key_in)                                    \
+({                                                              \
+    di_key_t key = key_in;                                      \
+                                                                \
+    ((key == DI_KEY_FK) ? "IIM" :                               \
+     ((key == DI_KEY_PK) ? "PRG" :                              \
+      ((key == DI_KEY_RK) ? "RND" :                             \
+       ((key == DI_KEY_FPK) ? "IIM_PRG" :                       \
+        ((key == DI_KEY_FRK) ? "IIM_RND" : "unk")))));          \
+})
+
+#ifdef DIAG_SECURITY_FUNC
+extern const char *di_error_string(int code);
+#endif
+
+#endif				/* HAVE DRYICE */
+
 #endif				/* SHW_DRIVER_H */
diff --git a/drivers/mxc/security/rng/include/shw_hash.h b/drivers/mxc/security/rng/include/shw_hash.h
new file mode 100644
index 0000000..5cd2290
--- /dev/null
+++ b/drivers/mxc/security/rng/include/shw_hash.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @file shw_hash.h
+ *
+ * This file contains definitions for use of the (internal) SHW hash
+ * software computation.  It defines the usual three steps:
+ *
+ * - #shw_hash_init()
+ * - #shw_hash_update()
+ * - #shw_hash_final()
+ *
+ * The only other item of note to callers is #SHW_HASH_LEN, which is the number
+ * of bytes calculated for the hash.
+ */
+
+#ifndef SHW_HASH_H
+#define SHW_HASH_H
+
+/*! Define which gives the number of bytes available in an hash result */
+#define SHW_HASH_LEN 32
+
+/* Define which matches block length in bytes of the underlying hash */
+#define SHW_HASH_BLOCK_LEN 64
+
+/* "Internal" define which matches SHA-256 state size (32-bit words) */
+#define SHW_HASH_STATE_WORDS 8
+
+/* "Internal" define which matches word length in blocks of the underlying
+   hash. */
+#define SHW_HASH_BLOCK_WORD_SIZE 16
+
+#define SHW_HASH_STATE_SIZE 32
+
+/*!
+ * State for a SHA-1/SHA-2 Hash
+ *
+ * (Note to maintainers: state needs to be updated to uint64_t to handle
+ * SHA-384/SHA-512)... And bit_count to uint128_t (heh).
+ */
+typedef struct shw_hash_state {
+	unsigned int partial_count_bytes;	/*!< Number of bytes of message sitting
+						 * in @c partial_block */
+	uint8_t partial_block[SHW_HASH_BLOCK_LEN];	/*!< Data waiting to be processed as a block  */
+	uint32_t state[SHW_HASH_STATE_WORDS];	/*!< Current hash state variables */
+	uint64_t bit_count;	/*!< Number of bits sent through the update function */
+} shw_hash_state_t;
+
+/*!
+ * Initialize the hash state structure
+ *
+ * @param state     Address of hash state structure.
+ * @param algorithm Which hash algorithm to use (must be FSL_HASH_ALG_SHA256)
+ *
+ * @return  FSL_RETURN_OK_S if all went well, otherwise an error code.
+ */
+fsl_shw_return_t shw_hash_init(shw_hash_state_t * state,
+			       fsl_shw_hash_alg_t algorithm);
+
+/*!
+ * Put data into the hash calculation
+ *
+ * @param state     Address of hash state structure.
+ * @param msg       Address of the message data for the hash.
+ * @param msg_len   Number of bytes of @c msg.
+ *
+ * @return  FSL_RETURN_OK_S if all went well, otherwise an error code.
+ */
+fsl_shw_return_t shw_hash_update(shw_hash_state_t * state,
+				 const uint8_t * msg, unsigned int msg_len);
+
+/*!
+ * Calculate the final hash value
+ *
+ * @param state     Address of hash state structure.
+ * @param hash      Address of location to store the hash.
+ * @param hash_len  Number of bytes of @c hash to be stored.
+ *
+ * @return FSL_RETURN_OK_S if all went well, FSL_RETURN_BAD_DATA_LENGTH_S if
+ * hash_len is too long, otherwise an error code.
+ */
+fsl_shw_return_t shw_hash_final(shw_hash_state_t * state,
+				uint8_t * hash, unsigned int hash_len);
+
+#endif				/* SHW_HASH_H */
diff --git a/drivers/mxc/security/rng/include/shw_hmac.h b/drivers/mxc/security/rng/include/shw_hmac.h
new file mode 100644
index 0000000..de44941
--- /dev/null
+++ b/drivers/mxc/security/rng/include/shw_hmac.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @file shw_hmac.h
+ *
+ * This file contains definitions for use of the (internal) SHW HMAC
+ * software computation.  It defines the usual three steps:
+ *
+ * - #shw_hmac_init()
+ * - #shw_hmac_update()
+ * - #shw_hmac_final()
+ *
+ * The only other item of note to callers is #SHW_HASH_LEN, which is the number
+ * of bytes calculated for the HMAC.
+ */
+
+#ifndef SHW_HMAC_H
+#define SHW_HMAC_H
+
+#include "shw_hash.h"
+
+/*!
+ * State for an HMAC
+ *
+ * Note to callers: This structure contains key material and should be kept in
+ * a secure location, such as internal RAM.
+ */
+typedef struct shw_hmac_state {
+	shw_hash_state_t inner_hash;	/*!< Current state of inner hash */
+	shw_hash_state_t outer_hash;	/*!< Current state of outer hash */
+} shw_hmac_state_t;
+
+/*!
+ * Initialize the HMAC state structure with the HMAC key
+ *
+ * @param state     Address of HMAC state structure.
+ * @param key       Address of the key to be used for the HMAC.
+ * @param key_len   Number of bytes of @c key.  This must not be greater than
+ *                  the block size of the underlying hash (#SHW_HASH_BLOCK_LEN).
+ *
+ * @return  FSL_RETURN_OK_S if all went well, otherwise an error code.
+ */
+fsl_shw_return_t shw_hmac_init(shw_hmac_state_t * state,
+			       const uint8_t * key, unsigned int key_len);
+
+/*!
+ * Put data into the HMAC calculation
+ *
+ * @param state     Address of HMAC state structure.
+ * @param msg       Address of the message data for the HMAC.
+ * @param msg_len   Number of bytes of @c msg.
+ *
+ * @return  FSL_RETURN_OK_S if all went well, otherwise an error code.
+ */
+fsl_shw_return_t shw_hmac_update(shw_hmac_state_t * state,
+				 const uint8_t * msg, unsigned int msg_len);
+
+/*!
+ * Calculate the final HMAC
+ *
+ * @param state     Address of HMAC state structure.
+ * @param hmac      Address of location to store the HMAC.
+ * @param hmac_len  Number of bytes of @c mac to be stored.  Probably best if
+ *                  this value is no greater than #SHW_HASH_LEN.
+ *
+ * @return  FSL_RETURN_OK_S if all went well, otherwise an error code.
+ */
+fsl_shw_return_t shw_hmac_final(shw_hmac_state_t * state,
+				uint8_t * hmac, unsigned int hmac_len);
+
+#endif				/* SHW_HMAC_H */
diff --git a/drivers/mxc/security/rng/include/shw_internals.h b/drivers/mxc/security/rng/include/shw_internals.h
index c815b3d..7e45af8 100644
--- a/drivers/mxc/security/rng/include/shw_internals.h
+++ b/drivers/mxc/security/rng/include/shw_internals.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -24,14 +24,11 @@
  *
  *  @li Some sort of platform flag.
  *
- *  @ingroup RNG
  */
 
 #include "portable_os.h"
 #include "shw_driver.h"
 
-//#include <asm/arch/mxc_scc_driver.h>
-
 /*! @defgroup shwcompileflags SHW Compile Flags
  *
  * These are flags which are used to configure the SHW driver at compilation
@@ -82,6 +79,7 @@
 #define SHW_DRIVER_NAME "fsl_shw"
 /*! @} */
 #endif
+/*#define SHW_DEBUG*/
 
 /*!
  * Add a user context onto the list of registered users.
diff --git a/drivers/mxc/security/rng/rng_driver.c b/drivers/mxc/security/rng/rng_driver.c
index 501d6de..d346639 100644
--- a/drivers/mxc/security/rng/rng_driver.c
+++ b/drivers/mxc/security/rng/rng_driver.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -60,16 +60,23 @@
 
 #if defined(RNG_DEBUG) || defined(RNG_ENTROPY_DEBUG) ||                     \
     defined(RNG_REGISTER_DEBUG)
+    
 #include <diagnostic.h>
+
+#else
+
+#define LOG_KDIAG_ARGS(fmt, ...)
+#define LOG_KDIAG(diag)
+
 #endif
 
 /* These are often handy */
 #ifndef FALSE
-/** Non-true value for arguments, return values. */
+/*! Non-true value for arguments, return values. */
 #define FALSE 0
 #endif
 #ifndef TRUE
-/** True value for arguments, return values. */
+/*! True value for arguments, return values. */
 #define TRUE 1
 #endif
 
@@ -79,7 +86,7 @@
  *
  *****************************************************************************/
 
-/**
+/*!
  * This is type void* so that a) it cannot directly be dereferenced, and b)
  * pointer arithmetic on it will function for the byte offsets in rng_rnga.h
  * and rng_rngc.h
@@ -98,51 +105,51 @@
  */
 static volatile void *rng_base;
 
-/**
+/*!
  * Flag to say whether interrupt handler has been registered for RNG
  * interrupt */
 static int rng_irq_set = FALSE;
 
-/**
+/*!
  * Size of the RNG's OUTPUT_FIFO, in words.  Retrieved with
  * #RNG_GET_FIFO_SIZE() during driver initialization.
  */
 static int rng_output_fifo_size;
 
-/** Major number for device driver. */
+/*! Major number for device driver. */
 static int rng_major;
 
-/** Registration handle for registering driver with OS. */
+/*! Registration handle for registering driver with OS. */
 os_driver_reg_t rng_reg_handle;
 
-/**
+/*!
  * Internal flag to know whether RNG is in Failed state (and thus many
  * registers are unavailable).  If the value ever goes to #RNG_STATUS_FAILED,
  * it will never change.
  */
 static volatile rng_status_t rng_availability = RNG_STATUS_INITIAL;
 
-/**
+/*!
  * Global lock for the RNG driver.  Mainly used for entries on the RNG work
  * queue.
  */
 static os_lock_t rng_queue_lock = NULL;
 
-/**
+/*!
  * Queue for the RNG task to process.
  */
 static shw_queue_t rng_work_queue;
 
-/**
+/*!
  * Flag to say whether task initialization succeeded.
  */
 static unsigned task_started = FALSE;
-/**
- * Waiting queue for RNG SELF TESTING
+/*!
+ * Waiting queue for RNG SELF TESTING 
  */
 static DECLARE_COMPLETION(rng_self_testing);
 static DECLARE_COMPLETION(rng_seed_done);
-/**
+/*!
  *  Object for blocking-mode callers of RNG driver to sleep.
  */
 OS_WAIT_OBJECT(rng_wait_queue);
@@ -156,7 +163,7 @@ OS_WAIT_OBJECT(rng_wait_queue);
 /*****************************************************************************/
 /* fn rng_init()                                                             */
 /*****************************************************************************/
-/**
+/*!
  * Initialize the driver.
  *
  * Set up the driver to have access to RNG device registers and verify that
@@ -183,7 +190,7 @@ OS_DEV_INIT(rng_init)
 	os_error_code return_code = OS_ERROR_FAIL_S;
 	rng_availability = RNG_STATUS_CHECKING;
 
-#if defined(FSL_HAVE_RNGC)
+#if !defined(FSL_HAVE_RNGA)
 	INIT_COMPLETION(rng_self_testing);
 	INIT_COMPLETION(rng_seed_done);
 #endif
@@ -192,34 +199,30 @@ OS_DEV_INIT(rng_init)
 
 	clk = clk_get(NULL, "rng_clk");
 
-	/* Check that the clock was found */
+	// Check that the clock was found
 	if (IS_ERR(clk)) {
-#ifdef RNG_DEBUG
 		LOG_KDIAG("RNG: Failed to find rng_clock.");
-#endif
 		return_code = OS_ERROR_FAIL_S;
 		goto check_err;
 	}
 
 	clk_enable(clk);
 
-	printk(KERN_INFO "RNG Driver: Loading\n");
+	os_printk(KERN_INFO "RNG Driver: Loading\n");
+
 	return_code = rng_map_RNG_memory();
 	if (return_code != OS_ERROR_OK_S) {
 		rng_availability = RNG_STATUS_UNIMPLEMENTED;
-#ifdef RNG_DEBUG
 		LOG_KDIAG_ARGS("RNG: Driver failed to map RNG registers. %d",
 			       return_code);
-#endif
 		goto check_err;
 	}
-#ifdef RNG_DEBUG
 	LOG_KDIAG_ARGS("RNG Driver: rng_base is 0x%08x", (uint32_t) rng_base);
-#endif
 	/*Check SCC keys are fused */
 	if (RNG_HAS_ERROR()) {
 		if (RNG_HAS_BAD_KEY()) {
 #ifdef RNG_DEBUG
+#if !defined(FSL_HAVE_RNGA)
 			LOG_KDIAG("ERROR: BAD KEYS SELECTED");
 			{
 				uint32_t rngc_status =
@@ -231,6 +234,7 @@ OS_DEV_INIT(rng_init)
 				     rngc_status, rngc_error);
 			}
 #endif
+#endif
 			rng_availability = RNG_STATUS_FAILED;
 			return_code = OS_ERROR_FAIL_S;
 			goto check_err;
@@ -252,9 +256,7 @@ OS_DEV_INIT(rng_init)
 
 	/* Determine status of RNG */
 	if (RNG_OSCILLATOR_FAILED()) {
-#ifdef RNG_DEBUG
 		LOG_KDIAG("RNG Driver: RNG Oscillator is dead");
-#endif
 		rng_availability = RNG_STATUS_FAILED;
 		goto check_err;
 	}
@@ -270,11 +272,9 @@ OS_DEV_INIT(rng_init)
 		/* Self Testing For RNG */
 		do {
 			RNG_CLEAR_ERR();
-			/* wait for Clearing Erring finished */
-			msleep(1);
 			RNG_UNMASK_ALL_INTERRUPTS();
 			RNG_SELF_TEST();
-#if defined(FSL_HAVE_RNGC)
+#if !defined(FSL_HAVE_RNGA)
 			wait_for_completion(&rng_self_testing);
 #endif
 		} while (RNG_CHECK_SELF_ERR());
@@ -284,7 +284,7 @@ OS_DEV_INIT(rng_init)
 		do {
 			RNG_CLEAR_ERR();
 			RNG_SEED_GEN();
-#if defined(FSL_HAVE_RNGC)
+#if !defined(FSL_HAVE_RNGA)
 			wait_for_completion(&rng_seed_done);
 #endif
 		} while (RNG_CHECK_SEED_ERR());
@@ -292,27 +292,21 @@ OS_DEV_INIT(rng_init)
 		RNG_SET_HIGH_ASSURANCE();
 #endif
 		if (RNG_GET_HIGH_ASSURANCE()) {
-#ifdef RNG_DEBUG
 			LOG_KDIAG("RNG Driver: RNG is in High Assurance mode");
-#endif
 		} else {
 #ifndef RNG_NO_FORCE_HIGH_ASSURANCE
-#ifdef RNG_DEBUG
 			LOG_KDIAG
-			("RNG Driver: RNG could not be put in High Assurance mode");
-#endif
-#endif				/* RNG_NO_FORCE_HIGH_ASSURANCE */
+			    ("RNG Driver: RNG could not be put in High Assurance mode");
 			rng_availability = RNG_STATUS_FAILED;
 			goto check_err;
+#endif				/* RNG_NO_FORCE_HIGH_ASSURANCE */
 		}
 
 		/* Check that RNG is OK */
 		if (!RNG_WORKING()) {
-#ifdef RNG_DEBUG
 			LOG_KDIAG_ARGS
 			    ("RNG determined to be inoperable.  Status %08x",
 			     RNG_GET_STATUS());
-#endif
 			/* Couldn't wake it up or other problem */
 			rng_availability = RNG_STATUS_FAILED;
 			goto check_err;
@@ -320,18 +314,14 @@ OS_DEV_INIT(rng_init)
 
 		rng_queue_lock = os_lock_alloc_init();
 		if (rng_queue_lock == NULL) {
-#ifdef RNG_DEBUG
 			LOG_KDIAG("RNG: lock initialization failed");
-#endif
 			rng_availability = RNG_STATUS_FAILED;
 			goto check_err;
 		}
 
 		return_code = os_create_task(rng_entropy_task);
 		if (return_code != OS_ERROR_OK_S) {
-#ifdef RNG_DEBUG
 			LOG_KDIAG("RNG: task initialization failed");
-#endif
 			rng_availability = RNG_STATUS_FAILED;
 			goto check_err;
 		} else {
@@ -340,10 +330,8 @@ OS_DEV_INIT(rng_init)
 #ifdef FSL_HAVE_RNGA
 		scc_code = scc_monitor_security_failure(rng_sec_failure);
 		if (scc_code != SCC_RET_OK) {
-#ifdef RNG_DEBUG
 			LOG_KDIAG_ARGS("Failed to register SCC callback: %d",
 				       scc_code);
-#endif
 #ifndef RNG_NO_FORCE_HIGH_ASSURANCE
 			return_code = OS_ERROR_FAIL_S;
 			goto check_err;
@@ -371,9 +359,8 @@ OS_DEV_INIT(rng_init)
 		RNG_PUT_RNG_TO_SLEEP();
 		rng_availability = RNG_STATUS_OK;	/* RNG & driver are ready */
 	} else if (return_code != OS_ERROR_OK_S) {
-#ifdef RNG_DEBUG
-		LOG_KDIAG_ARGS("Driver initialization failed. %d", return_code);
-#endif
+		os_printk(KERN_ALERT "Driver initialization failed. %d",
+			  return_code);
 		rng_cleanup();
 	}
 
@@ -384,7 +371,7 @@ OS_DEV_INIT(rng_init)
 /*****************************************************************************/
 /* fn rng_shutdown()                                                         */
 /*****************************************************************************/
-/**
+/*!
  * Prepare driver for exit.
  *
  * This is called during @c rmmod when the driver is unloading.
@@ -395,10 +382,7 @@ OS_DEV_INIT(rng_init)
  */
 OS_DEV_SHUTDOWN(rng_shutdown)
 {
-
-#ifdef RNG_DEBUG
 	LOG_KDIAG("shutdown called");
-#endif
 
 	rng_cleanup();
 
@@ -415,7 +399,7 @@ OS_DEV_SHUTDOWN(rng_shutdown)
 /*****************************************************************************/
 /* fn rng_cleanup()                                                          */
 /*****************************************************************************/
-/**
+/*!
  * Undo everything done by rng_init() and place driver in fail mode.
  *
  * Deregister from SCC, stop tasklet, shutdown the RNG.  Leave the register
@@ -447,17 +431,16 @@ static void rng_cleanup(void)
 			os_deregister_interrupt(INT_RNG);
 			rng_irq_set = FALSE;
 		}
+		LOG_KDIAG("Leaving rng driver status as failed");
 		rng_availability = RNG_STATUS_FAILED;
 	} else {
+		LOG_KDIAG("Leaving rng driver status as unimplemented");
 		rng_availability = RNG_STATUS_UNIMPLEMENTED;
 	}
-#ifdef RNG_DEBUG
 	LOG_KDIAG("Cleaned up");
-#endif
-
 }				/* rng_cleanup */
 
-/**
+/*!
  * Post-process routine for fsl_shw_get_random().
  *
  * This function will copy the random data generated by the background task
@@ -488,7 +471,7 @@ static uint32_t finish_random(shw_queue_entry_t * gen_entry)
 /*****************************************************************************/
 /* fn fsl_shw_get_random()                                                   */
 /*****************************************************************************/
-/**
+/*!
  * Get random data.
  *
  * @param      user_ctx  A user context from #fsl_shw_register_user().
@@ -497,7 +480,7 @@ static uint32_t finish_random(shw_queue_entry_t * gen_entry)
  *                       random data will be returned.
  *
  * @return     FSL_RETURN_NO_RESOURCE_S  A return code of type #fsl_shw_return_t.
- *             FSL_RETURN_OK_S
+ *             FSL_RETURN_OK_S 
  */
 fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx, uint32_t length,
 				    uint8_t * data)
@@ -509,6 +492,14 @@ fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx, uint32_t length,
 
 	if ((rng_availability != RNG_STATUS_OK) || (buf == NULL)
 	    || (work == NULL)) {
+		if (rng_availability != RNG_STATUS_OK) {
+			LOG_KDIAG_ARGS("rng not available: %d\n",
+				       rng_availability);
+		} else {
+			LOG_KDIAG_ARGS
+			    ("Resource allocation failure: %d or %d bytes",
+			     length, sizeof(*work));
+		}
 		/* Cannot perform function.  Clean up and clear out. */
 		if (buf != NULL) {
 			os_free_memory(buf);
@@ -547,7 +538,7 @@ fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx, uint32_t length,
 /*****************************************************************************/
 /* fn fsl_shw_add_entropy()                                                  */
 /*****************************************************************************/
-/**
+/*!
  * Add entropy to random number generator.
  *
  * @param      user_ctx  A user context from #fsl_shw_register_user().
@@ -560,7 +551,8 @@ fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx, uint32_t length,
 				     uint8_t * data)
 {
 	fsl_shw_return_t return_code = FSL_RETURN_NO_RESOURCE_S;
-#ifdef FSL_HAVE_RNGC
+#if defined(FSL_HAVE_RNGC)
+	/* No Entropy Register in RNGC */
 	return_code = FSL_RETURN_OK_S;
 #else
 	uint32_t *local_data = NULL;
@@ -665,7 +657,7 @@ rng_return_t rng_write_register(uint32_t register_offset, uint32_t value)
 /*****************************************************************************/
 /* fn check_register_offset()                                                */
 /*****************************************************************************/
-/**
+/*!
  * Verify that the @c offset is appropriate for the RNG's register set.
  *
  * @param[in]  offset  The (byte) offset within the RNG block
@@ -696,7 +688,7 @@ inline int rng_check_register_offset(uint32_t offset)
 /*****************************************************************************/
 /* fn check_register_accessible()                                            */
 /*****************************************************************************/
-/**
+/*!
  * Make sure that register access is legal.
  *
  * Verify that, if in secure mode, only safe registers are used.
@@ -732,11 +724,11 @@ static int rng_check_register_accessible(uint32_t offset, int access_write)
 	      (offset == RNGA_OSCILLATOR1_COUNTER) ||
 	      (offset == RNGA_OSCILLATOR2_COUNTER) ||
 	      (offset == RNGA_OSCILLATOR_COUNTER_STATUS)))
-#else				/* RNGC */
+#else				/* RNGB or RNGC */
 	    (secure &&
 	     ((offset == RNGC_FIFO) ||
 	      (offset == RNGC_VERIFICATION_CONTROL) ||
-	      (offset == RNGC_OSCILLATOR_CONTROL_COUNTER) ||
+	      (offset == RNGC_OSC_COUNTER_CONTROL) ||
 	      (offset == RNGC_OSC_COUNTER) ||
 	      (offset == RNGC_OSC_COUNTER_STATUS)))
 #endif
@@ -747,18 +739,22 @@ static int rng_check_register_accessible(uint32_t offset, int access_write)
 		   R/W permissions. */
 		if (access_write == RNG_CHECK_READ) {	/* read request */
 			/* Only the entropy register is write-only */
+#ifdef FSL_HAVE_RNGC
+			/* No registers are write-only */
+			return_code = TRUE;
+#else				/* else RNGA or RNGB */
 #ifdef FSL_HAVE_RNGA
-			if (!(offset == RNGA_ENTROPY)) {
+			if (1) {
+#else
+			if (!(offset == RNGB_ENTROPY)) {
+#endif
 				return_code = TRUE;	/* Let all others be read */
 			} else {
 				pr_debug
 				    ("RNG: Offset %04x denied read access\n",
 				     offset);
 			}
-#else				/* else RNGC */
-			/* No registers are write-only */
-			return_code = TRUE;
-#endif				/* RNGA */
+#endif				/* RNGA or RNGB */
 		} /* read */
 		else {		/* access_write means write */
 			/* Check against list of non-writable registers */
@@ -769,7 +765,7 @@ static int rng_check_register_accessible(uint32_t offset, int access_write)
 			     (offset == RNGA_OSCILLATOR1_COUNTER) ||
 			     (offset == RNGA_OSCILLATOR2_COUNTER) ||
 			     (offset == RNGA_OSCILLATOR_COUNTER_STATUS))
-#else				/* FSL_HAVE_RNGC */
+#else				/* FSL_HAVE_RNGB or FSL_HAVE_RNGC */
 			    ((offset == RNGC_STATUS) ||
 			     (offset == RNGC_FIFO) ||
 			     (offset == RNGC_OSC_COUNTER) ||
@@ -778,18 +774,14 @@ static int rng_check_register_accessible(uint32_t offset, int access_write)
 			    ) {
 				return_code = TRUE;	/* can be written */
 			} else {
-#ifdef RNG_DEBUG
 				LOG_KDIAG_ARGS
 				    ("Offset %04x denied write access", offset);
-#endif
 			}
 		}		/* write */
 	} /* not high assurance and inaccessible register... */
 	else {
-#ifdef RNG_DEBUG
 		LOG_KDIAG_ARGS("Offset %04x denied high-assurance access",
 			       offset);
-#endif
 	}
 
 	return return_code;
@@ -799,7 +791,7 @@ static int rng_check_register_accessible(uint32_t offset, int access_write)
 /*****************************************************************************/
 /* fn rng_irq()                                                             */
 /*****************************************************************************/
-/**
+/*!
  * This is the interrupt handler for the RNG.  It is only ever invoked if the
  * RNG detects a FIFO Underflow error.
  *
@@ -816,9 +808,7 @@ OS_DEV_ISR(rng_irq)
 {
 	int handled = FALSE;	/* assume interrupt isn't from RNG */
 
-#ifdef RNG_DEBUG
 	LOG_KDIAG("rng irq!");
-#endif
 
 	if (RNG_SEED_DONE()) {
 		complete(&rng_seed_done);
@@ -849,7 +839,7 @@ OS_DEV_ISR(rng_irq)
 /*****************************************************************************/
 /* fn map_RNG_memory()                                                      */
 /*****************************************************************************/
-/**
+/*!
  * Place the RNG's memory into kernel virtual space.
  *
  * @return OS_ERROR_OK_S on success, os_error_code on failure
@@ -861,9 +851,7 @@ static os_error_code rng_map_RNG_memory(void)
 	rng_base = os_map_device(RNG_BASE_ADDR, RNG_ADDRESS_RANGE);
 	if (rng_base == NULL) {
 		/* failure ! */
-#ifdef RNG_DEBUG
 		LOG_KDIAG("RNG Driver: ioremap failed.");
-#endif
 	} else {
 		error_code = OS_ERROR_OK_S;
 	}
@@ -874,7 +862,7 @@ static os_error_code rng_map_RNG_memory(void)
 /*****************************************************************************/
 /* fn rng_setup_interrupt_handling()                                        */
 /*****************************************************************************/
-/**
+/*!
  * Register #rng_irq() as the interrupt handler for #INT_RNG.
  *
  * @return OS_ERROR_OK_S on success, os_error_code on failure
@@ -890,10 +878,9 @@ static os_error_code rng_setup_interrupt_handling(void)
 	error_code = os_register_interrupt(RNG_DRIVER_NAME, INT_RNG,
 					   OS_DEV_ISR_REF(rng_irq));
 	if (error_code != OS_ERROR_OK_S) {
-#ifdef RNG_DEBUG
 		LOG_KDIAG("RNG Driver: Error installing Interrupt Handler");
-#endif
 	} else {
+		rng_irq_set = TRUE;
 		RNG_UNMASK_ALL_INTERRUPTS();
 	}
 
@@ -903,7 +890,7 @@ static os_error_code rng_setup_interrupt_handling(void)
 /*****************************************************************************/
 /* fn rng_grab_config_values()                                               */
 /*****************************************************************************/
-/**
+/*!
  * Read configuration information from the RNG.
  *
  * Sets #rng_output_fifo_size.
@@ -926,12 +913,10 @@ static os_error_code rng_grab_config_values(void)
 		}
 	}
 	if (ret != OS_ERROR_OK_S) {
-#ifdef RNG_DEBUG
 		LOG_KDIAG_ARGS
 		    ("Unknown or unexpected RNG type %d (FIFO size %d)."
 		     "  Failing driver initialization", type,
 		     rng_output_fifo_size);
-#endif
 	}
 
 	return ret;
@@ -942,7 +927,7 @@ static os_error_code rng_grab_config_values(void)
 /*****************************************************************************/
 /* fn rng_drain_fifo()                                                       */
 /*****************************************************************************/
-/**
+/*!
  * This function copies words from the RNG FIFO into the caller's buffer.
  *
  *
@@ -959,19 +944,21 @@ static fsl_shw_return_t rng_drain_fifo(uint32_t * random_p, int count_words)
 	int sequential_count = 0;	/* times through big while w/empty FIFO */
 	int fifo_empty_count = 0;	/* number of times FIFO was empty */
 	int max_sequential = 0;	/* max times 0 seen in a row */
-#if defined(FSL_HAVE_RNGC)
+#if !defined(FSL_HAVE_RNGA)
 	int count_for_reseed = 0;
 	INIT_COMPLETION(rng_seed_done);
 #endif
-#if defined(FSL_HAVE_RNGC)
+#if !defined(FSL_HAVE_RNGA)
 	if (RNG_RESEED()) {
 		do {
+			LOG_KDIAG("Reseeding RNG");
+
 			RNG_CLEAR_ERR();
 			RNG_SEED_GEN();
 			wait_for_completion(&rng_seed_done);
 			if (count_for_reseed == 3) {
 				os_printk(KERN_ALERT
-					"Device was not able to enter RESEED Mode\n");
+					  "Device was not able to enter RESEED Mode\n");
 				code = FSL_RETURN_INTERNAL_ERROR_S;
 			}
 			count_for_reseed++;
@@ -989,10 +976,8 @@ static fsl_shw_return_t rng_drain_fifo(uint32_t * random_p, int count_words)
 				max_sequential = sequential_count;
 			}
 			if (sequential_count >= RNG_MAX_TRIES) {
-#ifdef RNG_DEBUG
 				LOG_KDIAG_ARGS("FIFO staying empty (%d)",
 					       words_in_rng);
-#endif
 				code = FSL_RETURN_NO_RESOURCE_S;
 				break;
 			}
@@ -1023,10 +1008,8 @@ static fsl_shw_return_t rng_drain_fifo(uint32_t * random_p, int count_words)
 		code = FSL_RETURN_OK_S;
 	}
 	if (fifo_empty_count != 0) {
-#ifdef RNG_DEBUG
 		LOG_KDIAG_ARGS("FIFO empty %d times, max loop count %d",
 			       fifo_empty_count, max_sequential);
-#endif
 	}
 
 	return code;
@@ -1035,7 +1018,7 @@ static fsl_shw_return_t rng_drain_fifo(uint32_t * random_p, int count_words)
 /*****************************************************************************/
 /* fn rng_entropy_task()                                                     */
 /*****************************************************************************/
-/**
+/*!
  * This is the background task of the driver.  It is scheduled by
  * RNG_ADD_WORK_ENTRY().
  *
@@ -1100,7 +1083,7 @@ OS_DEV_TASK(rng_entropy_task)
 /*****************************************************************************/
 /* fn rng_sec_failure()                                                      */
 /*****************************************************************************/
-/**
+/*!
  * Function to handle "Security Alarm" indication from SCC.
  *
  * This function is registered with the Security Monitor ans the callback
@@ -1123,7 +1106,7 @@ static void rng_sec_failure(void)
 /*****************************************************************************/
 /* fn dbg_rng_read_register()                                                */
 /*****************************************************************************/
-/**
+/*!
  * Noisily read a 32-bit value to an RNG register.
  * @param offset        The address of the register to read.
  *
@@ -1147,7 +1130,7 @@ static uint32_t dbg_rng_read_register(uint32_t offset)
 /*****************************************************************************/
 /* fn dbg_rng_write_register()                                               */
 /*****************************************************************************/
-/**
+/*!
  * Noisily write a 32-bit value to an RNG register.
  * @param offset        The address of the register to written.
  *
@@ -1155,9 +1138,7 @@ static uint32_t dbg_rng_read_register(uint32_t offset)
  */
 static void dbg_rng_write_register(uint32_t offset, uint32_t value)
 {
-#ifdef RNG_DEBUG
 	LOG_KDIAG_ARGS("WR: 0x%4x : 0x%08x", offset, value);
-#endif
 	os_write32(value, rng_base + offset);
 	return;
 }
diff --git a/drivers/mxc/security/rng/shw_driver.c b/drivers/mxc/security/rng/shw_driver.c
index d5e7358..e552dc7 100644
--- a/drivers/mxc/security/rng/shw_driver.c
+++ b/drivers/mxc/security/rng/shw_driver.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -55,7 +55,6 @@
  * fsl_shw_deregister_user(), fsl_shw_get_capabilities(), and
  * fsl_shw_get_results().  Other parts of the API are provided by other
  * drivers, if available, to support the cryptographic functions.
- *  @ingroup RNG
  */
 
 #include "portable_os.h"
@@ -86,28 +85,43 @@ OS_DEV_SHUTDOWN_DCL(shw_shutdown);
 OS_DEV_IOCTL_DCL(shw_ioctl);
 OS_DEV_MMAP_DCL(shw_mmap);
 
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_smalloc);
+EXPORT_SYMBOL(fsl_shw_sfree);
+EXPORT_SYMBOL(fsl_shw_sstatus);
+EXPORT_SYMBOL(fsl_shw_diminish_perms);
+EXPORT_SYMBOL(do_scc_encrypt_region);
+EXPORT_SYMBOL(do_scc_decrypt_region);
+
+EXPORT_SYMBOL(do_system_keystore_slot_alloc);
+EXPORT_SYMBOL(do_system_keystore_slot_dealloc);
+EXPORT_SYMBOL(do_system_keystore_slot_load);
+EXPORT_SYMBOL(do_system_keystore_slot_encrypt);
+EXPORT_SYMBOL(do_system_keystore_slot_decrypt);
+#endif
+
 static os_error_code
-shw_handle_scc_sfree(fsl_shw_uco_t *user_ctx, uint32_t info);
+shw_handle_scc_sfree(fsl_shw_uco_t * user_ctx, uint32_t info);
 
 static os_error_code
-shw_handle_scc_sstatus(fsl_shw_uco_t *user_ctx, uint32_t info);
+shw_handle_scc_sstatus(fsl_shw_uco_t * user_ctx, uint32_t info);
 
 static os_error_code
-shw_handle_scc_drop_perms(fsl_shw_uco_t *user_ctx, uint32_t info);
+shw_handle_scc_drop_perms(fsl_shw_uco_t * user_ctx, uint32_t info);
 
 static os_error_code
-shw_handle_scc_encrypt(fsl_shw_uco_t *user_ctx, uint32_t info);
+shw_handle_scc_encrypt(fsl_shw_uco_t * user_ctx, uint32_t info);
 
 static os_error_code
-shw_handle_scc_decrypt(fsl_shw_uco_t *user_ctx, uint32_t info);
+shw_handle_scc_decrypt(fsl_shw_uco_t * user_ctx, uint32_t info);
 
 #ifdef FSL_HAVE_SCC2
-static fsl_shw_return_t register_user_partition(fsl_shw_uco_t *user_ctx,
+static fsl_shw_return_t register_user_partition(fsl_shw_uco_t * user_ctx,
 						uint32_t user_base,
 						void *kernel_base);
-static fsl_shw_return_t deregister_user_partition(fsl_shw_uco_t *user_ctx,
+static fsl_shw_return_t deregister_user_partition(fsl_shw_uco_t * user_ctx,
 						  uint32_t user_base);
-void *lookup_user_partition(fsl_shw_uco_t *user_ctx, uint32_t user_base);
+void *lookup_user_partition(fsl_shw_uco_t * user_ctx, uint32_t user_base);
 
 #endif				/* FSL_HAVE_SCC2 */
 
@@ -117,28 +131,28 @@ void *lookup_user_partition(fsl_shw_uco_t *user_ctx, uint32_t user_base);
  *
  *****************************************************************************/
 
-/**
+/*!
  *  Major node (user/device interaction value) of this driver.
  */
 static int shw_major_node = SHW_MAJOR_NODE;
 
-/**
+/*!
  *  Flag to know whether the driver has been associated with its user device
  *  node (e.g. /dev/shw).
  */
 static int shw_device_registered = 0;
 
-/**
+/*!
  * OS-dependent handle used for registering user interface of a driver.
  */
 static os_driver_reg_t reg_handle;
 
-/**
+/*!
  * Linked List of registered users of the API
  */
 fsl_shw_uco_t *user_list;
 
-/**
+/*!
  * This is the lock for all user request pools.  H/W component drivers may also
  * use it for their own work queues.
  */
@@ -148,23 +162,23 @@ os_lock_t shw_queue_lock = NULL;
 fsl_shw_kso_t system_keystore;
 
 #ifndef FSL_HAVE_SAHARA
-/** Empty list of supported symmetric algorithms. */
+/*! Empty list of supported symmetric algorithms. */
 static fsl_shw_key_alg_t pf_syms[] = {
 };
 
-/** Empty list of supported symmetric modes. */
+/*! Empty list of supported symmetric modes. */
 static fsl_shw_sym_mode_t pf_modes[] = {
 };
 
-/** Empty list of supported hash algorithms. */
+/*! Empty list of supported hash algorithms. */
 static fsl_shw_hash_alg_t pf_hashes[] = {
 };
 #endif				/* no Sahara */
 
-/** This matches SHW capabilities... */
+/*! This matches SHW capabilities... */
 static fsl_shw_pco_t cap = {
-	1, 2,			/* api version number - major & minor */
-	1, 1,			/* driver version number - major & minor */
+	1, 3,			/* api version number - major & minor */
+	2, 3,			/* driver version number - major & minor */
 	sizeof(pf_syms) / sizeof(fsl_shw_key_alg_t),	/* key alg count */
 	pf_syms,		/* key alg list ptr */
 	sizeof(pf_modes) / sizeof(fsl_shw_sym_mode_t),	/* sym mode count */
@@ -182,8 +196,13 @@ static fsl_shw_pco_t cap = {
 	 ,			/* AES  */
 	 {0, 0, 0, 0}
 	 ,			/* DES */
+#ifdef FSL_HAVE_DRYICE
+	 {0, 1, 1, 0}
+	 ,			/* 3DES - ECB and CBC */
+#else
 	 {0, 0, 0, 0}
 	 ,			/* 3DES */
+#endif
 	 {0, 0, 0, 0}		/* ARC4 */
 	 }
 	,
@@ -196,11 +215,11 @@ static fsl_shw_pco_t cap = {
 
 /* These are often handy */
 #ifndef FALSE
-/** Not true.  Guaranteed to be zero. */
+/*! Not true.  Guaranteed to be zero. */
 #define FALSE 0
 #endif
 #ifndef TRUE
-/** True.  Guaranteed to be non-zero. */
+/*! True.  Guaranteed to be non-zero. */
 #define TRUE 1
 #endif
 
@@ -213,7 +232,7 @@ static fsl_shw_pco_t cap = {
 /*****************************************************************************/
 /* fn shw_init()                                                             */
 /*****************************************************************************/
-/**
+/*!
  * Initialize the driver.
  *
  * This routine is called during kernel init or module load (insmod).
@@ -253,19 +272,19 @@ OS_DEV_INIT(shw_init)
 	cap.block_size_bytes = shw_capabilities->block_size_bytes;
 
 #ifdef FSL_HAVE_SCC
-	cap.scc_info.black_ram_size_blocks =
+	cap.u.scc_info.black_ram_size_blocks =
 	    shw_capabilities->black_ram_size_blocks;
-	cap.scc_info.red_ram_size_blocks =
+	cap.u.scc_info.red_ram_size_blocks =
 	    shw_capabilities->red_ram_size_blocks;
 #elif defined(FSL_HAVE_SCC2)
-	cap.scc2_info.partition_size_bytes =
+	cap.u.scc2_info.partition_size_bytes =
 	    shw_capabilities->partition_size_bytes;
-	cap.scc2_info.partition_count = shw_capabilities->partition_count;
+	cap.u.scc2_info.partition_count = shw_capabilities->partition_count;
 #endif
 
-#ifdef FSL_HAVE_SCC2
+#if defined(FSL_HAVE_SCC2) || defined(FSL_HAVE_DRYICE)
 	if (error_code == OS_ERROR_OK_S) {
-/* set up the system keystore, using the default keystore handler */
+		/* set up the system keystore, using the default keystore handler */
 		fsl_shw_init_keystore_default(&system_keystore);
 
 		if (fsl_shw_establish_keystore(NULL, &system_keystore)
@@ -275,7 +294,7 @@ OS_DEV_INIT(shw_init)
 			error_code = OS_ERROR_FAIL_S;
 		}
 
-		if (error_code < OS_ERROR_OK_S) {
+		if (error_code != OS_ERROR_OK_S) {
 #ifdef SHW_DEBUG
 			LOG_KDIAG_ARGS
 			    ("Registering the system keystore failed with error"
@@ -303,7 +322,7 @@ OS_DEV_INIT(shw_init)
 /*****************************************************************************/
 /* fn shw_shutdown()                                                         */
 /*****************************************************************************/
-/**
+/*!
  * Prepare driver for exit.
  *
  * This is called during @c rmmod when the driver is unloading or when the
@@ -326,7 +345,7 @@ OS_DEV_SHUTDOWN(shw_shutdown)
 /*****************************************************************************/
 /* fn shw_cleanup()                                                          */
 /*****************************************************************************/
-/**
+/*!
  * Prepare driver for shutdown.
  *
  * Remove the driver registration.
@@ -352,7 +371,7 @@ static void shw_cleanup(void)
 /*****************************************************************************/
 /* fn shw_open()                                                             */
 /*****************************************************************************/
-/**
+/*!
  * Handle @c open() call from user.
  *
  * @return OS_ERROR_OK_S on success (always!)
@@ -369,7 +388,7 @@ OS_DEV_OPEN(shw_open)
 /*****************************************************************************/
 /* fn shw_ioctl()                                                            */
 /*****************************************************************************/
-/**
+/*!
  * Process an ioctl() request from user-mode API.
  *
  * This code determines which of the API requests the user has made and then
@@ -399,8 +418,10 @@ OS_DEV_IOCTL(shw_ioctl)
 			if (user_ctx == NULL) {
 				code = OS_ERROR_NO_MEMORY_S;
 			} else {
-				code = init_uco(user_ctx, (fsl_shw_uco_t *)
-						os_dev_get_ioctl_arg());
+				code =
+				    init_uco(user_ctx,
+					     (fsl_shw_uco_t *)
+					     os_dev_get_ioctl_arg());
 				if (code == OS_ERROR_OK_S) {
 					os_dev_set_user_private(user_ctx);
 				} else {
@@ -424,7 +445,8 @@ OS_DEV_IOCTL(shw_ioctl)
 #ifdef SHW_DEBUG
 		LOG_KDIAG("SHW: get_results ioctl received");
 #endif
-		code = get_results(user_ctx, (struct results_req *)
+		code = get_results(user_ctx,
+				   (struct results_req *)
 				   os_dev_get_ioctl_arg());
 		break;
 
@@ -432,7 +454,8 @@ OS_DEV_IOCTL(shw_ioctl)
 #ifdef SHW_DEBUG
 		LOG_KDIAG("SHW: get_capabilities ioctl received");
 #endif
-		code = get_capabilities(user_ctx, (fsl_shw_pco_t *)
+		code = get_capabilities(user_ctx,
+					(fsl_shw_pco_t *)
 					os_dev_get_ioctl_arg());
 		break;
 
@@ -440,7 +463,8 @@ OS_DEV_IOCTL(shw_ioctl)
 #ifdef SHW_DEBUG
 		LOG_KDIAG("SHW: get_random ioctl received");
 #endif
-		code = get_random(user_ctx, (struct get_random_req *)
+		code = get_random(user_ctx,
+				  (struct get_random_req *)
 				  os_dev_get_ioctl_arg());
 		break;
 
@@ -448,7 +472,8 @@ OS_DEV_IOCTL(shw_ioctl)
 #ifdef SHW_DEBUG
 		LOG_KDIAG("SHW: add_entropy ioctl received");
 #endif
-		code = add_entropy(user_ctx, (struct add_entropy_req *)
+		code = add_entropy(user_ctx,
+				   (struct add_entropy_req *)
 				   os_dev_get_ioctl_arg());
 		break;
 
@@ -506,12 +531,12 @@ OS_DEV_IOCTL(shw_ioctl)
 /*****************************************************************************/
 uint32_t get_user_smid(void *proc)
 {
-/*
- * A real implementation would have some way to handle signed applications
- * which wouild be assigned distinct SMIDs.  For the reference
- * implementation, we show where this would be determined (here), but
- * always provide a fixed answer, thus not separating users at all.
- */
+	/*
+	 * A real implementation would have some way to handle signed applications
+	 * which wouild be assigned distinct SMIDs.  For the reference
+	 * implementation, we show where this would be determined (here), but
+	 * always provide a fixed answer, thus not separating users at all.
+	 */
 
 	return 0x42eaae42;
 }
@@ -519,21 +544,22 @@ uint32_t get_user_smid(void *proc)
 /* user_base: userspace base address of the partition
  * kernel_base: kernel mode base address of the partition
  */
-static fsl_shw_return_t register_user_partition(fsl_shw_uco_t *user_ctx,
+static fsl_shw_return_t register_user_partition(fsl_shw_uco_t * user_ctx,
 						uint32_t user_base,
 						void *kernel_base)
 {
 	fsl_shw_spo_t *partition_info;
 	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
 
-	if (user_ctx == NULL)
+	if (user_ctx == NULL) {
 		goto out;
+	}
 
 	partition_info = os_alloc_memory(sizeof(fsl_shw_spo_t), GFP_KERNEL);
 
-	if (partition_info == NULL)
+	if (partition_info == NULL) {
 		goto out;
-
+	}
 
 	/* stuff the partition info, then put it at the front of the chain */
 	partition_info->user_base = user_base;
@@ -550,13 +576,13 @@ static fsl_shw_return_t register_user_partition(fsl_shw_uco_t *user_ctx,
 
 	ret = FSL_RETURN_OK_S;
 
-out:
+      out:
 
 	return ret;
 }
 
 /* if the partition is in the users list, remove it */
-static fsl_shw_return_t deregister_user_partition(fsl_shw_uco_t *user_ctx,
+static fsl_shw_return_t deregister_user_partition(fsl_shw_uco_t * user_ctx,
 						  uint32_t user_base)
 {
 	fsl_shw_spo_t *curr = (fsl_shw_spo_t *) user_ctx->partition;
@@ -592,16 +618,17 @@ static fsl_shw_return_t deregister_user_partition(fsl_shw_uco_t *user_ctx,
 /* Find the kernel-mode address of the partition.
  * This can then be passed to the SCC functions.
  */
-void *lookup_user_partition(fsl_shw_uco_t *user_ctx, uint32_t user_base)
+void *lookup_user_partition(fsl_shw_uco_t * user_ctx, uint32_t user_base)
 {
-/* search through the partition chain to find one that matches the user base
- * address.
- */
+	/* search through the partition chain to find one that matches the user base
+	 * address.
+	 */
 	fsl_shw_spo_t *curr = (fsl_shw_spo_t *) user_ctx->partition;
 
 	while (curr != NULL) {
-		if (curr->user_base == user_base)
+		if (curr->user_base == user_base) {
 			return curr->kernel_base;
+		}
 		curr = (fsl_shw_spo_t *) curr->next;
 	}
 	return NULL;
@@ -609,7 +636,7 @@ void *lookup_user_partition(fsl_shw_uco_t *user_ctx, uint32_t user_base)
 
 #endif				/* FSL_HAVE_SCC2 */
 
-/**
+/*!
 *******************************************************************************
 * This function implements the smalloc() function for userspace programs, by
 * making a call to the SCC2 mmap() function that acquires a region of secure
@@ -654,9 +681,9 @@ OS_DEV_MMAP(shw_mmap)
 		/* Determine the size of a secure partition */
 		scc_configuration = scc_get_configuration();
 
-	/* Check that the memory size requested is equal to the partition
-	 * size, and that the requested destination is on a page boundary.
-	 */
+		/* Check that the memory size requested is equal to the partition
+		 * size, and that the requested destination is on a page boundary.
+		 */
 		if (((os_mmap_user_base() % PAGE_SIZE) != 0) ||
 		    (os_mmap_memory_size() !=
 		     scc_configuration->partition_size_bytes)) {
@@ -690,8 +717,8 @@ OS_DEV_MMAP(shw_mmap)
 
 		if (fsl_ret != FSL_RETURN_OK_S) {
 			pr_debug
-		    ("SCC mmap() request failed to register partition with user"
-		     " context, error: %d\n", fsl_ret);
+			    ("SCC mmap() request failed to register partition with user"
+			     " context, error: %d\n", fsl_ret);
 			status = OS_ERROR_FAIL_S;
 		}
 
@@ -703,21 +730,23 @@ OS_DEV_MMAP(shw_mmap)
 #ifdef SHW_DEBUG
 		if (status == OS_ERROR_OK_S) {
 			LOG_KDIAG_ARGS
-		    ("Partition allocated: user_base=%p, partition_base=%p.",
-		     (void *)user_base, partition_base);
+			    ("Partition allocated: user_base=%p, partition_base=%p.",
+			     (void *)user_base, partition_base);
 		}
 #endif
 
-out:
+	      out:
 		/* If there is an error it has to be handled here */
 		if (status != OS_ERROR_OK_S) {
-		/* if the partition was registered with the user, unregister it. */
-			if (partition_registered == TRUE)
+			/* if the partition was registered with the user, unregister it. */
+			if (partition_registered == TRUE) {
 				deregister_user_partition(user_ctx, user_base);
+			}
 
 			/* if the partition was allocated, deallocate it */
-			if (partition_base != NULL)
+			if (partition_base != NULL) {
 				scc_release_partition(partition_base);
+			}
 		}
 	}
 #endif				/* FSL_HAVE_SCC2 */
@@ -728,7 +757,7 @@ out:
 /*****************************************************************************/
 /* fn shw_release()                                                         */
 /*****************************************************************************/
-/**
+/*!
  * Handle @c close() call from user.
  * This is a Linux device driver interface routine.
  *
@@ -753,7 +782,7 @@ OS_DEV_CLOSE(shw_release)
 /*****************************************************************************/
 /* fn shw_user_callback()                                                    */
 /*****************************************************************************/
-/**
+/*!
  * FSL SHW User callback function.
  *
  * This function is set in the kernel version of the user context as the
@@ -766,7 +795,7 @@ OS_DEV_CLOSE(shw_release)
  *
  * @return void
  */
-static void shw_user_callback(fsl_shw_uco_t *user_ctx)
+static void shw_user_callback(fsl_shw_uco_t * user_ctx)
 {
 #ifdef SHW_DEBUG
 	LOG_KDIAG_ARGS("SHW: Signalling callback user process for context %p\n",
@@ -778,7 +807,7 @@ static void shw_user_callback(fsl_shw_uco_t *user_ctx)
 /*****************************************************************************/
 /* fn setup_user_driver_interaction()                                        */
 /*****************************************************************************/
-/**
+/*!
  * Register the driver with the kernel as the driver for shw_major_node.  Note
  * that this value may be zero, in which case the major number will be assigned
  * by the OS.  shw_major_node is never modified.
@@ -825,7 +854,7 @@ static os_error_code shw_setup_user_driver_interaction(void)
 /* User Mode Support                                              */
 /******************************************************************/
 
-/**
+/*!
  * Initialze kernel User Context Object from User-space version.
  *
  * Copy user UCO into kernel UCO, set flags and fields for operation
@@ -857,7 +886,7 @@ static os_error_code init_uco(fsl_shw_uco_t * user_ctx, void *user_mode_uco)
 	return code;
 }
 
-/**
+/*!
  * Copy array from kernel to user space.
  *
  * This routine will check bounds before trying to copy, and return failure
@@ -887,7 +916,7 @@ inline static void *copy_array(void *userloc, void *userend, void *data_start,
 	return userloc;
 }
 
-/**
+/*!
  * Send an FSL SHW API return code up into the user-space request structure.
  *
  * @param user_header   User address of request block / request header
@@ -906,7 +935,7 @@ inline static os_error_code copy_fsl_code(void *user_header,
 			       &result_code, sizeof(result_code));
 }
 
-static os_error_code shw_handle_scc_drop_perms(fsl_shw_uco_t *user_ctx,
+static os_error_code shw_handle_scc_drop_perms(fsl_shw_uco_t * user_ctx,
 					       uint32_t info)
 {
 	os_error_code status = OS_ERROR_NO_MEMORY_S;
@@ -919,8 +948,9 @@ static os_error_code shw_handle_scc_drop_perms(fsl_shw_uco_t *user_ctx,
 	    os_copy_from_user(&partition_info, (void *)info,
 			      sizeof(partition_info));
 
-	if (status != OS_ERROR_OK_S)
+	if (status != OS_ERROR_OK_S) {
 		goto out;
+	}
 
 	/* validate that the user owns this partition, and look up its handle */
 	kernel_base = lookup_user_partition(user_ctx, partition_info.user_base);
@@ -942,12 +972,12 @@ static os_error_code shw_handle_scc_drop_perms(fsl_shw_uco_t *user_ctx,
 		status = OS_ERROR_FAIL_S;
 	}
 
-out:
+      out:
 #endif				/* FSL_HAVE_SCC2 */
 	return status;
 }
 
-static os_error_code shw_handle_scc_sstatus(fsl_shw_uco_t *user_ctx,
+static os_error_code shw_handle_scc_sstatus(fsl_shw_uco_t * user_ctx,
 					    uint32_t info)
 {
 	os_error_code status = OS_ERROR_NO_MEMORY_S;
@@ -958,8 +988,9 @@ static os_error_code shw_handle_scc_sstatus(fsl_shw_uco_t *user_ctx,
 	status = os_copy_from_user(&partition_info,
 				   (void *)info, sizeof(partition_info));
 
-	if (status != OS_ERROR_OK_S)
+	if (status != OS_ERROR_OK_S) {
 		goto out;
+	}
 
 	/* validate that the user owns this partition, and look up its handle */
 	kernel_base = lookup_user_partition(user_ctx, partition_info.user_base);
@@ -979,12 +1010,12 @@ static os_error_code shw_handle_scc_sstatus(fsl_shw_uco_t *user_ctx,
 	status = os_copy_to_user((void *)info,
 				 &partition_info, sizeof(partition_info));
 
-out:
+      out:
 #endif				/* FSL_HAVE_SCC2 */
 	return status;
 }
 
-static os_error_code shw_handle_scc_sfree(fsl_shw_uco_t *user_ctx,
+static os_error_code shw_handle_scc_sfree(fsl_shw_uco_t * user_ctx,
 					  uint32_t info)
 {
 	os_error_code status = OS_ERROR_NO_MEMORY_S;
@@ -999,10 +1030,11 @@ static os_error_code shw_handle_scc_sfree(fsl_shw_uco_t *user_ctx,
 					   sizeof(partition_info));
 
 		/* check that the copy was successful */
-		if (status != OS_ERROR_OK_S)
+		if (status != OS_ERROR_OK_S) {
 			goto out;
+		}
 
-	/* validate that the user owns this partition, and look up its handle */
+		/* validate that the user owns this partition, and look up its handle */
 		kernel_base =
 		    lookup_user_partition(user_ctx, partition_info.user_base);
 
@@ -1036,12 +1068,12 @@ static os_error_code shw_handle_scc_sfree(fsl_shw_uco_t *user_ctx,
 		}
 
 	}
-out:
+      out:
 #endif				/* FSL_HAVE_SCC2 */
 	return status;
 }
 
-static os_error_code shw_handle_scc_encrypt(fsl_shw_uco_t *user_ctx,
+static os_error_code shw_handle_scc_encrypt(fsl_shw_uco_t * user_ctx,
 					    uint32_t info)
 {
 	os_error_code status = OS_ERROR_FAIL_S;
@@ -1058,10 +1090,11 @@ static os_error_code shw_handle_scc_encrypt(fsl_shw_uco_t *user_ctx,
 		    os_copy_from_user(&region_info, (void *)info,
 				      sizeof(region_info));
 
-		if (status != OS_ERROR_OK_S)
+		if (status != OS_ERROR_OK_S) {
 			goto out;
+		}
 
-	/* validate that the user owns this partition, and look up its handle */
+		/* validate that the user owns this partition, and look up its handle */
 		partition_base = lookup_user_partition(user_ctx,
 						       region_info.
 						       partition_base);
@@ -1098,21 +1131,22 @@ static os_error_code shw_handle_scc_encrypt(fsl_shw_uco_t *user_ctx,
 					  region_info.IV,
 					  region_info.cypher_mode);
 
-		if (retval == FSL_RETURN_OK_S)
+		if (retval == FSL_RETURN_OK_S) {
 			status = OS_ERROR_OK_S;
-		else
+		} else {
 			status = OS_ERROR_FAIL_S;
+		}
 
 		/* release black data */
 		unwire_user_memory(&page_ctx);
 	}
-out:
+      out:
 
 #endif				/* FSL_HAVE_SCC2 */
 	return status;
 }
 
-static os_error_code shw_handle_scc_decrypt(fsl_shw_uco_t *user_ctx,
+static os_error_code shw_handle_scc_decrypt(fsl_shw_uco_t * user_ctx,
 					    uint32_t info)
 {
 	os_error_code status = OS_ERROR_FAIL_S;
@@ -1136,10 +1170,11 @@ static os_error_code shw_handle_scc_decrypt(fsl_shw_uco_t *user_ctx,
 		     region_info.length, (void *)region_info.black_data);
 #endif
 
-		if (status != OS_ERROR_OK_S)
+		if (status != OS_ERROR_OK_S) {
 			goto out;
+		}
 
-	/* validate that the user owns this partition, and look up its handle */
+		/* validate that the user owns this partition, and look up its handle */
 		partition_base = lookup_user_partition(user_ctx,
 						       region_info.
 						       partition_base);
@@ -1176,76 +1211,84 @@ static os_error_code shw_handle_scc_decrypt(fsl_shw_uco_t *user_ctx,
 					  region_info.IV,
 					  region_info.cypher_mode);
 
-		if (retval == FSL_RETURN_OK_S)
+		if (retval == FSL_RETURN_OK_S) {
 			status = OS_ERROR_OK_S;
-		else
+		} else {
 			status = OS_ERROR_FAIL_S;
+		}
 
 		/* release black data */
 		unwire_user_memory(&page_ctx);
 	}
-out:
+      out:
 
 #endif				/* FSL_HAVE_SCC2 */
 	return status;
 }
 
-fsl_shw_return_t do_system_keystore_slot_alloc(fsl_shw_uco_t *user_ctx,
+fsl_shw_return_t do_system_keystore_slot_alloc(fsl_shw_uco_t * user_ctx,
 					       uint32_t key_length,
 					       uint64_t ownerid,
-					       uint32_t *slot)
+					       uint32_t * slot)
 {
 	(void)user_ctx;
 	return keystore_slot_alloc(&system_keystore, key_length, ownerid, slot);
 }
-EXPORT_SYMBOL(do_system_keystore_slot_alloc);
 
-fsl_shw_return_t do_system_keystore_slot_dealloc(fsl_shw_uco_t *user_ctx,
+fsl_shw_return_t do_system_keystore_slot_dealloc(fsl_shw_uco_t * user_ctx,
 						 uint64_t ownerid,
 						 uint32_t slot)
 {
 	(void)user_ctx;
 	return keystore_slot_dealloc(&system_keystore, ownerid, slot);
 }
-EXPORT_SYMBOL(do_system_keystore_slot_dealloc);
 
-fsl_shw_return_t do_system_keystore_slot_load(fsl_shw_uco_t *user_ctx,
+fsl_shw_return_t do_system_keystore_slot_load(fsl_shw_uco_t * user_ctx,
 					      uint64_t ownerid,
 					      uint32_t slot,
-					      const uint8_t *key,
+					      const uint8_t * key,
 					      uint32_t key_length)
 {
 	(void)user_ctx;
-	return keystore_load_slot(&system_keystore, ownerid, slot,
+	return keystore_slot_load(&system_keystore, ownerid, slot,
 				  (void *)key, key_length);
 }
-EXPORT_SYMBOL(do_system_keystore_slot_load);
 
-fsl_shw_return_t do_system_keystore_slot_encrypt(fsl_shw_uco_t *user_ctx,
+fsl_shw_return_t do_system_keystore_slot_encrypt(fsl_shw_uco_t * user_ctx,
 						 uint64_t ownerid,
 						 uint32_t slot,
 						 uint32_t key_length,
-						 uint8_t *black_data)
+						 uint8_t * black_data)
 {
 	(void)user_ctx;
 	return keystore_slot_encrypt(NULL, &system_keystore, ownerid,
 				     slot, key_length, black_data);
 }
-EXPORT_SYMBOL(do_system_keystore_slot_encrypt);
 
-fsl_shw_return_t do_system_keystore_slot_decrypt(fsl_shw_uco_t *user_ctx,
+fsl_shw_return_t do_system_keystore_slot_decrypt(fsl_shw_uco_t * user_ctx,
 						 uint64_t ownerid,
 						 uint32_t slot,
 						 uint32_t key_length,
-						 const uint8_t *black_data)
+						 const uint8_t * black_data)
 {
 	(void)user_ctx;
 	return keystore_slot_decrypt(NULL, &system_keystore, ownerid,
 				     slot, key_length, black_data);
 }
-EXPORT_SYMBOL(do_system_keystore_slot_decrypt);
 
-/**
+fsl_shw_return_t do_system_keystore_slot_read(fsl_shw_uco_t * user_ctx,
+					      uint64_t ownerid,
+					      uint32_t slot,
+					      uint32_t key_length,
+					      uint8_t * key_data)
+{
+	(void)user_ctx;
+
+	return keystore_slot_read(&system_keystore, ownerid,
+				  slot, key_length, key_data);
+}
+
+/*!
  * Handle user-mode Get Capabilities request
  *
  * Right now, this function can only have a failure if the user has failed to
@@ -1259,7 +1302,7 @@ EXPORT_SYMBOL(do_system_keystore_slot_decrypt);
  *
  * @return an os_error_code
  */
-static os_error_code get_capabilities(fsl_shw_uco_t *user_ctx,
+static os_error_code get_capabilities(fsl_shw_uco_t * user_ctx,
 				      void *user_mode_pco_request)
 {
 	os_error_code code;
@@ -1343,7 +1386,7 @@ static os_error_code get_capabilities(fsl_shw_uco_t *user_ctx,
 	return code;
 }
 
-/**
+/*!
  * Handle user-mode Get Results request
  *
  * Get arguments from user space into kernel space, then call
@@ -1355,7 +1398,7 @@ static os_error_code get_capabilities(fsl_shw_uco_t *user_ctx,
  *
  * @return an os_error_code
  */
-static os_error_code get_results(fsl_shw_uco_t *user_ctx,
+static os_error_code get_results(fsl_shw_uco_t * user_ctx,
 				 void *user_mode_results_req)
 {
 	os_error_code code;
@@ -1403,7 +1446,7 @@ static os_error_code get_results(fsl_shw_uco_t *user_ctx,
 	return code;
 }
 
-/**
+/*!
  * Process header of user-mode request.
  *
  * Mark header as User Mode request.  Update UCO's flags and reference fields
@@ -1414,7 +1457,7 @@ static os_error_code get_results(fsl_shw_uco_t *user_ctx,
  *
  * @return void
  */
-static inline void process_hdr(fsl_shw_uco_t *user_ctx,
+inline static void process_hdr(fsl_shw_uco_t * user_ctx,
 			       struct shw_req_header *hdr)
 {
 	hdr->flags |= FSL_UCO_USERMODE_USER;
@@ -1424,7 +1467,7 @@ static inline void process_hdr(fsl_shw_uco_t *user_ctx,
 	return;
 }
 
-/**
+/*!
  * Handle user-mode Get Random request
  *
  * @param user_ctx    The kernel version of user's context
@@ -1432,7 +1475,7 @@ static inline void process_hdr(fsl_shw_uco_t *user_ctx,
  *
  * @return an os_error_code
  */
-static os_error_code get_random(fsl_shw_uco_t *user_ctx,
+static os_error_code get_random(fsl_shw_uco_t * user_ctx,
 				void *user_mode_get_random_req)
 {
 	os_error_code code;
@@ -1461,7 +1504,7 @@ static os_error_code get_random(fsl_shw_uco_t *user_ctx,
 	return code;
 }
 
-/**
+/*!
  * Handle user-mode Add Entropy request
  *
  * @param user_ctx    Pointer to the kernel version of user's context
@@ -1469,7 +1512,7 @@ static os_error_code get_random(fsl_shw_uco_t *user_ctx,
  *
  * @return an os_error_code
  */
-static os_error_code add_entropy(fsl_shw_uco_t *user_ctx,
+static os_error_code add_entropy(fsl_shw_uco_t * user_ctx,
 				 void *user_mode_add_entropy_req)
 {
 	os_error_code code;
@@ -1505,6 +1548,9 @@ static os_error_code add_entropy(fsl_shw_uco_t *user_ctx,
 /* End User Mode Support                                          */
 /******************************************************************/
 
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_register_user);
+#endif
 /* REQ-S2LRD-PINTFC-API-GEN-004 */
 /*
  * Handle user registration.
@@ -1513,7 +1559,7 @@ static os_error_code add_entropy(fsl_shw_uco_t *user_ctx,
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t *user_ctx)
+fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t * user_ctx)
 {
 	fsl_shw_return_t code = FSL_RETURN_INTERNAL_ERROR_S;
 
@@ -1534,17 +1580,19 @@ fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t *user_ctx)
       error_exit:
 	return code;
 }
-EXPORT_SYMBOL(fsl_shw_register_user);
 
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_deregister_user);
+#endif
 /* REQ-S2LRD-PINTFC-API-GEN-005 */
-/**
+/*!
  * Destroy the association between the the user and the provider of the API.
  *
  * @param  user_ctx   The user context which is no longer needed.
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t *user_ctx)
+fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t * user_ctx)
 {
 	shw_queue_entry_t *finished_request;
 	fsl_shw_return_t ret = FSL_RETURN_OK_S;
@@ -1581,11 +1629,11 @@ fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t *user_ctx)
 			     partition);
 #endif
 
-		/* It appears that current->mm is not valid if this is called from a
-		 * close routine (perhaps only if the program raised an exception that
-		 * caused it to close?)  If that is the case, then still free the
-		 * partition, but do not remove it from the memory space (dangerous?)
-		 */
+			/* It appears that current->mm is not valid if this is called from a
+			 * close routine (perhaps only if the program raised an exception that
+			 * caused it to close?)  If that is the case, then still free the 
+			 * partition, but do not remove it from the memory space (dangerous?)
+			 */
 
 			if (mm == NULL) {
 #ifdef SHW_DEBUG
@@ -1594,8 +1642,8 @@ fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t *user_ctx)
 				     "partition from user memory\n");
 #endif
 			} else {
-			/* Unmap the memory region (see sys_munmap in mmap.c) */
-			/* Note that this assumes a single memory partition */
+				/* Unmap the memory region (see sys_munmap in mmap.c) */
+				/* Note that this assumes a single memory partition */
 				unmap_user_memory(partition->user_base, 8192);
 			}
 
@@ -1616,17 +1664,19 @@ fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t *user_ctx)
 			}
 		}
 	}
-out:
+      out:
 #endif				/* FSL_HAVE_SCC2 */
 
 	SHW_REMOVE_USER(user_ctx);
 
 	return ret;
 }
-EXPORT_SYMBOL(fsl_shw_deregister_user);
 
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_get_results);
+#endif
 /* REQ-S2LRD-PINTFC-API-GEN-006 */
-fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t *user_ctx,
+fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t * user_ctx,
 				     unsigned result_size,
 				     fsl_shw_result_t results[],
 				     unsigned *result_count)
@@ -1677,9 +1727,11 @@ fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t *user_ctx,
 
 	return FSL_RETURN_OK_S;
 }
-EXPORT_SYMBOL(fsl_shw_get_results);
 
-fsl_shw_pco_t *fsl_shw_get_capabilities(fsl_shw_uco_t *user_ctx)
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_get_capabilities);
+#endif
+fsl_shw_pco_t *fsl_shw_get_capabilities(fsl_shw_uco_t * user_ctx)
 {
 
 	/* Unused */
@@ -1687,11 +1739,13 @@ fsl_shw_pco_t *fsl_shw_get_capabilities(fsl_shw_uco_t *user_ctx)
 
 	return &cap;
 }
-EXPORT_SYMBOL(fsl_shw_get_capabilities);
 
 #if !(defined(FSL_HAVE_SAHARA) || defined(FSL_HAVE_RNGA)                    \
-      || defined(FSL_HAVE_RNGC))
+      || defined(FSL_HAVE_RNGB) || defined(FSL_HAVE_RNGC))
 
+#if defined(LINUX_VERSION_CODE)
+EXPORT_SYMBOL(fsl_shw_get_random);
+#endif
 fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx,
 				    uint32_t length, uint8_t * data)
 {
@@ -1703,10 +1757,12 @@ fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx,
 
 	return FSL_RETURN_ERROR_S;
 }
-EXPORT_SYMBOL(fsl_shw_get_random);
 
-fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t *user_ctx,
-				     uint32_t length, uint8_t *data)
+#if defined(LINUX_VERSION_CODE)
+EXPORT_SYMBOL(fsl_shw_add_entropy);
+#endif
+fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx,
+				     uint32_t length, uint8_t * data)
 {
 
 	/* Unused */
@@ -1716,17 +1772,18 @@ fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t *user_ctx,
 
 	return FSL_RETURN_ERROR_S;
 }
-EXPORT_SYMBOL(fsl_shw_add_entropy);
-
 #endif
 
-#ifndef FSL_HAVE_SAHARA
-
-fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t *user_ctx,
-					   fsl_shw_sko_t *key_info,
-					   fsl_shw_scco_t *sym_ctx,
+#if !defined(FSL_HAVE_DRYICE) && !defined(FSL_HAVE_SAHARA2)
+#if 0
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_symmetric_decrypt);
+#endif
+fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t * user_ctx,
+					   fsl_shw_sko_t * key_info,
+					   fsl_shw_scco_t * sym_ctx,
 					   uint32_t length,
-					   const uint8_t *ct, uint8_t *pt)
+					   const uint8_t * ct, uint8_t * pt)
 {
 
 	/* Unused */
@@ -1740,13 +1797,14 @@ fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t *user_ctx,
 	return FSL_RETURN_ERROR_S;
 }
 
-EXPORT_SYMBOL(fsl_shw_symmetric_decrypt);
-
-fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t *user_ctx,
-					   fsl_shw_sko_t *key_info,
-					   fsl_shw_scco_t *sym_ctx,
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_symmetric_encrypt);
+#endif
+fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
+					   fsl_shw_sko_t * key_info,
+					   fsl_shw_scco_t * sym_ctx,
 					   uint32_t length,
-					   const uint8_t *pt, uint8_t *ct)
+					   const uint8_t * pt, uint8_t * ct)
 {
 
 	/* Unused */
@@ -1759,12 +1817,16 @@ fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t *user_ctx,
 
 	return FSL_RETURN_ERROR_S;
 }
-EXPORT_SYMBOL(fsl_shw_symmetric_encrypt);
 
-fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t *user_ctx,
-				       fsl_shw_sko_t *key_info,
+/* DryIce support provided in separate file */
+
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_establish_key);
+#endif
+fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
+				       fsl_shw_sko_t * key_info,
 				       fsl_shw_key_wrap_t establish_type,
-				       const uint8_t *key)
+				       const uint8_t * key)
 {
 
 	/* Unused */
@@ -1775,11 +1837,13 @@ fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t *user_ctx,
 
 	return FSL_RETURN_ERROR_S;
 }
-EXPORT_SYMBOL(fsl_shw_establish_key);
 
-fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t *user_ctx,
-				     fsl_shw_sko_t *key_info,
-				     uint8_t *covered_key)
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_extract_key);
+#endif
+fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info,
+				     uint8_t * covered_key)
 {
 
 	/* Unused */
@@ -1789,10 +1853,12 @@ fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t *user_ctx,
 
 	return FSL_RETURN_ERROR_S;
 }
-EXPORT_SYMBOL(fsl_shw_extract_key);
 
-fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t *user_ctx,
-				     fsl_shw_sko_t *key_info)
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_release_key);
+#endif
+fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info)
 {
 
 	/* Unused */
@@ -1801,16 +1867,18 @@ fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t *user_ctx,
 
 	return FSL_RETURN_ERROR_S;
 }
-EXPORT_SYMBOL(fsl_shw_release_key);
-
 #endif
+#endif				/* SAHARA or DRYICE */
 
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_hash);
+#endif
 #if !defined(FSL_HAVE_SAHARA)
-fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t *user_ctx,
-			      fsl_shw_hco_t *hash_ctx,
-			      const uint8_t *msg,
+fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t * user_ctx,
+			      fsl_shw_hco_t * hash_ctx,
+			      const uint8_t * msg,
 			      uint32_t length,
-			      uint8_t *result, uint32_t result_len)
+			      uint8_t * result, uint32_t result_len)
 {
 	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
 
@@ -1824,16 +1892,16 @@ fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t *user_ctx,
 
 	return ret;
 }
-EXPORT_SYMBOL(fsl_shw_hash);
-
 #endif
 
 #ifndef FSL_HAVE_SAHARA
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_hmac_precompute);
+#endif
 
-
-fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t *user_ctx,
-					 fsl_shw_sko_t *key_info,
-					 fsl_shw_hmco_t *hmac_ctx)
+fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t * user_ctx,
+					 fsl_shw_sko_t * key_info,
+					 fsl_shw_hmco_t * hmac_ctx)
 {
 	fsl_shw_return_t status = FSL_RETURN_ERROR_S;
 
@@ -1845,14 +1913,16 @@ fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t *user_ctx,
 	return status;
 }
 
-EXPORT_SYMBOL(fsl_shw_hmac_precompute);
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_hmac);
+#endif
 
-fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t *user_ctx,
-			      fsl_shw_sko_t *key_info,
-			      fsl_shw_hmco_t *hmac_ctx,
-			      const uint8_t *msg,
+fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t * user_ctx,
+			      fsl_shw_sko_t * key_info,
+			      fsl_shw_hmco_t * hmac_ctx,
+			      const uint8_t * msg,
 			      uint32_t length,
-			      uint8_t *result, uint32_t result_len)
+			      uint8_t * result, uint32_t result_len)
 {
 	fsl_shw_return_t status = FSL_RETURN_ERROR_S;
 
@@ -1867,15 +1937,12 @@ fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t *user_ctx,
 
 	return status;
 }
-
-EXPORT_SYMBOL(fsl_shw_hmac);
-
 #endif
 
-/**
+/*!
  * Call the proper function to encrypt a region of encrypted secure memory
  *
- * @brief
+ * @brief 
  *
  * @param   user_ctx        User context of the partition owner (NULL in kernel)
  * @param   partition_base  Base address (physical) of the partition
@@ -1889,10 +1956,10 @@ EXPORT_SYMBOL(fsl_shw_hmac);
  * @return  status
  */
 fsl_shw_return_t
-do_scc_encrypt_region(fsl_shw_uco_t *user_ctx,
+do_scc_encrypt_region(fsl_shw_uco_t * user_ctx,
 		      void *partition_base, uint32_t offset_bytes,
-		      uint32_t byte_count, uint8_t *black_data,
-		      uint32_t *IV, fsl_shw_cypher_mode_t cypher_mode)
+		      uint32_t byte_count, uint8_t * black_data,
+		      uint32_t * IV, fsl_shw_cypher_mode_t cypher_mode)
 {
 	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
 #ifdef FSL_HAVE_SCC2
@@ -1900,7 +1967,7 @@ do_scc_encrypt_region(fsl_shw_uco_t *user_ctx,
 	scc_return_t scc_ret;
 
 #ifdef SHW_DEBUG
-	uint32_t *owner_32 = (uint32_t *) &(owner_id);
+	uint32_t *owner_32 = (uint32_t *) & (owner_id);
 
 	LOG_KDIAG_ARGS
 	    ("partition base: %p, offset: %i, count: %i, black data: %p\n",
@@ -1917,26 +1984,26 @@ do_scc_encrypt_region(fsl_shw_uco_t *user_ctx,
 			       byte_count, __virt_to_phys(black_data), IV,
 			       cypher_mode);
 
-	if (scc_ret == SCC_RET_OK)
+	if (scc_ret == SCC_RET_OK) {
 		retval = FSL_RETURN_OK_S;
-	else
+	} else {
 		retval = FSL_RETURN_ERROR_S;
+	}
 
-	/* The SCC2 DMA engine should have written to the black ram,
-	 * so we need to invalidate that region of memory.  Note that the
-	 * red ram is not an because it is mapped with the cache disabled.
+	/* The SCC2 DMA engine should have written to the black ram, so we need to
+	 * invalidate that region of memory.  Note that the red ram is not an
+	 * because it is mapped with the cache disabled.
 	 */
 	os_cache_inv_range(black_data, byte_count);
 
 #endif				/* FSL_HAVE_SCC2 */
 	return retval;
 }
-EXPORT_SYMBOL(do_scc_encrypt_region);
 
-/**
+/*!
  * Call the proper function to decrypt a region of encrypted secure memory
  *
- * @brief
+ * @brief 
  *
  * @param   user_ctx        User context of the partition owner (NULL in kernel)
  * @param   partition_base  Base address (physical) of the partition
@@ -1951,10 +2018,10 @@ EXPORT_SYMBOL(do_scc_encrypt_region);
  * @return  status
  */
 fsl_shw_return_t
-do_scc_decrypt_region(fsl_shw_uco_t *user_ctx,
+do_scc_decrypt_region(fsl_shw_uco_t * user_ctx,
 		      void *partition_base, uint32_t offset_bytes,
-		      uint32_t byte_count, const uint8_t *black_data,
-		      uint32_t *IV, fsl_shw_cypher_mode_t cypher_mode)
+		      uint32_t byte_count, const uint8_t * black_data,
+		      uint32_t * IV, fsl_shw_cypher_mode_t cypher_mode)
 {
 	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
 
@@ -1963,7 +2030,7 @@ do_scc_decrypt_region(fsl_shw_uco_t *user_ctx,
 	scc_return_t scc_ret;
 
 #ifdef SHW_DEBUG
-	uint32_t *owner_32 = (uint32_t *) &(owner_id);
+	uint32_t *owner_32 = (uint32_t *) & (owner_id);
 
 	LOG_KDIAG_ARGS
 	    ("partition base: %p, offset: %i, count: %i, black data: %p\n",
@@ -1986,19 +2053,19 @@ do_scc_decrypt_region(fsl_shw_uco_t *user_ctx,
 			       (uint8_t *) __virt_to_phys(black_data), IV,
 			       cypher_mode);
 
-	if (scc_ret == SCC_RET_OK)
+	if (scc_ret == SCC_RET_OK) {
 		retval = FSL_RETURN_OK_S;
-	else
+	} else {
 		retval = FSL_RETURN_ERROR_S;
+	}
 
 #endif				/* FSL_HAVE_SCC2 */
 
 	return retval;
 }
-EXPORT_SYMBOL(do_scc_decrypt_region);
 
-void *fsl_shw_smalloc(fsl_shw_uco_t *user_ctx,
-		      uint32_t size, const uint8_t *UMID, uint32_t permissions)
+void *fsl_shw_smalloc(fsl_shw_uco_t * user_ctx,
+		      uint32_t size, const uint8_t * UMID, uint32_t permissions)
 {
 #ifdef FSL_HAVE_SCC2
 	int part_no;
@@ -2008,22 +2075,23 @@ void *fsl_shw_smalloc(fsl_shw_uco_t *user_ctx,
 
 	/* Check that the memory size requested is correct */
 	scc_configuration = scc_get_configuration();
-	if (size != scc_configuration->partition_size_bytes)
+	if (size != scc_configuration->partition_size_bytes) {
 		return NULL;
+	}
 
 	/* attempt to grab a partition. */
 	if (scc_allocate_partition(0, &part_no, &part_base, &part_phys)
-	    != SCC_RET_OK)
+	    != SCC_RET_OK) {
 		return NULL;
-
+	}
 #ifdef SHW_DEBUG
-	LOG_KDIAG_ARGS("Partition_base:%p, partition_base_phys: %p\n",
+	LOG_KDIAG_ARGS("Partition_base: %p, partition_base_phys: %p\n",
 		       part_base, (void *)part_phys);
 #endif
 
 	if (scc_engage_partition(part_base, UMID, permissions)
 	    != SCC_RET_OK) {
-/* Engagement failed, so the partition needs to be de-allocated */
+		/* Engagement failed, so the partition needs to be de-allocated */
 
 #ifdef SHW_DEBUG
 		LOG_KDIAG_ARGS("Failed to engage partition %p, de-allocating",
@@ -2046,10 +2114,9 @@ void *fsl_shw_smalloc(fsl_shw_uco_t *user_ctx,
 
 #endif				/* FSL_HAVE_SCC2 */
 }
-EXPORT_SYMBOL(fsl_shw_smalloc);
 
 /* Release a block of secure memory */
-fsl_shw_return_t fsl_shw_sfree(fsl_shw_uco_t *user_ctx, void *address)
+fsl_shw_return_t fsl_shw_sfree(fsl_shw_uco_t * user_ctx, void *address)
 {
 	(void)user_ctx;
 
@@ -2061,12 +2128,11 @@ fsl_shw_return_t fsl_shw_sfree(fsl_shw_uco_t *user_ctx, void *address)
 
 	return FSL_RETURN_ERROR_S;
 }
-EXPORT_SYMBOL(fsl_shw_sfree);
 
 /* Check the status of a block of secure memory */
-fsl_shw_return_t fsl_shw_sstatus(fsl_shw_uco_t *user_ctx,
+fsl_shw_return_t fsl_shw_sstatus(fsl_shw_uco_t * user_ctx,
 				 void *address,
-				 fsl_shw_partition_status_t *part_status)
+				 fsl_shw_partition_status_t * part_status)
 {
 	(void)user_ctx;
 
@@ -2078,34 +2144,36 @@ fsl_shw_return_t fsl_shw_sstatus(fsl_shw_uco_t *user_ctx,
 
 	return FSL_RETURN_ERROR_S;
 }
-EXPORT_SYMBOL(fsl_shw_sstatus);
 
 /* Diminish permissions on some secure memory */
-fsl_shw_return_t fsl_shw_diminish_perms(fsl_shw_uco_t *user_ctx,
+fsl_shw_return_t fsl_shw_diminish_perms(fsl_shw_uco_t * user_ctx,
 					void *address, uint32_t permissions)
 {
 
 	(void)user_ctx;		/* unused parameter warning */
 
 #ifdef FSL_HAVE_SCC2
-	if (scc_diminish_permissions(address, permissions) == SCC_RET_OK)
+	if (scc_diminish_permissions(address, permissions) == SCC_RET_OK) {
 		return FSL_RETURN_OK_S;
+	}
 #endif
 	return FSL_RETURN_ERROR_S;
 }
-EXPORT_SYMBOL(fsl_shw_diminish_perms);
 
 #ifndef FSL_HAVE_SAHARA
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_gen_encrypt);
+#endif
 
-fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t *user_ctx,
-				     fsl_shw_acco_t *auth_ctx,
-				     fsl_shw_sko_t *cipher_key_info,
-				     fsl_shw_sko_t *auth_key_info,
+fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_acco_t * auth_ctx,
+				     fsl_shw_sko_t * cipher_key_info,
+				     fsl_shw_sko_t * auth_key_info,
 				     uint32_t auth_data_length,
-				     const uint8_t *auth_data,
+				     const uint8_t * auth_data,
 				     uint32_t payload_length,
-				     const uint8_t *payload,
-				     uint8_t *ct, uint8_t *auth_value)
+				     const uint8_t * payload,
+				     uint8_t * ct, uint8_t * auth_value)
 {
 	volatile fsl_shw_return_t status = FSL_RETURN_ERROR_S;
 
@@ -2124,10 +2192,10 @@ fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t *user_ctx,
 	return status;
 }
 
-EXPORT_SYMBOL(fsl_shw_gen_encrypt);
-
-
-/**
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_auth_decrypt);
+#endif
+/*!
  * @brief Authenticate and decrypt a (CCM) stream.
  *
  * @param user_ctx         The user's context
@@ -2143,15 +2211,15 @@ EXPORT_SYMBOL(fsl_shw_gen_encrypt);
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t *user_ctx,
-				      fsl_shw_acco_t *auth_ctx,
-				      fsl_shw_sko_t *cipher_key_info,
-				      fsl_shw_sko_t *auth_key_info,
+fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
+				      fsl_shw_acco_t * auth_ctx,
+				      fsl_shw_sko_t * cipher_key_info,
+				      fsl_shw_sko_t * auth_key_info,
 				      uint32_t auth_data_length,
-				      const uint8_t *auth_data,
+				      const uint8_t * auth_data,
 				      uint32_t payload_length,
-				      const uint8_t *ct,
-				      const uint8_t *auth_value,
+				      const uint8_t * ct,
+				      const uint8_t * auth_value,
 				      uint8_t * payload)
 {
 	volatile fsl_shw_return_t status = FSL_RETURN_ERROR_S;
@@ -2171,6 +2239,97 @@ fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t *user_ctx,
 	return status;
 }
 
-EXPORT_SYMBOL(fsl_shw_auth_decrypt);
+#endif				/* no SAHARA */
 
+#ifndef FSL_HAVE_DRYICE
+
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_gen_random_pf_key);
 #endif
+/*!
+ * Cause the hardware to create a new random key for secure memory use.
+ *
+ * Have the hardware use the secure hardware random number generator to load a
+ * new secret key into the hardware random key register.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_gen_random_pf_key(fsl_shw_uco_t * user_ctx)
+{
+	volatile fsl_shw_return_t status = FSL_RETURN_ERROR_S;
+
+	return status;
+}
+
+#endif				/* not have DRYICE */ 
+
+fsl_shw_return_t alloc_slot(fsl_shw_uco_t * user_ctx, fsl_shw_sko_t * key_info)
+{
+	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
+
+	if (key_info->keystore == NULL) {
+		/* Key goes in system keystore */
+		ret = do_system_keystore_slot_alloc(user_ctx,
+						    key_info->key_length,
+						    key_info->userid,
+						    &(key_info->handle));
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("key length: %i, handle: %i",
+			      key_info->key_length, key_info->handle);
+#endif
+
+	} else {
+		/* Key goes in user keystore */
+		ret = keystore_slot_alloc(key_info->keystore,
+					  key_info->key_length,
+					  key_info->userid,
+					  &(key_info->handle));
+	}
+
+	return ret;
+}				/* end fn alloc_slot */
+
+fsl_shw_return_t load_slot(fsl_shw_uco_t * user_ctx,
+			   fsl_shw_sko_t * key_info, const uint8_t * key)
+{
+	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
+
+	if (key_info->keystore == NULL) {
+		/* Key goes in system keystore */
+		ret = do_system_keystore_slot_load(user_ctx,
+						   key_info->userid,
+						   key_info->handle, key,
+						   key_info->key_length);
+	} else {
+		/* Key goes in user keystore */
+		ret = keystore_slot_load(key_info->keystore,
+					 key_info->userid,
+					 key_info->handle, key,
+					 key_info->key_length);
+	}
+
+	return ret;
+}				/* end fn load_slot */
+
+fsl_shw_return_t dealloc_slot(fsl_shw_uco_t * user_ctx,
+			      fsl_shw_sko_t * key_info)
+{
+	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
+
+	if (key_info->keystore == NULL) {
+		/* Key goes in system keystore */
+		do_system_keystore_slot_dealloc(user_ctx,
+						key_info->userid,
+						key_info->handle);
+	} else {
+		/* Key goes in user keystore */
+		keystore_slot_dealloc(key_info->keystore,
+				      key_info->userid, key_info->handle);
+	}
+
+	key_info->flags &= ~(FSL_SKO_KEY_ESTABLISHED | FSL_SKO_KEY_PRESENT);
+
+	return ret;
+}				/* end fn slot_dealloc */
diff --git a/drivers/mxc/security/rng/shw_dryice.c b/drivers/mxc/security/rng/shw_dryice.c
new file mode 100644
index 0000000..7175695
--- /dev/null
+++ b/drivers/mxc/security/rng/shw_dryice.c
@@ -0,0 +1,204 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include "shw_driver.h"
+#include <../dryice.h>
+
+#include <diagnostic.h>
+
+#ifdef FSL_HAVE_DRYICE
+
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_gen_random_pf_key);
+#endif
+/*!
+ * Cause the hardware to create a new random key for secure memory use.
+ *
+ * Have the hardware use the secure hardware random number generator to load a
+ * new secret key into the hardware random key register.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+fsl_shw_return_t fsl_shw_gen_random_pf_key(fsl_shw_uco_t * user_ctx)
+{
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+	di_return_t di_ret;
+
+	/* For now, only blocking mode calls are supported */
+	if (!(user_ctx->flags & FSL_UCO_BLOCKING_MODE)) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	di_ret = dryice_set_random_key(0);
+	if (di_ret != DI_SUCCESS) {
+		printk("dryice_set_random_key returned %d\n", di_ret);
+		goto out;
+	}
+
+	ret = FSL_RETURN_OK_S;
+
+      out:
+	return ret;
+}
+
+#ifdef LINUX_VERSION_CODE
+EXPORT_SYMBOL(fsl_shw_read_tamper_event);
+#endif
+fsl_shw_return_t fsl_shw_read_tamper_event(fsl_shw_uco_t * user_ctx,
+					   fsl_shw_tamper_t * tamperp,
+					   uint64_t * timestampp)
+{
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+	di_return_t di_ret;
+	uint32_t di_events = 0;
+	uint32_t di_time_stamp;
+
+	/* Only blocking mode calls are supported */
+	if (!(user_ctx->flags & FSL_UCO_BLOCKING_MODE)) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	di_ret = dryice_get_tamper_event(&di_events, &di_time_stamp, 0);
+	if ((di_ret != DI_SUCCESS) && (di_ret != DI_ERR_STATE)) {
+#ifdef DIAG_SECURITY_FUNC
+		LOG_DIAG_ARGS("dryice_get_tamper_event returned %s\n",
+			      di_error_string(di_ret));
+#endif
+		goto out;
+	}
+
+	/* Pass time back to caller */
+	*timestampp = (uint64_t) di_time_stamp;
+
+	if (di_events & DI_TAMPER_EVENT_WTD) {
+		*tamperp = FSL_SHW_TAMPER_WTD;
+	} else if (di_events & DI_TAMPER_EVENT_ETBD) {
+		*tamperp = FSL_SHW_TAMPER_ETBD;
+	} else if (di_events & DI_TAMPER_EVENT_ETAD) {
+		*tamperp = FSL_SHW_TAMPER_ETAD;
+	} else if (di_events & DI_TAMPER_EVENT_EBD) {
+		*tamperp = FSL_SHW_TAMPER_EBD;
+	} else if (di_events & DI_TAMPER_EVENT_SAD) {
+		*tamperp = FSL_SHW_TAMPER_SAD;
+	} else if (di_events & DI_TAMPER_EVENT_TTD) {
+		*tamperp = FSL_SHW_TAMPER_TTD;
+	} else if (di_events & DI_TAMPER_EVENT_CTD) {
+		*tamperp = FSL_SHW_TAMPER_CTD;
+	} else if (di_events & DI_TAMPER_EVENT_VTD) {
+		*tamperp = FSL_SHW_TAMPER_VTD;
+	} else if (di_events & DI_TAMPER_EVENT_MCO) {
+		*tamperp = FSL_SHW_TAMPER_MCO;
+	} else if (di_events & DI_TAMPER_EVENT_TCO) {
+		*tamperp = FSL_SHW_TAMPER_TCO;
+	} else if (di_events != 0) {
+		/* Apparentliy a tamper type not known to this driver was detected */
+		goto out;
+	} else {
+		*tamperp = FSL_SHW_TAMPER_NONE;
+	}
+
+	ret = FSL_RETURN_OK_S;
+
+      out:
+	return ret;
+}				/* end fn fsl_shw_read_tamper_event */
+#endif
+/*!
+ * Convert an SHW HW key reference into a DI driver key reference
+ *
+ * @param shw_pf_key   An SHW HW key value
+ * @param di_keyp      Location to store the equivalent DI driver key
+ *
+ * @return FSL_RETURN_OK_S, or error if key is unknown or cannot translate.
+ */
+fsl_shw_return_t shw_convert_pf_key(fsl_shw_pf_key_t shw_pf_key,
+				    di_key_t * di_keyp)
+{
+	fsl_shw_return_t ret = FSL_RETURN_BAD_FLAG_S;
+
+	switch (shw_pf_key) {
+	case FSL_SHW_PF_KEY_IIM:
+		*di_keyp = DI_KEY_FK;
+		break;
+	case FSL_SHW_PF_KEY_RND:
+		*di_keyp = DI_KEY_RK;
+		break;
+	case FSL_SHW_PF_KEY_IIM_RND:
+		*di_keyp = DI_KEY_FRK;
+		break;
+	case FSL_SHW_PF_KEY_PRG:
+		*di_keyp = DI_KEY_PK;
+		break;
+	case FSL_SHW_PF_KEY_IIM_PRG:
+		*di_keyp = DI_KEY_FPK;
+		break;
+	default:
+		goto out;
+	}
+
+	ret = FSL_RETURN_OK_S;
+
+      out:
+	return ret;
+}
+
+#ifdef DIAG_SECURITY_FUNC
+const char *di_error_string(int code)
+{
+	char *str = "unknown";
+
+	switch (code) {
+	case DI_SUCCESS:
+		str = "operation was successful";
+		break;
+	case DI_ERR_BUSY:
+		str = "device or resource busy";
+		break;
+	case DI_ERR_STATE:
+		str = "dryice is in incompatible state";
+		break;
+	case DI_ERR_INUSE:
+		str = "resource is already in use";
+		break;
+	case DI_ERR_UNSET:
+		str = "resource has not been initialized";
+		break;
+	case DI_ERR_WRITE:
+		str = "error occurred during register write";
+		break;
+	case DI_ERR_INVAL:
+		str = "invalid argument";
+		break;
+	case DI_ERR_FAIL:
+		str = "operation failed";
+		break;
+	case DI_ERR_HLOCK:
+		str = "resource is hard locked";
+		break;
+	case DI_ERR_SLOCK:
+		str = "resource is soft locked";
+		break;
+	case DI_ERR_NOMEM:
+		str = "out of memory";
+		break;
+	default:
+		break;
+	}
+
+	return str;
+}
+#endif				/* HAVE DRYICE */
diff --git a/drivers/mxc/security/rng/shw_hash.c b/drivers/mxc/security/rng/shw_hash.c
new file mode 100644
index 0000000..ad9e7f3
--- /dev/null
+++ b/drivers/mxc/security/rng/shw_hash.c
@@ -0,0 +1,328 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file shw_hash.c
+ *
+ * This file contains implementations for use of the (internal) SHW hash
+ * software computation.  It defines the usual three steps:
+ *
+ * - #shw_hash_init()
+ * - #shw_hash_update()
+ * - #shw_hash_final()
+ *
+ * In support of the above functions, it also contains these functions:
+ * - #sha256_init()
+ * - #sha256_process_block()
+ *
+ *
+ * These functions depend upon the Linux Endian functions __be32_to_cpu(),
+ * __cpu_to_be32() to convert a 4-byte big-endian array to an integer and
+ * vice-versa.  For those without Linux, it should be pretty obvious what they
+ * do.
+ *
+ * The #shw_hash_update() and #shw_hash_final() functions are generic enough to
+ * support SHA-1/SHA-224/SHA-256, as needed.  Some extra tweaking would be
+ * necessary to get them to support SHA-384/SHA-512.
+ * 
+ */
+
+#include "shw_driver.h"
+#include "shw_hash.h"
+
+#ifndef __KERNEL__
+#include <asm/types.h>
+#include <linux/byteorder/little_endian.h>	/* or whichever is proper for target arch */
+#define printk printf
+#endif
+
+/*!
+ * Rotate a value right by a number of bits.
+ *
+ * @param x   Word of data which needs rotating
+ * @param y   Number of bits to rotate
+ *
+ * @return The new value
+ */
+inline uint32_t rotr32fixed(uint32_t x, unsigned int y)
+{
+	return (uint32_t) ((x >> y) | (x << (32 - y)));
+}
+
+#define blk0(i) (W[i] = data[i])
+// Referencing parameters so many times is really poor practice.  Do not imitate these macros
+#define blk2(i) (W[i & 15] += s1(W[(i - 2) & 15]) + W[(i - 7) & 15] + s0(W[(i - 15) & 15]))
+
+#define Ch(x,y,z) (z ^ (x & (y ^ z)))
+#define Maj(x,y,z) ((x & y) | (z & (x | y)))
+
+#define a(i) T[(0 - i) & 7]
+#define b(i) T[(1 - i) & 7]
+#define c(i) T[(2 - i) & 7]
+#define d(i) T[(3 - i) & 7]
+#define e(i) T[(4 - i) & 7]
+#define f(i) T[(5 - i) & 7]
+#define g(i) T[(6 - i) & 7]
+#define h(i) T[(7 - i) & 7]
+
+// This is a bad way to write a multi-statement macro... and referencing 'i' so many
+// times is really poor practice.  Do not imitate.
+#define R(i) h(i) += S1( e(i)) + Ch(e(i), f(i), g(i)) + K[i + j] +(j ? blk2(i) : blk0(i));\
+        d(i) += h(i);h(i) += S0(a(i)) + Maj(a(i), b(i), c(i))
+
+// for SHA256
+#define S0(x) (rotr32fixed(x, 2) ^ rotr32fixed(x, 13) ^ rotr32fixed(x, 22))
+#define S1(x) (rotr32fixed(x, 6) ^ rotr32fixed(x, 11) ^ rotr32fixed(x, 25))
+#define s0(x) (rotr32fixed(x, 7) ^ rotr32fixed(x, 18) ^ (x >> 3))
+#define s1(x) (rotr32fixed(x, 17) ^ rotr32fixed(x, 19) ^ (x >> 10))
+
+/*!
+ * Initialize the Hash State
+ *
+ *  Constructs the SHA256 hash engine.
+ *  Specification:
+ *      State Size  = 32 bytes
+ *      Block Size  = 64 bytes
+ *      Digest Size = 32 bytes
+ *
+ * @param state     Address of hash state structure
+ *
+ */
+void sha256_init(shw_hash_state_t * state)
+{
+	state->bit_count = 0;
+	state->partial_count_bytes = 0;
+
+	state->state[0] = 0x6a09e667;
+	state->state[1] = 0xbb67ae85;
+	state->state[2] = 0x3c6ef372;
+	state->state[3] = 0xa54ff53a;
+	state->state[4] = 0x510e527f;
+	state->state[5] = 0x9b05688c;
+	state->state[6] = 0x1f83d9ab;
+	state->state[7] = 0x5be0cd19;
+}
+
+const uint32_t K[64] = {
+	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
+	0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
+	0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
+	0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
+	0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
+	0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
+	0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
+	0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
+	0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+};
+
+/*!
+ * Hash a block of data into the SHA-256 hash state.
+ *
+ * This function hash the block of data in the @c partial_block
+ * element of the state structure into the state variables of the
+ * state structure.
+ *
+ * @param state     Address of hash state structure
+ *
+ */
+static void sha256_process_block(shw_hash_state_t * state)
+{
+	uint32_t W[16];
+	uint32_t T[8];
+	uint32_t stack_buffer[SHW_HASH_BLOCK_WORD_SIZE];
+	uint32_t *data = &stack_buffer[0];
+	uint8_t *input = state->partial_block;
+	unsigned int i;
+	unsigned int j;
+
+	/* Copy byte-oriented input block into word-oriented registers */
+	for (i = 0; i < SHW_HASH_BLOCK_LEN / sizeof(uint32_t);
+	     i++, input += sizeof(uint32_t)) {
+		stack_buffer[i] = __be32_to_cpu(*(uint32_t *) input);
+	}
+
+	/* Copy context->state[] to working vars */
+	memcpy(T, state->state, sizeof(T));
+
+	/* 64 operations, partially loop unrolled */
+	for (j = 0; j < SHW_HASH_BLOCK_LEN; j += 16) {
+		R(0);
+		R(1);
+		R(2);
+		R(3);
+		R(4);
+		R(5);
+		R(6);
+		R(7);
+		R(8);
+		R(9);
+		R(10);
+		R(11);
+		R(12);
+		R(13);
+		R(14);
+		R(15);
+	}
+	/* Add the working vars back into context.state[] */
+	state->state[0] += a(0);
+	state->state[1] += b(0);
+	state->state[2] += c(0);
+	state->state[3] += d(0);
+	state->state[4] += e(0);
+	state->state[5] += f(0);
+	state->state[6] += g(0);
+	state->state[7] += h(0);
+
+	/* Wipe variables */
+	memset(W, 0, sizeof(W));
+	memset(T, 0, sizeof(T));
+}
+
+/*!
+ * Initialize the hash state structure
+ *
+ * @param state     Address of hash state structure.
+ * @param alg Which hash algorithm to use (must be FSL_HASH_ALG_SHA1)
+ *
+ * @return  FSL_RETURN_OK_S if all went well, otherwise an error code.
+ */
+fsl_shw_return_t shw_hash_init(shw_hash_state_t * state, fsl_shw_hash_alg_t alg)
+{
+	if (alg != FSL_HASH_ALG_SHA256) {
+		return FSL_RETURN_BAD_ALGORITHM_S;
+	}
+
+	sha256_init(state);
+
+	return FSL_RETURN_OK_S;
+}
+
+/*!
+ * Add input bytes to the hash 
+ *
+ * The bytes are added to the partial_block element of the hash state, and as
+ * the partial block is filled, it is processed by sha1_process_block().  This
+ * function also updates the bit_count element of the hash state.
+ *
+ * @param state     Address of hash state structure
+ * @param input     Address of bytes to add to the hash
+ * @param input_len Numbef of bytes at @c input
+ *
+ */
+fsl_shw_return_t shw_hash_update(shw_hash_state_t * state,
+				 const uint8_t * input, unsigned int input_len)
+{
+	unsigned int bytes_needed;	/* Needed to fill a block */
+	unsigned int bytes_to_copy;	/* to copy into the block */
+
+	/* Account for new data */
+	state->bit_count += 8 * input_len;
+
+	/*
+	 * Process input bytes into the ongoing block; process the block when it
+	 * gets full.
+	 */
+	while (input_len > 0) {
+		bytes_needed = SHW_HASH_BLOCK_LEN - state->partial_count_bytes;
+		bytes_to_copy = ((input_len < bytes_needed) ?
+				 input_len : bytes_needed);
+
+		/* Add in the bytes and do the accounting */
+		memcpy(state->partial_block + state->partial_count_bytes,
+		       input, bytes_to_copy);
+		input += bytes_to_copy;
+		input_len -= bytes_to_copy;
+		state->partial_count_bytes += bytes_to_copy;
+
+		/* Run a full block through the transform */
+		if (state->partial_count_bytes == SHW_HASH_BLOCK_LEN) {
+			sha256_process_block(state);
+			state->partial_count_bytes = 0;
+		}
+	}
+
+	return FSL_RETURN_OK_S;
+}				/* end fn shw_hash_update */
+
+/*!
+ * Finalize the hash
+ *
+ * Performs the finalize operation on the previous input data & returns the
+ * resulting digest.  The finalize operation performs the appropriate padding
+ * up to the block size.
+ *
+ * @param state     Address of hash state structure
+ * @param result    Location to store the hash result
+ * @param result_len Number of bytes of @c result to be stored.
+ *
+ * @return FSL_RETURN_OK_S if all went well, FSL_RETURN_BAD_DATA_LENGTH_S if
+ * hash_len is too long, otherwise an error code.
+ */
+fsl_shw_return_t shw_hash_final(shw_hash_state_t * state, uint8_t * result,
+				unsigned int result_len)
+{
+	static const uint8_t pad[SHW_HASH_BLOCK_LEN * 2] = {
+		0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+	};
+
+	uint8_t data[sizeof(state->bit_count)];
+	uint32_t pad_length;
+	uint64_t bit_count = state->bit_count;
+	uint8_t hash[SHW_HASH_LEN];
+	int i;
+
+	if (result_len > SHW_HASH_LEN) {
+		return FSL_RETURN_BAD_DATA_LENGTH_S;
+	}
+
+	/* Save the length before padding. */
+	for (i = sizeof(state->bit_count) - 1; i >= 0; i--) {
+		data[i] = bit_count & 0xFF;
+		bit_count >>= 8;
+	}
+	pad_length = ((state->partial_count_bytes < 56) ?
+		      (56 - state->partial_count_bytes) :
+		      (120 - state->partial_count_bytes));
+
+	/* Pad to 56 bytes mod 64 (BLOCK_SIZE). */
+	shw_hash_update(state, pad, pad_length);
+
+	/*
+	 * Append the length.  This should trigger transform of the final block.
+	 */
+	shw_hash_update(state, data, sizeof(state->bit_count));
+
+	/* Copy the result into a byte array */
+	for (i = 0; i < SHW_HASH_STATE_WORDS; i++) {
+		*(uint32_t *) (hash + 4 * i) = __cpu_to_be32(state->state[i]);
+	}
+
+	/* And copy the result out to caller */
+	memcpy(result, hash, result_len);
+
+	return FSL_RETURN_OK_S;
+}				/* end fn shw_hash_final */
diff --git a/drivers/mxc/security/rng/shw_hmac.c b/drivers/mxc/security/rng/shw_hmac.c
new file mode 100644
index 0000000..0e87282
--- /dev/null
+++ b/drivers/mxc/security/rng/shw_hmac.c
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file shw_hmac.c
+ *
+ * This file contains implementations for use of the (internal) SHW HMAC
+ * software computation.  It defines the usual three steps:
+ *
+ * - #shw_hmac_init()
+ * - #shw_hmac_update()
+ * - #shw_hmac_final()
+ *
+ * 
+ */
+
+#include "shw_driver.h"
+#include "shw_hmac.h"
+
+#ifndef __KERNEL__
+#include <asm/types.h>
+#include <linux/byteorder/little_endian.h>	/* or whichever is proper for target arch */
+#define printk printf
+#endif
+
+/*! XOR value for HMAC inner key */
+#define INNER_HASH_CONSTANT 0x36
+
+/*! XOR value for HMAC outer key */
+#define OUTER_HASH_CONSTANT 0x5C
+
+/*!
+ * Initialize the HMAC state structure with the HMAC key
+ *
+ * @param state     Address of HMAC state structure
+ * @param key       Address of the key to be used for the HMAC.
+ * @param key_len   Number of bytes of @c key.
+ *
+ * Convert the key into its equivalent inner and outer hash state objects.
+ *
+ * @return  FSL_RETURN_OK_S if all went well, otherwise an error code.
+ */
+fsl_shw_return_t shw_hmac_init(shw_hmac_state_t * state,
+			       const uint8_t * key, unsigned int key_len)
+{
+	fsl_shw_return_t code = FSL_RETURN_ERROR_S;
+	uint8_t first_block[SHW_HASH_BLOCK_LEN];
+	unsigned int i;
+
+	/* Don't bother handling the pre-hash. */
+	if (key_len > SHW_HASH_BLOCK_LEN) {
+		code = FSL_RETURN_BAD_KEY_LENGTH_S;
+		goto out;
+	}
+
+	/* Prepare inner hash */
+	for (i = 0; i < SHW_HASH_BLOCK_LEN; i++) {
+		if (i < key_len) {
+			first_block[i] = key[i] ^ INNER_HASH_CONSTANT;
+		} else {
+			first_block[i] = INNER_HASH_CONSTANT;
+		}
+	}
+	code = shw_hash_init(&state->inner_hash, FSL_HASH_ALG_SHA256);
+	if (code != FSL_RETURN_OK_S) {
+		goto out;
+	}
+	shw_hash_update(&state->inner_hash, first_block, SHW_HASH_BLOCK_LEN);
+
+	/* Prepare outer hash */
+	for (i = 0; i < SHW_HASH_BLOCK_LEN; i++) {
+		if (i < key_len) {
+			first_block[i] = key[i] ^ OUTER_HASH_CONSTANT;
+		} else {
+			first_block[i] = OUTER_HASH_CONSTANT;
+		}
+	}
+	code = shw_hash_init(&state->outer_hash, FSL_HASH_ALG_SHA256);
+	if (code != FSL_RETURN_OK_S) {
+		goto out;
+	}
+	shw_hash_update(&state->outer_hash, first_block, SHW_HASH_BLOCK_LEN);
+
+	/* Wipe evidence of key */
+	memset(first_block, 0, SHW_HASH_BLOCK_LEN);
+
+      out:
+	return code;
+}
+
+/*!
+ * Put data into the HMAC calculation
+ *
+ * Send the msg data inner inner hash's update function.
+ *
+ * @param state     Address of HMAC state structure.
+ * @param msg       Address of the message data for the HMAC.
+ * @param msg_len   Number of bytes of @c msg.
+ *
+ * @return  FSL_RETURN_OK_S if all went well, otherwise an error code.
+ */
+fsl_shw_return_t shw_hmac_update(shw_hmac_state_t * state,
+				 const uint8_t * msg, unsigned int msg_len)
+{
+	shw_hash_update(&state->inner_hash, msg, msg_len);
+
+	return FSL_RETURN_OK_S;
+}
+
+/*!
+ * Calculate the final HMAC
+ *
+ * @param state     Address of HMAC state structure.
+ * @param hmac      Address of location to store the HMAC.
+ * @param hmac_len  Number of bytes of @c mac to be stored.  Probably best if
+ *                  this value is no greater than #SHW_HASH_LEN.
+ *
+ * This function finalizes the internal hash, and uses that result as
+ * data for the outer hash.  As many bytes of that result are passed
+ * to the user as desired.
+ *
+ * @return  FSL_RETURN_OK_S if all went well, otherwise an error code.
+ */
+fsl_shw_return_t shw_hmac_final(shw_hmac_state_t * state,
+				uint8_t * hmac, unsigned int hmac_len)
+{
+	uint8_t hash_result[SHW_HASH_LEN];
+
+	shw_hash_final(&state->inner_hash, hash_result, sizeof(hash_result));
+	shw_hash_update(&state->outer_hash, hash_result, SHW_HASH_LEN);
+
+	shw_hash_final(&state->outer_hash, hmac, hmac_len);
+
+	return FSL_RETURN_OK_S;
+}
diff --git a/drivers/mxc/security/sahara2/fsl_shw_auth.c b/drivers/mxc/security/sahara2/fsl_shw_auth.c
index 31e676a..d3100f0 100644
--- a/drivers/mxc/security/sahara2/fsl_shw_auth.c
+++ b/drivers/mxc/security/sahara2/fsl_shw_auth.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -33,14 +33,17 @@ EXPORT_SYMBOL(fsl_shw_auth_decrypt);
 /*!
  * Compute the size, in bytes, of the encoded auth length
  *
- * @param l    The actual auth length
+ * @param l    The actual associated data length
  *
  * @return The encoded length
  */
 #define COMPUTE_NIST_AUTH_LEN_SIZE(l)                                         \
 ({                                                                            \
     unsigned val;                                                             \
-    if ((uint32_t)(l) < 65280) {                                              \
+    uint32_t len = l;                                                         \
+    if (len == 0) {                                                           \
+        val = 0;                                                              \
+    } else if (len < 65280) {                                                 \
         val = 2;                                                              \
     } else {                    /* cannot handle >= 2^32 */                   \
         val = 6;                                                              \
@@ -74,9 +77,9 @@ EXPORT_SYMBOL(fsl_shw_auth_decrypt);
     }                                                                         \
 }
 
-/*! Buffer to repetively sink useless CBC output */
 #if defined (FSL_HAVE_SAHARA2) || defined (USE_S2_CCM_DECRYPT_CHAIN)          \
     || defined (USE_S2_CCM_ENCRYPT_CHAIN)
+/*! Buffer to repetively sink useless CBC output */
 static uint8_t cbc_buffer[CBC_BUF_LEN];
 #endif
 
@@ -143,33 +146,36 @@ static inline fsl_shw_return_t process_assoc_from_nist_params(sah_Link ** link1,
 				 auth_ctx->auth_info.CCM_ctx_info.
 				 block_size_bytes, SAH_USES_LINK_DATA);
 
-	if (status == FSL_RETURN_OK_S) {
-		/* Add on length preamble to auth data */
-		STORE_NIST_AUTH_LEN(auth_data_length, *temp_buf);
-		status = sah_Append_Link(user_ctx->mem_util, *link1,
-					 *temp_buf, auth_size_length,
-					 SAH_OWNS_LINK_DATA);
-		*temp_buf += auth_size_length;	/* 2, 6, or 10 bytes */
-	}
+	if (auth_data_length != 0) {
+		if (status == FSL_RETURN_OK_S) {
+			/* Add on length preamble to auth data */
+			STORE_NIST_AUTH_LEN(auth_data_length, *temp_buf);
+			status = sah_Append_Link(user_ctx->mem_util, *link1,
+						 *temp_buf, auth_size_length,
+						 SAH_OWNS_LINK_DATA);
+			*temp_buf += auth_size_length;	/* 2, 6, or 10 bytes */
+		}
 
-	if (status == FSL_RETURN_OK_S) {
-		/* Add in auth data */
-		status = sah_Append_Link(user_ctx->mem_util, *link1,
-					 (uint8_t *) auth_data,
-					 auth_data_length, SAH_USES_LINK_DATA);
-	}
+		if (status == FSL_RETURN_OK_S) {
+			/* Add in auth data */
+			status = sah_Append_Link(user_ctx->mem_util, *link1,
+						 (uint8_t *) auth_data,
+						 auth_data_length,
+						 SAH_USES_LINK_DATA);
+		}
 
-	if ((status == FSL_RETURN_OK_S) && (auth_pad_length > 0)) {
-		status = sah_Append_Link(user_ctx->mem_util, *link1,
-					 block_zeros, auth_pad_length,
-					 SAH_USES_LINK_DATA);
+		if ((status == FSL_RETURN_OK_S) && (auth_pad_length > 0)) {
+			status = sah_Append_Link(user_ctx->mem_util, *link1,
+						 block_zeros, auth_pad_length,
+						 SAH_USES_LINK_DATA);
+		}
 	}
-
+	/* ... if auth_data_length != 0 */
 	*data_len = auth_ctx->auth_info.CCM_ctx_info.block_size_bytes +
 	    auth_data_length + auth_size_length + auth_pad_length;
 
 	return status;
-}
+}				/* end fn process_assoc_from_nist_params */
 
 /*!
  * Add a Descriptor which will process with CBC the NIST preamble data
@@ -199,7 +205,7 @@ static inline fsl_shw_return_t add_assoc_preamble(sah_Head_Desc ** desc_chain,
 	uint32_t header = SAH_HDR_SKHA_ENC_DEC;
 	uint32_t temp_buf_flag;
 	unsigned chain_s2 = 1;
-	
+
 #if defined (FSL_HAVE_SAHARA4) && !defined (USE_S2_CCM_DECRYPT_CHAIN)
 	if (!encrypt) {
 		chain_s2 = 0;
@@ -210,7 +216,6 @@ static inline fsl_shw_return_t add_assoc_preamble(sah_Head_Desc ** desc_chain,
 		chain_s2 = 0;
 	}
 #endif
-
 	/* Grab a block big enough for multiple uses so that only one allocate
 	 * request needs to be made.
 	 */
@@ -223,65 +228,61 @@ static inline fsl_shw_return_t add_assoc_preamble(sah_Head_Desc ** desc_chain,
 	if (temp_buf == NULL) {
 		status = FSL_RETURN_NO_RESOURCE_S;
 		goto out;
-	} 
-
-		if (auth_ctx->flags & FSL_ACCO_NIST_CCM) {
-			status = process_assoc_from_nist_params(&link1,
-								&cbc_data_length,
-								user_ctx,
-								auth_ctx,
-								auth_data,
-								auth_data_length,
-								&temp_buf);
-			
-			if (status != FSL_RETURN_OK_S) {
-				goto out;
-			}
-			/* temp_buf has been referenced (and incremented).  Only 'own' it
-			 * once, at its first value.  Since the nist routine called above
-			 * bumps it...
-			 */
-			temp_buf_flag = SAH_USES_LINK_DATA;
-		} else {	/* if NIST */
-			status =
-			    sah_Create_Link(user_ctx->mem_util, &link1,
-					    (uint8_t *) auth_data,
-					    auth_data_length,
-					    SAH_USES_LINK_DATA);
-			if (status != FSL_RETURN_OK_S) {
-				goto out;
-			}
-			/* for next/first use of temp_buf */
-			temp_buf_flag = SAH_OWNS_LINK_DATA;
-			
-			cbc_data_length = auth_data_length;
-		}		/* else not NIST */
+	}
+
+	if (auth_ctx->flags & FSL_ACCO_NIST_CCM) {
+		status = process_assoc_from_nist_params(&link1,
+							&cbc_data_length,
+							user_ctx,
+							auth_ctx,
+							auth_data,
+							auth_data_length,
+							&temp_buf);
+		if (status != FSL_RETURN_OK_S) {
+			goto out;
+		}
+		/* temp_buf has been referenced (and incremented).  Only 'own' it
+		 * once, at its first value.  Since the nist routine called above
+		 * bumps it...
+		 */
+		temp_buf_flag = SAH_USES_LINK_DATA;
+	} else {		/* if NIST */
+		status = sah_Create_Link(user_ctx->mem_util, &link1,
+					 (uint8_t *) auth_data,
+					 auth_data_length, SAH_USES_LINK_DATA);
+		if (status != FSL_RETURN_OK_S) {
+			goto out;
+		}
+		/* for next/first use of temp_buf */
+		temp_buf_flag = SAH_OWNS_LINK_DATA;
+		cbc_data_length = auth_data_length;
+	}			/* else not NIST */
+
 #if defined (FSL_HAVE_SAHARA2) || defined (USE_S2_CCM_ENCRYPT_CHAIN)   \
-	|| defined (USE_S2_CCM_DECRYPT_CHAIN)
-		
+    || defined (USE_S2_CCM_DECRYPT_CHAIN)
+
 	if (!chain_s2) {
 		header = SAH_HDR_SKHA_CBC_ICV
-				^ sah_insert_skha_mode_cbc ^ sah_insert_skha_aux0
-				^ sah_insert_skha_encrypt;
+		    ^ sah_insert_skha_mode_cbc ^ sah_insert_skha_aux0
+		    ^ sah_insert_skha_encrypt;
 	} else {
-
 		/*
 		 * Auth data links have been created.  Now create link for the
 		 * useless output of the CBC calculation.
 		 */
 		status = sah_Create_Link(user_ctx->mem_util, &link2,
-				 temp_buf,
-				 auth_ctx->auth_info.CCM_ctx_info.block_size_bytes,
-				 temp_buf_flag | SAH_OUTPUT_LINK);
-
+					 temp_buf,
+					 auth_ctx->auth_info.CCM_ctx_info.
+					 block_size_bytes,
+					 temp_buf_flag | SAH_OUTPUT_LINK);
 		if (status != FSL_RETURN_OK_S) {
 			goto out;
 		}
+
 		temp_buf += auth_ctx->auth_info.CCM_ctx_info.block_size_bytes;
 
 		cbc_data_length -=
 		    auth_ctx->auth_info.CCM_ctx_info.block_size_bytes;
-
 		if (cbc_data_length != 0) {
 			while ((status == FSL_RETURN_OK_S)
 			       && (cbc_data_length != 0)) {
@@ -301,31 +302,29 @@ static inline fsl_shw_return_t add_assoc_preamble(sah_Head_Desc ** desc_chain,
 				cbc_data_length -= linklen;
 			}
 		}
-   }
+	}
 #else
-			header = SAH_HDR_SKHA_CBC_ICV
-				^ sah_insert_skha_mode_cbc ^ sah_insert_skha_aux0
-				^ sah_insert_skha_encrypt;
+	header = SAH_HDR_SKHA_CBC_ICV
+	    ^ sah_insert_skha_mode_cbc ^ sah_insert_skha_aux0
+	    ^ sah_insert_skha_encrypt;
 #endif
-		/* Crank through auth data */
-		status = sah_Append_Desc(user_ctx->mem_util, desc_chain,
-					 header, link1, link2);
-		
-out:
+	/* Crank through auth data */
+	status = sah_Append_Desc(user_ctx->mem_util, desc_chain,
+				 header, link1, link2);
 
-		if (status != FSL_RETURN_OK_S) {
-			if (link1 != NULL) {
-				sah_Destroy_Link(user_ctx->mem_util, link1);
-			}
-			if (link2 != NULL) {
-				sah_Destroy_Link(user_ctx->mem_util, link2);
-			}
-		} 
-	
-    (void)encrypt;
+      out:
+	if (status != FSL_RETURN_OK_S) {
+		if (link1 != NULL) {
+			sah_Destroy_Link(user_ctx->mem_util, link1);
+		}
+		if (link2 != NULL) {
+			sah_Destroy_Link(user_ctx->mem_util, link2);
+		}
+	}
 
+	(void)encrypt;
 	return status;
-}
+}				/* add_assoc_preamble() */
 
 #if SUPPORT_SSL
 /*!
@@ -470,7 +469,7 @@ fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
 				     uint8_t * ct, uint8_t * auth_value)
 {
 	SAH_SF_DCLS;
-    printk("Entering fsl_shw_gen_encrypt \n");
+
 	SAH_SF_USER_CHECK();
 
 	if (auth_ctx->mode == FSL_ACC_MODE_SSL) {
@@ -496,7 +495,7 @@ fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
 		ret = FSL_RETURN_BAD_FLAG_S;
 		goto out;
 	}
-	
+
 	/* Load CTR0 and Key */
 	header = (SAH_HDR_SKHA_SET_MODE_IV_KEY
 		  ^ sah_insert_skha_mode_ctr
@@ -506,29 +505,26 @@ fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
 		    auth_ctx->cipher_ctx_info.context, cipher_key_info);
 
 	/* Encrypt dummy data to bump to CTR1 */
-
 	header = SAH_HDR_SKHA_ENC_DEC;
 	DESC_IN_OUT(header, auth_ctx->mac_length, garbage_output,
-		auth_ctx->mac_length, garbage_output);
-	
+		    auth_ctx->mac_length, garbage_output);
+
 #if defined(FSL_HAVE_SAHARA2) || defined(USE_S2_CCM_ENCRYPT_CHAIN)
 #ifndef NO_ZERO_IV_LOAD
 	header = (SAH_HDR_SKHA_SET_MODE_IV_KEY
 		  ^ sah_insert_skha_encrypt ^ sah_insert_skha_mode_cbc);
 	DESC_IN_IN(header,
-			    auth_ctx->auth_info.CCM_ctx_info.block_size_bytes,
-				block_zeros, 0, NULL);
-#endif	
+		   auth_ctx->auth_info.CCM_ctx_info.block_size_bytes,
+		   block_zeros, 0, NULL);
+#endif
 #endif
 
-	if (auth_data_length > 0) {
-		ret = add_assoc_preamble(&desc_chain, user_ctx,
-					 auth_ctx, 1, auth_data, auth_data_length);
-		if (ret != FSL_RETURN_OK_S) {
-			goto out;
-		}
+	ret = add_assoc_preamble(&desc_chain, user_ctx,
+				 auth_ctx, 1, auth_data, auth_data_length);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
 	}
-	/* if auth_data_length > 0 */
+
 	/* Process the payload */
 	header = (SAH_HDR_SKHA_SET_MODE_ENC_DEC
 		  ^ sah_insert_skha_mode_ccm
@@ -536,32 +532,34 @@ fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
 #if defined (FSL_HAVE_SAHARA4) && !defined (USE_S2_CCM_ENCRYPT_CHAIN)
 	header ^= sah_insert_skha_aux0;
 #endif
-	DESC_IN_OUT(header, payload_length, payload, payload_length, ct);
+	if (payload_length != 0) {
+		DESC_IN_OUT(header, payload_length, payload, payload_length,
+			    ct);
+	} else {
+		DESC_IN_OUT(header, 0, NULL, 0, NULL);
+	}			/* if payload_length */
 
 #if defined (FSL_HAVE_SAHARA4) && !defined (USE_S2_CCM_ENCRYPT_CHAIN)
-
 	/* Pull out the CBC-MAC value. */
-	
 	DESC_OUT_OUT(SAH_HDR_SKHA_READ_CONTEXT_IV, 0, NULL,
-				 auth_ctx->mac_length, auth_value);
+		     auth_ctx->mac_length, auth_value);
 #else
-		/* Pull out the unencrypted CBC-MAC value. */
+	/* Pull out the unencrypted CBC-MAC value. */
 	DESC_OUT_OUT(SAH_HDR_SKHA_READ_CONTEXT_IV,
-		0, NULL, auth_ctx->mac_length, auth_ctx->unencrypted_mac);
+		     0, NULL, auth_ctx->mac_length, auth_ctx->unencrypted_mac);
 
 	/* Now load CTR0 in, and encrypt the MAC */
-	
 	header = SAH_HDR_SKHA_SET_MODE_IV_KEY
-			^ sah_insert_skha_encrypt
-			^ sah_insert_skha_mode_ctr ^ sah_insert_skha_modulus_128;
-		DESC_IN_IN(header,
-			   auth_ctx->cipher_ctx_info.block_size_bytes,
-			   auth_ctx->cipher_ctx_info.context, 0, NULL);
-	
-		header = SAH_HDR_SKHA_ENC_DEC;	/* Desc. #4 SKHA Enc/Dec */
-		DESC_IN_OUT(header,
-				auth_ctx->mac_length, auth_ctx->unencrypted_mac,
-					  auth_ctx->mac_length, auth_value);
+	    ^ sah_insert_skha_encrypt
+	    ^ sah_insert_skha_mode_ctr ^ sah_insert_skha_modulus_128;
+	DESC_IN_IN(header,
+		   auth_ctx->cipher_ctx_info.block_size_bytes,
+		   auth_ctx->cipher_ctx_info.context, 0, NULL);
+
+	header = SAH_HDR_SKHA_ENC_DEC;	/* Desc. #4 SKHA Enc/Dec */
+	DESC_IN_OUT(header,
+		    auth_ctx->mac_length, auth_ctx->unencrypted_mac,
+		    auth_ctx->mac_length, auth_value);
 #endif
 
 	SAH_SF_EXECUTE();
@@ -608,12 +606,11 @@ fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
 
 	SAH_SF_USER_CHECK();
 
-	/* Only support CCM. */
+	/* Only support CCM */
 	if (auth_ctx->mode != FSL_ACC_MODE_CCM) {
 		ret = FSL_RETURN_BAD_MODE_S;
 		goto out;
 	}
-	
 	/* Only support INIT and FINALIZE flags right now. */
 	if ((auth_ctx->flags & (FSL_ACCO_CTX_INIT | FSL_ACCO_CTX_LOAD |
 				FSL_ACCO_CTX_SAVE | FSL_ACCO_CTX_FINALIZE))
@@ -621,6 +618,7 @@ fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
 		ret = FSL_RETURN_BAD_FLAG_S;
 		goto out;
 	}
+
 	/* Load CTR0 and Key */
 	header = SAH_HDR_SKHA_SET_MODE_IV_KEY
 	    ^ sah_insert_skha_mode_ctr ^ sah_insert_skha_modulus_128;
@@ -629,42 +627,44 @@ fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
 #endif
 	DESC_IN_KEY(header,
 		    auth_ctx->cipher_ctx_info.block_size_bytes,
-			auth_ctx->cipher_ctx_info.context, cipher_key_info);
-	
+		    auth_ctx->cipher_ctx_info.context, cipher_key_info);
+
 	/* Decrypt the MAC which the user passed in */
 	header = SAH_HDR_SKHA_ENC_DEC;
 	DESC_IN_OUT(header,
 		    auth_ctx->mac_length, auth_value,
 		    auth_ctx->mac_length, auth_ctx->unencrypted_mac);
+
 #if defined(FSL_HAVE_SAHARA2) || defined(USE_S2_CCM_DECRYPT_CHAIN)
 #ifndef NO_ZERO_IV_LOAD
 	header = (SAH_HDR_SKHA_SET_MODE_IV_KEY
-			  ^ sah_insert_skha_encrypt ^ sah_insert_skha_mode_cbc);
+		  ^ sah_insert_skha_encrypt ^ sah_insert_skha_mode_cbc);
 	DESC_IN_IN(header,
-			    auth_ctx->auth_info.CCM_ctx_info.block_size_bytes,
-			    block_zeros, 0, NULL);
+		   auth_ctx->auth_info.CCM_ctx_info.block_size_bytes,
+		   block_zeros, 0, NULL);
 #endif
 #endif
 
-	if (auth_data_length > 0) {
-		ret = add_assoc_preamble(&desc_chain, user_ctx,
-					 auth_ctx, 0, auth_data, auth_data_length);
-		if (ret != FSL_RETURN_OK_S) {
-			goto out;
-		}
+	ret = add_assoc_preamble(&desc_chain, user_ctx,
+				 auth_ctx, 0, auth_data, auth_data_length);
+	if (ret != FSL_RETURN_OK_S) {
+		goto out;
 	}
-	/* if auth_data_length > 0 */
-	
+
 	/* Process the payload */
 	header = (SAH_HDR_SKHA_SET_MODE_ENC_DEC
-		^ sah_insert_skha_mode_ccm ^ sah_insert_skha_modulus_128);
+		  ^ sah_insert_skha_mode_ccm ^ sah_insert_skha_modulus_128);
 #if defined (FSL_HAVE_SAHARA4) && !defined (USE_S2_CCM_DECRYPT_CHAIN)
 	header ^= sah_insert_skha_aux0;
 #endif
-	DESC_IN_OUT(header, payload_length, ct, payload_length, payload);
-	
-#if defined (FSL_HAVE_SAHARA2) || defined (USE_S2_CCM_DECRYPT_CHAIN)
+	if (payload_length != 0) {
+		DESC_IN_OUT(header, payload_length, ct, payload_length,
+			    payload);
+	} else {
+		DESC_IN_OUT(header, 0, NULL, 0, NULL);
+	}
 
+#if defined (FSL_HAVE_SAHARA2) || defined (USE_S2_CCM_DECRYPT_CHAIN)
 	/* Now pull CBC context (unencrypted MAC) out for comparison. */
 	/* Need to allocate a place for it, to handle non-blocking mode
 	 * when this stack frame will disappear!
@@ -672,7 +672,6 @@ fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
 	calced_auth = DESC_TEMP_ALLOC(auth_ctx->mac_length);
 	header = SAH_HDR_SKHA_READ_CONTEXT_IV;
 	DESC_OUT_OUT(header, 0, NULL, auth_ctx->mac_length, calced_auth);
-	
 	if (!blocking) {
 		/* get_results will need this for comparison */
 		desc_chain->out1_ptr = calced_auth;
@@ -684,7 +683,6 @@ fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
 	SAH_SF_EXECUTE();
 
 #if defined (FSL_HAVE_SAHARA2) || defined (USE_S2_CCM_DECRYPT_CHAIN)
-
 	if (blocking && (ret == FSL_RETURN_OK_S)) {
 		unsigned i;
 		/* Validate the auth code */
@@ -695,13 +693,14 @@ fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
 			}
 		}
 	}
-
 #endif
-out:
+
+      out:
 	SAH_SF_DESC_CLEAN();
 #if defined (FSL_HAVE_SAHARA2) || defined (USE_S2_CCM_DECRYPT_CHAIN)
 	DESC_TEMP_FREE(calced_auth);
 #endif
+
 	(void)auth_key_info;
 	return ret;
 }				/* fsl_shw_gen_decrypt() */
diff --git a/drivers/mxc/security/sahara2/fsl_shw_keystore.c b/drivers/mxc/security/sahara2/fsl_shw_keystore.c
index 8b3c325..1fb69ae 100644
--- a/drivers/mxc/security/sahara2/fsl_shw_keystore.c
+++ b/drivers/mxc/security/sahara2/fsl_shw_keystore.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -40,14 +40,14 @@
 #define RELEASE_LOCK
 #endif	/* __KERNEL__ */
 
-/**
+/*!
  * Calculates the byte offset into a word
  *  @param   bp  The byte (char*) pointer
  *  @return      The offset (0, 1, 2, or 3)
  */
 #define SCC_BYTE_OFFSET(bp) ((uint32_t)(bp) % sizeof(uint32_t))
 
-/**
+/*!
  * Converts (by rounding down) a byte pointer into a word pointer
  *  @param  bp  The byte (char*) pointer
  *  @return     The word (uint32_t) as though it were an aligned (uint32_t*)
@@ -61,6 +61,7 @@
  * available in kernel mode, so they should be stubbed out in user mode.
  */
 #if defined(FSL_HAVE_SCC2) || (defined(FSL_HAVE_SCC) && defined(__KERNEL__))
+EXPORT_SYMBOL(fsl_shw_init_keystore);
 void fsl_shw_init_keystore(
 			    fsl_shw_kso_t *keystore,
 			    fsl_shw_return_t(*data_init) (fsl_shw_uco_t *user_ctx,
@@ -100,6 +101,8 @@ void fsl_shw_init_keystore(
 	keystore->slot_get_offset = slot_get_offset;
 	keystore->slot_get_slot_size = slot_get_slot_size;
 }
+
+EXPORT_SYMBOL(fsl_shw_init_keystore_default);
 void fsl_shw_init_keystore_default(fsl_shw_kso_t *keystore)
 {
 	keystore->data_init = shw_kso_init_data;
@@ -113,9 +116,10 @@ void fsl_shw_init_keystore_default(fsl_shw_kso_t *keystore)
 	keystore->slot_get_slot_size = shw_slot_get_slot_size;
 }
 
-/**
+/*!
  * Do any keystore specific initializations
  */
+EXPORT_SYMBOL(fsl_shw_establish_keystore);
 fsl_shw_return_t fsl_shw_establish_keystore(fsl_shw_uco_t *user_ctx,
 						fsl_shw_kso_t *keystore)
 {
@@ -126,6 +130,8 @@ fsl_shw_return_t fsl_shw_establish_keystore(fsl_shw_uco_t *user_ctx,
     /* Call the data_init function for any user setup */
     return keystore->data_init(user_ctx, &(keystore->user_data));
 }
+
+EXPORT_SYMBOL(fsl_shw_release_keystore);
 void fsl_shw_release_keystore(fsl_shw_uco_t *user_ctx,
 				 fsl_shw_kso_t *keystore)
 {
@@ -181,7 +187,7 @@ out:RELEASE_LOCK;
 }
 
 fsl_shw_return_t
-keystore_load_slot(fsl_shw_kso_t * keystore, uint64_t owner_id, uint32_t slot,
+keystore_slot_load(fsl_shw_kso_t * keystore, uint64_t owner_id, uint32_t slot,
 		   const uint8_t * key_data, uint32_t key_length)
 {
 
@@ -238,6 +244,56 @@ out:RELEASE_LOCK;
 }
 
 fsl_shw_return_t
+keystore_slot_read(fsl_shw_kso_t * keystore, uint64_t owner_id, uint32_t slot,
+		   uint32_t key_length, uint8_t * key_data)
+{
+#ifdef FSL_HAVE_SCC2
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+	uint8_t *slot_addr;
+	uint32_t slot_size;
+
+	slot_addr = keystore->slot_get_address(keystore->user_data, slot);
+	slot_size = keystore->slot_get_slot_size(keystore->user_data, slot);
+
+	if (key_length > slot_size) {
+		retval = FSL_RETURN_BAD_KEY_LENGTH_S;
+		goto out;
+	}
+
+	memcpy(key_data, slot_addr, key_length);
+	retval = FSL_RETURN_OK_S;
+
+      out:
+	return retval;
+
+#else				/* Have SCC2 */
+	fsl_shw_return_t retval = FSL_RETURN_ERROR_S;
+	scc_return_t scc_ret;
+	printk("keystore SCC \n");
+
+	scc_ret =
+	    scc_read_slot(owner_id, slot, key_length, (uint8_t *) key_data);
+	printk("keystore SCC Ret value: %d \n", scc_ret);
+	switch (scc_ret) {
+	case SCC_RET_OK:
+		retval = FSL_RETURN_OK_S;
+		break;
+	case SCC_RET_VERIFICATION_FAILED:
+		retval = FSL_RETURN_AUTH_FAILED_S;
+		break;
+	case SCC_RET_INSUFFICIENT_SPACE:
+		retval = FSL_RETURN_BAD_DATA_LENGTH_S;
+		break;
+	default:
+		retval = FSL_RETURN_ERROR_S;
+	}
+
+	return retval;
+
+#endif				/* FSL_HAVE_SCC2 */
+}/* end fn keystore_slot_read */
+
+fsl_shw_return_t
 keystore_slot_encrypt(fsl_shw_uco_t *user_ctx, fsl_shw_kso_t *keystore,
 		      uint64_t owner_id, uint32_t slot, uint32_t length,
 		      uint8_t *destination)
@@ -421,7 +477,7 @@ fsl_shw_return_t keystore_slot_dealloc(fsl_shw_kso_t *keystore,
 }
 
 fsl_shw_return_t
-keystore_load_slot(fsl_shw_kso_t *keystore, uint64_t owner_id, uint32_t slot,
+keystore_slot_load(fsl_shw_kso_t *keystore, uint64_t owner_id, uint32_t slot,
 		   const uint8_t *key_data, uint32_t key_length)
 {
 	(void)keystore;
@@ -433,6 +489,19 @@ keystore_load_slot(fsl_shw_kso_t *keystore, uint64_t owner_id, uint32_t slot,
 }
 
 fsl_shw_return_t
+keystore_slot_read(fsl_shw_kso_t * keystore, uint64_t owner_id, uint32_t slot,
+		   uint32_t key_length, uint8_t * key_data)
+{
+	(void)keystore;
+	(void)owner_id;
+	(void)slot;
+	(void)key_length;
+	(void)key_data;
+
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+fsl_shw_return_t
 keystore_slot_decrypt(fsl_shw_uco_t *user_ctx, fsl_shw_kso_t *keystore,
 		      uint64_t owner_id, uint32_t slot, uint32_t length,
 		      const uint8_t *source)
@@ -610,6 +679,9 @@ fsl_shw_return_t shw_slot_dealloc(void *user_data, uint64_t owner_id,
 	if (slot >= data->slot_count)
 		return FSL_RETURN_ERROR_S;
 	if (data->slot[slot].allocated == 1) {
+		/* Forcibly remove the data from the keystore */
+		memset(shw_slot_get_address(user_data, slot), 0,
+		       KEYSTORE_SLOT_SIZE);
 		data->slot[slot].allocated = 0;
 		return FSL_RETURN_OK_S;
 	}
diff --git a/drivers/mxc/security/sahara2/fsl_shw_wrap.c b/drivers/mxc/security/sahara2/fsl_shw_wrap.c
index af556eb..08fd7fa 100644
--- a/drivers/mxc/security/sahara2/fsl_shw_wrap.c
+++ b/drivers/mxc/security/sahara2/fsl_shw_wrap.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -40,11 +40,11 @@
 <tr><th>To Wrap</th></tr>
 <tr><TD align="right">T</td> <TD width="3">=</td> <TD>RND()<sub>16</sub>
     </td></tr>
-<tr><TD align="right">KEK</td><TD width="3">=</td><TD>HASH<sub>sha1</sub>(T |
+<tr><TD align="right">KEK</td><TD width="3">=</td><TD>HASH<sub>sha256</sub>(T |
      Ownerid)<sub>16</sub></td></tr>
 <tr><TD align="right">KEY'<TD width="3">=</td><TD>
      AES<sub>ctr-enc</sub>(Key=KEK, CTR=0, Data=KEY)</td></tr>
-<tr><TD align="right">ICV</td><TD width="3">=</td><td>HMAC<sub>sha1</sub>
+<tr><TD align="right">ICV</td><TD width="3">=</td><td>HMAC<sub>sha256</sub>
      (Key=T, Data=Ownerid | LEN | ALG | KEY')<sub>16</sub></td></tr>
 <tr><TD align="right">T'</td><TD width="3">=</td><TD>TDES<sub>cbc-enc</sub>
      (Key=SLID, IV=Ownerid, Data=T)</td></tr>
@@ -54,9 +54,9 @@
 <tr><th>To Unwrap</th></tr>
 <tr><TD align="right">T</td><TD width="3">=</td><TD>TDES<sub>ecb-dec</sub>
     (Key=SLID, IV=Ownerid, Data=T')</sub></td></tr>
-<tr><TD align="right">ICV</td><TD width="3">=</td><td>HMAC<sub>sha1</sub>
+<tr><TD align="right">ICV</td><TD width="3">=</td><td>HMAC<sub>sha256</sub>
     (Key=T, Data=Ownerid | LEN | ALG | KEY')<sub>16</sub></td></tr>
-<tr><TD align="right">KEK</td><TD width="3">=</td><td>HASH<sub>sha1</sub>
+<tr><TD align="right">KEK</td><TD width="3">=</td><td>HASH<sub>sha256</sub>
     (T | Ownerid)<sub>16</sub></td></tr>
 <tr><TD align="right">KEY<TD width="3">=</td><TD>AES<sub>ctr-dec</sub>
     (Key=KEK, CTR=0, Data=KEY')</td></tr>
@@ -107,6 +107,7 @@
 EXPORT_SYMBOL(fsl_shw_establish_key);
 EXPORT_SYMBOL(fsl_shw_extract_key);
 EXPORT_SYMBOL(fsl_shw_release_key);
+EXPORT_SYMBOL(fsl_shw_read_key);
 #endif
 
 #define ICV_LENGTH 16
@@ -114,13 +115,16 @@ EXPORT_SYMBOL(fsl_shw_release_key);
 #define KEK_LENGTH 16
 #define LENGTH_LENGTH 1
 #define ALGORITHM_LENGTH 1
+#define FLAGS_LENGTH 1
 
 /* ICV | T' | LEN | ALG | KEY' */
 #define ICV_OFFSET       0
 #define T_PRIME_OFFSET   (ICV_OFFSET + ICV_LENGTH)
 #define LENGTH_OFFSET    (T_PRIME_OFFSET + T_LENGTH)
 #define ALGORITHM_OFFSET (LENGTH_OFFSET + LENGTH_LENGTH)
-#define KEY_PRIME_OFFSET (ALGORITHM_OFFSET + ALGORITHM_LENGTH)
+#define FLAGS_OFFSET     (ALGORITHM_OFFSET + ALGORITHM_LENGTH)
+#define KEY_PRIME_OFFSET (FLAGS_OFFSET + FLAGS_LENGTH)
+#define FLAGS_SW_KEY     0x01
 
 /*
  * For testing of the algorithm implementation,, the DO_REPEATABLE_WRAP flag
@@ -141,7 +145,7 @@ static uint8_t T_block_[16] = {
 };
 #endif
 
-/*
+/*!
  * Insert descriptors to calculate ICV = HMAC(key=T, data=LEN|ALG|KEY')
  *
  * @param  user_ctx      User's context for this operation
@@ -168,7 +172,7 @@ static inline fsl_shw_return_t create_icv_calc(fsl_shw_uco_t * user_ctx,
 
 	/* Load up T as key for the HMAC */
 	header = (SAH_HDR_MDHA_SET_MODE_MD_KEY	/* #6 */
-		  ^ sah_insert_mdha_algorithm_sha1
+		  ^ sah_insert_mdha_algorithm_sha256
 		  ^ sah_insert_mdha_init ^ sah_insert_mdha_hmac ^
 		  sah_insert_mdha_pdata ^ sah_insert_mdha_mac_full);
 	sah_code = sah_add_in_key_desc(header, NULL, 0, t_key_info,	/* Reference T in RED */
@@ -252,13 +256,21 @@ static fsl_shw_return_t unwrap(fsl_shw_uco_t * user_ctx,
 	t_key_info.key_length = T_LENGTH;
 	t_key_info.keystore = key_info->keystore;
 
+	/* Validate SW flags to prevent misuse */
+	if ((key_info->flags & FSL_SKO_KEY_SW_KEY)
+		&& !(black_key[FLAGS_OFFSET] & FLAGS_SW_KEY)) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
 	/* Compute T = SLID_decrypt(T'); leave in RED slot */
 	if (key_info->keystore == NULL) {
 		/* Key goes in system keystore */
 		ret = do_system_keystore_slot_decrypt(user_ctx,
 					key_info->userid,
 				    t_key_info.handle,
-				    T_LENGTH, black_key + T_PRIME_OFFSET);
+				    T_LENGTH, 
+				    black_key + T_PRIME_OFFSET);
 	
 	} else {
 			/* Key goes in user keystore */
@@ -322,10 +334,10 @@ static fsl_shw_return_t unwrap(fsl_shw_uco_t * user_ctx,
 	/* This is no longer needed. */
 	DESC_TEMP_FREE(hmac);
 
-	/* Compute KEK = SHA1(T | ownerid).  Rewrite slot with value */
+	/* Compute KEK = SHA256(T | ownerid).  Rewrite slot with value */
 	header = (SAH_HDR_MDHA_SET_MODE_HASH	/* #8 */
 		  ^ sah_insert_mdha_init
-		  ^ sah_insert_mdha_algorithm_sha1 ^ sah_insert_mdha_pdata);
+		  ^ sah_insert_mdha_algorithm_sha256 ^ sah_insert_mdha_pdata);
 
 	/* Input - Start with T */
 	ret = sah_Create_Key_Link(user_ctx->mem_util, &link1, &t_key_info);
@@ -456,12 +468,12 @@ static fsl_shw_return_t wrap(fsl_shw_uco_t * user_ctx,
 #endif
 		if (key_info->keystore == NULL) {
 			/* Key goes in system keystore */
-			ret = do_system_keystore_slot_dealloc(user_ctx,
+			(void)do_system_keystore_slot_dealloc(user_ctx,
 				key_info->userid, T_key_info.handle);
 	
 		} else {
 			/* Key goes in user keystore */
-			ret = keystore_slot_dealloc(key_info->keystore,
+			(void)keystore_slot_dealloc(key_info->keystore,
 				  	key_info->userid, T_key_info.handle);
 		}
 	} else {
@@ -476,13 +488,13 @@ static fsl_shw_return_t wrap(fsl_shw_uco_t * user_ctx,
 #else
 	if (key_info->keystore == NULL) {
 		/* Key goes in system keystore */
-		ret = do_system_keystore_load_slot(user_ctx,
+		ret = do_system_keystore_slot_load(user_ctx,
 			   T_key_info.userid,
 			   T_key_info.handle, T_block,
 			   T_key_info.key_length);
 	} else {
 		/* Key goes in user keystore */
-		ret = keystore_load_slot(key_info->keystore,
+		ret = keystore_slot_load(key_info->keystore,
 				 T_key_info.userid,
 				 T_key_info.handle,
 				 T_block, T_key_info.key_length);
@@ -493,10 +505,10 @@ static fsl_shw_return_t wrap(fsl_shw_uco_t * user_ctx,
 	}
 #endif
 
-	/* Compute KEK = SHA1(T | Ownerid) */
+	/* Compute KEK = SHA256(T | Ownerid) */
 	header = (SAH_HDR_MDHA_SET_MODE_HASH	/* #8 */
 		  ^ sah_insert_mdha_init
-		  ^ sah_insert_mdha_algorithm[FSL_HASH_ALG_SHA1]
+		  ^ sah_insert_mdha_algorithm[FSL_HASH_ALG_SHA256]
 		  ^ sah_insert_mdha_pdata);
 	/* Input - Start with T */
 	ret = sah_Create_Key_Link(user_ctx->mem_util, &link1, &T_key_info);
@@ -538,6 +550,12 @@ static fsl_shw_return_t wrap(fsl_shw_uco_t * user_ctx,
 	DESC_KEY_OUT(header, key_info,
 		     key_info->key_length, black_key + KEY_PRIME_OFFSET);
 
+	/* Set up flags info */
+	black_key[FLAGS_OFFSET] = 0;
+	if (key_info->flags & FSL_SKO_KEY_SW_KEY) {
+		black_key[FLAGS_OFFSET] |= FLAGS_SW_KEY;
+	}
+
 	/* Compute and store ICV into Black Key */
 	ret = create_icv_calc(user_ctx, &desc_chain, &T_key_info,
 			      black_key, original_key_length,
@@ -676,6 +694,14 @@ fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
 	}
 
 	SAH_SF_USER_CHECK();
+	
+	if (key_info->flags & FSL_SKO_KEY_ESTABLISHED) {
+#ifdef DIAG_SECURITY_FUNC
+			ret = FSL_RETURN_BAD_FLAG_S;
+			LOG_DIAG("Key already established\n");
+#endif
+	}
+
 
 	if (key_info->keystore == NULL) {
 		/* Key goes in system keystore */
@@ -752,7 +778,7 @@ fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
 						   rounded_key_length);
 		} else {
 			/* Key goes in user keystore */
-			ret = keystore_load_slot(key_info->keystore,
+			ret = keystore_slot_load(key_info->keystore,
 								 key_info->userid,
 								 key_info->handle, key,
 								 key_info->key_length);
@@ -837,6 +863,12 @@ fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
 				goto out;
 			}
 
+			/* Verify that a SW key info really belongs to a SW key */
+			if (key_info->flags & FSL_SKO_KEY_SW_KEY) {
+			/*  ret = FSL_RETURN_BAD_FLAG_S;
+			  goto out;*/
+			}
+
 			/* Need to deallocate on successful extraction */
 			if (key_info->keystore == NULL) {
 				/* Key goes in system keystore */
@@ -900,3 +932,36 @@ out:
 
 	return ret;
 }
+
+fsl_shw_return_t fsl_shw_read_key(fsl_shw_uco_t * user_ctx,
+				  fsl_shw_sko_t * key_info, uint8_t * key)
+{
+	SAH_SF_DCLS;
+
+	SAH_SF_USER_CHECK();
+
+	if (!(key_info->flags & FSL_SKO_KEY_ESTABLISHED)
+	    || !(key_info->flags & FSL_SKO_KEY_SW_KEY)) {
+		ret = FSL_RETURN_BAD_FLAG_S;
+		goto out;
+	}
+
+	if (key_info->keystore == NULL) {
+		/* Key lives in system keystore */
+		ret = do_system_keystore_slot_read(user_ctx,
+						   key_info->userid,
+						   key_info->handle,
+						   key_info->key_length, key);
+	} else {
+		/* Key lives in user keystore */
+		ret = keystore_slot_read(key_info->keystore,
+					 key_info->userid,
+					 key_info->handle,
+					 key_info->key_length, key);
+	}
+
+      out:
+	SAH_SF_DESC_CLEAN();
+
+	return ret;
+}
diff --git a/drivers/mxc/security/sahara2/include/diagnostic.h b/drivers/mxc/security/sahara2/include/diagnostic.h
index b55ceaf..57f84d4 100644
--- a/drivers/mxc/security/sahara2/include/diagnostic.h
+++ b/drivers/mxc/security/sahara2/include/diagnostic.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -27,7 +27,8 @@
 
 #if defined(FSL_HAVE_SAHARA2) || defined(FSL_HAVE_SAHARA4)
 #define DEV_NAME "sahara"
-#elif defined(FSL_HAVE_RNGA) || defined(FSL_HAVE_RNGC)
+#elif defined(FSL_HAVE_RNGA) || defined(FSL_HAVE_RNGB) ||                     \
+      defined(FSL_HAVE_RNGC)
 #define DEV_NAME "shw"
 #endif
 
@@ -40,12 +41,12 @@
 * @return   void
 *
 */
-#if defined DIAG_SECURITY_FUNC || defined DIAG_ADAPTOR
+//#if defined DIAG_SECURITY_FUNC || defined DIAG_ADAPTOR
 #define LOG_DIAG(diag)                                              \
 ({                                                                  \
     const char* fname = strrchr(__FILE__, '/');                           \
                                                                     \
-     sah_Log_Diag (fname ? fname+1 : __FILE__, __LINE__, diag);     \
+     sah_Log_Diag(fname ? fname+1 : __FILE__, __LINE__, diag);     \
 })
 
 #ifdef __KERNEL__
@@ -99,12 +100,12 @@ void sah_Log_Diag(char *source_name, int source_line, char *diag);
 })
 
 #define LOG_KDIAG(diag)                                                       \
-    os_printk (KERN_ALERT "sahara (%s:%i): %s\n",                             \
-               strrchr(__FILE__, '/')+1, __LINE__, diag);
+    os_printk (KERN_ALERT "%s (%s:%i): %s\n",                             \
+               DEV_NAME, strrchr(__FILE__, '/')+1, __LINE__, diag);
 
 #define sah_Log_Diag(n, l, d)                                                 \
-    os_printk("%s:%i: %s\n", n, l, d)
-#endif
+    os_printk(KERN_ALERT "%s:%i: %s\n", n, l, d)
+
 #else				/* not KERNEL */
 
 #define sah_Log_Diag(n, l, d)                                                 \
diff --git a/drivers/mxc/security/sahara2/include/fsl_platform.h b/drivers/mxc/security/sahara2/include/fsl_platform.h
index 56cfe72..e7a6fd1 100644
--- a/drivers/mxc/security/sahara2/include/fsl_platform.h
+++ b/drivers/mxc/security/sahara2/include/fsl_platform.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -40,13 +40,20 @@
 #define FSL_HAVE_RNGA
 #define FSL_HAVE_SCC
 
+#elif defined(CONFIG_ARCH_MX25)
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_RNGB
+#define FSL_HAVE_RTIC3
+#define FSL_HAVE_DRYICE
+
 #elif defined(CONFIG_ARCH_MX27)
 
 #define FSL_HAVE_SAHARA2
 #define SUBMIT_MULTIPLE_DARS
 #define FSL_HAVE_RTIC
 #define FSL_HAVE_SCC
-#define USE_OLD_PTRS
+#define ALLOW_LLO_DESCRIPTORS
 
 #elif defined(CONFIG_ARCH_MX35)
 
@@ -59,13 +66,14 @@
 #define FSL_HAVE_SCC2
 #define FSL_HAVE_RNGC
 #define FSL_HAVE_RTIC2
+#define FSL_HAVE_SRTC
 
 #elif defined(CONFIG_ARCH_MX51)
 
 #define FSL_HAVE_SCC2
 #define FSL_HAVE_SAHARA4
 #define FSL_HAVE_RTIC3
-#define NO_1K_CROSSING
+#define FSL_HAVE_SRTC
 #define NO_RESEED_WORKAROUND
 #define NEED_CTR_WORKAROUND
 #define USE_S2_CCM_ENCRYPT_CHAIN
@@ -75,7 +83,7 @@
 #elif defined(CONFIG_ARCH_MXC91131)
 
 #define FSL_HAVE_SCC
-#define FSL_HAVE_RNGA
+#define FSL_HAVE_RNGC
 #define FSL_HAVE_HAC
 
 #elif defined(CONFIG_ARCH_MXC91221)
@@ -87,7 +95,6 @@
 #elif defined(CONFIG_ARCH_MXC91231)
 
 #define FSL_HAVE_SAHARA2
-#define USE_OLD_PTRS
 #define FSL_HAVE_RTIC
 #define FSL_HAVE_SCC
 #define NO_OUTPUT_1K_CROSSING
@@ -97,23 +104,38 @@
 #define FSL_HAVE_SCC
 #define FSL_HAVE_RNGC
 
+#elif defined(CONFIG_ARCH_MXC91314)
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_SAHAR4
+#define FSL_HAVE_RTIC3
+#define NO_RESEED_WORKAROUND
+#define NEED_CTR_WORKAROUND
+#define USE_S2_CCM_ENCRYPT_CHAIN
+#define USE_S2_CCM_DECRYPT_CHAIN
+#define ALLOW_LLO_DESCRIPTORS
+
 #elif defined(CONFIG_ARCH_MXC91321)
 
 #define FSL_HAVE_SAHARA2
 #define FSL_HAVE_RTIC
 #define FSL_HAVE_SCC
+#define SCC_CLOCK_NOT_GATED
 #define NO_OUTPUT_1K_CROSSING
-#define USE_OLD_PTRS
 
 #elif defined(CONFIG_ARCH_MXC92323)
 
 #define FSL_HAVE_SCC2
 #define FSL_HAVE_SAHARA4
+#define FSL_HAVE_PKHA
 #define FSL_HAVE_RTIC2
 #define NO_1K_CROSSING
 #define NO_RESEED_WORKAROUND
 #define NEED_CTR_WORKAROUND
-#define USE_3WORD_BURST
+#define USE_S2_CCM_ENCRYPT_CHAIN
+#define USE_S2_CCM_DECRYPT_CHAIN
+#define ALLOW_LLO_DESCRIPTORS
+
 
 #elif  defined(CONFIG_ARCH_MXC91331)
 
diff --git a/drivers/mxc/security/sahara2/include/fsl_shw.h b/drivers/mxc/security/sahara2/include/fsl_shw.h
index 4802571..1a2a763 100644
--- a/drivers/mxc/security/sahara2/include/fsl_shw.h
+++ b/drivers/mxc/security/sahara2/include/fsl_shw.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -14,7 +14,7 @@
 /*
  * NOTE TO MAINTAINERS: Although this header file is *the* header file to be
  * #include'd by FSL SHW programs, it does not itself make any definitions for
- * the API.  Instead, it use te fsl_platform.h file and / or compiler
+ * the API.  Instead, it uses the fsl_platform.h file and / or compiler
  * environment variables to determine which actual driver header file to
  * include.  This allows different implementations to contain different
  * implementations of the various objects, macros, etc., or even to change
@@ -51,6 +51,13 @@
  * provide support for other platforms.  The Platform Capabilities Object is
  * intended as a way to allow programs to adapt to different platforms.
  *
+ * The i.MX25 is an example of a platform without a SAHARA but yet has
+ * capabilities supported by this API.  These include #fsl_shw_get_random() and
+ * #fsl_shw_add_entropy(), and the use of Triple-DES (TDEA) cipher algorithm
+ * (with no checking of key parity supported) in ECB and CBC modes with @ref
+ * sym_sec.  See also the @ref di_sec for information on key handling, and @ref
+ * td_sec for detection of Tamper Events.  Only the random functions are
+ * available from user space on this platform.
  *
  * @section usr_ctx The User Context
  *
@@ -59,7 +66,7 @@
  * registration (#fsl_shw_register_user()), and is part of every interaction
  * thereafter.
  *
- * @section pf_sec Platform Capababilities
+ * @section pf_sec Platform Capabilities
  *
  * Since this API is not tied to one specific type of hardware or even one
  * given version of a given type of hardware, the platform capabilities object
@@ -121,7 +128,7 @@
  * Support is available for acquiring random values from a
  * cryptographically-strong random number generator.  See
  * #fsl_shw_get_random().  The function #fsl_shw_add_entropy() may be used to
- * add entropy to the random number generaator.
+ * add entropy to the random number generator.
  *
  *
  * @section cmb_sec Combined Cipher and Authentication
@@ -138,16 +145,85 @@
  * Only AES-CCM is supported.
  *
  *
- * @section Wrapped Keys
+ * @section wrap_sec Wrapped Keys
  *
  * On platforms with a Secure Memory, the function #fsl_shw_establish_key() can
- * be used to place a key into the Secure Memory.  This key then be used
+ * be used to place a key into the System Keystore.  This key then can be used
  * directly by the cryptographic hardware.  It later then be wrapped
  * (cryptographically obscured) by #fsl_shw_extract_key() and stored for later
- * use.
+ * use.  If a software key (#FSL_SKO_KEY_SW_KEY) was established, then its
+ * value can be retrieved with a call to #fsl_shw_read_key().
  *
  * The wrapping and unwrapping functions provide security against unauthorized
  * use and detection of tampering.
+ *
+ * The functions can also be used with a User Keystore.
+ *
+ * @section smalloc_sec Secure Memory Allocation
+ *
+ * On platforms with multiple partitions of Secure Memory, the function
+ * #fsl_shw_smalloc() can be used to acquire a partition for private use.  The
+ * function #fsl_shw_diminish_perms() can then be used to revoke specific
+ * permissions on the partition, and #fsl_shw_sfree() can be used to release the
+ * partition.
+ *
+ * @section keystore_sec User Keystore
+ *
+ * User Keystore functionality is defined in fsl_shw_keystore.h.  See @ref
+ * user_keystore for details.  This is not supported on platforms without SCC2.
+ *
+ * @section di_sec Hardware key-select extensions - DryIce
+ *
+ * Some platforms have a component called DryIce which allows the software to
+ * control which key will be used by the secure memory encryption hardware.
+ * The choices are the secret per-chip Fused (IIM) Key, an unknown, hardware-
+ * generated Random Key, a software-written Programmed Key, or the IIM Key in
+ * combination with one of the others.  #fsl_shw_pco_check_pk_supported() can
+ * be used to determine whether this feature is available on the platform.
+ * The rest of this section will explain the symmetric ciphering and key
+ * operations which are available on such a platform.
+ *
+ * The function #fsl_shw_sko_init_pf_key() will set up a Secret Key Object to
+ * refer to one of the system's platform keys.  All keys which reference a
+ * platform key must use this initialization function, including a user-
+ * provided key value.  Keys which are intended for software encryption must
+ * use #fsl_shw_sko_init().
+ *
+ * To change the setting of the Programmed Key of the DryIce module,
+ * #fsl_shw_establish_key() must be called with a platform key object of type
+ * #FSL_SHW_PF_KEY_PRG or #FSL_SHW_PF_KEY_IIM_PRG.  The key will be go
+ * into the PK register of DryIce and not to the keystore.  Any symmetric
+ * operation which references either #FSL_SHW_PF_KEY_PRG or
+ * #FSL_SHW_PF_KEY_IIM_PRG will use the current PK value (possibly modified by
+ * the secret fused IIM key).  Before the Flatform Key can be changed, a call to
+ * #fsl_shw_release_key() or #fsl_shw_extract_key() must be made.  Neither
+ * function will change the value in the PK registers, and further ciphering
+ * can take place.
+ *
+ * When #fsl_shw_establish_key() is called to change the PK value, a plaintext
+ * key can be passed in with the #FSL_KEY_WRAP_ACCEPT argument or a previously
+ * wrapped key can be passed in with the #FSL_KEY_WRAP_UNWRAP argument.  If
+ * #FSL_KEY_WRAP_CREATE is passed in, then a random value will be loaded into
+ * the PK register.  The PK value can be wrapped by a call to
+ * #fsl_shw_extract_key() for later use with the #FSL_KEY_WRAP_UNWRAP argument.
+ *
+ * As an alternative to using only the fused key for @ref wrap_sec,
+ * #fsl_shw_uco_set_wrap_key() can be used to select either the random key or
+ * the random key with the fused key as the key which will be used to protect
+ * the one-time value used to wrap the key.  This allows for these
+ * wrapped keys to be dependent upon and therefore unrecoverable after a tamper
+ * event causes the erasure of the DryIce Random Key register.
+ *
+ * The software can request that the hardware generate a (new) Random Key for
+ * DryIce by calling #fsl_shw_gen_random_pf_key().
+ *
+ *
+ * @section td_sec Device Tamper-Detection
+ *
+ * Some platforms have a component which can detect certain types of tampering
+ * with the hardware.  #fsl_shw_read_tamper_event() API will allow the
+ * retrieval of the type of event which caused a tamper-detection failure.
+ *
  */
 
 /*! @defgroup glossary Glossary
@@ -167,7 +243,7 @@
  * @li @b DES - Data Encryption Standard - An 8-octet-block cipher.
  * @li @b ECB - Electronic Codebook - A straight encryption/decryption of the
  *        data.
- * @li @b hash - A cryptographically strong one-way function peformed on data.
+ * @li @b hash - A cryptographically strong one-way function performed on data.
  * @li @b HMAC - Hashed Message Authentication Code - A key-dependent one-way
  *        hash result, used to verify authenticity of a message.  The equation
  *        for an HMAC is hash((K + A) || hash((K + B) || msg)), where K is the
@@ -212,7 +288,7 @@
 
 #else
 
-#if defined(FSL_HAVE_RNGA) || defined(FSL_HAVE_RNGC)
+#if defined(FSL_HAVE_RNGA) || defined(FSL_HAVE_RNGB) || defined(FSL_HAVE_RNGC)
 
 #include "rng_driver.h"
 
@@ -222,7 +298,7 @@
 
 #endif
 
-#endif				/* HAVE_SAHARA2 */
+#endif				/* HAVE SAHARA */
 
 #else				/* API_DOC */
 
@@ -237,7 +313,7 @@
  * These objects are used to pass information into and out of the API.  Through
  * flags and other settings, they control the behavior of the @ref opfuns.
  *
- * They are maninpulated and queried by use of the various access functions.
+ * They are manipulated and queried by use of the various access functions.
  * There are different sets defined for each object.  See @ref objman.
  */
 
@@ -292,6 +368,13 @@
  */
 
 /*!
+ * @defgroup ksoops Keystore Object Operations
+ *
+ * These operations should be the only access to the #fsl_shw_kso_t
+ * type/struct, as the internal members of that object are subject to change.
+ */
+
+/*!
  * @defgroup hcops Hash Context Object Operations
  *
  * These operations should be the only access to the #fsl_shw_hco_t
@@ -333,2098 +416,2100 @@
  * Enumerations
  *****************************************************************************/
 /*! @addtogroup consgrp
-    @} */
+    @{ */
 
 /*!
  * Flags for the state of the User Context Object (#fsl_shw_uco_t).
  *
  * These flags describe how the @ref opfuns will operate.
  */
-	typedef enum fsl_shw_user_ctx_flags_t
-	{
-		/**
-		 * API will block the caller until operation completes.  The result will be
-		 * available in the return code.  If this is not set, user will have to get
-		 * results using #fsl_shw_get_results().
-		 */
-		FSL_UCO_BLOCKING_MODE,
-		/**
-		 * User wants callback (at the function specified with
-		 * #fsl_shw_uco_set_callback()) when the operation completes.  This flag is
-		 * valid only if #FSL_UCO_BLOCKING_MODE is not set.
-		 */
-		FSL_UCO_CALLBACK_MODE,
-		/** Do not free descriptor chain after driver (adaptor) finishes */
-		FSL_UCO_SAVE_DESC_CHAIN,
-		/**
-		 * User has made at least one request with callbacks requested, so API is
-		 * ready to handle others.
-		 */
-		FSL_UCO_CALLBACK_SETUP_COMPLETE,
-		/**
-		 * (virtual) pointer to descriptor chain is completely linked with physical
-		 * (DMA) addresses, ready for the hardware.  This flag should not be used
-		 * by FSL SHW API programs.
-		 */
-		FSL_UCO_CHAIN_PREPHYSICALIZED,
-		/**
-		 * The user has changed the context but the changes have not been copied to
-		 * the kernel driver.
-		 */
-		FSL_UCO_CONTEXT_CHANGED,
-		/** Internal Use.  This context belongs to a user-mode API user. */
-		FSL_UCO_USERMODE_USER,
-	} fsl_shw_user_ctx_flags_t;
-	
-	
-	/**
-	 * Return code for FSL_SHW library.
-	 *
-	 * These codes may be returned from a function call.  In non-blocking mode,
-	 * they will appear as the status in a Result Object.
-	 */
-	typedef enum fsl_shw_return_t
-	{
-		/**
-		 * No error.  As a function return code in Non-blocking mode, this may
-		 * simply mean that the operation was accepted for eventual execution.
-		 */
-		FSL_RETURN_OK_S = 0,
-		/** Failure for non-specific reason. */
-		FSL_RETURN_ERROR_S,
-	   /**
-		* Operation failed because some resource was not able to be allocated.
-		*/
-		FSL_RETURN_NO_RESOURCE_S,
-		/** Crypto algorithm unrecognized or improper. */
-		FSL_RETURN_BAD_ALGORITHM_S,
-		/** Crypto mode unrecognized or improper. */
-		FSL_RETURN_BAD_MODE_S,
-		/** Flag setting unrecognized or inconsistent. */
-		FSL_RETURN_BAD_FLAG_S,
-		/** Improper or unsupported key length for algorithm. */
-		FSL_RETURN_BAD_KEY_LENGTH_S,
-		/** Improper parity in a (DES, TDES) key. */
-		FSL_RETURN_BAD_KEY_PARITY_S,
-		/**
-		 * Improper or unsupported data length for algorithm or internal buffer.
-		 */
-		FSL_RETURN_BAD_DATA_LENGTH_S,
-		/** Authentication / Integrity Check code check failed. */
-		FSL_RETURN_AUTH_FAILED_S,
-		/** A memory error occurred. */
-		FSL_RETURN_MEMORY_ERROR_S,
-		/** An error internal to the hardware occurred. */
-		FSL_RETURN_INTERNAL_ERROR_S,
-		/** ECC detected Point at Infinity */
-		FSL_RETURN_POINT_AT_INFINITY_S,
-		/** ECC detected No Point at Infinity */
-		FSL_RETURN_POINT_NOT_AT_INFINITY_S,
-		/** GCD is One */
-		FSL_RETURN_GCD_IS_ONE_S,
-		/** GCD is not One */
-		FSL_RETURN_GCD_IS_NOT_ONE_S,
-		/** Candidate is Prime */
-		FSL_RETURN_PRIME_S,
-		/** Candidate is not Prime */
-		FSL_RETURN_NOT_PRIME_S,
-		/** N register loaded improperly with even value */
-		FSL_RETURN_EVEN_MODULUS_ERROR_S,
-		/** Divisor is zero. */
-		FSL_RETURN_DIVIDE_BY_ZERO_ERROR_S,
-		/** Bad Exponent or Scalar value for Point Multiply */
-		FSL_RETURN_BAD_EXPONENT_ERROR_S,
-		/** RNG hardware problem. */
-		FSL_RETURN_OSCILLATOR_ERROR_S,
-		/** RNG hardware problem. */
-		FSL_RETURN_STATISTICS_ERROR_S,
-	} fsl_shw_return_t;
-	
-	
-	/**
-	 * Algorithm Identifier.
-	 *
-	 * Selection of algorithm will determine how large the block size of the
-	 * algorithm is.   Context size is the same length unless otherwise specified.
-	 * Selection of algorithm also affects the allowable key length.
-	 */
-	typedef enum fsl_shw_key_alg_t
-	{
-		FSL_KEY_ALG_HMAC,			/**< Key will be used to perform an HMAC.  Key
-									   size is 1 to 64 octets.	Block size is 64
-									   octets. */
-		FSL_KEY_ALG_AES,			/**< Advanced Encryption Standard (Rijndael).
-									   Block size is 16 octets.  Key size is 16
-									   octets.	(The single choice of key size is a
-									   Sahara platform limitation.) */
-		FSL_KEY_ALG_DES,			/**< Data Encryption Standard.	Block size is
-									   8 octets.  Key size is 8 octets. */
-		FSL_KEY_ALG_TDES,			/**< 2- or 3-key Triple DES.  Block size is 8
-									   octets.	Key size is 16 octets for 2-key
-									   Triple DES, and 24 octets for 3-key. */
-		FSL_KEY_ALG_ARC4			/**< ARC4.	No block size.	Context size is 259
-									   octets.	Allowed key size is 1-16 octets.
-									   (The choices for key size are a Sahara
-									   platform limitation.) */
-	} fsl_shw_key_alg_t;
-	
-	
-	/**
-	 * Mode selector for Symmetric Ciphers.
-	 *
-	 * The selection of mode determines how a cryptographic algorithm will be
-	 * used to process the plaintext or ciphertext.
-	 *
-	 * For all modes which are run block-by-block (that is, all but
-	 * #FSL_SYM_MODE_STREAM), any partial operations must be performed on a text
-	 * length which is multiple of the block size.	Except for #FSL_SYM_MODE_CTR,
-	 * these block-by-block algorithms must also be passed a total number of octets
-	 * which is a multiple of the block size.
-	 *
-	 * In modes which require that the total number of octets of data be a multiple
-	 * of the block size (#FSL_SYM_MODE_ECB and #FSL_SYM_MODE_CBC), and the user
-	 * has a total number of octets which are not a multiple of the block size, the
-	 * user must perform any necessary padding to get to the correct data length.
-	 */
-	typedef enum fsl_shw_sym_mode_t
-	{
-		/**
-		 * Stream.	There is no associated block size.	Any request to process data
-		 * may be of any length.  This mode is only for ARC4 operations, and is
-		 * also the only mode used for ARC4.
-		 */
-		FSL_SYM_MODE_STREAM,
-	
-		/**
-		 * Electronic Codebook.  Each block of data is encrypted/decrypted.  The
-		 * length of the data stream must be a multiple of the block size.	This
-		 * mode may be used for DES, 3DES, and AES.  The block size is determined
-		 * by the algorithm.
-		 */
-		FSL_SYM_MODE_ECB,
-		/**
-		 * Cipher-Block Chaining.  Each block of data is encrypted/decrypted and
-		 * then "chained" with the previous block by an XOR function.  Requires
-		 * context to start the XOR (previous block).  This mode may be used for
-		 * DES, 3DES, and AES.	The block size is determined by the algorithm.
-		 */
-		FSL_SYM_MODE_CBC,
-		/**
-		 * Counter.  The counter is encrypted, then XORed with a block of data.
-		 * The counter is then incremented (using modulus arithmetic) for the next
-		 * block. The final operation may be non-multiple of block size.  This mode
-		 * may be used for AES.  The block size is determined by the algorithm.
-		 */
-		FSL_SYM_MODE_CTR,
-	} fsl_shw_sym_mode_t;
-	
-	
-	/**
-	 * Algorithm selector for Cryptographic Hash functions.
-	 *
-	 * Selection of algorithm determines how large the context and digest will be.
-	 * Context is the same size as the digest (resulting hash), unless otherwise
-	 * specified.
-	 */
-	typedef enum fsl_shw_hash_alg_t
-	{
-		FSL_HASH_ALG_MD5,			/**< MD5 algorithm.  Digest is 16 octets. */
-		FSL_HASH_ALG_SHA1,			/**< SHA-1 (aka SHA or SHA-160) algorithm.
-									   Digest is 20 octets. */
-		FSL_HASH_ALG_SHA224,		/**< SHA-224 algorithm.  Digest is 28 octets,
-									   though context is 32 octets. */
-		FSL_HASH_ALG_SHA256 		/**< SHA-256 algorithm.  Digest is 32
-									   octets. */
-	} fsl_shw_hash_alg_t;
-	
-	
-	/**
-	 * The type of Authentication-Cipher function which will be performed.
-	 */
-	typedef enum fsl_shw_acc_mode_t
-	{
-		/**
-		 * CBC-MAC for Counter.  Requires context and modulus.	Final operation may
-		 * be non-multiple of block size.  This mode may be used for AES.
-		 */
-		FSL_ACC_MODE_CCM,
-		/**
-		 * SSL mode.  Not supported.  Combines HMAC and encrypt (or decrypt).
-		 * Needs one key object for encryption, another for the HMAC.  The usual
-		 * hashing and symmetric encryption algorithms are supported.
-		 */
-		FSL_ACC_MODE_SSL,
-	} fsl_shw_acc_mode_t;
-	
-	
-	/**
-	 * The operation which controls the behavior of #fsl_shw_establish_key().
-	 *
-	 * These values are passed to #fsl_shw_establish_key().
-	 */
-	typedef enum fsl_shw_key_wrap_t
-	{
-		FSL_KEY_WRAP_CREATE,		/**< Generate a key from random values. */
-		FSL_KEY_WRAP_ACCEPT,		/**< Use the provided clear key. */
-		FSL_KEY_WRAP_UNWRAP 		/**< Unwrap a previously wrapped key. */
-	} fsl_shw_key_wrap_t;
-	
-	
-	/* REQ-S2LRD-PINTFC-COA-HCO-001 */
-	/**
-	 * Flags which control a Hash operation.
-	 *
-	 *	These may be combined by ORing them together.  See #fsl_shw_hco_set_flags()
-	 * and #fsl_shw_hco_clear_flags().
-	 */
-	typedef enum fsl_shw_hash_ctx_flags_t
-	{
-		FSL_HASH_FLAGS_INIT = 1,		/**< Context is empty.	Hash is started
-										   from scratch, with a message-processed
-										   count of zero. */
-		FSL_HASH_FLAGS_SAVE = 2,		/**< Retrieve context from hardware after
-										   hashing.  If used with the
-                                       #FSL_HASH_FLAGS_FINALIZE flag, the final
-										   digest value will be saved in the
-										   object. */
-		FSL_HASH_FLAGS_LOAD = 4,		/**< Place context into hardware before
-										   hashing. */
-		FSL_HASH_FLAGS_FINALIZE = 8,	/**< PAD message and perform final digest
-										   operation.  If user message is
-										   pre-padded, this flag should not be
-										   used. */
-	} fsl_shw_hash_ctx_flags_t;
-	
-	
-	/**
-	 * Flags which control an HMAC operation.
-	 *
-	 * These may be combined by ORing them together.  See #fsl_shw_hmco_set_flags()
-	 * and #fsl_shw_hmco_clear_flags().
-	 */
-	typedef enum fsl_shw_hmac_ctx_flags_t
-	{
-		FSL_HMAC_FLAGS_INIT = 1,		/**< Message context is empty.	HMAC is
-										   started from scratch (with key) or from
-										   precompute of inner hash, depending on
-										   whether
-                                       #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT is
-										   set. */
-		FSL_HMAC_FLAGS_SAVE = 2,		/**< Retrieve ongoing context from hardware
-										   after hashing.  If used with the
-                                       #FSL_HMAC_FLAGS_FINALIZE flag, the final
-										   digest value (HMAC) will be saved in the
-										   object. */
-		FSL_HMAC_FLAGS_LOAD = 4,		/**< Place ongoing context into hardware
-										   before hashing. */
-		FSL_HMAC_FLAGS_FINALIZE = 8,	/**< PAD message and perform final HMAC
-										   operations of inner and outer hashes. */
-		FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT = 16 /**< This means that the context
-											contains precomputed inner and outer
-											hash values. */
-	} fsl_shw_hmac_ctx_flags_t;
-	
-	
-	/**
-	 * Flags to control use of the #fsl_shw_scco_t.
-	 *
-	 * These may be ORed together to get the desired effect.
-	 * See #fsl_shw_scco_set_flags() and #fsl_shw_scco_clear_flags()
-	 */
-	typedef enum fsl_shw_sym_ctx_flags_t
-	{
-		/**
-		 * Context is empty.  In ARC4, this means that the S-Box needs to be
-		 * generated from the key.	In #FSL_SYM_MODE_CBC mode, this allows an IV of
-		 * zero to be specified.  In #FSL_SYM_MODE_CTR mode, it means that an
-		 * initial CTR value of zero is desired.
-		 */
-		FSL_SYM_CTX_INIT = 1,
-		/**
-		 * Load context from object into hardware before running cipher.  In
-		 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
-		 */
-		FSL_SYM_CTX_LOAD = 2,
-		/**
-		 * Save context from hardware into object after running cipher.  In
-		 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
-		 */
-		FSL_SYM_CTX_SAVE = 4,
-		/**
-		 * Context (SBox) is to be unwrapped and wrapped on each use.
-		 * This flag is unsupported.
-		 * */
-		FSL_SYM_CTX_PROTECT = 8,
-	} fsl_shw_sym_ctx_flags_t;
-	
-	
-	/**
-	 * Flags which describe the state of the #fsl_shw_sko_t.
-	 *
-	 * These may be ORed together to get the desired effect.
-	 * See #fsl_shw_sko_set_flags() and #fsl_shw_sko_clear_flags()
-	 */
-	typedef enum fsl_shw_key_flags_t
-	{
-		FSL_SKO_KEY_IGNORE_PARITY = 1, /**< If algorithm is DES or 3DES, do not
-										  validate the key parity bits. */
-		FSL_SKO_KEY_PRESENT = 2,	   /**< Clear key is present in the object. */
-		FSL_SKO_KEY_ESTABLISHED = 4,   /**< Key has been established for use.  This
-										   feature is not available for all
-										   platforms, nor for all algorithms and
-										   modes.*/
-	} fsl_shw_key_flags_t;
-	
-	
-	/**
-	 * Type of value which is associated with an established key.
-	 */
-	typedef uint64_t key_userid_t;
-	
-	
-	/**
-	 * Flags which describe the state of the #fsl_shw_acco_t.
-	 *
-	 * The @a FSL_ACCO_CTX_INIT and @a FSL_ACCO_CTX_FINALIZE flags, when used
-	 * together, provide for a one-shot operation.
-	 */
-	typedef enum fsl_shw_auth_ctx_flags_t
-	{
-		FSL_ACCO_CTX_INIT = 1,		/**< Initialize Context(s) */
-		FSL_ACCO_CTX_LOAD = 2,		/**< Load intermediate context(s).
-									   This flag is unsupported. */
-		FSL_ACCO_CTX_SAVE = 4,		/**< Save intermediate context(s).
-									   This flag is unsupported. */
-		FSL_ACCO_CTX_FINALIZE = 8,	/**< Create MAC during this operation. */
-		FSL_ACCO_NIST_CCM = 16, 	/**< Formatting of CCM input data is
-										performed by calls to
-                                    #fsl_shw_ccm_nist_format_ctr_and_iv() and
-                                    #fsl_shw_ccm_nist_update_ctr_and_iv().  */
-	}  fsl_shw_auth_ctx_flags_t;
-	
-	
-	/**
-	 *	Modulus Selector for CTR modes.
-	 *
-	 * The incrementing of the Counter value may be modified by a modulus.	If no
-	 * modulus is needed or desired for AES, use #FSL_CTR_MOD_128.
-	 */
-	typedef enum fsl_shw_ctr_mod_t
-	{
-		FSL_CTR_MOD_8,				/**< Run counter with modulus of 2^8. */
-		FSL_CTR_MOD_16, 			/**< Run counter with modulus of 2^16. */
-		FSL_CTR_MOD_24, 			/**< Run counter with modulus of 2^24. */
-		FSL_CTR_MOD_32, 			/**< Run counter with modulus of 2^32. */
-		FSL_CTR_MOD_40, 			/**< Run counter with modulus of 2^40. */
-		FSL_CTR_MOD_48, 			/**< Run counter with modulus of 2^48. */
-		FSL_CTR_MOD_56, 			/**< Run counter with modulus of 2^56. */
-		FSL_CTR_MOD_64, 			/**< Run counter with modulus of 2^64. */
-		FSL_CTR_MOD_72, 			/**< Run counter with modulus of 2^72. */
-		FSL_CTR_MOD_80, 			/**< Run counter with modulus of 2^80. */
-		FSL_CTR_MOD_88, 			/**< Run counter with modulus of 2^88. */
-		FSL_CTR_MOD_96, 			/**< Run counter with modulus of 2^96. */
-		FSL_CTR_MOD_104,			/**< Run counter with modulus of 2^104. */
-		FSL_CTR_MOD_112,			/**< Run counter with modulus of 2^112. */
-		FSL_CTR_MOD_120,			/**< Run counter with modulus of 2^120. */
-		FSL_CTR_MOD_128 			/**< Run counter with modulus of 2^128. */
-	} fsl_shw_ctr_mod_t;
-	
-	
-	/**
-	 * Permissions flags for Secure Partitions
-	 *
-	 * They currently map directly to the SCC2 hardware values, but this is not
-	 * guarinteed behavior.
-	 */
-	typedef enum fsl_shw_permission_t
-	{
-	/** SCM Access Permission: Do not zeroize/deallocate partition on SMN Fail state */
-		FSL_PERM_NO_ZEROIZE,
-	/** SCM Access Permission: Enforce trusted key read in	*/
-		FSL_PERM_TRUSTED_KEY_READ,
-	/** SCM Access Permission: Ignore Supervisor/User mode in permission determination */
-		FSL_PERM_HD_S,
-	/** SCM Access Permission: Allow Read Access to  Host Domain */
-		FSL_PERM_HD_R,
-	/** SCM Access Permission: Allow Write Access to  Host Domain */
-		FSL_PERM_HD_W,
-	/** SCM Access Permission: Allow Execute Access to	Host Domain */
-		FSL_PERM_HD_X,
-	/** SCM Access Permission: Allow Read Access to Trusted Host Domain */
-		FSL_PERM_TH_R,
-	/** SCM Access Permission: Allow Write Access to Trusted Host Domain */
-		FSL_PERM_TH_W,
-	/** SCM Access Permission: Allow Read Access to Other/World Domain */
-		FSL_PERM_OT_R,
-	/** SCM Access Permission: Allow Write Access to Other/World Domain */
-		FSL_PERM_OT_W,
-	/** SCM Access Permission: Allow Execute Access to Other/World Domain */
-		FSL_PERM_OT_X,
-	} fsl_shw_permission_t;
-	
-	/**
-	 * Select the cypher mode to use for partition cover/uncover operations.
-	 *
-	 * They currently map directly to the values used in the SCC2 driver, but this
-	 * is not guarinteed behavior.
-	 */
-	typedef enum fsl_shw_cypher_mode_t
-	{
-		FSL_SHW_CYPHER_MODE_ECB,		  /**< ECB mode */
-		FSL_SHW_CYPHER_MODE_CBC,		  /**< CBC mode */
-	} fsl_shw_cypher_mode_t;
-	/** @} */ /* consgrp */
-	
-	
-	/******************************************************************************
-	 * Data Structures
-	 *****************************************************************************/
-	/** @addtogroup strgrp
-		@{ */
-	
-	/* REQ-S2LRD-PINTFC-COA-IBO-001 */
-	/**
-	 * Application Initialization Object
-	 *
-	 * This object, the operations on it, and its interaction with the driver are
-	 * TBD.
-	 */
-	typedef struct fsl_sho_ibo_t
-	{
-	} fsl_sho_ibo_t;
-	
-	
-	/* REQ-S2LRD-PINTFC-COA-UCO-001 */
-	/**
-	 * User Context Object
-	 *
-	 * This object must be initialized by a call to #fsl_shw_uco_init().  It must
-	 * then be passed to #fsl_shw_register_user() before it can be used in any
-	 * calls besides those in @ref ucoops.
-	 *
-	 * It contains the user's configuration for the API, for instance whether an
-	 * operation should block, or instead should call back the user upon completion
-	 * of the operation.
-	 *
-	 * See @ref ucoops for further information.
-	 */
-	typedef struct fsl_shw_uco_t	/* fsl_shw_user_context_object */
-	{
-	} fsl_shw_uco_t;
-	
-	
-	/* REQ-S2LRD-PINTFC-API-GEN-006  ??  */
-	/**
-	 * Result Object
-	 *
-	 * This object will contain success and failure information about a specific
-	 * cryptographic request which has been made.
-	 *
-	 * No direct access to its members should be made by programs.	Instead, the
-	 * object should be manipulated using the provided functions.  See @ref rops.
-	 */
-	typedef struct fsl_shw_result_t /* fsl_shw_result */
-	{
-	} fsl_shw_result_t;
-	
-	
-	/**
-	 * Keystore Object
-	 *
-	 * This object holds the context of a user keystore, including the functions
-	 * that define the interface and pointers to where the key data is stored.	The
-	 * user must supply a set of functions to handle keystore management, including
-	 * slot allocation, deallocation, etc.	A default keystore manager is provided
-	 * as part of the API.
-	 * 
-	 * No direct access to its members should be made by programs.	Instead, the
-	 * object should be manipulated using the provided functions.  See @ref ksoops.
-	 */
-	typedef struct fsl_shw_kso_t /* fsl_shw_keystore_object */
-	{
-	} fsl_shw_kso_t;
-	
-	
-	/* REQ-S2LRD-PINTFC-COA-SKO-001 */
-	/**
-	 * Secret Key Object
-	 *
-	 * This object contains a key for a cryptographic operation, and information
-	 * about its current state, its intended usage, etc.  It may instead contain
-	 * information about a protected key, or an indication to use a platform-
-	 * specific secret key.
-	 *
-	 * No direct access to its members should be made by programs.	Instead, the
-	 * object should be manipulated using the provided functions.  See @ref skoops.
-	 */
-	typedef struct fsl_shw_sko_t /* fsl_shw_secret_key_object */
-	{
-	} fsl_shw_sko_t;
-	
-	
-	/* REQ-S2LRD-PINTFC-COA-CO-001 */
-	/**
-	 * Platform Capabilities Object
-	 *
-	 * This object will contain information about the cryptographic features of the
-	 * platform which the program is running on.
-	 *
-	 * No direct access to its members should be made by programs.	Instead, the
-	 * object should be manipulated using the provided functions.
-	 *
-	 * See @ref pcoops.
-	 */
-	typedef struct fsl_shw_pco_t /* fsl_shw_platform_capabilities_object */
-	{
-	} fsl_shw_pco_t;
-	
-	
-	/* REQ-S2LRD-PINTFC-COA-HCO-001 */
-	/**
-	 * Hash Context Object
-	 *
-	 * This object contains information to control hashing functions.
-	
-	 * No direct access to its members should be made by programs.	Instead, the
-	 * object should be manipulated using the provided functions.  See @ref hcops.
-	 */
-	typedef struct fsl_shw_hco_t /* fsl_shw_hash_context_object */
-	{
-	} fsl_shw_hco_t;
-	
-	/**
-	 * HMAC Context Object
-	 *
-	 * This object contains information to control HMAC functions.
-	
-	 * No direct access to its members should be made by programs.	Instead, the
-	 * object should be manipulated using the provided functions.  See @ref hmcops.
-	 */
-	typedef struct fsl_shw_hmco_t /* fsl_shw_hmac_context_object */
-	{
-	} fsl_shw_hmco_t;
-	
-	
-	/* REQ-S2LRD-PINTFC-COA-SCCO-001 */
-	/**
-	 * Symmetric Cipher Context Object
-	 *
-	 * This object contains information to control Symmetric Ciphering encrypt and
-	 * decrypt functions in #FSL_SYM_MODE_STREAM (ARC4), #FSL_SYM_MODE_ECB,
-	 * #FSL_SYM_MODE_CBC, and #FSL_SYM_MODE_CTR modes and the
-	 * #fsl_shw_symmetric_encrypt() and #fsl_shw_symmetric_decrypt() functions.
-	 * CCM mode is controlled with the #fsl_shw_acco_t object.
-	 *
-	 * No direct access to its members should be made by programs.	Instead, the
-	 * object should be manipulated using the provided functions.  See @ref sccops.
-	 */
-	typedef struct fsl_shw_scco_t /* fsl_shw_symmetric_cipher_context_object */
-	{
-	} fsl_shw_scco_t;
-	
-	
-	/**
-	 * Authenticate-Cipher Context Object
-	
-	 * An object for controlling the function of, and holding information about,
-	 * data for the authenticate-cipher functions, #fsl_shw_gen_encrypt() and
-	 * #fsl_shw_auth_decrypt().
-	 *
-	 * No direct access to its members should be made by programs.	Instead, the
-	 * object should be manipulated using the provided functions.  See @ref
-	 * accoops.
-	 */
-	typedef struct fsl_shw_acco_t /* fsl_shw_authenticate_cipher_context_object */
-	{
-	} fsl_shw_acco_t;
-	/** @} */ /* strgrp */
-	
-	
-	/******************************************************************************
-	 * Access Macros for Objects
-	 *****************************************************************************/
-	/** @addtogroup pcoops
-		@{ */
-	
-	/**
-	 * Get FSL SHW API version
-	 *
-	 * @param	   pc_info	 The Platform Capabilities Object to query.
-	 * @param[out] major	 A pointer to where the major version
-	 *						 of the API is to be stored.
-	 * @param[out] minor	 A pointer to where the minor version
-	 *						 of the API is to be stored.
-	 */
-	void fsl_shw_pco_get_version(const fsl_shw_pco_t* pc_info,
-								 uint32_t* major, uint32_t* minor);
-	
-	
-	/**
-	 * Get underlying driver version.
-	 *
-	 * @param	   pc_info	 The Platform Capabilities Object to query.
-	 * @param[out] major	 A pointer to where the major version
-	 *						 of the driver is to be stored.
-	 * @param[out] minor	 A pointer to where the minor version
-	 *						 of the driver is to be stored.
-	 */
-	void fsl_shw_pco_get_driver_version(const fsl_shw_pco_t* pc_info,
-										uint32_t* major, uint32_t* minor);
-	
-	
-	/**
-	 * Get list of symmetric algorithms supported.
-	 *
-	 * @param pc_info	The Platform Capabilities Object to query.
-	 * @param[out] algorithms A pointer to where to store the location of
-	 *						  the list of algorithms.
-	 * @param[out] algorithm_count A pointer to where to store the number of
-	 *							   algorithms in the list at @a algorithms.
-	 */
-	void fsl_shw_pco_get_sym_algorithms(const fsl_shw_pco_t* pc_info,
-										fsl_shw_key_alg_t* algorithms[],
-										uint8_t* algorithm_count);
-	
-	
-	/**
-	 * Get list of symmetric modes supported.
-	 *
-	 * @param pc_info		  The Platform Capabilities Object to query.
-	 * @param[out] modes	  A pointer to where to store the location of
-	 *						  the list of modes.
-	 * @param[out] mode_count A pointer to where to store the number of
-	 *						  algorithms in the list at @a modes.
-	 */
-	void fsl_shw_pco_get_sym_modes(const fsl_shw_pco_t* pc_info,
-								   fsl_shw_sym_mode_t* modes[],
-								   uint8_t* mode_count);
-	
-	
-	/**
-	 * Get list of hash algorithms supported.
-	 *
-	 * @param pc_info		  The Platform Capabilities Object to query.
-	 * @param[out] algorithms A pointer which will be set to the list of
-	 *						  algorithms.
-	 * @param[out] algorithm_count The number of algorithms in the list at @a
-	 *							   algorithms.
-	 */
-	void fsl_shw_pco_get_hash_algorithms(const fsl_shw_pco_t* pc_info,
-										fsl_shw_hash_alg_t* algorithms[],
-										uint8_t* algorithm_count);
-	
-	
-	/**
-	 * Determine whether the combination of a given symmetric algorithm and a given
-	 * mode is supported.
-	 *
-	 * @param pc_info	 The Platform Capabilities Object to query.
-	 * @param algorithm  A Symmetric Cipher algorithm.
-	 * @param mode		 A Symmetric Cipher mode.
-	 *
-	 * @return 0 if combination is not supported, non-zero if supported.
-	 */
-	int fsl_shw_pco_check_sym_supported(const fsl_shw_pco_t* pc_info,
-										fsl_shw_key_alg_t algorithm,
-										fsl_shw_sym_mode_t mode);
-	
-	
-	/**
-	 * Determine whether a given Encryption-Authentication mode is supported.
-	 *
-	 * @param pc_info	The Platform Capabilities Object to query.
-	 * @param mode		 The Authentication mode.
-	 *
-	 * @return 0 if mode is not supported, non-zero if supported.
-	 */
-	int fsl_shw_pco_check_auth_supported(const fsl_shw_pco_t* pc_info,
-										 fsl_shw_acc_mode_t mode);
-	
-	
-	/**
-	 * Determine whether Black Keys (key establishment / wrapping) is supported.
-	 *
-	 * @param pc_info  The Platform Capabilities Object to query.
-	 *
-	 * @return 0 if wrapping is not supported, non-zero if supported.
-	 */
-	int fsl_shw_pco_check_black_key_supported(const fsl_shw_pco_t* pc_info);
-	
-	
-	/**
-	 * Get FSL SHW SCC driver version
-	 *
-	 * @param	   pc_info	 The Platform Capabilities Object to query.
-	 * @param[out] major	 A pointer to where the major version
-	 *						 of the SCC driver is to be stored.
-	 * @param[out] minor	 A pointer to where the minor version
-	 *						 of the SCC driver is to be stored.
-	 */
-	void fsl_shw_pco_get_scc_driver_version(const fsl_shw_pco_t* pc_info,
-											uint32_t* major, uint32_t* minor);
-	
-	
-	/**
-	 * Get SCM hardware version
-	 *
-	 * @param	   pc_info	 The Platform Capabilities Object to query.
-	 * @return				 The SCM hardware version
-	 */
-	uint32_t fsl_shw_pco_get_scm_version(const fsl_shw_pco_t* pc_info);
-	
-	
-	/**
-	 * Get SMN hardware version
-	 *
-	 * @param	   pc_info	 The Platform Capabilities Object to query.
-	 * @return				 The SMN hardware version
-	 */
-	uint32_t fsl_shw_pco_get_smn_version(const fsl_shw_pco_t* pc_info);
-	
-	
-	/**
-	 * Get the size of an SCM block, in bytes
-	 *
-	 * @param	   pc_info	 The Platform Capabilities Object to query.
-	 * @return				 The size of an SCM block, in bytes.
-	 */
-	uint32_t fsl_shw_pco_get_scm_block_size(const fsl_shw_pco_t* pc_info);
-	
-	
-	/**
-	 * Get size of Black and Red RAM memory
-	 *
-	 * @param	   pc_info	   The Platform Capabilities Object to query.
-	 * @param[out] black_size  A pointer to where the size of the Black RAM, in
-	 *						   blocks, is to be placed.
-	 * @param[out] red_size    A pointer to where the size of the Red RAM, in 
-	 *						   blocks, is to be placed.
-	 */
-	void fsl_shw_pco_get_smn_size(const fsl_shw_pco_t* pc_info,
-								  uint32_t* black_size, uint32_t* red_size);
-	
-	
-	/**
-	 * Determine whether Secure Partitions are supported
-	 *
-	 * @param pc_info		   The Platform Capabilities Object to query.
-	 *
-	 * @return 0 if secure partitions are not supported, non-zero if supported.
-	 */
-	int fsl_shw_pco_check_spo_supported(const fsl_shw_pco_t* pc_info);
-	
-	
-	/**
-	 * Get the size of a Secure Partitions
-	 *
-	 * @param pc_info		   The Platform Capabilities Object to query.
-	 * 
-	 * @return Partition size, in bytes.  0 if Secure Partitions not supported.
-	 */
-	uint32_t fsl_shw_pco_get_spo_size_bytes(const fsl_shw_pco_t* pc_info);
-	
-	
-	/**
-	 * Get the number of Secure Partitions on this platform
-	 *
-	 * @param pc_info		   The Platform Capabilities Object to query.
-	 * 
-	 * @return Number of partitions. 0 if Secure Partitions not supported.	Note
-	 *		   that this returns the total number of partitions, not all may be
-	 *		   available to the user.
-	 */
-	uint32_t fsl_shw_pco_get_spo_count(const fsl_shw_pco_t* pc_info);
-	
-	
-	/** @} */ /* pcoops */
-	
-	
-	/** @addtogroup ucoops
-		@{ */
-	
-	/**
-	 * Initialize a User Context Object.
-	 *
-	 * This function must be called before performing any other operation with the
-	 * Object.	It sets the User Context Object to initial values, and set the size
-	 * of the results pool.  The mode will be set to a default of
-	 * #FSL_UCO_BLOCKING_MODE.
-	 *
-	 * When using non-blocking operations, this sets the maximum number of
-	 * operations which can be outstanding.  This number includes the counts of
-	 * operations waiting to start, operation(s) being performed, and results which
-	 * have not been retrieved.
-	 *
-	 * Changes to this value are ignored once user registration has completed.	It
-	 * should be set to 1 if only blocking operations will ever be performed.
-	 *
-	 * @param user_ctx	   The User Context object to operate on.
-	 * @param pool_size    The maximum number of operations which can be
-	 *					   outstanding.
-	 */
-	void fsl_shw_uco_init(fsl_shw_uco_t* user_ctx, uint16_t pool_size);
-	
-	/**
-	 * Set the User Reference for the User Context.
-	 *
-	 * @param user_ctx	   The User Context object to operate on.
-	 * @param reference    A value which will be passed back with a result.
-	 */
-	void fsl_shw_uco_set_reference(fsl_shw_uco_t* user_ctx, uint32_t reference);
-	
-	
-	/**
-	 * Set the callback routine for the User Context.
-	 *
-	 * Note that the callback routine may be called when no results are available,
-	 * and possibly even when no requests are outstanding.
-	 *
-	 *
-	 * @param user_ctx	   The User Context object to operate on.
-	 * @param callback_fn  The function the API will invoke when an operation
-	 *					   completes.
-	 */
-	void fsl_shw_uco_set_callback(fsl_shw_uco_t* user_ctx,
-								  void (*callback_fn)(fsl_shw_uco_t* uco));
-	
-	/**
-	 * Set flags in the User Context.
-	 *
-	 * Turns on the flags specified in @a flags.  Other flags are untouched.
-	 *
-	 * @param user_ctx	   The User Context object to operate on.
-	 * @param flags 	   ORed values from #fsl_shw_user_ctx_flags_t.
-	 */
-	void fsl_shw_uco_set_flags(fsl_shw_uco_t* user_ctx, uint32_t flags);
-	
-	
-	/**
-	 * Clear flags in the User Context.
-	 *
-	 * Turns off the flags specified in @a flags.  Other flags are untouched.
-	 *
-	 * @param user_ctx	   The User Context object to operate on.
-	 * @param flags 	   ORed values from #fsl_shw_user_ctx_flags_t.
-	 */
-	void fsl_shw_uco_clear_flags(fsl_shw_uco_t* user_ctx, uint32_t flags);
-	
-	/** @} */ /* ucoops */
-	
-	
-	/** @addtogroup rops
-		@{ */
-	
-	/**
-	 * Retrieve the status code from a Result Object.
-	 *
-	 * @param result   The result object to query.
-	 *
-	 * @return The status of the request.
-	 */
-	fsl_shw_return_t fsl_shw_ro_get_status(fsl_shw_result_t* result);
-	
-	/**
-	 * Retrieve the reference value from a Result Object.
-	 *
-	 * @param result   The result object to query.
-	 *
-	 * @return The reference associated with the request.
-	 */
-	uint32_t fsl_shw_ro_get_reference(fsl_shw_result_t* result);
-	
-	
-	/* @} */ /* rops */
-	
-	
-	/** @addtogroup skoops
-		@{ */
-	
-	/**
-	 * Initialize a Secret Key Object.
-	 *
-	 * This function must be called before performing any other operation with
-	 * the Object.
-	 *
-	 * @param key_info	The Secret Key Object to be initialized.
-	 * @param algorithm DES, AES, etc.
-	 *
-	 */
-	void fsl_shw_sko_init(fsl_shw_sko_t* key_info, fsl_shw_key_alg_t algorithm);
-	
-	
-	/**
-	 * Store a cleartext key in the key object.
-	 *
-	 * This has the side effect of setting the #FSL_SKO_KEY_PRESENT flag and
-	 * resetting the #FSL_SKO_KEY_ESTABLISHED flag.
-	 *
-	 * @param key_object   A variable of type #fsl_shw_sko_t.
-	 * @param key		   A pointer to the beginning of the key.
-	 * @param key_length   The length, in octets, of the key.  The value should be
-	 *					   appropriate to the key size supported by the algorithm.
-	 *					   64 octets is the absolute maximum value allowed for this
-	 *					   call.
-	 */
-	void fsl_shw_sko_set_key(fsl_shw_sko_t* key_object,
-							 const uint8_t* key, uint16_t key_length);
-	
-	/**
-	 * Set a size for the key.
-	 *
-	 * This function would normally be used when the user wants the key to be
-	 * generated from a random source.
-	 *
-	 * @param key_object   A variable of type #fsl_shw_sko_t.
-	 * @param key_length   The length, in octets, of the key.  The value should be
-	 *					   appropriate to the key size supported by the algorithm.
-	 *					   64 octets is the absolute maximum value allowed for this
-	 *					   call.
-	 */
-	void fsl_shw_sko_set_key_length(fsl_shw_sko_t* key_object,
-									uint16_t key_length);
-	
-	
-	/**
-	 * Set the User ID associated with the key.
-	 *
-	 * @param key_object   A variable of type #fsl_shw_sko_t.
-	 * @param userid	   The User ID to identify authorized users of the key.
-	 */
-	void fsl_shw_sko_set_user_id(fsl_shw_sko_t* key_object, key_userid_t userid);
-	
-	
-	/**
-	 * Set the keystore that the key will be stored in.
-	 *
-	 * @param key_object	A variable of type #fsl_shw_sko_t.
-	 * @param keystore		The keystore to place the key in.  This is a variable of
-	 *						type #fsl_shw_kso_t.
-	 */
-	 void fsl_shw_sko_set_keystore(fsl_shw_sko_t* key_object, 
-								   fsl_shw_kso_t* keystore);
-	
-	
-	
-	/**
-	 * Set the establish key handle into a key object.
-	 *
-	 * The @a userid field will be used to validate the access to the unwrapped
-	 * key.  This feature is not available for all platforms, nor for all
-	 * algorithms and modes.
-	 *
-	 * The #FSL_SKO_KEY_ESTABLISHED will be set (and the #FSL_SKO_KEY_PRESENT
-	 * flag will be cleared).
-	 *
-	 * @param key_object   A variable of type #fsl_shw_sko_t.
-	 * @param userid	   The User ID to verify this user is an authorized user of
-	 *					   the key.
-	 * @param handle	   A @a handle from #fsl_shw_sko_get_established_info.
-	 */
-	void fsl_shw_sko_set_established_info(fsl_shw_sko_t* key_object,
-										  key_userid_t userid, uint32_t handle);
-	
-	
-	/**
-	 * Extract the algorithm from a key object.
-	 *
-	 * @param	   key_info  The Key Object to be queried.
-	 * @param[out] algorithm A pointer to the location to store the algorithm.
-	 */
-	void fsl_shw_sko_get_algorithm(const fsl_shw_sko_t* key_info,
-								   fsl_shw_key_alg_t* algorithm);
-	
-	/**
-	 * Retrieve the cleartext key from a key object that is stored in a user
-	 * keystore.
-	 *
-	 * @param	   skobject 	The Key Object to be queried.
-	 * @param[out] skkey		A pointer to the location to store the key.  NULL
-	 *							if the key is not stored in a user keystore.
-	 */
-	void fsl_shw_sko_get_key(const fsl_shw_sko_t* skobject,
-							 void* skkey);
-	
-	/**
-	 * Retrieve the established-key handle from a key object.
-	 *
-	 * @param key_object   A variable of type #fsl_shw_sko_t.
-	 * @param handle	   The location to store the @a handle of the unwrapped
-	 *					   key.
-	 */
-	void fsl_shw_sko_get_established_info(fsl_shw_sko_t* key_object,
-										  uint32_t* handle);
-	
-	
-	/**
-	 * Determine the size of a wrapped key based upon the cleartext key's length.
-	 *
-	 * This function can be used to calculate the number of octets that
-	 * #fsl_shw_extract_key() will write into the location at @a covered_key.
-	 *
-	 * If zero is returned at @a length, this means that the key length in
-	 * @a key_info is not supported.
-	 *
-	 * @param	   key_info 		Information about a key to be wrapped.
-	 * @param	   length			Location to store the length of a wrapped
-	 *								version of the key in @a key_info.
-	 */
-	void fsl_shw_sko_calculate_wrapped_size(const fsl_shw_sko_t* key_info,
-											uint32_t* length);
-	
-	
-	/**
-	 * Set some flags in the key object.
-	 *
-	 * Turns on the flags specified in @a flags.  Other flags are untouched.
-	 *
-	 * @param key_object   A variable of type #fsl_shw_sko_t.
-	 * @param flags 	   (One or more) ORed members of #fsl_shw_key_flags_t which
-	 *					   are to be set.
-	 */
-	void fsl_shw_sko_set_flags(fsl_shw_sko_t* key_object, uint32_t flags);
-	
-	
-	/**
-	 * Clear some flags in the key object.
-	 *
-	 * Turns off the flags specified in @a flags.  Other flags are untouched.
-	 *
-	 * @param key_object   A variable of type #fsl_shw_sko_t.
-	 * @param flags 	   (One or more) ORed members of #fsl_shw_key_flags_t which
-	 *						are to be reset.
-	 */
-	void fsl_shw_sko_clear_flags(fsl_shw_sko_t* key_object, uint32_t flags);
-	
-	/** @} */ /* end skoops */
-	
-	
-	/*****************************************************************************/
-	
-	/** @addtogroup hcops
-		@{ */
-	
-	/*****************************************************************************/
-	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-004 - partially */
-	/**
-	 * Initialize a Hash Context Object.
-	 *
-	 * This function must be called before performing any other operation with the
-	 * Object.	It sets the current message length and hash algorithm in the hash
-	 * context object.
-	 *
-	 * @param	   hash_ctx  The hash context to operate upon.
-	 * @param	   algorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
-	 *						 #FSL_HASH_ALG_SHA256, etc).
-	 *
-	 */
-	void fsl_shw_hco_init(fsl_shw_hco_t* hash_ctx, fsl_shw_hash_alg_t algorithm);
-	
-	
-	/*****************************************************************************/
-	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-001 */
-	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-002 */
-	/**
-	 * Get the current hash value and message length from the hash context object.
-	 *
-	 * The algorithm must have already been specified.	See #fsl_shw_hco_init().
-	 *
-	 * @param	   hash_ctx  The hash context to query.
-	 * @param[out] digest	 Pointer to the location of @a length octets where to
-	 *						 store a copy of the current value of the digest.
-	 * @param	   length	 Number of octets of hash value to copy.
-	 * @param[out] msg_length Pointer to the location to store the number of octets
-	 *						  already hashed.
-	 */
-	void fsl_shw_hco_get_digest(const fsl_shw_hco_t* hash_ctx, uint8_t* digest,
-								uint8_t length, uint32_t* msg_length);
-	
-	
-	/*****************************************************************************/
-	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-002 - partially */
-	/**
-	 * Get the hash algorithm from the hash context object.
-	 *
-	 * @param	   hash_ctx  The hash context to query.
-	 * @param[out] algorithm Pointer to where the algorithm is to be stored.
-	 */
-	void fsl_shw_hco_get_info(const fsl_shw_hco_t* hash_ctx,
-							  fsl_shw_hash_alg_t* algorithm);
-	
-	
-	/*****************************************************************************/
-	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-003 */
-	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-004 */
-	/**
-	 * Set the current hash value and message length in the hash context object.
-	 *
-	 * The algorithm must have already been specified.	See #fsl_shw_hco_init().
-	 *
-	 * @param	   hash_ctx  The hash context to operate upon.
-	 * @param	   context	 Pointer to buffer of appropriate length to copy into
-	 *						 the hash context object.
-	 * @param	   msg_length The number of octets of the message which have
-	 *						  already been hashed.
-	 *
-	 */
-	void fsl_shw_hco_set_digest(fsl_shw_hco_t* hash_ctx, const uint8_t* context,
-								uint32_t msg_length);
-	
-	
-	/**
-	 * Set flags in a Hash Context Object.
-	 *
-	 * Turns on the flags specified in @a flags.  Other flags are untouched.
-	 *
-	 * @param hash_ctx	 The hash context to be operated on.
-	 * @param flags 	 The flags to be set in the context.  These can be ORed
-	 *					 members of #fsl_shw_hash_ctx_flags_t.
-	 */
-	void fsl_shw_hco_set_flags(fsl_shw_hco_t* hash_ctx, uint32_t flags);
-	
-	
-	/**
-	 * Clear flags in a Hash Context Object.
-	 *
-	 * Turns off the flags specified in @a flags.  Other flags are untouched.
-	 *
-	 * @param hash_ctx	 The hash context to be operated on.
-	 * @param flags 	 The flags to be reset in the context.	These can be ORed
-	 *					 members of #fsl_shw_hash_ctx_flags_t.
-	 */
-	void fsl_shw_hco_clear_flags(fsl_shw_hco_t* hash_ctx, uint32_t flags);
-	
-	/** @} */ /* end hcops */
-	
-	
-	/*****************************************************************************/
-	
-	/** @addtogroup hmcops
-		@{ */
-	
-	/**
-	 * Initialize an HMAC Context Object.
-	 *
-	 * This function must be called before performing any other operation with the
-	 * Object.	It sets the current message length and hash algorithm in the HMAC
-	 * context object.
-	 *
-	 * @param	   hmac_ctx  The HMAC context to operate upon.
-	 * @param	   algorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
-	 *						 #FSL_HASH_ALG_SHA256, etc).
-	 *
-	 */
-	void fsl_shw_hmco_init(fsl_shw_hmco_t* hmac_ctx, fsl_shw_hash_alg_t algorithm);
-	
-	/**
-	 * Set flags in an HMAC Context Object.
-	 *
-	 * Turns on the flags specified in @a flags.  Other flags are untouched.
-	 *
-	 * @param hmac_ctx	 The HMAC context to be operated on.
-	 * @param flags 	 The flags to be set in the context.  These can be ORed
-	 *					 members of #fsl_shw_hmac_ctx_flags_t.
-	 */
-	void fsl_shw_hmco_set_flags(fsl_shw_hmco_t* hmac_ctx, uint32_t flags);
-	
-	
-	/**
-	 * Clear flags in an HMAC Context Object.
-	 *
-	 * Turns off the flags specified in @a flags.  Other flags are untouched.
-	 *
-	 * @param hmac_ctx	 The HMAC context to be operated on.
-	 * @param flags 	 The flags to be reset in the context.	These can be ORed
-	 *					 members of #fsl_shw_hmac_ctx_flags_t.
-	 */
-	void fsl_shw_hmco_clear_flags(fsl_shw_hmco_t* hmac_ctx, uint32_t flags);
-	
-	
-	/** @} */
-	
-	/*****************************************************************************/
-	
-	/** @addtogroup sccops
-		@{ */
-	
-	/**
-	 * Initialize a Symmetric Cipher Context Object.
-	 *
-	 * This function must be called before performing any other operation with the
-	 * Object.	This will set the @a mode and @a algorithm and initialize the
-	 * Object.
-	 *
-	 * @param sym_ctx	The context object to operate on.
-	 * @param algorithm The cipher algorithm this context will be used with.
-	 * @param mode		#FSL_SYM_MODE_CBC, #FSL_SYM_MODE_ECB, etc.
-	 *
-	 */
-	void fsl_shw_scco_init(fsl_shw_scco_t* sym_ctx,
-						   fsl_shw_key_alg_t algorithm,
-						   fsl_shw_sym_mode_t mode);
-	
-	
-	/**
-	 * Set the flags for a Symmetric Cipher Context.
-	 *
-	 * Turns on the flags specified in @a flags.  Other flags are untouched.
-	 *
-	 * @param sym_ctx  The context object to operate on.
-	 * @param flags    The flags to reset (one or more values from
-	 *				   #fsl_shw_sym_ctx_flags_t ORed together).
-	 *
-	 */
-	void fsl_shw_scco_set_flags(fsl_shw_scco_t* sym_ctx, uint32_t flags);
-	
-	
-	/**
-	 * Clear some flags in a Symmetric Cipher Context Object.
-	 *
-	 * Turns off the flags specified in @a flags.  Other flags are untouched.
-	 *
-	 * @param sym_ctx  The context object to operate on.
-	 * @param flags    The flags to reset (one or more values from
-	 *				   #fsl_shw_sym_ctx_flags_t ORed together).
-	 *
-	 */
-	void fsl_shw_scco_clear_flags(fsl_shw_scco_t* sym_ctx, uint32_t flags);
-	
-	
-	/**
-	 * Set the Context (IV) for a Symmetric Cipher Context.
-	 *
-	 * This is to set the context/IV for #FSL_SYM_MODE_CBC mode, or to set the
-	 * context (the S-Box and pointers) for ARC4.  The full context size will
-	 * be copied.
-	 *
-	 * @param sym_ctx  The context object to operate on.
-	 * @param context  A pointer to the buffer which contains the context.
-	 *
-	 */
-	void fsl_shw_scco_set_context(fsl_shw_scco_t* sym_ctx, uint8_t* context);
-	
-	
-	
-	/**
-	 * Get the Context for a Symmetric Cipher Context.
-	 *
-	 * This is to retrieve the context/IV for #FSL_SYM_MODE_CBC mode, or to
-	 * retrieve context (the S-Box and pointers) for ARC4.	The full context
-	 * will be copied.
-	 *
-	 * @param	   sym_ctx	The context object to operate on.
-	 * @param[out] context	Pointer to location where context will be stored.
-	 */
-	void fsl_shw_scco_get_context(const fsl_shw_scco_t* sym_ctx, uint8_t* context);
-	
-	
-	/**
-	 * Set the Counter Value for a Symmetric Cipher Context.
-	 *
-	 * This will set the Counter Value for CTR mode.
-	 *
-	 * @param sym_ctx  The context object to operate on.
-	 * @param counter  The starting counter value.	The number of octets.
-	 *				   copied will be the block size for the algorithm.
-	 * @param modulus  The modulus for controlling the incrementing of the counter.
-	 *
-	 */
-	void fsl_shw_scco_set_counter_info(fsl_shw_scco_t* sym_ctx,
-									   const uint8_t* counter,
-									   fsl_shw_ctr_mod_t modulus);
-	
-	
-	/**
-	 * Get the Counter Value for a Symmetric Cipher Context.
-	 *
-	 * This will retrieve the Counter Value is for CTR mode.
-	 *
-	 * @param sym_ctx		  The context object to query.
-	 * @param[out] counter	  Pointer to location to store the current counter
-	 *						  value.  The number of octets copied will be the
-	 *						  block size for the algorithm.
-	 * @param[out] modulus	  Pointer to location to store the modulus.
-	 *
-	 */
-	void fsl_shw_scco_get_counter_info(const fsl_shw_scco_t* sym_ctx,
-									   uint8_t* counter,
-									   fsl_shw_ctr_mod_t* modulus);
-	
-	/** @} */ /* end sccops */
-	
-	
-	/*****************************************************************************/
-	
-	/** @addtogroup accoops
-		@{ */
-	
-	/**
-	 * Initialize a Authentication-Cipher Context.
-	 *
-	 * @param auth_object  Pointer to object to operate on.
-	 * @param mode		   The mode for this object (only #FSL_ACC_MODE_CCM
-	 *					   supported).
-	 */
-	void fsl_shw_acco_init(fsl_shw_acco_t* auth_object, fsl_shw_acc_mode_t mode);
-	
-	
-	/**
-	 * Set the flags for a Authentication-Cipher Context.
-	 *
-	 * Turns on the flags specified in @a flags.  Other flags are untouched.
-	 *
-	 * @param auth_object  Pointer to object to operate on.
-	 * @param flags 	   The flags to set (one or more from
-	 *					   #fsl_shw_auth_ctx_flags_t ORed together).
-	 *
-	 */
-	void fsl_shw_acco_set_flags(fsl_shw_acco_t* auth_object, uint32_t flags);
-	
-	
-	/**
-	 * Clear some flags in a Authentication-Cipher Context Object.
-	 *
-	 * Turns off the flags specified in @a flags.  Other flags are untouched.
-	 *
-	 * @param auth_object  Pointer to object to operate on.
-	 * @param flags 	   The flags to reset (one or more from
-	 *					   #fsl_shw_auth_ctx_flags_t ORed together).
-	 *
-	 */
-	void fsl_shw_acco_clear_flags(fsl_shw_acco_t* auth_object, uint32_t flags);
-	
-	
-	/**
-	 * Set up the Authentication-Cipher Object for CCM mode.
-	 *
-	 * This will set the @a auth_object for CCM mode and save the @a ctr,
-	 * and @a mac_length.  This function can be called instead of
-	 * #fsl_shw_acco_init().
-	 *
-	 * The parameter @a ctr is Counter Block 0, (counter value 0), which is for the
-	 * MAC.
-	 *
-	 * @param auth_object  Pointer to object to operate on.
-	 * @param algorithm    Cipher algorithm.  Only AES is supported.
-	 * @param ctr		   The initial counter value.
-	 * @param mac_length   The number of octets used for the MAC.  Valid values are
-	 *					   4, 6, 8, 10, 12, 14, and 16.
-	 */
-	void fsl_shw_acco_set_ccm(fsl_shw_acco_t* auth_object,
-							  fsl_shw_key_alg_t algorithm,
-							  const uint8_t* ctr,
-							  uint8_t mac_length);
-	
-	
-	/**
-	 * Format the First Block (IV) & Initial Counter Value per NIST CCM.
-	 *
-	 * This function will also set the IV and CTR values per Appendix A of NIST
-	 * Special Publication 800-38C (May 2004).	It will also perform the
-	 * #fsl_shw_acco_set_ccm() operation with information derived from this set of
-	 * parameters.
-	 *
-	 * Note this function assumes the algorithm is AES.  It initializes the
-	 * @a auth_object by setting the mode to #FSL_ACC_MODE_CCM and setting the
-	 * flags to be #FSL_ACCO_NIST_CCM.
-	 *
-	 * @param auth_object  Pointer to object to operate on.
-	 * @param t_length	   The number of octets used for the MAC.  Valid values are
-	 *					   4, 6, 8, 10, 12, 14, and 16.
-	 * @param ad_length    Number of octets of Associated Data (may be zero).
-	 * @param q_length	   A value for the size of the length of @a q field.  Valid
-	 *					   values are 1-8.
-	 * @param n 		   The Nonce (packet number or other changing value). Must
-	 *					   be (15 - @a q_length) octets long.
-	 * @param q 		   The value of Q (size of the payload in octets).
-	 *
-	 */
-	void fsl_shw_ccm_nist_format_ctr_and_iv(fsl_shw_acco_t* auth_object,
-											uint8_t t_length,
-											uint32_t ad_length,
-											uint8_t q_length,
-											const uint8_t* n, uint32_t q);
-	
-	
-	/**
-	 * Update the First Block (IV) & Initial Counter Value per NIST CCM.
-	 *
-	 * This function will set the IV and CTR values per Appendix A of NIST Special
-	 * Publication 800-38C (May 2004).
-	 *
-	 * Note this function assumes that #fsl_shw_ccm_nist_format_ctr_and_iv() has
-	 * previously been called on the @a auth_object.
-	 *
-	 * @param auth_object  Pointer to object to operate on.
-	 * @param n 			The Nonce (packet number or other changing value). Must
-	 *						be (15 - @a q_length) octets long.
-	 * @param q 			The value of Q (size of the payload in octets).
-	 *
-	 */
-	void fsl_shw_ccm_nist_update_ctr_and_iv(fsl_shw_acco_t* auth_object,
-											const uint8_t* n, uint32_t q);
-	
-	
-	/* @} */ /* accoops */
-	
-	
-	/******************************************************************************
-	 * Library functions
-	 *****************************************************************************/
-	
-	/** @addtogroup miscfuns
-		@{ */
-	
-	/* REQ-S2LRD-PINTFC-API-GEN-003 */
-	/**
-	 * Determine the hardware security capabilities of this platform.
-	 *
-	 * Though a user context object is passed into this function, it will always
-	 * act in a non-blocking manner.
-	 *
-	 * @param  user_ctx   The user context which will be used for the query.
-	 *
-	 * @return	A pointer to the capabilities object.
-	 */
-	extern fsl_shw_pco_t* fsl_shw_get_capabilities(fsl_shw_uco_t* user_ctx);
-	
-	
-	/* REQ-S2LRD-PINTFC-API-GEN-004 */
-	/**
-	 * Create an association between the user and the provider of the API.
-	 *
-	 * @param  user_ctx   The user context which will be used for this association.
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t* user_ctx);
-	
-	
-	/* REQ-S2LRD-PINTFC-API-GEN-005 */
-	/**
-	 * Destroy the association between the user and the provider of the API.
-	 *
-	 * @param  user_ctx   The user context which is no longer needed.
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t* user_ctx);
-	
-	
-	/* REQ-S2LRD-PINTFC-API-GEN-006 */
-	/**
-	 * Retrieve results from earlier operations.
-	 *
-	 * @param		  user_ctx	   The user's context.
-	 * @param		  result_size  The number of array elements of @a results.
-	 * @param[in,out] results	   Pointer to first of the (array of) locations to
-	 *							   store results.
-	 * @param[out]	  result_count Pointer to store the number of results which
-	 *							   were returned.
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t* user_ctx,
-												uint16_t result_size,
-												fsl_shw_result_t results[],
-												uint16_t* result_count);
-	
-	
-	/**
-	 * Allocate a block of secure memory
-	 *
-	 * @param		user_ctx		User context
-	 * @param		size			Memory size (octets).  Note: currently only
-	 *								supports only single-partition sized blocks.
-	 * @param		UMID			User Mode ID to use when registering the
-	 *								partition.
-	 * @param		permissions 	Permissions to initialize the partition with.
-	 *								Can be made by ORing flags from the
-	 *								#fsl_shw_permission_t.
-	 *
-	 * @return						Address of the allocated memory.  NULL if the
-	 *								call was not successful.
-	 */
-	extern void* fsl_shw_smalloc(fsl_shw_uco_t* user_ctx,
-								 uint32_t size,
-								 const uint8_t *UMID,
-								 uint32_t permissions);
-	
-	
-	/**
-	 * Free a block of secure memory that was allocated with #fsl_shw_smalloc
-	 *
-	 * @param		user_ctx		User context
-	 * @param		address 		Address of the block of secure memory to be
-	 *								released.
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_sfree(
-									fsl_shw_uco_t* user_ctx,
-									void *address);
-	
-	
-	/**
-	 * Diminish the permissions of a block of secure memory.  Note that permissions
-	 * can only be revoked.
-	 *
-	 * @param		user_ctx		User context
-	 * @param		address 		Base address of the secure memory to work with
-	 * @param		permissions 	Permissions to initialize the partition with.
-	 *								Can be made by ORing flags from the
-	 *								#fsl_shw_permission_t.
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_diminish_perms(
-									fsl_shw_uco_t* user_ctx,
-									void *address,
-									uint32_t permissions);
-	
-	
-	/**
-	 * @brief	Encrypt a region of secure memory using the hardware secret key
-	 *
-	 * @param		user_ctx		User context
-	 * @param		partition_base	Base address of the partition
-	 * @param		offset_bytes	Offset of data from the partition base
-	 * @param		byte_count		Length of the data to encrypt
-	 * @param		black_data		Location to store the encrypted data
-	 * @param		IV				IV to use for the encryption routine
-	 * @param		cypher_mode 	Cyphering mode to use, specified by type
-	 *								#fsl_shw_cypher_mode_t
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t 
-	do_scc_encrypt_region(fsl_shw_uco_t* user_ctx,
-						  void* partition_base, uint32_t offset_bytes,
-						  uint32_t byte_count, uint8_t* black_data,
-						  uint32_t* IV, fsl_shw_cypher_mode_t cypher_mode);
-	
-	
-	/**
-	 * @brief	Decrypt a region of secure memory using the hardware secret key
-	 *
-	 * @param		user_ctx		User context
-	 * @param		partition_base	Base address of the partition
-	 * @param		offset_bytes	Offset of data from the partition base
-	 * @param		byte_count		Length of the data to encrypt
-	 * @param		black_data		Location to store the encrypted data
-	 * @param		IV				IV to use for the encryption routine
-	 * @param		cypher_mode 	Cyphering mode to use, specified by type
-	 *								#fsl_shw_cypher_mode_t
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t 
-	do_scc_decrypt_region(fsl_shw_uco_t* user_ctx,
-						  void* partition_base, uint32_t offset_bytes,
-						  uint32_t byte_count, const uint8_t* black_data,
-						  uint32_t* IV, fsl_shw_cypher_mode_t cypher_mode);
-	
-	
-	/** @} */ /* miscfuns */
-	
-	
-	/** @addtogroup opfuns
-		@{ */
-	
-	/* REQ-S2LRD-PINTFC-API-BASIC-SYM-002 */
-	/* PINTFC-API-BASIC-SYM-ARC4-001 */
-	/* PINTFC-API-BASIC-SYM-ARC4-002 */
-	/**
-	 * Encrypt a stream of data with a symmetric-key algorithm.
-	 *
-	 * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
-	 * flags of the @a sym_ctx object will control part of the operation of this
-	 * function.  The #FSL_SYM_CTX_INIT flag means that there is no context info in
-	 * the object.	The #FSL_SYM_CTX_LOAD means to use information in the
-	 * @a sym_ctx at the start of the operation, and the #FSL_SYM_CTX_SAVE flag
-	 * means to update the object's context information after the operation has
-	 * been performed.
-	 *
-	 * All of the data for an operation can be run through at once using the
-	 * #FSL_SYM_CTX_INIT or #FSL_SYM_CTX_LOAD flags, as appropriate, and then using
-	 * a @a length for the whole of the data.
-	 *
-	 * If a #FSL_SYM_CTX_SAVE flag were added, an additional call to the function
-	 * would "pick up" where the previous call left off, allowing the user to
-	 * perform the larger function in smaller steps.
-	 *
-	 * In #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_ECB modes, the @a length must always
-	 * be a multiple of the block size for the algorithm being used.  For proper
-	 * operation in #FSL_SYM_MODE_CTR mode, the @a length must be a multiple of the
-	 * block size until the last operation on the total octet stream.
-	 *
-	 * Some users of ARC4 may want to compute the context (S-Box and pointers) from
-	 * the key before any data is available.  This may be done by running this
-	 * function with a @a length of zero, with the init & save flags flags on in
-	 * the @a sym_ctx.	Subsequent operations would then run as normal with the
-	 * load and save flags.  Note that they key object is still required.
-	 *
-	 * @param		  user_ctx	A user context from #fsl_shw_register_user().
-	 * @param		  key_info	Key and algorithm  being used for this operation.
-	 * @param[in,out] sym_ctx	Info on cipher mode, state of the cipher.
-	 * @param		  length   Length, in octets, of the pt (and ct).
-	 * @param		  pt	   pointer to plaintext to be encrypted.
-	 * @param[out]	  ct	   pointer to where to store the resulting ciphertext.
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 *
-	 */
-	extern fsl_shw_return_t fsl_shw_symmetric_encrypt(
-									fsl_shw_uco_t* user_ctx,
-									fsl_shw_sko_t* key_info,
-									fsl_shw_scco_t* sym_ctx,
-									uint32_t length,
-									const uint8_t* pt,
-									uint8_t* ct);
-	
-	/* PINTFC-API-BASIC-SYM-002 */
-	/* PINTFC-API-BASIC-SYM-ARC4-001 */
-	/* PINTFC-API-BASIC-SYM-ARC4-002 */
-	/**
-	 * Decrypt a stream of data with a symmetric-key algorithm.
-	 *
-	 * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
-	 * flags of the @a sym_ctx object will control part of the operation of this
-	 * function.  The #FSL_SYM_CTX_INIT flag means that there is no context info in
-	 * the object.	The #FSL_SYM_CTX_LOAD means to use information in the
-	 * @a sym_ctx at the start of the operation, and the #FSL_SYM_CTX_SAVE flag
-	 * means to update the object's context information after the operation has
-	 * been performed.
-	 *
-	 * All of the data for an operation can be run through at once using the
-	 * #FSL_SYM_CTX_INIT or #FSL_SYM_CTX_LOAD flags, as appropriate, and then using
-	 * a @a length for the whole of the data.
-	 *
-	 * If a #FSL_SYM_CTX_SAVE flag were added, an additional call to the function
-	 * would "pick up" where the previous call left off, allowing the user to
-	 * perform the larger function in smaller steps.
-	 *
-	 * In #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_ECB modes, the @a length must always
-	 * be a multiple of the block size for the algorithm being used.  For proper
-	 * operation in #FSL_SYM_MODE_CTR mode, the @a length must be a multiple of the
-	 * block size until the last operation on the total octet stream.
-	 *
-	 * Some users of ARC4 may want to compute the context (S-Box and pointers) from
-	 * the key before any data is available.  This may be done by running this
-	 * function with a @a length of zero, with the #FSL_SYM_CTX_INIT &
-	 * #FSL_SYM_CTX_SAVE flags on in the @a sym_ctx.  Subsequent operations would
-	 * then run as normal with the load & save flags.  Note that they key object is
-	 * still required.
-	 *
-	 * @param	   user_ctx  A user context from #fsl_shw_register_user().
-	 * @param	   key_info The key and algorithm being used in this operation.
-	 * @param[in,out] sym_ctx Info on cipher mode, state of the cipher.
-	 * @param	   length	Length, in octets, of the ct (and pt).
-	 * @param	   ct		pointer to ciphertext to be decrypted.
-	 * @param[out] pt		pointer to where to store the resulting plaintext.
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t
-	 *
-	 */
-	extern fsl_shw_return_t fsl_shw_symmetric_decrypt(
-									fsl_shw_uco_t* user_ctx,
-									fsl_shw_sko_t* key_info,
-									fsl_shw_scco_t* sym_ctx,
-									uint32_t length,
-									const uint8_t* ct,
-									uint8_t* pt);
-	
-	
-	/* REQ-S2LRD-PINTFC-API-BASIC-HASH-005 */
-	/**
-	 * Hash a stream of data with a cryptographic hash algorithm.
-	 *
-	 * The flags in the @a hash_ctx control the operation of this function.
-	 *
-	 * Hashing functions work on 64 octets of message at a time.  Therefore, when
-	 * any partial hashing of a long message is performed, the message @a length of
-	 * each segment must be a multiple of 64.  When ready to
-	 * #FSL_HASH_FLAGS_FINALIZE the hash, the @a length may be any value.
-	 *
-	 * With the #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_FINALIZE flags on, a
-	 * one-shot complete hash, including padding, will be performed.  The @a length
-	 * may be any value.
-	 *
-	 * The first octets of a data stream can be hashed by setting the
-	 * #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_SAVE flags.  The @a length must be
-	 * a multiple of 64.
-	 *
-	 * The flag #FSL_HASH_FLAGS_LOAD is used to load a context previously saved by
-	 * #FSL_HASH_FLAGS_SAVE.  The two in combination will allow a (multiple-of-64
-	 * octets) 'middle sequence' of the data stream to be hashed with the
-	 * beginning.  The @a length must again be a multiple of 64.
-	 *
-	 * Since the flag #FSL_HASH_FLAGS_LOAD is used to load a context previously
-	 * saved by #FSL_HASH_FLAGS_SAVE, the #FSL_HASH_FLAGS_LOAD and
-	 * #FSL_HASH_FLAGS_FINALIZE flags, used together, can be used to finish the
-	 * stream.	The @a length may be any value.
-	 *
-	 * If the user program wants to do the padding for the hash, it can leave off
-	 * the #FSL_HASH_FLAGS_FINALIZE flag.  The @a length must then be a multiple of
-	 * 64 octets.
-	 *
-	 * @param	   user_ctx  A user context from #fsl_shw_register_user().
-	 * @param[in,out] hash_ctx Hashing algorithm and state of the cipher.
-	 * @param	   msg		 Pointer to the data to be hashed.
-	 * @param	   length	 Length, in octets, of the @a msg.
-	 * @param[out] result	 If not null, pointer to where to store the hash
-	 *						 digest.
-	 * @param	   result_len Number of octets to store in @a result.
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_hash(
-									fsl_shw_uco_t* user_ctx,
-									fsl_shw_hco_t* hash_ctx,
-									const uint8_t* msg,
-									uint32_t length,
-									uint8_t* result,
-									uint32_t result_len);
-	
-	
-	/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-001 */
-	/**
-	 * Precompute the Key hashes for an HMAC operation.
-	 *
-	 * This function may be used to calculate the inner and outer precomputes,
-	 * which are the hash contexts resulting from hashing the XORed key for the
-	 * 'inner hash' and the 'outer hash', respectively, of the HMAC function.
-	 *
-	 * After execution of this function, the @a hmac_ctx will contain the
-	 * precomputed inner and outer contexts, so that they may be used by
-	 * #fsl_shw_hmac().  The flags of @a hmac_ctx will be updated with
-	 * #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT to mark their presence.	In addition, the
-	 * #FSL_HMAC_FLAGS_INIT flag will be set.
-	 *
-	 * @param	   user_ctx  A user context from #fsl_shw_register_user().
-	 * @param	   key_info  The key being used in this operation.	Key must be
-	 *						 1 to 64 octets long.
-	 * @param[in,out] hmac_ctx The context which controls, by its flags and
-	 *						   algorithm, the operation of this function.
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_hmac_precompute(
-									fsl_shw_uco_t* user_ctx,
-									fsl_shw_sko_t* key_info,
-									fsl_shw_hmco_t* hmac_ctx);
-	
-	
-	/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-002 */
-	/**
-	 * Continue, finalize, or one-shot an HMAC operation.
-	 *
-	 * There are a number of ways to use this function.  The flags in the
-	 * @a hmac_ctx object will determine what operations occur.
-	 *
-	 * If #FSL_HMAC_FLAGS_INIT is set, then the hash will be started either from
-	 * the @a key_info, or from the precomputed inner hash value in the
-	 * @a hmac_ctx, depending on the value of #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT.
-	 *
-	 * If, instead, #FSL_HMAC_FLAGS_LOAD is set, then the hash will be continued
-	 * from the ongoing inner hash computation in the @a hmac_ctx.
-	 *
-	 * If #FSL_HMAC_FLAGS_FINALIZE are set, then the @a msg will be padded, hashed,
-	 * the outer hash will be performed, and the @a result will be generated.
-	 *
-	 * If the #FSL_HMAC_FLAGS_SAVE flag is set, then the (ongoing or final) digest
-	 * value will be stored in the ongoing inner hash computation field of the @a
-	 * hmac_ctx.
-	 *
-	 * @param	   user_ctx  A user context from #fsl_shw_register_user().
-	 * @param key_info		 If #FSL_HMAC_FLAGS_INIT is set in the @a hmac_ctx,
-	 *						 this is the key being used in this operation, and the
-	 *						 IPAD.	If #FSL_HMAC_FLAGS_INIT is set in the @a
-	 *						 hmac_ctx and @a key_info is NULL, then
-	 *						 #fsl_shw_hmac_precompute() has been used to populate
-	 *						 the @a inner_precompute and @a outer_precompute
-	 *						 contexts.	If #FSL_HMAC_FLAGS_INIT is not set, this
-	 *						 parameter is ignored.
-	
-	 * @param[in,out] hmac_ctx The context which controls, by its flags and
-	 *						 algorithm, the operation of this function.
-	 * @param	   msg				 Pointer to the message to be hashed.
-	 * @param	   length			 Length, in octets, of the @a msg.
-	 * @param[out] result			 Pointer, of @a result_len octets, to where to
-	 *								 store the HMAC.
-	 * @param	   result_len		 Length of @a result buffer.
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_hmac(
-									fsl_shw_uco_t* user_ctx,
-									fsl_shw_sko_t* key_info,
-									fsl_shw_hmco_t* hmac_ctx,
-									const uint8_t* msg,
-									uint32_t length,
-									uint8_t* result,
-									uint32_t result_len);
-	
-	
-	/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
-	/**
-	 * Get random data.
-	 *
-	 * @param	   user_ctx  A user context from #fsl_shw_register_user().
-	 * @param	   length	 The number of octets of @a data being requested.
-	 * @param[out] data 	 A pointer to a location of @a length octets to where
-	 *						 random data will be returned.
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_get_random(
-									fsl_shw_uco_t* user_ctx,
-									uint32_t length,
-									uint8_t* data);
-	
-	
-	/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
-	/**
-	 * Add entropy to random number generator.
-	 *
-	 * @param	   user_ctx  A user context from #fsl_shw_register_user().
-	 * @param	   length	 Number of bytes at @a data.
-	 * @param	   data 	 Entropy to add to random number generator.
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_add_entropy(
-									fsl_shw_uco_t* user_ctx,
-									uint32_t length,
-									uint8_t* data);
-	
-	
-	/**
-	 * Perform Generation-Encryption by doing a Cipher and a Hash.
-	 *
-	 * Generate the authentication value @a auth_value as well as encrypt the @a
-	 * payload into @a ct (the ciphertext).  This is a one-shot function, so all of
-	 * the @a auth_data and the total message @a payload must passed in one call.
-	 * This also means that the flags in the @a auth_ctx must be #FSL_ACCO_CTX_INIT
-	 * and #FSL_ACCO_CTX_FINALIZE.
-	 *
-	 * @param	   user_ctx 		A user context from #fsl_shw_register_user().
-	 * @param	   auth_ctx 		Controlling object for Authenticate-decrypt.
-	 * @param	   cipher_key_info	The key being used for the cipher part of this
-	 *								operation.	In CCM mode, this key is used for
-	 *								both parts.
-	 * @param	   auth_key_info	The key being used for the authentication part
-	 *								of this operation.	In CCM mode, this key is
-	 *								ignored and may be NULL.
-	 * @param	   auth_data_length Length, in octets, of @a auth_data.
-	 * @param	   auth_data		Data to be authenticated but not encrypted.
-	 * @param	   payload_length	Length, in octets, of @a payload.
-	 * @param	   payload			Pointer to the plaintext to be encrypted.
-	 * @param[out] ct				Pointer to the where the encrypted @a payload
-	 *								will be stored.  Must be @a payload_length
-	 *								octets long.
-	 * @param[out] auth_value		Pointer to where the generated authentication
-	 *								field will be stored. Must be as many octets as
-	 *								indicated by MAC length in the @a function_ctx.
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_gen_encrypt(
-									fsl_shw_uco_t* user_ctx,
-									fsl_shw_acco_t* auth_ctx,
-									fsl_shw_sko_t* cipher_key_info,
-									fsl_shw_sko_t* auth_key_info,
-									uint32_t auth_data_length,
-									const uint8_t* auth_data,
-									uint32_t payload_length,
-									const uint8_t* payload,
-									uint8_t* ct,
-									uint8_t* auth_value);
-	
-	
-	/**
-	 * Perform Authentication-Decryption in Cipher + Hash.
-	 *
-	 * This function will perform a one-shot decryption of a data stream as well as
-	 * authenticate the authentication value.  This is a one-shot function, so all
-	 * of the @a auth_data and the total message @a payload must passed in one
-	 * call.  This also means that the flags in the @a auth_ctx must be
-	 * #FSL_ACCO_CTX_INIT and #FSL_ACCO_CTX_FINALIZE.
-	 *
-	 * @param	   user_ctx 		A user context from #fsl_shw_register_user().
-	 * @param	   auth_ctx 		Controlling object for Authenticate-decrypt.
-	 * @param	   cipher_key_info	The key being used for the cipher part of this
-	 *								operation.	In CCM mode, this key is used for
-	 *								both parts.
-	 * @param	   auth_key_info	The key being used for the authentication part
-	 *								of this operation.	In CCM mode, this key is
-	 *								ignored and may be NULL.
-	 * @param	   auth_data_length Length, in octets, of @a auth_data.
-	 * @param	   auth_data		Data to be authenticated but not decrypted.
-	 * @param	   payload_length	Length, in octets, of @a ct and @a pt.
-	 * @param	   ct				Pointer to the encrypted input stream.
-	 * @param	   auth_value		The (encrypted) authentication value which will
-	 *								be authenticated.  This is the same data as the
-	 *								(output) @a auth_value argument to
-	 *								#fsl_shw_gen_encrypt().
-	 * @param[out] payload			Pointer to where the plaintext resulting from
-	 *								the decryption will be stored.
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_auth_decrypt(
-									fsl_shw_uco_t* user_ctx,
-									fsl_shw_acco_t* auth_ctx,
-									fsl_shw_sko_t* cipher_key_info,
-									fsl_shw_sko_t* auth_key_info,
-									uint32_t auth_data_length,
-									const uint8_t* auth_data,
-									uint32_t payload_length,
-									const uint8_t* ct,
-									const uint8_t* auth_value,
-									uint8_t* payload);
-	
-	
-	/**
-	 * Establish the key in a protected location, either in the system keystore or
-	 * a user keystore.
-	 *
-	 * If the key is established in the system keystore, it can only be used for
-	 * hardware encrypt or decrypt operations.	If a user keystore is used, then
-	 * the user is responsible for setting the correct access permissions on their
-	 * secure partition.  The key will be placed in the system	keystore by
-	 * default, unless the user has called #fsl_shw_sko_set_keystore() to specify a
-	 * user keystore.
-	 *
-	 * This only needs to be used to a) unwrap a key, or b) set up a key which
-	 * could be wrapped with a later call to #fsl_shw_extract_key().  Normal
-	 * cleartext keys can simply be placed into #fsl_shw_sko_t key objects with
-	 * #fsl_shw_sko_set_key() and used directly.
-	 *
-	 * The maximum key size supported for wrapped/unwrapped keys is 32 octets.
-	 * (This is the maximum reasonable key length on Sahara - 32 octets for an HMAC
-	 * key based on SHA-256.)  The key size is determined by the @a key_info.  The
-	 * expected length of @a key can be determined by
-	 * #fsl_shw_sko_calculate_wrapped_size()
-	 *
-	 * The protected key will not be available for use until this operation
-	 * successfully completes.
-	 *
-	 * This feature is not available for all platforms, nor for all algorithms and
-	 * modes.
-	 *
-	 * @param	   user_ctx 		A user context from #fsl_shw_register_user().
-	 * @param[in,out] key_info		The information about the key to be which will
-	 *								be established.  In the create case, the key
-	 *								length must be set.
-	 * @param	   establish_type	How @a key will be interpreted to establish a
-	 *								key for use.
-	 * @param key					If @a establish_type is #FSL_KEY_WRAP_UNWRAP,
-	 *								this is the location of a wrapped key.	If
-	 *								@a establish_type is #FSL_KEY_WRAP_CREATE, this
-	 *								parameter can be @a NULL.  If @a establish_type
-	 *								is #FSL_KEY_WRAP_ACCEPT, this is the location
-	 *								of a plaintext key.
-	 */
-	extern fsl_shw_return_t fsl_shw_establish_key(
-									fsl_shw_uco_t* user_ctx,
-									fsl_shw_sko_t* key_info,
-									fsl_shw_key_wrap_t establish_type,
-									const uint8_t* key);
-	
-	
-	/**
-	 * Wrap a key and retrieve the wrapped value.
-	 *
-	 * A wrapped key is a key that has been cryptographically obscured.  It is
-	 * only able to be used with #fsl_shw_establish_key().
-	 *
-	 * This function will also release the key (see #fsl_shw_release_key()) so
-	 * that it must be re-established before reuse.
-	 *
-	 * This feature is not available for all platforms, nor for all algorithms and
-	 * modes.
-	 *
-	 * @param	   user_ctx 		A user context from #fsl_shw_register_user().
-	 * @param	   key_info 		The information about the key to be deleted.
-	 * @param[out] covered_key		The location to store the wrapped key.
-	 *								(This size is based upon the maximum key size
-	 *								of 32 octets).
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t* user_ctx,
-												fsl_shw_sko_t* key_info,
-												uint8_t* covered_key);
-	
-	
-	/**
-	 * De-establish a key so that it can no longer be accessed.
-	 *
-	 * The key will need to be re-established before it can again be used.
-	 *
-	 * This feature is not available for all platforms, nor for all algorithms and
-	 * modes.
-	 *
-	 * @param	   user_ctx 		A user context from #fsl_shw_register_user().
-	 * @param	   key_info 		The information about the key to be deleted.
-	 *
-	 * @return	  A return code of type #fsl_shw_return_t.
-	 */
-	extern fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t* user_ctx,
-												fsl_shw_sko_t* key_info);
-	
-	/** @} */ /* opfuns */
-	
-	
-	
-	
-	
-	/* Insert example code into the API documentation. */
-	
-	/**
-	 * @example apitest.c
-	 */
-	
-	/**
-	 * @example sym.c
-	 */
-	
-	/**
-	 * @example rand.c
-	 */
-	
-	/**
-	 * @example hash.c
-	 */
-	
-	/**
-	 * @example hmac1.c
-	 */
-	
-	/**
-	 * @example hmac2.c
-	 */
-	
-	/**
-	 * @example gen_encrypt.c
-	 */
-	
-	/**
-	 * @example auth_decrypt.c
-	 */
-	
-	/**
-	 * @example wrapped_key.c
-	 */
-	
-	/**
-	 * @example smalloc.c
-	 */
-	
-	/**
-	 * @example user_keystore.c
+typedef enum fsl_shw_user_ctx_flags_t {
+	/*!
+	 * API will block the caller until operation completes.  The result will be
+	 * available in the return code.  If this is not set, user will have to get
+	 * results using #fsl_shw_get_results().
+	 */
+	FSL_UCO_BLOCKING_MODE,
+	/*!
+	 * User wants callback (at the function specified with
+	 * #fsl_shw_uco_set_callback()) when the operation completes.  This flag is
+	 * valid only if #FSL_UCO_BLOCKING_MODE is not set.
+	 */
+	FSL_UCO_CALLBACK_MODE,
+	/*! Do not free descriptor chain after driver (adaptor) finishes */
+	FSL_UCO_SAVE_DESC_CHAIN,
+	/*!
+	 * User has made at least one request with callbacks requested, so API is
+	 * ready to handle others.
+	 */
+	FSL_UCO_CALLBACK_SETUP_COMPLETE,
+	/*!
+	 * (virtual) pointer to descriptor chain is completely linked with physical
+	 * (DMA) addresses, ready for the hardware.  This flag should not be used
+	 * by FSL SHW API programs.
+	 */
+	FSL_UCO_CHAIN_PREPHYSICALIZED,
+	/*!
+	 * The user has changed the context but the changes have not been copied to
+	 * the kernel driver.
+	 */
+	FSL_UCO_CONTEXT_CHANGED,
+	/*! Internal Use.  This context belongs to a user-mode API user. */
+	FSL_UCO_USERMODE_USER,
+} fsl_shw_user_ctx_flags_t;
+
+/*!
+ * Return code for FSL_SHW library.
+ *
+ * These codes may be returned from a function call.  In non-blocking mode,
+ * they will appear as the status in a Result Object.
+ */
+typedef enum fsl_shw_return_t {
+	/*!
+	 * No error.  As a function return code in Non-blocking mode, this may
+	 * simply mean that the operation was accepted for eventual execution.
+	 */
+	FSL_RETURN_OK_S = 0,
+	/*! Failure for non-specific reason. */
+	FSL_RETURN_ERROR_S,
+	/*!
+	 * Operation failed because some resource was not able to be allocated.
+	 */
+	FSL_RETURN_NO_RESOURCE_S,
+	/*! Crypto algorithm unrecognized or improper. */
+	FSL_RETURN_BAD_ALGORITHM_S,
+	/*! Crypto mode unrecognized or improper. */
+	FSL_RETURN_BAD_MODE_S,
+	/*! Flag setting unrecognized or inconsistent. */
+	FSL_RETURN_BAD_FLAG_S,
+	/*! Improper or unsupported key length for algorithm. */
+	FSL_RETURN_BAD_KEY_LENGTH_S,
+	/*! Improper parity in a (DES, TDES) key. */
+	FSL_RETURN_BAD_KEY_PARITY_S,
+	/*!
+	 * Improper or unsupported data length for algorithm or internal buffer.
+	 */
+	FSL_RETURN_BAD_DATA_LENGTH_S,
+	/*! Authentication / Integrity Check code check failed. */
+	FSL_RETURN_AUTH_FAILED_S,
+	/*! A memory error occurred. */
+	FSL_RETURN_MEMORY_ERROR_S,
+	/*! An error internal to the hardware occurred. */
+	FSL_RETURN_INTERNAL_ERROR_S,
+	/*! ECC detected Point at Infinity */
+	FSL_RETURN_POINT_AT_INFINITY_S,
+	/*! ECC detected No Point at Infinity */
+	FSL_RETURN_POINT_NOT_AT_INFINITY_S,
+	/*! GCD is One */
+	FSL_RETURN_GCD_IS_ONE_S,
+	/*! GCD is not One */
+	FSL_RETURN_GCD_IS_NOT_ONE_S,
+	/*! Candidate is Prime */
+	FSL_RETURN_PRIME_S,
+	/*! Candidate is not Prime */
+	FSL_RETURN_NOT_PRIME_S,
+	/*! N register loaded improperly with even value */
+	FSL_RETURN_EVEN_MODULUS_ERROR_S,
+	/*! Divisor is zero. */
+	FSL_RETURN_DIVIDE_BY_ZERO_ERROR_S,
+	/*! Bad Exponent or Scalar value for Point Multiply */
+	FSL_RETURN_BAD_EXPONENT_ERROR_S,
+	/*! RNG hardware problem. */
+	FSL_RETURN_OSCILLATOR_ERROR_S,
+	/*! RNG hardware problem. */
+	FSL_RETURN_STATISTICS_ERROR_S,
+} fsl_shw_return_t;
+
+/*!
+ * Algorithm Identifier.
+ *
+ * Selection of algorithm will determine how large the block size of the
+ * algorithm is.   Context size is the same length unless otherwise specified.
+ * Selection of algorithm also affects the allowable key length.
+ */
+typedef enum fsl_shw_key_alg_t {
+	FSL_KEY_ALG_HMAC,	/*!< Key will be used to perform an HMAC.  Key
+				   size is 1 to 64 octets.  Block size is 64
+				   octets. */
+	FSL_KEY_ALG_AES,	/*!< Advanced Encryption Standard (Rijndael).
+				   Block size is 16 octets.  Key size is 16
+				   octets.  (The single choice of key size is a
+				   Sahara platform limitation.) */
+	FSL_KEY_ALG_DES,	/*!< Data Encryption Standard.  Block size is
+				   8 octets.  Key size is 8 octets. */
+	FSL_KEY_ALG_TDES,	/*!< 2- or 3-key Triple DES.  Block size is 8
+				   octets.  Key size is 16 octets for 2-key
+				   Triple DES, and 24 octets for 3-key. */
+	FSL_KEY_ALG_ARC4	/*!< ARC4.  No block size.  Context size is 259
+				   octets.  Allowed key size is 1-16 octets.
+				   (The choices for key size are a Sahara
+				   platform limitation.) */
+} fsl_shw_key_alg_t;
+
+/*!
+ * Mode selector for Symmetric Ciphers.
+ *
+ * The selection of mode determines how a cryptographic algorithm will be
+ * used to process the plaintext or ciphertext.
+ *
+ * For all modes which are run block-by-block (that is, all but
+ * #FSL_SYM_MODE_STREAM), any partial operations must be performed on a text
+ * length which is multiple of the block size.  Except for #FSL_SYM_MODE_CTR,
+ * these block-by-block algorithms must also be passed a total number of octets
+ * which is a multiple of the block size.
+ *
+ * In modes which require that the total number of octets of data be a multiple
+ * of the block size (#FSL_SYM_MODE_ECB and #FSL_SYM_MODE_CBC), and the user
+ * has a total number of octets which are not a multiple of the block size, the
+ * user must perform any necessary padding to get to the correct data length.
+ */
+typedef enum fsl_shw_sym_mode_t {
+	/*!
+	 * Stream.  There is no associated block size.  Any request to process data
+	 * may be of any length.  This mode is only for ARC4 operations, and is
+	 * also the only mode used for ARC4.
 	 */
+	FSL_SYM_MODE_STREAM,
 
+	/*!
+	 * Electronic Codebook.  Each block of data is encrypted/decrypted.  The
+	 * length of the data stream must be a multiple of the block size.  This
+	 * mode may be used for DES, 3DES, and AES.  The block size is determined
+	 * by the algorithm.
+	 */
+	FSL_SYM_MODE_ECB,
+	/*!
+	 * Cipher-Block Chaining.  Each block of data is encrypted/decrypted and
+	 * then "chained" with the previous block by an XOR function.  Requires
+	 * context to start the XOR (previous block).  This mode may be used for
+	 * DES, 3DES, and AES.  The block size is determined by the algorithm.
+	 */
+	FSL_SYM_MODE_CBC,
+	/*!
+	 * Counter.  The counter is encrypted, then XORed with a block of data.
+	 * The counter is then incremented (using modulus arithmetic) for the next
+	 * block. The final operation may be non-multiple of block size.  This mode
+	 * may be used for AES.  The block size is determined by the algorithm.
+	 */
+	FSL_SYM_MODE_CTR,
+} fsl_shw_sym_mode_t;
 
-#endif				/* API_DOC */
+/*!
+ * Algorithm selector for Cryptographic Hash functions.
+ *
+ * Selection of algorithm determines how large the context and digest will be.
+ * Context is the same size as the digest (resulting hash), unless otherwise
+ * specified.
+ */
+typedef enum fsl_shw_hash_alg_t {
+	FSL_HASH_ALG_MD5,	/*!< MD5 algorithm.  Digest is 16 octets. */
+	FSL_HASH_ALG_SHA1,	/*!< SHA-1 (aka SHA or SHA-160) algorithm.
+				   Digest is 20 octets. */
+	FSL_HASH_ALG_SHA224,	/*!< SHA-224 algorithm.  Digest is 28 octets,
+				   though context is 32 octets. */
+	FSL_HASH_ALG_SHA256	/*!< SHA-256 algorithm.  Digest is 32
+				   octets. */
+} fsl_shw_hash_alg_t;
+
+/*!
+ * The type of Authentication-Cipher function which will be performed.
+ */
+typedef enum fsl_shw_acc_mode_t {
+	/*!
+	 * CBC-MAC for Counter.  Requires context and modulus.  Final operation may
+	 * be non-multiple of block size.  This mode may be used for AES.
+	 */
+	FSL_ACC_MODE_CCM,
+	/*!
+	 * SSL mode.  Not supported.  Combines HMAC and encrypt (or decrypt).
+	 * Needs one key object for encryption, another for the HMAC.  The usual
+	 * hashing and symmetric encryption algorithms are supported.
+	 */
+	FSL_ACC_MODE_SSL,
+} fsl_shw_acc_mode_t;
+
+/*!
+ * The operation which controls the behavior of #fsl_shw_establish_key().
+ *
+ * These values are passed to #fsl_shw_establish_key().
+ */
+typedef enum fsl_shw_key_wrap_t {
+	FSL_KEY_WRAP_CREATE,	/*!< Generate a key from random values. */
+	FSL_KEY_WRAP_ACCEPT,	/*!< Use the provided clear key. */
+	FSL_KEY_WRAP_UNWRAP	/*!< Unwrap a previously wrapped key. */
+} fsl_shw_key_wrap_t;
+
+/* REQ-S2LRD-PINTFC-COA-HCO-001 */
+/*!
+ * Flags which control a Hash operation.
+ *
+ *  These may be combined by ORing them together.  See #fsl_shw_hco_set_flags()
+ * and #fsl_shw_hco_clear_flags().
+ */
+typedef enum fsl_shw_hash_ctx_flags_t {
+	FSL_HASH_FLAGS_INIT = 1,	/*!< Context is empty.  Hash is started
+					   from scratch, with a message-processed
+					   count of zero. */
+	FSL_HASH_FLAGS_SAVE = 2,	/*!< Retrieve context from hardware after
+					   hashing.  If used with the
+					   #FSL_HASH_FLAGS_FINALIZE flag, the final
+					   digest value will be saved in the
+					   object. */
+	FSL_HASH_FLAGS_LOAD = 4,	/*!< Place context into hardware before
+					   hashing. */
+	FSL_HASH_FLAGS_FINALIZE = 8,	/*!< PAD message and perform final digest
+					   operation.  If user message is
+					   pre-padded, this flag should not be
+					   used. */
+} fsl_shw_hash_ctx_flags_t;
+
+/*!
+ * Flags which control an HMAC operation.
+ *
+ * These may be combined by ORing them together.  See #fsl_shw_hmco_set_flags()
+ * and #fsl_shw_hmco_clear_flags().
+ */
+typedef enum fsl_shw_hmac_ctx_flags_t {
+	FSL_HMAC_FLAGS_INIT = 1,	/*!< Message context is empty.  HMAC is
+					   started from scratch (with key) or from
+					   precompute of inner hash, depending on
+					   whether
+					   #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT is
+					   set. */
+	FSL_HMAC_FLAGS_SAVE = 2,	/*!< Retrieve ongoing context from hardware
+					   after hashing.  If used with the
+					   #FSL_HMAC_FLAGS_FINALIZE flag, the final
+					   digest value (HMAC) will be saved in the
+					   object. */
+	FSL_HMAC_FLAGS_LOAD = 4,	/*!< Place ongoing context into hardware
+					   before hashing. */
+	FSL_HMAC_FLAGS_FINALIZE = 8,	/*!< PAD message and perform final HMAC
+					   operations of inner and outer hashes. */
+	FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT = 16	/*!< This means that the context
+						   contains precomputed inner and outer
+						   hash values. */
+} fsl_shw_hmac_ctx_flags_t;
+
+/*!
+ * Flags to control use of the #fsl_shw_scco_t.
+ *
+ * These may be ORed together to get the desired effect.
+ * See #fsl_shw_scco_set_flags() and #fsl_shw_scco_clear_flags()
+ */
+typedef enum fsl_shw_sym_ctx_flags_t {
+	/*!
+	 * Context is empty.  In ARC4, this means that the S-Box needs to be
+	 * generated from the key.  In #FSL_SYM_MODE_CBC mode, this allows an IV of
+	 * zero to be specified.  In #FSL_SYM_MODE_CTR mode, it means that an
+	 * initial CTR value of zero is desired.
+	 */
+	FSL_SYM_CTX_INIT = 1,
+	/*!
+	 * Load context from object into hardware before running cipher.  In
+	 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+	 */
+	FSL_SYM_CTX_LOAD = 2,
+	/*!
+	 * Save context from hardware into object after running cipher.  In
+	 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+	 */
+	FSL_SYM_CTX_SAVE = 4,
+	/*!
+	 * Context (SBox) is to be unwrapped and wrapped on each use.
+	 * This flag is unsupported.
+	 * */
+	FSL_SYM_CTX_PROTECT = 8,
+} fsl_shw_sym_ctx_flags_t;
+
+/*!
+ * Flags which describe the state of the #fsl_shw_sko_t.
+ *
+ * These may be ORed together to get the desired effect.
+ * See #fsl_shw_sko_set_flags() and #fsl_shw_sko_clear_flags()
+ */
+typedef enum fsl_shw_key_flags_t {
+	FSL_SKO_KEY_IGNORE_PARITY = 1,	/*!< If algorithm is DES or 3DES, do not
+					   validate the key parity bits. */
+	FSL_SKO_KEY_PRESENT = 2,	/*!< Clear key is present in the object. */
+	FSL_SKO_KEY_ESTABLISHED = 4,	/*!< Key has been established for use.  This
+					   feature is not available for all
+					   platforms, nor for all algorithms and
+					   modes. */
+	FSL_SKO_KEY_SW_KEY = 8,	/*!< This key is for software use, and can
+				   be copied out of a keystore by its owner.
+				   The default is that they key is available
+				   only for hardware (or security driver)
+				   use. */
+} fsl_shw_key_flags_t;
+
+/*!
+ * Type of value which is associated with an established key.
+ */
+typedef uint64_t key_userid_t;
+
+/*!
+ * Flags which describe the state of the #fsl_shw_acco_t.
+ *
+ * The @a FSL_ACCO_CTX_INIT and @a FSL_ACCO_CTX_FINALIZE flags, when used
+ * together, provide for a one-shot operation.
+ */
+typedef enum fsl_shw_auth_ctx_flags_t {
+	FSL_ACCO_CTX_INIT = 1,	/*!< Initialize Context(s) */
+	FSL_ACCO_CTX_LOAD = 2,	/*!< Load intermediate context(s).
+				   This flag is unsupported. */
+	FSL_ACCO_CTX_SAVE = 4,	/*!< Save intermediate context(s).
+				   This flag is unsupported. */
+	FSL_ACCO_CTX_FINALIZE = 8,	/*!< Create MAC during this operation. */
+	FSL_ACCO_NIST_CCM = 16,	/*!< Formatting of CCM input data is
+				   performed by calls to
+				   #fsl_shw_ccm_nist_format_ctr_and_iv() and
+				   #fsl_shw_ccm_nist_update_ctr_and_iv().  */
+} fsl_shw_auth_ctx_flags_t;
+
+/*!
+ *  Modulus Selector for CTR modes.
+ *
+ * The incrementing of the Counter value may be modified by a modulus.  If no
+ * modulus is needed or desired for AES, use #FSL_CTR_MOD_128.
+ */
+typedef enum fsl_shw_ctr_mod_t {
+	FSL_CTR_MOD_8,		/*!< Run counter with modulus of 2^8. */
+	FSL_CTR_MOD_16,		/*!< Run counter with modulus of 2^16. */
+	FSL_CTR_MOD_24,		/*!< Run counter with modulus of 2^24. */
+	FSL_CTR_MOD_32,		/*!< Run counter with modulus of 2^32. */
+	FSL_CTR_MOD_40,		/*!< Run counter with modulus of 2^40. */
+	FSL_CTR_MOD_48,		/*!< Run counter with modulus of 2^48. */
+	FSL_CTR_MOD_56,		/*!< Run counter with modulus of 2^56. */
+	FSL_CTR_MOD_64,		/*!< Run counter with modulus of 2^64. */
+	FSL_CTR_MOD_72,		/*!< Run counter with modulus of 2^72. */
+	FSL_CTR_MOD_80,		/*!< Run counter with modulus of 2^80. */
+	FSL_CTR_MOD_88,		/*!< Run counter with modulus of 2^88. */
+	FSL_CTR_MOD_96,		/*!< Run counter with modulus of 2^96. */
+	FSL_CTR_MOD_104,	/*!< Run counter with modulus of 2^104. */
+	FSL_CTR_MOD_112,	/*!< Run counter with modulus of 2^112. */
+	FSL_CTR_MOD_120,	/*!< Run counter with modulus of 2^120. */
+	FSL_CTR_MOD_128		/*!< Run counter with modulus of 2^128. */
+} fsl_shw_ctr_mod_t;
+
+/*!
+ * Permissions flags for Secure Partitions
+ *
+ * They currently map directly to the SCC2 hardware values, but this is not
+ * guarinteed behavior.
+ */
+typedef enum fsl_shw_permission_t {
+/*! SCM Access Permission: Do not zeroize/deallocate partition on SMN Fail state */
+	FSL_PERM_NO_ZEROIZE,
+/*! SCM Access Permission: Enforce trusted key read in  */
+	FSL_PERM_TRUSTED_KEY_READ,
+/*! SCM Access Permission: Ignore Supervisor/User mode in permission determination */
+	FSL_PERM_HD_S,
+/*! SCM Access Permission: Allow Read Access to  Host Domain */
+	FSL_PERM_HD_R,
+/*! SCM Access Permission: Allow Write Access to  Host Domain */
+	FSL_PERM_HD_W,
+/*! SCM Access Permission: Allow Execute Access to  Host Domain */
+	FSL_PERM_HD_X,
+/*! SCM Access Permission: Allow Read Access to Trusted Host Domain */
+	FSL_PERM_TH_R,
+/*! SCM Access Permission: Allow Write Access to Trusted Host Domain */
+	FSL_PERM_TH_W,
+/*! SCM Access Permission: Allow Read Access to Other/World Domain */
+	FSL_PERM_OT_R,
+/*! SCM Access Permission: Allow Write Access to Other/World Domain */
+	FSL_PERM_OT_W,
+/*! SCM Access Permission: Allow Execute Access to Other/World Domain */
+	FSL_PERM_OT_X,
+} fsl_shw_permission_t;
+
+/*!
+ * Select the cypher mode to use for partition cover/uncover operations.
+ *
+ * They currently map directly to the values used in the SCC2 driver, but this
+ * is not guarinteed behavior.
+ */
+typedef enum fsl_shw_cypher_mode_t {
+	FSL_SHW_CYPHER_MODE_ECB,	/*!< ECB mode */
+	FSL_SHW_CYPHER_MODE_CBC,	/*!< CBC mode */
+} fsl_shw_cypher_mode_t;
+
+/*!
+ * Which platform key should be presented for cryptographic use.
+ */
+typedef enum fsl_shw_pf_key_t {
+	FSL_SHW_PF_KEY_IIM,	/*!< Present fused IIM key */
+	FSL_SHW_PF_KEY_PRG,	/*!< Present Program key */
+	FSL_SHW_PF_KEY_IIM_PRG,	/*!< Present IIM ^ Program key */
+	FSL_SHW_PF_KEY_IIM_RND,	/*!< Present Random key */
+	FSL_SHW_PF_KEY_RND,	/*!< Present IIM ^ Random key */
+} fsl_shw_pf_key_t;
+
+/*!
+ * The various security tamper events
+ */
+typedef enum fsl_shw_tamper_t {
+	FSL_SHW_TAMPER_NONE,	/*!< No error detected */
+	FSL_SHW_TAMPER_WTD,	/*!< wire-mesh tampering det */
+	FSL_SHW_TAMPER_ETBD,	/*!< ext tampering det: input B */
+	FSL_SHW_TAMPER_ETAD,	/*!< ext tampering det: input A */
+	FSL_SHW_TAMPER_EBD,	/*!< external boot detected */
+	FSL_SHW_TAMPER_SAD,	/*!< security alarm detected */
+	FSL_SHW_TAMPER_TTD,	/*!< temperature tampering det */
+	FSL_SHW_TAMPER_CTD,	/*!< clock tampering det */
+	FSL_SHW_TAMPER_VTD,	/*!< voltage tampering det */
+	FSL_SHW_TAMPER_MCO,	/*!< monotonic counter overflow */
+	FSL_SHW_TAMPER_TCO,	/*!< time counter overflow */
+} fsl_shw_tamper_t;
 
+/*! @} *//* consgrp */
+
+/******************************************************************************
+ * Data Structures
+ *****************************************************************************/
+/*! @addtogroup strgrp
+    @{ */
+
+/* REQ-S2LRD-PINTFC-COA-IBO-001 */
+/*!
+ * Application Initialization Object
+ *
+ * This object, the operations on it, and its interaction with the driver are
+ * TBD.
+ */
+typedef struct fsl_sho_ibo_t {
+} fsl_sho_ibo_t;
+
+/* REQ-S2LRD-PINTFC-COA-UCO-001 */
+/*!
+ * User Context Object
+ *
+ * This object must be initialized by a call to #fsl_shw_uco_init().  It must
+ * then be passed to #fsl_shw_register_user() before it can be used in any
+ * calls besides those in @ref ucoops.
+ *
+ * It contains the user's configuration for the API, for instance whether an
+ * operation should block, or instead should call back the user upon completion
+ * of the operation.
+ *
+ * See @ref ucoops for further information.
+ */
+typedef struct fsl_shw_uco_t {	/* fsl_shw_user_context_object */
+} fsl_shw_uco_t;
+
+/* REQ-S2LRD-PINTFC-API-GEN-006  ??  */
+/*!
+ * Result Object
+ *
+ * This object will contain success and failure information about a specific
+ * cryptographic request which has been made.
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref rops.
+ */
+typedef struct fsl_shw_result_t {	/* fsl_shw_result */
+} fsl_shw_result_t;
+
+/*!
+ * Keystore Object
+ *
+ * This object holds the context of a user keystore, including the functions
+ * that define the interface and pointers to where the key data is stored.  The
+ * user must supply a set of functions to handle keystore management, including
+ * slot allocation, deallocation, etc.  A default keystore manager is provided
+ * as part of the API.
+ * 
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref ksoops.
+ */
+typedef struct fsl_shw_kso_t {	/* fsl_shw_keystore_object */
+} fsl_shw_kso_t;
+
+/* REQ-S2LRD-PINTFC-COA-SKO-001 */
+/*!
+ * Secret Key Object
+ *
+ * This object contains a key for a cryptographic operation, and information
+ * about its current state, its intended usage, etc.  It may instead contain
+ * information about a protected key, or an indication to use a platform-
+ * specific secret key.
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref skoops.
+ */
+typedef struct fsl_shw_sko_t {	/* fsl_shw_secret_key_object */
+} fsl_shw_sko_t;
+
+/* REQ-S2LRD-PINTFC-COA-CO-001 */
+/*!
+ * Platform Capabilities Object
+ *
+ * This object will contain information about the cryptographic features of the
+ * platform which the program is running on.
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.
+ *
+ * See @ref pcoops.
+ */
+typedef struct fsl_shw_pco_t {	/* fsl_shw_platform_capabilities_object */
+} fsl_shw_pco_t;
+
+/* REQ-S2LRD-PINTFC-COA-HCO-001 */
+/*!
+ * Hash Context Object
+ *
+ * This object contains information to control hashing functions.
+
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref hcops.
+ */
+typedef struct fsl_shw_hco_t {	/* fsl_shw_hash_context_object */
+} fsl_shw_hco_t;
+
+/*!
+ * HMAC Context Object
+ *
+ * This object contains information to control HMAC functions.
+
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref hmcops.
+ */
+typedef struct fsl_shw_hmco_t {	/* fsl_shw_hmac_context_object */
+} fsl_shw_hmco_t;
+
+/* REQ-S2LRD-PINTFC-COA-SCCO-001 */
+/*!
+ * Symmetric Cipher Context Object
+ *
+ * This object contains information to control Symmetric Ciphering encrypt and
+ * decrypt functions in #FSL_SYM_MODE_STREAM (ARC4), #FSL_SYM_MODE_ECB,
+ * #FSL_SYM_MODE_CBC, and #FSL_SYM_MODE_CTR modes and the
+ * #fsl_shw_symmetric_encrypt() and #fsl_shw_symmetric_decrypt() functions.
+ * CCM mode is controlled with the #fsl_shw_acco_t object.
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref sccops.
+ */
+typedef struct fsl_shw_scco_t {	/* fsl_shw_symmetric_cipher_context_object */
+} fsl_shw_scco_t;
+
+/*!
+ * Authenticate-Cipher Context Object
+
+ * An object for controlling the function of, and holding information about,
+ * data for the authenticate-cipher functions, #fsl_shw_gen_encrypt() and
+ * #fsl_shw_auth_decrypt().
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref
+ * accoops.
+ */
+typedef struct fsl_shw_acco_t {	/* fsl_shw_authenticate_cipher_context_object */
+} fsl_shw_acco_t;
+	  /*! @} *//* strgrp */
+
+/******************************************************************************
+ * Access Macros for Objects
+ *****************************************************************************/
+/*! @addtogroup pcoops
+    @{ */
+
+/*!
+ * Get FSL SHW API version
+ *
+ * @param      pc_info   The Platform Capabilities Object to query.
+ * @param[out] major     A pointer to where the major version
+ *                       of the API is to be stored.
+ * @param[out] minor     A pointer to where the minor version
+ *                       of the API is to be stored.
+ */
+void fsl_shw_pco_get_version(const fsl_shw_pco_t * pc_info,
+			     uint32_t * major, uint32_t * minor);
+
+/*!
+ * Get underlying driver version.
+ *
+ * @param      pc_info   The Platform Capabilities Object to query.
+ * @param[out] major     A pointer to where the major version
+ *                       of the driver is to be stored.
+ * @param[out] minor     A pointer to where the minor version
+ *                       of the driver is to be stored.
+ */
+void fsl_shw_pco_get_driver_version(const fsl_shw_pco_t * pc_info,
+				    uint32_t * major, uint32_t * minor);
+
+/*!
+ * Get list of symmetric algorithms supported.
+ *
+ * @param pc_info   The Platform Capabilities Object to query.
+ * @param[out] algorithms A pointer to where to store the location of
+ *                        the list of algorithms.
+ * @param[out] algorithm_count A pointer to where to store the number of
+ *                             algorithms in the list at @a algorithms.
+ */
+void fsl_shw_pco_get_sym_algorithms(const fsl_shw_pco_t * pc_info,
+				    fsl_shw_key_alg_t * algorithms[],
+				    uint8_t * algorithm_count);
+
+/*!
+ * Get list of symmetric modes supported.
+ *
+ * @param pc_info         The Platform Capabilities Object to query.
+ * @param[out] modes      A pointer to where to store the location of
+ *                        the list of modes.
+ * @param[out] mode_count A pointer to where to store the number of
+ *                        algorithms in the list at @a modes.
+ */
+void fsl_shw_pco_get_sym_modes(const fsl_shw_pco_t * pc_info,
+			       fsl_shw_sym_mode_t * modes[],
+			       uint8_t * mode_count);
+
+/*!
+ * Get list of hash algorithms supported.
+ *
+ * @param pc_info         The Platform Capabilities Object to query.
+ * @param[out] algorithms A pointer which will be set to the list of
+ *                        algorithms.
+ * @param[out] algorithm_count The number of algorithms in the list at @a
+ *                             algorithms.
+ */
+void fsl_shw_pco_get_hash_algorithms(const fsl_shw_pco_t * pc_info,
+				     fsl_shw_hash_alg_t * algorithms[],
+				     uint8_t * algorithm_count);
+
+/*!
+ * Determine whether the combination of a given symmetric algorithm and a given
+ * mode is supported.
+ *
+ * @param pc_info    The Platform Capabilities Object to query.
+ * @param algorithm  A Symmetric Cipher algorithm.
+ * @param mode       A Symmetric Cipher mode.
+ *
+ * @return 0 if combination is not supported, non-zero if supported.
+ */
+int fsl_shw_pco_check_sym_supported(const fsl_shw_pco_t * pc_info,
+				    fsl_shw_key_alg_t algorithm,
+				    fsl_shw_sym_mode_t mode);
+
+/*!
+ * Determine whether a given Encryption-Authentication mode is supported.
+ *
+ * @param pc_info   The Platform Capabilities Object to query.
+ * @param mode       The Authentication mode.
+ *
+ * @return 0 if mode is not supported, non-zero if supported.
+ */
+int fsl_shw_pco_check_auth_supported(const fsl_shw_pco_t * pc_info,
+				     fsl_shw_acc_mode_t mode);
+
+/*!
+ * Determine whether Black Keys (key establishment / wrapping) is supported.
+ *
+ * @param pc_info  The Platform Capabilities Object to query.
+ *
+ * @return 0 if wrapping is not supported, non-zero if supported.
+ */
+int fsl_shw_pco_check_black_key_supported(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Get FSL SHW SCC driver version
+ *
+ * @param      pc_info   The Platform Capabilities Object to query.
+ * @param[out] major     A pointer to where the major version
+ *                       of the SCC driver is to be stored.
+ * @param[out] minor     A pointer to where the minor version
+ *                       of the SCC driver is to be stored.
+ */
+void fsl_shw_pco_get_scc_driver_version(const fsl_shw_pco_t * pc_info,
+					uint32_t * major, uint32_t * minor);
+
+/*!
+ * Get SCM hardware version
+ *
+ * @param      pc_info   The Platform Capabilities Object to query.
+ * @return               The SCM hardware version
+ */
+uint32_t fsl_shw_pco_get_scm_version(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Get SMN hardware version
+ *
+ * @param      pc_info   The Platform Capabilities Object to query.
+ * @return               The SMN hardware version
+ */
+uint32_t fsl_shw_pco_get_smn_version(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Get the size of an SCM block, in bytes
+ *
+ * @param      pc_info   The Platform Capabilities Object to query.
+ * @return               The size of an SCM block, in bytes.
+ */
+uint32_t fsl_shw_pco_get_scm_block_size(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Get size of Black and Red RAM memory
+ *
+ * @param      pc_info     The Platform Capabilities Object to query.
+ * @param[out] black_size  A pointer to where the size of the Black RAM, in
+ *                         blocks, is to be placed.
+ * @param[out] red_size    A pointer to where the size of the Red RAM, in 
+ *                         blocks, is to be placed.
+ */
+void fsl_shw_pco_get_smn_size(const fsl_shw_pco_t * pc_info,
+			      uint32_t * black_size, uint32_t * red_size);
+
+/*!
+ * Determine whether Secure Partitions are supported
+ *
+ * @param pc_info          The Platform Capabilities Object to query.
+ *
+ * @return 0 if secure partitions are not supported, non-zero if supported.
+ */
+int fsl_shw_pco_check_spo_supported(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Get the size of a Secure Partitions
+ *
+ * @param pc_info          The Platform Capabilities Object to query.
+ * 
+ * @return Partition size, in bytes.  0 if Secure Partitions not supported.
+ */
+uint32_t fsl_shw_pco_get_spo_size_bytes(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Get the number of Secure Partitions on this platform
+ *
+ * @param pc_info          The Platform Capabilities Object to query.
+ * 
+ * @return Number of partitions. 0 if Secure Partitions not supported.  Note
+ *         that this returns the total number of partitions, though
+ *         not all may be available to the user.
+ */
+uint32_t fsl_shw_pco_get_spo_count(const fsl_shw_pco_t * pc_info);
+
+/*!
+ * Determine whether Platform Key features are available
+ *
+ * @param pc_info          The Platform Capabilities Object to query.
+ *
+ * @return  1 if Programmed Key features are available, otherwise zero.
+ */
+int fsl_shw_pco_check_pk_supported(const fsl_shw_pco_t * pc_info);
+
+/*!
+  * Determine whether Software Key features are available
+  *
+  * @param pc_info 		 The Platform Capabilities Object to query.
+  *
+  * @return  1 if Software key features are available, otherwise zero.
+  */
+int fsl_shw_pco_check_sw_keys_supported(const fsl_shw_pco_t * pc_info);
+
+/*! @} *//* pcoops */
+
+/*! @addtogroup ucoops
+    @{ */
+
+/*!
+ * Initialize a User Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the User Context Object to initial values, and set the size
+ * of the results pool.  The mode will be set to a default of
+ * #FSL_UCO_BLOCKING_MODE.
+ *
+ * When using non-blocking operations, this sets the maximum number of
+ * operations which can be outstanding.  This number includes the counts of
+ * operations waiting to start, operation(s) being performed, and results which
+ * have not been retrieved.
+ *
+ * Changes to this value are ignored once user registration has completed.  It
+ * should be set to 1 if only blocking operations will ever be performed.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param pool_size    The maximum number of operations which can be
+ *                     outstanding.
+ */
+void fsl_shw_uco_init(fsl_shw_uco_t * user_ctx, uint16_t pool_size);
+
+/*!
+ * Set the User Reference for the User Context.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param reference    A value which will be passed back with a result.
+ */
+void fsl_shw_uco_set_reference(fsl_shw_uco_t * user_ctx, uint32_t reference);
+
+/*!
+ * Set the callback routine for the User Context.
+ *
+ * Note that the callback routine may be called when no results are available,
+ * and possibly even when no requests are outstanding.
+ *
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param callback_fn  The function the API will invoke when an operation
+ *                     completes.
+ */
+void fsl_shw_uco_set_callback(fsl_shw_uco_t * user_ctx,
+			      void (*callback_fn) (fsl_shw_uco_t * uco));
+
+/*!
+ * Set flags in the User Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param flags        ORed values from #fsl_shw_user_ctx_flags_t.
+ */
+void fsl_shw_uco_set_flags(fsl_shw_uco_t * user_ctx, uint32_t flags);
+
+/*!
+ * Clear flags in the User Context.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param flags        ORed values from #fsl_shw_user_ctx_flags_t.
+ */
+void fsl_shw_uco_clear_flags(fsl_shw_uco_t * user_ctx, uint32_t flags);
+
+/*!
+ * Select a key for the key-wrap key for key wrapping/unwrapping
+ *
+ * Without a call to this function, default is FSL_SHW_PF_KEY_IIM.  The wrap
+ * key is used to encrypt and decrypt the per-key random secret which is used
+ * to calculate the key which will encrypt/decrypt the user's key.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param pf_key       Which key to use.  Valid choices are
+ *                     #FSL_SHW_PF_KEY_IIM, #FSL_SHW_PF_KEY_RND, and
+ *                     #FSL_SHW_PF_KEY_IIM_RND.
+ */
+void fsl_shw_uco_set_wrap_key(fsl_shw_uco_t * user_ctx,
+			      fsl_shw_pf_key_t pf_key);
+
+	  /*! @} *//* ucoops */
+
+/*! @addtogroup rops
+    @{ */
+
+/*!
+ * Retrieve the status code from a Result Object.
+ *
+ * @param result   The result object to query.
+ *
+ * @return The status of the request.
+ */
+fsl_shw_return_t fsl_shw_ro_get_status(fsl_shw_result_t * result);
+
+/*!
+ * Retrieve the reference value from a Result Object.
+ *
+ * @param result   The result object to query.
+ *
+ * @return The reference associated with the request.
+ */
+uint32_t fsl_shw_ro_get_reference(fsl_shw_result_t * result);
+
+	 /* @} *//* rops */
+
+/*! @addtogroup skoops
+    @{ */
+
+/*!
+ * Initialize a Secret Key Object.
+ *
+ * This function or #fsl_shw_sko_init_pf_key() must be called before performing
+ * any other operation with the Object.
+ *
+ * @param key_info  The Secret Key Object to be initialized.
+ * @param algorithm DES, AES, etc.
+ *
+ */
+void fsl_shw_sko_init(fsl_shw_sko_t * key_info, fsl_shw_key_alg_t algorithm);
+
+/*!
+ * Initialize a Secret Key Object to use a Platform Key register.
+ *
+ * This function or #fsl_shw_sko_init() must be called before performing any
+ * other operation with the Object.  #fsl_shw_sko_set_key() does not work on
+ * a key object initialized in this way.
+ *
+ * If this function is used to initialize the key object, but no key is
+ * established with the key object, then the object will refer strictly to the
+ * key value specified by the @c pf_key selection.
+ *
+ * If the pf key is #FSL_SHW_PF_KEY_PRG or #FSL_SHW_PF_KEY_IIM_PRG, then the
+ * key object may be used with #fsl_shw_establish_key() to change the Program
+ * Key value.  When the pf key is neither #FSL_SHW_PF_KEY_PRG nor
+ * #FSL_SHW_PF_KEY_IIM_PRG, it is an error to call #fsl_shw_establish_key().
+ *
+ * @param key_info     The Secret Key Object to be initialized.
+ * @param algorithm    DES, AES, etc.
+ * @param pf_key       Which platform key is referenced.
+ */
+void fsl_shw_sko_init_pf_key(fsl_shw_sko_t * key_info,
+			     fsl_shw_key_alg_t algorithm,
+			     fsl_shw_pf_key_t pf_key);
+
+/*!
+ * Store a cleartext key in the key object.
+ *
+ * This has the side effect of setting the #FSL_SKO_KEY_PRESENT flag. It should
+ * not be used if there is a key established with the key object.  If there is,
+ * a call to #fsl_shw_release_key() should be made first.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param key          A pointer to the beginning of the key.
+ * @param key_length   The length, in octets, of the key.  The value should be
+ *                     appropriate to the key size supported by the algorithm.
+ *                     64 octets is the absolute maximum value allowed for this
+ *                     call.
+ */
+void fsl_shw_sko_set_key(fsl_shw_sko_t * key_object,
+			 const uint8_t * key, uint16_t key_length);
+
+/*!
+ * Set a size for the key.
+ *
+ * This function would normally be used when the user wants the key to be
+ * generated from a random source.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param key_length   The length, in octets, of the key.  The value should be
+ *                     appropriate to the key size supported by the algorithm.
+ *                     64 octets is the absolute maximum value allowed for this
+ *                     call.
+ */
+void fsl_shw_sko_set_key_length(fsl_shw_sko_t * key_object,
+				uint16_t key_length);
+
+/*!
+ * Set the User ID associated with the key.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param userid       The User ID to identify authorized users of the key.
+ */
+void fsl_shw_sko_set_user_id(fsl_shw_sko_t * key_object, key_userid_t userid);
+
+/*!
+ * Set the keystore that the key will be stored in.
+ *
+ * @param key_object    A variable of type #fsl_shw_sko_t.
+ * @param keystore      The keystore to place the key in.  This is a variable of
+ *                      type #fsl_shw_kso_t.
+ */
+void fsl_shw_sko_set_keystore(fsl_shw_sko_t * key_object,
+			      fsl_shw_kso_t * keystore);
+
+/*!
+ * Set the establish key handle into a key object.
+ *
+ * The @a userid field will be used to validate the access to the unwrapped
+ * key.  This feature is not available for all platforms, nor for all
+ * algorithms and modes.
+ *
+ * The #FSL_SKO_KEY_ESTABLISHED will be set (and the #FSL_SKO_KEY_PRESENT
+ * flag will be cleared).
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param userid       The User ID to verify this user is an authorized user of
+ *                     the key.
+ * @param handle       A @a handle from #fsl_shw_sko_get_established_info.
+ */
+void fsl_shw_sko_set_established_info(fsl_shw_sko_t * key_object,
+				      key_userid_t userid, uint32_t handle);
+
+/*!
+ * Extract the algorithm from a key object.
+ *
+ * @param      key_info  The Key Object to be queried.
+ * @param[out] algorithm A pointer to the location to store the algorithm.
+ */
+void fsl_shw_sko_get_algorithm(const fsl_shw_sko_t * key_info,
+			       fsl_shw_key_alg_t * algorithm);
+
+/*!
+ * Retrieve the cleartext key from a key object that is stored in a user
+ * keystore.
+ *
+ * @param      skobject     The Key Object to be queried.
+ * @param[out] skkey        A pointer to the location to store the key.  NULL
+ *                          if the key is not stored in a user keystore.
+ */
+void fsl_shw_sko_get_key(const fsl_shw_sko_t * skobject, void *skkey);
+
+/*!
+ * Retrieve the established-key handle from a key object.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param handle       The location to store the @a handle of the unwrapped
+ *                     key.
+ */
+void fsl_shw_sko_get_established_info(fsl_shw_sko_t * key_object,
+				      uint32_t * handle);
+
+/*!
+ * Determine the size of a wrapped key based upon the cleartext key's length.
+ *
+ * This function can be used to calculate the number of octets that
+ * #fsl_shw_extract_key() will write into the location at @a covered_key.
+ *
+ * If zero is returned at @a length, this means that the key length in
+ * @a key_info is not supported.
+ *
+ * @param      key_info         Information about a key to be wrapped.
+ * @param      length           Location to store the length of a wrapped
+ *                              version of the key in @a key_info.
+ */
+void fsl_shw_sko_calculate_wrapped_size(const fsl_shw_sko_t * key_info,
+					uint32_t * length);
+
+/*!
+ * Set some flags in the key object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param flags        (One or more) ORed members of #fsl_shw_key_flags_t which
+ *                     are to be set.
+ */
+void fsl_shw_sko_set_flags(fsl_shw_sko_t * key_object, uint32_t flags);
+
+/*!
+ * Clear some flags in the key object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param flags        (One or more) ORed members of #fsl_shw_key_flags_t which
+ *                      are to be reset.
+ */
+void fsl_shw_sko_clear_flags(fsl_shw_sko_t * key_object, uint32_t flags);
+
+	  /*! @} *//* end skoops */
+
+/*****************************************************************************/
+
+/*! @addtogroup hcops
+    @{ */
+
+/*****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-004 - partially */
+/*!
+ * Initialize a Hash Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the current message length and hash algorithm in the hash
+ * context object.
+ *
+ * @param      hash_ctx  The hash context to operate upon.
+ * @param      algorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
+ *                       #FSL_HASH_ALG_SHA256, etc).
+ *
+ */
+void fsl_shw_hco_init(fsl_shw_hco_t * hash_ctx, fsl_shw_hash_alg_t algorithm);
+
+/*****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-001 */
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-002 */
+/*!
+ * Get the current hash value and message length from the hash context object.
+ *
+ * The algorithm must have already been specified.  See #fsl_shw_hco_init().
+ *
+ * @param      hash_ctx  The hash context to query.
+ * @param[out] digest    Pointer to the location of @a length octets where to
+ *                       store a copy of the current value of the digest.
+ * @param      length    Number of octets of hash value to copy.
+ * @param[out] msg_length Pointer to the location to store the number of octets
+ *                        already hashed.
+ */
+void fsl_shw_hco_get_digest(const fsl_shw_hco_t * hash_ctx, uint8_t * digest,
+			    uint8_t length, uint32_t * msg_length);
+
+/*****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-002 - partially */
+/*!
+ * Get the hash algorithm from the hash context object.
+ *
+ * @param      hash_ctx  The hash context to query.
+ * @param[out] algorithm Pointer to where the algorithm is to be stored.
+ */
+void fsl_shw_hco_get_info(const fsl_shw_hco_t * hash_ctx,
+			  fsl_shw_hash_alg_t * algorithm);
+
+/*****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-003 */
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-004 */
+/*!
+ * Set the current hash value and message length in the hash context object.
+ *
+ * The algorithm must have already been specified.  See #fsl_shw_hco_init().
+ *
+ * @param      hash_ctx  The hash context to operate upon.
+ * @param      context   Pointer to buffer of appropriate length to copy into
+ *                       the hash context object.
+ * @param      msg_length The number of octets of the message which have
+ *                        already been hashed.
+ *
+ */
+void fsl_shw_hco_set_digest(fsl_shw_hco_t * hash_ctx, const uint8_t * context,
+			    uint32_t msg_length);
+
+/*!
+ * Set flags in a Hash Context Object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hash_ctx   The hash context to be operated on.
+ * @param flags      The flags to be set in the context.  These can be ORed
+ *                   members of #fsl_shw_hash_ctx_flags_t.
+ */
+void fsl_shw_hco_set_flags(fsl_shw_hco_t * hash_ctx, uint32_t flags);
+
+/*!
+ * Clear flags in a Hash Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hash_ctx   The hash context to be operated on.
+ * @param flags      The flags to be reset in the context.  These can be ORed
+ *                   members of #fsl_shw_hash_ctx_flags_t.
+ */
+void fsl_shw_hco_clear_flags(fsl_shw_hco_t * hash_ctx, uint32_t flags);
+
+	  /*! @} *//* end hcops */
+
+/*****************************************************************************/
+
+/*! @addtogroup hmcops
+    @{ */
+
+/*!
+ * Initialize an HMAC Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the current message length and hash algorithm in the HMAC
+ * context object.
+ *
+ * @param      hmac_ctx  The HMAC context to operate upon.
+ * @param      algorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
+ *                       #FSL_HASH_ALG_SHA256, etc).
+ *
+ */
+void fsl_shw_hmco_init(fsl_shw_hmco_t * hmac_ctx, fsl_shw_hash_alg_t algorithm);
+
+/*!
+ * Set flags in an HMAC Context Object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hmac_ctx   The HMAC context to be operated on.
+ * @param flags      The flags to be set in the context.  These can be ORed
+ *                   members of #fsl_shw_hmac_ctx_flags_t.
+ */
+void fsl_shw_hmco_set_flags(fsl_shw_hmco_t * hmac_ctx, uint32_t flags);
+
+/*!
+ * Clear flags in an HMAC Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hmac_ctx   The HMAC context to be operated on.
+ * @param flags      The flags to be reset in the context.  These can be ORed
+ *                   members of #fsl_shw_hmac_ctx_flags_t.
+ */
+void fsl_shw_hmco_clear_flags(fsl_shw_hmco_t * hmac_ctx, uint32_t flags);
+
+/*! @} */
+
+/*****************************************************************************/
+
+/*! @addtogroup sccops
+    @{ */
+
+/*!
+ * Initialize a Symmetric Cipher Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  This will set the @a mode and @a algorithm and initialize the
+ * Object.
+ *
+ * @param sym_ctx   The context object to operate on.
+ * @param algorithm The cipher algorithm this context will be used with.
+ * @param mode      #FSL_SYM_MODE_CBC, #FSL_SYM_MODE_ECB, etc.
+ *
+ */
+void fsl_shw_scco_init(fsl_shw_scco_t * sym_ctx,
+		       fsl_shw_key_alg_t algorithm, fsl_shw_sym_mode_t mode);
+
+/*!
+ * Set the flags for a Symmetric Cipher Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param sym_ctx  The context object to operate on.
+ * @param flags    The flags to reset (one or more values from
+ *                 #fsl_shw_sym_ctx_flags_t ORed together).
+ *
+ */
+void fsl_shw_scco_set_flags(fsl_shw_scco_t * sym_ctx, uint32_t flags);
+
+/*!
+ * Clear some flags in a Symmetric Cipher Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param sym_ctx  The context object to operate on.
+ * @param flags    The flags to reset (one or more values from
+ *                 #fsl_shw_sym_ctx_flags_t ORed together).
+ *
+ */
+void fsl_shw_scco_clear_flags(fsl_shw_scco_t * sym_ctx, uint32_t flags);
+
+/*!
+ * Set the Context (IV) for a Symmetric Cipher Context.
+ *
+ * This is to set the context/IV for #FSL_SYM_MODE_CBC mode, or to set the
+ * context (the S-Box and pointers) for ARC4.  The full context size will
+ * be copied.
+ *
+ * @param sym_ctx  The context object to operate on.
+ * @param context  A pointer to the buffer which contains the context.
+ *
+ */
+void fsl_shw_scco_set_context(fsl_shw_scco_t * sym_ctx, uint8_t * context);
+
+/*!
+ * Get the Context for a Symmetric Cipher Context.
+ *
+ * This is to retrieve the context/IV for #FSL_SYM_MODE_CBC mode, or to
+ * retrieve context (the S-Box and pointers) for ARC4.  The full context
+ * will be copied.
+ *
+ * @param      sym_ctx  The context object to operate on.
+ * @param[out] context  Pointer to location where context will be stored.
+ */
+void fsl_shw_scco_get_context(const fsl_shw_scco_t * sym_ctx,
+			      uint8_t * context);
+
+/*!
+ * Set the Counter Value for a Symmetric Cipher Context.
+ *
+ * This will set the Counter Value for CTR mode.
+ *
+ * @param sym_ctx  The context object to operate on.
+ * @param counter  The starting counter value.  The number of octets.
+ *                 copied will be the block size for the algorithm.
+ * @param modulus  The modulus for controlling the incrementing of the counter.
+ *
+ */
+void fsl_shw_scco_set_counter_info(fsl_shw_scco_t * sym_ctx,
+				   const uint8_t * counter,
+				   fsl_shw_ctr_mod_t modulus);
+
+/*!
+ * Get the Counter Value for a Symmetric Cipher Context.
+ *
+ * This will retrieve the Counter Value is for CTR mode.
+ *
+ * @param sym_ctx         The context object to query.
+ * @param[out] counter    Pointer to location to store the current counter
+ *                        value.  The number of octets copied will be the
+ *                        block size for the algorithm.
+ * @param[out] modulus    Pointer to location to store the modulus.
+ *
+ */
+void fsl_shw_scco_get_counter_info(const fsl_shw_scco_t * sym_ctx,
+				   uint8_t * counter,
+				   fsl_shw_ctr_mod_t * modulus);
+
+	  /*! @} *//* end sccops */
+
+/*****************************************************************************/
+
+/*! @addtogroup accoops
+    @{ */
+
+/*!
+ * Initialize a Authentication-Cipher Context.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param mode         The mode for this object (only #FSL_ACC_MODE_CCM
+ *                     supported).
+ */
+void fsl_shw_acco_init(fsl_shw_acco_t * auth_object, fsl_shw_acc_mode_t mode);
+
+/*!
+ * Set the flags for a Authentication-Cipher Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param flags        The flags to set (one or more from
+ *                     #fsl_shw_auth_ctx_flags_t ORed together).
+ *
+ */
+void fsl_shw_acco_set_flags(fsl_shw_acco_t * auth_object, uint32_t flags);
+
+/*!
+ * Clear some flags in a Authentication-Cipher Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param flags        The flags to reset (one or more from
+ *                     #fsl_shw_auth_ctx_flags_t ORed together).
+ *
+ */
+void fsl_shw_acco_clear_flags(fsl_shw_acco_t * auth_object, uint32_t flags);
+
+/*!
+ * Set up the Authentication-Cipher Object for CCM mode.
+ *
+ * This will set the @a auth_object for CCM mode and save the @a ctr,
+ * and @a mac_length.  This function can be called instead of
+ * #fsl_shw_acco_init().
+ *
+ * The parameter @a ctr is Counter Block 0, (counter value 0), which is for the
+ * MAC.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param algorithm    Cipher algorithm.  Only AES is supported.
+ * @param ctr          The initial counter value.
+ * @param mac_length   The number of octets used for the MAC.  Valid values are
+ *                     4, 6, 8, 10, 12, 14, and 16.
+ */
+void fsl_shw_acco_set_ccm(fsl_shw_acco_t * auth_object,
+			  fsl_shw_key_alg_t algorithm,
+			  const uint8_t * ctr, uint8_t mac_length);
+
+/*!
+ * Format the First Block (IV) & Initial Counter Value per NIST CCM.
+ *
+ * This function will also set the IV and CTR values per Appendix A of NIST
+ * Special Publication 800-38C (May 2004).  It will also perform the
+ * #fsl_shw_acco_set_ccm() operation with information derived from this set of
+ * parameters.
+ *
+ * Note this function assumes the algorithm is AES.  It initializes the
+ * @a auth_object by setting the mode to #FSL_ACC_MODE_CCM and setting the
+ * flags to be #FSL_ACCO_NIST_CCM.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param t_length     The number of octets used for the MAC.  Valid values are
+ *                     4, 6, 8, 10, 12, 14, and 16.
+ * @param ad_length    Number of octets of Associated Data (may be zero).
+ * @param q_length     A value for the size of the length of @a q field.  Valid
+ *                     values are 1-8.
+ * @param n            The Nonce (packet number or other changing value). Must
+ *                     be (15 - @a q_length) octets long.
+ * @param q            The value of Q (size of the payload in octets).
+ *
+ */
+void fsl_shw_ccm_nist_format_ctr_and_iv(fsl_shw_acco_t * auth_object,
+					uint8_t t_length,
+					uint32_t ad_length,
+					uint8_t q_length,
+					const uint8_t * n, uint32_t q);
+
+/*!
+ * Update the First Block (IV) & Initial Counter Value per NIST CCM.
+ *
+ * This function will set the IV and CTR values per Appendix A of NIST Special
+ * Publication 800-38C (May 2004).
+ *
+ * Note this function assumes that #fsl_shw_ccm_nist_format_ctr_and_iv() has
+ * previously been called on the @a auth_object.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param n             The Nonce (packet number or other changing value). Must
+ *                      be (15 - @a q_length) octets long.
+ * @param q             The value of Q (size of the payload in octets).
+ *
+ */
+void fsl_shw_ccm_nist_update_ctr_and_iv(fsl_shw_acco_t * auth_object,
+					const uint8_t * n, uint32_t q);
+
+	 /* @} *//* accoops */
+
+/******************************************************************************
+ * Library functions
+ *****************************************************************************/
+
+/*! @addtogroup miscfuns
+    @{ */
+
+/* REQ-S2LRD-PINTFC-API-GEN-003 */
+/*!
+ * Determine the hardware security capabilities of this platform.
+ *
+ * Though a user context object is passed into this function, it will always
+ * act in a non-blocking manner.
+ *
+ * @param  user_ctx   The user context which will be used for the query.
+ *
+ * @return  A pointer to the capabilities object.
+ */
+extern fsl_shw_pco_t *fsl_shw_get_capabilities(fsl_shw_uco_t * user_ctx);
+
+/* REQ-S2LRD-PINTFC-API-GEN-004 */
+/*!
+ * Create an association between the user and the provider of the API.
+ *
+ * @param  user_ctx   The user context which will be used for this association.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t * user_ctx);
+
+/* REQ-S2LRD-PINTFC-API-GEN-005 */
+/*!
+ * Destroy the association between the user and the provider of the API.
+ *
+ * @param  user_ctx   The user context which is no longer needed.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t * user_ctx);
+
+/* REQ-S2LRD-PINTFC-API-GEN-006 */
+/*!
+ * Retrieve results from earlier operations.
+ *
+ * @param         user_ctx     The user's context.
+ * @param         result_size  The number of array elements of @a results.
+ * @param[in,out] results      Pointer to first of the (array of) locations to
+ *                             store results.
+ * @param[out]    result_count Pointer to store the number of results which
+ *                             were returned.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t * user_ctx,
+					    uint16_t result_size,
+					    fsl_shw_result_t results[],
+					    uint16_t * result_count);
+
+/*!
+ * Allocate a block of secure memory
+ *
+ * @param       user_ctx        User context
+ * @param       size            Memory size (octets).  Note: currently only
+ *                              supports only single-partition sized blocks.
+ * @param       UMID            User Mode ID to use when registering the
+ *                              partition.
+ * @param       permissions     Permissions to initialize the partition with.
+ *                              Can be made by ORing flags from the
+ *                              #fsl_shw_permission_t.
+ *
+ * @return                      Address of the allocated memory.  NULL if the
+ *                              call was not successful.
+ */
+extern void *fsl_shw_smalloc(fsl_shw_uco_t * user_ctx,
+			     uint32_t size,
+			     const uint8_t * UMID, uint32_t permissions);
+
+/*!
+ * Free a block of secure memory that was allocated with #fsl_shw_smalloc
+ *
+ * @param       user_ctx        User context
+ * @param       address         Address of the block of secure memory to be
+ *                              released.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_sfree(fsl_shw_uco_t * user_ctx, void *address);
+
+/*!
+ * Diminish the permissions of a block of secure memory.  Note that permissions
+ * can only be revoked.
+ *
+ * @param       user_ctx        User context
+ * @param       address         Base address of the secure memory to work with
+ * @param       permissions     Permissions to initialize the partition with.
+ *                              Can be made by ORing flags from the
+ *                              #fsl_shw_permission_t.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_diminish_perms(fsl_shw_uco_t * user_ctx,
+					       void *address,
+					       uint32_t permissions);
+
+/*!
+ * @brief   Encrypt a region of secure memory using the hardware secret key
+ *
+ * @param       user_ctx        User context
+ * @param       partition_base  Base address of the partition
+ * @param       offset_bytes    Offset of data from the partition base
+ * @param       byte_count      Length of the data to encrypt
+ * @param       black_data      Location to store the encrypted data
+ * @param       IV              IV to use for the encryption routine
+ * @param       cypher_mode     Cyphering mode to use, specified by type
+ *                              #fsl_shw_cypher_mode_t
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t
+do_scc_encrypt_region(fsl_shw_uco_t * user_ctx,
+		      void *partition_base, uint32_t offset_bytes,
+		      uint32_t byte_count, uint8_t * black_data,
+		      uint32_t * IV, fsl_shw_cypher_mode_t cypher_mode);
+
+/*!
+ * @brief   Decrypt a region of secure memory using the hardware secret key
+ *
+ * @param       user_ctx        User context
+ * @param       partition_base  Base address of the partition
+ * @param       offset_bytes    Offset of data from the partition base
+ * @param       byte_count      Length of the data to encrypt
+ * @param       black_data      Location to store the encrypted data
+ * @param       IV              IV to use for the encryption routine
+ * @param       cypher_mode     Cyphering mode to use, specified by type
+ *                              #fsl_shw_cypher_mode_t
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t
+do_scc_decrypt_region(fsl_shw_uco_t * user_ctx,
+		      void *partition_base, uint32_t offset_bytes,
+		      uint32_t byte_count, const uint8_t * black_data,
+		      uint32_t * IV, fsl_shw_cypher_mode_t cypher_mode);
+
+	  /*! @} *//* miscfuns */
+
+/*! @addtogroup opfuns
+    @{ */
+
+/* REQ-S2LRD-PINTFC-API-BASIC-SYM-002 */
+/* PINTFC-API-BASIC-SYM-ARC4-001 */
+/* PINTFC-API-BASIC-SYM-ARC4-002 */
+/*!
+ * Encrypt a stream of data with a symmetric-key algorithm.
+ *
+ * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
+ * flags of the @a sym_ctx object will control part of the operation of this
+ * function.  The #FSL_SYM_CTX_INIT flag means that there is no context info in
+ * the object.  The #FSL_SYM_CTX_LOAD means to use information in the
+ * @a sym_ctx at the start of the operation, and the #FSL_SYM_CTX_SAVE flag
+ * means to update the object's context information after the operation has
+ * been performed.
+ *
+ * All of the data for an operation can be run through at once using the
+ * #FSL_SYM_CTX_INIT or #FSL_SYM_CTX_LOAD flags, as appropriate, and then using
+ * a @a length for the whole of the data.
+ *
+ * If a #FSL_SYM_CTX_SAVE flag were added, an additional call to the function
+ * would "pick up" where the previous call left off, allowing the user to
+ * perform the larger function in smaller steps.
+ *
+ * In #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_ECB modes, the @a length must always
+ * be a multiple of the block size for the algorithm being used.  For proper
+ * operation in #FSL_SYM_MODE_CTR mode, the @a length must be a multiple of the
+ * block size until the last operation on the total octet stream.
+ *
+ * Some users of ARC4 may want to compute the context (S-Box and pointers) from
+ * the key before any data is available.  This may be done by running this
+ * function with a @a length of zero, with the init & save flags flags on in
+ * the @a sym_ctx.  Subsequent operations would then run as normal with the
+ * load and save flags.  Note that they key object is still required.
+ *
+ * @param         user_ctx  A user context from #fsl_shw_register_user().
+ * @param         key_info  Key and algorithm  being used for this operation.
+ * @param[in,out] sym_ctx   Info on cipher mode, state of the cipher.
+ * @param         length   Length, in octets, of the pt (and ct).
+ * @param         pt       pointer to plaintext to be encrypted.
+ * @param[out]    ct       pointer to where to store the resulting ciphertext.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ *
+ */
+extern fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
+						  fsl_shw_sko_t * key_info,
+						  fsl_shw_scco_t * sym_ctx,
+						  uint32_t length,
+						  const uint8_t * pt,
+						  uint8_t * ct);
+
+/* PINTFC-API-BASIC-SYM-002 */
+/* PINTFC-API-BASIC-SYM-ARC4-001 */
+/* PINTFC-API-BASIC-SYM-ARC4-002 */
+/*!
+ * Decrypt a stream of data with a symmetric-key algorithm.
+ *
+ * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
+ * flags of the @a sym_ctx object will control part of the operation of this
+ * function.  The #FSL_SYM_CTX_INIT flag means that there is no context info in
+ * the object.  The #FSL_SYM_CTX_LOAD means to use information in the
+ * @a sym_ctx at the start of the operation, and the #FSL_SYM_CTX_SAVE flag
+ * means to update the object's context information after the operation has
+ * been performed.
+ *
+ * All of the data for an operation can be run through at once using the
+ * #FSL_SYM_CTX_INIT or #FSL_SYM_CTX_LOAD flags, as appropriate, and then using
+ * a @a length for the whole of the data.
+ *
+ * If a #FSL_SYM_CTX_SAVE flag were added, an additional call to the function
+ * would "pick up" where the previous call left off, allowing the user to
+ * perform the larger function in smaller steps.
+ *
+ * In #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_ECB modes, the @a length must always
+ * be a multiple of the block size for the algorithm being used.  For proper
+ * operation in #FSL_SYM_MODE_CTR mode, the @a length must be a multiple of the
+ * block size until the last operation on the total octet stream.
+ *
+ * Some users of ARC4 may want to compute the context (S-Box and pointers) from
+ * the key before any data is available.  This may be done by running this
+ * function with a @a length of zero, with the #FSL_SYM_CTX_INIT &
+ * #FSL_SYM_CTX_SAVE flags on in the @a sym_ctx.  Subsequent operations would
+ * then run as normal with the load & save flags.  Note that they key object is
+ * still required.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param      key_info The key and algorithm being used in this operation.
+ * @param[in,out] sym_ctx Info on cipher mode, state of the cipher.
+ * @param      length   Length, in octets, of the ct (and pt).
+ * @param      ct       pointer to ciphertext to be decrypted.
+ * @param[out] pt       pointer to where to store the resulting plaintext.
+ *
+ * @return    A return code of type #fsl_shw_return_t
+ *
+ */
+extern fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t * user_ctx,
+						  fsl_shw_sko_t * key_info,
+						  fsl_shw_scco_t * sym_ctx,
+						  uint32_t length,
+						  const uint8_t * ct,
+						  uint8_t * pt);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-005 */
+/*!
+ * Hash a stream of data with a cryptographic hash algorithm.
+ *
+ * The flags in the @a hash_ctx control the operation of this function.
+ *
+ * Hashing functions work on 64 octets of message at a time.  Therefore, when
+ * any partial hashing of a long message is performed, the message @a length of
+ * each segment must be a multiple of 64.  When ready to
+ * #FSL_HASH_FLAGS_FINALIZE the hash, the @a length may be any value.
+ *
+ * With the #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_FINALIZE flags on, a
+ * one-shot complete hash, including padding, will be performed.  The @a length
+ * may be any value.
+ *
+ * The first octets of a data stream can be hashed by setting the
+ * #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_SAVE flags.  The @a length must be
+ * a multiple of 64.
+ *
+ * The flag #FSL_HASH_FLAGS_LOAD is used to load a context previously saved by
+ * #FSL_HASH_FLAGS_SAVE.  The two in combination will allow a (multiple-of-64
+ * octets) 'middle sequence' of the data stream to be hashed with the
+ * beginning.  The @a length must again be a multiple of 64.
+ *
+ * Since the flag #FSL_HASH_FLAGS_LOAD is used to load a context previously
+ * saved by #FSL_HASH_FLAGS_SAVE, the #FSL_HASH_FLAGS_LOAD and
+ * #FSL_HASH_FLAGS_FINALIZE flags, used together, can be used to finish the
+ * stream.  The @a length may be any value.
+ *
+ * If the user program wants to do the padding for the hash, it can leave off
+ * the #FSL_HASH_FLAGS_FINALIZE flag.  The @a length must then be a multiple of
+ * 64 octets.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param[in,out] hash_ctx Hashing algorithm and state of the cipher.
+ * @param      msg       Pointer to the data to be hashed.
+ * @param      length    Length, in octets, of the @a msg.
+ * @param[out] result    If not null, pointer to where to store the hash
+ *                       digest.
+ * @param      result_len Number of octets to store in @a result.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_hco_t * hash_ctx,
+				     const uint8_t * msg,
+				     uint32_t length,
+				     uint8_t * result, uint32_t result_len);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-001 */
+/*!
+ * Precompute the Key hashes for an HMAC operation.
+ *
+ * This function may be used to calculate the inner and outer precomputes,
+ * which are the hash contexts resulting from hashing the XORed key for the
+ * 'inner hash' and the 'outer hash', respectively, of the HMAC function.
+ *
+ * After execution of this function, the @a hmac_ctx will contain the
+ * precomputed inner and outer contexts, so that they may be used by
+ * #fsl_shw_hmac().  The flags of @a hmac_ctx will be updated with
+ * #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT to mark their presence.  In addition, the
+ * #FSL_HMAC_FLAGS_INIT flag will be set.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param      key_info  The key being used in this operation.  Key must be
+ *                       1 to 64 octets long.
+ * @param[in,out] hmac_ctx The context which controls, by its flags and
+ *                         algorithm, the operation of this function.
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t * user_ctx,
+						fsl_shw_sko_t * key_info,
+						fsl_shw_hmco_t * hmac_ctx);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-002 */
+/*!
+ * Continue, finalize, or one-shot an HMAC operation.
+ *
+ * There are a number of ways to use this function.  The flags in the
+ * @a hmac_ctx object will determine what operations occur.
+ *
+ * If #FSL_HMAC_FLAGS_INIT is set, then the hash will be started either from
+ * the @a key_info, or from the precomputed inner hash value in the
+ * @a hmac_ctx, depending on the value of #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT.
+ *
+ * If, instead, #FSL_HMAC_FLAGS_LOAD is set, then the hash will be continued
+ * from the ongoing inner hash computation in the @a hmac_ctx.
+ *
+ * If #FSL_HMAC_FLAGS_FINALIZE are set, then the @a msg will be padded, hashed,
+ * the outer hash will be performed, and the @a result will be generated.
+ *
+ * If the #FSL_HMAC_FLAGS_SAVE flag is set, then the (ongoing or final) digest
+ * value will be stored in the ongoing inner hash computation field of the @a
+ * hmac_ctx.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param key_info       If #FSL_HMAC_FLAGS_INIT is set in the @a hmac_ctx,
+ *                       this is the key being used in this operation, and the
+ *                       IPAD.  If #FSL_HMAC_FLAGS_INIT is set in the @a
+ *                       hmac_ctx and @a key_info is NULL, then
+ *                       #fsl_shw_hmac_precompute() has been used to populate
+ *                       the @a inner_precompute and @a outer_precompute
+ *                       contexts.  If #FSL_HMAC_FLAGS_INIT is not set, this
+ *                       parameter is ignored.
+
+ * @param[in,out] hmac_ctx The context which controls, by its flags and
+ *                       algorithm, the operation of this function.
+ * @param      msg               Pointer to the message to be hashed.
+ * @param      length            Length, in octets, of the @a msg.
+ * @param[out] result            Pointer, of @a result_len octets, to where to
+ *                               store the HMAC.
+ * @param      result_len        Length of @a result buffer.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info,
+				     fsl_shw_hmco_t * hmac_ctx,
+				     const uint8_t * msg,
+				     uint32_t length,
+				     uint8_t * result, uint32_t result_len);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
+/*!
+ * Get random data.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param      length    The number of octets of @a data being requested.
+ * @param[out] data      A pointer to a location of @a length octets to where
+ *                       random data will be returned.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx,
+					   uint32_t length, uint8_t * data);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
+/*!
+ * Add entropy to random number generator.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param      length    Number of bytes at @a data.
+ * @param      data      Entropy to add to random number generator.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx,
+					    uint32_t length, uint8_t * data);
+
+/*!
+ * Perform Generation-Encryption by doing a Cipher and a Hash.
+ *
+ * Generate the authentication value @a auth_value as well as encrypt the @a
+ * payload into @a ct (the ciphertext).  This is a one-shot function, so all of
+ * the @a auth_data and the total message @a payload must passed in one call.
+ * This also means that the flags in the @a auth_ctx must be #FSL_ACCO_CTX_INIT
+ * and #FSL_ACCO_CTX_FINALIZE.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      auth_ctx         Controlling object for Authenticate-decrypt.
+ * @param      cipher_key_info  The key being used for the cipher part of this
+ *                              operation.  In CCM mode, this key is used for
+ *                              both parts.
+ * @param      auth_key_info    The key being used for the authentication part
+ *                              of this operation.  In CCM mode, this key is
+ *                              ignored and may be NULL.
+ * @param      auth_data_length Length, in octets, of @a auth_data.
+ * @param      auth_data        Data to be authenticated but not encrypted.
+ * @param      payload_length   Length, in octets, of @a payload.
+ * @param      payload          Pointer to the plaintext to be encrypted.
+ * @param[out] ct               Pointer to the where the encrypted @a payload
+ *                              will be stored.  Must be @a payload_length
+ *                              octets long.
+ * @param[out] auth_value       Pointer to where the generated authentication
+ *                              field will be stored. Must be as many octets as
+ *                              indicated by MAC length in the @a function_ctx.
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
+					    fsl_shw_acco_t * auth_ctx,
+					    fsl_shw_sko_t * cipher_key_info,
+					    fsl_shw_sko_t * auth_key_info,
+					    uint32_t auth_data_length,
+					    const uint8_t * auth_data,
+					    uint32_t payload_length,
+					    const uint8_t * payload,
+					    uint8_t * ct, uint8_t * auth_value);
+
+/*!
+ * Perform Authentication-Decryption in Cipher + Hash.
+ *
+ * This function will perform a one-shot decryption of a data stream as well as
+ * authenticate the authentication value.  This is a one-shot function, so all
+ * of the @a auth_data and the total message @a payload must passed in one
+ * call.  This also means that the flags in the @a auth_ctx must be
+ * #FSL_ACCO_CTX_INIT and #FSL_ACCO_CTX_FINALIZE.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      auth_ctx         Controlling object for Authenticate-decrypt.
+ * @param      cipher_key_info  The key being used for the cipher part of this
+ *                              operation.  In CCM mode, this key is used for
+ *                              both parts.
+ * @param      auth_key_info    The key being used for the authentication part
+ *                              of this operation.  In CCM mode, this key is
+ *                              ignored and may be NULL.
+ * @param      auth_data_length Length, in octets, of @a auth_data.
+ * @param      auth_data        Data to be authenticated but not decrypted.
+ * @param      payload_length   Length, in octets, of @a ct and @a pt.
+ * @param      ct               Pointer to the encrypted input stream.
+ * @param      auth_value       The (encrypted) authentication value which will
+ *                              be authenticated.  This is the same data as the
+ *                              (output) @a auth_value argument to
+ *                              #fsl_shw_gen_encrypt().
+ * @param[out] payload          Pointer to where the plaintext resulting from
+ *                              the decryption will be stored.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
+					     fsl_shw_acco_t * auth_ctx,
+					     fsl_shw_sko_t * cipher_key_info,
+					     fsl_shw_sko_t * auth_key_info,
+					     uint32_t auth_data_length,
+					     const uint8_t * auth_data,
+					     uint32_t payload_length,
+					     const uint8_t * ct,
+					     const uint8_t * auth_value,
+					     uint8_t * payload);
+
+/*!
+ * Establish the key in a protected location, which can be the system keystore,
+ * user keystore, or (on platforms that support it) as a Platform Key.
+ *
+ * By default, keys initialized with #fsl_shw_sko_init() will be placed into
+ * the system keystore.  The user can cause the key to be established in a
+ * user keystore by first calling #fsl_shw_sko_set_keystore() on the key.
+ * Normally, keys in the system keystore can only be used for hardware
+ * encrypt or decrypt operations, however if the #FSL_SKO_KEY_SW_KEY flag is
+ * applied using #fsl_shw_sko_set_flags(), the key will be established as a
+ * software key, which can then be read out using #fsl_shw_read_key().
+ *
+ * Keys initialized with #fsl_shw_sko_init_pf_key() are established as a
+ * Platform Key.  Their use is covered in @ref di_sec.
+ *
+ * This function only needs to be used when unwrapping a key, setting up a key
+ * which could be wrapped with a later call to #fsl_shw_extract_key(), or
+ * setting up a key as a Platform Key.  Normal cleartext keys can simply be
+ * placed into #fsl_shw_sko_t key objects with #fsl_shw_sko_set_key() and used
+ * directly.
+ *
+ * The maximum key size supported for wrapped/unwrapped keys is 32 octets.
+ * (This is the maximum reasonable key length on Sahara - 32 octets for an HMAC
+ * key based on SHA-256.)  The key size is determined by the @a key_info.  The
+ * expected length of @a key can be determined by
+ * #fsl_shw_sko_calculate_wrapped_size()
+ *
+ * The protected key will not be available for use until this operation
+ * successfully completes.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param[in,out] key_info      The information about the key to be which will
+ *                              be established.  In the create case, the key
+ *                              length must be set.
+ * @param      establish_type   How @a key will be interpreted to establish a
+ *                              key for use.
+ * @param key                   If @a establish_type is #FSL_KEY_WRAP_UNWRAP,
+ *                              this is the location of a wrapped key.  If
+ *                              @a establish_type is #FSL_KEY_WRAP_CREATE, this
+ *                              parameter can be @a NULL.  If @a establish_type
+ *                              is #FSL_KEY_WRAP_ACCEPT, this is the location
+ *                              of a plaintext key.
+ */
+extern fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
+					      fsl_shw_sko_t * key_info,
+					      fsl_shw_key_wrap_t establish_type,
+					      const uint8_t * key);
+
+/*!
+ * Read the key value from a key object.
+ *
+ * Only a key marked as a software key (#FSL_SKO_KEY_SW_KEY) can be read with
+ * this call.  It has no effect on the status of the key store.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      key_info         The referenced key.
+ * @param[out] key              The location to store the key value.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_read_key(fsl_shw_uco_t * user_ctx,
+					 fsl_shw_sko_t * key_info,
+					 uint8_t * key);
+
+/*!
+ * Wrap a key and retrieve the wrapped value.
+ *
+ * A wrapped key is a key that has been cryptographically obscured.  It is
+ * only able to be used with keys that have been established by 
+ * #fsl_shw_establish_key().
+ *
+ * For keys established in the system or user keystore, this function will
+ * also release the key (see #fsl_shw_release_key()) so that it must be re-
+ * established before reuse.  This function will not release keys that are
+ * established as a Platform Key, so a call to #fsl_shw_release_key() is
+ * necessary to release those keys.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      key_info         The information about the key to be deleted.
+ * @param[out] covered_key      The location to store the wrapped key.
+ *                              (This size is based upon the maximum key size
+ *                              of 32 octets).
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
+					    fsl_shw_sko_t * key_info,
+					    uint8_t * covered_key);
+
+/*!
+ * De-establish a key so that it can no longer be accessed.
+ *
+ * The key will need to be re-established before it can again be used.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      key_info         The information about the key to be deleted.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
+					    fsl_shw_sko_t * key_info);
+
+/*!
+ * Cause the hardware to create a new random key for use by the secure memory
+ * encryption hardware.
+ *
+ * Have the hardware use the secure hardware random number generator to load a
+ * new secret key into the system's Random Key register.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_gen_random_pf_key(fsl_shw_uco_t * user_ctx);
+
+/*!
+ * Retrieve the detected tamper event.
+ *
+ * Note that if more than one event was detected, this routine will only ever
+ * return one of them.
+ *
+ * @param[in]  user_ctx         A user context from #fsl_shw_register_user().
+ * @param[out] tamperp          Location to store the tamper information.
+ * @param[out] timestampp       Locate to store timestamp from hardwhare when
+ *                              an event was detected.
+ *
+ *
+ * @return    A return code of type #fsl_shw_return_t (for instance, if the platform
+ *            is not in a fail state.
+ */
+extern fsl_shw_return_t fsl_shw_read_tamper_event(fsl_shw_uco_t * user_ctx,
+						  fsl_shw_tamper_t * tamperp,
+						  uint64_t * timestampp);
+
+/*! @} *//* opfuns */
+
+/* Insert example code into the API documentation. */
+
+/*!
+ * @example apitest.c
+ */
+
+/*!
+ * @example sym.c
+ */
+
+/*!
+ * @example rand.c
+ */
+
+/*!
+ * @example hash.c
+ */
+
+/*!
+ * @example hmac1.c
+ */
+
+/*!
+ * @example hmac2.c
+ */
+
+/*!
+ * @example gen_encrypt.c
+ */
+
+/*!
+ * @example auth_decrypt.c
+ */
+
+/*!
+ * @example wrapped_key.c
+ */
+
+/*!
+ * @example smalloc.c
+ */
+
+/*!
+ * @example user_keystore.c
+ */
+
+/*!
+ * @example dryice.c
+ */
+
+#endif				/* API_DOC */
 
 #endif				/* FSL_SHW_H */
diff --git a/drivers/mxc/security/sahara2/include/fsl_shw_keystore.h b/drivers/mxc/security/sahara2/include/fsl_shw_keystore.h
index d182a80..837d010 100644
--- a/drivers/mxc/security/sahara2/include/fsl_shw_keystore.h
+++ b/drivers/mxc/security/sahara2/include/fsl_shw_keystore.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -15,15 +15,14 @@
 #ifndef FSL_SHW_KEYSTORE_H
 #define FSL_SHW_KEYSTORE_H
 
-
-/**
+/*!
  * @file fsl_shw_keystore.h
  *
  * @brief Definition of the User Keystore API.
  *
  */
 
-/** \page user_keystore User Keystore API
+/*! \page user_keystore User Keystore API
  *
  * Definition of the User Keystore API.
  *
@@ -40,7 +39,7 @@
  *
  */
 
-/**
+/*!
  * @defgroup keystore_api User Keystore API
  *
  * Keystore API
@@ -50,7 +49,7 @@
  * keystore.
  */
 
-/**
+/*!
  * @defgroup default_keystore Default Keystore Implementation
  *
  * Default Keystore Implementation
@@ -68,20 +67,17 @@
  * Differences between the two versions are noted below.
  */
 
-
-
-/** @addtogroup keystore_api
+/*! @addtogroup keystore_api
     @{ */
 
 #ifndef KEYSTORE_SLOT_SIZE
-/** Size of each key slot, in octets.  This sets an upper bound on the size
+/*! Size of each key slot, in octets.  This sets an upper bound on the size
  * of a key that can placed in the keystore.
  */
 #define KEYSTORE_SLOT_SIZE 32
 #endif
 
-
-/**
+/*!
  * Initialize a Keystore Object.
  *
  * This function must be called before performing any other operation with the
@@ -119,25 +115,45 @@
  *                           For SCC: Not implemented.
  * @param slot_get_slot_size Get the size of the key slot, in octets.
  */
-extern void fsl_shw_init_keystore(
-    fsl_shw_kso_t *keystore,
-    fsl_shw_return_t (*data_init)        (fsl_shw_uco_t *user_ctx,
-                                          void **user_data),
-    void             (*data_cleanup)     (fsl_shw_uco_t *user_ctx,
-                                          void **user_data),
-    fsl_shw_return_t (*slot_alloc)       (void *user_data, uint32_t size,
-                                          uint64_t owner_id, uint32_t *slot),
-    fsl_shw_return_t (*slot_dealloc)     (void *user_data,
-                                          uint64_t owner_id, uint32_t slot),
-    fsl_shw_return_t (*slot_verify_access)(void *user_data,
-                                          uint64_t owner_id, uint32_t slot),
-    void*            (*slot_get_address) (void *user_data, uint32_t handle),
-    uint32_t         (*slot_get_base)    (void *user_data, uint32_t handle),
-    uint32_t         (*slot_get_offset)  (void *user_data, uint32_t handle),
-    uint32_t         (*slot_get_slot_size) (void *user_data, uint32_t handle));
-
-
-/**
+extern void fsl_shw_init_keystore(fsl_shw_kso_t * keystore,
+				  fsl_shw_return_t(*data_init) (fsl_shw_uco_t *
+								user_ctx,
+								void
+								**user_data),
+				  void (*data_cleanup) (fsl_shw_uco_t *
+							user_ctx,
+							void **user_data),
+				  fsl_shw_return_t(*slot_alloc) (void
+								 *user_data,
+								 uint32_t size,
+								 uint64_t
+								 owner_id,
+								 uint32_t *
+								 slot),
+				  fsl_shw_return_t(*slot_dealloc) (void
+								   *user_data,
+								   uint64_t
+								   owner_id,
+								   uint32_t
+								   slot),
+				  fsl_shw_return_t(*slot_verify_access) (void
+									 *user_data,
+									 uint64_t
+									 owner_id,
+									 uint32_t
+									 slot),
+				  void *(*slot_get_address) (void *user_data,
+							     uint32_t handle),
+				  uint32_t(*slot_get_base) (void *user_data,
+							    uint32_t handle),
+				  uint32_t(*slot_get_offset) (void *user_data,
+							      uint32_t handle),
+				  uint32_t(*slot_get_slot_size) (void
+								 *user_data,
+								 uint32_t
+								 handle));
+
+/*!
  * Initialize a Keystore Object.
  *
  * This function must be called before performing any other operation with the
@@ -147,10 +163,9 @@ extern void fsl_shw_init_keystore(
  *
  * @param keystore      The Keystore object to operate on.
  */
-extern void fsl_shw_init_keystore_default(fsl_shw_kso_t *keystore);
-
+extern void fsl_shw_init_keystore_default(fsl_shw_kso_t * keystore);
 
-/**
+/*!
  * Establish a Keystore Object.
  *
  * This function establishes a keystore object that has been set up by a call
@@ -163,11 +178,10 @@ extern void fsl_shw_init_keystore_default(fsl_shw_kso_t *keystore);
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t fsl_shw_establish_keystore(fsl_shw_uco_t *user_ctx,
-                        fsl_shw_kso_t* keystore);
+extern fsl_shw_return_t fsl_shw_establish_keystore(fsl_shw_uco_t * user_ctx,
+						   fsl_shw_kso_t * keystore);
 
-
-/**
+/*!
  * Release a Keystore Object.
  *
  * This function releases an established keystore object.  It is a wrapper for
@@ -178,11 +192,10 @@ extern fsl_shw_return_t fsl_shw_establish_keystore(fsl_shw_uco_t *user_ctx,
  *                      to.
  * @param keystore      The Keystore object to operate on.
  */
-extern void fsl_shw_release_keystore(fsl_shw_uco_t *user_ctx,
-                                     fsl_shw_kso_t *keystore);
-
+extern void fsl_shw_release_keystore(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_kso_t * keystore);
 
-/**
+/*!
  * Allocate a slot in the Keystore.
  *
  * This function attempts to allocate a slot to hold a key in the keystore.  It
@@ -198,13 +211,11 @@ extern void fsl_shw_release_keystore(fsl_shw_uco_t *user_ctx,
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t keystore_slot_alloc(fsl_shw_kso_t *keystore,
-                                            uint32_t size,
-                                            uint64_t owner_id,
-                                            uint32_t *slot);
+extern fsl_shw_return_t keystore_slot_alloc(fsl_shw_kso_t * keystore,
+					    uint32_t size,
+					    uint64_t owner_id, uint32_t * slot);
 
-
-/**
+/*!
  * Deallocate a slot in the Keystore.
  *
  * This function attempts to allocate a slot to hold a key in the keystore.
@@ -218,12 +229,10 @@ extern fsl_shw_return_t keystore_slot_alloc(fsl_shw_kso_t *keystore,
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t keystore_slot_dealloc(fsl_shw_kso_t *keystore,
-                                              uint64_t owner_id,
-                                              uint32_t slot);
-
+extern fsl_shw_return_t keystore_slot_dealloc(fsl_shw_kso_t * keystore,
+					      uint64_t owner_id, uint32_t slot);
 
-/**
+/*!
  * Load cleartext key data into a key slot
  *
  * This function loads a key slot with cleartext data.
@@ -236,19 +245,32 @@ extern fsl_shw_return_t keystore_slot_dealloc(fsl_shw_kso_t *keystore,
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-extern fsl_shw_return_t 
-keystore_load_slot(fsl_shw_kso_t *keystore, uint64_t owner_id, uint32_t slot,
-                   const uint8_t *key_data, uint32_t key_length);
+extern fsl_shw_return_t
+keystore_slot_load(fsl_shw_kso_t * keystore, uint64_t owner_id, uint32_t slot,
+		   const uint8_t * key_data, uint32_t key_length);
 
+/*!
+ * Read cleartext key data from a key slot
+ *
+ * This function returns the key in a key slot.
+ *
+ * @param keystore      The Keystore object to operate on.
+ * @param[in]  owner_id   ID of the key owner.
+ * @param[in]  slot       ID of slot where key resides.
+ * @param[in]  key_length Length of the key data (octets).
+ * @param[out] key_data   Pointer to the location of the cleartext key data.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t
+keystore_slot_read(fsl_shw_kso_t * keystore, uint64_t owner_id, uint32_t slot,
+		   uint32_t key_length, uint8_t * key_data);
 
-/**
+/*!
  * Encrypt a keyslot
  *
  * This function encrypts a key using the hardware secret key.
- dler. It uses an entire Secure Memory partition, divided in to equal slots of length KEYSTORE_SLOT_SIZE.
-
-
-*
+ *
  * @param user_ctx      User context
  * @param keystore      The Keystore object to operate on.
  * @param[in] owner_id  ID of the key owner.
@@ -260,14 +282,12 @@ keystore_load_slot(fsl_shw_kso_t *keystore, uint64_t owner_id, uint32_t slot,
  * @return    A return code of type #fsl_shw_return_t.
  */
 extern fsl_shw_return_t
-keystore_slot_encrypt(fsl_shw_uco_t *user_ctx,
-                      fsl_shw_kso_t *keystore, uint64_t owner_id,
-                      uint32_t slot, uint32_t length,
-                      uint8_t *destination);
+keystore_slot_encrypt(fsl_shw_uco_t * user_ctx,
+		      fsl_shw_kso_t * keystore, uint64_t owner_id,
+		      uint32_t slot, uint32_t length, uint8_t * destination);
 
-
-/**
- * Encrypt a keyslot
+/*!
+ * Decrypt a keyslot
  *
  * This function decrypts a key using the hardware secret key.
  *
@@ -282,38 +302,34 @@ keystore_slot_encrypt(fsl_shw_uco_t *user_ctx,
  * @return    A return code of type #fsl_shw_return_t.
  */
 extern fsl_shw_return_t
-keystore_slot_decrypt(fsl_shw_uco_t *user_ctx,
-                      fsl_shw_kso_t *keystore, uint64_t owner_id,
-                      uint32_t slot, uint32_t length,
-                      const uint8_t *source);
+keystore_slot_decrypt(fsl_shw_uco_t * user_ctx,
+		      fsl_shw_kso_t * keystore, uint64_t owner_id,
+		      uint32_t slot, uint32_t length, const uint8_t * source);
 
 /* @} */
 
-/** @addtogroup default_keystore
+/*! @addtogroup default_keystore
     @{ */
 
-
-/**
+/*!
  * Data structure to hold per-slot information
  */
 typedef struct keystore_data_slot_info_t {
-    uint8_t     allocated;              /**< Track slot assignments */
-    uint64_t    owner;                  /**< Owner IDs */
-    uint32_t    key_length;             /**< Size of the key */
+	uint8_t allocated;	/*!< Track slot assignments */
+	uint64_t owner;		/*!< Owner IDs */
+	uint32_t key_length;	/*!< Size of the key */
 } keystore_data_slot_info_t;
 
-
-/**
+/*!
  * Data structure to hold keystore information.
  */
 typedef struct keystore_data_t {
-    void*       base_address;           /**< Base of the Secure Partition */
-    uint32_t    slot_count;             /**< Number of slots in the keystore */
-    struct keystore_data_slot_info_t* slot; /**< Per-slot information */
+	void *base_address;	/*!< Base of the Secure Partition */
+	uint32_t slot_count;	/*!< Number of slots in the keystore */
+	struct keystore_data_slot_info_t *slot;	/*!< Per-slot information */
 } keystore_data_t;
 
-
-/**
+/*!
  * Default keystore initialization routine.
  *
  * This function acquires a Secure Partition Object to store the keystore,
@@ -326,11 +342,9 @@ typedef struct keystore_data_t {
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-fsl_shw_return_t shw_kso_init_data     (fsl_shw_uco_t *user_ctx,
-                                        void **user_data);
-
+fsl_shw_return_t shw_kso_init_data(fsl_shw_uco_t * user_ctx, void **user_data);
 
-/**
+/*!
  * Default keystore cleanup routine.
  *
  * This function releases the Secure Partition Object and the memory holding
@@ -341,11 +355,9 @@ fsl_shw_return_t shw_kso_init_data     (fsl_shw_uco_t *user_ctx,
  * @param[in,out] user_data Pointer to the location where the keystore data
  *                          structure is stored.
  */
-void             shw_kso_cleanup_data  (fsl_shw_uco_t *user_ctx,
-                                        void **user_data);
+void shw_kso_cleanup_data(fsl_shw_uco_t * user_ctx, void **user_data);
 
-
-/**
+/*!
  * Default keystore slot access verification
  *
  * This function compares the supplied Owner ID to the registered owner of
@@ -359,10 +371,9 @@ void             shw_kso_cleanup_data  (fsl_shw_uco_t *user_ctx,
  * @return    A return code of type #fsl_shw_return_t.
  */
 fsl_shw_return_t shw_slot_verify_access(void *user_data, uint64_t owner_id,
-                                        uint32_t slot);
-
+					uint32_t slot);
 
-/**
+/*!
  * Default keystore slot allocation
  *
  * This function first checks that the requested size is equal to or less than
@@ -379,11 +390,10 @@ fsl_shw_return_t shw_slot_verify_access(void *user_data, uint64_t owner_id,
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-fsl_shw_return_t shw_slot_alloc        (void *user_data, uint32_t size,
-                                        uint64_t owner_id, uint32_t *slot);
+fsl_shw_return_t shw_slot_alloc(void *user_data, uint32_t size,
+				uint64_t owner_id, uint32_t * slot);
 
-
-/**
+/*!
  * Default keystore slot deallocation
  *
  * This function releases the given key slot in the keystore, making it
@@ -396,11 +406,10 @@ fsl_shw_return_t shw_slot_alloc        (void *user_data, uint32_t size,
  *
  * @return    A return code of type #fsl_shw_return_t.
  */
-fsl_shw_return_t shw_slot_dealloc      (void *user_data,
-                                        uint64_t owner_id, uint32_t slot);
-
+fsl_shw_return_t shw_slot_dealloc(void *user_data,
+				  uint64_t owner_id, uint32_t slot);
 
-/**
+/*!
  * Default keystore slot address lookup
  *
  * This function calculates the address where the key data is stored.
@@ -412,10 +421,9 @@ fsl_shw_return_t shw_slot_dealloc      (void *user_data,
  * @return    SCC2: Virtual address (kernel or userspace) of the key data.
  *            SCC: Physical address of the key data.
  */
-void*            shw_slot_get_address  (void *user_data, uint32_t slot);
+void *shw_slot_get_address(void *user_data, uint32_t slot);
 
-
-/**
+/*!
  * Default keystore slot base address lookup
  *
  * This function calculates the base address of the Secure Partition on which
@@ -429,10 +437,9 @@ void*            shw_slot_get_address  (void *user_data, uint32_t slot);
  * @return    SCC2: Secure Partition virtual (kernel or userspace) base address.
  *            SCC: Secure Partition physical base address.
  */
-uint32_t         shw_slot_get_base     (void *user_data, uint32_t slot);
-
+uint32_t shw_slot_get_base(void *user_data, uint32_t slot);
 
-/**
+/*!
  * Default keystore slot offset lookup
  *
  * This function calculates the offset from the base of the Secure Partition
@@ -445,10 +452,9 @@ uint32_t         shw_slot_get_base     (void *user_data, uint32_t slot);
  * @return    SCC2: Key data offset (octets)
  *            SCC: Not implemented
  */
-uint32_t         shw_slot_get_offset   (void *user_data, uint32_t slot);
+uint32_t shw_slot_get_offset(void *user_data, uint32_t slot);
 
-
-/**
+/*!
  * Default keystore slot offset lookup
  *
  * This function returns the size of the given key slot.  In the reference
@@ -462,9 +468,8 @@ uint32_t         shw_slot_get_offset   (void *user_data, uint32_t slot);
  * @return    SCC2: Keystore slot size.
  *            SCC: Not implemented
  */
-uint32_t         shw_slot_get_slot_size (void *user_data, uint32_t slot);
+uint32_t shw_slot_get_slot_size(void *user_data, uint32_t slot);
 
 /* @} */
 
-
 #endif /* FSL_SHW_KEYSTORE_H */
diff --git a/drivers/mxc/security/sahara2/include/linux_port.h b/drivers/mxc/security/sahara2/include/linux_port.h
index fad1ef1..6891754 100644
--- a/drivers/mxc/security/sahara2/include/linux_port.h
+++ b/drivers/mxc/security/sahara2/include/linux_port.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -62,16 +62,21 @@
 #include <linux/delay.h>
 #include <linux/slab.h>		/* kmalloc */
 
+#include <stdarg.h>
+
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-#include <linux/device.h>	/* used in dynamic power management */
+#include <linux/device.h>  /* used in dynamic power management */
 #else
-#include <linux/platform_device.h>	/* used in dynamic power management */
+#include <linux/platform_device.h>  /* used in dynamic power management */
 #endif
 
+#include <linux/dmapool.h>
+#include <linux/dma-mapping.h>
+
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
-#include <asm/arch/clock.h>	/* clock en/disable for DPM */
+#include <asm/arch/clock.h>         /* clock en/disable for DPM */
 #else
-#include <linux/clk.h>		/* clock en/disable for DPM */
+#include <linux/clk.h>         /* clock en/disable for DPM */
 #endif
 
 #include <linux/dmapool.h>
@@ -83,38 +88,35 @@
 #include <asm/cacheflush.h>
 
 #ifndef TRUE
-/** Useful symbol for unsigned values used as flags. */
+/*! Useful symbol for unsigned values used as flags. */
 #define TRUE 1
 #endif
 
 #ifndef FALSE
-/** Useful symbol for unsigned values used as flags. */
+/*! Useful symbol for unsigned values used as flags. */
 #define FALSE 0
 #endif
 
-
 /* These symbols are defined in Linux 2.6 and later.  Include here for minimal
  * support of 2.4 kernel.
  **/
 #if !defined(LINUX_VERSION_CODE) || LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-/**
+/*!
  * Symbol defined somewhere in 2.5/2.6.  It is the return signature of an ISR.
  */
 #define irqreturn_t void
-/** Possible return value of 'modern' ISR routine. */
+/*! Possible return value of 'modern' ISR routine. */
 #define IRQ_HANDLED
-/** Method of generating value of 'modern' ISR routine. */
+/*! Method of generating value of 'modern' ISR routine. */
 #define IRQ_RETVAL(x)
 #endif
 
-
-/**
+/*!
  * Type used for registering and deregistering interrupts.
  */
 typedef int os_interrupt_id_t;
 
-
-/**
+/*!
  * Type used as handle for a process
  *
  * See #os_get_process_handle() and #os_send_signal().
@@ -132,24 +134,21 @@ typedef task_t *os_process_handle_t;
 typedef struct task_struct *os_process_handle_t;
 #endif
 
-
-
-/**
+/*!
  * Generic return code for functions which need such a thing.
  *
  * No knowledge should be assumed of the value of any of these symbols except
  * that @c OS_ERROR_OK_S is guaranteed to be zero.
  */
 typedef enum {
-    OS_ERROR_OK_S = 0,         /**< Success  */
-    OS_ERROR_FAIL_S = -EIO,    /**< Generic driver failure */
-    OS_ERROR_NO_MEMORY_S = -ENOMEM, /**< Failure to acquire/use memory  */
-    OS_ERROR_BAD_ADDRESS_S = -EFAULT, /**< Bad address  */
-    OS_ERROR_BAD_ARG_S = -EINVAL, /**< Bad input argument  */
+	OS_ERROR_OK_S = 0,	/*!< Success  */
+	OS_ERROR_FAIL_S = -EIO,	/*!< Generic driver failure */
+	OS_ERROR_NO_MEMORY_S = -ENOMEM,	/*!< Failure to acquire/use memory  */
+	OS_ERROR_BAD_ADDRESS_S = -EFAULT,	/*!< Bad address  */
+	OS_ERROR_BAD_ARG_S = -EINVAL,	/*!< Bad input argument  */
 } os_error_code;
 
-
-/**
+/*!
  * Handle to a lock.
  */
 #ifdef CONFIG_PREEMPT_RT
@@ -158,64 +157,67 @@ typedef raw_spinlock_t *os_lock_t;
 typedef spinlock_t *os_lock_t;
 #endif
 
-/**
+/*!
  * Context while locking.
  */
 typedef unsigned long os_lock_context_t;
 
-/**
+/*!
  * Declare a wait object for sleeping/waking processes.
  */
 #define OS_WAIT_OBJECT(name)                                            \
     DECLARE_WAIT_QUEUE_HEAD(name##_qh)
 
-/**
+/*!
  * Driver registration handle
  *
  * Used with #os_driver_init_registration(), #os_driver_add_registration(),
  * and #os_driver_complete_registration().
  */
 typedef struct {
-    unsigned reg_complete;      /**< TRUE if next inits succeeded. */
-    dev_t  dev;                 /**< dev_t for register_chrdev() */
-    struct file_operations fops; /**< struct for register_chrdev() */
+	unsigned reg_complete;	/*!< TRUE if next inits succeeded. */
+	dev_t dev;		/*!< dev_t for register_chrdev() */
+	struct file_operations fops;	/*!< struct for register_chrdev() */
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
-    struct class_simple *cs;    /**< results of class_simple_create() */
+	struct class_simple *cs;	/*!< results of class_simple_create() */
 #else
-    struct class        *cs;    /**< results of class_create() */
+	struct class *cs;	/*!< results of class_create() */
 #endif
-    struct device *cd;    /**< Result of class_simple_device_add() */
-    unsigned power_complete;    /**< TRUE if next inits succeeded */
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+	struct class_device *cd;	/*!< Result of class_device_create() */
+#else
+	struct device *cd;	/*!< Result of device_create() */
+#endif
+	unsigned power_complete;	/*!< TRUE if next inits succeeded */
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-    struct device_driver   dd;  /**< struct for register_driver() */
+	struct device_driver dd;	/*!< struct for register_driver() */
 #else
-    struct platform_driver dd;  /**< struct for register_driver() */
+	struct platform_driver dd;	/*!< struct for register_driver() */
 #endif
-    struct platform_device pd;  /**< struct for platform_register_device() */
+	struct platform_device pd;	/*!< struct for platform_register_device() */
 } os_driver_reg_t;
 
-
 /*
  *  Function types which can be associated with driver entry points.
  *
  *  Note that init and shutdown are absent.
  */
-/** @{ */
-/** Keyword for registering open() operation handler. */
+/*! @{ */
+/*! Keyword for registering open() operation handler. */
 #define OS_FN_OPEN open
-/** Keyword for registering close() operation handler. */
+/*! Keyword for registering close() operation handler. */
 #define OS_FN_CLOSE release
-/** Keyword for registering read() operation handler. */
+/*! Keyword for registering read() operation handler. */
 #define OS_FN_READ read
-/** Keyword for registering write() operation handler. */
+/*! Keyword for registering write() operation handler. */
 #define OS_FN_WRITE write
-/** Keyword for registering ioctl() operation handler. */
+/*! Keyword for registering ioctl() operation handler. */
 #define OS_FN_IOCTL ioctl
-/** Keyword for registering mmap() operation handler. */
+/*! Keyword for registering mmap() operation handler. */
 #define OS_FN_MMAP mmap
-/** @} */
+/*! @} */
 
-/**
+/*!
  * Function signature for the portable interrupt handler
  *
  * While it would be nice to know which interrupt is being serviced, the
@@ -223,23 +225,23 @@ typedef struct {
  *
  * @return  Zero if not handled, non-zero if handled.
  */
-#if  LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-typedef int (*os_interrupt_handler_t)(int, void*, struct pt_regs*);
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+typedef int (*os_interrupt_handler_t) (int, void *, struct pt_regs *);
 #else
-typedef int (*os_interrupt_handler_t)(int, void*);
+typedef int (*os_interrupt_handler_t) (int, void *);
 #endif
 
-/**
+/*!
  * @defgroup dkops Driver-to-Kernel Operations
  *
  * These are the operations which drivers should call to get the OS to perform
  * services.
  */
 
-/** @addtogroup dkops */
-/** @{ */
+/*! @addtogroup dkops */
+/*! @{ */
 
-/**
+/*!
  * Register an interrupt handler.
  *
  * @param driver_name    The name of the driver
@@ -252,9 +254,7 @@ typedef int (*os_interrupt_handler_t)(int, void*);
 #define os_register_interrupt(driver_name, interrupt_id, function)            \
      request_irq(interrupt_id, function, 0, driver_name, NULL)
 
-
-
-/**
+/*!
  * Deregister an interrupt handler.
  *
  * @param interrupt_id   The interrupt line to stop monitoring
@@ -264,28 +264,27 @@ typedef int (*os_interrupt_handler_t)(int, void*);
 #define os_deregister_interrupt(interrupt_id)                                 \
      free_irq(interrupt_id, NULL)
 
-/**
+/*!
  * INTERNAL implementation of os_driver_init_registration()
  *
  * @return An os error code.
  */
-static inline int os_drv_do_init_reg(os_driver_reg_t *handle)
+inline static int os_drv_do_init_reg(os_driver_reg_t * handle)
 {
-    memset(handle, sizeof(*handle), 0);
-    handle->fops.owner = THIS_MODULE;
-    handle->power_complete = FALSE;
-    handle->reg_complete = FALSE;
+	memset(handle, 0, sizeof(*handle));
+	handle->fops.owner = THIS_MODULE;
+	handle->power_complete = FALSE;
+	handle->reg_complete = FALSE;
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-    handle->dd.name = NULL;
+	handle->dd.name = NULL;
 #else
-    handle->dd.driver.name = NULL;
+	handle->dd.driver.name = NULL;
 #endif
 
-    return OS_ERROR_OK_S;
+	return OS_ERROR_OK_S;
 }
 
-
-/**
+/*!
  * Initialize driver registration.
  *
  * If the driver handles open(), close(), ioctl(), read(), write(), or mmap()
@@ -301,8 +300,7 @@ static inline int os_drv_do_init_reg(os_driver_reg_t *handle)
 #define os_driver_init_registration(handle)                                   \
     os_drv_do_init_reg(&handle)
 
-
-/**
+/*!
  * Add a function registration to driver registration.
  *
  * @param handle    A handle initialized by #os_driver_init_registration().
@@ -314,8 +312,7 @@ static inline int os_drv_do_init_reg(os_driver_reg_t *handle)
 #define os_driver_add_registration(handle, name, function)                    \
     do {handle.fops.name = (void*)(function); } while (0)
 
-
-/**
+/*!
  * Record 'power suspend' function for the device.
  *
  * @param handle    A handle initialized by #os_driver_init_registration().
@@ -328,8 +325,7 @@ static inline int os_drv_do_init_reg(os_driver_reg_t *handle)
 #define os_driver_register_power_suspend(handle, function)                    \
    handle.dd.suspend = function
 
-
-/**
+/*!
  * Record 'power resume' function for the device.
  *
  * @param handle    A handle initialized by #os_driver_init_registration().
@@ -342,8 +338,7 @@ static inline int os_drv_do_init_reg(os_driver_reg_t *handle)
 #define os_driver_register_resume(handle, function)                          \
    handle.dd.resume = function
 
-
-/**
+/*!
  * INTERNAL function of the Linux port of the OS API.   Implements the
  * os_driver_complete_registration() function.
  *
@@ -357,122 +352,146 @@ static inline int os_drv_do_init_reg(os_driver_reg_t *handle)
  *
  * @return  An error code
  */
-inline static int os_drv_do_reg(os_driver_reg_t *handle,
-                                unsigned major, char*driver_name)
+inline static int os_drv_do_reg(os_driver_reg_t * handle,
+				unsigned major, char *driver_name)
 {
-    os_error_code code = OS_ERROR_NO_MEMORY_S;
-    char* name = kmalloc(strlen(driver_name)+1, 0);
-
-    if (name != NULL) {
-        memcpy(name, driver_name,strlen(driver_name)+1);
-        code = OS_ERROR_OK_S; /* OK so far */
-        /* If any chardev/POSIX routines were added, then do chrdev part */
-        if (handle->fops.open || handle->fops.release || handle->fops.read ||
-            handle->fops.write || handle->fops.ioctl || handle->fops.mmap) {
-
-            printk("ioctl pointer: %p.  mmap pointer: %p\n",
-                    handle->fops.ioctl, handle->fops.mmap);
-
-            /* this method is depricated, see:
-             * http://lwn.net/Articles/126808/
-             */
-            code = register_chrdev(major, driver_name, &handle->fops);
-
-
-            /* instead something like this: */
+	os_error_code code = OS_ERROR_NO_MEMORY_S;
+	char *name = kmalloc(strlen(driver_name) + 1, 0);
+
+	if (name != NULL) {
+		memcpy(name, driver_name, strlen(driver_name) + 1);
+		code = OS_ERROR_OK_S;	/* OK so far */
+		/* If any chardev/POSIX routines were added, then do chrdev part */
+		if (handle->fops.open || handle->fops.release
+		    || handle->fops.read || handle->fops.write
+		    || handle->fops.ioctl || handle->fops.mmap) {
+
+			printk("ioctl pointer: %p.  mmap pointer: %p\n",
+			       handle->fops.ioctl, handle->fops.mmap);
+
+			/* this method is depricated, see:
+			 * http://lwn.net/Articles/126808/
+			 */
+			code =
+			    register_chrdev(major, driver_name, &handle->fops);
+
+			/* instead something like this: */
 #if 0
-            handle->dev = MKDEV(major, 0);
-	    	code = register_chrdev_region(handle->dev, 1, driver_name);
-            if (code < 0) {
-                code = OS_ERROR_FAIL_S;
-            } else {
-                cdev_init(&handle->cdev, &handle->fops);
-                code = cdev_add(&handle->cdev, major, 1);
-            }
+			handle->dev = MKDEV(major, 0);
+			code =
+			    register_chrdev_region(handle->dev, 1, driver_name);
+			if (code < 0) {
+				code = OS_ERROR_FAIL_S;
+			} else {
+				cdev_init(&handle->cdev, &handle->fops);
+				code = cdev_add(&handle->cdev, major, 1);
+			}
 #endif
 
-
-            if (code < 0) {
-                code = OS_ERROR_FAIL_S;
-            } else {
-                if (code != 0) {
-                    /* Zero was passed in for major; code is actual value */
-                    handle->dev = MKDEV(code, 0);
-                } else {
-                    handle->dev = MKDEV(major, 0);
-                }
-                code = OS_ERROR_OK_S;
+			if (code < 0) {
+				code = OS_ERROR_FAIL_S;
+			} else {
+				if (code != 0) {
+					/* Zero was passed in for major; code is actual value */
+					handle->dev = MKDEV(code, 0);
+				} else {
+					handle->dev = MKDEV(major, 0);
+				}
+				code = OS_ERROR_OK_S;
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
-                handle->cs = class_simple_create(THIS_MODULE, driver_name);
-                if (IS_ERR(handle->cs)) {
-                    code = (os_error_code)handle->cs;
-                    handle->cs = NULL;
-                } else {
-                    handle->cd = class_simple_device_add(handle->cs,
-                                                        handle->dev, NULL,
-                                                        driver_name);
-                    if (IS_ERR(handle->cd)) {
-                        class_simple_device_remove(handle->dev);
-                        unregister_chrdev(MAJOR(handle->dev), driver_name);
-                        code = (os_error_code)handle->cs;
-                        handle->cs = NULL;
-                    } else {
-                        handle->reg_complete = TRUE;
-                    }
-                }
+				handle->cs =
+				    class_simple_create(THIS_MODULE,
+							driver_name);
+				if (IS_ERR(handle->cs)) {
+					code = (os_error_code) handle->cs;
+					handle->cs = NULL;
+				} else {
+					handle->cd =
+					    class_simple_device_add(handle->cs,
+								    handle->dev,
+								    NULL,
+								    driver_name);
+					if (IS_ERR(handle->cd)) {
+						class_simple_device_remove
+						    (handle->dev);
+						unregister_chrdev(MAJOR
+								  (handle->dev),
+								  driver_name);
+						code =
+						    (os_error_code) handle->cs;
+						handle->cs = NULL;
+					} else {
+						handle->reg_complete = TRUE;
+					}
+				}
 #else
-                handle->cs = class_create(THIS_MODULE, driver_name);
-                if (IS_ERR(handle->cs)) {
-                    code = (os_error_code)handle->cs;
-                    handle->cs = NULL;
-                } else {
-                    handle->cd = device_create(handle->cs, NULL, handle->dev,
-                                               driver_name);
-                    if (IS_ERR(handle->cd)) {
-                        class_destroy(handle->cs);
-                        unregister_chrdev(MAJOR(handle->dev), driver_name);
-                        code = (os_error_code)handle->cs;
-                        handle->cs = NULL;
-                    } else {
-                        handle->reg_complete = TRUE;
-                    }
-                }
+				handle->cs =
+				    class_create(THIS_MODULE, driver_name);
+				if (IS_ERR(handle->cs)) {
+					code = (os_error_code) handle->cs;
+					handle->cs = NULL;
+				} else {
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+					handle->cd =
+					    class_device_create(handle->cs,
+								NULL,
+								handle->dev,
+								NULL,
+								driver_name);
+#else
+					handle->cd =
+					    device_create(handle->cs, NULL,
+							  handle->dev,
+							  driver_name);
+#endif
+					if (IS_ERR(handle->cd)) {
+						class_destroy(handle->cs);
+						unregister_chrdev(MAJOR
+								  (handle->dev),
+								  driver_name);
+						code =
+						    (os_error_code) handle->cs;
+						handle->cs = NULL;
+					} else {
+						handle->reg_complete = TRUE;
+					}
+				}
 #endif
-            }
-        } /* ... fops routine registered */
-        /* Handle power management fns through separate interface */
-        if ((code == OS_ERROR_OK_S) &&
-            (handle->dd.suspend || handle->dd.resume)) {
+			}
+		}
+		/* ... fops routine registered */
+		/* Handle power management fns through separate interface */
+		if ((code == OS_ERROR_OK_S) &&
+		    (handle->dd.suspend || handle->dd.resume)) {
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-            handle->dd.name = name;
-            handle->dd.bus = &platform_bus_type;
-            code = driver_register(&handle->dd);
+			handle->dd.name = name;
+			handle->dd.bus = &platform_bus_type;
+			code = driver_register(&handle->dd);
 #else
-            handle->dd.driver.name = name;
-            handle->dd.driver.bus = &platform_bus_type;
-            code = driver_register(&handle->dd.driver);
+			handle->dd.driver.name = name;
+			handle->dd.driver.bus = &platform_bus_type;
+			code = driver_register(&handle->dd.driver);
 #endif
-            if (code == OS_ERROR_OK_S) {
-                handle->pd.name = name;
-                handle->pd.id = 0;
-                code = platform_device_register(&handle->pd);
-                if (code != OS_ERROR_OK_S) {
+			if (code == OS_ERROR_OK_S) {
+				handle->pd.name = name;
+				handle->pd.id = 0;
+				code = platform_device_register(&handle->pd);
+				if (code != OS_ERROR_OK_S) {
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-                    driver_unregister(&handle->dd);
+					driver_unregister(&handle->dd);
 #else
-                    driver_unregister(&handle->dd.driver);
+					driver_unregister(&handle->dd.driver);
 #endif
-                }  else {
-                    handle->power_complete = TRUE;
-                }
-            }
-        } /* ... suspend or resume */
-    }  /* name != NULL */
-    return code;
+				} else {
+					handle->power_complete = TRUE;
+				}
+			}
+		}		/* ... suspend or resume */
+	}			/* name != NULL */
+	return code;
 }
 
-
-/**
+/*!
  * Finalize the driver registration with the kernel.
  *
  * Upon return from this call, the driver may begin receiving calls at the
@@ -491,8 +510,7 @@ inline static int os_drv_do_reg(os_driver_reg_t *handle,
 #define os_driver_complete_registration(handle, major, driver_name)           \
    os_drv_do_reg(&handle, major, driver_name)
 
-
-/**
+/*!
  * Get driver Major Number from handle after a successful registration.
  *
  * @param   handle  A handle which has completed registration.
@@ -502,65 +520,67 @@ inline static int os_drv_do_reg(os_driver_reg_t *handle,
 #define os_driver_get_major(handle)                                           \
     (handle.reg_complete ? MAJOR(handle.dev) : -1)
 
-
-/**
+/*!
  * INTERNAL implemention of os_driver_remove_registration.
  *
  * @param handle    A handle initialized by #os_driver_init_registration().
  *
  * @return  An error code.
  */
-inline static int os_drv_rmv_reg(os_driver_reg_t* handle)
+inline static int os_drv_rmv_reg(os_driver_reg_t * handle)
 {
-    if (handle->reg_complete) {
+	if (handle->reg_complete) {
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
-        if (handle->cd != NULL) {
-            class_simple_device_remove(handle->dev);
-            handle->cd = NULL;
-        }
-        if (handle->cs != NULL) {
-            class_simple_destroy(handle->cs);
-            handle->cs = NULL;
-        }
-        unregister_chrdev(MAJOR(handle->dev), handle->dd.name);
+		if (handle->cd != NULL) {
+			class_simple_device_remove(handle->dev);
+			handle->cd = NULL;
+		}
+		if (handle->cs != NULL) {
+			class_simple_destroy(handle->cs);
+			handle->cs = NULL;
+		}
+		unregister_chrdev(MAJOR(handle->dev), handle->dd.name);
+#else
+		if (handle->cd != NULL) {
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+			class_device_destroy(handle->cs, handle->dev);
 #else
-        if (handle->cd != NULL) {
-            device_destroy(handle->cs, handle->dev);
-            handle->cd = NULL;
-        }
-        if (handle->cs != NULL) {
-            class_destroy(handle->cs);
-            handle->cs = NULL;
-        }
-        unregister_chrdev(MAJOR(handle->dev), handle->dd.driver.name);
+			device_destroy(handle->cs, handle->dev);
 #endif
-        handle->reg_complete = FALSE;
-    }
-    if (handle->power_complete) {
-        platform_device_unregister(&handle->pd);
+			handle->cd = NULL;
+		}
+		if (handle->cs != NULL) {
+			class_destroy(handle->cs);
+			handle->cs = NULL;
+		}
+		unregister_chrdev(MAJOR(handle->dev), handle->dd.driver.name);
+#endif
+		handle->reg_complete = FALSE;
+	}
+	if (handle->power_complete) {
+		platform_device_unregister(&handle->pd);
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-        driver_unregister(&handle->dd);
+		driver_unregister(&handle->dd);
 #else
-        driver_unregister(&handle->dd.driver);
+		driver_unregister(&handle->dd.driver);
 #endif
-        handle->power_complete = FALSE;
-    }
+		handle->power_complete = FALSE;
+	}
 #if  LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-    if (handle->dd.name != NULL) {
-        kfree(handle->dd.name);
-        handle->dd.name = NULL;
-    }
+	if (handle->dd.name != NULL) {
+		kfree(handle->dd.name);
+		handle->dd.name = NULL;
+	}
 #else
-    if (handle->dd.driver.name != NULL) {
-        kfree(handle->dd.driver.name);
-        handle->dd.driver.name = NULL;
-    }
+	if (handle->dd.driver.name != NULL) {
+		kfree(handle->dd.driver.name);
+		handle->dd.driver.name = NULL;
+	}
 #endif
-    return OS_ERROR_OK_S;
+	return OS_ERROR_OK_S;
 }
 
-
-/**
+/*!
  * Remove the driver's registration with the kernel.
  *
  * Upon return from this call, the driver not receive any more calls at the
@@ -573,8 +593,7 @@ inline static int os_drv_rmv_reg(os_driver_reg_t* handle)
 #define os_driver_remove_registration(handle)                                 \
    os_drv_rmv_reg(&handle)
 
-
-/**
+/*!
  * Register a driver with the Linux Device Model.
  *
  * @param   driver_information  The device_driver structure information
@@ -586,7 +605,7 @@ inline static int os_drv_rmv_reg(os_driver_reg_t* handle)
 #define os_register_to_driver(driver_information)                             \
               driver_register(driver_information)
 
-/**
+/*!
  * Unregister a driver from the Linux Device Model
  *
  * this routine unregisters from the Linux Device Model
@@ -600,7 +619,7 @@ inline static int os_drv_rmv_reg(os_driver_reg_t* handle)
 #define os_unregister_from_driver(driver_information)                         \
                 driver_unregister(driver_information)
 
-/**
+/*!
  * register a device to a driver
  *
  * this routine registers a drivers devices to the Linux Device Model
@@ -614,7 +633,7 @@ inline static int os_drv_rmv_reg(os_driver_reg_t* handle)
 #define os_register_a_device(device_information)                              \
     platform_device_register(device_information)
 
-/**
+/*!
  * unregister a device from a driver
  *
  * this routine unregisters a drivers devices from the Linux Device Model
@@ -628,8 +647,7 @@ inline static int os_drv_rmv_reg(os_driver_reg_t* handle)
 #define os_unregister_a_device(device_information)                            \
     platform_device_unregister(device_information)
 
-
-/**
+/*!
  * Print a message to console / into log file.  After the @c msg argument a
  * number of printf-style arguments may be added.  Types should be limited to
  * printf string, char, octal, decimal, and hexadecimal types.  (This excludes
@@ -643,7 +661,7 @@ inline static int os_drv_rmv_reg(os_driver_reg_t* handle)
 #define os_printk(...)                                                        \
     (void) printk(__VA_ARGS__)
 
-/**
+/*!
  * Prepare a task to execute the given function.  This should only be done once
  * per function,, during the driver's initialization routine.
  *
@@ -654,8 +672,7 @@ inline static int os_drv_rmv_reg(os_driver_reg_t* handle)
 #define os_create_task(function_name)                                         \
     OS_ERROR_OK_S
 
-
-/**
+/*!
  * Schedule execution of a task.
  *
  * @param function_name   The function associated with the task.
@@ -665,8 +682,7 @@ inline static int os_drv_rmv_reg(os_driver_reg_t* handle)
 #define os_dev_schedule_task(function_name)                                   \
     tasklet_schedule(&(function_name ## let))
 
-
-/**
+/*!
  * Make sure that task is no longer running and will no longer run.
  *
  * This function will not return until both are true.  This is useful when
@@ -678,7 +694,7 @@ do {                                                                          \
     tasklet_kill(&(function_name ## let));                                    \
 } while (0)
 
-/**
+/*!
  * Allocate some kernel memory
  *
  * @param amount   Number of 8-bit bytes to allocate
@@ -689,8 +705,7 @@ do {                                                                          \
 #define os_alloc_memory(amount, flags)                                        \
     (void*)kmalloc(amount, flags)
 
-
-/**
+/*!
  * Free some kernel memory
  *
  * @param location  The beginning of the region to be freed.
@@ -702,8 +717,7 @@ do {                                                                          \
 #define os_free_memory(location)                                              \
     kfree(location)
 
-
-/**
+/*!
  * Allocate cache-coherent memory
  *
  * @param       amount     Number of bytes to allocate
@@ -718,8 +732,7 @@ do {                                                                          \
 #define os_alloc_coherent(amount, dma_addrp, flags)                           \
     (void*)dma_alloc_coherent(NULL, amount, dma_addrp, flags)
 
-
-/**
+/*!
  * Free cache-coherent memory
  *
  * @param       size       Number of bytes which were allocated.
@@ -734,8 +747,7 @@ do {                                                                          \
 #define os_free_coherent(size, virt_addr, dma_addr)                           \
     dma_free_coherent(NULL, size, virt_addr, dma_addr
 
-
-/**
+/*!
  * Map an I/O space into kernel memory space
  *
  * @param start       The starting address of the (physical / io space) region
@@ -746,8 +758,7 @@ do {                                                                          \
 #define os_map_device(start, range_bytes)                                     \
     (void*)ioremap_nocache((start), range_bytes)
 
-
-/**
+/*!
  * Unmap an I/O space from kernel memory space
  *
  * @param start       The starting address of the (virtual) region
@@ -758,8 +769,7 @@ do {                                                                          \
 #define os_unmap_device(start, range_bytes)                                   \
     iounmap((void*)(start))
 
-
-/**
+/*!
  * Copy data from Kernel space to User space
  *
  * @param to   The target location in user memory
@@ -771,8 +781,7 @@ do {                                                                          \
 #define os_copy_to_user(to, from, size)                                       \
     ((copy_to_user(to, from, size) == 0) ? 0 : OS_ERROR_BAD_ADDRESS_S)
 
-
-/**
+/*!
  * Copy data from User space to Kernel space
  *
  * @param to   The target location in kernel memory
@@ -784,8 +793,7 @@ do {                                                                          \
 #define os_copy_from_user(to, from, size)                                     \
     ((copy_from_user(to, from, size) == 0) ? 0 : OS_ERROR_BAD_ADDRESS_S)
 
-
-/**
+/*!
  * Read a 8-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -794,8 +802,7 @@ do {                                                                          \
 #define os_read8(register_address)                                            \
     __raw_readb(register_address)
 
-
-/**
+/*!
  * Write a 8-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -804,7 +811,7 @@ do {                                                                          \
 #define os_write8(register_address, value)                                    \
     __raw_writeb(value, register_address)
 
-/**
+/*!
  * Read a 16-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -813,8 +820,7 @@ do {                                                                          \
 #define os_read16(register_address)                                           \
     __raw_readw(register_address)
 
-
-/**
+/*!
  * Write a 16-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -823,7 +829,7 @@ do {                                                                          \
 #define os_write16(register_address, value)                                   \
     __raw_writew(value, (uint32_t*)(register_address))
 
-/**
+/*!
  * Read a 32-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -832,8 +838,7 @@ do {                                                                          \
 #define os_read32(register_address)                                           \
     __raw_readl((uint32_t*)(register_address))
 
-
-/**
+/*!
  * Write a 32-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -842,7 +847,7 @@ do {                                                                          \
 #define os_write32(register_address, value)                                   \
     __raw_writel(value, register_address)
 
-/**
+/*!
  * Read a 64-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -851,8 +856,7 @@ do {                                                                          \
 #define os_read64(register_address)                                           \
      ERROR_UNIMPLEMENTED
 
-
-/**
+/*!
  * Write a 64-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
@@ -861,7 +865,7 @@ do {                                                                          \
 #define os_write64(register_address, value)                                   \
     ERROR_UNIMPLEMENTED
 
-/**
+/*!
  * Delay some number of microseconds
  *
  * Note that this is a busy-loop, not a suspension of the task/process.
@@ -872,8 +876,7 @@ do {                                                                          \
  */
 #define os_mdelay mdelay
 
-
-/**
+/*!
  * Calculate virtual address from physical address
  *
  * @param pa    Physical address
@@ -884,8 +887,7 @@ do {                                                                          \
  */
 #define os_va __va
 
-
-/**
+/*!
  * Calculate physical address from virtual address
  *
  *
@@ -897,9 +899,8 @@ do {                                                                          \
  */
 #define os_pa __pa
 
-
 #ifdef CONFIG_PREEMPT_RT
-/**
+/*!
  * Allocate and initialize a lock, returning a lock handle.
  *
  * The lock state will be initialized to 'unlocked'.
@@ -908,18 +909,18 @@ do {                                                                          \
  */
 inline static os_lock_t os_lock_alloc_init(void)
 {
-    raw_spinlock_t* lockp;
-    lockp = (raw_spinlock_t*)kmalloc(sizeof(raw_spinlock_t), 0);
-    if (lockp) {
-        _raw_spin_lock_init(lockp);
-    } else {
-        printk("OS: lock init failed\n");
-    }
-
-    return lockp;
+	raw_spinlock_t *lockp;
+	lockp = (raw_spinlock_t *) kmalloc(sizeof(raw_spinlock_t), 0);
+	if (lockp) {
+		_raw_spin_lock_init(lockp);
+	} else {
+		printk("OS: lock init failed\n");
+	}
+
+	return lockp;
 }
 #else
-/**
+/*!
  * Allocate and initialize a lock, returning a lock handle.
  *
  * The lock state will be initialized to 'unlocked'.
@@ -928,19 +929,19 @@ inline static os_lock_t os_lock_alloc_init(void)
  */
 inline static os_lock_t os_lock_alloc_init(void)
 {
-    spinlock_t* lockp;
-    lockp = (spinlock_t*)kmalloc(sizeof(spinlock_t), 0);
-    if (lockp) {
-        spin_lock_init(lockp);
-    } else {
-        printk("OS: lock init failed\n");
-    }
-
-    return lockp;
+	spinlock_t *lockp;
+	lockp = (spinlock_t *) kmalloc(sizeof(spinlock_t), 0);
+	if (lockp) {
+		spin_lock_init(lockp);
+	} else {
+		printk("OS: lock init failed\n");
+	}
+
+	return lockp;
 }
-#endif /* CONFIG_PREEMPT_RT */
+#endif				/* CONFIG_PREEMPT_RT */
 
-/**
+/*!
  * Acquire a lock.
  *
  * This function should only be called from an interrupt service routine.
@@ -952,8 +953,7 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_lock(lock_handle)                                              \
    spin_lock(lock_handle)
 
-
-/**
+/*!
  * Unlock a lock.  Lock must have been acquired by #os_lock().
  *
  * @param   lock_handle  A handle to the lock to unlock.
@@ -963,8 +963,7 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_unlock(lock_handle)                                            \
    spin_unlock(lock_handle)
 
-
-/**
+/*!
  * Acquire a lock in non-ISR context
  *
  * This function will spin until the lock is available.
@@ -977,7 +976,7 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_lock_save_context(lock_handle, context)                        \
     spin_lock_irqsave(lock_handle, context)
 
-/**
+/*!
  * Release a lock in non-ISR context
  *
  * @param lock_handle  A handle of the lock to release.
@@ -988,8 +987,7 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_unlock_restore_context(lock_handle, context)                  \
     spin_unlock_irqrestore(lock_handle, context)
 
-
-/**
+/*!
  * Deallocate a lock handle.
  *
  * @param lock_handle   An #os_lock_t that has been allocated.
@@ -999,8 +997,7 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_lock_deallocate(lock_handle)                                   \
     kfree(lock_handle)
 
-
-/**
+/*!
  * Determine process handle
  *
  * The process handle of the current user is returned.
@@ -1010,8 +1007,7 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_get_process_handle()                                           \
     current
 
-
-/**
+/*!
  * Send a signal to a process
  *
  * @param  proc   A handle to the target process.
@@ -1020,8 +1016,7 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_send_signal(proc, sig)                                         \
     send_sig(sig, proc, 0);
 
-
-/**
+/*!
  * Get some random bytes
  *
  * @param buf    The location to store the random data.
@@ -1032,8 +1027,7 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_get_random_bytes(buf, count)                                   \
     get_random_bytes(buf, count)
 
-
-/**
+/*!
  * Go to sleep on an object.
  *
  * @param object    The object on which to sleep
@@ -1067,8 +1061,7 @@ inline static os_lock_t os_lock_alloc_init(void)
     code;                                                               \
 })
 
-
-/**
+/*!
  * Wake up whatever is sleeping on sleep object
  *
  * @param object  The object on which things might be sleeping
@@ -1078,15 +1071,13 @@ inline static os_lock_t os_lock_alloc_init(void)
 #define os_wake_sleepers(object)                                        \
     wake_up_interruptible(&(object##_qh));
 
-
-/** @} */ /* dkops */
-
+	  /*! @} *//* dkops */
 
 /******************************************************************************
  *  Function signature-generating macros
  *****************************************************************************/
 
-/**
+/*!
  * @defgroup drsigs Driver Signatures
  *
  * These macros will define the entry point signatures for interrupt handlers;
@@ -1130,10 +1121,10 @@ inline static os_lock_t os_lock_alloc_init(void)
  *
  */
 
-/** @addtogroup drsigs */
-/** @{ */
+/*! @addtogroup drsigs */
+/*! @{ */
 
-/**
+/*!
  * Define a function which will handle device initialization
  *
  * This is tne driver initialization routine.  This is normally where the
@@ -1149,15 +1140,13 @@ inline static os_lock_t os_lock_alloc_init(void)
 module_init(function_name);                                                   \
 static int __init function_name (void)
 
-
-/** Make declaration for driver init function.
+/*! Make declaration for driver init function.
  * @param function_name foo
  */
 #define OS_DEV_INIT_DCL(function_name)                                        \
 static int __init function_name (void);
 
-
-/**
+/*!
  * Generate a function reference to the driver's init function.
  * @param function_name   Name of the OS_DEV_INIT() function.
  *
@@ -1166,8 +1155,7 @@ static int __init function_name (void);
 #define OS_DEV_INIT_REF(function_name)                                        \
 function_name
 
-
-/**
+/*!
  * Define a function which will handle device shutdown
  *
  * This is the inverse of the #OS_DEV_INIT() routine.
@@ -1181,8 +1169,7 @@ function_name
 module_exit(function_name);                                                   \
 static void function_name(void)
 
-
-/**
+/*!
  * Generate a function reference to the driver's shutdown function.
  * @param function_name   Name of the OS_DEV_HUSTDOWN() function.
  *
@@ -1191,7 +1178,7 @@ static void function_name(void)
 #define OS_DEV_SHUTDOWN_DCL(function_name)                                    \
 static void function_name(void);
 
-/**
+/*!
  * Generate a reference to driver's shutdown function
  * @param function_name   Name of the OS_DEV_HUSTDOWN() function.
 */
@@ -1199,8 +1186,7 @@ static void function_name(void);
 #define OS_DEV_SHUTDOWN_REF(function_name)                                    \
 function_name
 
-
-/**
+/*!
  * Define a function which will open the device for a user.
  *
  * @param function_name The name of the driver open() function
@@ -1210,8 +1196,7 @@ function_name
 #define OS_DEV_OPEN(function_name)                                            \
 static int function_name(struct inode* inode_p_, struct file* file_p_)
 
-
-/**
+/*!
  * Declare prototype for an open() function.
  *
  * @param function_name The name of the OS_DEV_OPEN() function.
@@ -1219,8 +1204,7 @@ static int function_name(struct inode* inode_p_, struct file* file_p_)
 #define OS_DEV_OPEN_DCL(function_name)                                        \
 OS_DEV_OPEN(function_name);
 
-
-/**
+/*!
  * Generate a function reference to the driver's open() function.
  * @param function_name   Name of the OS_DEV_OPEN() function.
  *
@@ -1229,8 +1213,7 @@ OS_DEV_OPEN(function_name);
 #define OS_DEV_OPEN_REF(function_name)                                        \
 function_name
 
-
-/**
+/*!
  * Define a function which will handle a user's ioctl() request
  *
  * @param function_name The name of the driver ioctl() function
@@ -1241,11 +1224,11 @@ function_name
 static int function_name(struct inode* inode_p_, struct file* file_p_,        \
                      unsigned int cmd_, unsigned long data_)
 
-/** Boo. */
+/*! Boo. */
 #define OS_DEV_IOCTL_DCL(function_name)                                       \
 OS_DEV_IOCTL(function_name);
 
-/**
+/*!
  * Generate a function reference to the driver's ioctl() function.
  * @param function_name   Name of the OS_DEV_IOCTL() function.
  *
@@ -1254,7 +1237,7 @@ OS_DEV_IOCTL(function_name);
 #define OS_DEV_IOCTL_REF(function_name)                                       \
 function_name
 
-/**
+/*!
  * Define a function which will handle a user's mmap() request
  *
  * @param function_name The name of the driver mmap() function
@@ -1264,7 +1247,6 @@ function_name
 #define OS_DEV_MMAP(function_name)                                            \
 int function_name(struct file* file_p_, struct vm_area_struct* vma_)
 
-
 #define OS_DEV_MMAP_DCL(function_name)                                        \
 OS_DEV_MMAP(function_name);
 
@@ -1280,7 +1262,7 @@ function_name
 /* Determine the base address of the requested MMAP region*/
 #define os_mmap_user_base() (vma_->vm_start)
 
-/**
+/*!
  * Declare prototype for an read() function.
  *
  * @param function_name The name of the driver read function.
@@ -1288,7 +1270,7 @@ function_name
 #define OS_DEV_READ_DCL(function_name)                                        \
 OS_DEV_READ(function_name);
 
-/**
+/*!
  * Generate a function reference to the driver's read() routine
  * @param function_name   Name of the OS_DEV_READ() function.
  *
@@ -1297,8 +1279,7 @@ OS_DEV_READ(function_name);
 #define OS_DEV_READ_REF(function_name)                                        \
 function_name
 
-
-/**
+/*!
  * Define a function which will handle a user's write() request
  *
  * @param function_name The name of the driver write() function
@@ -1309,8 +1290,7 @@ function_name
 static ssize_t function_name(struct file* file_p_, char* user_buffer_,        \
                      size_t count_bytes_, loff_t* file_position_)
 
-
-/**
+/*!
  * Declare prototype for an write() function.
  *
  * @param function_name The name of the driver write function.
@@ -1318,7 +1298,7 @@ static ssize_t function_name(struct file* file_p_, char* user_buffer_,        \
 #define OS_DEV_WRITE_DCL(function_name)                                       \
 OS_DEV_WRITE(function_name);
 
-/**
+/*!
  * Generate a function reference to the driver's write() routine
  * @param function_name   Name of the OS_DEV_WRITE() function.
  *
@@ -1327,8 +1307,7 @@ OS_DEV_WRITE(function_name);
 #define OS_DEV_WRITE_REF(function_name)                                       \
 function_name
 
-
-/**
+/*!
  * Define a function which will close the device - opposite of OS_DEV_OPEN()
  *
  * @param function_name The name of the driver close() function
@@ -1338,7 +1317,7 @@ function_name
 #define OS_DEV_CLOSE(function_name)                                           \
 static int function_name(struct inode* inode_p_, struct file* file_p_)
 
-/**
+/*!
  * Declare prototype for an close() function
  *
  * @param function_name The name of the driver close() function.
@@ -1346,7 +1325,7 @@ static int function_name(struct inode* inode_p_, struct file* file_p_)
 #define OS_DEV_CLOSE_DCL(function_name)                                       \
 OS_DEV_CLOSE(function_name);
 
-/**
+/*!
  * Generate a function reference to the driver's close function.
  * @param function_name   Name of the OS_DEV_CLOSE() function.
  *
@@ -1355,8 +1334,7 @@ OS_DEV_CLOSE(function_name);
 #define OS_DEV_CLOSE_REF(function_name)                                       \
 function_name
 
-
-/**
+/*!
  * Define a function which will handle an interrupt
  *
  * No arguments are available to the generic function.  It must not invoke any
@@ -1383,7 +1361,7 @@ static irqreturn_t function_name(int N1_, void* N2_, struct pt_regs* N3_)
 static irqreturn_t function_name(int N1_, void* N2_)
 #endif
 
-/**
+/*!
  * Declare prototype for an ISR function.
  *
  * @param function_name The name of the driver ISR function.
@@ -1391,7 +1369,7 @@ static irqreturn_t function_name(int N1_, void* N2_)
 #define OS_DEV_ISR_DCL(function_name)                                         \
 OS_DEV_ISR(function_name);
 
-/**
+/*!
  * Generate a function reference to the driver's interrupt service routine
  * @param function_name   Name of the OS_DEV_ISR() function.
  *
@@ -1400,8 +1378,7 @@ OS_DEV_ISR(function_name);
 #define OS_DEV_ISR_REF(function_name)                                         \
 function_name
 
-
-/**
+/*!
  * Define a function which will operate as a background task / bottom half.
  *
  * Tasklet stuff isn't strictly limited to 'Device drivers', but leave it
@@ -1414,8 +1391,7 @@ function_name
 #define OS_DEV_TASK(function_name)                                            \
 static void function_name(unsigned long data_)
 
-
-/**
+/*!
  * Declare prototype for a background task / bottom half function
  *
  * @param function_name The name of this background task function
@@ -1424,8 +1400,7 @@ static void function_name(unsigned long data_)
 OS_DEV_TASK(function_name);                                                   \
 DECLARE_TASKLET(function_name ## let, function_name, 0);
 
-
-/**
+/*!
  * Generate a reference to an #OS_DEV_TASK() function
  *
  * @param function_name   The name of the task being referenced.
@@ -1433,15 +1408,13 @@ DECLARE_TASKLET(function_name ## let, function_name, 0);
 #define OS_DEV_TASK_REF(function_name)                                        \
     (function_name ## let)
 
-
-/** @} */ /* drsigs */
-
+	  /*! @} *//* drsigs */
 
 /*****************************************************************************
  *  Functions/Macros for returning values from Driver Signature routines
  *****************************************************************************/
 
-/**
+/*!
  * Return from the #OS_DEV_INIT() function
  *
  * @param code    An error code to report success or failure.
@@ -1450,8 +1423,7 @@ DECLARE_TASKLET(function_name ## let, function_name, 0);
 #define os_dev_init_return(code)                                             \
     return code
 
-
-/**
+/*!
  * Return from the #OS_DEV_SHUTDOWN() function
  *
  * @param code    An error code to report success or failure.
@@ -1460,8 +1432,7 @@ DECLARE_TASKLET(function_name ## let, function_name, 0);
 #define os_dev_shutdown_return(code)                                         \
     return
 
-
-/**
+/*!
  * Return from the #OS_DEV_ISR() function
  *
  * The function should verify that it really was supposed to be called,
@@ -1492,8 +1463,7 @@ do {                                                                         \
 } while (0)
 #endif
 
-
-/**
+/*!
  * Return from the #OS_DEV_OPEN() function
  *
  * @param code    An error code to report success or failure.
@@ -1510,9 +1480,7 @@ do {                                                                         \
     return retcode;                                                          \
 } while (0)
 
-
-
-/**
+/*!
  * Return from the #OS_DEV_IOCTL() function
  *
  * @param code    An error code to report success or failure.
@@ -1531,9 +1499,7 @@ do {                                                                         \
     return retcode;                                                          \
 } while (0)
 
-
-
-/**
+/*!
  * Return from the #OS_DEV_READ() function
  *
  * @param code    Number of bytes read, or an error code to report failure.
@@ -1552,8 +1518,7 @@ do {                                                                         \
     return retcode;                                                          \
 } while (0)
 
-
-/**
+/*!
  * Return from the #OS_DEV_WRITE() function
  *
  * @param code    Number of bytes written, or an error code to report failure.
@@ -1572,7 +1537,7 @@ do {                                                                         \
     return retcode;                                                          \
 } while (0)
 
-/**
+/*!
  * Return from the #OS_DEV_CLOSE() function
  *
  * @param code    An error code to report success or failure.
@@ -1589,8 +1554,7 @@ do {                                                                         \
     return retcode;                                                          \
 } while (0)
 
-
-/**
+/*!
  * Start the #OS_DEV_TASK() function
  *
  * In some implementations, this could be turned into a label for
@@ -1600,8 +1564,7 @@ do {                                                                         \
  */
 #define os_dev_task_begin()
 
-
-/**
+/*!
  * Return from the #OS_DEV_TASK() function
  *
  * In some implementations, this could be turned into a sleep followed
@@ -1618,17 +1581,16 @@ do {                                                                         \
     return;                                                                  \
 } while (0)
 
-
 /*****************************************************************************
  *  Functions/Macros for accessing arguments from Driver Signature routines
  *****************************************************************************/
 
-/** @defgroup drsigargs Functions for Getting Arguments in Signature functions
+/*! @defgroup drsigargs Functions for Getting Arguments in Signature functions
  *
  */
 /* @addtogroup @drsigargs */
-/** @{ */
-/**
+/*! @{ */
+/*!
  * Used in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ() and
  * #OS_DEV_WRITE() routines to check whether user is requesting read
  * (permission)
@@ -1636,7 +1598,7 @@ do {                                                                         \
 #define os_dev_is_flag_read()                                                 \
    (file_p_->f_mode & FMODE_READ)
 
-/**
+/*!
  * Used in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ() and
  * #OS_DEV_WRITE() routines to check whether user is requesting write
  * (permission)
@@ -1644,8 +1606,7 @@ do {                                                                         \
 #define os_dev_is_flag_write()                                                \
    (file_p_->f_mode & FMODE_WRITE)
 
-
-/**
+/*!
  * Used in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ() and
  * #OS_DEV_WRITE() routines to check whether user is requesting non-blocking
  * I/O.
@@ -1653,23 +1614,21 @@ do {                                                                         \
 #define os_dev_is_flag_nonblock()                                             \
    (file_p_->f_flags & (O_NONBLOCK | O_NDELAY))
 
-
-/**
+/*!
  * Used in #OS_DEV_OPEN() and #OS_DEV_CLOSE() to determine major device being
  * accessed.
  */
 #define os_dev_get_major()                                                    \
     (imajor(inode_p_))
 
-
-/**
+/*!
  * Used in #OS_DEV_OPEN() and #OS_DEV_CLOSE() to determine minor device being
  * accessed.
  */
 #define os_dev_get_minor()                                                    \
     (iminor(inode_p_))
 
-/**
+/*!
  * Used in #OS_DEV_IOCTL() to determine which operation the user wants
  * performed.
  *
@@ -1678,7 +1637,7 @@ do {                                                                         \
 #define os_dev_get_ioctl_op()                                                 \
     (cmd_)
 
-/**
+/*!
  * Used in #OS_DEV_IOCTL() to return the associated argument for the desired
  * operation.
  *
@@ -1688,7 +1647,7 @@ do {                                                                         \
 #define os_dev_get_ioctl_arg()                                                \
     (data_)
 
-/**
+/*!
  * Used in OS_DEV_READ() and OS_DEV_WRITE() routines to access the requested
  * byte count.
  *
@@ -1697,7 +1656,7 @@ do {                                                                         \
 #define os_dev_get_count()                                                    \
     ((unsigned)count_bytes_)
 
-/**
+/*!
  * Used in OS_DEV_READ() and OS_DEV_WRITE() routines to return the pointer
  * byte count.
  *
@@ -1706,7 +1665,7 @@ do {                                                                         \
 #define os_dev_get_user_buffer()                                              \
     ((void*)user_buffer_)
 
-/**
+/*!
  * Used in OS_DEV_READ(), OS_DEV_WRITE(), and OS_DEV_IOCTL() routines to
  * get the POSIX flags field for the associated open file).
  *
@@ -1715,8 +1674,7 @@ do {                                                                         \
 #define os_dev_get_file_flags()                                               \
     (file_p_->f_flags)
 
-
-/**
+/*!
  * Set the driver's private structure associated with this file/open.
  *
  * Generally used during #OS_DEV_OPEN().  See #os_dev_get_user_private().
@@ -1726,7 +1684,7 @@ do {                                                                         \
 #define os_dev_set_user_private(struct_p)                                     \
     file_p_->private_data = (void*)(struct_p)
 
-/**
+/*!
  * Get the driver's private structure associated with this file.
  *
  * May be used during #OS_DEV_OPEN(), #OS_DEV_READ(), #OS_DEV_WRITE(),
@@ -1737,8 +1695,7 @@ do {                                                                         \
 #define os_dev_get_user_private()                                             \
     ((void*)file_p_->private_data)
 
-
-/**
+/*!
  * Get the IRQ associated with this call to the #OS_DEV_ISR() function.
  *
  * @return  The IRQ (integer) interrupt number.
@@ -1746,18 +1703,17 @@ do {                                                                         \
 #define os_dev_get_irq()                                                      \
     N1_
 
-/** @} */  /* drsigargs */
-
+	   /*! @} *//* drsigargs */
 
-/**
+/*!
  * @defgroup cacheops Cache Operations
  *
  * These functions are for synchronizing processor cache with RAM.
  */
-/** @addtogroup cacheops */
-/** @{ */
+/*! @addtogroup cacheops */
+/*! @{ */
 
-/**
+/*!
  * Flush and invalidate all cache lines.
  */
 #if 0
@@ -1768,7 +1724,7 @@ do {                                                                         \
 #define os_flush_cache_all()                                              \
     v6_flush_kern_cache_all_L2()
 
-/**
+/*!
  * ARM-routine to flush all cache.  Defined here, because it exists in no
  * easy-access header file.  ARM-11 with L210 cache only!
  */
@@ -1782,7 +1738,7 @@ extern void v6_flush_kern_cache_all_L2(void);
  *  call, which the Sahara driver code will never invoke.
  */
 
-/**
+/*!
  * Clean a range of addresses from the cache.  That is, write updates back
  * to (RAM, next layer).
  *
@@ -1804,7 +1760,7 @@ extern void v6_flush_kern_cache_all_L2(void);
 }
 #endif
 
-/**
+/*!
  * Invalidate a range of addresses in the cache
  *
  * @param  start    Starting virtual address
@@ -1825,7 +1781,7 @@ extern void v6_flush_kern_cache_all_L2(void);
 }
 #endif
 
-/**
+/*!
  * Flush a range of addresses from the cache.  That is, perform clean
  * and invalidate
  *
@@ -1847,7 +1803,6 @@ extern void v6_flush_kern_cache_all_L2(void);
 }
 #endif
 
-/** @} */ /* cacheops */
-
+	  /*! @} *//* cacheops */
 
 #endif				/* LINUX_PORT_H */
diff --git a/drivers/mxc/security/sahara2/include/portable_os.h b/drivers/mxc/security/sahara2/include/portable_os.h
index baa5ca6..e904b32 100644
--- a/drivers/mxc/security/sahara2/include/portable_os.h
+++ b/drivers/mxc/security/sahara2/include/portable_os.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -40,7 +40,7 @@
 
 /***************************************************************************/
 
-/**
+/*!
  * @file portable_os.h
  *
  * This file should be included by portable driver code in order to gain access
@@ -53,7 +53,7 @@
  *
  */
 
-/**
+/*!
  * @if USE_MAINPAGE
  * @mainpage Generic OS API for STC Drivers
  * @endif
@@ -115,7 +115,7 @@
  * logical devices to access, because the design usually calls for some sort of
  * indication to the #OS_DEV_TASK() function or OS_DEV_ISR() to indicate which
  * channel is to be serviced by that instance of the task/function.  This sort
- * of argument is missing in this API for functions like os_schedule_task() and
+ * of argument is missing in this API for functions like os_dev_schedule_task() and
  * os_register_interrupt().
  *
  *
@@ -170,7 +170,6 @@
  *
  */
 
-
 /***************************************************************************
  * Compile flags
  **************************************************************************/
@@ -181,7 +180,7 @@
  */
 #ifdef DOXYGEN_PORTABLE_OS_DOC
 
-/**
+/*!
  * @todo module_init()/module_cleanup() for Linux need to be added to OS
  * abstractions.  Also need EXPORT_SYMBOL() equivalent??
  *
@@ -189,15 +188,14 @@
 
 /* Drop OS differentation documentation here */
 
-
-/**
+/*!
  * \#define this flag to build your driver as a Linux driver
  */
 #define LINUX
 
 /* end OS differentation documentation */
 
-/**
+/*!
  * Symbol to give version number of the implementation file.  Earliest
  * definition is in version 1.1, with value 101 (to mean version 1.1)
  */
@@ -213,27 +211,25 @@
  * DOXYGEN_PORTABLE_OS_DOC flag.
  */
 
-
 /***************************************************************************
  * Type definitions
  **************************************************************************/
 
-/**
+/*!
  * Type used for registering and deregistering interrupts.
  *
  * This is typically an interrupt channel number.
  */
 typedef int os_interrupt_id_t;
 
-/**
+/*!
  * Type used as handle for a process
  *
  * See #os_get_process_handle() and #os_send_signal().
  */
 typedef int os_process_handle_t;
 
-
-/**
+/*!
  * Generic return code for functions which need such a thing.
  *
  * No knowledge should be assumed of the value of any of these symbols except
@@ -243,63 +239,55 @@ typedef int os_process_handle_t;
  * too Linux/Unix-specific read()/write() return values) ?
  */
 typedef enum {
-    OS_ERROR_OK_S = 0,          /**< Success  */
-    OS_ERROR_FAIL_S,            /**< Generic driver failure */
-    OS_ERROR_NO_MEMORY_S,       /**< Failure to acquire/use memory  */
-    OS_ERROR_BAD_ADDRESS_S,     /**< Bad address  */
-    OS_ERROR_BAD_ARG_S          /**< Bad input argument */
+	OS_ERROR_OK_S = 0,	/*!< Success  */
+	OS_ERROR_FAIL_S,	/*!< Generic driver failure */
+	OS_ERROR_NO_MEMORY_S,	/*!< Failure to acquire/use memory  */
+	OS_ERROR_BAD_ADDRESS_S,	/*!< Bad address  */
+	OS_ERROR_BAD_ARG_S	/*!< Bad input argument */
 } os_error_code;
 
-
-/**
+/*!
  * Handle to a lock.
  */
-typedef int* os_lock_t;
-
+typedef int *os_lock_t;
 
-/**
+/*!
  * Context while locking.
  */
 typedef int os_lock_context_t;
 
-
-/**
+/*!
  * An object which can be slept on and later used to wake any/all sleepers.
  */
 typedef int os_sleep_object_t;
 
-
-/**
+/*!
  * Driver registration handle
  */
-typedef void* os_driver_reg_t;
+typedef void *os_driver_reg_t;
 
-
-/**
+/*!
  * Function signature for an #OS_DEV_INIT() function.
  *
  * @return  A call to os_dev_init_return() function.
  */
-typedef void (*os_init_function_t)(void);
-
+typedef void (*os_init_function_t) (void);
 
-/**
+/*!
  * Function signature for an #OS_DEV_SHUTDOWN() function.
  *
  * @return  A call to os_dev_shutdown_return() function.
  */
-typedef void (*os_shutdown_function_t)(void);
+typedef void (*os_shutdown_function_t) (void);
 
-
-/**
+/*!
  * Function signature for a user-driver function.
  *
  * @return  A call to the appropriate os_dev_xxx_return() function.
  */
-typedef void (*os_user_function_t)(void);
-
+typedef void (*os_user_function_t) (void);
 
-/**
+/*!
  * Function signature for the portable interrupt handler
  *
  * While it would be nice to know which interrupt is being serviced, the
@@ -307,10 +295,9 @@ typedef void (*os_user_function_t)(void);
  *
  * @return  A call to #os_dev_isr_return()
  */
-typedef void (*os_interrupt_handler_t)(void);
+typedef void (*os_interrupt_handler_t) (void);
 
-
-/**
+/*!
  * Function signature for a task function
  *
  * Many task function definitions get some sort of generic argument so that the
@@ -320,40 +307,38 @@ typedef void (*os_interrupt_handler_t)(void);
  * This function must be structured as documented by #OS_DEV_TASK().
  *
  */
-typedef void (*os_task_fn_t)(void);
-
+typedef void (*os_task_fn_t) (void);
 
-/**
+/*!
  *  Function types which can be associated with driver entry points.  These are
  *  used in os_driver_add_registration().
  *
  *  Note that init and shutdown are absent.
  */
 typedef enum {
-    OS_FN_OPEN,                 /**< open() operation handler. */
-    OS_FN_CLOSE,                /**< close() operation handler. */
-    OS_FN_READ,                 /**< read() operation handler. */
-    OS_FN_WRITE,                /**< write() operation handler. */
-    OS_FN_IOCTL,                /**< ioctl() operation handler. */
-    OS_FN_MMAP                  /**< mmap() operation handler. */
+	OS_FN_OPEN,		/*!< open() operation handler. */
+	OS_FN_CLOSE,		/*!< close() operation handler. */
+	OS_FN_READ,		/*!< read() operation handler. */
+	OS_FN_WRITE,		/*!< write() operation handler. */
+	OS_FN_IOCTL,		/*!< ioctl() operation handler. */
+	OS_FN_MMAP		/*!< mmap() operation handler. */
 } os_driver_fn_t;
 
-
 /***************************************************************************
  * Driver-to-Kernel Operations
  **************************************************************************/
 
-/**
+/*!
  * @defgroup dkops Driver-to-Kernel Operations
  *
  * These are the operations which drivers should call to get the OS to perform
  * services.
  */
 
-/** @addtogroup dkops */
-/** @{ */
+/*! @addtogroup dkops */
+/*! @{ */
 
-/**
+/*!
  * Register an interrupt handler.
  *
  * @param driver_name    The name of the driver
@@ -363,12 +348,11 @@ typedef enum {
  *
  * @return #os_error_code
  */
-os_error_code os_register_interrupt(char* driver_name,
-                                    os_interrupt_id_t interrupt_id,
-                                    os_interrupt_handler_t function);
+os_error_code os_register_interrupt(char *driver_name,
+				    os_interrupt_id_t interrupt_id,
+				    os_interrupt_handler_t function);
 
-
-/**
+/*!
  * Deregister an interrupt handler.
  *
  * @param interrupt_id   The interrupt line to stop monitoring
@@ -377,8 +361,7 @@ os_error_code os_register_interrupt(char* driver_name,
  */
 os_error_code os_deregister_interrupt(os_interrupt_id_t interrupt_id);
 
-
-/**
+/*!
  * Initialize driver registration.
  *
  * If the driver handles open(), close(), ioctl(), read(), write(), or mmap()
@@ -393,8 +376,7 @@ os_error_code os_deregister_interrupt(os_interrupt_id_t interrupt_id);
  */
 os_error_code os_driver_init_registration(os_driver_reg_t handle);
 
-
-/**
+/*!
  * Add a function registration to driver registration.
  *
  * @param handle    The handle used with #os_driver_init_registration().
@@ -405,10 +387,9 @@ os_error_code os_driver_init_registration(os_driver_reg_t handle);
  * @return void
  */
 void os_driver_add_registration(os_driver_reg_t handle, os_driver_fn_t name,
-                                void* function);
-
+				void *function);
 
-/**
+/*!
  * Finalize the driver registration with the kernel.
  *
  * Upon return from this call, the driver may begin receiving calls at the
@@ -425,11 +406,9 @@ void os_driver_add_registration(os_driver_reg_t handle, os_driver_fn_t name,
  * @return  An error code
  */
 os_error_code os_driver_complete_registration(os_driver_reg_t handle,
-                                              int major,
-                                              char* driver_name);
+					      int major, char *driver_name);
 
-
-/**
+/*!
  * Get driver Major Number from handle after a successful registration.
  *
  * @param   handle  A handle which has completed registration.
@@ -438,8 +417,7 @@ os_error_code os_driver_complete_registration(os_driver_reg_t handle,
  */
 uint32_t os_driver_get_major(os_driver_reg_t handle);
 
-
-/**
+/*!
  * Remove the driver's registration with the kernel.
  *
  * Upon return from this call, the driver not receive any more calls at the
@@ -450,10 +428,9 @@ uint32_t os_driver_get_major(os_driver_reg_t handle);
  *
  * @return  An error code.
  */
-os_error_code os_driver_remove_registration(int major, char* driver_name);
-
+os_error_code os_driver_remove_registration(int major, char *driver_name);
 
-/**
+/*!
  * Print a message to console / into log file.  After the @c msg argument a
  * number of printf-style arguments may be added.  Types should be limited to
  * printf string, char, octal, decimal, and hexadecimal types.  (This excludes
@@ -463,10 +440,9 @@ os_error_code os_driver_remove_registration(int major, char* driver_name);
  *
  * @return (void)
  */
-void os_printk(char* msg, ...);
+void os_printk(char *msg, ...);
 
-
-/**
+/*!
  * Allocate some kernel memory
  *
  * @param amount   Number of 8-bit bytes to allocate
@@ -474,10 +450,9 @@ void os_printk(char* msg, ...);
  *
  * @return  Pointer to allocated memory, or NULL if failed.
  */
-void* os_alloc_memory(unsigned amount, int flags);
-
+void *os_alloc_memory(unsigned amount, int flags);
 
-/**
+/*!
  * Free some kernel memory
  *
  * @param location  The beginning of the region to be freed.
@@ -487,10 +462,9 @@ void* os_alloc_memory(unsigned amount, int flags);
  * size of the buffer being freed?  Perhaps separate routines for each
  * alloc/free pair (DMAable, etc.)?
  */
-void os_free_memory(void* location);
+void os_free_memory(void *location);
 
-
-/**
+/*!
  * Allocate cache-coherent memory
  *
  * @param       amount     Number of bytes to allocate
@@ -502,10 +476,9 @@ void os_free_memory(void* location);
  * @return (virtual space) pointer to allocated memory, or NULL if failed.
  *
  */
-void* os_alloc_coherent(unsigned amount, uint32_t* dma_addrp, int flags);
-
+void *os_alloc_coherent(unsigned amount, uint32_t * dma_addrp, int flags);
 
-/**
+/*!
  * Free cache-coherent memory
  *
  * @param       size       Number of bytes which were allocated.
@@ -517,10 +490,9 @@ void* os_alloc_coherent(unsigned amount, uint32_t* dma_addrp, int flags);
  * @return void
  *
  */
-void os_free_coherent(unsigned size, void* virt_addr, uint32_t dma_addr);
+void os_free_coherent(unsigned size, void *virt_addr, uint32_t dma_addr);
 
-
-/**
+/*!
  * Map an I/O space into kernel memory space
  *
  * @param start       The starting address of the (physical / io space) region
@@ -528,11 +500,9 @@ void os_free_coherent(unsigned size, void* virt_addr, uint32_t dma_addr);
  *
  * @return A pointer to the mapped area, or NULL on failure
  */
-void* os_map_device(uint32_t start, unsigned range_bytes);
-
-
+void *os_map_device(uint32_t start, unsigned range_bytes);
 
-/**
+/*!
  * Unmap an I/O space from kernel memory space
  *
  * @param start       The starting address of the (virtual) region
@@ -540,10 +510,9 @@ void* os_map_device(uint32_t start, unsigned range_bytes);
  *
  * @return None
  */
-void os_unmap_device(void* start, unsigned range_bytes);
+void os_unmap_device(void *start, unsigned range_bytes);
 
-
-/**
+/*!
  * Copy data from Kernel space to User space
  *
  * @param to   The target location in user memory
@@ -552,10 +521,9 @@ void os_unmap_device(void* start, unsigned range_bytes);
  *
  * @return #os_error_code
  */
-os_error_code os_copy_to_user(void* to, void* from, unsigned size);
-
+os_error_code os_copy_to_user(void *to, void *from, unsigned size);
 
-/**
+/*!
  * Copy data from User space to Kernel space
  *
  * @param to   The target location in kernel memory
@@ -564,81 +532,73 @@ os_error_code os_copy_to_user(void* to, void* from, unsigned size);
  *
  * @return #os_error_code
  */
-os_error_code os_copy_from_user(void* to, void* from, unsigned size);
+os_error_code os_copy_from_user(void *to, void *from, unsigned size);
 
-
-/**
+/*!
  * Read an 8-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @return                  The value in the register
  */
-uint8_t os_read8(uint8_t* register_address);
-
+uint8_t os_read8(uint8_t * register_address);
 
-/**
+/*!
  * Write an 8-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @param value             The value to write into the register
  */
-void os_write8(uint8_t* register_address, uint8_t value);
+void os_write8(uint8_t * register_address, uint8_t value);
 
-
-/**
+/*!
  * Read a 16-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @return                  The value in the register
  */
-uint16_t os_read16(uint16_t* register_address);
-
+uint16_t os_read16(uint16_t * register_address);
 
-/**
+/*!
  * Write a 16-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @param value             The value to write into the register
  */
-void os_write16(uint16_t* register_address, uint16_t value);
+void os_write16(uint16_t * register_address, uint16_t value);
 
-/**
+/*!
  * Read a 32-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @return                  The value in the register
  */
-uint32_t os_read32(uint32_t* register_address);
-
+uint32_t os_read32(uint32_t * register_address);
 
-/**
+/*!
  * Write a 32-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @param value             The value to write into the register
  */
-void os_write32(uint32_t* register_address, uint32_t value);
+void os_write32(uint32_t * register_address, uint32_t value);
 
-
-/**
+/*!
  * Read a 64-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @return                  The value in the register
  */
-uint64_t os_read64(uint64_t* register_address);
-
+uint64_t os_read64(uint64_t * register_address);
 
-/**
+/*!
  * Write a 64-bit device register
  *
  * @param register_address  The (bus) address of the register to write to
  * @param value             The value to write into the register
  */
-void os_write64(uint64_t* register_address, uint64_t value);
+void os_write64(uint64_t * register_address, uint64_t value);
 
-
-/**
+/*!
  * Prepare a task to execute the given function.  This should only be done once
  * per task, during the driver's initialization routine.
  *
@@ -646,10 +606,9 @@ void os_write64(uint64_t* register_address, uint64_t value);
  *
  * @return an OS ERROR code.
  */
-os_error os_create_task(os_task_fn_t* task_fn);
-
+os_error os_create_task(os_task_fn_t * task_fn);
 
-/**
+/*!
  * Run the task associated with an #OS_DEV_TASK() function
  *
  * The task will begin execution sometime after or during this call.
@@ -658,9 +617,9 @@ os_error os_create_task(os_task_fn_t* task_fn);
  *
  * @return void
  */
-void os_schedule_task(os_task_fn_t* task_fn);
+void os_dev_schedule_task(os_task_fn_t * task_fn);
 
-/**
+/*!
  * Make sure that task is no longer running and will no longer run.
  *
  * This function will not return until both are true.  This is useful when
@@ -669,10 +628,9 @@ void os_schedule_task(os_task_fn_t* task_fn);
  * @param task_fn   Name of the OS_DEV_TASK() funciton to be stopped.
  *
  */
-void os_stop_task(os_task_fn_t* task_fn);
+void os_stop_task(os_task_fn_t * task_fn);
 
-
-/**
+/*!
  * Delay some number of microseconds
  *
  * Note that this is a busy-loop, not a suspension of the task/process.
@@ -683,8 +641,7 @@ void os_stop_task(os_task_fn_t* task_fn);
  */
 void os_mdelay(unsigned long msecs);
 
-
-/**
+/*!
  * Calculate virtual address from physical address
  *
  * @param pa    Physical address
@@ -695,8 +652,7 @@ void os_mdelay(unsigned long msecs);
  */
 void *os_va(uint32_t pa);
 
-
-/**
+/*!
  * Calculate physical address from virtual address
  *
  *
@@ -706,10 +662,9 @@ void *os_va(uint32_t pa);
  *
  * @note this assumes that addresses are 32 bits wide
  */
-uint32_t os_pa(void* va);
+uint32_t os_pa(void *va);
 
-
-/**
+/*!
  * Allocate and initialize a lock, returning a lock handle.
  *
  * The lock state will be initialized to 'unlocked'.
@@ -718,8 +673,7 @@ uint32_t os_pa(void* va);
  */
 os_lock_t os_lock_alloc_init(void);
 
-
-/**
+/*!
  * Acquire a lock.
  *
  * This function should only be called from an interrupt service routine.
@@ -730,8 +684,7 @@ os_lock_t os_lock_alloc_init(void);
  */
 void os_lock(os_lock_t lock_handle);
 
-
-/**
+/*!
  * Unlock a lock.  Lock must have been acquired by #os_lock().
  *
  * @param   lock_handle  A handle to the lock to unlock.
@@ -740,7 +693,7 @@ void os_lock(os_lock_t lock_handle);
  */
 void os_unlock(os_lock_t lock_handle);
 
-/**
+/*!
  * Acquire a lock in non-ISR context
  *
  * This function will spin until the lock is available.
@@ -752,7 +705,7 @@ void os_unlock(os_lock_t lock_handle);
  */
 void os_lock_save_context(os_lock_t lock_handle, os_lock_context_t context);
 
-/**
+/*!
  * Release a lock in non-ISR context
  *
  * @param lock_handle  A handle of the lock to release.
@@ -761,9 +714,9 @@ void os_lock_save_context(os_lock_t lock_handle, os_lock_context_t context);
  * @return void
  */
 void os_unlock_restore_context(os_lock_t lock_handle,
-                               os_lock_context_t context);
+			       os_lock_context_t context);
 
-/**
+/*!
  * Deallocate a lock handle.
  *
  * @param lock_handle   An #os_lock_t that has been allocated.
@@ -772,8 +725,7 @@ void os_unlock_restore_context(os_lock_t lock_handle,
  */
 void os_lock_deallocate(os_lock_t lock_handle);
 
-
-/**
+/*!
  * Determine process handle
  *
  * The process handle of the current user is returned.
@@ -782,8 +734,7 @@ void os_lock_deallocate(os_lock_t lock_handle);
  */
 os_process_handle_t os_get_process_handle();
 
-
-/**
+/*!
  * Send a signal to a process
  *
  * @param  proc   A handle to the target process.
@@ -791,8 +742,7 @@ os_process_handle_t os_get_process_handle();
  */
 void os_send_signal(os_process_handle_t proc, int sig);
 
-
-/**
+/*!
  * Get some random bytes
  *
  * @param buf    The location to store the random data.
@@ -800,9 +750,9 @@ void os_send_signal(os_process_handle_t proc, int sig);
  *
  * @return  void
  */
-void os_get_random_bytes(void* buf, unsigned count);
+void os_get_random_bytes(void *buf, unsigned count);
 
-/**
+/*!
  * Go to sleep on an object.
  *
  * Example: code = os_sleep(my_queue, available_count == 0, 0);
@@ -816,10 +766,9 @@ void os_get_random_bytes(void* buf, unsigned count);
  * @return error code -- OK or sleep interrupted??
  */
 os_error_code os_sleep(os_sleep_object_t object, unsigned condition,
-                       unsigned atomic);
-
+		       unsigned atomic);
 
-/**
+/*!
  * Wake up whatever is sleeping on sleep object
  *
  * @param object  The object on which things might be sleeping
@@ -828,15 +777,13 @@ os_error_code os_sleep(os_sleep_object_t object, unsigned condition,
  */
 void os_wake_sleepers(os_sleep_object_t object);
 
-
-/** @} */ /* dkops */
-
+	  /*! @} *//* dkops */
 
 /*****************************************************************************
  *  Function-signature-generating macros
  *****************************************************************************/
 
-/**
+/*!
  * @defgroup drsigs Driver Function Signatures
  *
  * These macros will define the entry point signatures for interrupt handlers;
@@ -887,10 +834,10 @@ void os_wake_sleepers(os_sleep_object_t object);
  * @endcode
  */
 
-/** @addtogroup drsigs */
-/** @{ */
+/*! @addtogroup drsigs */
+/*! @{ */
 
-/**
+/*!
  * Define a function which will handle device initialization
  *
  * This is tne driver initialization routine.  This is normally where the
@@ -904,8 +851,7 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_INIT(function_name)
 
-
-/**
+/*!
  * Define a function which will handle device shutdown
  *
  * This is the reverse of the #OS_DEV_INIT() routine.
@@ -916,8 +862,7 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_SHUTDOWN(function_name)
 
-
-/**
+/*!
  * Define a function which will open the device for a user.
  *
  * @param function_name The name of the driver open() function
@@ -926,8 +871,7 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_OPEN(function_name)
 
-
-/**
+/*!
  * Define a function which will handle a user's ioctl() request
  *
  * @param function_name The name of the driver ioctl() function
@@ -936,8 +880,7 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_IOCTL(function_name)
 
-
-/**
+/*!
  * Define a function which will handle a user's read() request
  *
  * @param function_name The name of the driver read() function
@@ -946,8 +889,7 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_READ(function_name)
 
-
-/**
+/*!
  * Define a function which will handle a user's write() request
  *
  * @param function_name The name of the driver write() function
@@ -956,8 +898,7 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_WRITE(function_name)
 
-
-/**
+/*!
  * Define a function which will handle a user's mmap() request
  *
  * The mmap() function requests the driver to map some memory into user space.
@@ -970,8 +911,7 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_MMAP(function_name)
 
-
-/**
+/*!
  * Define a function which will close the device - opposite of OS_DEV_OPEN()
  *
  * @param function_name The name of the driver close() function
@@ -980,8 +920,7 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_CLOSE(function_name)
 
-
-/**
+/*!
  * Define a function which will handle an interrupt
  *
  * No arguments are available to the generic function.  It must not invoke any
@@ -1002,8 +941,7 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_ISR(function_name)
 
-
-/**
+/*!
  * Define a function which will operate as a background task / bottom half.
  *
  * The function implementation must be structured in the following manner:
@@ -1027,27 +965,25 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_TASK(function_name)
 
-/** @} */ /* drsigs */
+	  /*! @} *//* drsigs */
 
-
-/** @defgroup dclsigs Routines to declare Driver Signature routines
+/*! @defgroup dclsigs Routines to declare Driver Signature routines
  *
  * These macros drop prototypes suitable for forward-declaration of
  * @ref drsigs "function signatures".
  */
 
-/** @addtogroup dclsigs */
-/** @{ */
+/*! @addtogroup dclsigs */
+/*! @{ */
 
-/**
+/*!
  * Declare prototype for the device initialization function
  *
  * @param function_name   The name of the portable initialization function.
  */
 #define OS_DEV_INIT_DCL(function_name)
 
-
-/**
+/*!
  * Declare prototype for the device shutdown function
  *
  * @param function_name   The name of the portable driver shutdown routine.
@@ -1056,8 +992,7 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_SHUTDOWN_DCL(function_name)
 
-
-/**
+/*!
  * Declare prototype for the open() function.
  *
  * @param function_name The name of the driver open() function
@@ -1066,8 +1001,7 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_OPEN_DCL(function_name)
 
-
-/**
+/*!
  * Declare prototype for the user's ioctl() request function
  *
  * @param function_name The name of the driver ioctl() function
@@ -1076,32 +1010,28 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_IOCTL_DCL(function_name)
 
-
-/**
+/*!
  * Declare prototype for the function a user's read() request
  *
  * @param function_name The name of the driver read() function
  */
 #define OS_DEV_READ_DCL(function_name)
 
-
-/**
+/*!
  * Declare prototype for the user's write() request function
  *
  * @param function_name The name of the driver write() function
  */
 #define OS_DEV_WRITE_DCL(function_name)
 
-
-/**
+/*!
  * Declare prototype for the user's mmap() request function
  *
  * @param function_name The name of the driver mmap() function
  */
 #define OS_DEV_MMAP_DCL(function_name)
 
-
-/**
+/*!
  * Declare prototype for the close function
  *
  * @param function_name The name of the driver close() function
@@ -1110,37 +1040,34 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 #define OS_DEV_CLOSE_DCL(function_name)
 
-
-/**
+/*!
  * Declare prototype for the interrupt handling function
  *
  * @param function_name The name of the driver ISR function
  */
 #define OS_DEV_ISR_DCL(function_name)
 
-
-/**
+/*!
  * Declare prototype for a background task / bottom half function
  *
  * @param function_name The name of this background task function
  */
 #define OS_DEV_TASK_DCL(function_name)
 
-/** @} */ /* dclsigs */
-
+	  /*! @} *//* dclsigs */
 
 /*****************************************************************************
  *  Functions for Returning Values from Driver Signature routines
  *****************************************************************************/
 
-/**
+/*!
  * @defgroup retfns Functions to Return Values from Driver Signature routines
  */
 
-/** @addtogroup retfns */
-/** @{ */
+/*! @addtogroup retfns */
+/*! @{ */
 
-/**
+/*!
  * Return from the #OS_DEV_INIT() function
  *
  * @param code    An error code to report success or failure.
@@ -1148,8 +1075,7 @@ void os_wake_sleepers(os_sleep_object_t object);
  */
 void os_dev_init_return(os_error_code code);
 
-
-/**
+/*!
  * Return from the #OS_DEV_SHUTDOWN() function
  *
  * @param code    An error code to report success or failure.
@@ -1157,8 +1083,7 @@ void os_dev_init_return(os_error_code code);
  */
 void os_dev_shutdown_return(os_error_code code);
 
-
-/**
+/*!
  * Return from the #OS_DEV_ISR() function
  *
  * The function should verify that it really was supposed to be called,
@@ -1170,8 +1095,7 @@ void os_dev_shutdown_return(os_error_code code);
  */
 void os_dev_isr_return(int code);
 
-
-/**
+/*!
  * Return from the #OS_DEV_OPEN() function
  *
  * @param code    An error code to report success or failure.
@@ -1179,8 +1103,7 @@ void os_dev_isr_return(int code);
  */
 void os_dev_open_return(os_error_code code);
 
-
-/**
+/*!
  * Return from the #OS_DEV_IOCTL() function
  *
  * @param code    An error code to report success or failure.
@@ -1188,8 +1111,7 @@ void os_dev_open_return(os_error_code code);
  */
 void os_dev_ioctl_return(os_error_code code);
 
-
-/**
+/*!
  * Return from the #OS_DEV_READ() function
  *
  * @param code    Number of bytes read, or an error code to report failure.
@@ -1197,8 +1119,7 @@ void os_dev_ioctl_return(os_error_code code);
  */
 void os_dev_read_return(os_error_code code);
 
-
-/**
+/*!
  * Return from the #OS_DEV_WRITE() function
  *
  * @param code    Number of bytes written, or an error code to report failure.
@@ -1206,8 +1127,7 @@ void os_dev_read_return(os_error_code code);
  */
 void os_dev_write_return(os_error_code code);
 
-
-/**
+/*!
  * Return from the #OS_DEV_MMAP() function
  *
  * @param code    Number of bytes written, or an error code to report failure.
@@ -1215,8 +1135,7 @@ void os_dev_write_return(os_error_code code);
  */
 void os_dev_mmap_return(os_error_code code);
 
-
-/**
+/*!
  * Return from the #OS_DEV_CLOSE() function
  *
  * @param code    An error code to report success or failure.
@@ -1224,7 +1143,7 @@ void os_dev_mmap_return(os_error_code code);
  */
 void os_dev_close_return(os_error_code code);
 
-/**
+/*!
  * Start the #OS_DEV_TASK() function
  *
  * In some implementations, this could be turned into a label for
@@ -1237,8 +1156,7 @@ void os_dev_close_return(os_error_code code);
  */
 void os_dev_task_begin(void);
 
-
-/**
+/*!
  * Return from the #OS_DEV_TASK() function
  *
  * In some implementations, this could be turned into a sleep followed
@@ -1249,37 +1167,33 @@ void os_dev_task_begin(void);
  */
 void os_dev_task_return(os_error_code code);
 
-
-/** @} */ /* retfns */
-
+	  /*! @} *//* retfns */
 
 /*****************************************************************************
  *  Functions/Macros for accessing arguments from Driver Signature routines
  *****************************************************************************/
 
-/** @defgroup drsigargs Functions for Getting Arguments in Signature functions
+/*! @defgroup drsigargs Functions for Getting Arguments in Signature functions
  *
  */
 /* @addtogroup @drsigargs */
-/** @{ */
+/*! @{ */
 
-/**
+/*!
  * Check whether user is requesting read (permission) on the file/device.
  * Usable in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ()
  * and #OS_DEV_WRITE() routines.
  */
 int os_dev_is_flag_read(void);
 
-
-/**
+/*!
  * Check whether user is requesting write (permission) on the file/device.
  * Usable in #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ()
  * and #OS_DEV_WRITE() routines.
  */
 int os_dev_is_flag_write(void);
 
-
-/**
+/*!
  * Check whether user is requesting non-blocking I/O.  Usable in
  * #OS_DEV_OPEN(), #OS_DEV_CLOSE(), #OS_DEV_IOCTL(), #OS_DEV_READ() and
  * #OS_DEV_WRITE() routines.
@@ -1290,22 +1204,19 @@ int os_dev_is_flag_write(void);
  */
 int os_dev_is_flag_nonblock(void);
 
-
-/**
+/*!
  * Determine which major device is being accessed.  Usable in #OS_DEV_OPEN()
  * and #OS_DEV_CLOSE().
  */
 int os_dev_get_major(void);
 
-
-/**
+/*!
  * Determine which minor device is being accessed.  Usable in #OS_DEV_OPEN()
  * and #OS_DEV_CLOSE().
  */
 int os_dev_get_minor(void);
 
-
-/**
+/*!
  * Determine which operation the user wants performed.  Usable in
  * #OS_DEV_IOCTL().
  *
@@ -1315,8 +1226,7 @@ int os_dev_get_minor(void);
  */
 unsigned os_dev_get_ioctl_op(void);
 
-
-/**
+/*!
  * Retrieve the associated argument for the desired operation.  Usable in
  * #OS_DEV_IOCTL().
  *
@@ -1325,8 +1235,7 @@ unsigned os_dev_get_ioctl_op(void);
  */
 os_dev_ioctl_arg_t os_dev_get_ioctl_arg(void);
 
-
-/**
+/*!
  * Determine the requested byte count. This should be the size of buffer at
  * #os_dev_get_user_buffer(). Usable in OS_DEV_READ() and OS_DEV_WRITE()
  * routines.
@@ -1335,18 +1244,16 @@ os_dev_ioctl_arg_t os_dev_get_ioctl_arg(void);
  */
 unsigned os_dev_get_count(void);
 
-
-/**
+/*!
  * Get the pointer to the user's data buffer. Usable in OS_DEV_READ(),
  * OS_DEV_WRITE(), and OS_DEV_MMAP() routines.
  *
  * @return   Pointer to user buffer (in user space).  See #os_copy_to_user()
  *           and #os_copy_from_user().
  */
-void* os_dev_get_user_buffer(void);
-
+void *os_dev_get_user_buffer(void);
 
-/**
+/*!
  * Get the POSIX flags field for the associated open file.  Usable in
  * OS_DEV_READ(), OS_DEV_WRITE(), and OS_DEV_IOCTL() routines.
  *
@@ -1354,7 +1261,7 @@ void* os_dev_get_user_buffer(void);
  */
 unsigned os_dev_get_file_flags(void);
 
-/**
+/*!
  * Set the driver's private structure associated with this file/open.
  *
  * Generally used during #OS_DEV_OPEN().  May also be used during
@@ -1363,10 +1270,9 @@ unsigned os_dev_get_file_flags(void);
  *
  * @param  struct_p   The driver data structure to associate with this user.
  */
-void os_dev_set_user_private(void* struct_p);
+void os_dev_set_user_private(void *struct_p);
 
-
-/**
+/*!
  * Get the driver's private structure associated with this file.
  *
  * May be used during #OS_DEV_OPEN(), #OS_DEV_READ(), #OS_DEV_WRITE(),
@@ -1375,24 +1281,22 @@ void os_dev_set_user_private(void* struct_p);
  *
  * @return   The driver data structure to associate with this user.
  */
-void* os_dev_get_user_private(void);
-
+void *os_dev_get_user_private(void);
 
-/**
+/*!
  * Get the IRQ associated with this call to the #OS_DEV_ISR() function.
  *
  * @return  The IRQ (integer) interrupt number.
  */
 int os_dev_get_irq(void);
 
-/** @} */ /* drsigargs */
-
+	  /*! @} *//* drsigargs */
 
 /*****************************************************************************
  *  Functions for Generating References to Driver Routines
  *****************************************************************************/
 
-/**
+/*!
  * @defgroup drref Functions for Generating References to Driver Routines
  *
  * These functions will most likely be implemented as macros.  They are a
@@ -1405,10 +1309,10 @@ int os_dev_get_irq(void);
  * passing a pointer to the function.
  */
 
-/** @addtogroup drref */
-/** @{ */
+/*! @addtogroup drref */
+/*! @{ */
 
-/**
+/*!
  * Generate a reference to an #OS_DEV_INIT() function
  *
  * @param function_name   The name of the init function being referenced.
@@ -1417,8 +1321,7 @@ int os_dev_get_irq(void);
  */
 os_init_function_t OS_DEV_INIT_REF(symbol function_name);
 
-
-/**
+/*!
  * Generate a reference to an #OS_DEV_SHUTDOWN() function
  *
  * @param function_name   The name of the shutdown function being referenced.
@@ -1427,8 +1330,7 @@ os_init_function_t OS_DEV_INIT_REF(symbol function_name);
  */
 os_shutdown_function_t OS_DEV_SHUTDOWN_REF(symbol function_name);
 
-
-/**
+/*!
  * Generate a reference to an #OS_DEV_OPEN() function
  *
  * @param function_name   The name of the open function being referenced.
@@ -1437,8 +1339,7 @@ os_shutdown_function_t OS_DEV_SHUTDOWN_REF(symbol function_name);
  */
 os_user_function_t OS_DEV_OPEN_REF(symbol function_name);
 
-
-/**
+/*!
  * Generate a reference to an #OS_DEV_CLOSE() function
  *
  * @param function_name   The name of the close function being referenced.
@@ -1447,8 +1348,7 @@ os_user_function_t OS_DEV_OPEN_REF(symbol function_name);
  */
 os_user_function_t OS_DEV_CLOSE_REF(symbol function_name);
 
-
-/**
+/*!
  * Generate a reference to an #OS_DEV_READ() function
  *
  * @param function_name   The name of the read function being referenced.
@@ -1457,8 +1357,7 @@ os_user_function_t OS_DEV_CLOSE_REF(symbol function_name);
  */
 os_user_function_t OS_DEV_READ_REF(symbol function_name);
 
-
-/**
+/*!
  * Generate a reference to an #OS_DEV_WRITE() function
  *
  * @param function_name   The name of the write function being referenced.
@@ -1467,8 +1366,7 @@ os_user_function_t OS_DEV_READ_REF(symbol function_name);
  */
 os_user_function_t OS_DEV_WRITE_REF(symbol function_name);
 
-
-/**
+/*!
  * Generate a reference to an #OS_DEV_IOCTL() function
  *
  * @param function_name   The name of the ioctl function being referenced.
@@ -1477,8 +1375,7 @@ os_user_function_t OS_DEV_WRITE_REF(symbol function_name);
  */
 os_user_function_t OS_DEV_IOCTL_REF(symbol function_name);
 
-
-/**
+/*!
  * Generate a reference to an #OS_DEV_MMAP() function
  *
  * @param function_name   The name of the mmap function being referenced.
@@ -1487,8 +1384,7 @@ os_user_function_t OS_DEV_IOCTL_REF(symbol function_name);
  */
 os_user_function_t OS_DEV_MMAP_REF(symbol function_name);
 
-
-/**
+/*!
  * Generate a reference to an #OS_DEV_ISR() function
  *
  * @param function_name   The name of the isr being referenced.
@@ -1497,43 +1393,61 @@ os_user_function_t OS_DEV_MMAP_REF(symbol function_name);
  */
 os_interrupt_handler_t OS_DEV_ISR_REF(symbol function_name);
 
+	  /*! @} *//* drref */
 
-/** @} */ /* drref */
-
-
-/**
+/*!
  * Flush and invalidate all cache lines.
  */
 void os_flush_cache_all(void);
 
-
-/**
+/*!
  * Flush a range of addresses from the cache
  *
  * @param  start    Starting virtual address
  * @param  len      Number of bytes to flush
  */
-void os_cache_flush_range(void* start, uint32_t len);
+void os_cache_flush_range(void *start, uint32_t len);
 
-
-/**
+/*!
  * Invalidate a range of addresses in the cache
  *
  * @param  start    Starting virtual address
  * @param  len      Number of bytes to flush
  */
-void os_cache_inv_range(void* start, uint32_t len);
-
+void os_cache_inv_range(void *start, uint32_t len);
 
-/**
+/*!
  * Clean a range of addresses from the cache
  *
  * @param  start    Starting virtual address
  * @param  len      Number of bytes to flush
  */
-void os_cache_clean_range(void* start, uint32_t len);
+void os_cache_clean_range(void *start, uint32_t len);
+
+/*!
+  * @example widget.h
+  */
+
+/*!
+  * @example widget.c
+  */
+
+/*!
+  * @example rng_driver.h
+  */
+
+/*!
+  * @example rng_driver.c
+  */
+
+/*!
+  * @example shw_driver.h
+  */
 
-#endif /* DOXYGEN_PORTABLE_OS_DOC */
+/*!
+  * @example shw_driver.c
+  */
 
+#endif				/* DOXYGEN_PORTABLE_OS_DOC */
 
 #endif				/* PORTABLE_OS_H */
diff --git a/drivers/mxc/security/sahara2/include/sah_kernel.h b/drivers/mxc/security/sahara2/include/sah_kernel.h
index d9abd2e..5397232 100644
--- a/drivers/mxc/security/sahara2/include/sah_kernel.h
+++ b/drivers/mxc/security/sahara2/include/sah_kernel.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -80,6 +80,7 @@
 
 #define SAHARA_SCC_SSTATUS  _IOWR(SAH_IOC_MAGIC, 25, scc_partition_info_t)
 
+#define SAHARA_SK_READ      _IOWR(SAH_IOC_MAGIC, 29, scc_slot_t)
 
 /*! This is the name that will appear in /proc/interrupts */
 #define SAHARA_NAME         "SAHARA"
diff --git a/drivers/mxc/security/sahara2/include/sahara.h b/drivers/mxc/security/sahara2/include/sahara.h
index 9e07c3d..da23527 100644
--- a/drivers/mxc/security/sahara2/include/sahara.h
+++ b/drivers/mxc/security/sahara2/include/sahara.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -23,17 +23,13 @@
  *
  */
 
+#define _DIAG_DRV_IF
+#define _DIAG_SECURITY_FUNC
+#define _DIAG_ADAPTOR
+
 #ifndef SAHARA2_API_H
 #define SAHARA2_API_H
 
-/* Sahara Debug Flags */
-#if 0
-#define DIAG_DRV_IF
-#define DIAG_SECURITY_FUNC
-#define DIAG_ADAPTOR
-#define DO_DBG
-#endif
-
 #ifdef DIAG_SECURITY_FUNC
 #include <diagnostic.h>
 #endif				/* DIAG_SECURITY_FUNC */
@@ -124,9 +120,9 @@
 * it can be removed during DePhysicalise, thereby returning to the caller an
 * intact chain.
 ******************************************************************************/
-#define SAH_LINK_INSERTED_LINK 0x80
+#define SAH_LINK_INSERTED_LINK      0x80
 
-/*! 
+/*!
 *******************************************************************************
 * The Data field points to the location of the key, which is in a secure
 * partition held by the user.  The memory address needs to be converted to
@@ -287,7 +283,6 @@ typedef enum fsl_shw_return_t {
 	FSL_RETURN_OSCILLATOR_ERROR_S,
 	/*! RNG hardware problem. */
 	FSL_RETURN_STATISTICS_ERROR_S,
-	
 } fsl_shw_return_t;
 
 /*!
@@ -325,6 +320,10 @@ typedef enum fsl_shw_key_alg_t {
 	 * limitation.)
 	 */
 	FSL_KEY_ALG_ARC4,
+	/*!
+	 * Private key of a public-private key-pair.  Max is 512 bits...
+	 */
+	FSL_KEY_PK_PRIVATE,
 } fsl_shw_key_alg_t;
 
 /*!
@@ -517,6 +516,11 @@ typedef enum fsl_shw_key_flags_t {
 	 * platforms, nor for all algorithms and modes.
 	 */
 	FSL_SKO_KEY_ESTABLISHED = 4,
+	/*!
+	 * Key intended for user (software) use; can be read cleartext from the
+	 * keystore.
+	 */
+	FSL_SKO_KEY_SW_KEY = 8,
 } fsl_shw_key_flags_t;
 
 /*!
@@ -619,6 +623,28 @@ typedef enum fsl_shw_cypher_mode_t {
 	FSL_SHW_CYPHER_MODE_CBC = 2,	/*!< CBC mode */
 } fsl_shw_cypher_mode_t;
 
+typedef enum fsl_shw_pf_key_t {
+	FSL_SHW_PF_KEY_IIM,	/*!< Present fused IIM key */
+	FSL_SHW_PF_KEY_PRG,	/*!< Present Program key */
+	FSL_SHW_PF_KEY_IIM_PRG,	/*!< Present IIM ^ Program key */
+	FSL_SHW_PF_KEY_IIM_RND,	/*!< Present Random key */
+	FSL_SHW_PF_KEY_RND,	/*!< Present IIM ^ Random key */
+} fsl_shw_pf_key_t;
+
+typedef enum fsl_shw_tamper_t {
+	FSL_SHW_TAMPER_NONE,	/*!< No error detected */
+	FSL_SHW_TAMPER_WTD,	/*!< wire-mesh tampering det */
+	FSL_SHW_TAMPER_ETBD,	/*!< ext tampering det: input B */
+	FSL_SHW_TAMPER_ETAD,	/*!< ext tampering det: input A */
+	FSL_SHW_TAMPER_EBD,	/*!< external boot detected */
+	FSL_SHW_TAMPER_SAD,	/*!< security alarm detected */
+	FSL_SHW_TAMPER_TTD,	/*!< temperature tampering det */
+	FSL_SHW_TAMPER_CTD,	/*!< clock tampering det */
+	FSL_SHW_TAMPER_VTD,	/*!< voltage tampering det */
+	FSL_SHW_TAMPER_MCO,	/*!< monotonic counter overflow */
+	FSL_SHW_TAMPER_TCO,	/*!< time counter overflow */
+} fsl_shw_tamper_t;
+
 /******************************************************************************
  * Data Structures
  *****************************************************************************/
@@ -913,6 +939,7 @@ typedef struct fsl_shw_pco_t {	/* Consider turning these constants into symbols
 	fsl_shw_sym_mode_t sym_modes[4];
 	fsl_shw_hash_alg_t hash_algorithms[4];
 	uint8_t sym_support[5][4];	/* indexed by key alg then mode */
+
 	int scc_driver_major;
 	int scc_driver_minor;
 	int scm_version;	/*!< Version from SCM Configuration register */
@@ -1129,105 +1156,125 @@ typedef enum fsl_shw_partition_status_t {
  *
  * @return 0 if wrapping is not supported, non-zero if supported.
  */
-#define fsl_shw_pco_check_black_key_supported(pcobject)                       \
+#define fsl_shw_pco_check_black_key_supported(pcobject)                     \
     1
 
 /*!
+ * Determine whether Programmed Key features are available
+ *
+ * @param pc_info          The Platform Capabilities Object to query.
+ *
+ * @return  1 if Programmed Key features are available, otherwise zero.
+ */
+#define fsl_shw_pco_check_pk_supported(pcobject)        \
+    0
+
+/*!
+ * Determine whether Software Key features are available
+ *
+ * @param pc_info          The Platform Capabilities Object to query.
+ *
+ * @return  1 if Software key features are available, otherwise zero.
+ */
+#define fsl_shw_pco_check_sw_keys_supported(pcobject)        \
+    0
+
+/*!
  * Get FSL SHW SCC driver version
-  *
-  * @param		pcobject  The Platform Capabilities Object to query.
-  * @param[out] pcmajor   A pointer to where the major version
-  * 					  of the SCC driver is to be stored.
-  * @param[out] pcminor   A pointer to where the minor version
-  * 					  of the SCC driver is to be stored.
-  */
+ *
+ * @param      pcobject  The Platform Capabilities Object to query.
+ * @param[out] pcmajor   A pointer to where the major version
+ *                       of the SCC driver is to be stored.
+ * @param[out] pcminor   A pointer to where the minor version
+ *                       of the SCC driver is to be stored.
+ */
 #define fsl_shw_pco_get_scc_driver_version(pcobject, pcmajor, pcminor)        \
- {																			   \
-	 *(pcmajor) = (pcobject)->scc_driver_major; 							   \
-	 *(pcminor) = (pcobject)->scc_driver_minor; 							   \
- }
- 
- /*!
-  * Get SCM hardware version
-  *
-  * @param		pcobject  The Platform Capabilities Object to query.
-  * @return 			  The SCM hardware version
-  */
+{                                                                             \
+    *(pcmajor) = (pcobject)->scc_driver_major;                                \
+    *(pcminor) = (pcobject)->scc_driver_minor;                                \
+}
+
+/*!
+ * Get SCM hardware version
+ *
+ * @param      pcobject  The Platform Capabilities Object to query.
+ * @return               The SCM hardware version
+ */
 #define fsl_shw_pco_get_scm_version(pcobject)                                 \
-	 ((pcobject)->scm_version)
- 
- /*!
-  * Get SMN hardware version
-  *
-  * @param		pcobject  The Platform Capabilities Object to query.
-  * @return 			  The SMN hardware version
-  */
+    ((pcobject)->scm_version)
+
+/*!
+ * Get SMN hardware version
+ *
+ * @param      pcobject  The Platform Capabilities Object to query.
+ * @return               The SMN hardware version
+ */
 #define fsl_shw_pco_get_smn_version(pcobject)                                 \
-	 ((pcobject)->smn_version)
- 
- /*!
-  * Get the size of an SCM block, in bytes
-  *
-  * @param		pcobject  The Platform Capabilities Object to query.
-  * @return 			  The size of an SCM block, in bytes.
-  */
+    ((pcobject)->smn_version)
+
+/*!
+ * Get the size of an SCM block, in bytes
+ *
+ * @param      pcobject  The Platform Capabilities Object to query.
+ * @return               The size of an SCM block, in bytes.
+ */
 #define fsl_shw_pco_get_scm_block_size(pcobject)                              \
-	 ((pcobject)->block_size_bytes)
- 
- /*!
-  * Get size of Black and Red RAM memory
-  *
-  * @param		pcobject	The Platform Capabilities Object to query.
-  * @param[out] black_size	A pointer to where the size of the Black RAM, in
-  * 						blocks, is to be placed.
-  * @param[out] red_size	A pointer to where the size of the Red RAM, in 
-  * 						blocks, is to be placed.
-  */
+    ((pcobject)->block_size_bytes)
+
+/*!
+ * Get size of Black and Red RAM memory
+ *
+ * @param      pcobject    The Platform Capabilities Object to query.
+ * @param[out] black_size  A pointer to where the size of the Black RAM, in
+ *                         blocks, is to be placed.
+ * @param[out] red_size    A pointer to where the size of the Red RAM, in 
+ *                         blocks, is to be placed.
+ */
 #define fsl_shw_pco_get_smn_size(pcobject, black_size, red_size)              \
- {																			   \
-	 if ((pcobject)->scm_version == 1) {									   \
-		 *(black_size) = (pcobject)->scc_info.black_ram_size_blocks;		   \
-		 *(red_size)   = (pcobject)->scc_info.red_ram_size_blocks;			   \
-	 } else {																   \
-		 *(black_size) = 0; 												   \
-		 *(red_size)   = 0; 												   \
-	 }																		   \
- }
- 
- /*!
-  * Determine whether Secure Partitions are supported
-  *
-  * @param pcobject   The Platform Capabilities Object to query.
-  *
-  * @return 0 if secure partitions are not supported, non-zero if supported.
-  */
+{                                                                             \
+    if ((pcobject)->scm_version == 1) {                                       \
+        *(black_size) = (pcobject)->scc_info.black_ram_size_blocks;           \
+        *(red_size)   = (pcobject)->scc_info.red_ram_size_blocks;             \
+    } else {                                                                  \
+        *(black_size) = 0;                                                    \
+        *(red_size)   = 0;                                                    \
+    }                                                                         \
+}
+
+/*!
+ * Determine whether Secure Partitions are supported
+ *
+ * @param pcobject   The Platform Capabilities Object to query.
+ *
+ * @return 0 if secure partitions are not supported, non-zero if supported.
+ */
 #define fsl_shw_pco_check_spo_supported(pcobject)                           \
-	 ((pcobject)->scm_version == 2)
- 
- /*!
-  * Get the size of a Secure Partitions
-  *
-  * @param pcobject   The Platform Capabilities Object to query.
-  * 
-  * @return Partition size, in bytes.  0 if Secure Partitions not supported.
-  */
+    ((pcobject)->scm_version == 2)
+
+/*!
+ * Get the size of a Secure Partitions
+ *
+ * @param pcobject   The Platform Capabilities Object to query.
+ * 
+ * @return Partition size, in bytes.  0 if Secure Partitions not supported.
+ */
 #define fsl_shw_pco_get_spo_size_bytes(pcobject)                            \
-	 (((pcobject)->scm_version == 2) ?										 \
-		 ((pcobject)->scc2_info.partition_size_bytes) : 0 )
- 
- /*!
-  * Get the number of Secure Partitions on this platform
-  *
-  * @param pcobject   The Platform Capabilities Object to query.
-  * 
-  * @return Number of partitions. 0 if Secure Paritions not supported.	Note
-  * 		that this returns the total number of partitions, not all may be
-  * 		available to the user.
-  */
+    (((pcobject)->scm_version == 2) ?                                       \
+        ((pcobject)->scc2_info.partition_size_bytes) : 0 )
+
+/*!
+ * Get the number of Secure Partitions on this platform
+ *
+ * @param pcobject   The Platform Capabilities Object to query.
+ * 
+ * @return Number of partitions. 0 if Secure Paritions not supported.  Note
+ *         that this returns the total number of partitions, not all may be
+ *         available to the user.
+ */
 #define fsl_shw_pco_get_spo_count(pcobject)                                 \
-	 (((pcobject)->scm_version == 2) ?										 \
-		 ((pcobject)->scc2_info.partition_count) : 0 )
- 
+    (((pcobject)->scm_version == 2) ?                                       \
+        ((pcobject)->scc2_info.partition_count) : 0 )
+
 /*!
  * Initialize a User Context Object.
  *
@@ -1258,7 +1305,7 @@ typedef enum fsl_shw_partition_status_t {
       (ucontext)->partition = NULL;                                           \
       (ucontext)->callback = NULL;                                            \
 }
-#else 
+#else
 #define fsl_shw_uco_init(ucontext, usize)                                     \
 {                                                                             \
       (ucontext)->pool_size = usize;                                          \
@@ -1348,6 +1395,24 @@ typedef enum fsl_shw_partition_status_t {
 }
 
 /*!
+ * Initialize a Secret Key Object to use a Platform Key register.
+ *
+ * This function must be called before performing any other operation with
+ * the Object.  INVALID on this platform.
+ *
+ * @param skobject     The Secret Key Object to be initialized.
+ * @param skalgorithm  DES, AES, etc.
+ * @param skhwkey      one of the fsl_shw_pf_key_t values.
+ *
+ */
+#define fsl_shw_sko_init_pf_key(skobject,skalgorithm,skhwkey)       \
+{                                                                   \
+    (skobject)->algorithm = -1;                                         \
+    (skobject)->flags = -1;                                             \
+    (skobject)->keystore = NULL;                                        \
+}
+
+/*!
  * Store a cleartext key in the key object.
  *
  * This has the side effect of setting the #FSL_SKO_KEY_PRESENT flag and
@@ -1473,13 +1538,14 @@ typedef enum fsl_shw_partition_status_t {
  * @param      wkeylen          Location to store the length of a wrapped
  *                              version of the key in @a key_info.
  */
-#define fsl_shw_sko_calculate_wrapped_size(wkeyinfo, wkeylen)                 \
-{                                                                             \
-     if ((wkeyinfo)->key_length > 32) {                                       \
-         *(wkeylen) = 0;                                                      \
-     } else {                                                                 \
-         *(wkeylen) = 66;                                                     \
-     }                                                                        \
+#define fsl_shw_sko_calculate_wrapped_size(wkeyinfo, wkeylen)           \
+{                                                                       \
+    register fsl_shw_sko_t* kp = wkeyinfo;                              \
+    register uint32_t kl = kp->key_length;                              \
+    int key_blocks = (kl + 15) / 16;                                    \
+    int base_size = 35; /* ICV + T' + ALG + LEN + FLAGS */              \
+                                                                        \
+    *(wkeylen) = base_size + 16 * key_blocks;                           \
 }
 
 /*!
@@ -2032,6 +2098,12 @@ extern fsl_shw_return_t do_system_keystore_slot_load(fsl_shw_uco_t * user_ctx,
 						     const uint8_t * key,
 						     uint32_t key_length);
 
+extern fsl_shw_return_t do_system_keystore_slot_read(fsl_shw_uco_t * user_ctx,
+						     uint64_t ownerid,
+						     uint32_t slot,
+						     uint32_t key_length,
+						     const uint8_t * key);
+
 extern fsl_shw_return_t do_system_keystore_slot_encrypt(fsl_shw_uco_t *
 							user_ctx,
 							uint64_t ownerid,
@@ -2131,6 +2203,30 @@ extern fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
 					     const uint8_t * auth_value,
 					     uint8_t * payload);
 
+extern fsl_shw_return_t fsl_shw_read_key(fsl_shw_uco_t * user_ctx,
+						fsl_shw_sko_t * key_info,
+						uint8_t * key);
+
+static inline fsl_shw_return_t fsl_shw_gen_random_pf_key(fsl_shw_uco_t *
+							 user_ctx)
+{
+	(void)user_ctx;
+
+	return FSL_RETURN_NO_RESOURCE_S;
+}
+
+static inline fsl_shw_return_t fsl_shw_read_tamper_event(fsl_shw_uco_t *
+							 user_ctx,
+							 fsl_shw_tamper_t *
+							 tamperp,
+							 uint64_t * timestampp)
+{
+	(void)user_ctx;
+	(void)tamperp;
+	(void)timestampp;
+
+	return FSL_RETURN_NO_RESOURCE_S;
+}
 
 fsl_shw_return_t sah_Append_Desc(const sah_Mem_Util * mu,
 				 sah_Head_Desc ** desc_head,
@@ -2167,3 +2263,4 @@ void sah_Postprocess_Results(fsl_shw_uco_t * user_ctx,
 			     sah_results * result_info);
 
 #endif				/* SAHARA2_API_H */
+
diff --git a/drivers/mxc/security/sahara2/include/sf_util.h b/drivers/mxc/security/sahara2/include/sf_util.h
index 6836776..c0af0c9 100644
--- a/drivers/mxc/security/sahara2/include/sf_util.h
+++ b/drivers/mxc/security/sahara2/include/sf_util.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -384,6 +384,8 @@ extern const uint32_t sah_insert_skha_modulus[];
 #define sah_insert_pkha_rtn_f2m_mult1_mont     0x80000026
 #define sah_insert_pkha_rtn_f2m_mult2_deconv   0x00000027
 #define sah_insert_pkha_rtn_miller_rabin       0x00000028
+#define sah_insert_pkha_rtn_mod_amodn          0x00000029
+#define sah_insert_pkha_rtn_f2m_amodn          0x8000002A
 /*! @} */
 
 /*! Add a descriptor with two input pointers */
diff --git a/drivers/mxc/security/sahara2/km_adaptor.c b/drivers/mxc/security/sahara2/km_adaptor.c
index 6943c48..0ec50ab 100644
--- a/drivers/mxc/security/sahara2/km_adaptor.c
+++ b/drivers/mxc/security/sahara2/km_adaptor.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -43,6 +43,7 @@ EXPORT_SYMBOL(do_scc_decrypt_region);
 EXPORT_SYMBOL(do_system_keystore_slot_alloc);
 EXPORT_SYMBOL(do_system_keystore_slot_dealloc);
 EXPORT_SYMBOL(do_system_keystore_slot_load);
+EXPORT_SYMBOL(do_system_keystore_slot_read);
 EXPORT_SYMBOL(do_system_keystore_slot_encrypt);
 EXPORT_SYMBOL(do_system_keystore_slot_decrypt);
 
@@ -63,8 +64,8 @@ DECLARE_WAIT_QUEUE_HEAD(Wait_queue_km);
 
 /*! This matches Sahara2 capabilities... */
 fsl_shw_pco_t sahara2_capabilities = {
-	1, 2,			/* api version number - major & minor */
-	1, 4,			/* driver version number - major & minor */
+	1, 3,			/* api version number - major & minor */
+	1, 6,			/* driver version number - major & minor */
 	{
 	 FSL_KEY_ALG_AES,
 	 FSL_KEY_ALG_DES,
@@ -455,10 +456,21 @@ fsl_shw_return_t do_system_keystore_slot_load(fsl_shw_uco_t * user_ctx,
 					      uint32_t key_length)
 {
 	(void)user_ctx;
-	return keystore_load_slot(&system_keystore, ownerid, slot,
+	return keystore_slot_load(&system_keystore, ownerid, slot,
 				  (void *)key, key_length);
 }
 
+fsl_shw_return_t do_system_keystore_slot_read(fsl_shw_uco_t * user_ctx,
+					      uint64_t ownerid,
+					      uint32_t slot,
+					      uint32_t key_length,
+					      const uint8_t * key)
+{
+	(void)user_ctx;
+	return keystore_slot_read(&system_keystore, ownerid, slot,
+				  key_length, (void *)key);
+}
+
 fsl_shw_return_t do_system_keystore_slot_encrypt(fsl_shw_uco_t * user_ctx,
 						 uint64_t ownerid,
 						 uint32_t slot,
@@ -587,7 +599,7 @@ do_scc_encrypt_region(fsl_shw_uco_t * user_ctx,
 #ifdef FSL_HAVE_SCC2
 
 #ifdef DIAG_ADAPTOR
-	//uint32_t *owner_32 = (uint32_t *) & (owner_id);
+	uint32_t *owner_32 = (uint32_t *) & (owner_id);
 
 	LOG_KDIAG_ARGS
 	    ("partition base: %p, offset: %i, count: %i, black data: %p\n",
@@ -649,7 +661,7 @@ do_scc_decrypt_region(fsl_shw_uco_t * user_ctx,
 #ifdef FSL_HAVE_SCC2
 
 #ifdef DIAG_ADAPTOR
-	//uint32_t *owner_32 = (uint32_t *) & (owner_id);
+	uint32_t *owner_32 = (uint32_t *) & (owner_id);
 
 	LOG_KDIAG_ARGS
 	    ("partition base: %p, offset: %i, count: %i, black data: %p\n",
diff --git a/drivers/mxc/security/sahara2/sah_driver_interface.c b/drivers/mxc/security/sahara2/sah_driver_interface.c
index 104d698..16db154 100644
--- a/drivers/mxc/security/sahara2/sah_driver_interface.c
+++ b/drivers/mxc/security/sahara2/sah_driver_interface.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -87,16 +87,17 @@ static os_error_code sah_handle_scc_decrypt(fsl_shw_uco_t* user_ctx,
                                             uint32_t info);
 
 #ifdef FSL_HAVE_SCC2
-static fsl_shw_return_t register_user_partition(fsl_shw_uco_t* user_ctx,
-                                                uint32_t user_base,
-                                                void* kernel_base);
-static fsl_shw_return_t deregister_user_partition(fsl_shw_uco_t* user_ctx,
-                                                  uint32_t user_base);
+static fsl_shw_return_t register_user_partition(fsl_shw_uco_t * user_ctx,
+						uint32_t user_base,
+						void *kernel_base);
+static fsl_shw_return_t deregister_user_partition(fsl_shw_uco_t * user_ctx,
+						  uint32_t user_base);
 #endif
 
 static os_error_code sah_handle_sk_slot_alloc(uint32_t info);
 static os_error_code sah_handle_sk_slot_dealloc(uint32_t info);
 static os_error_code sah_handle_sk_slot_load(uint32_t info);
+static os_error_code sah_handle_sk_slot_read(uint32_t info);
 static os_error_code sah_handle_sk_slot_decrypt(uint32_t info);
 static os_error_code sah_handle_sk_slot_encrypt(uint32_t info);
 
@@ -174,7 +175,6 @@ OS_DEV_INIT(sah_init)
 	interrupt_registered = 0;
 
 	/* Enable the SAHARA Clocks */
-	printk("Sahara base address: 0x%08x\n", IO_ADDRESS(SAHA_BASE_ADDR));
 #ifdef DIAG_DRV_IF
 	LOG_KDIAG("SAHARA : Enabling the IPG and AHB clocks\n")
 #endif				/*DIAG_DRV_IF */
@@ -257,8 +257,7 @@ OS_DEV_INIT(sah_init)
 		/* Create the PROCFS entry. This is used to report the assigned device
 		 * major number back to user-space. */
 #if 1
-		Sahara_procfs_handle = create_proc_entry(
-		SAHARA_DEVICE_SHORT, 0700,	/* default mode */
+		Sahara_procfs_handle = create_proc_entry(SAHARA_DEVICE_SHORT, 0700,	/* default mode */
 							 NULL);	/* parent dir */
 		if (Sahara_procfs_handle == NULL) {
 #ifdef DIAG_DRV_IF
@@ -315,7 +314,8 @@ OS_DEV_INIT(sah_init)
 		os_driver_add_registration(reg_handle, OS_FN_CLOSE,
 					   OS_DEV_CLOSE_REF(sah_release));
 		os_driver_add_registration(reg_handle, OS_FN_MMAP,
-                                   OS_DEV_MMAP_REF(sah_mmap));
+					   OS_DEV_MMAP_REF(sah_mmap));
+
 		os_error_code =
 		    os_driver_complete_registration(reg_handle, Major,
 						    "sahara");
@@ -335,19 +335,19 @@ OS_DEV_INIT(sah_init)
 	if (os_error_code == OS_ERROR_OK_S) {
 		/* set up the system keystore, using the default keystore handler */
 		fsl_shw_init_keystore_default(&system_keystore);
-	
+
 		if (fsl_shw_establish_keystore(NULL, &system_keystore)
-				== FSL_RETURN_OK_S) {
+		    == FSL_RETURN_OK_S) {
 			os_error_code = OS_ERROR_OK_S;
 		} else {
 			os_error_code = OS_ERROR_FAIL_S;
 		}
-	
-		if (os_error_code < OS_ERROR_OK_S) {
+
+		if (os_error_code != OS_ERROR_OK_S) {
 #ifdef DIAG_DRV_IF
-			snprintf(Diag_msg, DIAG_MSG_SIZE, "Registering the system keystore "
-					 "failed with error code: %d\n",
-					 os_error_code);
+			snprintf(Diag_msg, DIAG_MSG_SIZE,
+				 "Registering the system keystore "
+				 "failed with error code: %d\n", os_error_code);
 			LOG_KDIAG(Diag_msg);
 #endif
 		}
@@ -362,7 +362,7 @@ OS_DEV_INIT(sah_init)
 	}
 #ifdef DIAG_DRV_IF
 	else {
-		LOG_KDIAG_ARGS( "Sahara major node is %d\n", Major);
+		LOG_KDIAG_ARGS("Sahara major node is %d\n", Major);
 	}
 #endif
 
@@ -380,11 +380,10 @@ OS_DEV_INIT(sah_init)
 */
 OS_DEV_SHUTDOWN(sah_cleanup)
 {
-
 	int ret_val = 0;
-	
+
 	printk(KERN_ALERT "Sahara going into cleanup\n");
-	
+
 	/* clear out the system keystore */
 	fsl_shw_release_keystore(NULL, &system_keystore);
 
@@ -392,6 +391,7 @@ OS_DEV_SHUTDOWN(sah_cleanup)
 #if defined(CONFIG_DEVFS_FS) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
 	devfs_unregister(Sahara_devfs_handle);
 #else
+
 	if (Sahara_procfs_handle != NULL) {
 		remove_proc_entry(SAHARA_DEVICE_SHORT, NULL);
 	}
@@ -590,6 +590,7 @@ OS_DEV_IOCTL(sah_ioctl)
 			} else {
 				status = OS_ERROR_FAIL_S;
 			}
+
 		}
 		break;
 
@@ -665,115 +666,129 @@ OS_DEV_IOCTL(sah_ioctl)
 			}
 		}
 		break;
-
-    case SAHARA_SCC_DROP_PERMS:
+	case SAHARA_SCC_DROP_PERMS:
 #ifdef DIAG_DRV_IF
 		LOG_KDIAG("SAHARA_SCC_DROP_PERMS IOCTL.");
-#endif /* DIAG_DRV_IF */
+#endif				/* DIAG_DRV_IF */
 		{
 			/* drop permissions on the specified partition */
-			fsl_shw_uco_t* user_ctx = os_dev_get_user_private();
-	
-			status = sah_handle_scc_drop_perms(user_ctx, os_dev_get_ioctl_arg());
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			status =
+			    sah_handle_scc_drop_perms(user_ctx,
+						      os_dev_get_ioctl_arg());
 		}
 		break;
-	
+
 	case SAHARA_SCC_SFREE:
 		/* Unmap the specified partition from the users space, and then
 		 * free it for use by someone else.
-		 */ 
+		 */
 #ifdef DIAG_DRV_IF
 		LOG_KDIAG("SAHARA_SCC_SFREE IOCTL.");
-#endif /* DIAG_DRV_IF */
+#endif				/* DIAG_DRV_IF */
 		{
-			fsl_shw_uco_t* user_ctx = os_dev_get_user_private();
-	
-			status = sah_handle_scc_sfree(user_ctx, os_dev_get_ioctl_arg());
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			status =
+			    sah_handle_scc_sfree(user_ctx,
+						 os_dev_get_ioctl_arg());
 		}
 		break;
 
 	case SAHARA_SCC_SSTATUS:
-			/* Unmap the specified partition from the users space, and then
-			 * free it for use by someone else.
-			 */
+		/* Unmap the specified partition from the users space, and then
+		 * free it for use by someone else.
+		 */
 #ifdef DIAG_DRV_IF
-			LOG_KDIAG("SAHARA_SCC_SSTATUS IOCTL.");
+		LOG_KDIAG("SAHARA_SCC_SSTATUS IOCTL.");
 #endif				/* DIAG_DRV_IF */
-			{
-				fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
-	
-				status =
-					sah_handle_scc_sstatus(user_ctx,
-							   os_dev_get_ioctl_arg());
-			}
-			break;
-	
+		{
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			status =
+			    sah_handle_scc_sstatus(user_ctx,
+						   os_dev_get_ioctl_arg());
+		}
+		break;
+
 	case SAHARA_SCC_ENCRYPT:
 #ifdef DIAG_DRV_IF
 		LOG_KDIAG("SAHARA_SCC_ENCRYPT IOCTL.");
-#endif /* DIAG_DRV_IF */
+#endif				/* DIAG_DRV_IF */
 		{
-			fsl_shw_uco_t* user_ctx = os_dev_get_user_private();
-	
-			status = sah_handle_scc_encrypt(user_ctx, os_dev_get_ioctl_arg());
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			status =
+			    sah_handle_scc_encrypt(user_ctx,
+						   os_dev_get_ioctl_arg());
 		}
 		break;
-	
+
 	case SAHARA_SCC_DECRYPT:
 #ifdef DIAG_DRV_IF
 		LOG_KDIAG("SAHARA_SCC_DECRYPT IOCTL.");
-#endif /* DIAG_DRV_IF */
+#endif				/* DIAG_DRV_IF */
 		{
-			fsl_shw_uco_t* user_ctx = os_dev_get_user_private();
-	
-			status = sah_handle_scc_decrypt(user_ctx, os_dev_get_ioctl_arg());
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
+
+			status =
+			    sah_handle_scc_decrypt(user_ctx,
+						   os_dev_get_ioctl_arg());
 		}
 		break;
-	
+
 	case SAHARA_SK_ALLOC:
 #ifdef DIAG_DRV_IF
 		LOG_KDIAG("SAHARA_SK_ALLOC IOCTL.");
-#endif /* DIAG_DRV_IF */
+#endif				/* DIAG_DRV_IF */
 		status = sah_handle_sk_slot_alloc(os_dev_get_ioctl_arg());
 		break;
+
 	case SAHARA_SK_DEALLOC:
 #ifdef DIAG_DRV_IF
 		LOG_KDIAG("SAHARA_SK_DEALLOC IOCTL.");
-#endif /* DIAG_DRV_IF */
+#endif				/* DIAG_DRV_IF */
 		status = sah_handle_sk_slot_dealloc(os_dev_get_ioctl_arg());
 		break;
 
 	case SAHARA_SK_LOAD:
 #ifdef DIAG_DRV_IF
 		LOG_KDIAG("SAHARA_SK_LOAD IOCTL.");
-#endif	/* DIAG_DRV_IF */
+#endif				/* DIAG_DRV_IF */
 		status = sah_handle_sk_slot_load(os_dev_get_ioctl_arg());
 		break;
+	case SAHARA_SK_READ:
+#ifdef DIAG_DRV_IF
+				LOG_KDIAG("SAHARA_SK_READ IOCTL.");
+#endif				/* DIAG_DRV_IF */
+				status = sah_handle_sk_slot_read(os_dev_get_ioctl_arg());
+				break;
 
 	case SAHARA_SK_SLOT_DEC:
 #ifdef DIAG_DRV_IF
 		LOG_KDIAG("SAHARA_SK_SLOT_DECRYPT IOCTL.");
-#endif	/* DIAG_DRV_IF */
+#endif				/* DIAG_DRV_IF */
 		status = sah_handle_sk_slot_decrypt(os_dev_get_ioctl_arg());
 		break;
 
 	case SAHARA_SK_SLOT_ENC:
 #ifdef DIAG_DRV_IF
-		LOG_KDIAG("SAHARA_SK_LOAD_ENCRYPT IOCTL.");
-#endif	/* DIAG_DRV_IF */
+		LOG_KDIAG("SAHARA_SK_SLOT_ENCRYPT IOCTL.");
+#endif				/* DIAG_DRV_IF */
 		status = sah_handle_sk_slot_encrypt(os_dev_get_ioctl_arg());
 		break;
-
 	case SAHARA_GET_CAPS:
 #ifdef DIAG_DRV_IF
 		LOG_KDIAG("SAHARA_GET_CAPS IOCTL.");
-#endif /* DIAG_DRV_IF */
+#endif				/* DIAG_DRV_IF */
 		{
-			fsl_shw_uco_t* user_ctx = os_dev_get_user_private();
-		
-			status = sah_handle_get_capabilities(user_ctx, os_dev_get_ioctl_arg());
-		}
+			fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
 
+			status =
+			    sah_handle_get_capabilities(user_ctx,
+							os_dev_get_ioctl_arg());
+		}
 		break;
 
 	default:
@@ -787,592 +802,602 @@ OS_DEV_IOCTL(sah_ioctl)
 }
 
 /* Fill in the user's capabilities structure */
-static os_error_code sah_handle_get_capabilities(fsl_shw_uco_t* user_ctx, uint32_t info)
+static os_error_code sah_handle_get_capabilities(fsl_shw_uco_t * user_ctx,
+						 uint32_t info)
 {
-    os_error_code status = OS_ERROR_FAIL_S;
-    fsl_shw_pco_t capabilities;
+	os_error_code status = OS_ERROR_FAIL_S;
+	fsl_shw_pco_t capabilities;
 
-    status = os_copy_from_user(&capabilities, (void*)info,
-                               sizeof(fsl_shw_pco_t));
+	status = os_copy_from_user(&capabilities, (void *)info,
+				   sizeof(fsl_shw_pco_t));
 
-    if (status != OS_ERROR_OK_S) {
-        goto out;
-    }
+	if (status != OS_ERROR_OK_S) {
+		goto out;
+	}
 
-    if (get_capabilities(user_ctx, &capabilities) == FSL_RETURN_OK_S) {
-        status = os_copy_to_user((void*)info, &capabilities,
-                                 sizeof(fsl_shw_pco_t));
-    }
+	if (get_capabilities(user_ctx, &capabilities) == FSL_RETURN_OK_S) {
+		status = os_copy_to_user((void *)info, &capabilities,
+					 sizeof(fsl_shw_pco_t));
+	}
 
-out:
-    return status;
+      out:
+	return status;
 }
 
 #ifdef FSL_HAVE_SCC2
 
-
 /* Find the kernel-mode address of the partition.
  * This can then be passed to the SCC functions.
  */
-void* lookup_user_partition(fsl_shw_uco_t* user_ctx, uint32_t user_base)
+void *lookup_user_partition(fsl_shw_uco_t * user_ctx, uint32_t user_base)
 {
-    /* search through the partition chain to find one that matches the user base
-     * address.
-     */
-    fsl_shw_spo_t* curr = (fsl_shw_spo_t*)user_ctx->partition;
-
-    while(curr != NULL) {
-        if (curr->user_base == user_base) {
-            return curr->kernel_base;
-        }
-        curr = (fsl_shw_spo_t*)curr->next;
-    }
-    return NULL;
+	/* search through the partition chain to find one that matches the user base
+	 * address.
+	 */
+	fsl_shw_spo_t *curr = (fsl_shw_spo_t *) user_ctx->partition;
+
+	while (curr != NULL) {
+		if (curr->user_base == user_base) {
+			return curr->kernel_base;
+		}
+		curr = (fsl_shw_spo_t *) curr->next;
+	}
+	return NULL;
 }
 
 /* user_base: userspace base address of the partition
  * kernel_base: kernel mode base address of the partition
  */
-static fsl_shw_return_t register_user_partition(
-                            fsl_shw_uco_t* user_ctx,
-                            uint32_t user_base,
-                            void* kernel_base) {
-    fsl_shw_spo_t* partition_info;
-    fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
+static fsl_shw_return_t register_user_partition(fsl_shw_uco_t * user_ctx,
+						uint32_t user_base,
+						void *kernel_base)
+{
+	fsl_shw_spo_t *partition_info;
+	fsl_shw_return_t ret = FSL_RETURN_ERROR_S;
 
-    if (user_ctx == NULL) {
-        goto out;
-    }
+	if (user_ctx == NULL) {
+		goto out;
+	}
 
-    partition_info = os_alloc_memory(sizeof(fsl_shw_spo_t), GFP_KERNEL);
+	partition_info = os_alloc_memory(sizeof(fsl_shw_spo_t), GFP_KERNEL);
 
-    if (partition_info == NULL) {
-        goto out;
-    }
+	if (partition_info == NULL) {
+		goto out;
+	}
 
-    /* stuff the partition info, then put it at the front of the chain */
-    partition_info->user_base = user_base;
-    partition_info->kernel_base = kernel_base;
-    partition_info->next = user_ctx->partition;
+	/* stuff the partition info, then put it at the front of the chain */
+	partition_info->user_base = user_base;
+	partition_info->kernel_base = kernel_base;
+	partition_info->next = user_ctx->partition;
 
-    user_ctx->partition = (struct fsl_shw_spo_t*)partition_info;
+	user_ctx->partition = (struct fsl_shw_spo_t *)partition_info;
 
 #ifdef DIAG_DRV_IF
-    LOG_KDIAG_ARGS("partition with user_base=%p, kernel_base=%p registered.",
-                   (void*)user_base, kernel_base);
+	LOG_KDIAG_ARGS
+	    ("partition with user_base=%p, kernel_base=%p registered.",
+	     (void *)user_base, kernel_base);
 #endif
 
-    ret = FSL_RETURN_OK_S;
+	ret = FSL_RETURN_OK_S;
 
-out: 
+      out:
 
-    return ret;
+	return ret;
 }
 
 /* if the partition is in the users list, remove it */
-static fsl_shw_return_t deregister_user_partition(fsl_shw_uco_t* user_ctx,
-                                                  uint32_t user_base) {
-    fsl_shw_spo_t* curr = (fsl_shw_spo_t*)user_ctx->partition;
-    fsl_shw_spo_t* last = (fsl_shw_spo_t*)user_ctx->partition;
-
-    while(curr != NULL) {
-        if (curr->user_base == user_base) {
-        
+static fsl_shw_return_t deregister_user_partition(fsl_shw_uco_t * user_ctx,
+						  uint32_t user_base)
+{
+	fsl_shw_spo_t *curr = (fsl_shw_spo_t *) user_ctx->partition;
+	fsl_shw_spo_t *last = (fsl_shw_spo_t *) user_ctx->partition;
+
+	while (curr != NULL) {
+		if (curr->user_base == user_base) {
+
 #ifdef DIAG_DRV_IF
-            LOG_KDIAG_ARGS("deregister_user_partition: partition with "
-                           "user_base=%p, kernel_base=%p deregistered.\n",
-                           (void*)curr->user_base, curr->kernel_base);
+			LOG_KDIAG_ARGS
+			    ("deregister_user_partition: partition with "
+			     "user_base=%p, kernel_base=%p deregistered.\n",
+			     (void *)curr->user_base, curr->kernel_base);
 #endif
 
-            if (last == curr) {
-                user_ctx->partition = curr->next;
-                os_free_memory(curr); 
-                return FSL_RETURN_OK_S; 
-            }
-            else {
-                last->next = curr->next;
-                os_free_memory(curr); 
-                return FSL_RETURN_OK_S;
-            }
-        }
-        last = curr;
-        curr = (fsl_shw_spo_t*)curr->next;
-    }
-
-    return FSL_RETURN_ERROR_S;
+			if (last == curr) {
+				user_ctx->partition = curr->next;
+				os_free_memory(curr);
+				return FSL_RETURN_OK_S;
+			} else {
+				last->next = curr->next;
+				os_free_memory(curr);
+				return FSL_RETURN_OK_S;
+			}
+		}
+		last = curr;
+		curr = (fsl_shw_spo_t *) curr->next;
+	}
+
+	return FSL_RETURN_ERROR_S;
 }
 
-#endif /* FSL_HAVE_SCC2 */
+#endif				/* FSL_HAVE_SCC2 */
 
-static os_error_code sah_handle_scc_drop_perms(fsl_shw_uco_t* user_ctx,
-                                               uint32_t info)
+static os_error_code sah_handle_scc_drop_perms(fsl_shw_uco_t * user_ctx,
+					       uint32_t info)
 {
-    os_error_code status = OS_ERROR_NO_MEMORY_S;
+	os_error_code status = OS_ERROR_NO_MEMORY_S;
 #ifdef FSL_HAVE_SCC2
-    scc_return_t scc_ret;
-    scc_partition_info_t partition_info;
-    void* kernel_base;
+	scc_return_t scc_ret;
+	scc_partition_info_t partition_info;
+	void *kernel_base;
 
-    status = os_copy_from_user(&partition_info, (void*)info, sizeof(partition_info));
+	status =
+	    os_copy_from_user(&partition_info, (void *)info,
+			      sizeof(partition_info));
 
-    if (status != OS_ERROR_OK_S) {
-        goto out;
-    }
+	if (status != OS_ERROR_OK_S) {
+		goto out;
+	}
 
-    /* validate that the user owns this partition, and look up its handle */
-    kernel_base = lookup_user_partition(user_ctx, partition_info.user_base);
+	/* validate that the user owns this partition, and look up its handle */
+	kernel_base = lookup_user_partition(user_ctx, partition_info.user_base);
 
-    if (kernel_base == NULL) {
-        status = OS_ERROR_FAIL_S;
+	if (kernel_base == NULL) {
+		status = OS_ERROR_FAIL_S;
 #ifdef DIAG_DRV_IF
-        LOG_KDIAG("_scc_drop_perms(): failed to find partition\n");
+		LOG_KDIAG("_scc_drop_perms(): failed to find partition\n");
 #endif
-        goto out;
-    }
-
-    /* call scc driver to perform the drop */
-    scc_ret = scc_diminish_permissions(kernel_base,
-                                       partition_info.permissions);
-    if (scc_ret == SCC_RET_OK) {
-        status = OS_ERROR_OK_S;
-    } else {
-        status = OS_ERROR_FAIL_S;
-    }
-
-out:
-#endif /* FSL_HAVE_SCC2 */
-    return status;
+		goto out;
+	}
+
+	/* call scc driver to perform the drop */
+	scc_ret = scc_diminish_permissions(kernel_base,
+					   partition_info.permissions);
+	if (scc_ret == SCC_RET_OK) {
+		status = OS_ERROR_OK_S;
+	} else {
+		status = OS_ERROR_FAIL_S;
+	}
+
+      out:
+#endif				/* FSL_HAVE_SCC2 */
+	return status;
 }
 
-static os_error_code sah_handle_scc_sfree(fsl_shw_uco_t* user_ctx, uint32_t info)
+static os_error_code sah_handle_scc_sfree(fsl_shw_uco_t * user_ctx,
+					  uint32_t info)
 {
-    os_error_code status = OS_ERROR_NO_MEMORY_S;
+	os_error_code status = OS_ERROR_NO_MEMORY_S;
 #ifdef FSL_HAVE_SCC2
-    {
-        scc_partition_info_t partition_info;
-        void* kernel_base;
-        int ret;
+	{
+		scc_partition_info_t partition_info;
+		void *kernel_base;
+		int ret;
 
-        status = os_copy_from_user(&partition_info, (void*)info, sizeof(partition_info));
+		status =
+		    os_copy_from_user(&partition_info, (void *)info,
+				      sizeof(partition_info));
 
-        /* check that the copy was successful */
-        if (status != OS_ERROR_OK_S) {
-            goto out;
-        }
+		/* check that the copy was successful */
+		if (status != OS_ERROR_OK_S) {
+			goto out;
+		}
 
-        /* validate that the user owns this partition, and look up its handle */
-        kernel_base = lookup_user_partition(user_ctx, partition_info.user_base);
+		/* validate that the user owns this partition, and look up its handle */
+		kernel_base =
+		    lookup_user_partition(user_ctx, partition_info.user_base);
 
-        if (kernel_base == NULL) {
-            status = OS_ERROR_FAIL_S;
+		if (kernel_base == NULL) {
+			status = OS_ERROR_FAIL_S;
 #ifdef DIAG_DRV_IF
-            LOG_KDIAG("failed to find partition\n");
-#endif /*DIAG_DRV_IF */
-            goto out;
-        }
+			LOG_KDIAG("failed to find partition\n");
+#endif				/*DIAG_DRV_IF */
+			goto out;
+		}
 
-        /* Unmap the memory region (see sys_munmap in mmap.c) */
-        ret = unmap_user_memory(partition_info.user_base, 8192);
+		/* Unmap the memory region (see sys_munmap in mmap.c) */
+		ret = unmap_user_memory(partition_info.user_base, 8192);
 
-        /* If the memory was successfully released */
-        if (ret == OS_ERROR_OK_S) {
+		/* If the memory was successfully released */
+		if (ret == OS_ERROR_OK_S) {
 
-            /* release the partition */
-            scc_release_partition(kernel_base);
+			/* release the partition */
+			scc_release_partition(kernel_base);
 
-            /* and remove it from the users context */
-            deregister_user_partition(user_ctx, partition_info.user_base);
+			/* and remove it from the users context */
+			deregister_user_partition(user_ctx,
+						  partition_info.user_base);
 
-            status = OS_ERROR_OK_S;
-        }
-    }
-out:
-#endif /* FSL_HAVE_SCC2 */
-    return status;
+			status = OS_ERROR_OK_S;
+		}
+	}
+      out:
+#endif				/* FSL_HAVE_SCC2 */
+	return status;
 }
 
-static os_error_code sah_handle_scc_sstatus(fsl_shw_uco_t* user_ctx, uint32_t info)
+static os_error_code sah_handle_scc_sstatus(fsl_shw_uco_t * user_ctx,
+					    uint32_t info)
 {
-    os_error_code status = OS_ERROR_NO_MEMORY_S;
-	
+	os_error_code status = OS_ERROR_NO_MEMORY_S;
 #ifdef FSL_HAVE_SCC2
 	{
 		scc_partition_info_t partition_info;
 		void *kernel_base;
+
 		status =
-			os_copy_from_user(&partition_info, (void *)info,
-					  sizeof(partition_info));
-	
+		    os_copy_from_user(&partition_info, (void *)info,
+				      sizeof(partition_info));
+
 		/* check that the copy was successful */
 		if (status != OS_ERROR_OK_S) {
 			goto out;
 		}
-	
+
 		/* validate that the user owns this partition, and look up its handle */
 		kernel_base =
-			lookup_user_partition(user_ctx, partition_info.user_base);
-	
+		    lookup_user_partition(user_ctx, partition_info.user_base);
+
 		if (kernel_base == NULL) {
 			status = OS_ERROR_FAIL_S;
 #ifdef DIAG_DRV_IF
 			LOG_KDIAG("failed to find partition\n");
-#endif			/*DIAG_DRV_IF */
+#endif				/*DIAG_DRV_IF */
 			goto out;
 		}
-	
+
 		partition_info.status = scc_partition_status(kernel_base);
-	
+
 		status =
-			os_copy_to_user((void *)info, &partition_info,
-					sizeof(partition_info));
+		    os_copy_to_user((void *)info, &partition_info,
+				    sizeof(partition_info));
 	}
-out:
+      out:
 #endif				/* FSL_HAVE_SCC2 */
 	return status;
-
 }
 
-static os_error_code sah_handle_scc_encrypt(fsl_shw_uco_t* user_ctx, uint32_t info)
+static os_error_code sah_handle_scc_encrypt(fsl_shw_uco_t * user_ctx,
+					    uint32_t info)
 {
-    os_error_code os_err = OS_ERROR_FAIL_S;
+	os_error_code os_err = OS_ERROR_FAIL_S;
 #ifdef FSL_HAVE_SCC2
-    {
-        fsl_shw_return_t retval;
-        scc_region_t region_info;
-        void* page_ctx = NULL;
-        void* black_addr = NULL;
-        void* partition_base = NULL;
-        scc_config_t*   scc_configuration;
-
-        os_err = os_copy_from_user(&region_info, (void*)info, sizeof(region_info));
+	{
+		fsl_shw_return_t retval;
+		scc_region_t region_info;
+		void *page_ctx = NULL;
+		void *black_addr = NULL;
+		void *partition_base = NULL;
+		scc_config_t *scc_configuration;
 
-        if (os_err != OS_ERROR_OK_S) {
-            goto out;
-        }
+		os_err =
+		    os_copy_from_user(&region_info, (void *)info,
+				      sizeof(region_info));
 
+		if (os_err != OS_ERROR_OK_S) {
+			goto out;
+		}
 #ifdef DIAG_DRV_IF
 		LOG_KDIAG_ARGS
-		("partition_base: %p, offset: %i, length: %i, black data: %p",
-		 (void *)region_info.partition_base, region_info.offset,
-		 region_info.length, (void *)region_info.black_data);
+		    ("partition_base: %p, offset: %i, length: %i, black data: %p",
+		     (void *)region_info.partition_base, region_info.offset,
+		     region_info.length, (void *)region_info.black_data);
 #endif
 
-        /* validate that the user owns this partition, and look up its handle */
-        partition_base = lookup_user_partition(user_ctx,
-                                               region_info.partition_base);
+		/* validate that the user owns this partition, and look up its handle */
+		partition_base = lookup_user_partition(user_ctx,
+						       region_info.
+						       partition_base);
 
-        if (partition_base == NULL) {
-            os_err = OS_ERROR_FAIL_S;
+		if (partition_base == NULL) {
+			retval = FSL_RETURN_ERROR_S;
 #ifdef DIAG_DRV_IF
-            LOG_KDIAG("failed to find secure partition\n");
+			LOG_KDIAG("failed to find secure partition\n");
 #endif
-            goto out;
-        }
-
-        /* Check that the memory size requested is correct */
-        scc_configuration = scc_get_configuration();
-        if (region_info.offset + region_info.length > 
-                scc_configuration->partition_size_bytes) {
-            retval= FSL_RETURN_ERROR_S;
-            goto out;
-        }
-
-        /* wire down black data */
-        black_addr = wire_user_memory(region_info.black_data,
-                                      region_info.length,
-                                      &page_ctx);
-
-        if (black_addr == NULL) {
-            retval= FSL_RETURN_ERROR_S;
-            goto out;
-        }
-
-        retval = do_scc_encrypt_region(NULL, partition_base, region_info.offset,
-                                       region_info.length, black_addr,
-                                       region_info.IV,
-                                       region_info.cypher_mode);
-
-        /* release black data */
-        unwire_user_memory(&page_ctx);
-
-out:
+			goto out;
+		}
+
+		/* Check that the memory size requested is correct */
+		scc_configuration = scc_get_configuration();
+		if (region_info.offset + region_info.length >
+		    scc_configuration->partition_size_bytes) {
+			retval = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+
+		/* wire down black data */
+		black_addr = wire_user_memory(region_info.black_data,
+					      region_info.length, &page_ctx);
+
+		if (black_addr == NULL) {
+			retval = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+
+		retval =
+		    do_scc_encrypt_region(NULL, partition_base,
+					  region_info.offset,
+					  region_info.length, black_addr,
+					  region_info.IV,
+					  region_info.cypher_mode);
+
+		/* release black data */
+		unwire_user_memory(&page_ctx);
+
+	      out:
 		if (os_err == OS_ERROR_OK_S) {
 			/* Return error code */
 			region_info.code = retval;
 			os_err =
-				os_copy_to_user((void *)info, &region_info,
-						sizeof(region_info));
+			    os_copy_to_user((void *)info, &region_info,
+					    sizeof(region_info));
 		}
-    }
+	}
 
 #endif
-    return os_err;
+	return os_err;
 }
 
-static os_error_code sah_handle_scc_decrypt(fsl_shw_uco_t* user_ctx, uint32_t info)
+static os_error_code sah_handle_scc_decrypt(fsl_shw_uco_t * user_ctx,
+					    uint32_t info)
 {
-    os_error_code os_err = OS_ERROR_FAIL_S;
+	os_error_code os_err = OS_ERROR_FAIL_S;
 #ifdef FSL_HAVE_SCC2
-    {
-        fsl_shw_return_t retval;
-        scc_region_t region_info;
-        void* page_ctx = NULL;
-        void* black_addr;
-        void* partition_base;
-        scc_config_t* scc_configuration;
+	{
+		fsl_shw_return_t retval;
+		scc_region_t region_info;
+		void *page_ctx = NULL;
+		void *black_addr;
+		void *partition_base;
+		scc_config_t *scc_configuration;
 
-        os_err = os_copy_from_user(&region_info, (void*)info, sizeof(region_info));
+		os_err =
+		    os_copy_from_user(&region_info, (void *)info,
+				      sizeof(region_info));
 
+		if (os_err != OS_ERROR_OK_S) {
+			goto out;
+		}
 #ifdef DIAG_DRV_IF
-        LOG_KDIAG_ARGS("partition_base: %p, offset: %i, length: %i, black data: %p",
-                       (void*)region_info.partition_base,
-                       region_info.offset,
-                       region_info.length,
-                       (void*)region_info.black_data);
+		LOG_KDIAG_ARGS
+		    ("partition_base: %p, offset: %i, length: %i, black data: %p",
+		     (void *)region_info.partition_base, region_info.offset,
+		     region_info.length, (void *)region_info.black_data);
 #endif
 
-        if (os_err != OS_ERROR_OK_S) {
-            goto out;
-        }
+		/* validate that the user owns this partition, and look up its handle */
+		partition_base = lookup_user_partition(user_ctx,
+						       region_info.
+						       partition_base);
+
+		if (partition_base == NULL) {
+			retval = FSL_RETURN_ERROR_S;
 #ifdef DIAG_DRV_IF
-			LOG_KDIAG_ARGS
-				("partition_base: %p, offset: %i, length: %i, black data: %p",
-				 (void *)region_info.partition_base, region_info.offset,
-				 region_info.length, (void *)region_info.black_data);
+			LOG_KDIAG("failed to find partition\n");
 #endif
+			goto out;
+		}
+
+		/* Check that the memory size requested is correct */
+		scc_configuration = scc_get_configuration();
+		if (region_info.offset + region_info.length >
+		    scc_configuration->partition_size_bytes) {
+			retval = FSL_RETURN_ERROR_S;
+			goto out;
+		}
 
-        /* validate that the user owns this partition, and look up its handle */
-        partition_base = lookup_user_partition(user_ctx,
-                                               region_info.partition_base);
+		/* wire down black data */
+		black_addr = wire_user_memory(region_info.black_data,
+					      region_info.length, &page_ctx);
 
-        if (partition_base == NULL) {
-            retval = FSL_RETURN_ERROR_S;
-#ifdef DIAG_DRV_IF
-            LOG_KDIAG("failed to find partition\n");
-#endif
-            goto out;
-        }
-
-        /* Check that the memory size requested is correct */
-        scc_configuration = scc_get_configuration();
-        if (region_info.offset + region_info.length > 
-                scc_configuration->partition_size_bytes) {
-            retval = FSL_RETURN_ERROR_S;
-            goto out;
-        }
-
-        /* wire down black data */
-        black_addr = wire_user_memory(region_info.black_data,
-                                      region_info.length,
-                                      &page_ctx);
-
-        if (black_addr == NULL) {
-            retval = FSL_RETURN_ERROR_S;
-            goto out;
-        }
-
-        retval = do_scc_decrypt_region(NULL, partition_base, region_info.offset,
-                                       region_info.length, black_addr,
-                                       region_info.IV,
-                                       region_info.cypher_mode);
-
-        /* release black data */
-        unwire_user_memory(&page_ctx);
-
-out:
-	    if (os_err == OS_ERROR_OK_S) {
+		if (black_addr == NULL) {
+			retval = FSL_RETURN_ERROR_S;
+			goto out;
+		}
+
+		retval =
+		    do_scc_decrypt_region(NULL, partition_base,
+					  region_info.offset,
+					  region_info.length, black_addr,
+					  region_info.IV,
+					  region_info.cypher_mode);
+
+		/* release black data */
+		unwire_user_memory(&page_ctx);
+
+	      out:
+		if (os_err == OS_ERROR_OK_S) {
 			/* Return error code */
 			region_info.code = retval;
 			os_err =
-				os_copy_to_user((void *)info, &region_info,
-						sizeof(region_info));
+			    os_copy_to_user((void *)info, &region_info,
+					    sizeof(region_info));
 		}
+	}
 
-    }
-
-#endif /* FSL_HAVE_SCC2 */
-    return os_err;
+#endif				/* FSL_HAVE_SCC2 */
+	return os_err;
 }
 
 /*****************************************************************************/
 /* fn get_user_smid()                                                        */
 /*****************************************************************************/
-uint32_t get_user_smid(void* proc)
+uint32_t get_user_smid(void *proc)
 {
-    /*
-     * A real implementation would have some way to handle signed applications
-     * which wouild be assigned distinct SMIDs.  For the reference
-     * implementation, we show where this would be determined (here), but
-     * always provide a fixed answer, thus not separating users at all.
-     */
-
-    return 0x42eaae42;
+	/*
+	 * A real implementation would have some way to handle signed applications
+	 * which wouild be assigned distinct SMIDs.  For the reference
+	 * implementation, we show where this would be determined (here), but
+	 * always provide a fixed answer, thus not separating users at all.
+	 */
+
+	return 0x42eaae42;
 }
-/*
+
+/*!
+*******************************************************************************
 * This function implements the smalloc() function for userspace programs, by
 * making a call to the SCC2 mmap() function that acquires a region of secure
 * memory on behalf of the user, and then maps it into the users memory space.
 * Currently, the only memory size supported is that of a single SCC2 partition.
 * Requests for other sized memory regions will fail.
 */
-//static os_error_code sah_handle_scc_slot_alloc(uint32_t info)
 OS_DEV_MMAP(sah_mmap)
 {
-    os_error_code status = OS_ERROR_NO_MEMORY_S;
+	os_error_code status = OS_ERROR_NO_MEMORY_S;
 
 #ifdef FSL_HAVE_SCC2
-    {   scc_return_t scc_ret;
-        fsl_shw_return_t fsl_ret;
-        uint32_t partition_registered = FALSE;
-
-        uint32_t user_base;
-        void* partition_base;
-        uint32_t smid;
-        scc_config_t* scc_configuration;
-
-        int part_no = -1;
-        uint32_t part_phys;
-
-        fsl_shw_uco_t* user_ctx = (fsl_shw_uco_t*)os_dev_get_user_private();
-
-        /* Make sure that the user context is valid */
-        if (user_ctx == NULL) {
-            user_ctx = os_alloc_memory(sizeof(*user_ctx), GFP_KERNEL);
-
-            if (user_ctx == NULL) {
-                status = OS_ERROR_NO_MEMORY_S;
-                goto out;
-            }
-                                        
-            sah_handle_registration(user_ctx);
-            os_dev_set_user_private(user_ctx);
-        }
-
-        /* Determine the size of a secure partition */
-        scc_configuration = scc_get_configuration();
-
-        /* Check that the memory size requested is equal to the partition
-         * size, and that the requested destination is on a page boundary.
-         */
-        if (((os_mmap_user_base() % PAGE_SIZE) != 0) || 
-            (os_mmap_memory_size() != scc_configuration->partition_size_bytes))
-        {
-            status = OS_ERROR_BAD_ARG_S;
-            goto out;
-        }
-
-        /* Retrieve the SMID associated with the user */
-        smid = get_user_smid(user_ctx->process);
-
-        /* Attempt to allocate a secure partition */
-        scc_ret = scc_allocate_partition(smid, &part_no, &partition_base, &part_phys);
-        if (scc_ret != SCC_RET_OK) {
-            pr_debug("SCC mmap() request failed to allocate partition;"
-                     " error %d\n", status);
-            status = OS_ERROR_FAIL_S;
-            goto out;
-        }
-
-        pr_debug("scc_mmap() acquired partition %d at %08x\n",
-                 part_no, part_phys);
-
-
-        /* Record partition info in the user context */
-        user_base = os_mmap_user_base();
-        fsl_ret = register_user_partition(user_ctx, user_base, partition_base);
-
-        if (fsl_ret != FSL_RETURN_OK_S) {
-            pr_debug("SCC mmap() request failed to register partition with user"
-                     " context, error: %d\n", fsl_ret);
-            status = OS_ERROR_FAIL_S;
-        }
-
-        partition_registered = TRUE;
-
-        status = map_user_memory(os_mmap_memory_ctx(), part_phys,
-                                 os_mmap_memory_size());
+	{
+		scc_return_t scc_ret;
+		fsl_shw_return_t fsl_ret;
+		uint32_t partition_registered = FALSE;
+
+		uint32_t user_base;
+		void *partition_base;
+		uint32_t smid;
+		scc_config_t *scc_configuration;
+
+		int part_no = -1;
+		uint32_t part_phys;
+
+		fsl_shw_uco_t *user_ctx =
+		    (fsl_shw_uco_t *) os_dev_get_user_private();
+
+		/* Make sure that the user context is valid */
+		if (user_ctx == NULL) {
+			user_ctx =
+			    os_alloc_memory(sizeof(*user_ctx), GFP_KERNEL);
+
+			if (user_ctx == NULL) {
+				status = OS_ERROR_NO_MEMORY_S;
+				goto out;
+			}
+
+			sah_handle_registration(user_ctx);
+			os_dev_set_user_private(user_ctx);
+		}
+
+		/* Determine the size of a secure partition */
+		scc_configuration = scc_get_configuration();
+
+		/* Check that the memory size requested is equal to the partition
+		 * size, and that the requested destination is on a page boundary.
+		 */
+		if (((os_mmap_user_base() % PAGE_SIZE) != 0) ||
+		    (os_mmap_memory_size() !=
+		     scc_configuration->partition_size_bytes)) {
+			status = OS_ERROR_BAD_ARG_S;
+			goto out;
+		}
+
+		/* Retrieve the SMID associated with the user */
+		smid = get_user_smid(user_ctx->process);
+
+		/* Attempt to allocate a secure partition */
+		scc_ret =
+		    scc_allocate_partition(smid, &part_no, &partition_base,
+					   &part_phys);
+		if (scc_ret != SCC_RET_OK) {
+			pr_debug
+			    ("SCC mmap() request failed to allocate partition;"
+			     " error %d\n", status);
+			status = OS_ERROR_FAIL_S;
+			goto out;
+		}
+
+		pr_debug("scc_mmap() acquired partition %d at %08x\n",
+			 part_no, part_phys);
+
+		/* Record partition info in the user context */
+		user_base = os_mmap_user_base();
+		fsl_ret =
+		    register_user_partition(user_ctx, user_base,
+					    partition_base);
+
+		if (fsl_ret != FSL_RETURN_OK_S) {
+			pr_debug
+			    ("SCC mmap() request failed to register partition with user"
+			     " context, error: %d\n", fsl_ret);
+			status = OS_ERROR_FAIL_S;
+		}
+
+		partition_registered = TRUE;
+
+		status = map_user_memory(os_mmap_memory_ctx(), part_phys,
+					 os_mmap_memory_size());
 
 #ifdef SHW_DEBUG
-        if (status == OS_ERROR_OK_S) {
-            LOG_KDIAG_ARGS("Partition allocated: user_base=%p, partition_base=%p.",
-                           (void*)user_base, partition_base);
-        }
+		if (status == OS_ERROR_OK_S) {
+			LOG_KDIAG_ARGS
+			    ("Partition allocated: user_base=%p, partition_base=%p.",
+			     (void *)user_base, partition_base);
+		}
 #endif
 
-out:
-        /* If there is an error it has to be handled here */
-        if (status != OS_ERROR_OK_S) {
-            /* if the partition was registered with the user, unregister it. */
-            if (partition_registered == TRUE) {
-                deregister_user_partition(user_ctx, user_base);
-            }
-
-            /* if the partition was allocated, deallocate it */
-            if (partition_base != NULL) {
-                scc_release_partition(partition_base);
-            }
-        }
-    }
-#endif /* FSL_HAVE_SCC2 */
-
- return status;
+	      out:
+		/* If there is an error it has to be handled here */
+		if (status != OS_ERROR_OK_S) {
+			/* if the partition was registered with the user, unregister it. */
+			if (partition_registered == TRUE) {
+				deregister_user_partition(user_ctx, user_base);
+			}
+
+			/* if the partition was allocated, deallocate it */
+			if (partition_base != NULL) {
+				scc_release_partition(partition_base);
+			}
+		}
+	}
+#endif				/* FSL_HAVE_SCC2 */
+
+	return status;
 }
 
 /* Find the physical address of a key stored in the system keystore */
 fsl_shw_return_t
-system_keystore_get_slot_info(uint64_t owner_id, uint32_t slot, uint32_t* address,
-                              uint32_t* slot_size_bytes)
+system_keystore_get_slot_info(uint64_t owner_id, uint32_t slot,
+			      uint32_t * address, uint32_t * slot_size_bytes)
 {
-    fsl_shw_return_t retval;
-    void* kernel_address;
+	fsl_shw_return_t retval;
+	void *kernel_address;
 
-    /* First verify that the key access is valid */
-    retval = system_keystore.slot_verify_access(system_keystore.user_data,
-                                                owner_id, slot);
+	/* First verify that the key access is valid */
+	retval = system_keystore.slot_verify_access(system_keystore.user_data,
+						    owner_id, slot);
 
-    if (retval != FSL_RETURN_OK_S) {
+	if (retval != FSL_RETURN_OK_S) {
 #ifdef DIAG_DRV_IF
-        LOG_KDIAG("verification failed");
+		LOG_KDIAG("verification failed");
 #endif
-        return retval;
-    }
+		return retval;
+	}
 
-    if (address != NULL) {
+	if (address != NULL) {
 #ifdef FSL_HAVE_SCC2
-        kernel_address =
-            system_keystore.slot_get_address(system_keystore.user_data, slot);
-        (*address) = scc_virt_to_phys(kernel_address);
+		kernel_address =
+		    system_keystore.slot_get_address(system_keystore.user_data,
+						     slot);
+		(*address) = scc_virt_to_phys(kernel_address);
 #else
-        kernel_address =
-            system_keystore.slot_get_address((void*)&owner_id, slot);
-        (*address) = (uint32_t)kernel_address;
+		kernel_address =
+		    system_keystore.slot_get_address((void *)&owner_id, slot);
+		(*address) = (uint32_t) kernel_address;
 #endif
-    }
+	}
 
-    if (slot_size_bytes != NULL) {
+	if (slot_size_bytes != NULL) {
 #ifdef FSL_HAVE_SCC2
-        *slot_size_bytes =
-           system_keystore.slot_get_slot_size(system_keystore.user_data, slot);
+		*slot_size_bytes =
+		    system_keystore.slot_get_slot_size(system_keystore.
+						       user_data, slot);
 #else
-        *slot_size_bytes =
-           system_keystore.slot_get_slot_size((void*)&owner_id, slot);
+		*slot_size_bytes =
+		    system_keystore.slot_get_slot_size((void *)&owner_id, slot);
 #endif
-    }
+	}
 
-    return retval;
+	return retval;
 }
 
-
-/*!
-*******************************************************************************
-* Allocates a slot in the SCC
-*
-* @brief Allocates a slot in the SCC
-*
-* @param    info   slot information
-*
-* @return   0 if pass; non-zero on error
-*/
 static os_error_code sah_handle_sk_slot_alloc(uint32_t info)
 {
 	scc_slot_t slot_info;
@@ -1382,8 +1407,9 @@ static os_error_code sah_handle_sk_slot_alloc(uint32_t info)
 	os_err = os_copy_from_user(&slot_info, (void *)info, sizeof(slot_info));
 	if (os_err == OS_ERROR_OK_S) {
 		scc_ret = keystore_slot_alloc(&system_keystore,
-		    slot_info.key_length, slot_info.ownerid,
-				   &slot_info.slot);
+					      slot_info.key_length,
+					      slot_info.ownerid,
+					      &slot_info.slot);
 		if (scc_ret == SCC_RET_OK) {
 			slot_info.code = FSL_RETURN_OK_S;
 		} else if (scc_ret == SCC_RET_INSUFFICIENT_SPACE) {
@@ -1392,10 +1418,9 @@ static os_error_code sah_handle_sk_slot_alloc(uint32_t info)
 			slot_info.code = FSL_RETURN_ERROR_S;
 		}
 
-		
 #ifdef DIAG_DRV_IF
-			LOG_KDIAG_ARGS("key length: %i, handle: %i\n", slot_info.key_length,
-							   slot_info.slot);
+		LOG_KDIAG_ARGS("key length: %i, handle: %i\n",
+			       slot_info.key_length, slot_info.slot);
 #endif
 
 		/* Return error code and slot info */
@@ -1404,23 +1429,15 @@ static os_error_code sah_handle_sk_slot_alloc(uint32_t info)
 				    sizeof(slot_info));
 
 		if (os_err != OS_ERROR_OK_S) {
-			(void)keystore_slot_dealloc(&system_keystore,slot_info.ownerid,
-					       slot_info.slot);
+			(void)keystore_slot_dealloc(&system_keystore,
+						    slot_info.ownerid,
+						    slot_info.slot);
 		}
 	}
 
 	return os_err;
 }
 
-/*!
- * Deallocate a slot in the SK
- *
- * @brief Deallocate a slot in the SK
- *
- * @param    info   slot information
- *
- * @return   0 if pass; non-zero on error
- */
 static os_error_code sah_handle_sk_slot_dealloc(uint32_t info)
 {
 	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
@@ -1429,9 +1446,11 @@ static os_error_code sah_handle_sk_slot_dealloc(uint32_t info)
 	scc_return_t scc_ret;
 
 	os_err = os_copy_from_user(&slot_info, (void *)info, sizeof(slot_info));
+
 	if (os_err == OS_ERROR_OK_S) {
 		scc_ret = keystore_slot_dealloc(&system_keystore,
-			slot_info.ownerid, slot_info.slot);
+						slot_info.ownerid,
+						slot_info.slot);
 
 		if (scc_ret == SCC_RET_OK) {
 			ret = FSL_RETURN_OK_S;
@@ -1439,6 +1458,7 @@ static os_error_code sah_handle_sk_slot_dealloc(uint32_t info)
 			ret = FSL_RETURN_ERROR_S;
 		}
 		slot_info.code = ret;
+
 		os_err =
 		    os_copy_to_user((void *)info, &slot_info,
 				    sizeof(slot_info));
@@ -1447,15 +1467,6 @@ static os_error_code sah_handle_sk_slot_dealloc(uint32_t info)
 	return os_err;
 }
 
-/*!
- * Populate a slot in the SK
- *
- * @brief Populate a slot in the SK
- *
- * @param    info   slot information
- *
- * @return   0 if pass; non-zero on error
- */
 static os_error_code sah_handle_sk_slot_load(uint32_t info)
 {
 	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
@@ -1470,7 +1481,7 @@ static os_error_code sah_handle_sk_slot_load(uint32_t info)
 		key = os_alloc_memory(slot_info.key_length + 3, GFP_KERNEL);
 		if (key == NULL) {
 			ret = FSL_RETURN_NO_RESOURCE_S;
-			os_err = OS_ERROR_OK_S;
+			os_err = OS_ERROR_NO_MEMORY_S;
 		} else {
 			os_err = os_copy_from_user(key, slot_info.key,
 						   slot_info.key_length);
@@ -1485,8 +1496,73 @@ static os_error_code sah_handle_sk_slot_load(uint32_t info)
 		if ((key_length & 3) != 0) {
 			key_length += 4 - (key_length & 3);
 		}
-		ret = keystore_load_slot(&system_keystore, slot_info.ownerid,
-			slot_info.slot, key, key_length);
+		ret = keystore_slot_load(&system_keystore,
+					 slot_info.ownerid, slot_info.slot, key,
+					 key_length);
+
+		slot_info.code = ret;
+		os_err =
+		    os_copy_to_user((void *)info, &slot_info,
+				    sizeof(slot_info));
+	}
+
+	if (key != NULL) {
+		memset(key, 0, slot_info.key_length);
+		os_free_memory(key);
+	}
+
+	return os_err;
+}
+
+static os_error_code sah_handle_sk_slot_read(uint32_t info)
+{
+	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
+	scc_slot_t slot_info;
+	os_error_code os_err;
+	uint8_t *key = NULL;
+
+	os_err = os_copy_from_user(&slot_info, (void *)info, sizeof(slot_info));
+
+	if (os_err == OS_ERROR_OK_S) {
+
+		/* This operation is not allowed for user keys */
+		slot_info.code = FSL_RETURN_NO_RESOURCE_S;
+		os_err =
+		    os_copy_to_user((void *)info, &slot_info,
+				    sizeof(slot_info));
+
+		return os_err;
+	}
+
+	if (os_err == OS_ERROR_OK_S) {
+		/* Allow slop in alloc in case we are rounding up to word multiple */
+		key = os_alloc_memory(slot_info.key_length + 3, GFP_KERNEL);
+		if (key == NULL) {
+			ret = FSL_RETURN_NO_RESOURCE_S;
+			os_err = OS_ERROR_NO_MEMORY_S;
+		}
+	}
+
+	if (os_err == OS_ERROR_OK_S) {
+		unsigned key_length = slot_info.key_length;
+
+		/* @bug Do some PERMISSIONS checking - make sure this is SW key */
+
+		/* Round up if necessary, as SCC call wants a multiple of 32-bit
+		 * values for the full object being loaded. */
+		if ((key_length & 3) != 0) {
+			key_length += 4 - (key_length & 3);
+		}
+		ret = keystore_slot_read(&system_keystore,
+					 slot_info.ownerid, slot_info.slot,
+					 key_length, key);
+
+		/* @bug do some error checking */
+
+		/* Send key back to user */
+		os_err = os_copy_to_user(slot_info.key, key,
+					 slot_info.key_length);
+
 		slot_info.code = ret;
 		os_err =
 		    os_copy_to_user((void *)info, &slot_info,
@@ -1501,15 +1577,6 @@ static os_error_code sah_handle_sk_slot_load(uint32_t info)
 	return os_err;
 }
 
-/*!
- * Encrypt data into a slot in the SCC
- *
- * @brief Encrypt data into a slot in the SCC
- *
- * @param    info   user-space ptr to slot and data information
- *
- * @return   0 if pass; non-zero on error
- */
 static os_error_code sah_handle_sk_slot_encrypt(uint32_t info)
 {
 	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
@@ -1527,26 +1594,31 @@ static os_error_code sah_handle_sk_slot_encrypt(uint32_t info)
 		}
 	}
 
-	if (key != NULL)
-	{
+	if (key != NULL) {
+
 		scc_ret = keystore_slot_encrypt(NULL, &system_keystore,
-			slot_info.ownerid, slot_info.slot,
-			slot_info.key_length, key);
+						slot_info.ownerid,
+						slot_info.slot,
+						slot_info.key_length, key);
+
 		if (scc_ret != SCC_RET_OK) {
 			ret = FSL_RETURN_ERROR_S;
+		} else {
+			os_err =
+			    os_copy_to_user(slot_info.key, key,
+					    slot_info.key_length);
+			if (os_err != OS_ERROR_OK_S) {
+				ret = FSL_RETURN_INTERNAL_ERROR_S;
+			} else {
+				ret = FSL_RETURN_OK_S;
+			}
 		}
-		else {
-		  os_err = os_copy_to_user(slot_info.key, key, slot_info.key_length);
-		  if (os_err != OS_ERROR_OK_S)
-		      ret = FSL_RETURN_INTERNAL_ERROR_S;
-		  else
-		      ret = FSL_RETURN_OK_S;
-		  
-	    }
+
 		slot_info.code = ret;
 		os_err =
 		    os_copy_to_user((void *)info, &slot_info,
 				    sizeof(slot_info));
+
 		memset(key, 0, slot_info.key_length);
 		os_free_memory(key);
 	}
@@ -1554,19 +1626,10 @@ static os_error_code sah_handle_sk_slot_encrypt(uint32_t info)
 	return os_err;
 }
 
-/*!
- * Decrypt data in a slot in the SCC
- *
- * @brief Decrypt data in a slot in the SCC
- *
- * @param    info   slot data and target location information
- *
- * @return   0 if pass; non-zero on error
- */
 static os_error_code sah_handle_sk_slot_decrypt(uint32_t info)
 {
 	fsl_shw_return_t ret = FSL_RETURN_INTERNAL_ERROR_S;
-	scc_slot_t slot_info; /*!< decrypt request fields */
+	scc_slot_t slot_info;	/*!< decrypt request fields */
 	os_error_code os_err;
 	scc_return_t scc_ret;
 	uint8_t *key = NULL;
@@ -1578,27 +1641,29 @@ static os_error_code sah_handle_sk_slot_decrypt(uint32_t info)
 		if (key == NULL) {
 			ret = FSL_RETURN_NO_RESOURCE_S;
 			os_err = OS_ERROR_OK_S;
-        } else {
-            os_err = os_copy_from_user(key, slot_info.key,
-                                       slot_info.key_length);
+		} else {
+			os_err = os_copy_from_user(key, slot_info.key,
+						   slot_info.key_length);
 		}
 	}
 
 	if (os_err == OS_ERROR_OK_S) {
-			scc_ret = keystore_slot_decrypt(NULL, &system_keystore,
-				slot_info.ownerid, slot_info.slot,
-				slot_info.key_length, key);
-
-		if (scc_ret == SCC_RET_OK)
+		scc_ret = keystore_slot_decrypt(NULL, &system_keystore,
+						slot_info.ownerid,
+						slot_info.slot,
+						slot_info.key_length, key);
+		if (scc_ret == SCC_RET_OK) {
 			ret = FSL_RETURN_OK_S;
-		else
+		} else {
 			ret = FSL_RETURN_ERROR_S;
+		}
 
 		slot_info.code = ret;
 		os_err =
 		    os_copy_to_user((void *)info, &slot_info,
 				    sizeof(slot_info));
 	}
+
 	if (key != NULL) {
 		memset(key, 0, slot_info.key_length);
 		os_free_memory(key);
@@ -1640,8 +1705,6 @@ fsl_shw_return_t sah_handle_registration(fsl_shw_uco_t * user_ctx)
  */
 fsl_shw_return_t sah_handle_deregistration(fsl_shw_uco_t * user_ctx)
 {
-
-	
 	/* NOTE:
 	 * This will release any secure partitions that are held by the user.
 	 * Encryption keys that were placed in the system keystore by the user
@@ -1650,57 +1713,59 @@ fsl_shw_return_t sah_handle_deregistration(fsl_shw_uco_t * user_ctx)
 	 * longer in use.
 	 */
 	fsl_shw_return_t ret = FSL_RETURN_OK_S;
-	
 
 #ifdef FSL_HAVE_SCC2
-	fsl_shw_spo_t* partition;
+	fsl_shw_spo_t *partition;
 	struct mm_struct *mm = current->mm;
-	
-	while((user_ctx->partition != NULL) && (ret == FSL_RETURN_OK_S)) {
-	
+
+	while ((user_ctx->partition != NULL) && (ret == FSL_RETURN_OK_S)) {
+
 		partition = user_ctx->partition;
-	
+
 #ifdef DIAG_DRV_IF
-		LOG_KDIAG_ARGS("Found an abandoned secure partition at %p, releasing",
-					   partition);
+		LOG_KDIAG_ARGS
+		    ("Found an abandoned secure partition at %p, releasing",
+		     partition);
 #endif
-	
-			/* It appears that current->mm is not valid if this is called from a
-			 * close routine (perhaps only if the program raised an exception that
-			 * caused it to close?)  If that is the case, then still free the 
-			 * partition, but do not remove it from the memory space (dangerous?)
-			 */
-			
-			if (mm == NULL) {
+
+		/* It appears that current->mm is not valid if this is called from a
+		 * close routine (perhaps only if the program raised an exception that
+		 * caused it to close?)  If that is the case, then still free the 
+		 * partition, but do not remove it from the memory space (dangerous?)
+		 */
+
+		if (mm == NULL) {
 #ifdef DIAG_DRV_IF
-				LOG_KDIAG("Warning: no mm structure found, not unmapping "
-						  "partition from user memory\n");
+			LOG_KDIAG
+			    ("Warning: no mm structure found, not unmapping "
+			     "partition from user memory\n");
 #endif
-			} else {
-				/* Unmap the memory region (see sys_munmap in mmap.c) */
-				/* Note that this assumes a single memory partition */
-				unmap_user_memory(partition->user_base, 8192);
-			 }
-	
-			/* If the memory was successfully released */
-			if (ret == OS_ERROR_OK_S) {
-				/* release the partition */
-				scc_release_partition(partition->kernel_base);
-	
-				/* and remove it from the users context */
-				deregister_user_partition(user_ctx, partition->user_base);
-	
-				ret = FSL_RETURN_OK_S;
-			} else {
-				ret = FSL_RETURN_ERROR_S;
-	
-				goto out;
-			}
+		} else {
+			/* Unmap the memory region (see sys_munmap in mmap.c) */
+			/* Note that this assumes a single memory partition */
+			unmap_user_memory(partition->user_base, 8192);
 		}
-		out:
-#endif /* FSL_HAVE_SCC2 */
-	
-		return ret;
+
+		/* If the memory was successfully released */
+		if (ret == OS_ERROR_OK_S) {
+			/* release the partition */
+			scc_release_partition(partition->kernel_base);
+
+			/* and remove it from the users context */
+			deregister_user_partition(user_ctx,
+						  partition->user_base);
+
+			ret = FSL_RETURN_OK_S;
+		} else {
+			ret = FSL_RETURN_ERROR_S;
+
+			goto out;
+		}
+	}
+      out:
+#endif				/* FSL_HAVE_SCC2 */
+
+	return ret;
 }
 
 /*!
@@ -1860,8 +1925,9 @@ static int handle_sah_ioctl_dar(fsl_shw_uco_t * user_ctx,
 	/* This will re-create the linked list so that the SAHARA hardware can
 	 * DMA on it.
 	 */
-	desc_chain_head =
-	    sah_Copy_Descriptors(user_ctx,(sah_Head_Desc *) user_space_desc);
+	desc_chain_head = sah_Copy_Descriptors(user_ctx,
+					       (sah_Head_Desc *)
+					       user_space_desc);
 
 	if (desc_chain_head == NULL) {
 		/* We may have failed due to a -EFAULT as well, but we will return
diff --git a/drivers/mxc/security/scc2_driver.c b/drivers/mxc/security/scc2_driver.c
index dc62011..3821a90 100644
--- a/drivers/mxc/security/scc2_driver.c
+++ b/drivers/mxc/security/scc2_driver.c
@@ -13,16 +13,17 @@
 
 /*! @file scc2_driver.c
  *
- * This is the driver code for the Security Controller (SCC).  It has no device
- * driver interface, so no user programs may access it.  Its interaction with
- * the Linux kernel is from calls to #scc_init() when the driver is loaded, and
- * #scc_cleanup() should the driver be unloaded.  The driver uses locking and
- * (task-sleep/task-wakeup) functions of the kernel.  It also registers itself
- * to handle the interrupt line(s) from the SCC.
- *
- * Other drivers in the kernel may use the remaining API functions to get at
- * the services of the SCC.  The main service provided is the Secure Memory,
- * which allows encoding and decoding of secrets with a per-chip secret key.
+ * This is the driver code for the Security Controller version 2 (SCC2).  It's
+ * interaction with the Linux kernel is from calls to #scc_init() when the
+ * driver is loaded, and #scc_cleanup() should the driver be unloaded.  The
+ * driver uses locking and (task-sleep/task-wakeup) functions from the kernel.
+ * It also registers itself to handle the interrupt line(s) from the SCC.  New
+ * to this version of the driver is an interface providing access to the secure
+ * partitions.  This is in turn exposed to the API user through the
+ * fsl_shw_smalloc() series of functions.  Other drivers in the kernel may use
+ * the remaining API functions to get at the services of the SCC.  The main
+ * service provided is the Secure Memory, which allows encoding and decoding of
+ * secrets with a per-chip secret key.
  *
  * The SCC is single-threaded, and so is this module.  When the scc_crypt()
  * routine is called, it will lock out other accesses to the function.  If
@@ -33,14 +34,12 @@
  * preventing other kernel work (other than interrupt processing) to get done.
  *
  * The external (kernel module) interface is through the following functions:
- * @li scc_get_configuration()
- * @li scc_crypt()
- * @li scc_zeroize_memories()
- * @li scc_monitor_security_failure()
- * @li scc_stop_monitoring_security_failure()
- * @li scc_set_sw_alarm()
- * @li scc_read_register()
- * @li scc_write_register()
+ * @li scc_get_configuration() @li scc_crypt() @li scc_zeroize_memories() @li
+ * scc_monitor_security_failure() @li scc_stop_monitoring_security_failure()
+ * @li scc_set_sw_alarm() @li scc_read_register() @li scc_write_register() @li
+ * scc_allocate_partition() @li scc_initialize_partition @li
+ * scc_release_partition() @li scc_diminish_permissions @li
+ * scc_encrypt_region() @li scc_decrypt_region() @li scc_virt_to_phys
  *
  * All other functions are internal to the driver.
  */
@@ -125,7 +124,7 @@ uint32_t scm_memory_size_bytes;
 /** Structure returned by #scc_get_configuration() */
 static scc_config_t scc_configuration = {
 	.driver_major_version = SCC_DRIVER_MAJOR_VERSION,
-	.driver_minor_version = SCC_DRIVER_MINOR_VERSION,
+	.driver_minor_version = SCC_DRIVER_MINOR_VERSION_2,
 	.scm_version = -1,
 	.smn_version = -1,
 	.block_size_bytes = -1,
diff --git a/include/asm-arm/arch-mxc/mxc_scc2_driver.h b/include/asm-arm/arch-mxc/mxc_scc2_driver.h
index 355d329..f8a24f2 100644
--- a/include/asm-arm/arch-mxc/mxc_scc2_driver.h
+++ b/include/asm-arm/arch-mxc/mxc_scc2_driver.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -15,11 +15,6 @@
 #ifndef SCC_DRIVER_H
 #define SCC_DRIVER_H
 
-/* Start marker for C++ compilers */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 /*
  * NAMING CONVENTIONS
  * ==================
@@ -32,13 +27,13 @@ extern "C" {
  * scc_write_register, or values passed/retrieved from those routines.
  */
 
-/*! @file scc_driver.h
+/*! @file mxc_scc2_driver.h
  *
- * @brief (Header file to use the SCC driver.)
+ * @brief (Header file to use the SCC2 driver.)
  *
- * The SCC driver will only be available to other kernel modules.  That is,
- * there will be no node file in /dev, no way for a user-mode program to access
- * the driver, no way for a user program to access the device directly.
+ * The SCC2 driver is available to other kernel modules directly.  Secure
+ * Partition functionality is extended to users through the SHW API.  Other
+ * functionality of the SCC2 is limited to kernel-space users.
  *
  * With the exception of #scc_monitor_security_failure(), all routines are
  * 'synchronous', i.e. they will not return to their caller until the requested
@@ -46,29 +41,24 @@ extern "C" {
  * take quite a while to perform, depending upon the request.
  *
  * Routines are provided to:
- * @li encrypt or decrypt secrets - #scc_crypt()
  * @li trigger a security-violation alarm - #scc_set_sw_alarm()
  * @li get configuration and version information - #scc_get_configuration()
  * @li zeroize memory - #scc_zeroize_memories()
- * @li Work on wrapped and stored secret values: #scc_alloc_slot(),
- *     #scc_dealloc_slot(), scc_load_slot(), #scc_decrypt_slot(),
- *     #scc_encrypt_slot(), #scc_get_slot_info()
-
+ * @li Work with secure partitions: #scc_allocate_partition()
+ *     #scc_engage_partition() #scc_diminish_permissions() 
+ *     #scc_release_partition()
+ * @li Encrypt or decrypt regions of data: #scc_encrypt_region()
+ *     #scc_decrypt_region()
  * @li monitor the Security Failure alarm - #scc_monitor_security_failure()
  * @li stop monitoring Security Failure alarm -
  *     #scc_stop_monitoring_security_failure()
  * @li write registers of the SCC - #scc_write_register()
  * @li read registers of the SCC - #scc_read_register()
  *
- * The driver does not allow "storage" of data in either the Red or Black
- * memories.  Any decrypted secret is returned to the user, and if the user
- * wants to use it at a later point, the encrypted form must again be passed
- * to the driver, and it must be decrypted again.
- *
- * The SCC encrypts and decrypts using Triple DES with an internally stored
- * key.  When the SCC is in Secure mode, it uses its secret, unique-per-chip
+ * The SCC2 encrypts and decrypts using Triple DES with an internally stored
+ * key.  When the SCC2 is in Secure mode, it uses its secret, unique-per-chip
  * key.  When it is in Non-Secure mode, it uses a default key.  This ensures
- * that secrets stay secret if the SCC is not in Secure mode.
+ * that secrets stay secret if the SCC2 is not in Secure mode.
  *
  * Not all functions that could be provided in a 'high level' manner have been
  * implemented.  Among the missing are interfaces to the ASC/AIC components and
@@ -76,7 +66,7 @@ extern "C" {
  * #scc_read_register() and #scc_write_register(), using the @c \#define values
  * provided.
  *
- * Here is a glossary of acronyms used in the SCC driver documentation:
+ * Here is a glossary of acronyms used in the SCC2 driver documentation:
  * - CBC - Cipher Block Chaining.  A method of performing a block cipher.
  *    Each block is encrypted using some part of the result of the previous
  *    block's encryption.  It needs an 'initialization vector' to seed the
@@ -84,13 +74,13 @@ extern "C" {
  * - ECB - Electronic Code Book.  A method of performing a block cipher.
  *    With a given key, a given block will always encrypt to the same value.
  * - DES - Data Encryption Standard.  (8-byte) Block cipher algorithm which
- *    uses 56-bit keys.  In SCC, this key is constant and unique to the device.
+ *    uses 56-bit keys.  In SCC2, this key is constant and unique to the device.
  *    SCC uses the "triple DES" form of this algorithm.
  * - AIC - Algorithm Integrity Checker.
  * - ASC - Algorithm Sequence Checker.
- * - SMN - Security Monitor.  The part of the SCC responsible for monitoring
+ * - SMN - Security Monitor.  The part of the SCC2 responsible for monitoring
  *    for security problems and notifying the CPU and other PISA components.
- * - SCM - Secure Memory.  The part of the SCC which handles the cryptography.
+ * - SCM - Secure Memory.  The part of the SCC2 which handles the cryptography.
  * - SCC - Security Controller.  Central security mechanism for PISA.
  * - PISA - Platform-Independent Security Architecture.
  */
@@ -119,12 +109,15 @@ extern "C" {
 
 #endif				/* DOXYGEN_HACK */
 
-/** Major Version of the driver.  Used for
+/*! Major Version of the driver.  Used for
     scc_configuration->driver_major_version */
 #define SCC_DRIVER_MAJOR_VERSION    2
-/** Minor Version of the driver.  Used for
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_0    0
+/*! Minor Version of the driver.  Used for
     scc_configuration->driver_minor_version */
-#define SCC_DRIVER_MINOR_VERSION    0
+#define SCC_DRIVER_MINOR_VERSION_2    2
+
 
 /*!
  *  Interrupt line number of SCM interrupt.
@@ -320,6 +313,9 @@ extern "C" {
  * Calculate the physical address from the kernel virtual address.
  */
 	extern uint32_t scc_virt_to_phys(void *address);
+/*scc_return_t
+scc_verify_slot_access(uint64_t owner_id, uint32_t slot, uint32_t access_len);*/
+
 
 /**
  * Encrypt a region of secure memory.
@@ -972,8 +968,6 @@ extern "C" {
     (#SMN_COMPARE_REG) */
 #define SMN_COMPARE_SIZE_MASK      0x0000003f
 
-/* Close out marker for C++ compilers */
-#ifdef __cplusplus
-}
-#endif
+/*! @} */
+
 #endif				/* SCC_DRIVER_H */
diff --git a/include/asm-arm/arch-mxc/mxc_scc_driver.h b/include/asm-arm/arch-mxc/mxc_scc_driver.h
index e575f52..5f1e1bb 100644
--- a/include/asm-arm/arch-mxc/mxc_scc_driver.h
+++ b/include/asm-arm/arch-mxc/mxc_scc_driver.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -41,7 +41,7 @@ extern "C" {
 /*!
  * @file arch-mxc/mxc_scc_driver.h
  *
- * @brief Header file to use the SCC driver.
+ * @brief (Header file to use the SCC driver.)
  *
  * The SCC driver will only be available to other kernel modules.  That is,
  * there will be no node file in /dev, no way for a user-mode program to access
@@ -100,9 +100,31 @@ extern "C" {
  * - SCM - Secure Memory.  The part of the SCC which handles the cryptography.
  * - SCC - Security Controller.  Central security mechanism for PISA.
  * - PISA - Platform-Independent Security Architecture.
+ */
+
+/* Temporarily define compile-time flags to make Doxygen happy. */
+#ifdef DOXYGEN_HACK
+/*! @defgroup scccompileflags SCC Driver compile-time flags
+ *
+ * These preprocessor flags should be set, if desired, in a makefile so
+ * that they show up on the compiler command line.
+ */
+/*! @addtogroup scccompileflags */
+
+/*! @{ */
+/*!
+ * Compile-time flag to change @ref smnregs and @ref scmregs
+ * offset values for the SCC's implementation on the MX.21 board.
  *
- * @ingroup MXCSCC
+ * This must also be set properly for any code which calls the
+ * scc_read_register() or scc_write_register() functions or references the
+ * register offsets.
  */
+#define TAHITI
+/*! @} */
+#undef TAHITI
+
+#endif				/* DOXYGEN_HACK */
 
 /*! Major Version of the driver.  Used for
     scc_configuration->driver_major_version */
@@ -113,13 +135,15 @@ extern "C" {
 #define SCC_DRIVER_MINOR_VERSION_4 4
 /*! Old Minor Version of the driver. */
 #define SCC_DRIVER_MINOR_VERSION_5 5
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_6 6
 /*! Minor Version of the driver.  Used for
     scc_configuration->driver_minor_version */
-#define SCC_DRIVER_MINOR_VERSION_6 6
+#define SCC_DRIVER_MINOR_VERSION_8 8
 
 
 /*!
- * @typedef scc_return_t (enum scc_return)
+ * @typedef scc_return_t 
  */
 /*! Common status return values from SCC driver functions. */
 	typedef enum scc_return_t {
@@ -134,10 +158,7 @@ extern "C" {
 	} scc_return_t;
 
 /*!
- * @typedef scc_config_t (struct scc_config)
- **/
-/*!
- * @brief Configuration information about SCC and the driver.
+ * Configuration information about SCC and the driver.
  *
  * This struct/typedef contains information from the SCC and the driver to
  * allow the user of the driver to determine the size of the SCC's memories and
@@ -155,7 +176,7 @@ extern "C" {
 	} scc_config_t;
 
 /*!
- * @typedef scc_enc_dec_t (enum scc_enc_dec)
+ * @typedef scc_enc_dec_t 
  */
 /*!
  * Determine whether SCC will run its cryptographic
@@ -167,8 +188,8 @@ extern "C" {
 		SCC_DECRYPT	/*!< Decrypt (from Black to Red) */
 	} scc_enc_dec_t;
 
-/*!
- * @typedef scc_crypto_mode_t (enum scc_crypto_mode)
+/*
+ * @typedef scc_crypto_mode_t 
  */
 /*!
  * Determine whether SCC will run its cryptographic function in ECB (electronic
@@ -181,7 +202,7 @@ extern "C" {
 	} scc_crypto_mode_t;
 
 /*!
- * @typedef scc_verify_t (enum scc_verify)
+ * @typedef scc_verify_t 
  */
 /*!
  * Tell the driver whether it is responsible for verifying the integrity of a
@@ -301,25 +322,27 @@ extern "C" {
  * #scc_encrypt or #scc_decrypt routine will be called to do the actual work.
  * The crypto lock will then be released.
  */
-	extern scc_return_t scc_crypt(unsigned long count_in_bytes,
-				      uint8_t * data_in, uint8_t * init_vector,
+extern scc_return_t scc_crypt(unsigned long count_in_bytes,
+				      const uint8_t * data_in,
+				      const uint8_t * init_vector,
 				      scc_enc_dec_t direction,
 				      scc_crypto_mode_t crypto_mode,
 				      scc_verify_t check_mode,
 				      uint8_t * data_out,
 				      unsigned long *count_out_bytes);
 
+
 /*!
  * Allocate a key slot for a stored key (or other stored value).
  *
- * This feature is to allow decrypted secret values to be kept in RED RAM.  This
- * can all visibility of the data only by Sahara.
+ * This feature is to allow decrypted secret values to be kept in RED RAM.
+ * This can all visibility of the data only by Sahara.
  *
  * @param   value_size_bytes  Size, in bytes, of RED key/value.  Currently only
  *                            a size up to 32 bytes is supported.
  *
- * @param      owner_id       A value which will control access to the slot.  It
- *                            must be passed into to any subsequent calls to
+ * @param      owner_id       A value which will control access to the slot.
+ *                            It must be passed into to any subsequent calls to
  *                            use the assigned slot.
  *
  * @param[out] slot           The slot number for the key.
@@ -353,8 +376,23 @@ extern "C" {
  * if @c key_length exceeds the size of the slot.
  */
 	extern scc_return_t scc_load_slot(uint64_t owner_id, uint32_t slot,
-					  uint8_t * key_data,
+					  const uint8_t * key_data,
 					  uint32_t key_length);
+/*!
+ * Read a value from a slot.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param key_length    Length, in bytes, of @c key_data to copy from SCC.
+ * @param key_data      Location to write the key
+ *
+ * @return SCC_RET_OK on success.  SCC_RET_FAIL will be returned if slot
+ * specified cannot be accessed for any reason, or SCC_RET_INSUFFICIENT_SPACE
+ * if @c key_length exceeds the size of the slot.
+ */
+	extern scc_return_t scc_read_slot(uint64_t owner_id, uint32_t slot,
+					  uint32_t key_length,
+					  uint8_t * key_data);
 
 /*!
  * Allocate a key slot to fit the requested size.
@@ -474,11 +512,6 @@ extern "C" {
 	extern scc_return_t scc_read_register(int register_offset,
 					      uint32_t * value);
 
-/* Make Partition for VPU in Secure RAM */
-        extern uint8_t make_vpu_partition(void);
-
-
-
 /*!
  * Write a new value into an SCC register.
  * The offset will be checked for validity (range) as well as whether it is
@@ -581,7 +614,7 @@ extern "C" {
  * information.
  */
 
-/** @def SMN_COMMAND
+/*! @def SMN_COMMAND
  * Command register for SMN. See
  * @ref smncommandregdefs "Command Register Definitions" for further
  * information.
@@ -685,6 +718,7 @@ extern "C" {
 /*!
  * @defgroup smnstatusregdefs SMN Status Register definitions (SMN_STATUS)
  */
+/*! @addtogroup smnstatusregdefs */
 /*! @{ */
 /*! SMN version id. */
 #define SMN_STATUS_VERSION_ID_MASK        0xfc000000
@@ -787,8 +821,9 @@ extern "C" {
  */
 /*! @addtogroup smncommandregdefs */
 /*! @{ */
-#define SMN_COMMAND_ZEROS_MASK   0xfffffff0	/*!< These bits are unimplemented
+#define SMN_COMMAND_ZEROS_MASK   0xffffff70	/*!< These bits are unimplemented
 						   or reserved */
+#define SMN_COMMAND_TAMPER_LOCK         0x10 /*!< Lock Tamper Detect Bit */
 #define SMN_COMMAND_CLEAR_INTERRUPT     0x8	/*!< Clear SMN Interrupt */
 #define SMN_COMMAND_CLEAR_BIT_BANK      0x4	/*!< Clear SMN Bit Bank */
 #define SMN_COMMAND_ENABLE_INTERRUPT    0x2	/*!< Enable SMN Interrupts */
@@ -815,6 +850,7 @@ extern "C" {
  *
  * These are the bit definitions for the #SCM_INTERRUPT_CTRL register.
  */
+/*! @addtogroup scminterruptcontroldefs */ 
 /*! @{ */
 /*! Clear SCM memory */
 #define SCM_INTERRUPT_CTRL_ZEROIZE_MEMORY      0x4
@@ -825,26 +861,28 @@ extern "C" {
 /*! @} */
 
 /*!
- * @name SCM Control Register definitions (SCM_CONTROL).
+ * @defgroup scmcontrolregdefs SCM Control Register definitions (SCM_CONTROL).
  * These values are used with the #SCM_CONTROL register.
  */
+/*! @addtogroup scmcontrolregdefs */
 /*! @{ */
 /*! These bits are zero or reserved */
 #define SCM_CONTROL_ZEROS_MASK    0xfffffff8
 /*! Setting this will start encrypt/decrypt */
 #define SCM_CONTROL_START_CIPHER        0x04
 /*! CBC/ECB flag.
- * See "Chaining Mode bit definitions."
+ * See @ref scmchainmodedefs "Chaining Mode bit definitions."
  */
 #define SCM_CONTROL_CHAINING_MODE_MASK  0x02
 /*! Encrypt/decrypt choice.
- * See "Cipher Mode bit definitions." */
+ * See @ref scmciphermodedefs "Cipher Mode bit definitions." */
 #define SCM_CONTROL_CIPHER_MODE_MASK    0x01
 /*! @} */
 
 /*!
- * @name SCM_CHAINING_MODE_MASK - Bit definitions
+ * @defgroup scmchainmodedefs  SCM_CHAINING_MODE_MASK - Bit definitions
  */
+/*! @addtogroup scmchainmodedefs */
 /*! @{ */
 #define SCM_CBC_MODE            0x2	/*!< Cipher block chaining */
 #define SCM_ECB_MODE            0x0	/*!< Electronic codebook. */
@@ -852,7 +890,7 @@ extern "C" {
 
 /* Bit definitions in the SCM_CIPHER_MODE_MASK */
 /*!
- * @name SCM_CIPHER_MODE_MASK - Bit definitions
+ * @defgroup scmciphermodedefs SCM_CIPHER_MODE_MASK - Bit definitions
  */
 /*! @{ */
 #define SCM_DECRYPT_MODE        0x1	/*!< decrypt from black to red memory */
@@ -860,9 +898,10 @@ extern "C" {
 /*! @} */
 
 /*!
- * @name SCM Status Register (SCM_STATUS).
+ * @defgroup scmstatusregdefs  SCM Status Register (SCM_STATUS).
  * Bit and field definitions of the SCM_STATUS register.
  */
+/*! @addtogroup scmstatusregdefs */
 /*! @{ */
 /*! These bits are zero or reserved */
 #define SCM_STATUS_ZEROS_MASK        0xffffe000
@@ -897,11 +936,12 @@ extern "C" {
 /*! @} */
 
 /*!
- * @name SCM Error Status Register (SCM_ERROR_STATUS)
+ * @defgroup scmerrstatdefs SCM Error Status Register (SCM_ERROR_STATUS)
  *
  * These definitions are associated with the SCM Error Status Register
  * (SCM_ERROR_STATUS).
  */
+/*! @addtogroup scmerrstatdefs */
 /*! @{ */
 /*! These bits are zero or reserved */
 #define SCM_ERR_ZEROS_MASK      0xffffc000
@@ -936,8 +976,10 @@ extern "C" {
 /*! @} */
 
 /*!
- * @name SMN Debug Detector Status Register (SCM_DEBUG_DETECT_STAT)
+ * @defgroup smndbgdetdefs SMN Debug Detector Status Register
+ * (SCM_DEBUG_DETECT_STAT)
  */
+/*! @addtogroup smndbgdetdefs */
 /*! @{ */
 #define SMN_DBG_ZEROS_MASK  0xfffff000	/*!< These bits are zero or reserved */
 #define SMN_DBG_D12             0x0800	/*!< Error detected on Debug Port D12 */
-- 
1.5.4.4

