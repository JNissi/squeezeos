From 84173434b84f78b18fb5d46271bcc3a6805a9219 Mon Sep 17 00:00:00 2001
From: Ross Wille <wille@freescale.com>
Date: Thu, 18 Sep 2008 15:26:24 -0600
Subject: [PATCH] ENGR00093036-2 MX25-3DS: Add base functionality

Add pin defs, mux and pad ctl regs
Add memory map
Add basic clock driver
Add basic UART driver for console
Add basic interrupt support
Add hardware timer support
Add system timer support
Add GPIO pin config for UART, FEC, KPP, SPI, etc.

Boots to shell prompt with imx25_3stack_defconfig

Signed-off-by: Ross Wille <wille@freescale.com>
---
 arch/arm/configs/imx25_3stack_defconfig | 1295 ++++++++++++++++++++++++
 arch/arm/mach-mx25/Kconfig              |   55 +
 arch/arm/mach-mx25/Makefile             |   10 +
 arch/arm/mach-mx25/Makefile.boot        |    3 +
 arch/arm/mach-mx25/board-mx25_3stack.h  |  158 +++
 arch/arm/mach-mx25/clock.c              | 1667 +++++++++++++++++++++++++++++++
 arch/arm/mach-mx25/cpu.c                |   34 +
 arch/arm/mach-mx25/crm_regs.h           |  190 ++++
 arch/arm/mach-mx25/devices.c            |  329 ++++++
 arch/arm/mach-mx25/dma.c                |  162 +++
 arch/arm/mach-mx25/iomux.c              |  213 ++++
 arch/arm/mach-mx25/iomux.h              |  222 ++++
 arch/arm/mach-mx25/mm.c                 |   77 ++
 arch/arm/mach-mx25/mx25_3stack.c        |  235 +++++
 arch/arm/mach-mx25/mx25_3stack_cpld.c   |  226 +++++
 arch/arm/mach-mx25/mx25_3stack_gpio.c   | 1397 ++++++++++++++++++++++++++
 arch/arm/mach-mx25/mx25_pins.h          |  250 +++++
 arch/arm/mach-mx25/serial.c             |  173 ++++
 arch/arm/mach-mx25/serial.h             |  132 +++
 arch/arm/mach-mx25/system.c             |   58 ++
 arch/arm/plat-mxc/Kconfig               |    8 +
 include/asm-arm/arch-mxc/mx25.h         |  413 ++++++++
 22 files changed, 7307 insertions(+), 0 deletions(-)

diff --git a/arch/arm/configs/imx25_3stack_defconfig b/arch/arm/configs/imx25_3stack_defconfig
new file mode 100644
index 0000000..3c5e455
--- /dev/null
+++ b/arch/arm/configs/imx25_3stack_defconfig
@@ -0,0 +1,1295 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.26
+# Thu Oct  2 16:41:46 2008
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_AOUT=y
+CONFIG_ZONE_DMA=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+# CONFIG_MARKERS is not set
+CONFIG_OPROFILE=y
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+# CONFIG_HAVE_DMA_ATTRS is not set
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_CLASSIC_RCU=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM7X00A is not set
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# Freescale MXC Implementations
+#
+# CONFIG_ARCH_MX37 is not set
+# CONFIG_ARCH_MX35 is not set
+# CONFIG_ARCH_MX51 is not set
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_ARCH_MX27 is not set
+CONFIG_ARCH_MX25=y
+# CONFIG_ARCH_MX21 is not set
+
+#
+# MX25 Options
+#
+CONFIG_MX25_OPTIONS=y
+CONFIG_MACH_MX25_3DS=y
+# CONFIG_MX25_DOZE_DURING_IDLE is not set
+# CONFIG_MXC_SDMA_API is not set
+
+#
+# Device options
+#
+CONFIG_DMA_ZONE_SIZE=24
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+# CONFIG_CPU_V6 is not set
+# CONFIG_CPU_V7 is not set
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="noinitrd console=ttymxc0 root=/dev/mtdblock2 rw ip=off"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+CONFIG_IRDA=m
+
+#
+# IrDA protocols
+#
+CONFIG_IRLAN=m
+CONFIG_IRNET=m
+CONFIG_IRCOMM=m
+# CONFIG_IRDA_ULTRA is not set
+
+#
+# IrDA options
+#
+CONFIG_IRDA_CACHE_LAST_LSAP=y
+CONFIG_IRDA_FAST_RR=y
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+
+#
+# SIR device drivers
+#
+CONFIG_IRTTY_SIR=m
+
+#
+# Dongle support
+#
+# CONFIG_DONGLE is not set
+
+#
+# FIR device drivers
+#
+# CONFIG_MXC_FIR is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+# CONFIG_IEEE80211_CRYPT_WEP is not set
+# CONFIG_IEEE80211_CRYPT_CCMP is not set
+# CONFIG_IEEE80211_CRYPT_TKIP is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+CONFIG_MTD_RAM=y
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+# CONFIG_MTD_MXC is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=m
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=m
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+
+#
+# Voltage and Current regulators
+#
+# CONFIG_REGULATOR is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_SMC911X is not set
+CONFIG_SMSC911X=y
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_B44 is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=m
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_MXC is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_UCB1400 is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXC=y
+CONFIG_SERIAL_MXC_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+# CONFIG_I2C_SLAVE is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_MXC=y
+# CONFIG_SPI_MXC_TEST_LOOPBACK is not set
+CONFIG_SPI_MXC_SELECT1=y
+# CONFIG_SPI_MXC_SELECT2 is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_MXC_WATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_PASIC3 is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_MXC_CAMERA is not set
+# CONFIG_VIDEO_MXC_OUTPUT is not set
+# CONFIG_VIDEO_MXC_OPL is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_RADIO_ADAPTERS=y
+CONFIG_DAB=y
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_CORGI is not set
+# CONFIG_BACKLIGHT_MXC is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+# CONFIG_SND_MXC_SPDIF is not set
+
+#
+# SPI devices
+#
+
+#
+# System on Chip audio support
+#
+# CONFIG_SND_SOC is not set
+# CONFIG_SND_MXC_SOC is not set
+# CONFIG_SND_MXC_SOC_IRAM is not set
+# CONFIG_SND_SOC_IMX_3STACK_WM8350 is not set
+# CONFIG_SND_SOC_IMX_3STACK_AK4647 is not set
+# CONFIG_SND_SOC_IMX_3STACK_WM8580 is not set
+# CONFIG_SND_SOC_IMX_3STACK_WM8903 is not set
+
+#
+# ALSA SoC audio for Freescale SOCs
+#
+
+#
+# SoC Audio for the Texas Instruments OMAP
+#
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD Host Controller Drivers
+#
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_MXC is not set
+# CONFIG_MMC_IMX_ESDHCI is not set
+# CONFIG_MMC_IMX_ESDHCI_PIO_MODE is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_MXC is not set
+# CONFIG_RTC_DRV_MXC_V2 is not set
+# CONFIG_UIO is not set
+
+#
+# MXC support drivers
+#
+# CONFIG_MXC_IPU is not set
+
+#
+# MXC SSI support
+#
+# CONFIG_MXC_SSI is not set
+
+#
+# MXC Digital Audio Multiplexer support
+#
+# CONFIG_MXC_DAM is not set
+
+#
+# MXC PMIC support
+#
+# CONFIG_MXC_PMIC_MC13783 is not set
+
+#
+# Advanced Power Management devices
+#
+
+#
+# MXC Security Drivers
+#
+# CONFIG_MXC_SECURITY_SCC is not set
+# CONFIG_MXC_SECURITY_RNG is not set
+
+#
+# MXC MPEG4 Encoder Kernel module support
+#
+# CONFIG_MXC_HMP4E is not set
+
+#
+# MXC HARDWARE EVENT
+#
+# CONFIG_MXC_HWEVENT is not set
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+
+#
+# MXC Asynchronous Sample Rate Converter support
+#
+
+#
+# MXC Bluetooth support
+#
+
+#
+# Broadcom GPS ioctrl support
+#
+
+#
+# MXC Media Local Bus Driver
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_BIND34 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_SAMPLES is not set
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_GENERIC_FIND_FIRST_BIT is not set
+# CONFIG_GENERIC_FIND_NEXT_BIT is not set
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/mach-mx25/Kconfig b/arch/arm/mach-mx25/Kconfig
new file mode 100644
index 0000000..bfea884
--- /dev/null
+++ b/arch/arm/mach-mx25/Kconfig
@@ -0,0 +1,55 @@
+menu "MX25 Options"
+	depends on ARCH_MX25
+
+config MX25_OPTIONS
+	bool
+	default y
+	select CPU_ARM926T
+
+config MACH_MX25_3DS
+	bool "Support MX25 3STACK platforms"
+	default y
+	help
+	  Include support for MX25 3STACK platform. This includes specific
+	  configurations for the board and its peripherals.
+
+config MX25_DOZE_DURING_IDLE
+	bool "Enter Doze mode during idle"
+	help
+	  Turning on this option will put the CPU into Doze mode during idle.
+	  The default is to enter Wait mode during idle. Doze mode during
+	  idle will save additional power over Wait mode.
+
+config MXC_SDMA_API
+        bool "Use SDMA API"
+        default y
+        help
+           This selects the Freescale MXC SDMA API.
+           If unsure, say N.
+
+menu "Device options"
+
+config I2C_MXC_SELECT1
+	bool "Enable I2C1 module"
+	default y
+	depends on I2C_MXC
+	help
+	  Enable MX25 I2C1 module.
+
+config I2C_MXC_SELECT2
+	bool "Enable I2C2 module"
+	default n
+	depends on I2C_MXC
+	help
+	  Enable MX25 I2C2 module.
+
+config I2C_MXC_SELECT3
+	bool "Enable I2C3 module"
+	default n
+	depends on I2C_MXC
+	help
+	  Enable MX25 I2C3 module.
+
+endmenu
+
+endmenu
diff --git a/arch/arm/mach-mx25/Makefile b/arch/arm/mach-mx25/Makefile
new file mode 100644
index 0000000..fad1e76
--- /dev/null
+++ b/arch/arm/mach-mx25/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		:= system.o iomux.o cpu.o mm.o clock.o devices.o serial.o
+obj-$(CONFIG_MXC_SDMA_API) 	+= dma.o
+obj-$(CONFIG_SPI_MXC)		+= mx25_3stack_cpld.o
+obj-$(CONFIG_MACH_MX25_3DS)	+= mx25_3stack.o mx25_3stack_gpio.o
diff --git a/arch/arm/mach-mx25/Makefile.boot b/arch/arm/mach-mx25/Makefile.boot
new file mode 100644
index 0000000..e1dd366
--- /dev/null
+++ b/arch/arm/mach-mx25/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x80008000
+params_phys-y	:= 0x80000100
+initrd_phys-y	:= 0x80800000
diff --git a/arch/arm/mach-mx25/board-mx25_3stack.h b/arch/arm/mach-mx25/board-mx25_3stack.h
new file mode 100644
index 0000000..77f3a72
--- /dev/null
+++ b/arch/arm/mach-mx25/board-mx25_3stack.h
@@ -0,0 +1,158 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__
+#define __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__
+
+#ifdef CONFIG_MACH_MX25_3DS
+
+/*!
+ * @defgroup BRDCFG_MX25 Board Configuration Options
+ * @ingroup MSL_MX25
+ */
+
+/*!
+ * @file mach-mx25/board-mx25_3stack.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX25 3STACK Platform.
+ *
+ * @ingroup BRDCFG_MX25
+ */
+
+/*
+ * Include Files
+ */
+#include <asm/arch/mxc_uart.h>
+
+/*!
+ * @name MXC UART board-level configurations
+ */
+/*! @{ */
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE              MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR                NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED           1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE              MODE_DCE
+#define UART2_IR                NO_IRDA
+#define UART2_ENABLED           0
+
+/* UART 3 configuration */
+#define UART3_MODE              MODE_DTE
+#define UART3_IR                NO_IRDA
+#define UART3_ENABLED           0
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+/*!
+ * @name debug board parameters
+ */
+/*! @{ */
+/*!
+ * Base address of debug board
+ */
+#define DEBUG_BASE_ADDRESS      0x78000000	/* Use a dummy base address */
+
+/* External ethernet LAN9217 base address */
+#define LAN9217_BASE_ADDR       DEBUG_BASE_ADDRESS
+
+/* External UART */
+#define UARTA_BASE_ADDR     	(DEBUG_BASE_ADDRESS + 0x08000)
+#define UARTB_BASE_ADDR     	(DEBUG_BASE_ADDRESS + 0x10000)
+
+#define BOARD_IO_ADDR		0x20000
+
+/* LED switchs */
+#define LED_SWITCH_REG        	(BOARD_IO_ADDR + 0x00)
+/* buttons */
+#define SWITCH_BUTTON_REG     	(BOARD_IO_ADDR + 0x08)
+/* status, interrupt */
+#define INTR_STATUS_REG       	(BOARD_IO_ADDR + 0x10)
+#define INTR_RESET_REG        	(BOARD_IO_ADDR + 0x20)
+/*CPLD configuration*/
+#define CONFIG1_REG           	(BOARD_IO_ADDR + 0x28)
+#define CONFIG2_REG           	(BOARD_IO_ADDR + 0x30)
+/*interrupt mask */
+#define INTR_MASK_REG        	(BOARD_IO_ADDR + 0x38)
+
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER1_REG     	(BOARD_IO_ADDR + 0x40)
+#define	MAGIC_NUMBER2_REG     	(BOARD_IO_ADDR + 0x48)
+/* CPLD code version */
+#define CPLD_CODE_VER_REG       (BOARD_IO_ADDR + 0x50)
+/* magic word for debug CPLD */
+#define MAGIC3_NUMBER3_REG     	(BOARD_IO_ADDR + 0x58)
+/* module reset register*/
+#define CONTROL_REG      	(BOARD_IO_ADDR + 0x60)
+/* CPU ID and Personality ID*/
+#define IDENT_REG         	(BOARD_IO_ADDR + 0x68)
+
+/* For interrupts like xuart, enet etc */
+#define EXPIO_PARENT_INT        MX25_PIN_GPIO1_1
+
+#define EXPIO_INT_ENET_INT          (MXC_EXP_IO_BASE + 0)
+#define EXPIO_INT_XUARTA_INT        (MXC_EXP_IO_BASE + 1)
+#define EXPIO_INT_XUARTB_INT        (MXC_EXP_IO_BASE + 2)
+
+/*! This is System IRQ used by LAN9217 for interrupt generation taken
+ * from platform.h
+ */
+#define LAN9217_IRQ              EXPIO_INT_ENET_INT
+
+/*! This is base virtual address of debug board*/
+extern unsigned int mx25_3stack_board_io;
+
+#define MXC_BD_LED1             (1 << 0)
+#define MXC_BD_LED2             (1 << 1)
+#define MXC_BD_LED3             (1 << 2)
+#define MXC_BD_LED4             (1 << 3)
+#define MXC_BD_LED5             (1 << 4)
+#define MXC_BD_LED6             (1 << 5)
+#define MXC_BD_LED7             (1 << 6)
+#define MXC_BD_LED8             (1 << 7)
+#define MXC_BD_LED_ON(led)
+#define MXC_BD_LED_OFF(led)
+
+/*! @} */
+
+extern void mxc_map_io(void);
+extern void mxc_init_irq(void);
+extern void mxc_cpu_init(void) __init;
+extern void mx25_3stack_gpio_init(void) __init;
+extern struct sys_timer mxc_timer;
+extern void mxc_cpu_common_init(void);
+extern int mxc_clocks_init(void);
+extern void __init early_console_setup(char *);
+
+#endif				/* CONFIG_MACH_MX25_3DS */
+#endif				/* __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__ */
diff --git a/arch/arm/mach-mx25/clock.c b/arch/arm/mach-mx25/clock.c
new file mode 100644
index 0000000..34b43ee
--- /dev/null
+++ b/arch/arm/mach-mx25/clock.c
@@ -0,0 +1,1667 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/* based on mach-mx27/clock.c */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <asm/arch/clock.h>
+#include "crm_regs.h"
+
+#define OSC24M_CLK_FREQ     24000000	/* 24M reference clk */
+#define OSC32K_CLK_FREQ     32768	/* 32.768k oscillator in */
+
+static struct clk mpll_clk;
+static struct clk upll_clk;
+static struct clk ahb_clk;
+static struct clk upll_24610k_clk;
+
+static int _clk_enable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	return 0;
+}
+
+static void _clk_disable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(1 << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static int _clk_upll_enable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(MXC_CCM_CCTL);
+	reg &= ~MXC_CCM_CCTL_UPLL_DISABLE;
+	__raw_writel(reg, MXC_CCM_CCTL);
+
+	while ((__raw_readl(MXC_CCM_UPCTL) & MXC_CCM_UPCTL_LF) == 0) ;
+
+	return 0;
+}
+
+static void _clk_upll_disable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(MXC_CCM_CCTL);
+	reg |= MXC_CCM_CCTL_UPLL_DISABLE;
+	__raw_writel(reg, MXC_CCM_CCTL);
+}
+
+static int _perclk_enable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(MXC_CCM_CGCR0);
+	reg |= 1 << clk->id;
+	__raw_writel(reg, MXC_CCM_CGCR0);
+
+	return 0;
+}
+
+static void _perclk_disable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(MXC_CCM_CGCR0);
+	reg &= ~(1 << clk->id);
+	__raw_writel(reg, MXC_CCM_CGCR0);
+}
+
+static void _clk_pll_recalc(struct clk *clk)
+{
+	unsigned long mfi = 0, mfn = 0, mfd = 0, pdf = 0;
+	unsigned long ref_clk;
+	unsigned long reg;
+	unsigned long long temp;
+
+	ref_clk = clk->parent->rate;
+
+	if (clk == &mpll_clk) {
+		reg = __raw_readl(MXC_CCM_MPCTL);
+		pdf = (reg & MXC_CCM_MPCTL_PD_MASK) >> MXC_CCM_MPCTL_PD_OFFSET;
+		mfd =
+		    (reg & MXC_CCM_MPCTL_MFD_MASK) >> MXC_CCM_MPCTL_MFD_OFFSET;
+		mfi =
+		    (reg & MXC_CCM_MPCTL_MFI_MASK) >> MXC_CCM_MPCTL_MFI_OFFSET;
+		mfn =
+		    (reg & MXC_CCM_MPCTL_MFN_MASK) >> MXC_CCM_MPCTL_MFN_OFFSET;
+	} else if (clk == &upll_clk) {
+		reg = __raw_readl(MXC_CCM_UPCTL);
+		pdf = (reg & MXC_CCM_UPCTL_PD_MASK) >> MXC_CCM_UPCTL_PD_OFFSET;
+		mfd =
+		    (reg & MXC_CCM_UPCTL_MFD_MASK) >> MXC_CCM_UPCTL_MFD_OFFSET;
+		mfi =
+		    (reg & MXC_CCM_UPCTL_MFI_MASK) >> MXC_CCM_UPCTL_MFI_OFFSET;
+		mfn =
+		    (reg & MXC_CCM_UPCTL_MFN_MASK) >> MXC_CCM_UPCTL_MFN_OFFSET;
+	} else {
+		BUG();		/* oops */
+	}
+
+	mfi = (mfi <= 5) ? 5 : mfi;
+	temp = 2LL * ref_clk * mfn;
+	do_div(temp, mfd + 1);
+	temp = 2LL * ref_clk * mfi + temp;
+	do_div(temp, pdf + 1);
+
+	clk->rate = temp;
+}
+
+static unsigned long _clk_cpu_round_rate(struct clk *clk, unsigned long rate)
+{
+	int div = clk->parent->rate / rate;
+
+	if (clk->parent->rate % rate)
+		div++;
+
+	if (div > 4)
+		div = 4;
+
+	return clk->parent->rate / div;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	int div, reg;
+	unsigned long cctl = __raw_readl(MXC_CCM_CCTL);
+
+	div = clk->parent->rate / rate;
+
+	if (div > 4 || div < 1 || ((clk->parent->rate / div) != rate))
+		return -EINVAL;
+	div--;
+
+	reg =
+	    (cctl & ~MXC_CCM_CCTL_ARM_MASK) | (div << MXC_CCM_CCTL_ARM_OFFSET);
+	__raw_writel(MXC_CCM_CCTL, reg);
+	clk->rate = rate;
+
+	return 0;
+}
+
+static void _clk_cpu_recalc(struct clk *clk)
+{
+	unsigned long div;
+	unsigned long cctl = __raw_readl(MXC_CCM_CCTL);
+
+	div = (cctl & MXC_CCM_CCTL_ARM_MASK) >> MXC_CCM_CCTL_ARM_OFFSET;
+
+	clk->rate = clk->parent->rate / (div + 1);
+
+	if (cctl & MXC_CCM_CCTL_ARM_SRC) {
+		clk->rate *= 3;
+		clk->rate /= 4;
+	}
+}
+
+static void _clk_ahb_recalc(struct clk *clk)
+{
+	unsigned long div;
+	unsigned long cctl = __raw_readl(MXC_CCM_CCTL);
+
+	div = (cctl & MXC_CCM_CCTL_AHB_MASK) >> MXC_CCM_CCTL_AHB_OFFSET;
+
+	clk->rate = clk->parent->rate / (div + 1);
+}
+
+static unsigned int pcdr_a[4] = {
+	MXC_CCM_PCDR0, MXC_CCM_PCDR1, MXC_CCM_PCDR2, MXC_CCM_PCDR3
+};
+static void _clk_perclkx_recalc(struct clk *clk)
+{
+	unsigned long perclk_pdf;
+	unsigned long pcdr;
+
+	if (clk->id < 0 || clk->id > 15)
+		return;
+
+	pcdr = __raw_readl(pcdr_a[clk->id >> 2]);
+
+	perclk_pdf =
+	    (pcdr >> ((clk->id & 3) << 3)) & MXC_CCM_PCDR1_PERDIV1_MASK;
+
+	clk->rate = clk->parent->rate / (perclk_pdf + 1);
+}
+
+static unsigned long _clk_perclkx_round_rate(struct clk *clk,
+					     unsigned long rate)
+{
+	unsigned long div;
+
+	div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	if (div > 64)
+		div = 64;
+
+	return clk->parent->rate / div;
+}
+
+static int _clk_perclkx_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long reg;
+	unsigned long div;
+
+	if (clk->id < 0 || clk->id > 15)
+		return -EINVAL;
+
+	div = clk->parent->rate / rate;
+	if (div > 64 || div < 1 || ((clk->parent->rate / div) != rate))
+		return -EINVAL;
+	div--;
+
+	reg =
+	    __raw_readl(pcdr_a[clk->id >> 2]) & ~(MXC_CCM_PCDR1_PERDIV1_MASK <<
+						  ((clk->id & 3) << 3));
+	reg |= div << ((clk->id & 3) << 3);
+	__raw_writel(reg, pcdr_a[clk->id >> 2]);
+
+	clk->rate = rate;
+
+	return 0;
+}
+
+static int _clk_perclkx_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long mcr;
+
+	if (parent != &upll_clk && parent != &ahb_clk)
+		return -EINVAL;
+
+	clk->parent = parent;
+	mcr = __raw_readl(MXC_CCM_MCR);
+	if (parent == &upll_clk)
+		mcr |= (1 << clk->id);
+	else
+		mcr &= ~(1 << clk->id);
+
+	__raw_writel(mcr, MXC_CCM_MCR);
+
+	return 0;
+}
+
+static int _clk_perclkx_set_parent3(struct clk *clk, struct clk *parent)
+{
+	unsigned long mcr = __raw_readl(MXC_CCM_MCR);
+	int bit;
+
+	if (parent != &upll_clk && parent != &ahb_clk &&
+	    parent != &upll_24610k_clk)
+		return -EINVAL;
+
+	switch (clk->id) {
+	case 2:
+		bit = MXC_CCM_MCR_ESAI_CLK_MUX_OFFSET;
+		break;
+	case 13:
+		bit = MXC_CCM_MCR_SSI1_CLK_MUX_OFFSET;
+		break;
+	case 14:
+		bit = MXC_CCM_MCR_SSI2_CLK_MUX_OFFSET;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (parent == &upll_24610k_clk) {
+		mcr |= bit;
+		__raw_writel(mcr, MXC_CCM_MCR);
+		clk->parent = parent;
+	} else {
+		mcr &= ~bit;
+		__raw_writel(mcr, MXC_CCM_MCR);
+		return _clk_perclkx_set_parent(clk, parent);
+	}
+
+	return 0;
+}
+
+static void _clk_ipg_recalc(struct clk *clk)
+{
+	clk->rate = clk->parent->rate / 2;	/* Always AHB / 2 */
+}
+
+/* Top-level clocks */
+
+static struct clk osc24m_clk = {
+	.name = "osc24m",
+	.rate = OSC24M_CLK_FREQ,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk osc32k_clk = {
+	.name = "osc32k",
+	.rate = OSC32K_CLK_FREQ,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk mpll_clk = {
+	.name = "mpll",
+	.parent = &osc24m_clk,
+	.recalc = _clk_pll_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk upll_clk = {
+	.name = "upll",
+	.parent = &osc24m_clk,
+	.recalc = _clk_pll_recalc,
+	.enable = _clk_upll_enable,
+	.disable = _clk_upll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_24610k_recalc(struct clk *clk)
+{
+	long long temp = clk->parent->rate * 2461LL;
+
+	do_div(temp, 24000);
+
+	clk->rate = temp;	/* Always (UPLL * 24.61 / 240) */
+}
+
+static struct clk upll_24610k_clk = {
+	.name = "upll_24610k",
+	.parent = &upll_clk,
+	.recalc = _clk_24610k_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+/* Mid-level clocks */
+
+static struct clk cpu_clk = {	/* ARM clock */
+	.name = "cpu_clk",
+	.parent = &mpll_clk,
+	.set_rate = _clk_cpu_set_rate,
+	.recalc = _clk_cpu_recalc,
+	.round_rate = _clk_cpu_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ahb_clk = {	/* a.k.a. HCLK */
+	.name = "ahb_clk",
+	.parent = &cpu_clk,
+	.recalc = _clk_ahb_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ipg_clk = {
+	.name = "ipg_clk",
+	.parent = &ahb_clk,
+	.recalc = _clk_ipg_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+/* Bottom-level clocks */
+
+struct clk usbotg_clk = {
+	.name = "usbotg_clk",
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR0,
+	.enable_shift = MXC_CCM_CGCR0_HCLK_USBOTG_OFFSET,
+	.disable = _clk_disable,
+};
+
+struct clk rtic_clk = {
+	.name = "rtic_clk",
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR0,
+	.enable_shift = MXC_CCM_CGCR0_HCLK_RTIC_OFFSET,
+	.disable = _clk_disable,
+};
+
+struct clk emi_clk = {
+	.name = "emi_clk",
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR0,
+	.enable_shift = MXC_CCM_CGCR0_HCLK_EMI_OFFSET,
+	.disable = _clk_disable,
+};
+
+struct clk brom_clk = {
+	.name = "brom_clk",
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR0,
+	.enable_shift = MXC_CCM_CGCR0_HCLK_BROM_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk per_clk[] = {
+	{
+	 .name = "per_csi_clk",
+	 .id = 0,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_epit_clk",
+	 .id = 1,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_esai_clk",
+	 .id = 2,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL or 24.61MHz */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent3,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_esdhc1_clk",
+	 .id = 3,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .name = "per_esdhc2_clk",
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_esdhc2_clk",
+	 .id = 4,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_gpt_clk",
+	 .id = 5,
+	 .parent = &upll_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_i2c_clk",
+	 .id = 6,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_lcdc_clk",
+	 .id = 7,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_nfc_clk",
+	 .id = 8,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_owire_clk",
+	 .id = 9,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_pwm_clk",
+	 .id = 10,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_sim1_clk",
+	 .id = 11,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_sim2_clk",
+	 .id = 12,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_ssi1_clk",
+	 .id = 13,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL or 24.61MHz */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent3,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_ssi2_clk",
+	 .id = 14,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL or 24.61MHz */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent3,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+	{
+	 .name = "per_uart_clk",
+	 .id = 15,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+};
+
+struct clk nfc_clk = {
+	.name = "nfc_clk",
+	.id = 0,
+	.parent = &per_clk[8],
+};
+
+struct clk audmux_clk = {
+	.name = "audmux_clk",
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_AUDMUX_OFFSET,
+	.disable = _clk_disable,
+};
+
+struct clk ata_clk[] = {
+	{
+	 .name = "ata_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_ATA_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &ata_clk[1],},
+	{
+	 .name = "ata_ahb_clk",
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_ATA_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk can_clk[] = {
+	{
+	 .name = "can_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CAN1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "can_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CAN2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk csi_clk[] = {
+	{
+	 .name = "csi_clk",
+	 .id = 0,
+	 .parent = &per_clk[0],
+	 .secondary = &csi_clk[1],},
+	{
+	 .name = "csi_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CSI_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &csi_clk[2],},
+	{
+	 .name = "csi_ahb_clk",
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_CSI_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk cspi_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CSPI1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "cspi_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CSPI2_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "cspi_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CSPI3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk dryice_clk = {
+	.name = "dryice_clk",
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_DRYICE_OFFSET,
+	.disable = _clk_disable,
+};
+
+struct clk ect_clk = {
+	.name = "ect_clk",
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_ECT_OFFSET,
+	.disable = _clk_disable,
+};
+
+struct clk epit1_clk[] = {
+	{
+	 .name = "epit_clk",
+	 .id = 0,
+	 .parent = &per_clk[1],
+	 .secondary = &epit1_clk[1],},
+	{
+	 .name = "epit_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_EPIT1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk epit2_clk[] = {
+	{
+	 .name = "epit_clk",
+	 .id = 1,
+	 .parent = &per_clk[1],
+	 .secondary = &epit2_clk[1],},
+	{
+	 .name = "epit_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_EPIT2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk esai_clk[] = {
+	{
+	 .name = "esai_clk",
+	 .id = 0,
+	 .parent = &per_clk[2],
+	 .secondary = &esai_clk[1],},
+	{
+	 .name = "esai_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_ESAI_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esai_clk[2],},
+	{
+	 .name = "esai_ahb_clk",
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_ESAI_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk esdhc1_clk[] = {
+	{
+	 .name = "esdhc_clk",
+	 .id = 0,
+	 .parent = &per_clk[3],
+	 .secondary = &esdhc1_clk[1],},
+	{
+	 .name = "esdhc_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_ESDHC1_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc1_clk[2],},
+	{
+	 .name = "esdhc_ahb_clk",
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_ESDHC1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk esdhc2_clk[] = {
+	{
+	 .name = "esdhc_clk",
+	 .id = 1,
+	 .parent = &per_clk[4],
+	 .secondary = &esdhc2_clk[1],},
+	{
+	 .name = "esdhc_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_ESDHC2_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc2_clk[2],},
+	{
+	 .name = "esdhc_ahb_clk",
+	 .id = 1,
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_ESDHC2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk fec_clk[] = {
+	{
+	 .name = "fec_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_FEC_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &fec_clk[1],},
+	{
+	 .name = "fec_ahb_clk",
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_FEC_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk gpio_clk[] = {
+	{
+	 .name = "gpio_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPIO1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "gpio_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPIO2_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "gpio_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPIO3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt1_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 0,
+	 .parent = &per_clk[5],
+	 .secondary = &gpt1_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPT1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt2_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 1,
+	 .parent = &per_clk[5],
+	 .secondary = &gpt1_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPT2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt3_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 2,
+	 .parent = &per_clk[5],
+	 .secondary = &gpt1_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPT3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt4_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 3,
+	 .parent = &per_clk[5],
+	 .secondary = &gpt1_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPT4_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk i2c_clk[] = {
+	{
+	 .name = "i2c_clk",
+	 .id = 0,
+	 .parent = &per_clk[6],},
+	{
+	 .name = "i2c_clk",
+	 .id = 1,
+	 .parent = &per_clk[6],},
+	{
+	 .name = "i2c_clk",
+	 .id = 2,
+	 .parent = &per_clk[6],},
+};
+
+struct clk iim_clk = {
+	.name = "iim_clk",
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_IIM_OFFSET,
+	.disable = _clk_disable,
+};
+
+struct clk iomuxc_clk = {
+	.name = "iomuxc_clk",
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_IOMUXC_OFFSET,
+	.disable = _clk_disable,
+};
+
+struct clk kpp_clk = {
+	.name = "kpp_clk",
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_KPP_OFFSET,
+	.disable = _clk_disable,
+};
+
+struct clk lcdc_clk[] = {
+	{
+	 .name = "lcdc_clk",
+	 .id = 0,
+	 .parent = &per_clk[7],
+	 .secondary = &lcdc_clk[1],},
+	{
+	 .name = "lcdc_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_LCDC_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &lcdc_clk[2],},
+	{
+	 .name = "lcdc_ahb_clk",
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_LCDC_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk owire_clk[] = {
+	{
+	 .name = "owire_clk",
+	 .id = 0,
+	 .parent = &per_clk[9],
+	 .secondary = &owire_clk[1],},
+	{
+	 .name = "owire_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_OWIRE_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk pwm1_clk[] = {
+	{
+	 .name = "pwm_clk",
+	 .id = 0,
+	 .parent = &per_clk[10],
+	 .secondary = &pwm1_clk[1],},
+	{
+	 .name = "pwm_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_PWM1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk pwm2_clk[] = {
+	{
+	 .name = "pwm_clk",
+	 .id = 1,
+	 .parent = &per_clk[10],
+	 .secondary = &pwm2_clk[1],},
+	{
+	 .name = "pwm_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_PWM2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk pwm3_clk[] = {
+	{
+	 .name = "pwm_clk",
+	 .id = 2,
+	 .parent = &per_clk[10],
+	 .secondary = &pwm3_clk[1],},
+	{
+	 .name = "pwm_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_PWM3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk pwm4_clk[] = {
+	{
+	 .name = "pwm_clk",
+	 .id = 3,
+	 .parent = &per_clk[10],
+	 .secondary = &pwm4_clk[1],},
+	{
+	 .name = "pwm_ipg_clk",
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_PWM3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk rngb_clk = {
+	.name = "rngb_clk",
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_RNGB_OFFSET,
+	.disable = _clk_disable,
+};
+
+struct clk scc_clk = {
+	.name = "scc_clk",
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_SCC_OFFSET,
+	.disable = _clk_disable,
+};
+
+struct clk sdma_clk[] = {
+	{
+	 .name = "sdma_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SDMA_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &sdma_clk[1],},
+	{
+	 .name = "sdma_ahb_clk",
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_SDMA_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk sim1_clk[] = {
+	{
+	 .name = "sim_clk",
+	 .id = 0,
+	 .parent = &per_clk[11],
+	 .secondary = &sim1_clk[1],},
+	{
+	 .name = "sim_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SIM1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk sim2_clk[] = {
+	{
+	 .name = "sim_clk",
+	 .id = 1,
+	 .parent = &per_clk[12],
+	 .secondary = &sim2_clk[1],},
+	{
+	 .name = "sim_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SIM2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk slcdc_clk[] = {
+	{
+	 .name = "slcdc_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SLCDC_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &slcdc_clk[1],},
+	{
+	 .name = "slcdc_ahb_clk",
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_SLCDC_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk spba_clk = {
+	.name = "spba_clk",
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_SPBA_OFFSET,
+	.disable = _clk_disable,
+};
+
+struct clk ssi1_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .id = 0,
+	 .parent = &per_clk[13],
+	 .secondary = &ssi1_clk[1],},
+	{
+	 .name = "ssi_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SSI1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk ssi2_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .id = 1,
+	 .parent = &per_clk[14],
+	 .secondary = &ssi2_clk[1],},
+	{
+	 .name = "ssi_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SSI2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk tchscrn_clk = {
+	.name = "tchscrn_clk",
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_TCHSCRN_OFFSET,
+	.disable = _clk_disable,
+};
+
+struct clk uart1_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 0,
+	 .parent = &per_clk[15],
+	 .secondary = &uart1_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart2_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 1,
+	 .parent = &per_clk[15],
+	 .secondary = &uart2_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart3_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 2,
+	 .parent = &per_clk[15],
+	 .secondary = &uart3_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart4_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 3,
+	 .parent = &per_clk[15],
+	 .secondary = &uart4_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART4_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart5_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 4,
+	 .parent = &per_clk[15],
+	 .secondary = &uart5_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 4,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART5_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk wdog_clk = {
+	.name = "wdog_clk",
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_WDOG_OFFSET,
+	.disable = _clk_disable,
+};
+
+static unsigned long _clk_usb_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long div;
+
+	div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	if (div > 64)
+		return -EINVAL;
+
+	return clk->parent->rate / div;
+}
+
+static int _clk_usb_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long reg;
+	unsigned long div;
+
+	div = clk->parent->rate / rate;
+
+	if (clk->parent->rate / div != rate)
+		return -EINVAL;
+	if (div > 64)
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CCTL) & ~MXC_CCM_CCTL_USB_DIV_MASK;
+	reg |= (div - 1) << MXC_CCM_CCTL_USB_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_MCR);
+
+	return 0;
+}
+
+static void _clk_usb_recalc(struct clk *clk)
+{
+	unsigned long div =
+	    __raw_readl(MXC_CCM_MCR) & MXC_CCM_CCTL_USB_DIV_MASK;
+
+	div >>= MXC_CCM_CCTL_USB_DIV_OFFSET;
+
+	clk->rate = clk->parent->rate / (div + 1);
+}
+
+static int _clk_usb_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long mcr;
+
+	if (parent != &upll_clk && parent != &ahb_clk)
+		return -EINVAL;
+
+	clk->parent = parent;
+	mcr = __raw_readl(MXC_CCM_MCR);
+	if (parent == &ahb_clk)
+		mcr |= (1 << MXC_CCM_MCR_USB_CLK_MUX_OFFSET);
+	else
+		mcr &= ~(1 << MXC_CCM_MCR_USB_CLK_MUX_OFFSET);
+
+	__raw_writel(mcr, MXC_CCM_MCR);
+
+	return 0;
+}
+
+static struct clk usb_clk = {
+	.name = "usb_clk",
+	.parent = &upll_clk,
+	.recalc = _clk_usb_recalc,
+	.set_rate = _clk_usb_set_rate,
+	.round_rate = _clk_usb_round_rate,
+	.set_parent = _clk_usb_set_parent,
+};
+
+/* CLKO */
+
+static unsigned long _clk_clko_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long div;
+
+	div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	if (div > 64)
+		return -EINVAL;
+
+	return clk->parent->rate / div;
+}
+
+static int _clk_clko_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long reg;
+	unsigned long div;
+
+	div = clk->parent->rate / rate;
+
+	if ((clk->parent->rate / div) != rate)
+		return -EINVAL;
+	if (div > 64)
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_MCR) & ~MXC_CCM_MCR_CLKO_DIV_MASK;
+	reg |= (div - 1) << MXC_CCM_MCR_CLKO_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_MCR);
+
+	return 0;
+}
+
+static void _clk_clko_recalc(struct clk *clk)
+{
+	unsigned long div =
+	    __raw_readl(MXC_CCM_MCR) & MXC_CCM_MCR_CLKO_DIV_MASK;
+
+	div >>= MXC_CCM_MCR_CLKO_DIV_OFFSET;
+
+	clk->rate = clk->parent->rate / (div + 1);
+}
+
+static struct clk *clko_sources[] = {
+	&osc32k_clk,		/* 0x0 */
+	&osc24m_clk,		/* 0x1 */
+	&cpu_clk,		/* 0x2 */
+	&ahb_clk,		/* 0x3 */
+	&ipg_clk,		/* 0x4 */
+	NULL,			/* 0x5 */
+	NULL,			/* 0x6 */
+	NULL,			/* 0x7 */
+	NULL,			/* 0x8 */
+	NULL,			/* 0x9 */
+	&per_clk[0],		/* 0xA */
+	&per_clk[2],		/* 0xB */
+	&per_clk[13],		/* 0xC */
+	&per_clk[14],		/* 0xD */
+	&usb_clk,		/* 0xE */
+	NULL,			/* 0xF */
+};
+
+#define NR_CLKO_SOURCES (sizeof(clko_sources) / sizeof(struct clk *))
+
+static int _clk_clko_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long reg =
+	    __raw_readl(MXC_CCM_MCR) & ~MXC_CCM_MCR_CLKO_SEL_MASK;
+	struct clk **src;
+	int i;
+
+	for (i = 0, src = clko_sources; i < NR_CLKO_SOURCES; i++, src++)
+		if (*src == parent)
+			break;
+
+	if (i == NR_CLKO_SOURCES)
+		return -EINVAL;
+
+	clk->parent = parent;
+
+	reg |= i << MXC_CCM_MCR_CLKO_SEL_OFFSET;
+
+	__raw_writel(reg, MXC_CCM_MCR);
+
+	return 0;
+}
+
+static struct clk clko_clk = {
+	.name = "clko_clk",
+	.recalc = _clk_clko_recalc,
+	.set_rate = _clk_clko_set_rate,
+	.round_rate = _clk_clko_round_rate,
+	.set_parent = _clk_clko_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_MCR,
+	.enable_shift = MXC_CCM_MCR_CLKO_EN_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk *mxc_clks[] = {
+	&osc24m_clk,
+	&osc32k_clk,
+	&mpll_clk,
+	&upll_clk,
+	&cpu_clk,
+	&ahb_clk,
+	&ipg_clk,
+	&per_clk[0],
+	&per_clk[1],
+	&per_clk[2],
+	&per_clk[3],
+	&per_clk[4],
+	&per_clk[5],
+	&per_clk[6],
+	&per_clk[7],
+	&per_clk[8],
+	&per_clk[9],
+	&per_clk[10],
+	&per_clk[11],
+	&per_clk[12],
+	&per_clk[13],
+	&per_clk[14],
+	&per_clk[15],
+	&nfc_clk,
+	&audmux_clk,
+	&ata_clk[0],
+	&ata_clk[1],
+	&can_clk[0],
+	&can_clk[1],
+	&csi_clk[0],
+	&csi_clk[1],
+	&csi_clk[2],
+	&cspi_clk[0],
+	&cspi_clk[1],
+	&cspi_clk[2],
+	&dryice_clk,
+	&ect_clk,
+	&epit1_clk[0],
+	&epit1_clk[1],
+	&epit2_clk[0],
+	&epit2_clk[1],
+	&esai_clk[0],
+	&esai_clk[1],
+	&esai_clk[2],
+	&esdhc1_clk[0],
+	&esdhc1_clk[1],
+	&esdhc1_clk[2],
+	&esdhc2_clk[0],
+	&esdhc2_clk[1],
+	&esdhc2_clk[2],
+	&fec_clk[0],
+	&fec_clk[1],
+	&gpio_clk[0],
+	&gpio_clk[1],
+	&gpio_clk[2],
+	&gpt1_clk[0],
+	&gpt1_clk[1],
+	&gpt2_clk[0],
+	&gpt2_clk[1],
+	&gpt3_clk[0],
+	&gpt3_clk[1],
+	&gpt4_clk[0],
+	&gpt4_clk[1],
+	&i2c_clk[0],
+	&i2c_clk[1],
+	&i2c_clk[2],
+	&iim_clk,
+	&iomuxc_clk,
+	&kpp_clk,
+	&lcdc_clk[0],
+	&lcdc_clk[1],
+	&lcdc_clk[2],
+	&owire_clk[0],
+	&owire_clk[1],
+	&pwm1_clk[0],
+	&pwm1_clk[1],
+	&pwm2_clk[0],
+	&pwm2_clk[1],
+	&pwm3_clk[0],
+	&pwm3_clk[1],
+	&pwm4_clk[0],
+	&pwm4_clk[1],
+	&rngb_clk,
+	&scc_clk,
+	&sdma_clk[0],
+	&sdma_clk[1],
+	&sim1_clk[0],
+	&sim1_clk[1],
+	&sim2_clk[0],
+	&sim2_clk[1],
+	&slcdc_clk[0],
+	&slcdc_clk[1],
+	&spba_clk,
+	&ssi1_clk[0],
+	&ssi1_clk[1],
+	&ssi2_clk[0],
+	&ssi2_clk[1],
+	&tchscrn_clk,
+	&uart1_clk[0],
+	&uart1_clk[1],
+	&uart2_clk[0],
+	&uart2_clk[1],
+	&uart3_clk[0],
+	&uart3_clk[1],
+	&uart4_clk[0],
+	&uart4_clk[1],
+	&uart5_clk[0],
+	&uart5_clk[1],
+	&wdog_clk,
+	&usb_clk,
+	&clko_clk,
+};
+
+/*!
+ * Function to get timer clock rate early in boot process before clock tree is
+ * initialized.
+ *
+ * @return	Clock rate for timer
+ */
+unsigned long __init clk_early_get_timer_rate(void)
+{
+	upll_clk.recalc(&upll_clk);
+	per_clk[5].recalc(&per_clk[5]);
+	per_clk[5].enable(&per_clk[5]);
+
+	return per_clk[5].rate;
+}
+
+extern void propagate_rate(struct clk *tclk);
+
+int __init mxc_clocks_init(void)
+{
+	struct clk **clkp;
+	int i;
+
+	for (clkp = mxc_clks; clkp < mxc_clks + ARRAY_SIZE(mxc_clks); clkp++)
+		clk_register(*clkp);
+
+	/* Turn off all possible clocks */
+	__raw_writel((1 << MXC_CCM_CGCR0_HCLK_EMI_OFFSET), MXC_CCM_CGCR0);
+
+	__raw_writel((1 << MXC_CCM_CGCR1_GPT1_OFFSET) |
+		     (1 << MXC_CCM_CGCR1_IIM_OFFSET), MXC_CCM_CGCR1);
+	__raw_writel(1 << MXC_CCM_CGCR2_SCC_OFFSET, MXC_CCM_CGCR2);
+
+	/* Set all perclk sources to upll */
+	for (i = 0; i < 16; i++)
+		per_clk[i].set_parent(&per_clk[i], &upll_clk);
+
+	/* This will propagate to all children and init all the clock rates */
+	propagate_rate(&osc24m_clk);
+	propagate_rate(&osc32k_clk);
+
+	pr_info("Clock input source is %ld\n", osc24m_clk.rate);
+
+	clk_enable(&emi_clk);
+	clk_enable(&gpio_clk[0]);
+	clk_enable(&gpio_clk[1]);
+	clk_enable(&gpio_clk[2]);
+	clk_enable(&iim_clk);
+	clk_enable(&gpt1_clk[0]);
+	clk_enable(&iomuxc_clk);
+	clk_enable(&scc_clk);
+
+	return 0;
+}
diff --git a/arch/arm/mach-mx25/cpu.c b/arch/arm/mach-mx25/cpu.c
new file mode 100644
index 0000000..57490e7
--- /dev/null
+++ b/arch/arm/mach-mx25/cpu.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mach-mx25/cpu.c
+ *
+ * @brief This file contains the CPU initialization code.
+ *
+ * @ingroup MSL_MX25
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/hardware.h>
+
+/*!
+ * CPU initialization. It is called by fixup_mxc_board()
+ */
+void __init mxc_cpu_init(void)
+{
+	if (!system_rev)
+		mxc_set_system_rev(0x25, CHIP_REV_1_0);
+}
diff --git a/arch/arm/mach-mx25/crm_regs.h b/arch/arm/mach-mx25/crm_regs.h
new file mode 100644
index 0000000..a607c46
--- /dev/null
+++ b/arch/arm/mach-mx25/crm_regs.h
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX25_CRM_REGS_H__
+#define __ARCH_ARM_MACH_MX25_CRM_REGS_H__
+
+#include <asm/arch/hardware.h>
+
+/* Register offsets */
+#define MXC_CCM_MPCTL               (IO_ADDRESS(CCM_BASE_ADDR) + 0x00)
+#define MXC_CCM_UPCTL               (IO_ADDRESS(CCM_BASE_ADDR) + 0x04)
+#define MXC_CCM_CCTL                (IO_ADDRESS(CCM_BASE_ADDR) + 0x08)
+#define MXC_CCM_CGCR0               (IO_ADDRESS(CCM_BASE_ADDR) + 0x0C)
+#define MXC_CCM_CGCR1               (IO_ADDRESS(CCM_BASE_ADDR) + 0x10)
+#define MXC_CCM_CGCR2               (IO_ADDRESS(CCM_BASE_ADDR) + 0x14)
+#define MXC_CCM_PCDR0               (IO_ADDRESS(CCM_BASE_ADDR) + 0x18)
+#define MXC_CCM_PCDR1               (IO_ADDRESS(CCM_BASE_ADDR) + 0x1C)
+#define MXC_CCM_PCDR2               (IO_ADDRESS(CCM_BASE_ADDR) + 0x20)
+#define MXC_CCM_PCDR3               (IO_ADDRESS(CCM_BASE_ADDR) + 0x24)
+#define MXC_CCM_CRSR                (IO_ADDRESS(CCM_BASE_ADDR) + 0x28)
+#define MXC_CCM_CRDR                (IO_ADDRESS(CCM_BASE_ADDR) + 0x2C)
+#define MXC_CCM_DCVR0               (IO_ADDRESS(CCM_BASE_ADDR) + 0x30)
+#define MXC_CCM_DCVR1               (IO_ADDRESS(CCM_BASE_ADDR) + 0x34)
+#define MXC_CCM_DCVR2               (IO_ADDRESS(CCM_BASE_ADDR) + 0x38)
+#define MXC_CCM_DCVR3               (IO_ADDRESS(CCM_BASE_ADDR) + 0x3C)
+#define MXC_CCM_LTR0                (IO_ADDRESS(CCM_BASE_ADDR) + 0x40)
+#define MXC_CCM_LTR1                (IO_ADDRESS(CCM_BASE_ADDR) + 0x44)
+#define MXC_CCM_LTR2                (IO_ADDRESS(CCM_BASE_ADDR) + 0x48)
+#define MXC_CCM_LTR3                (IO_ADDRESS(CCM_BASE_ADDR) + 0x4C)
+#define MXC_CCM_LTBR0               (IO_ADDRESS(CCM_BASE_ADDR) + 0x50)
+#define MXC_CCM_LTBR1               (IO_ADDRESS(CCM_BASE_ADDR) + 0x54)
+#define MXC_CCM_PMCR0               (IO_ADDRESS(CCM_BASE_ADDR) + 0x58)
+#define MXC_CCM_PMCR1               (IO_ADDRESS(CCM_BASE_ADDR) + 0x5C)
+#define MXC_CCM_PMCR2               (IO_ADDRESS(CCM_BASE_ADDR) + 0x60)
+#define MXC_CCM_MCR                 (IO_ADDRESS(CCM_BASE_ADDR) + 0x64)
+
+#define MXC_CCM_MPCTL_BRMO          (1 << 31)
+#define MXC_CCM_MPCTL_PD_OFFSET     26
+#define MXC_CCM_MPCTL_PD_MASK       (0xf << 26)
+#define MXC_CCM_MPCTL_MFD_OFFSET    16
+#define MXC_CCM_MPCTL_MFD_MASK      (0x3ff << 16)
+#define MXC_CCM_MPCTL_MFI_OFFSET    10
+#define MXC_CCM_MPCTL_MFI_MASK      (0xf << 10)
+#define MXC_CCM_MPCTL_MFN_OFFSET    0
+#define MXC_CCM_MPCTL_MFN_MASK      0x3ff
+#define MXC_CCM_MPCTL_LF            (1 << 15)
+
+#define MXC_CCM_UPCTL_BRMO          (1 << 31)
+#define MXC_CCM_UPCTL_PD_OFFSET     26
+#define MXC_CCM_UPCTL_PD_MASK       (0xf << 26)
+#define MXC_CCM_UPCTL_MFD_OFFSET    16
+#define MXC_CCM_UPCTL_MFD_MASK      (0x3ff << 16)
+#define MXC_CCM_UPCTL_MFI_OFFSET    10
+#define MXC_CCM_UPCTL_MFI_MASK      (0xf << 10)
+#define MXC_CCM_UPCTL_MFN_OFFSET    0
+#define MXC_CCM_UPCTL_MFN_MASK      0x3ff
+#define MXC_CCM_UPCTL_LF            (1 << 15)
+
+#define MXC_CCM_CCTL_ARM_OFFSET     30
+#define MXC_CCM_CCTL_ARM_MASK       (0x3 << 30)
+#define MXC_CCM_CCTL_AHB_OFFSET     28
+#define MXC_CCM_CCTL_AHB_MASK       (0x3 << 28)
+#define MXC_CCM_CCTL_MPLL_RST       (1 << 27)
+#define MXC_CCM_CCTL_UPLL_RST       (1 << 26)
+#define MXC_CCM_CCTL_LP_CTL_OFFSET  24
+#define MXC_CCM_CCTL_LP_CTL_MASK    (0x3 << 24)
+#define MXC_CCM_CCTL_LP_MODE_RUN    (0x0 << 24)
+#define MXC_CCM_CCTL_LP_MODE_WAIT   (0x1 << 24)
+#define MXC_CCM_CCTL_LP_MODE_DOZE   (0x2 << 24)
+#define MXC_CCM_CCTL_LP_MODE_STOP   (0x3 << 24)
+#define MXC_CCM_CCTL_UPLL_DISABLE   (1 << 23)
+#define MXC_CCM_CCTL_MPLL_BYPASS    (1 << 22)
+#define MXC_CCM_CCTL_USB_DIV_OFFSET 16
+#define MXC_CCM_CCTL_USB_DIV_MASK   (0x3 << 16)
+#define MXC_CCM_CCTL_CG_CTRL        (1 << 15)
+#define MXC_CCM_CCTL_ARM_SRC        (1 << 14)
+
+#define MXC_CCM_CGCR0_HCLK_ATA_OFFSET    16
+#define MXC_CCM_CGCR0_HCLK_BROM_OFFSET   17
+#define MXC_CCM_CGCR0_HCLK_CSI_OFFSET    18
+#define MXC_CCM_CGCR0_HCLK_EMI_OFFSET    19
+#define MXC_CCM_CGCR0_HCLK_ESAI_OFFSET   20
+#define MXC_CCM_CGCR0_HCLK_ESDHC1_OFFSET 21
+#define MXC_CCM_CGCR0_HCLK_ESDHC2_OFFSET 22
+#define MXC_CCM_CGCR0_HCLK_FEC_OFFSET    23
+#define MXC_CCM_CGCR0_HCLK_LCDC_OFFSET   24
+#define MXC_CCM_CGCR0_HCLK_RTIC_OFFSET   25
+#define MXC_CCM_CGCR0_HCLK_SDMA_OFFSET   26
+#define MXC_CCM_CGCR0_HCLK_SLCDC_OFFSET  27
+#define MXC_CCM_CGCR0_HCLK_USBOTG_OFFSET 28
+
+#define MXC_CCM_CGCR0_PER_CSI_OFFSET     0
+#define MXC_CCM_CGCR0_PER_EPIT_OFFSET    1
+#define MXC_CCM_CGCR0_PER_ESAI_OFFSET    2
+#define MXC_CCM_CGCR0_PER_ESDHC1_OFFSET  3
+#define MXC_CCM_CGCR0_PER_ESDHC2_OFFSET  4
+#define MXC_CCM_CGCR0_PER_GPT_OFFSET     5
+#define MXC_CCM_CGCR0_PER_I2C_OFFSET     6
+#define MXC_CCM_CGCR0_PER_LCDC_OFFSET    7
+#define MXC_CCM_CGCR0_PER_NFC_OFFSET     8
+#define MXC_CCM_CGCR0_PER_OWIRE_OFFSET   9
+#define MXC_CCM_CGCR0_PER_PWM_OFFSET     10
+#define MXC_CCM_CGCR0_PER_SIM1_OFFSET    11
+#define MXC_CCM_CGCR0_PER_SIM2_OFFSET    12
+#define MXC_CCM_CGCR0_PER_SSI1_OFFSET    13
+#define MXC_CCM_CGCR0_PER_SSI2_OFFSET    14
+#define MXC_CCM_CGCR0_PER_UART_OFFSET    15
+
+#define MXC_CCM_CGCR1_AUDMUX_OFFSET      0
+#define MXC_CCM_CGCR1_ATA_OFFSET         1
+#define MXC_CCM_CGCR1_CAN1_OFFSET        2
+#define MXC_CCM_CGCR1_CAN2_OFFSET        3
+#define MXC_CCM_CGCR1_CSI_OFFSET         4
+#define MXC_CCM_CGCR1_CSPI1_OFFSET       5
+#define MXC_CCM_CGCR1_CSPI2_OFFSET       6
+#define MXC_CCM_CGCR1_CSPI3_OFFSET       7
+#define MXC_CCM_CGCR1_DRYICE_OFFSET      8
+#define MXC_CCM_CGCR1_ECT_OFFSET         9
+#define MXC_CCM_CGCR1_EPIT1_OFFSET       10
+#define MXC_CCM_CGCR1_EPIT2_OFFSET       11
+#define MXC_CCM_CGCR1_ESAI_OFFSET        12
+#define MXC_CCM_CGCR1_ESDHC1_OFFSET      13
+#define MXC_CCM_CGCR1_ESDHC2_OFFSET      14
+#define MXC_CCM_CGCR1_FEC_OFFSET         15
+#define MXC_CCM_CGCR1_GPIO1_OFFSET       16
+#define MXC_CCM_CGCR1_GPIO2_OFFSET       17
+#define MXC_CCM_CGCR1_GPIO3_OFFSET       18
+#define MXC_CCM_CGCR1_GPT1_OFFSET        19
+#define MXC_CCM_CGCR1_GPT2_OFFSET        20
+#define MXC_CCM_CGCR1_GPT3_OFFSET        21
+#define MXC_CCM_CGCR1_GPT4_OFFSET        22
+#define MXC_CCM_CGCR1_I2C1_OFFSET        23
+#define MXC_CCM_CGCR1_I2C2_OFFSET        24
+#define MXC_CCM_CGCR1_I2C3_OFFSET        25
+#define MXC_CCM_CGCR1_IIM_OFFSET         26
+#define MXC_CCM_CGCR1_IOMUXC_OFFSET      27
+#define MXC_CCM_CGCR1_KPP_OFFSET         28
+#define MXC_CCM_CGCR1_LCDC_OFFSET        29
+#define MXC_CCM_CGCR1_OWIRE_OFFSET       30
+#define MXC_CCM_CGCR1_PWM1_OFFSET        31
+
+#define MXC_CCM_CGCR2_PWM2_OFFSET        (32-32)
+#define MXC_CCM_CGCR2_PWM3_OFFSET        (33-32)
+#define MXC_CCM_CGCR2_PWM4_OFFSET        (34-32)
+#define MXC_CCM_CGCR2_RNGB_OFFSET        (35-32)
+#define MXC_CCM_CGCR2_RTIC_OFFSET        (36-32)
+#define MXC_CCM_CGCR2_SCC_OFFSET         (37-32)
+#define MXC_CCM_CGCR2_SDMA_OFFSET        (38-32)
+#define MXC_CCM_CGCR2_SIM1_OFFSET        (39-32)
+#define MXC_CCM_CGCR2_SIM2_OFFSET        (40-32)
+#define MXC_CCM_CGCR2_SLCDC_OFFSET       (41-32)
+#define MXC_CCM_CGCR2_SPBA_OFFSET        (42-32)
+#define MXC_CCM_CGCR2_SSI1_OFFSET        (43-32)
+#define MXC_CCM_CGCR2_SSI2_OFFSET        (44-32)
+#define MXC_CCM_CGCR2_TCHSCRN_OFFSET     (45-32)
+#define MXC_CCM_CGCR2_UART1_OFFSET       (46-32)
+#define MXC_CCM_CGCR2_UART2_OFFSET       (47-32)
+#define MXC_CCM_CGCR2_UART3_OFFSET       (48-32)
+#define MXC_CCM_CGCR2_UART4_OFFSET       (49-32)
+#define MXC_CCM_CGCR2_UART5_OFFSET       (50-32)
+#define MXC_CCM_CGCR2_WDOG_OFFSET        (51-32)
+
+#define MXC_CCM_PCDR1_PERDIV1_MASK       0x3f
+
+#define MXC_CCM_RCSR_NF16B               (1 << 14)
+
+#define MXC_CCM_MCR_USB_XTAL_MUX_OFFSET  31
+#define MXC_CCM_MCR_CLKO_EN_OFFSET       30
+#define MXC_CCM_MCR_CLKO_DIV_OFFSET      24
+#define MXC_CCM_MCR_CLKO_DIV_MASK        (0x3F << 24)
+#define MXC_CCM_MCR_CLKO_SEL_OFFSET      20
+#define MXC_CCM_MCR_CLKO_SEL_MASK        (0xF << 20)
+#define MXC_CCM_MCR_ESAI_CLK_MUX_OFFSET  19
+#define MXC_CCM_MCR_SSI2_CLK_MUX_OFFSET  18
+#define MXC_CCM_MCR_SSI1_CLK_MUX_OFFSET  17
+#define MXC_CCM_MCR_USB_CLK_MUX_OFFSET   16
+
+#define MXC_CCM_MCR_PER_CLK_MUX_MASK     (0xFFFF << 0)
+
+#endif				/* __ARCH_ARM_MACH_MX25_CRM_REGS_H__ */
diff --git a/arch/arm/mach-mx25/devices.c b/arch/arm/mach-mx25/devices.c
new file mode 100644
index 0000000..7fcaabd
--- /dev/null
+++ b/arch/arm/mach-mx25/devices.c
@@ -0,0 +1,329 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/spba.h>
+#include <asm/arch/sdma.h>
+
+#include "iomux.h"
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
+static struct resource wdt_resources[] = {
+	{
+	 .start = WDOG1_BASE_ADDR,
+	 .end = WDOG1_BASE_ADDR + 0x30,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_wdt_device = {
+	.name = "mxc_wdt",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(wdt_resources),
+	.resource = wdt_resources,
+};
+
+static void mxc_init_wdt(void)
+{
+	(void)platform_device_register(&mxc_wdt_device);
+}
+#else
+static inline void mxc_init_wdt(void)
+{
+}
+#endif
+
+/* SPI controller and device data */
+#if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
+
+#ifdef CONFIG_SPI_MXC_SELECT1
+/*!
+ * Resource definition for the CSPI1
+ */
+static struct resource mxcspi1_resources[] = {
+	[0] = {
+	       .start = CSPI1_BASE_ADDR,
+	       .end = CSPI1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_CSPI1,
+	       .end = MXC_INT_CSPI1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI1 */
+static struct mxc_spi_master mxcspi1_data = {
+	.maxchipselect = 4,
+	.spi_version = 7,
+};
+
+/*! Device Definition for MXC CSPI1 */
+static struct platform_device mxcspi1_device = {
+	.name = "mxc_spi",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi1_resources),
+	.resource = mxcspi1_resources,
+};
+
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+
+#ifdef CONFIG_SPI_MXC_SELECT2
+/*!
+ * Resource definition for the CSPI2
+ */
+static struct resource mxcspi2_resources[] = {
+	[0] = {
+	       .start = CSPI2_BASE_ADDR,
+	       .end = CSPI2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_CSPI2,
+	       .end = MXC_INT_CSPI2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI2 */
+static struct mxc_spi_master mxcspi2_data = {
+	.maxchipselect = 4,
+	.spi_version = 7,
+};
+
+/*! Device Definition for MXC CSPI2 */
+static struct platform_device mxcspi2_device = {
+	.name = "mxc_spi",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi2_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi2_resources),
+	.resource = mxcspi2_resources,
+};
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+
+static inline void mxc_init_spi(void)
+{
+#ifdef CONFIG_SPI_MXC_SELECT1
+	if (platform_device_register(&mxcspi1_device) < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_1\n");
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+#ifdef CONFIG_SPI_MXC_SELECT2
+	if (platform_device_register(&mxcspi2_device) < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_2\n");
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+}
+#else
+static inline void mxc_init_spi(void)
+{
+}
+#endif
+
+/* I2C controller and device data */
+#if defined(CONFIG_I2C_MXC) || defined(CONFIG_I2C_MXC_MODULE)
+
+#ifdef CONFIG_I2C_MXC_SELECT1
+/*!
+ * Resource definition for the I2C1
+ */
+static struct resource mxci2c1_resources[] = {
+	[0] = {
+	       .start = I2C_BASE_ADDR,
+	       .end = I2C_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_I2C,
+	       .end = MXC_INT_I2C,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c1_data = {
+	.i2c_clk = 40000,
+};
+#endif
+
+#ifdef CONFIG_I2C_MXC_SELECT2
+/*!
+ * Resource definition for the I2C2
+ */
+static struct resource mxci2c2_resources[] = {
+	[0] = {
+	       .start = I2C2_BASE_ADDR,
+	       .end = I2C2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_I2C2,
+	       .end = MXC_INT_I2C2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c2_data = {
+	.i2c_clk = 40000,
+};
+#endif
+
+#ifdef CONFIG_I2C_MXC_SELECT3
+/*!
+ * Resource definition for the I2C3
+ */
+static struct resource mxci2c3_resources[] = {
+	[0] = {
+	       .start = I2C3_BASE_ADDR,
+	       .end = I2C3_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_I2C3,
+	       .end = MXC_INT_I2C3,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c3_data = {
+	.i2c_clk = 40000,
+};
+#endif
+
+/*! Device Definition for MXC I2C1 */
+static struct platform_device mxci2c_devices[] = {
+#ifdef CONFIG_I2C_MXC_SELECT1
+	{
+	 .name = "mxc_i2c",
+	 .id = 0,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = &mxci2c1_data,
+		 },
+	 .num_resources = ARRAY_SIZE(mxci2c1_resources),
+	 .resource = mxci2c1_resources,},
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT2
+	{
+	 .name = "mxc_i2c",
+	 .id = 1,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = &mxci2c2_data,
+		 },
+	 .num_resources = ARRAY_SIZE(mxci2c2_resources),
+	 .resource = mxci2c2_resources,},
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT3
+	{
+	 .name = "mxc_i2c",
+	 .id = 2,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = &mxci2c3_data,
+		 },
+	 .num_resources = ARRAY_SIZE(mxci2c3_resources),
+	 .resource = mxci2c3_resources,},
+#endif
+};
+
+static inline void mxc_init_i2c(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mxci2c_devices); i++) {
+		if (platform_device_register(&mxci2c_devices[i]) < 0)
+			dev_err(&mxci2c_devices[i].dev,
+				"Unable to register I2C device\n");
+	}
+}
+#else
+static inline void mxc_init_i2c(void)
+{
+}
+#endif
+
+struct mxc_gpio_port mxc_gpio_ports[GPIO_PORT_NUM] = {
+	{
+	 .num = 0,
+	 .base = IO_ADDRESS(GPIO1_BASE_ADDR),
+	 .irq = MXC_INT_GPIO1,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE,
+	 },
+	{
+	 .num = 1,
+	 .base = IO_ADDRESS(GPIO2_BASE_ADDR),
+	 .irq = MXC_INT_GPIO2,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN,
+	 },
+	{
+	 .num = 2,
+	 .base = IO_ADDRESS(GPIO3_BASE_ADDR),
+	 .irq = MXC_INT_GPIO3,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 2,
+	 },
+	{
+	 .num = 3,
+	 .base = IO_ADDRESS(GPIO4_BASE_ADDR),
+	 .irq = MXC_INT_GPIO4,
+	 .virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 3,
+	 },
+};
+
+static struct platform_device mxc_dma_device = {
+	.name = "mxc_dma",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+};
+
+static inline void mxc_init_dma(void)
+{
+	(void)platform_device_register(&mxc_dma_device);
+}
+
+static int __init mxc_init_devices(void)
+{
+	mxc_init_wdt();
+	mxc_init_spi();
+	mxc_init_i2c();
+	mxc_init_dma();
+
+	return 0;
+}
+
+arch_initcall(mxc_init_devices);
diff --git a/arch/arm/mach-mx25/dma.c b/arch/arm/mach-mx25/dma.c
new file mode 100644
index 0000000..1bee714
--- /dev/null
+++ b/arch/arm/mach-mx25/dma.c
@@ -0,0 +1,162 @@
+/*
+ *  Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/dma.h>
+#include <asm/arch/hardware.h>
+
+#include "serial.h"
+
+struct mxc_sdma_info_entry_s {
+	mxc_dma_device_t device;
+	mxc_sdma_channel_params_t *chnl_info;
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_RXTL,
+			.per_address = UART1_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART1_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_TXTL,
+			.per_address = UART1_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART1_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_RXTL,
+			.per_address = UART2_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART2_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_TXTL,
+			.per_address = UART2_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART2_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_RXTL,
+			.per_address = UART3_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART3_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_TXTL,
+			.per_address = UART3_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART3_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
+	.chnl_params = {
+			.peripheral_type = MEMORY,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MEMORY,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static struct mxc_sdma_info_entry_s mxc_sdma_active_dma_info[] = {
+	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
+	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
+	{MXC_DMA_UART2_RX, &mxc_sdma_uart2_rx_params},
+	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
+	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
+	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
+};
+
+static int mxc_sdma_info_entrys =
+    sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id)
+{
+	struct mxc_sdma_info_entry_s *p = mxc_sdma_active_dma_info;
+	int i;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		if (p->device == channel_id)
+			return p->chnl_info;
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(mxc_sdma_get_channel_params);
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t *chnl)
+{
+	/* No channels statically allocated for MX25 */
+}
+EXPORT_SYMBOL(mxc_get_static_channels);
diff --git a/arch/arm/mach-mx25/iomux.c b/arch/arm/mach-mx25/iomux.c
new file mode 100644
index 0000000..29f5248
--- /dev/null
+++ b/arch/arm/mach-mx25/iomux.c
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup GPIO_MX25 Board GPIO and Muxing Setup
+ * @ingroup MSL_MX25
+ */
+/*!
+ * @file mach-mx25/iomux.c
+ *
+ * @brief I/O Muxing control functions
+ *
+ * @ingroup GPIO_MX25
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/hardware.h>
+#include <asm/arch/gpio.h>
+#include "iomux.h"
+
+/*!
+ * IOMUX register (base) addresses
+ */
+enum iomux_reg_addr {
+	IOMUXGPR = IO_ADDRESS(IOMUXC_BASE_ADDR),
+	/*!< General purpose */
+	IOMUXSW_MUX_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x008,
+	/*!< MUX control */
+	IOMUXSW_MUX_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x228,
+	/*!< last MUX control register */
+	IOMUXSW_PAD_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x22C,
+	/*!< Pad control */
+	IOMUXSW_PAD_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x414,
+	/*!< last Pad control register */
+	IOMUXSW_INPUT_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x460,
+	/*!< input select register */
+	IOMUXSW_INPUT_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x580,
+	/*!< last input select register */
+};
+
+#define MUX_PIN_NUM_MAX		\
+		(((IOMUXSW_PAD_END - IOMUXSW_PAD_CTL) >> 2) + 1)
+#define MUX_INPUT_NUM_MUX	\
+		(((IOMUXSW_INPUT_END - IOMUXSW_INPUT_CTL) >> 2) + 1)
+
+#define PIN_TO_IOMUX_INDEX(pin) ((PIN_TO_IOMUX_PAD(pin) - 0x22C) >> 2)
+
+static DEFINE_SPINLOCK(gpio_mux_lock);
+static u8 iomux_pin_res_table[MUX_PIN_NUM_MAX];
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ * FIXED ME: for backward compatible. Will be static function!
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  cfg		an output function as defined in \b #iomux_pin_cfg_t
+ *
+ * @return 		0 if successful; Non-zero otherwise
+ */
+static int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
+{
+	u32 ret = 0;
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	u32 mux_reg = PIN_TO_IOMUX_MUX(pin);
+	u8 *rp;
+
+	BUG_ON(pin_index > MUX_PIN_NUM_MAX);
+	if (mux_reg != NON_MUX_I) {
+		mux_reg += IOMUXGPR;
+		BUG_ON((mux_reg > IOMUXSW_MUX_END)
+		       || (mux_reg < IOMUXSW_MUX_CTL));
+		spin_lock(&gpio_mux_lock);
+		__raw_writel(cfg, mux_reg);
+		/*
+		 * Log a warning if a pin changes ownership
+		 */
+		rp = iomux_pin_res_table + pin_index;
+		if ((cfg & *rp) && (*rp != cfg)) {
+			/*Console: how to do */
+			printk(KERN_ERR "iomux_config_mux: Warning: iomux pin"
+			       " config changed, index=%d register=%d, "
+			       " prev=0x%x new=0x%x\n", pin_index, mux_reg,
+			       *rp, cfg);
+			ret = -EINVAL;
+		}
+		*rp = cfg;
+		spin_unlock(&gpio_mux_lock);
+	}
+
+	return ret;
+}
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
+{
+	int ret = iomux_config_mux(pin, cfg);
+	if (GPIO_TO_PORT(IOMUX_TO_GPIO(pin)) < GPIO_PORT_NUM) {
+		if (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_GPIO) ||
+		    (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_FUNC) &&
+		     ((pin == MX25_PIN_GPIO_A) || (pin == MX25_PIN_GPIO_B) ||
+		      (pin == MX25_PIN_GPIO_C) || (pin == MX25_PIN_GPIO_D) ||
+		      (pin == MX25_PIN_GPIO_E) || (pin == MX25_PIN_GPIO_F))))
+			ret |= mxc_request_gpio(pin);
+	}
+	return ret;
+}
+EXPORT_SYMBOL(mxc_request_iomux);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
+{
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	u8 *rp = iomux_pin_res_table + pin_index;
+
+	BUG_ON((pin_index > MUX_PIN_NUM_MAX));
+
+	*rp = 0;
+	if (GPIO_TO_PORT(IOMUX_TO_GPIO(pin)) < GPIO_PORT_NUM) {
+		if (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_GPIO) ||
+		    (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_FUNC) &&
+		     ((pin == MX25_PIN_GPIO_A) || (pin == MX25_PIN_GPIO_B) ||
+		      (pin == MX25_PIN_GPIO_C) || (pin == MX25_PIN_GPIO_D) ||
+		      (pin == MX25_PIN_GPIO_E) || (pin == MX25_PIN_GPIO_F))))
+			mxc_free_gpio(pin);
+	}
+}
+EXPORT_SYMBOL(mxc_free_iomux);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin     a pin number as defined in \b #iomux_pin_name_t
+ * @param  config  the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
+{
+	u32 pad_reg = IOMUXGPR + PIN_TO_IOMUX_PAD(pin);
+
+	BUG_ON((pad_reg > IOMUXSW_PAD_END) || (pad_reg < IOMUXSW_PAD_CTL));
+
+	spin_lock(&gpio_mux_lock);
+	__raw_writel(config, pad_reg);
+	spin_unlock(&gpio_mux_lock);
+}
+EXPORT_SYMBOL(mxc_iomux_set_pad);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en)
+{
+	u32 l;
+
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(IOMUXGPR);
+
+	if (en)
+		l |= gp;
+	else
+		l &= ~gp;
+
+	__raw_writel(l, IOMUXGPR);
+	spin_unlock(&gpio_mux_lock);
+}
+EXPORT_SYMBOL(mxc_iomux_set_gpr);
+
+/*!
+ * This function configures input path.
+ *
+ * @param input index of input select register as defined in \b
+ *  			#iomux_input_select_t
+ * @param config the binary value of elements defined in \b
+ * 			#iomux_input_config_t
+ */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config)
+{
+	u32 reg = IOMUXSW_INPUT_CTL + (input << 2);
+
+	BUG_ON(input >= MUX_INPUT_NUM_MUX);
+
+	spin_lock(&gpio_mux_lock);
+	__raw_writel(config, reg);
+	spin_unlock(&gpio_mux_lock);
+}
+EXPORT_SYMBOL(mxc_iomux_set_input);
diff --git a/arch/arm/mach-mx25/iomux.h b/arch/arm/mach-mx25/iomux.h
new file mode 100644
index 0000000..d54fe0f
--- /dev/null
+++ b/arch/arm/mach-mx25/iomux.h
@@ -0,0 +1,222 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MACH_MX25_IOMUX_H__
+#define __MACH_MX25_IOMUX_H__
+
+#include <linux/types.h>
+#include <asm/arch/gpio.h>
+#include "mx25_pins.h"
+
+/*!
+ * @file mach-mx25/iomux.h
+ *
+ * @brief I/O Muxing control definitions and functions
+ *
+ * @ingroup GPIO_MX25
+ */
+
+/*!
+ * IOMUX functions
+ * SW_MUX_CTL
+ */
+typedef enum iomux_pin_config {
+	MUX_CONFIG_FUNC = 0,	/*!< used as function */
+	MUX_CONFIG_ALT1,	/*!< used as alternate function 1 */
+	MUX_CONFIG_ALT2,	/*!< used as alternate function 2 */
+	MUX_CONFIG_ALT3,	/*!< used as alternate function 3 */
+	MUX_CONFIG_ALT4,	/*!< used as alternate function 4 */
+	MUX_CONFIG_ALT5,	/*!< used as alternate function 5 */
+	MUX_CONFIG_ALT6,	/*!< used as alternate function 6 */
+	MUX_CONFIG_ALT7,	/*!< used as alternate function 7 */
+	MUX_CONFIG_SION = 0x1 << 4,	/*!< used as LOOPBACK:MUX SION bit */
+	MUX_CONFIG_GPIO = MUX_CONFIG_ALT5,	/*!< used as GPIO */
+} iomux_pin_cfg_t;
+
+/*!
+ * IOMUX pad functions
+ * SW_PAD_CTL
+ */
+typedef enum iomux_pad_config {
+	PAD_CTL_DRV_3_3V = 0x0 << 13,
+	PAD_CTL_DRV_1_8V = 0x1 << 13,
+	PAD_CTL_HYS_CMOS = 0x0 << 8,
+	PAD_CTL_HYS_SCHMITZ = 0x1 << 8,
+	PAD_CTL_PKE_NONE = 0x0 << 7,
+	PAD_CTL_PKE_ENABLE = 0x1 << 7,
+	PAD_CTL_PUE_KEEPER = 0x0 << 6,
+	PAD_CTL_PUE_PUD = 0x1 << 6,
+	PAD_CTL_100K_PD = 0x0 << 4,
+	PAD_CTL_47K_PU = 0x1 << 4,
+	PAD_CTL_100K_PU = 0x2 << 4,
+	PAD_CTL_22K_PU = 0x3 << 4,
+	PAD_CTL_ODE_CMOS = 0x0 << 3,
+	PAD_CTL_ODE_OpenDrain = 0x1 << 3,
+	PAD_CTL_DRV_NORMAL = 0x0 << 1,
+	PAD_CTL_DRV_HIGH = 0x1 << 1,
+	PAD_CTL_DRV_MAX = 0x2 << 1,
+	PAD_CTL_SRE_SLOW = 0x0 << 0,
+	PAD_CTL_SRE_FAST = 0x1 << 0
+} iomux_pad_config_t;
+
+/*!
+ * IOMUX general purpose functions
+ * IOMUXC_GPR1
+ */
+typedef enum iomux_gp_func {
+	MUX_SDCTL_CSD0_SEL = 0x1 << 0,
+	MUX_SDCTL_CSD1_SEL = 0x1 << 1,
+} iomux_gp_func_t;
+
+/*!
+ * IOMUX SELECT_INPUT register index
+ * Base register is IOMUXSW_INPUT_CTL in iomux.c
+ */
+typedef enum iomux_input_select {
+	MUX_IN_AUDMUX_P4_INPUT_DA_AMX = 0,
+	MUX_IN_AUDMUX_P4_INPUT_DB_AMX,
+	MUX_IN_AUDMUX_P4_INPUT_RXCLK_AMX,
+	MUX_IN_AUDMUX_P4_INPUT_RXFS_AMX,
+	MUX_IN_AUDMUX_P4_INPUT_TXCLK_AMX,
+	MUX_IN_AUDMUX_P4_INPUT_TXFS_AMX,
+	MUX_IN_AUDMUX_P7_INPUT_DA_AMX,
+	MUX_IN_AUDMUX_P7_INPUT_TXFS_AMX,
+	MUX_IN_CAN1_IPP_IND_CANRX,
+	MUX_IN_CAN2_IPP_IND_CANRX,
+	MUX_IN_CSI_IPP_CSI_D_0,
+	MUX_IN_CSI_IPP_CSI_D_1,
+	MUX_IN_CSPI1_IPP_IND_SS3_B,
+	MUX_IN_CSPI2_IPP_CSPI_CLK_IN,
+	MUX_IN_CSPI2_IPP_IND_DATAREADY_B,
+	MUX_IN_CSPI2_IPP_IND_MISO,
+	MUX_IN_CSPI2_IPP_IND_MOSI,
+	MUX_IN_CSPI2_IPP_IND_SS0_B,
+	MUX_IN_CSPI2_IPP_IND_SS1_B,
+	MUX_IN_CSPI3_IPP_CSPI_CLK_IN,
+	MUX_IN_CSPI3_IPP_IND_DATAREADY_B,
+	MUX_IN_CSPI3_IPP_IND_MISO,
+	MUX_IN_CSPI3_IPP_IND_MOSI,
+	MUX_IN_CSPI3_IPP_IND_SS0_B,
+	MUX_IN_CSPI3_IPP_IND_SS1_B,
+	MUX_IN_CSPI3_IPP_IND_SS2_B,
+	MUX_IN_CSPI3_IPP_IND_SS3_B,
+	MUX_IN_ESDHC1_IPP_DAT4_IN,
+	MUX_IN_ESDHC1_IPP_DAT5_IN,
+	MUX_IN_ESDHC1_IPP_DAT6_IN,
+	MUX_IN_ESDHC1_IPP_DAT7_IN,
+	MUX_IN_ESDHC2_IPP_CARD_CLK_IN,
+	MUX_IN_ESDHC2_IPP_CMD_IN,
+	MUX_IN_ESDHC2_IPP_DAT0_IN,
+	MUX_IN_ESDHC2_IPP_DAT1_IN,
+	MUX_IN_ESDHC2_IPP_DAT2_IN,
+	MUX_IN_ESDHC2_IPP_DAT3_IN,
+	MUX_IN_ESDHC2_IPP_DAT4_IN,
+	MUX_IN_ESDHC2_IPP_DAT5_IN,
+	MUX_IN_ESDHC2_IPP_DAT6_IN,
+	MUX_IN_ESDHC2_IPP_DAT7_IN,
+	MUX_IN_FEC_FEC_COL,
+	MUX_IN_FEC_FEC_CRS,
+	MUX_IN_FEC_FEC_RDATA_2,
+	MUX_IN_FEC_FEC_RDATA_3,
+	MUX_IN_FEC_FEC_RX_CLK,
+	MUX_IN_FEC_FEC_RX_ER,
+	MUX_IN_I2C2_IPP_SCL_IN,
+	MUX_IN_I2C2_IPP_SDA_IN,
+	MUX_IN_I2C3_IPP_SCL_IN,
+	MUX_IN_I2C3_IPP_SDA_IN,
+	MUX_IN_KPP_IPP_IND_COL_4,
+	MUX_IN_KPP_IPP_IND_COL_5,
+	MUX_IN_KPP_IPP_IND_COL_6,
+	MUX_IN_KPP_IPP_IND_COL_7,
+	MUX_IN_KPP_IPP_IND_ROW_4,
+	MUX_IN_KPP_IPP_IND_ROW_5,
+	MUX_IN_KPP_IPP_IND_ROW_6,
+	MUX_IN_KPP_IPP_IND_ROW_7,
+	MUX_IN_SIM1_PIN_SIM_RCVD1_IN,
+	MUX_IN_SIM1_PIN_SIM_SIMPD1,
+	MUX_IN_SIM1_SIM_RCVD1_IO,
+	MUX_IN_SIM2_PIN_SIM_RCVD1_IN,
+	MUX_IN_SIM2_PIN_SIM_SIMPD1,
+	MUX_IN_SIM2_SIM_RCVD1_IO,
+	MUX_IN_UART3_IPP_UART_RTS_B,
+	MUX_IN_UART3_IPP_UART_RXD_MUX,
+	MUX_IN_UART4_IPP_UART_RTS_B,
+	MUX_IN_UART4_IPP_UART_RXD_MUX,
+	MUX_IN_UART5_IPP_UART_RTS_B,
+	MUX_IN_UART5_IPP_UART_RXD_MUX,
+	MUX_IN_USB_TOP_IPP_IND_OTG_USB_OC,
+	MUX_IN_USB_TOP_IPP_IND_UH2_USB_OC,
+} iomux_input_select_t;
+
+/*!
+ * IOMUX input functions
+ * SW_SELECT_INPUT bits 2-0
+ */
+typedef enum iomux_input_config {
+	INPUT_CTL_PATH0 = 0x0,
+	INPUT_CTL_PATH1,
+	INPUT_CTL_PATH2,
+	INPUT_CTL_PATH3,
+	INPUT_CTL_PATH4,
+	INPUT_CTL_PATH5,
+	INPUT_CTL_PATH6,
+	INPUT_CTL_PATH7,
+} iomux_input_cfg_t;
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b
+ *				#iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config);
+
+/*!
+ * This function configures input path.
+ *
+ * @param  input        index of input select register as defined in \b
+ * 				#iomux_input_select_t
+ * @param  config       the binary value of elements defined in \b
+ *				#iomux_input_cfg_t
+ */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config);
+#endif
diff --git a/arch/arm/mach-mx25/mm.c b/arch/arm/mach-mx25/mm.c
new file mode 100644
index 0000000..e62768a
--- /dev/null
+++ b/arch/arm/mach-mx25/mm.c
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <asm/hardware.h>
+#include <asm/pgtable.h>
+#include <asm/mach/map.h>
+
+/*!
+ * @file mach-mx25/mm.c
+ *
+ * @brief This file creates static mapping between physical to virtual memory.
+ *
+ * @ingroup Memory_MX25
+ */
+
+/*!
+ * This structure defines the MX25 memory map.
+ */
+static struct map_desc mxc_io_desc[] __initdata = {
+	{
+	 .virtual = IRAM_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(IRAM_BASE_ADDR),
+	 .length = IRAM_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = X_MEMC_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(X_MEMC_BASE_ADDR),
+	 .length = X_MEMC_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = NFC_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(NFC_BASE_ADDR),
+	 .length = NFC_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = ROMP_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(ROMP_BASE_ADDR),
+	 .length = ROMP_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = ASIC_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(ASIC_BASE_ADDR),
+	 .length = ASIC_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = AIPS1_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPS1_BASE_ADDR),
+	 .length = AIPS1_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = AIPS2_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPS2_BASE_ADDR),
+	 .length = AIPS2_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+};
+
+/*!
+ * This function initializes the memory map. It is called during the
+ * system startup to create static physical to virtual memory map for
+ * the IO modules.
+ */
+void __init mxc_map_io(void)
+{
+	iotable_init(mxc_io_desc, ARRAY_SIZE(mxc_io_desc));
+}
diff --git a/arch/arm/mach-mx25/mx25_3stack.c b/arch/arm/mach-mx25/mx25_3stack.c
new file mode 100644
index 0000000..ef61b53
--- /dev/null
+++ b/arch/arm/mach-mx25/mx25_3stack.c
@@ -0,0 +1,235 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/flash.h>
+#endif
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/memory.h>
+#include <asm/arch/gpio.h>
+
+#include "board-mx25_3stack.h"
+#include "crm_regs.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx25/mx25_3stack.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX25
+ */
+
+unsigned int mx25_3stack_board_io;
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+/* MTD NAND flash */
+
+#if defined(CONFIG_MTD_NAND_MXC) || defined(CONFIG_MTD_NAND_MXC_MODULE)
+
+static struct mtd_partition mxc_nand_partitions[] = {
+	{
+	 .name = "IPL-SPL",
+	 .offset = 0,
+	 .size = 256 * 1024},
+	{
+	 .name = "nand.kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 4 * 1024 * 1024},
+	{
+	 .name = "nand.rootfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 96 * 1024 * 1024},
+	{
+	 .name = "nand.configure",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 8 * 1024 * 1024},
+	{
+	 .name = "nand.userfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL},
+};
+
+static struct flash_platform_data mxc_nand_data = {
+	.parts = mxc_nand_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nand_partitions),
+	.width = 1,
+};
+
+static struct platform_device mxc_nand_mtd_device = {
+	.name = "mxc_nand_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_nand_data,
+		},
+};
+
+static void mxc_init_nand_mtd(void)
+{
+	if (__raw_readl(MXC_CCM_RCSR) & MXC_CCM_RCSR_NF16B)
+		mxc_nand_data.width = 2;
+
+	platform_device_register(&mxc_nand_mtd_device);
+}
+#else
+static inline void mxc_init_nand_mtd(void)
+{
+}
+#endif
+
+static struct spi_board_info mxc_spi_board_info[] __initdata = {
+	{
+	 .modalias = "cpld_spi",
+	 .max_speed_hz = 18000000,
+	 .bus_num = 1,
+	 .chip_select = 0,
+	 .mode = SPI_MODE_2,
+	 },
+};
+
+static struct i2c_board_info mxc_i2c_board_info[] __initdata = {
+	{
+	 .type = "mc34704",
+	 .addr = 0x54,
+	 },
+};
+
+#if  defined(CONFIG_SMSC911X) || defined(CONFIG_SMSC911X_MODULE)
+static struct resource smsc911x_resources[] = {
+	{
+	 .start = LAN9217_BASE_ADDR,
+	 .end = LAN9217_BASE_ADDR + 255,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MXC_EXP_IO_BASE,
+	 .flags = IORESOURCE_IRQ,
+	 }
+};
+
+static struct platform_device smsc_lan9217_device = {
+	.name = "smsc911x",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(smsc911x_resources),
+	.resource = smsc911x_resources,
+};
+
+static int __init mxc_init_enet(void)
+{
+	(void)platform_device_register(&smsc_lan9217_device);
+	return 0;
+}
+#else
+static int _init mxc_init_enet(void)
+{
+	return 0;
+}
+#endif
+
+late_initcall(mxc_init_enet);
+
+#if defined(CONFIG_FEC) || defined(CONFIG_FEC_MODULE)
+unsigned int expio_intr_fec;
+EXPORT_SYMBOL(expio_intr_fec);
+#endif
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	mxc_cpu_init();
+
+#ifdef CONFIG_DISCONTIGMEM
+	do {
+		int nid;
+		mi->nr_banks = MXC_NUMNODES;
+		for (nid = 0; nid < mi->nr_banks; nid++)
+			SET_NODE(mi, nid);
+	} while (0);
+#endif
+}
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	pr_info("AIPS1 VA base: 0x%x\n", IO_ADDRESS(AIPS1_BASE_ADDR));
+	mxc_cpu_common_init();
+	mxc_clocks_init();
+	mxc_gpio_init();
+	mx25_3stack_gpio_init();
+	early_console_setup(saved_command_line);
+#ifdef CONFIG_I2C
+	i2c_register_board_info(0, mxc_i2c_board_info,
+				ARRAY_SIZE(mxc_i2c_board_info));
+#endif
+	spi_register_board_info(mxc_spi_board_info,
+				ARRAY_SIZE(mxc_spi_board_info));
+	mxc_init_nand_mtd();
+}
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX25_3DS data structure.
+ */
+/* *INDENT-OFF* */
+MACHINE_START(MX25_3DS, "Freescale MX25 3-Stack Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.phys_io = AIPS1_BASE_ADDR,
+	.io_pg_offst = ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params = PHYS_OFFSET + 0x100,
+	.fixup = fixup_mxc_board,
+	.map_io = mxc_map_io,
+	.init_irq = mxc_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx25/mx25_3stack_cpld.c b/arch/arm/mach-mx25/mx25_3stack_cpld.c
new file mode 100644
index 0000000..5e62c77
--- /dev/null
+++ b/arch/arm/mach-mx25/mx25_3stack_cpld.c
@@ -0,0 +1,226 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <asm/hardware.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/gpio.h>
+#include "board-mx25_3stack.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx25/mx25_3stack_cpld.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX25
+ */
+
+extern int mxc_spi_poll_transfer(struct spi_device *spi,
+				 struct spi_transfer *t);
+
+struct spi_device *cpld_spi;
+
+/*!
+ * This function is used to tranfer data to CPLD regs over CSPI
+ */
+static inline int mx25_3ds_cpld_rw(u8 *buf, size_t len)
+{
+	struct spi_transfer t = {
+		.tx_buf = (const void *)buf,
+		.rx_buf = buf,
+		.len = len,
+		.cs_change = 0,
+		.delay_usecs = 0,
+	};
+	mxc_spi_poll_transfer(cpld_spi, &t);
+	return 0;
+}
+
+/*!
+ * This function is called to read a CPLD register over CSPI.
+ *
+ * @param        offset    number of the cpld register to be read
+ *
+ * @return       Returns 0 on success -1 on failure.
+ */
+unsigned int spi_cpld_read(unsigned int offset)
+{
+	unsigned int frame[2];
+	unsigned int reg_num = offset >> 1;
+	unsigned int data = 0;
+
+	frame[0] = (1 << 13) | ((reg_num & 0x0001FFFF) >> 5) | 0x00001000;
+	frame[1] = (((reg_num & 0x0000001F) << 27) | 0x0200001f);
+	mx25_3ds_cpld_rw((u8 *) frame, 2);
+	data = (frame[1] >> 6) & 0xFFFF;
+
+	reg_num = (offset + 2) >> 1;
+	frame[0] = (1 << 13) | ((reg_num & 0x0001FFFF) >> 5) | 0x00001000;
+	frame[1] = (((reg_num & 0x0000001F) << 27) | 0x0200001f);
+	mx25_3ds_cpld_rw((u8 *) frame, 2);
+
+	data |= (((frame[1] >> 6) & 0xFFFF) << 16);
+	return data;
+}
+
+/*!
+ * This function is called to write to a CPLD register over CSPI.
+ *
+ * @param        offset    number of the cpld register to be written
+ * @param        reg_val   value to be written
+ *
+ * @return       Returns 0 on success -1 on failure.
+ */
+unsigned int spi_cpld_write(unsigned int offset, unsigned int reg_val)
+{
+	unsigned int frame[2] = { 0, 0 };
+	unsigned int reg_num = offset >> 1;
+	unsigned int data = reg_val;
+
+	frame[0] = ((reg_num & 0x0001FFFF) >> 5) | 0x00001000;
+	frame[1] = (((reg_num & 0x0000001F) << 27) |
+		    ((data & 0x0000FFFF) << 6) | 0x03C00027);
+	mx25_3ds_cpld_rw((u8 *) frame, 2);
+
+	reg_num = (offset + 2) >> 1;
+	data = reg_val >> 16;
+	frame[0] = 0;
+	frame[1] = 0;
+	frame[0] = ((reg_num & 0x0001FFFF) >> 5) | 0x00001000;
+	frame[1] = (((reg_num & 0x0000001F) << 27) |
+		    ((data & 0x0000FFFF) << 6) | 0x03C00027);
+
+	mx25_3ds_cpld_rw((u8 *) frame, 2);
+
+	return 0;
+}
+
+static int __devinit mx25_3ds_cpld_probe(struct spi_device *spi)
+{
+	unsigned int i = 0;
+
+	spi->bits_per_word = 46;
+	cpld_spi = spi;
+
+	spi_setup(spi);
+	i = spi_cpld_read(CPLD_CODE_VER_REG);
+	pr_info("3-Stack Debug board detected, rev = 0x%04X\n", i);
+	spi_cpld_write(LED_SWITCH_REG, 0xFF);
+
+	/* disable the interrupt and clear the status */
+	spi_cpld_write(INTR_MASK_REG, 0);
+	spi_cpld_write(INTR_RESET_REG, 0xFFFF);
+	spi_cpld_write(INTR_RESET_REG, 0);
+	spi_cpld_write(INTR_MASK_REG, 0x1E);
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the CPLD callback functions.
+ */
+static struct spi_driver mx25_3ds_cpld_driver = {
+	.driver = {
+		   .name = "cpld_spi",
+		   .bus = &spi_bus_type,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = mx25_3ds_cpld_probe,
+};
+
+static int __init mx25_3ds_cpld_init(void)
+{
+	pr_info("Registering the CPLD Driver\n");
+	return spi_register_driver(&mx25_3ds_cpld_driver);
+}
+device_initcall(mx25_3ds_cpld_init);
+
+static void mxc_expio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 expio_irq;
+	struct irq_desc *d;
+
+	desc->chip->mask(irq);	/* irq = gpio irq number */
+
+	expio_irq = MXC_EXP_IO_BASE;
+
+	d = irq_desc + expio_irq;
+	if (unlikely(!(d->handle_irq))) {
+		printk(KERN_ERR "\nEXPIO irq: %d unhandled\n", expio_irq);
+		BUG();		/* oops */
+	}
+	d->handle_irq(expio_irq, d);
+
+	desc->chip->ack(irq);
+	desc->chip->unmask(irq);
+}
+
+/*
+ * Disable an expio pin's interrupt by setting the bit in the imr.
+ * @param irq		an expio virtual irq number
+ */
+static void expio_mask_irq(u32 irq)
+{
+}
+
+/*
+ * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
+ * @param irq		an expanded io virtual irq number
+ */
+static void expio_ack_irq(u32 irq)
+{
+	/* clear the interrupt status */
+	spi_cpld_write(INTR_RESET_REG, 1);
+	spi_cpld_write(INTR_RESET_REG, 0);
+}
+
+/*
+ * Enable a expio pin's interrupt by clearing the bit in the imr.
+ * @param irq		a expio virtual irq number
+ */
+static void expio_unmask_irq(u32 irq)
+{
+}
+
+static struct irq_chip expio_irq_chip = {
+	.ack = expio_ack_irq,
+	.mask = expio_mask_irq,
+	.unmask = expio_unmask_irq,
+};
+
+static int __init mxc_expio_init(void)
+{
+	int i;
+
+	/*
+	 * Configure INT line as GPIO input
+	 */
+	mxc_request_iomux(MX25_PIN_PWM, MUX_CONFIG_GPIO);
+	mxc_iomux_set_pad(MX25_PIN_PWM, PAD_CTL_PUE_PUD);
+	mxc_set_gpio_direction(MX25_PIN_PWM, 1);
+
+	for (i = MXC_EXP_IO_BASE; i < (MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES);
+	     i++) {
+		set_irq_chip(i, &expio_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_type(IOMUX_TO_IRQ(MX25_PIN_PWM), IRQT_LOW);
+	set_irq_chained_handler(IOMUX_TO_IRQ(MX25_PIN_PWM),
+				mxc_expio_irq_handler);
+
+	return 0;
+}
+
+arch_initcall(mxc_expio_init);
diff --git a/arch/arm/mach-mx25/mx25_3stack_gpio.c b/arch/arm/mach-mx25/mx25_3stack_gpio.c
new file mode 100644
index 0000000..66ed7f4
--- /dev/null
+++ b/arch/arm/mach-mx25/mx25_3stack_gpio.c
@@ -0,0 +1,1397 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/gpio.h>
+#include "board-mx25_3stack.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx25/mx25_3stack_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO_MX25
+ */
+
+/*!
+ * This system-wide GPIO function initializes the pins during system startup.
+ * All the statically linked device drivers should put the proper GPIO
+ * initialization code inside this function. It is called by
+ * \b fixup_mx25_3stack() during system startup. This function is board
+ * specific.
+ */
+void mx25_3stack_gpio_init(void)
+{
+}
+
+/*!
+ * Activate a UART port
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_active(int port, int no_irda)
+{
+	/*
+	 * Configure the IOMUX control registers for the UART signals
+	 */
+	switch (port) {
+	case 0:
+		/* UART 1 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_UART1_RXD, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART1_TXD, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART1_RTS, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART1_CTS, MUX_CONFIG_FUNC);
+		mxc_iomux_set_pad(MX25_PIN_UART1_RXD,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX25_PIN_UART1_TXD,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		mxc_iomux_set_pad(MX25_PIN_UART1_RTS,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX25_PIN_UART1_CTS,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+
+		break;
+	case 1:
+		/* UART 2 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_UART2_RXD, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART2_TXD, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART2_CTS, MUX_CONFIG_FUNC);
+		mxc_iomux_set_pad(MX25_PIN_UART2_RXD,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX25_PIN_UART2_TXD, PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		mxc_iomux_set_pad(MX25_PIN_UART2_RTS,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX25_PIN_UART2_CTS, PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		break;
+	case 2:
+		/* UART 3 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_KPP_ROW0, MUX_CONFIG_ALT1); /*RXD*/
+		mxc_request_iomux(MX25_PIN_KPP_ROW1, MUX_CONFIG_ALT1); /*TXD*/
+		mxc_request_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_ALT1); /*RTS*/
+		mxc_request_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_ALT1); /*CTS*/
+
+		mxc_iomux_set_input(MUX_IN_UART3_IPP_UART_RTS_B,
+				    INPUT_CTL_PATH1);
+		mxc_iomux_set_input(MUX_IN_UART3_IPP_UART_RXD_MUX,
+				    INPUT_CTL_PATH1);
+		break;
+	case 3:
+		/* UART 4 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_LD8, MUX_CONFIG_ALT2); /*RXD*/
+		mxc_request_iomux(MX25_PIN_LD9, MUX_CONFIG_ALT2); /*TXD*/
+		mxc_request_iomux(MX25_PIN_LD10, MUX_CONFIG_ALT2); /*RTS*/
+		mxc_request_iomux(MX25_PIN_LD11, MUX_CONFIG_ALT2); /*CTS*/
+
+		mxc_iomux_set_input(MUX_IN_UART4_IPP_UART_RTS_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_UART4_IPP_UART_RXD_MUX,
+				    INPUT_CTL_PATH0);
+	case 4:
+		/* UART 5 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_ALT1); /*RXD*/
+		mxc_request_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_ALT1); /*TXD*/
+		mxc_request_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_ALT1); /*RTS*/
+		mxc_request_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_ALT1); /*CTS*/
+
+		mxc_iomux_set_input(MUX_IN_UART5_IPP_UART_RTS_B,
+				    INPUT_CTL_PATH1);
+		mxc_iomux_set_input(MUX_IN_UART5_IPP_UART_RXD_MUX,
+				    INPUT_CTL_PATH1);
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_uart_active);
+
+/*!
+ * Inactivate a UART port
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_inactive(int port, int no_irda)
+{
+	switch (port) {
+	case 0:
+		mxc_request_gpio(MX25_PIN_UART1_RXD);
+		mxc_request_gpio(MX25_PIN_UART1_TXD);
+		mxc_request_gpio(MX25_PIN_UART1_RTS);
+		mxc_request_gpio(MX25_PIN_UART1_CTS);
+
+		mxc_free_iomux(MX25_PIN_UART1_RXD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART1_TXD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART1_RTS, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART1_CTS, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		mxc_request_gpio(MX25_PIN_UART2_RXD);
+		mxc_request_gpio(MX25_PIN_UART2_TXD);
+		mxc_request_gpio(MX25_PIN_UART2_RTS);
+		mxc_request_gpio(MX25_PIN_UART2_CTS);
+
+		mxc_free_iomux(MX25_PIN_UART2_RXD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART2_TXD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART2_CTS, MUX_CONFIG_GPIO);
+		break;
+	case 2:
+		mxc_request_gpio(MX25_PIN_KPP_ROW0);
+		mxc_request_gpio(MX25_PIN_KPP_ROW1);
+		mxc_request_gpio(MX25_PIN_KPP_ROW2);
+		mxc_request_gpio(MX25_PIN_KPP_ROW3);
+
+		mxc_free_iomux(MX25_PIN_KPP_ROW0, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_KPP_ROW1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_GPIO);
+		break;
+	case 3:
+		mxc_request_gpio(MX25_PIN_LD8);
+		mxc_request_gpio(MX25_PIN_LD9);
+		mxc_request_gpio(MX25_PIN_LD10);
+		mxc_request_gpio(MX25_PIN_LD11);
+
+		mxc_free_iomux(MX25_PIN_LD8, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD9, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD10, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD11, MUX_CONFIG_GPIO);
+		break;
+	case 4:
+		mxc_request_gpio(MX25_PIN_CSI_D2);
+		mxc_request_gpio(MX25_PIN_CSI_D3);
+		mxc_request_gpio(MX25_PIN_CSI_D4);
+		mxc_request_gpio(MX25_PIN_CSI_D5);
+
+		mxc_free_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_GPIO);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_uart_inactive);
+
+/*!
+ * Configure the IOMUX GPR register to receive shared SDMA UART events
+ *
+ * @param  port         a UART port
+ */
+void config_uartdma_event(int port)
+{
+}
+EXPORT_SYMBOL(config_uartdma_event);
+
+/*!
+ * Activate Keypad
+ */
+void gpio_keypad_active(void)
+{
+	mxc_request_iomux(MX25_PIN_KPP_ROW0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_ROW1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_COL0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_COL1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_COL2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_COL3, MUX_CONFIG_FUNC);
+
+#define KPP_PAD_CTL_ROW (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | \
+			 PAD_CTL_100K_PU)
+#define KPP_PAD_CTL_COL (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | \
+			 PAD_CTL_100K_PU | PAD_CTL_ODE_OpenDrain)
+
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW0, KPP_PAD_CTL_ROW);
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW1, KPP_PAD_CTL_ROW);
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW2, KPP_PAD_CTL_ROW);
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW3, KPP_PAD_CTL_ROW);
+	mxc_iomux_set_pad(MX25_PIN_KPP_COL0, KPP_PAD_CTL_COL);
+	mxc_iomux_set_pad(MX25_PIN_KPP_COL1, KPP_PAD_CTL_COL);
+	mxc_iomux_set_pad(MX25_PIN_KPP_COL2, KPP_PAD_CTL_COL);
+	mxc_iomux_set_pad(MX25_PIN_KPP_COL3, KPP_PAD_CTL_COL);
+
+#undef KPP_PAD_CTL_ROW
+#undef KPP_PAD_CTL_COL
+}
+EXPORT_SYMBOL(gpio_keypad_active);
+
+/*!
+ * Inactivate Keypad
+ */
+void gpio_keypad_inactive(void)
+{
+	mxc_request_gpio(MX25_PIN_KPP_ROW0);
+	mxc_request_gpio(MX25_PIN_KPP_ROW1);
+	mxc_request_gpio(MX25_PIN_KPP_ROW2);
+	mxc_request_gpio(MX25_PIN_KPP_ROW3);
+	mxc_request_gpio(MX25_PIN_KPP_COL0);
+	mxc_request_gpio(MX25_PIN_KPP_COL1);
+	mxc_request_gpio(MX25_PIN_KPP_COL2);
+	mxc_request_gpio(MX25_PIN_KPP_COL3);
+
+	mxc_free_iomux(MX25_PIN_KPP_ROW0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_ROW1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_COL0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_COL1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_COL2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_COL3, MUX_CONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_keypad_inactive);
+
+/*!
+ * Activate FEC
+ */
+void gpio_fec_active(void)
+{
+	mxc_request_iomux(MX25_PIN_FEC_TX_CLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_RX_DV, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_RDATA0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_TDATA0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_TX_EN, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_MDC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_MDIO, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_RDATA1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_TDATA1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_UART2_TXD, MUX_CONFIG_ALT2); /*TX_ERR*/
+	mxc_request_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_ALT2); /*COL*/
+	mxc_request_iomux(MX25_PIN_UART2_CTS, MUX_CONFIG_ALT2); /*RX_ERR*/
+	mxc_request_iomux(MX25_PIN_SD1_CMD, MUX_CONFIG_ALT2); /*RDATA2*/
+	mxc_request_iomux(MX25_PIN_SD1_CLK, MUX_CONFIG_ALT2); /*RDATA3*/
+	mxc_request_iomux(MX25_PIN_SD1_DATA0, MUX_CONFIG_ALT2); /*TDATA2*/
+	mxc_request_iomux(MX25_PIN_SD1_DATA1, MUX_CONFIG_ALT2); /*TDATA3*/
+	mxc_request_iomux(MX25_PIN_SD1_DATA2, MUX_CONFIG_ALT2); /*RX_CLK*/
+	mxc_request_iomux(MX25_PIN_SD1_DATA3, MUX_CONFIG_ALT2); /*CRS*/
+	mxc_request_iomux(MX25_PIN_A17, MUX_CONFIG_ALT5); /*FEC_EN*/
+
+#define FEC_PAD_CTL1 (PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE)
+#define FEC_PAD_CTL2 (PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PU)
+
+	mxc_iomux_set_pad(MX25_PIN_FEC_TX_CLK, FEC_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_FEC_RX_DV, FEC_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_FEC_RDATA0, FEC_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_FEC_TDATA0, FEC_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_FEC_TX_EN, FEC_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_FEC_MDC, FEC_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_FEC_MDIO, FEC_PAD_CTL1 |
+			  PAD_CTL_HYS_SCHMITZ | PAD_CTL_22K_PU);
+	mxc_iomux_set_pad(MX25_PIN_FEC_RDATA1, FEC_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_FEC_TDATA1, FEC_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_UART2_TXD, FEC_PAD_CTL2); /*TX_ERR*/
+	mxc_iomux_set_pad(MX25_PIN_UART2_RTS, FEC_PAD_CTL1); /*COL*/
+	mxc_iomux_set_pad(MX25_PIN_UART2_CTS, FEC_PAD_CTL1); /*RX_ERR*/
+	mxc_iomux_set_pad(MX25_PIN_SD1_CMD, FEC_PAD_CTL1); /*RDATA2*/
+	mxc_iomux_set_pad(MX25_PIN_SD1_CLK, FEC_PAD_CTL1 |
+			  PAD_CTL_HYS_SCHMITZ); /*RDATA3*/
+	mxc_iomux_set_pad(MX25_PIN_SD1_DATA0, FEC_PAD_CTL2); /*TDATA2*/
+	mxc_iomux_set_pad(MX25_PIN_SD1_DATA1, FEC_PAD_CTL2); /*TDATA3*/
+	mxc_iomux_set_pad(MX25_PIN_SD1_DATA2, FEC_PAD_CTL1); /*RX_CLK*/
+	mxc_iomux_set_pad(MX25_PIN_SD1_DATA3, FEC_PAD_CTL1); /*CRS*/
+	mxc_iomux_set_pad(MX25_PIN_A17, 0);
+
+	mxc_iomux_set_input(MUX_IN_FEC_FEC_COL, INPUT_CTL_PATH2);
+	mxc_iomux_set_input(MUX_IN_FEC_FEC_CRS, INPUT_CTL_PATH2);
+	mxc_iomux_set_input(MUX_IN_FEC_FEC_RDATA_2, INPUT_CTL_PATH2);
+	mxc_iomux_set_input(MUX_IN_FEC_FEC_RDATA_3, INPUT_CTL_PATH2);
+	mxc_iomux_set_input(MUX_IN_FEC_FEC_RX_CLK, INPUT_CTL_PATH2);
+	mxc_iomux_set_input(MUX_IN_FEC_FEC_RX_ER, INPUT_CTL_PATH2);
+
+	/* Configure enable as output */
+	mxc_set_gpio_direction(MX25_PIN_A17, 0); /*FEC_EN*/
+
+	/* FEC enable */
+	mxc_set_gpio_dataout(MX25_PIN_A17, 1);
+
+#undef FEC_PAD_CTL_COMMON
+#undef FEC_PAD_CTL1
+#undef FEC_PAD_CTL2
+}
+EXPORT_SYMBOL(gpio_fec_active);
+
+/*!
+ * Inactivate FEC
+ */
+void gpio_fec_inactive(void)
+{
+	mxc_request_gpio(MX25_PIN_FEC_TX_CLK);
+	mxc_request_gpio(MX25_PIN_FEC_RX_DV);
+	mxc_request_gpio(MX25_PIN_FEC_RDATA0);
+	mxc_request_gpio(MX25_PIN_FEC_TDATA0);
+	mxc_request_gpio(MX25_PIN_FEC_TX_EN);
+	mxc_request_gpio(MX25_PIN_FEC_MDC);
+	mxc_request_gpio(MX25_PIN_FEC_MDIO);
+	mxc_request_gpio(MX25_PIN_FEC_RDATA1);
+	mxc_request_gpio(MX25_PIN_FEC_TDATA1);
+	mxc_request_gpio(MX25_PIN_UART2_TXD);
+	mxc_request_gpio(MX25_PIN_UART2_RTS);
+	mxc_request_gpio(MX25_PIN_UART2_CTS);
+	mxc_request_gpio(MX25_PIN_SD1_CMD);
+	mxc_request_gpio(MX25_PIN_SD1_CLK);
+	mxc_request_gpio(MX25_PIN_SD1_DATA0);
+	mxc_request_gpio(MX25_PIN_SD1_DATA1);
+	mxc_request_gpio(MX25_PIN_SD1_DATA2);
+	mxc_request_gpio(MX25_PIN_SD1_DATA3);
+	mxc_request_gpio(MX25_PIN_A17);	/* FEC_EN */
+
+	mxc_free_iomux(MX25_PIN_FEC_TX_CLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_RX_DV, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_RDATA0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_TDATA0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_TX_EN, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_MDC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_MDIO, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_RDATA1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_TDATA1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_UART2_TXD, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_UART2_CTS, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_SD1_CMD, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_SD1_CLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_SD1_DATA0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_SD1_DATA1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_SD1_DATA2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_SD1_DATA3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_A17, MUX_CONFIG_GPIO);
+
+	/* FEC disable */
+	mxc_set_gpio_dataout(MX25_PIN_A17, 0);
+}
+EXPORT_SYMBOL(gpio_fec_inactive);
+
+/*!
+ * Activate an I2C device
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_active(int i2c_num)
+{
+#define I2C_PAD_CTL (PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | \
+		     PAD_CTL_PUE_PUD | PAD_CTL_100K_PU | PAD_CTL_ODE_OpenDrain)
+
+	switch (i2c_num) {
+	case 0:
+		/*I2C1*/
+		mxc_request_iomux(MX25_PIN_I2C1_CLK, MUX_CONFIG_SION);
+		mxc_request_iomux(MX25_PIN_I2C1_DAT, MUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX25_PIN_I2C1_CLK, I2C_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_I2C1_DAT, I2C_PAD_CTL);
+		break;
+	case 1:
+		/*I2C2*/
+		mxc_request_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_ALT2); /*SCL*/
+		mxc_request_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_ALT2); /*SDA*/
+		mxc_iomux_set_pad(MX25_PIN_GPIO_C, I2C_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_GPIO_D, I2C_PAD_CTL);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SCL_IN, INPUT_CTL_PATH1);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SDA_IN, INPUT_CTL_PATH1);
+
+#if 0
+		/* Or use FEC pins if it is not used */
+		mxc_request_iomux(MX25_PIN_FEC_RDATA1, MUX_CONFIG_ALT1); /*SCL*/
+		mxc_request_iomux(MX25_PIN_FEC_RX_DV, MUX_CONFIG_ALT1); /*SDA*/
+		mxc_iomux_set_pad(MX25_PIN_FEC_RDATA1, I2C_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_FEC_RX_DV, I2C_PAD_CTL);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SCL_IN, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SDA_IN, INPUT_CTL_PATH0);
+#endif
+
+		break;
+	case 2:
+		/*I2C3*/
+		mxc_request_iomux(MX25_PIN_HSYNC, MUX_CONFIG_ALT2); /*SCL*/
+		mxc_request_iomux(MX25_PIN_VSYNC, MUX_CONFIG_ALT2); /*SDA*/
+		mxc_iomux_set_pad(MX25_PIN_HSYNC, I2C_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_VSYNC, I2C_PAD_CTL);
+		mxc_iomux_set_input(MUX_IN_I2C3_IPP_SCL_IN, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_I2C3_IPP_SDA_IN, INPUT_CTL_PATH0);
+		break;
+	default:
+		break;
+	}
+#undef I2C_PAD_CTL
+}
+EXPORT_SYMBOL(gpio_i2c_active);
+
+/*!
+ * Inactivate an I2C device
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_inactive(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		/*I2C1*/
+		mxc_request_gpio(MX25_PIN_I2C1_CLK);
+		mxc_request_gpio(MX25_PIN_I2C1_DAT);
+		mxc_free_iomux(MX25_PIN_I2C1_CLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_I2C1_DAT, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		/*I2C2*/
+		mxc_request_gpio(MX25_PIN_GPIO_C);
+		mxc_request_gpio(MX25_PIN_GPIO_D);
+		mxc_free_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_GPIO);
+
+#if 0
+		/* Or use FEC pins if not in use */
+		mxc_request_gpio(MX25_PIN_FEC_RDATA1); /*SCL*/
+		mxc_request_gpio(MX25_PIN_FEC_RX_DV); /*SDA*/
+		mxc_free_iomux(MX25_PIN_FEC_RDATA1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_FEC_RX_DV, MUX_CONFIG_GPIO);
+#endif
+
+		break;
+	case 2:
+		/*I2C3*/
+		mxc_request_gpio(MX25_PIN_HSYNC);
+		mxc_request_gpio(MX25_PIN_VSYNC);
+		mxc_free_iomux(MX25_PIN_HSYNC, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_VSYNC, MUX_CONFIG_GPIO);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_i2c_inactive);
+
+/*!
+ * Activate a CSPI device
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_active(int cspi_mod)
+{
+#define SPI_PAD_CTL1 (PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE| \
+		      PAD_CTL_100K_PU)
+#define SPI_PAD_CTL2 (PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE| \
+		      PAD_CTL_PUE_PUD|PAD_CTL_100K_PU)
+
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		mxc_request_iomux(MX25_PIN_CSPI1_MOSI, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_MISO, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_SS0, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_SS1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_SCLK, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_RDY, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_ALT5); /*SS2*/
+		mxc_request_iomux(MX25_PIN_VSTBY_ACK, MUX_CONFIG_ALT2); /*SS3*/
+
+		/* Or if VSTBY_ACK is being used */
+		/*mxc_request_iomux(MX25_PIN_NF_CE0, MUX_CONFIG_ALT1);*/ /*SS3*/
+
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_MOSI, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_MISO, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_SS0, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_SS1, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_SCLK, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_RDY, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_GPIO_C, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_VSTBY_ACK, SPI_PAD_CTL1);
+
+		mxc_iomux_set_input(MUX_IN_CSPI1_IPP_IND_SS3_B,
+				    INPUT_CTL_PATH1);
+		break;
+	case 1:
+		/* SPI2 */
+#if 0
+		mxc_request_iomux(MX25_PIN_LD12, MUX_CONFIG_ALT2); /*MOSI*/
+		mxc_request_iomux(MX25_PIN_LD13, MUX_CONFIG_ALT2); /*MISO*/
+		mxc_request_iomux(MX25_PIN_LD14, MUX_CONFIG_ALT2); /*SCLK*/
+		mxc_request_iomux(MX25_PIN_LD15, MUX_CONFIG_ALT2); /*RDY*/
+		mxc_request_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_ALT2); /*SS0*/
+		mxc_request_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_ALT2); /*SS1*/
+		mxc_request_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_ALT7); /*SS2*/
+		mxc_request_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_ALT6); /*SS3*/
+
+		mxc_iomux_set_pad(MX25_PIN_LD12, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_LD13, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_LD14, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_LD15, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_OE_ACD, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_CONTRAST, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_GPIO_C, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_UART2_RTS, SPI_PAD_CTL2);
+
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_CSPI_CLK_IN,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_DATAREADY_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_MISO, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_MOSI, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_SS0_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_SS1_B,
+				    INPUT_CTL_PATH0);
+#endif
+		break;
+	case 2:
+		/* SPI3 */
+#if 0
+		mxc_request_iomux(MX25_PIN_EB0, MUX_CONFIG_ALT6); /*SS0*/
+		mxc_request_iomux(MX25_PIN_EB1, MUX_CONFIG_ALT6); /*SS1*/
+		mxc_request_iomux(MX25_PIN_CS4, MUX_CONFIG_ALT6); /*MOSI*/
+		mxc_request_iomux(MX25_PIN_CS5, MUX_CONFIG_ALT6); /*MISO*/
+		mxc_request_iomux(MX25_PIN_ECB, MUX_CONFIG_ALT6); /*SCLK*/
+		mxc_request_iomux(MX25_PIN_LBA, MUX_CONFIG_ALT6); /*RDY*/
+		mxc_request_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_ALT7); /*SS2*/
+		mxc_request_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_ALT7); /*SS3*/
+
+		mxc_iomux_set_pad(MX25_PIN_EB0, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_EB1, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CS4, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CS5, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_ECB, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_LBA, SPI_PAD_CTL1);
+
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_CSPI_CLK_IN,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_DATAREADY_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_MISO, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_MOSI, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_SS0_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_SS1_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_SS2_B,
+				    INPUT_CTL_PATH1);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_SS3_B,
+				    INPUT_CTL_PATH0);
+#endif
+		break;
+	default:
+		break;
+	}
+#undef SPI_PAD_CTL1
+#undef SPI_PAD_CTL2
+}
+EXPORT_SYMBOL(gpio_spi_active);
+
+/*!
+ * Inactivate a CSPI device
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_inactive(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		mxc_request_gpio(MX25_PIN_CSPI1_MOSI);
+		mxc_request_gpio(MX25_PIN_CSPI1_MISO);
+		mxc_request_gpio(MX25_PIN_CSPI1_SS0);
+		mxc_request_gpio(MX25_PIN_CSPI1_SS1);
+		mxc_request_gpio(MX25_PIN_CSPI1_SCLK);
+		mxc_request_gpio(MX25_PIN_CSPI1_RDY);
+		mxc_request_gpio(MX25_PIN_GPIO_C); /*SS2*/
+		mxc_request_gpio(MX25_PIN_VSTBY_ACK); /*SS3*/
+
+		mxc_free_iomux(MX25_PIN_CSPI1_MOSI, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_MISO, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_SS0, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_SS1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_SCLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_RDY, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_VSTBY_ACK, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		/* SPI2 */
+		mxc_request_gpio(MX25_PIN_LD12); /*MOSI*/
+		mxc_request_gpio(MX25_PIN_LD13); /*MISO*/
+		mxc_request_gpio(MX25_PIN_LD14); /*SCLK*/
+		mxc_request_gpio(MX25_PIN_LD15); /*RDY*/
+		mxc_request_gpio(MX25_PIN_OE_ACD); /*SS0*/
+		mxc_request_gpio(MX25_PIN_CONTRAST); /*SS1*/
+		mxc_request_gpio(MX25_PIN_GPIO_C); /*SS2*/
+		mxc_request_gpio(MX25_PIN_UART2_RTS); /*SS3*/
+
+		mxc_free_iomux(MX25_PIN_LD12, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD13, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD14, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD15, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_GPIO);
+		break;
+	case 2:
+		/* SPI3 */
+		mxc_request_gpio(MX25_PIN_EB0); /*SS0*/
+		mxc_request_gpio(MX25_PIN_EB1); /*SS1*/
+		mxc_request_gpio(MX25_PIN_CS4); /*MOSI*/
+		mxc_request_gpio(MX25_PIN_CS5); /*MISO*/
+		mxc_request_gpio(MX25_PIN_ECB); /*SCLK*/
+		mxc_request_gpio(MX25_PIN_LBA); /*RDY*/
+		mxc_request_gpio(MX25_PIN_GPIO_D); /*SS2*/
+		mxc_request_gpio(MX25_PIN_CSI_D9); /*SS3*/
+
+		mxc_free_iomux(MX25_PIN_EB0, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_EB1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CS4, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CS5, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_ECB, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LBA, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_GPIO);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_spi_inactive);
+
+/*!
+ * Activate LCD
+ */
+void gpio_lcd_active(void)
+{
+	mxc_request_iomux(MX25_PIN_LD0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD3, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD4, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD5, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD6, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD7, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD8, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD9, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD10, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD11, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD12, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD13, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD14, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD15, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_GPIO_E, MUX_CONFIG_ALT2); /*D16*/
+	mxc_request_iomux(MX25_PIN_GPIO_F, MUX_CONFIG_ALT2); /*D17*/
+	mxc_request_iomux(MX25_PIN_HSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_VSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LSCLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_PWM, MUX_CONFIG_ALT5); /*DEBUG_INT_B*/
+
+#define LCD_PAD_CTL (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | PAD_CTL_100K_PU)
+	mxc_iomux_set_pad(MX25_PIN_LD0, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD1, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD2, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD3, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD4, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD5, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD6, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD7, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD8, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD9, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD10, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD11, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD12, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD13, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD14, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD15, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_GPIO_E, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_GPIO_F, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_HSYNC, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_VSYNC, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LSCLK, LCD_PAD_CTL | PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_OE_ACD, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CONTRAST, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_PWM, 0);
+}
+EXPORT_SYMBOL(gpio_lcd_active);
+
+/*!
+ * Inactivate LCD
+ */
+void gpio_lcd_inactive(void)
+{
+	mxc_request_gpio(MX25_PIN_LD0);
+	mxc_request_gpio(MX25_PIN_LD1);
+	mxc_request_gpio(MX25_PIN_LD2);
+	mxc_request_gpio(MX25_PIN_LD3);
+	mxc_request_gpio(MX25_PIN_LD4);
+	mxc_request_gpio(MX25_PIN_LD5);
+	mxc_request_gpio(MX25_PIN_LD6);
+	mxc_request_gpio(MX25_PIN_LD7);
+	mxc_request_gpio(MX25_PIN_LD8);
+	mxc_request_gpio(MX25_PIN_LD9);
+	mxc_request_gpio(MX25_PIN_LD10);
+	mxc_request_gpio(MX25_PIN_LD11);
+	mxc_request_gpio(MX25_PIN_LD12);
+	mxc_request_gpio(MX25_PIN_LD13);
+	mxc_request_gpio(MX25_PIN_LD14);
+	mxc_request_gpio(MX25_PIN_LD15);
+	mxc_request_gpio(MX25_PIN_GPIO_E); /*D16*/
+	mxc_request_gpio(MX25_PIN_GPIO_F); /*D17*/
+	mxc_request_gpio(MX25_PIN_HSYNC);
+	mxc_request_gpio(MX25_PIN_VSYNC);
+	mxc_request_gpio(MX25_PIN_LSCLK);
+	mxc_request_gpio(MX25_PIN_OE_ACD);
+	mxc_request_gpio(MX25_PIN_CONTRAST);
+
+	mxc_free_iomux(MX25_PIN_LD0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD4, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD5, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD6, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD7, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD8, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD9, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD10, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD11, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD12, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD13, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD14, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD15, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_GPIO_E, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_GPIO_F, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_HSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_VSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LSCLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_lcd_inactive);
+
+/*!
+ * Activate SDHC
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_active(int module)
+{
+#define SDHC_PAD_CTL (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | \
+		      PAD_CTL_47K_PU | PAD_CTL_SRE_FAST)
+
+	switch (module) {
+	case 0:
+		/* SDHC1 */
+		mxc_request_iomux(MX25_PIN_SD1_CMD,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX25_PIN_SD1_CLK,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX25_PIN_SD1_DATA0, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_SD1_DATA1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_SD1_DATA2, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_SD1_DATA3, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_D15, MUX_CONFIG_ALT6); /*DAT7*/
+		mxc_request_iomux(MX25_PIN_D14, MUX_CONFIG_ALT6); /*DAT6*/
+		mxc_request_iomux(MX25_PIN_D13, MUX_CONFIG_ALT6); /*DAT5*/
+		mxc_request_iomux(MX25_PIN_D12, MUX_CONFIG_ALT6); /*DAT4*/
+		mxc_request_iomux(MX25_PIN_A14, MUX_CONFIG_ALT5); /*SD1_WP*/
+		mxc_request_iomux(MX25_PIN_A15, MUX_CONFIG_ALT5); /*SD1_DET*/
+
+#if 0
+		/* Or if UART2 pins are not in use */
+		mxc_request_iomux(MX25_PIN_UART2_RXD, MUX_CONFIG_ALT1); /*DAT7*/
+		mxc_request_iomux(MX25_PIN_UART2_TXD, MUX_CONFIG_ALT1); /*DAT6*/
+		mxc_request_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_ALT1); /*DAT5*/
+		mxc_request_iomux(MX25_PIN_UART2_CTS, MUX_CONFIG_ALT1); /*DAT4*/
+#endif
+
+		mxc_iomux_set_pad(MX25_PIN_SD1_CMD, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_CLK, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_DATA0, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_DATA1, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_DATA2, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_DATA3, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_D15, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_D14, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_D13, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_D12, SDHC_PAD_CTL);
+
+		/* Set write protect and card detect gpio as inputs */
+		mxc_set_gpio_direction(MX25_PIN_A14, 1); /*SD1_WP*/
+		mxc_set_gpio_direction(MX25_PIN_A15, 1); /*SD1_DET*/
+
+		break;
+	case 1:
+		/* SDHC2 */
+		mxc_request_iomux(MX25_PIN_LD8,
+				  MUX_CONFIG_ALT6 | MUX_CONFIG_SION); /*CMD*/
+		mxc_request_iomux(MX25_PIN_LD9,
+				  MUX_CONFIG_ALT6 | MUX_CONFIG_SION); /*CLK*/
+		mxc_request_iomux(MX25_PIN_LD10, MUX_CONFIG_ALT6); /*DAT0*/
+		mxc_request_iomux(MX25_PIN_LD11, MUX_CONFIG_ALT6); /*DAT1*/
+		mxc_request_iomux(MX25_PIN_LD12, MUX_CONFIG_ALT6); /*DAT2*/
+		mxc_request_iomux(MX25_PIN_LD13, MUX_CONFIG_ALT6); /*DAT3*/
+		mxc_request_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_ALT2); /*DAT4*/
+		mxc_request_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_ALT2); /*DAT5*/
+		mxc_request_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_ALT2); /*DAT6*/
+		mxc_request_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_ALT2); /*DAT7*/
+
+#if 0
+		/* Or if CSI pins are not in use */
+		mxc_request_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_ALT2); /*CMD*/
+		mxc_request_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_ALT2); /*CLK*/
+		mxc_request_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_ALT2); /*DAT0*/
+		mxc_request_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_ALT2); /*DAT1*/
+		mxc_request_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_ALT2); /*DAT2*/
+		/*DAT3*/
+		mxc_request_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_ALT2);
+#endif
+
+		mxc_iomux_set_pad(MX25_PIN_LD8, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD9, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD10, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD11, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD12, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD13, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_CSI_D2, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_CSI_D3, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_CSI_D4, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_CSI_D5, SDHC_PAD_CTL);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+/*!
+ * Inactivate SDHC
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_inactive(int module)
+{
+	switch (module) {
+	case 0:
+		/* SDHC1 */
+		mxc_request_gpio(MX25_PIN_SD1_CMD);
+		mxc_request_gpio(MX25_PIN_SD1_CLK);
+		mxc_request_gpio(MX25_PIN_SD1_DATA0);
+		mxc_request_gpio(MX25_PIN_SD1_DATA1);
+		mxc_request_gpio(MX25_PIN_SD1_DATA2);
+		mxc_request_gpio(MX25_PIN_SD1_DATA3);
+		mxc_request_gpio(MX25_PIN_D15); /*DAT7*/
+		mxc_request_gpio(MX25_PIN_D14); /*DAT6*/
+		mxc_request_gpio(MX25_PIN_D13); /*DAT5*/
+		mxc_request_gpio(MX25_PIN_D12); /*DAT4*/
+
+		mxc_free_iomux(MX25_PIN_SD1_CMD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_CLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_DATA0, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_DATA1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_DATA2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_DATA3, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_D15, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_D14, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_D13, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_D12, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		/* SDHC2 */
+		mxc_request_gpio(MX25_PIN_LD8); /*CMD*/
+		mxc_request_gpio(MX25_PIN_LD9); /*CLK*/
+		mxc_request_gpio(MX25_PIN_LD10); /*DAT0*/
+		mxc_request_gpio(MX25_PIN_LD11); /*DAT1*/
+		mxc_request_gpio(MX25_PIN_LD12); /*DAT2*/
+		mxc_request_gpio(MX25_PIN_LD13); /*DAT3*/
+		mxc_request_gpio(MX25_PIN_CSI_D2); /*DAT4*/
+		mxc_request_gpio(MX25_PIN_CSI_D3); /*DAT5*/
+		mxc_request_gpio(MX25_PIN_CSI_D4); /*DAT6*/
+		mxc_request_gpio(MX25_PIN_CSI_D5); /*DAT7*/
+
+		mxc_free_iomux(MX25_PIN_LD8, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD9, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD10, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD11, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD12, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD13, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_GPIO);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+/*
+ *  USB Host2
+ */
+int gpio_usbh2_active(void)
+{
+	mxc_request_iomux(MX25_PIN_D9, MUX_CONFIG_ALT6); /*PWR*/
+	mxc_request_iomux(MX25_PIN_D8, MUX_CONFIG_ALT6); /*OC*/
+	mxc_request_iomux(MX25_PIN_LD0, MUX_CONFIG_ALT6); /*CLK*/
+	mxc_request_iomux(MX25_PIN_LD1, MUX_CONFIG_ALT6); /*DIR*/
+	mxc_request_iomux(MX25_PIN_LD2, MUX_CONFIG_ALT6); /*STP*/
+	mxc_request_iomux(MX25_PIN_LD3, MUX_CONFIG_ALT6); /*NXT*/
+	mxc_request_iomux(MX25_PIN_LD4, MUX_CONFIG_ALT6); /*DATA0*/
+	mxc_request_iomux(MX25_PIN_LD5, MUX_CONFIG_ALT6); /*DATA1*/
+	mxc_request_iomux(MX25_PIN_LD6, MUX_CONFIG_ALT6); /*DATA2*/
+	mxc_request_iomux(MX25_PIN_LD7, MUX_CONFIG_ALT6); /*DATA3*/
+	mxc_request_iomux(MX25_PIN_HSYNC, MUX_CONFIG_ALT6); /*DATA4*/
+	mxc_request_iomux(MX25_PIN_VSYNC, MUX_CONFIG_ALT6); /*DATA5*/
+	mxc_request_iomux(MX25_PIN_LSCLK, MUX_CONFIG_ALT6); /*DATA6*/
+	mxc_request_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_ALT6); /*DATA7*/
+
+	/* If D9-D8 are used */
+#if 0
+	mxc_request_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_ALT6); /*PWR*/
+	mxc_request_iomux(MX25_PIN_PWM, MUX_CONFIG_ALT6); /*OC*/
+#endif
+
+	mxc_iomux_set_input(MUX_IN_USB_TOP_IPP_IND_UH2_USB_OC, INPUT_CTL_PATH0);
+
+#define USB_PAD_CTL_SLOW (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | \
+			  PAD_CTL_100K_PU)
+#define USB_PAD_CTL_FAST (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | \
+			  PAD_CTL_100K_PU | PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST)
+
+	mxc_iomux_set_pad(MX25_PIN_D9, PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+	mxc_iomux_set_pad(MX25_PIN_D8, PAD_CTL_HYS_SCHMITZ |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD);
+	mxc_iomux_set_pad(MX25_PIN_LD0, USB_PAD_CTL_SLOW);
+	mxc_iomux_set_pad(MX25_PIN_LD1, USB_PAD_CTL_SLOW);
+	mxc_iomux_set_pad(MX25_PIN_LD2, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_LD3, USB_PAD_CTL_SLOW);
+	mxc_iomux_set_pad(MX25_PIN_LD4, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_LD5, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_LD6, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_LD7, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_HSYNC, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_VSYNC, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_LSCLK, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_OE_ACD, USB_PAD_CTL_FAST);
+
+#undef USB_PAD_CTL_SLOW
+#undef USB_PAD_CTL_FAST
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbh2_active);
+
+void gpio_usbh2_inactive(void)
+{
+	mxc_request_gpio(MX25_PIN_D9); /*PWR*/
+	mxc_request_gpio(MX25_PIN_D8); /*OC*/
+	mxc_request_gpio(MX25_PIN_LD0); /*CLK*/
+	mxc_request_gpio(MX25_PIN_LD1); /*DIR*/
+	mxc_request_gpio(MX25_PIN_LD2); /*STP*/
+	mxc_request_gpio(MX25_PIN_LD3); /*NXT*/
+	mxc_request_gpio(MX25_PIN_LD4); /*DATA0*/
+	mxc_request_gpio(MX25_PIN_LD5); /*DATA1*/
+	mxc_request_gpio(MX25_PIN_LD6); /*DATA2*/
+	mxc_request_gpio(MX25_PIN_LD7); /*DATA3*/
+	mxc_request_gpio(MX25_PIN_HSYNC); /*DATA4*/
+	mxc_request_gpio(MX25_PIN_VSYNC); /*DATA5*/
+	mxc_request_gpio(MX25_PIN_LSCLK); /*DATA6*/
+	mxc_request_gpio(MX25_PIN_OE_ACD); /*DATA7*/
+
+	mxc_free_iomux(MX25_PIN_D9, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_D8, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD4, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD5, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD6, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD7, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_HSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_VSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LSCLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_GPIO);
+}
+
+/*
+ *  USB OTG UTMI
+ */
+int gpio_usbotg_utmi_active(void)
+{
+	mxc_request_iomux(MX25_PIN_D11, MUX_CONFIG_ALT6); /*PWR*/
+	mxc_request_iomux(MX25_PIN_D10, MUX_CONFIG_ALT6); /*OC*/
+	mxc_request_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_ALT6); /*DATA0*/
+	mxc_request_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_ALT6); /*DATA1*/
+	mxc_request_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_ALT6); /*DATA2*/
+	mxc_request_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_ALT6); /*DATA3*/
+	mxc_request_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_ALT6); /*DATA4*/
+	mxc_request_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_ALT6); /*DATA5*/
+	mxc_request_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_ALT6); /*DATA6*/
+	mxc_request_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_ALT6); /*DATA7*/
+	mxc_request_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_ALT6); /*DIR*/
+	mxc_request_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_ALT6); /*STP*/
+	mxc_request_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_ALT6); /*NXT*/
+	mxc_request_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_ALT6); /*CLK*/
+
+#if 0
+	/*if D10, D11 are in use */
+	mxc_request_iomux(MX25_PIN_GPIO_A, MUX_CONFIG_ALT2); /*PWR*/
+	mxc_request_iomux(MX25_PIN_GPIO_B, MUX_CONFIG_ALT2); /*OC*/
+#endif
+
+#define USB_PAD_CTL_SLOW (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | \
+			  PAD_CTL_100K_PU)
+#define USB_PAD_CTL_FAST (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | \
+			  PAD_CTL_100K_PU | PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST)
+
+	mxc_iomux_set_pad(MX25_PIN_D11, USB_PAD_CTL_SLOW);
+	mxc_iomux_set_pad(MX25_PIN_D10, PAD_CTL_HYS_SCHMITZ |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D2, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D3, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D4, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D5, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D6, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D7, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D8, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D9, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_CSI_MCLK, USB_PAD_CTL_SLOW);
+	mxc_iomux_set_pad(MX25_PIN_CSI_VSYNC, USB_PAD_CTL_FAST);
+	mxc_iomux_set_pad(MX25_PIN_CSI_HSYNC, USB_PAD_CTL_SLOW);
+	mxc_iomux_set_pad(MX25_PIN_CSI_PIXCLK, USB_PAD_CTL_SLOW);
+
+	mxc_iomux_set_input(MUX_IN_USB_TOP_IPP_IND_OTG_USB_OC, INPUT_CTL_PATH0);
+
+#undef USB_PAD_CTL_SLOW
+#undef USB_PAD_CTL_FAST
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbotg_utmi_active);
+
+void gpio_usbotg_utmi_inactive(void)
+{
+	mxc_request_gpio(MX25_PIN_D11); /*PWR*/
+	mxc_request_gpio(MX25_PIN_D10); /*OC*/
+	mxc_request_gpio(MX25_PIN_CSI_D2); /*DATA0*/
+	mxc_request_gpio(MX25_PIN_CSI_D3); /*DATA1*/
+	mxc_request_gpio(MX25_PIN_CSI_D4); /*DATA2*/
+	mxc_request_gpio(MX25_PIN_CSI_D5); /*DATA3*/
+	mxc_request_gpio(MX25_PIN_CSI_D6); /*DATA4*/
+	mxc_request_gpio(MX25_PIN_CSI_D7); /*DATA5*/
+	mxc_request_gpio(MX25_PIN_CSI_D8); /*DATA6*/
+	mxc_request_gpio(MX25_PIN_CSI_D9); /*DATA7*/
+	mxc_request_gpio(MX25_PIN_CSI_MCLK); /*DIR*/
+	mxc_request_gpio(MX25_PIN_CSI_VSYNC); /*STP*/
+	mxc_request_gpio(MX25_PIN_CSI_HSYNC); /*NXT*/
+	mxc_request_gpio(MX25_PIN_CSI_PIXCLK); /*CLK*/
+
+	mxc_free_iomux(MX25_PIN_D11, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_D10, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_usbotg_utmi_inactive);
+
+/*!
+ * Activate camera sensor
+ */
+void gpio_sensor_active(void)
+{
+	mxc_request_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_ALT3); /*CSI D0*/
+	mxc_request_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_ALT3); /*CSI D1*/
+	mxc_request_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD7, MUX_CONFIG_ALT2); /*CSI D10*/
+	mxc_request_iomux(MX25_PIN_LD6, MUX_CONFIG_ALT2); /*CSI D11*/
+	mxc_request_iomux(MX25_PIN_LD5, MUX_CONFIG_ALT2); /*CSI D12*/
+	mxc_request_iomux(MX25_PIN_LD4, MUX_CONFIG_ALT2); /*CSI D13*/
+	mxc_request_iomux(MX25_PIN_LD3, MUX_CONFIG_ALT2); /*CSI D14*/
+	mxc_request_iomux(MX25_PIN_LD2, MUX_CONFIG_ALT2); /*CSI D15*/
+	mxc_request_iomux(MX25_PIN_A19, MUX_CONFIG_ALT5); /*CSI_PWDN*/
+#if 0
+	/* Or if uart1 is not used */
+	mxc_request_iomux(MX25_PIN_UART1_RTS, MUX_CONFIG_ALT1); /*CSI D0*/
+	mxc_request_iomux(MX25_PIN_UART1_CTS, MUX_CONFIG_ALT1); /*CSI D1*/
+#endif
+
+#define CSI_PAD_CTL1 (PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PU)
+#define CSI_PAD_CTL2 (PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | \
+		      PAD_CTL_100K_PU)
+
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW2, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW3, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D2, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D3, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D4, CSI_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D5, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D6, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D7, CSI_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D8, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D9, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_HSYNC, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_MCLK, PAD_CTL_PKE_ENABLE |
+			  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU | PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_CSI_PIXCLK, CSI_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_CSI_VSYNC, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_LD7, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_LD6, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_LD5, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_LD4, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_LD3, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_LD2, CSI_PAD_CTL1);
+}
+EXPORT_SYMBOL(gpio_sensor_active);
+
+/*!
+ * Inactivate camera sensor
+ */
+void gpio_sensor_inactive(void)
+{
+	mxc_request_gpio(MX25_PIN_KPP_ROW2);
+	mxc_request_gpio(MX25_PIN_KPP_ROW3);
+	mxc_request_gpio(MX25_PIN_CSI_D2);
+	mxc_request_gpio(MX25_PIN_CSI_D3);
+	mxc_request_gpio(MX25_PIN_CSI_D4);
+	mxc_request_gpio(MX25_PIN_CSI_D5);
+	mxc_request_gpio(MX25_PIN_CSI_D6);
+	mxc_request_gpio(MX25_PIN_CSI_D7);
+	mxc_request_gpio(MX25_PIN_CSI_D8);
+	mxc_request_gpio(MX25_PIN_CSI_D9);
+	mxc_request_gpio(MX25_PIN_CSI_HSYNC);
+	mxc_request_gpio(MX25_PIN_CSI_MCLK);
+	mxc_request_gpio(MX25_PIN_CSI_PIXCLK);
+	mxc_request_gpio(MX25_PIN_CSI_VSYNC);
+	mxc_request_gpio(MX25_PIN_LD7);
+	mxc_request_gpio(MX25_PIN_LD6);
+	mxc_request_gpio(MX25_PIN_LD5);
+	mxc_request_gpio(MX25_PIN_LD4);
+	mxc_request_gpio(MX25_PIN_LD3);
+	mxc_request_gpio(MX25_PIN_LD2);
+	mxc_request_gpio(MX25_PIN_A19); /*CSI_PWDN*/
+
+	mxc_free_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD7, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD6, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD5, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD4, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_A19, MUX_CONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_sensor_inactive);
+
+/*!
+ * Activate ESAI ports to enable surround sound I/O
+ */
+void gpio_activate_esai_ports(void)
+{
+	mxc_request_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_ALT3); /*SCKR*/
+	mxc_request_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_ALT3); /*FSR*/
+	mxc_request_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_ALT3); /*HCKR*/
+	mxc_request_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_ALT3); /*SCKT*/
+	mxc_request_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_ALT3); /*FST*/
+	mxc_request_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_ALT3); /*HCKT*/
+	mxc_request_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_ALT3); /*TX5_RX0*/
+	mxc_request_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_ALT3); /*TX4_RX1*/
+	mxc_request_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_ALT3); /*TX3_RX2*/
+	mxc_request_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_ALT3); /*TX2_RX3*/
+	mxc_request_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_ALT3); /*TX1*/
+	mxc_request_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_ALT3); /*TX0*/
+
+#define ESAI_PAD_CTL (PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | \
+		      PAD_CTL_100K_PU | PAD_CTL_PUE_PUD)
+	mxc_iomux_set_pad(MX25_PIN_CSI_D2, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D3, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D4, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D5, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D6, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D7, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D8, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D9, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_MCLK, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_VSYNC, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_HSYNC, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_PIXCLK, ESAI_PAD_CTL);
+
+#undef ESAI_PAD_CTL
+}
+EXPORT_SYMBOL(gpio_activate_esai_ports);
+
+/*!
+ * Inactivate ESAI ports to disable surround sound I/O
+ */
+void gpio_inactivate_esai_ports(void)
+{
+	mxc_request_gpio(MX25_PIN_CSI_D2); /*SCKR*/
+	mxc_request_gpio(MX25_PIN_CSI_D3); /*FSR*/
+	mxc_request_gpio(MX25_PIN_CSI_D4); /*HCKR*/
+	mxc_request_gpio(MX25_PIN_CSI_D5); /*SCKT*/
+	mxc_request_gpio(MX25_PIN_CSI_D6); /*FST*/
+	mxc_request_gpio(MX25_PIN_CSI_D7); /*HCKT*/
+	mxc_request_gpio(MX25_PIN_CSI_D8); /*TX5_RX0*/
+	mxc_request_gpio(MX25_PIN_CSI_D9); /*TX4_RX1*/
+	mxc_request_gpio(MX25_PIN_CSI_MCLK); /*TX3_RX2*/
+	mxc_request_gpio(MX25_PIN_CSI_VSYNC); /*TX2_RX3*/
+	mxc_request_gpio(MX25_PIN_CSI_HSYNC); /*TX1*/
+	mxc_request_gpio(MX25_PIN_CSI_PIXCLK); /*TX0*/
+
+	mxc_free_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_FUNC);
+}
+EXPORT_SYMBOL(gpio_inactivate_esai_ports);
+
+
+/*!
+ * Activate CAN
+ */
+void gpio_can_active(int id)
+{
+#define CAN_PAD_CTL (PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | \
+		     PAD_CTL_PUE_PUD | PAD_CTL_100K_PU | PAD_CTL_ODE_OpenDrain)
+
+	switch (id) {
+	case 0:
+#if 0
+		/* CAN1 */
+		mxc_request_iomux(MX25_PIN_GPIO_A, MUX_CONFIG_ALT6); /*TXCAN*/
+		mxc_request_iomux(MX25_PIN_GPIO_B, MUX_CONFIG_ALT6); /*RXCAN*/
+#if 0
+		/* Or if FEC is not used */
+		/*TXCAN*/
+		mxc_request_iomux(MX25_PIN_FEC_TX_EN, MUX_CONFIG_ALT4);
+		/*RXCAN*/
+		mxc_request_iomux(MX25_PIN_FEC_RDATA0, MUX_CONFIG_ALT4);
+#endif
+
+		mxc_iomux_set_pad(MX25_PIN_GPIO_A, CAN_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_GPIO_B, CAN_PAD_CTL);
+
+#endif
+		break;
+	case 1:
+		/* CAN2 */
+		mxc_request_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_ALT6); /*TXCAN*/
+		mxc_request_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_ALT6); /*RXCAN*/
+		mxc_request_iomux(MX25_PIN_D14, MUX_CONFIG_ALT5); /*PWDN*/
+#if 0
+		/* Or if FEC is not used */
+		/*TXCAN*/
+		mxc_request_iomux(MX25_PIN_FEC_RDATA1, MUX_CONFIG_ALT4);
+		*RXCAN*/
+		mxc_request_iomux(MX25_PIN_FEC_RX_DV, MUX_CONFIG_ALT4);
+#endif
+
+		mxc_iomux_set_pad(MX25_PIN_GPIO_C, CAN_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_GPIO_D, CAN_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_D14, PAD_CTL_DRV_NORMAL);
+
+		mxc_iomux_set_input(MUX_IN_CAN2_IPP_IND_CANRX, INPUT_CTL_PATH1);
+
+		/* Configure CAN_PWDN as output */
+		mxc_set_gpio_direction(MX25_PIN_D14, 0);
+
+		/* Enable input by setting PWDN/TLE6250.INH low (gpio4 bit6) */
+		mxc_set_gpio_dataout(MX25_PIN_D14, 0);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_can_active);
+
+/*!
+ * Inactivate CAN
+ */
+void gpio_can_inactive(int id)
+{
+	switch (id) {
+	case 0:
+#if 0
+		/* CAN1 */
+		mxc_request_gpio(MX25_PIN_GPIO_A); /*TXCAN*/
+		mxc_request_gpio(MX25_PIN_GPIO_B); /*RXCAN*/
+
+		mxc_free_iomux(MX25_PIN_GPIO_A, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX25_PIN_GPIO_B, MUX_CONFIG_FUNC);
+
+#endif
+		break;
+	case 1:
+		/* CAN2 */
+		mxc_request_gpio(MX25_PIN_GPIO_C); /*TXCAN*/
+		mxc_request_gpio(MX25_PIN_GPIO_D); /*RXCAN*/
+		mxc_request_gpio(MX25_PIN_D14); /*PWDN*/
+
+		mxc_free_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX25_PIN_D14, MUX_CONFIG_FUNC);
+
+		/* Disable input by setting PWDN/TLE6250.INH high */
+		mxc_set_gpio_dataout(MX25_PIN_D14, 1);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_can_inactive);
diff --git a/arch/arm/mach-mx25/mx25_pins.h b/arch/arm/mach-mx25/mx25_pins.h
new file mode 100644
index 0000000..693eeb5
--- /dev/null
+++ b/arch/arm/mach-mx25/mx25_pins.h
@@ -0,0 +1,250 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX25_PINS_H__
+#define __ASM_ARCH_MXC_MX25_PINS_H__
+
+/*!
+ * @file arch-mxc/mx25_pins.h
+ *
+ * @brief MX25 I/O Pin List
+ *
+ * @ingroup GPIO_MX25
+ */
+
+#ifndef __ASSEMBLY__
+
+/*!
+ * @name IOMUX/PAD Bit field definitions
+ */
+
+/*! @{ */
+
+/*!
+ * In order to identify pins more effectively, each mux-controlled pin's
+ * enumerated value is constructed in the following way:
+ *
+ * -------------------------------------------------------------------
+ * 31-29 | 28 - 24 |23 - 21| 20 - 10| 9 - 0
+ * -------------------------------------------------------------------
+ * IO_P  |  IO_I   | RSVD  | PAD_I | MUX_I
+ * -------------------------------------------------------------------
+ *
+ * Bit 0 to 7 contains MUX_I used to identify the register
+ * offset (base is IOMUX_module_base ) defined in the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. Similar field
+ * definitions are used for the pad control register.  For example,
+ * MX25_PIN_A14 is defined in the enumeration:
+ * ( 0x10 << MUX_I) | ( 0x230 << PAD_I)
+ * So the absolute address is: IOMUX_module_base + 0x10.
+ * The pad control register offset is: 0x230.
+ */
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * MUX control register offset
+ */
+#define MUX_I		0
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * PAD control register offset
+ */
+#define PAD_I		10
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * reserved filed
+ */
+#define RSVD_I		21
+
+#define NON_GPIO_I	0x7
+#define PIN_TO_MUX_MASK	((1<<(PAD_I - MUX_I)) - 1)
+#define PIN_TO_PAD_MASK	((1<<(RSVD_I - PAD_I)) - 1)
+#define NON_MUX_I	PIN_TO_MUX_MASK
+
+#define _MXC_BUILD_PIN(gp, gi, mi, pi) \
+		(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | \
+		((mi) << MUX_I) | ((pi) << PAD_I))
+
+#define _MXC_BUILD_GPIO_PIN(gp, gi, mi, pi) \
+		_MXC_BUILD_PIN(gp, gi, mi, pi)
+
+#define _MXC_BUILD_NON_GPIO_PIN(mi, pi) \
+		_MXC_BUILD_PIN(NON_GPIO_I, 0, mi, pi)
+
+#define PIN_TO_IOMUX_MUX(pin) ((pin >> MUX_I) & PIN_TO_MUX_MASK)
+#define PIN_TO_IOMUX_PAD(pin) ((pin >> PAD_I) & PIN_TO_PAD_MASK)
+
+/*! @} End IOMUX/PAD Bit field definitions */
+
+enum iomux_pins {
+	MX25_PIN_A10 = _MXC_BUILD_GPIO_PIN(3, 0, 0x8, 0x0),
+	MX25_PIN_A13 = _MXC_BUILD_GPIO_PIN(3, 1, 0x0c, 0x22C),
+	MX25_PIN_A14 = _MXC_BUILD_GPIO_PIN(1, 0, 0x10, 0x230),
+	MX25_PIN_A15 = _MXC_BUILD_GPIO_PIN(1, 1, 0x14, 0x234),
+	MX25_PIN_A16 = _MXC_BUILD_GPIO_PIN(1, 2, 0x18, 0x0),
+	MX25_PIN_A17 = _MXC_BUILD_GPIO_PIN(1, 3, 0x1c, 0x238),
+	MX25_PIN_A18 = _MXC_BUILD_GPIO_PIN(1, 4, 0x20, 0x23c),
+	MX25_PIN_A19 = _MXC_BUILD_GPIO_PIN(1, 5, 0x24, 0x240),
+	MX25_PIN_A20 = _MXC_BUILD_GPIO_PIN(1, 6, 0x28, 0x244),
+	MX25_PIN_A21 = _MXC_BUILD_GPIO_PIN(1, 7, 0x2c, 0x248),
+	MX25_PIN_A22 = _MXC_BUILD_GPIO_PIN(1, 8, 0x30, 0x0),
+	MX25_PIN_A23 = _MXC_BUILD_GPIO_PIN(1, 9, 0x34, 0x24c),
+	MX25_PIN_A24 = _MXC_BUILD_GPIO_PIN(1, 10, 0x38, 0x250),
+	MX25_PIN_A25 = _MXC_BUILD_GPIO_PIN(1, 11, 0x3c, 0x254),
+	MX25_PIN_EB0 = _MXC_BUILD_GPIO_PIN(1, 12, 0x40, 0x258),
+	MX25_PIN_EB1 = _MXC_BUILD_GPIO_PIN(1, 13, 0x44, 0x25c),
+	MX25_PIN_OE =  _MXC_BUILD_GPIO_PIN(1, 14, 0x48, 0x260),
+	MX25_PIN_CS0 = _MXC_BUILD_GPIO_PIN(3, 2, 0x4c, 0x0),
+	MX25_PIN_CS1 = _MXC_BUILD_GPIO_PIN(3, 3, 0x50, 0x0),
+	MX25_PIN_CS4 = _MXC_BUILD_GPIO_PIN(2, 20, 0x54, 0x264),
+	MX25_PIN_CS5 = _MXC_BUILD_GPIO_PIN(2, 21, 0x58, 0x268),
+	MX25_PIN_NF_CE0 = _MXC_BUILD_GPIO_PIN(2, 22, 0x5c, 0x26c),
+	MX25_PIN_ECB = _MXC_BUILD_GPIO_PIN(2, 23, 0x60, 0x270),
+	MX25_PIN_LBA = _MXC_BUILD_GPIO_PIN(2, 24, 0x64, 0x274),
+	MX25_PIN_BCLK = _MXC_BUILD_GPIO_PIN(3, 4, 0x68, 0x0),
+	MX25_PIN_RW = _MXC_BUILD_GPIO_PIN(2, 25, 0x6c, 0x278),
+	MX25_PIN_NFWE_B = _MXC_BUILD_GPIO_PIN(2, 26, 0x70, 0x0),
+	MX25_PIN_NFRE_B = _MXC_BUILD_GPIO_PIN(2, 27, 0x74, 0x0),
+	MX25_PIN_NFALE = _MXC_BUILD_GPIO_PIN(2, 28, 0x78, 0x0),
+	MX25_PIN_NFCLE = _MXC_BUILD_GPIO_PIN(2, 29, 0x7c, 0x0),
+	MX25_PIN_NFWP_B = _MXC_BUILD_GPIO_PIN(2, 30, 0x80, 0x0),
+	MX25_PIN_NFRB = _MXC_BUILD_GPIO_PIN(2, 31, 0x84, 0x27c),
+	MX25_PIN_D15 = _MXC_BUILD_GPIO_PIN(3, 5, 0x88, 0x280),
+	MX25_PIN_D14 = _MXC_BUILD_GPIO_PIN(3, 6, 0x8c, 0x284),
+	MX25_PIN_D13 = _MXC_BUILD_GPIO_PIN(3, 7, 0x90, 0x288),
+	MX25_PIN_D12 = _MXC_BUILD_GPIO_PIN(3, 8, 0x94, 0x28c),
+	MX25_PIN_D11 = _MXC_BUILD_GPIO_PIN(3, 9, 0x98, 0x290),
+	MX25_PIN_D10 = _MXC_BUILD_GPIO_PIN(3, 10, 0x9c, 0x294),
+	MX25_PIN_D9 = _MXC_BUILD_GPIO_PIN(3, 11, 0xa0, 0x298),
+	MX25_PIN_D8 = _MXC_BUILD_GPIO_PIN(3, 12, 0xa4, 0x29c),
+	MX25_PIN_D7 = _MXC_BUILD_GPIO_PIN(3, 13, 0xa8, 0x2a0),
+	MX25_PIN_D6 = _MXC_BUILD_GPIO_PIN(3, 14, 0xac, 0x2a4),
+	MX25_PIN_D5 = _MXC_BUILD_GPIO_PIN(3, 15, 0xb0, 0x2a8),
+	MX25_PIN_D4 = _MXC_BUILD_GPIO_PIN(3, 16, 0xb4, 0x2ac),
+	MX25_PIN_D3 = _MXC_BUILD_GPIO_PIN(3, 17, 0xb8, 0x2b0),
+	MX25_PIN_D2 = _MXC_BUILD_GPIO_PIN(3, 18, 0xbc, 0x2b4),
+	MX25_PIN_D1 = _MXC_BUILD_GPIO_PIN(3, 19, 0xc0, 0x2b8),
+	MX25_PIN_D0 = _MXC_BUILD_GPIO_PIN(3, 20, 0xc4, 0x2bc),
+	MX25_PIN_LD0 = _MXC_BUILD_GPIO_PIN(1, 15, 0xc8, 0x2c0),
+	MX25_PIN_LD1 = _MXC_BUILD_GPIO_PIN(1, 16, 0xcc, 0x2c4),
+	MX25_PIN_LD2 = _MXC_BUILD_GPIO_PIN(1, 17, 0xd0, 0x2c8),
+	MX25_PIN_LD3 = _MXC_BUILD_GPIO_PIN(1, 18, 0xd4, 0x2cc),
+	MX25_PIN_LD4 = _MXC_BUILD_GPIO_PIN(1, 19, 0xd8, 0x2d0),
+	MX25_PIN_LD5 = _MXC_BUILD_GPIO_PIN(0, 19, 0xdc, 0x2d4),
+	MX25_PIN_LD6 = _MXC_BUILD_GPIO_PIN(0, 20, 0xe0, 0x2d8),
+	MX25_PIN_LD7 = _MXC_BUILD_GPIO_PIN(0, 21, 0xe4, 0x2dc),
+	MX25_PIN_LD8 = _MXC_BUILD_NON_GPIO_PIN(0xe8, 0x2e0),
+	MX25_PIN_LD9 = _MXC_BUILD_NON_GPIO_PIN(0xec, 0x2e4),
+	MX25_PIN_LD10 = _MXC_BUILD_NON_GPIO_PIN(0xf0, 0x2e8),
+	MX25_PIN_LD11 = _MXC_BUILD_NON_GPIO_PIN(0xf4, 0x2ec),
+	MX25_PIN_LD12 = _MXC_BUILD_NON_GPIO_PIN(0xf8, 0x2f0),
+	MX25_PIN_LD13 = _MXC_BUILD_NON_GPIO_PIN(0xfc, 0x2f4),
+	MX25_PIN_LD14 = _MXC_BUILD_NON_GPIO_PIN(0x100, 0x2f8),
+	MX25_PIN_LD15 = _MXC_BUILD_NON_GPIO_PIN(0x104, 0x2fc),
+	MX25_PIN_HSYNC = _MXC_BUILD_GPIO_PIN(0, 22, 0x108, 0x300),
+	MX25_PIN_VSYNC = _MXC_BUILD_GPIO_PIN(0, 23, 0x10c, 0x304),
+	MX25_PIN_LSCLK = _MXC_BUILD_GPIO_PIN(0, 24, 0x110, 0x308),
+	MX25_PIN_OE_ACD = _MXC_BUILD_GPIO_PIN(0, 25, 0x114, 0x30c),
+	MX25_PIN_CONTRAST = _MXC_BUILD_NON_GPIO_PIN(0x118, 0x310),
+	MX25_PIN_PWM = _MXC_BUILD_GPIO_PIN(0, 26, 0x11c, 0x314),
+	MX25_PIN_CSI_D2 = _MXC_BUILD_GPIO_PIN(0, 27, 0x120, 0x318),
+	MX25_PIN_CSI_D3 = _MXC_BUILD_GPIO_PIN(0, 28, 0x124, 0x31c),
+	MX25_PIN_CSI_D4 = _MXC_BUILD_GPIO_PIN(0, 29, 0x128, 0x320),
+	MX25_PIN_CSI_D5 = _MXC_BUILD_GPIO_PIN(0, 30, 0x12c, 0x324),
+	MX25_PIN_CSI_D6 = _MXC_BUILD_GPIO_PIN(0, 31, 0x130, 0x328),
+	MX25_PIN_CSI_D7 = _MXC_BUILD_GPIO_PIN(0, 6, 0x134, 0x32c),
+	MX25_PIN_CSI_D8 = _MXC_BUILD_GPIO_PIN(0, 7, 0x138, 0x330),
+	MX25_PIN_CSI_D9 = _MXC_BUILD_GPIO_PIN(3, 21, 0x13c, 0x334),
+	MX25_PIN_CSI_MCLK = _MXC_BUILD_GPIO_PIN(0, 8, 0x140, 0x338),
+	MX25_PIN_CSI_VSYNC = _MXC_BUILD_GPIO_PIN(0, 9, 0x144, 0x33c),
+	MX25_PIN_CSI_HSYNC = _MXC_BUILD_GPIO_PIN(0, 10, 0x148, 0x340),
+	MX25_PIN_CSI_PIXCLK = _MXC_BUILD_GPIO_PIN(0, 11, 0x14c, 0x344),
+	MX25_PIN_I2C1_CLK = _MXC_BUILD_GPIO_PIN(0, 12, 0x150, 0x348),
+	MX25_PIN_I2C1_DAT = _MXC_BUILD_GPIO_PIN(0, 13, 0x154, 0x34c),
+	MX25_PIN_CSPI1_MOSI = _MXC_BUILD_GPIO_PIN(0, 14, 0x158, 0x350),
+	MX25_PIN_CSPI1_MISO = _MXC_BUILD_GPIO_PIN(0, 15, 0x15c, 0x354),
+	MX25_PIN_CSPI1_SS0 = _MXC_BUILD_GPIO_PIN(0, 16, 0x160, 0x358),
+	MX25_PIN_CSPI1_SS1 = _MXC_BUILD_GPIO_PIN(0, 17, 0x164, 0x35c),
+	MX25_PIN_CSPI1_SCLK = _MXC_BUILD_GPIO_PIN(0, 18, 0x168, 0x360),
+	MX25_PIN_CSPI1_RDY = _MXC_BUILD_GPIO_PIN(1, 22, 0x16c, 0x364),
+	MX25_PIN_UART1_RXD = _MXC_BUILD_GPIO_PIN(3, 22, 0x170, 0x368),
+	MX25_PIN_UART1_TXD = _MXC_BUILD_GPIO_PIN(3, 23, 0x174, 0x36c),
+	MX25_PIN_UART1_RTS = _MXC_BUILD_GPIO_PIN(3, 24, 0x178, 0x370),
+	MX25_PIN_UART1_CTS = _MXC_BUILD_GPIO_PIN(3, 25, 0x17c, 0x374),
+	MX25_PIN_UART2_RXD = _MXC_BUILD_GPIO_PIN(3, 26, 0x180, 0x378),
+	MX25_PIN_UART2_TXD = _MXC_BUILD_GPIO_PIN(3, 27, 0x184, 0x37c),
+	MX25_PIN_UART2_RTS = _MXC_BUILD_GPIO_PIN(3, 28, 0x188, 0x380),
+	MX25_PIN_UART2_CTS = _MXC_BUILD_GPIO_PIN(3, 29, 0x18c, 0x384),
+	MX25_PIN_SD1_CMD = _MXC_BUILD_GPIO_PIN(1, 23, 0x190, 0x388),
+	MX25_PIN_SD1_CLK = _MXC_BUILD_GPIO_PIN(1, 24, 0x194, 0x38c),
+	MX25_PIN_SD1_DATA0 = _MXC_BUILD_GPIO_PIN(1, 25, 0x198, 0x390),
+	MX25_PIN_SD1_DATA1 = _MXC_BUILD_GPIO_PIN(1, 26, 0x19c, 0x394),
+	MX25_PIN_SD1_DATA2 = _MXC_BUILD_GPIO_PIN(1, 27, 0x1a0, 0x398),
+	MX25_PIN_SD1_DATA3 = _MXC_BUILD_GPIO_PIN(1, 28, 0x1a4, 0x39c),
+	MX25_PIN_KPP_ROW0 = _MXC_BUILD_GPIO_PIN(1, 29, 0x1a8, 0x3a0),
+	MX25_PIN_KPP_ROW1 = _MXC_BUILD_GPIO_PIN(1, 30, 0x1ac, 0x3a4),
+	MX25_PIN_KPP_ROW2 = _MXC_BUILD_GPIO_PIN(1, 31, 0x1b0, 0x3a8),
+	MX25_PIN_KPP_ROW3 = _MXC_BUILD_GPIO_PIN(2, 0, 0x1b4, 0x3ac),
+	MX25_PIN_KPP_COL0 = _MXC_BUILD_GPIO_PIN(2, 1, 0x1b8, 0x3b0),
+	MX25_PIN_KPP_COL1 = _MXC_BUILD_GPIO_PIN(2, 2, 0x1bc, 0x3b4),
+	MX25_PIN_KPP_COL2 = _MXC_BUILD_GPIO_PIN(2, 3, 0x1c0, 0x3b8),
+	MX25_PIN_KPP_COL3 = _MXC_BUILD_GPIO_PIN(2, 4, 0x1c4, 0x3bc),
+	MX25_PIN_FEC_MDC = _MXC_BUILD_GPIO_PIN(2, 5, 0x1c8, 0x3c0),
+	MX25_PIN_FEC_MDIO = _MXC_BUILD_GPIO_PIN(2, 6, 0x1cc, 0x3c4),
+	MX25_PIN_FEC_TDATA0 = _MXC_BUILD_GPIO_PIN(2, 7, 0x1d0, 0x3c8),
+	MX25_PIN_FEC_TDATA1 = _MXC_BUILD_GPIO_PIN(2, 8, 0x1d4, 0x3cc),
+	MX25_PIN_FEC_TX_EN = _MXC_BUILD_GPIO_PIN(2, 9, 0x1d8, 0x3d0),
+	MX25_PIN_FEC_RDATA0 = _MXC_BUILD_GPIO_PIN(2, 10, 0x1dc, 0x3d4),
+	MX25_PIN_FEC_RDATA1 = _MXC_BUILD_GPIO_PIN(2, 11, 0x1e0, 0x3d8),
+	MX25_PIN_FEC_RX_DV = _MXC_BUILD_GPIO_PIN(2, 12, 0x1e4, 0x3dc),
+	MX25_PIN_FEC_TX_CLK = _MXC_BUILD_GPIO_PIN(2, 13, 0x1e8, 0x3e0),
+	MX25_PIN_RTCK = _MXC_BUILD_GPIO_PIN(2, 14, 0x1ec, 0x3e4),
+	MX25_PIN_DE_B = _MXC_BUILD_GPIO_PIN(1, 20, 0x1f0, 0x3ec),
+	MX25_PIN_TDO = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x3e8),
+	MX25_PIN_GPIO_A = _MXC_BUILD_GPIO_PIN(0, 0, 0x1f4, 0x3f0),
+	MX25_PIN_GPIO_B = _MXC_BUILD_GPIO_PIN(0, 1, 0x1f8, 0x3f4),
+	MX25_PIN_GPIO_C = _MXC_BUILD_GPIO_PIN(0, 2, 0x1fc, 0x3f8),
+	MX25_PIN_GPIO_D = _MXC_BUILD_GPIO_PIN(0, 3, 0x200, 0x3fc),
+	MX25_PIN_GPIO_E = _MXC_BUILD_GPIO_PIN(0, 4, 0x204, 0x400),
+	MX25_PIN_GPIO_F = _MXC_BUILD_GPIO_PIN(0, 5, 0x208, 0x404),
+	MX25_PIN_EXT_ARMCLK = _MXC_BUILD_GPIO_PIN(2, 15, 0x20c, 0x0),
+	MX25_PIN_UPLL_BYPCLK = _MXC_BUILD_GPIO_PIN(2, 16, 0x210, 0x0),
+	MX25_PIN_VSTBY_REQ = _MXC_BUILD_GPIO_PIN(2, 17, 0x214, 0x408),
+	MX25_PIN_VSTBY_ACK = _MXC_BUILD_GPIO_PIN(2, 18, 0x218, 0x40c),
+	MX25_PIN_POWER_FAIL = _MXC_BUILD_GPIO_PIN(2, 19, 0x21c, 0x410),
+	MX25_PIN_CLKO = _MXC_BUILD_GPIO_PIN(1, 21, 0x220, 0x414),
+	MX25_PIN_BOOT_MODE0 = _MXC_BUILD_GPIO_PIN(3, 30, 0x224, 0x0),
+	MX25_PIN_BOOT_MODE1 = _MXC_BUILD_GPIO_PIN(3, 31, 0x228, 0x0),
+
+	MX25_PIN_CTL_GRP_DVS_MISC = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x418),
+	MX25_PIN_CTL_GRP_DSE_FEC = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x41c),
+	MX25_PIN_CTL_GRP_DVS_JTAG = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x420),
+	MX25_PIN_CTL_GRP_DSE_NFC = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x424),
+	MX25_PIN_CTL_GRP_DSE_CSI = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x428),
+	MX25_PIN_CTL_GRP_DSE_WEIM = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x42c),
+	MX25_PIN_CTL_GRP_DSE_DDR = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x430),
+	MX25_PIN_CTL_GRP_DVS_CRM = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x434),
+	MX25_PIN_CTL_GRP_DSE_KPP = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x438),
+	MX25_PIN_CTL_GRP_DSE_SDHC1 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x43c),
+	MX25_PIN_CTL_GRP_DSE_LCD = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x440),
+	MX25_PIN_CTL_GRP_DSE_UART = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x444),
+	MX25_PIN_CTL_GRP_DVS_NFC = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x448),
+	MX25_PIN_CTL_GRP_DVS_CSI = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x44c),
+	MX25_PIN_CTL_GRP_DSE_CSPI1 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x450),
+	MX25_PIN_CTL_GRP_DDRTYPE = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x454),
+	MX25_PIN_CTL_GRP_DVS_SDHC1 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x458),
+	MX25_PIN_CTL_GRP_DVS_LCD = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x45c)
+};
+
+#endif
+#endif
diff --git a/arch/arm/mach-mx25/serial.c b/arch/arm/mach-mx25/serial.c
new file mode 100644
index 0000000..8696a4c
--- /dev/null
+++ b/arch/arm/mach-mx25/serial.c
@@ -0,0 +1,173 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*!
+ * @file mach-mx25/serial.c
+ *
+ * @brief This file contains the UART initiliazation.
+ *
+ * @ingroup MSL_MX25
+ */
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <asm/hardware.h>
+#include <asm/arch/mxc_uart.h>
+#include <asm/arch/spba.h>
+#include "serial.h"
+#include "board-mx25_3stack.h"
+
+#if defined(CONFIG_SERIAL_MXC) || defined(CONFIG_SERIAL_MXC_MODULE)
+
+/*!
+ * This is an array where each element holds information about a UART port,
+ * like base address of the UART, interrupt numbers etc. This structure is
+ * passed to the serial_core.c file. Based on which UART is used, the core file
+ * passes back the appropriate port structure as an argument to the control
+ * functions.
+ */
+static uart_mxc_port mxc_ports[] = {
+	[0] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART1_BASE_ADDR),
+			.mapbase = UART1_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART1_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 0,
+			},
+	       .ints_muxed = UART1_MUX_INTS,
+	       .irqs = {UART1_INT2, UART1_INT3},
+	       .mode = UART1_MODE,
+	       .ir_mode = UART1_IR,
+	       .enabled = UART1_ENABLED,
+	       .hardware_flow = UART1_HW_FLOW,
+	       .cts_threshold = UART1_UCR4_CTSTL,
+	       .dma_enabled = UART1_DMA_ENABLE,
+	       .dma_rxbuf_size = UART1_DMA_RXBUFSIZE,
+	       .rx_threshold = UART1_UFCR_RXTL,
+	       .tx_threshold = UART1_UFCR_TXTL,
+	       .shared = UART1_SHARED_PERI,
+	       .dma_tx_id = MXC_DMA_UART1_TX,
+	       .dma_rx_id = MXC_DMA_UART1_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[1] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART2_BASE_ADDR),
+			.mapbase = UART2_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART2_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 1,
+			},
+	       .ints_muxed = UART2_MUX_INTS,
+	       .irqs = {UART2_INT2, UART2_INT3},
+	       .mode = UART2_MODE,
+	       .ir_mode = UART2_IR,
+	       .enabled = UART2_ENABLED,
+	       .hardware_flow = UART2_HW_FLOW,
+	       .cts_threshold = UART2_UCR4_CTSTL,
+	       .dma_enabled = UART2_DMA_ENABLE,
+	       .dma_rxbuf_size = UART2_DMA_RXBUFSIZE,
+	       .rx_threshold = UART2_UFCR_RXTL,
+	       .tx_threshold = UART2_UFCR_TXTL,
+	       .shared = UART2_SHARED_PERI,
+	       .dma_tx_id = MXC_DMA_UART2_TX,
+	       .dma_rx_id = MXC_DMA_UART2_RX,
+	       .rxd_mux = MXC_UART_IR_RXDMUX,
+	       },
+#if UART3_ENABLED == 1
+	[2] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART3_BASE_ADDR),
+			.mapbase = UART3_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART3_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 2,
+			},
+	       .ints_muxed = UART3_MUX_INTS,
+	       .irqs = {UART3_INT2, UART3_INT3},
+	       .mode = UART3_MODE,
+	       .ir_mode = UART3_IR,
+	       .enabled = UART3_ENABLED,
+	       .hardware_flow = UART3_HW_FLOW,
+	       .cts_threshold = UART3_UCR4_CTSTL,
+	       .dma_enabled = UART3_DMA_ENABLE,
+	       .dma_rxbuf_size = UART3_DMA_RXBUFSIZE,
+	       .rx_threshold = UART3_UFCR_RXTL,
+	       .tx_threshold = UART3_UFCR_TXTL,
+	       .shared = UART3_SHARED_PERI,
+	       .dma_tx_id = MXC_DMA_UART3_TX,
+	       .dma_rx_id = MXC_DMA_UART3_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+#endif
+};
+
+static struct platform_device mxc_uart_device1 = {
+	.name = "mxcintuart",
+	.id = 0,
+	.dev = {
+		.platform_data = &mxc_ports[0],
+		},
+};
+
+static struct platform_device mxc_uart_device2 = {
+	.name = "mxcintuart",
+	.id = 1,
+	.dev = {
+		.platform_data = &mxc_ports[1],
+		},
+};
+
+#if UART3_ENABLED == 1
+static struct platform_device mxc_uart_device3 = {
+	.name = "mxcintuart",
+	.id = 2,
+	.dev = {
+		.platform_data = &mxc_ports[2],
+		},
+};
+#endif
+
+static int __init mxc_init_uart(void)
+{
+	/* Register all the MXC UART platform device structures */
+	platform_device_register(&mxc_uart_device1);
+	platform_device_register(&mxc_uart_device2);
+
+	/* Grab ownership of shared UARTs 3 and 4, only when enabled */
+#if UART3_ENABLED == 1
+#if UART3_DMA_ENABLE == 1
+	spba_take_ownership(UART3_SHARED_PERI, (SPBA_MASTER_A | SPBA_MASTER_C));
+#else
+	spba_take_ownership(UART3_SHARED_PERI, SPBA_MASTER_A);
+#endif				/* UART3_DMA_ENABLE */
+	platform_device_register(&mxc_uart_device3);
+#endif				/* UART3_ENABLED */
+
+	return 0;
+}
+
+#else
+static int __init mxc_init_uart(void)
+{
+	return 0;
+}
+#endif
+
+arch_initcall(mxc_init_uart);
diff --git a/arch/arm/mach-mx25/serial.h b/arch/arm/mach-mx25/serial.h
new file mode 100644
index 0000000..28755ea
--- /dev/null
+++ b/arch/arm/mach-mx25/serial.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX25_SERIAL_H__
+#define __ARCH_ARM_MACH_MX25_SERIAL_H__
+
+/*!
+ * @file mach-mx25/serial.h
+ *
+ * @ingroup MSL_MX25
+ */
+#include <asm/arch/mxc_uart.h>
+
+/* UART 1 configuration */
+/*!
+ * This option allows to choose either an interrupt-driven software controlled
+ * hardware flow control (set this option to 0) or hardware-driven hardware
+ * flow control (set this option to 1).
+ */
+#define UART1_HW_FLOW           1
+/*!
+ * This specifies the threshold at which the CTS pin is deasserted by the
+ * RXFIFO. Set this value in Decimal to anything from 0 to 32 for
+ * hardware-driven hardware flow control. Read the HW spec while specifying
+ * this value. When using interrupt-driven software controlled hardware
+ * flow control set this option to -1.
+ */
+#define UART1_UCR4_CTSTL        16
+/*!
+ * This is option to enable (set this option to 1) or disable DMA data transfer
+ */
+#define UART1_DMA_ENABLE        0
+/*!
+ * Specify the size of the DMA receive buffer. The minimum buffer size is 512
+ * bytes. The buffer size should be a multiple of 256.
+ */
+#define UART1_DMA_RXBUFSIZE     1024
+/*!
+ * Specify the MXC UART's Receive Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the RxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_RXTL         16
+/*!
+ * Specify the MXC UART's Transmit Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the TxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_TXTL         16
+/* UART 2 configuration */
+#define UART2_HW_FLOW           0
+#define UART2_UCR4_CTSTL        (-1)
+#define UART2_DMA_ENABLE        0
+#define UART2_DMA_RXBUFSIZE     512
+#define UART2_UFCR_RXTL         16
+#define UART2_UFCR_TXTL         16
+/* UART 3 configuration */
+#define UART3_HW_FLOW           1
+#define UART3_UCR4_CTSTL        16
+#define UART3_DMA_ENABLE        1
+#define UART3_DMA_RXBUFSIZE     1024
+#define UART3_UFCR_RXTL         16
+#define UART3_UFCR_TXTL         16
+
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+/*
+ * Is the MUXED interrupt output sent to the ARM core
+ */
+#define INTS_NOTMUXED           0
+#define INTS_MUXED              1
+/* UART 1 configuration */
+/*!
+ * This define specifies whether the muxed ANDed interrupt line or the
+ * individual interrupts from the UART port is integrated with the ARM core.
+ * There exists a define like this for each UART port. Valid values that can
+ * be used are \b INTS_NOTMUXED or \b INTS_MUXED.
+ */
+#define UART1_MUX_INTS          INTS_MUXED
+/*!
+ * This define specifies the transmitter interrupt number or the interrupt
+ * number of the ANDed interrupt in case the interrupts are muxed. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_INT1              MXC_INT_UART1
+/*!
+ * This define specifies the receiver interrupt number. If the interrupts of
+ * the UART are muxed, then we specify here a dummy value -1. There exists a
+ * define like this for each UART port.
+ */
+#define UART1_INT2              (-1)
+/*!
+ * This specifies the master interrupt number. If the interrupts of the UART
+ * are muxed, then we specify here a dummy value of -1. There exists a define
+ * like this for each UART port.
+ */
+#define UART1_INT3              (-1)
+/*!
+ * This specifies if the UART is a shared peripheral. It holds the shared
+ * peripheral number if it is shared or -1 if it is not shared. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_SHARED_PERI       (-1)
+/* UART 2 configuration */
+#define UART2_MUX_INTS          INTS_MUXED
+#define UART2_INT1              MXC_INT_UART2
+#define UART2_INT2              (-1)
+#define UART2_INT3              (-1)
+#define UART2_SHARED_PERI       (-1)
+/* UART 3 configuration */
+#define UART3_MUX_INTS          INTS_MUXED
+#define UART3_INT1              MXC_INT_UART3
+#define UART3_INT2              (-1)
+#define UART3_INT3              (-1)
+#define UART3_SHARED_PERI       SPBA_UART3
+
+#endif				/* __ARCH_ARM_MACH_MX25_SERIAL_H__ */
diff --git a/arch/arm/mach-mx25/system.c b/arch/arm/mach-mx25/system.c
new file mode 100644
index 0000000..ce4a4fe
--- /dev/null
+++ b/arch/arm/mach-mx25/system.c
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <asm/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include <asm/arch/clock.h>
+#include "crm_regs.h"
+
+/*!
+ * @defgroup MSL_MX25 i.MX25 Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @file mach-mx25/system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup MSL_MX25
+ */
+
+extern int mxc_jtag_enabled;
+
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks.
+	 */
+	if (!mxc_jtag_enabled)
+		cpu_do_idle();
+}
+
+/*
+ * This function resets the system. It is called by machine_restart().
+ *
+ * @param  mode         indicates different kinds of resets
+ */
+void arch_reset(char mode)
+{
+	/* Assert SRS signal */
+	mxc_wd_reset();
+}
diff --git a/arch/arm/plat-mxc/Kconfig b/arch/arm/plat-mxc/Kconfig
index 8fdee23..338e20b 100644
--- a/arch/arm/plat-mxc/Kconfig
+++ b/arch/arm/plat-mxc/Kconfig
@@ -31,6 +31,12 @@ config ARCH_MX27
 	help
 	  This enables support for systems based on the Freescale i.MX27
 
+config ARCH_MX25
+	bool "MX25-based"
+	select MX25_OPTIONSS
+	help
+	  This enables support for systems based on the Freescale i.MX25
+
 config ARCH_MX21
 	bool "MX21-based"
 	help
@@ -40,6 +46,8 @@ endchoice
 
 source "arch/arm/mach-mx27/Kconfig"
 
+source "arch/arm/mach-mx25/Kconfig"
+
 source "arch/arm/mach-mx21/Kconfig"
 
 source "arch/arm/mach-mx3/Kconfig"
diff --git a/include/asm-arm/arch-mxc/mx25.h b/include/asm-arm/arch-mxc/mx25.h
new file mode 100644
index 0000000..f27d4c3
--- /dev/null
+++ b/include/asm-arm/arch-mxc/mx25.h
@@ -0,0 +1,413 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file arch-mxc/mx25.h
+ * @brief This file contains register definitions.
+ *
+ * @ingroup MSL_MX25
+ */
+
+#ifndef __ASM_ARCH_MXC_MX25_H__
+#define __ASM_ARCH_MXC_MX25_H__
+
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#error "Do not include directly."
+#endif
+
+/*!
+ * defines the OS clock tick rate
+ */
+#define CLOCK_TICK_RATE         12000000
+
+/*!
+ * Register an interrupt handler for the SMN as well as the SCC.  In some
+ * implementations, the SMN is not connected at all, and in others, it is
+ * on the same interrupt line as the SCM. Comment this line out accordingly
+ */
+#define USE_SMN_INTERRUPT
+
+/*!
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+#define MXC_UART_NR 5
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive Irda data.
+ */
+#define MXC_UART_IR_RXDMUX      0x0004
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive UART data.
+ */
+#define MXC_UART_RXDMUX         0x0004
+
+/*
+ * MX25 memory map:
+ *
+ * Virt     Phys        Size    What
+ * ---------------------------------------------------------------------------
+ * FC000000 43F00000    1M      AIPS 1
+ * FC100000 50000000    1M      SPBA
+ * FC200000 53F00000    1M      AIPS 2
+ * FC300000 60000000    1M      ROMPATCH (128M)
+ * FC400000 68000000    1M      ASIC (128M)
+ * FC500000 78000000    128K    FBC RAM (IRAM)
+ *          80000000    256M    SDRAM0
+ *          90000000    256M    SDRAM1
+ *          A0000000    128M    CS0 Flash
+ *          A8000000    128M    CS1 Flash
+ *          B0000000    32M     CS2 SRAM
+ *          B2000000    32M     CS3
+ *          B4000000    32M     CS4
+ *          B6000000    32M     CS5
+ * FC520000 B8000000    64K     SDRAM, WEIM, M3IF, EMI controllers
+ * FC530000 BB000000    8K      NFC
+ */
+
+/*
+ * IRAM
+ */
+#define IRAM_BASE_ADDR       0x78000000	/* internal ram */
+#define IRAM_BASE_ADDR_VIRT  0xFC500000
+#define IRAM_SIZE            SZ_128K
+
+/*
+ * AIPS 1
+ */
+#define AIPS1_BASE_ADDR       0x43F00000
+#define AIPS1_BASE_ADDR_VIRT  0xFC000000
+#define AIPS1_SIZE            SZ_1M
+
+#define MAX_BASE_ADDR       (AIPS1_BASE_ADDR + 0x00004000)
+#define CLKCTL_BASE_ADDR    (AIPS1_BASE_ADDR + 0x00008000)
+#define ETB_SLOT4_BASE_ADDR (AIPS1_BASE_ADDR + 0x0000C000)
+#define ETB_SLOT5_BASE_ADDR (AIPS1_BASE_ADDR + 0x00010000)
+#define AAPE_BASE_ADDR      (AIPS1_BASE_ADDR + 0x00014000)
+#define I2C_BASE_ADDR       (AIPS1_BASE_ADDR + 0x00080000)
+#define I2C3_BASE_ADDR      (AIPS1_BASE_ADDR + 0x00084000)
+#define CAN1_BASE_ADDR      (AIPS1_BASE_ADDR + 0x00088000)
+#define CAN3_BASE_ADDR      (AIPS1_BASE_ADDR + 0x0008C000)
+#define UART1_BASE_ADDR     (AIPS1_BASE_ADDR + 0x00090000)
+#define UART2_BASE_ADDR     (AIPS1_BASE_ADDR + 0x00094000)
+#define I2C2_BASE_ADDR      (AIPS1_BASE_ADDR + 0x00098000)
+#define OWIRE_BASE_ADDR     (AIPS1_BASE_ADDR + 0x0009C000)
+#define ATA_BASE_ADDR       (AIPS1_BASE_ADDR + 0x000A0000)
+#define CSPI1_BASE_ADDR     (AIPS1_BASE_ADDR + 0x000A4000)
+#define KPP_BASE_ADDR       (AIPS1_BASE_ADDR + 0x000A8000)
+#define IOMUXC_BASE_ADDR    (AIPS1_BASE_ADDR + 0x000AC000)
+#define AUDMUX_BASE_ADDR    (AIPS1_BASE_ADDR + 0x000B0000)
+#define ECT_A_BASE_ADDR     (AIPS1_BASE_ADDR + 0x000B8000)
+#define ECT_B_BASE_ADDR     (AIPS1_BASE_ADDR + 0x000BC000)
+
+/*
+ * SPBA global module enabled #0
+ */
+#define SPBA0_BASE_ADDR       0x50000000
+#define SPBA0_BASE_ADDR_VIRT  0xFC100000
+#define SPBA0_SIZE            SZ_256K
+
+#define CSPI3_BASE_ADDR         (SPBA0_BASE_ADDR + 0x00004000)
+#define UART4_BASE_ADDR         (SPBA0_BASE_ADDR + 0x00008000)
+#define UART3_BASE_ADDR         (SPBA0_BASE_ADDR + 0x0000C000)
+#define CSPI2_BASE_ADDR         (SPBA0_BASE_ADDR + 0x00010000)
+#define SSI2_BASE_ADDR          (SPBA0_BASE_ADDR + 0x00014000)
+#define ESAI_BASE_ADDR          (SPBA0_BASE_ADDR + 0x00018000)
+#define ATA_DMA_BASE_ADDR       (SPBA0_BASE_ADDR + 0x00020000)
+#define SIM1_BASE_ADDR          (SPBA0_BASE_ADDR + 0x00024000)
+#define SIM2_BASE_ADDR          (SPBA0_BASE_ADDR + 0x00028000)
+#define UART5_BASE_ADDR         (SPBA0_BASE_ADDR + 0x0002C000)
+#define TSC_BASE_ADDR           (SPBA0_BASE_ADDR + 0x00030000)
+#define SSI1_BASE_ADDR          (SPBA0_BASE_ADDR + 0x00034000)
+#define FEC_BASE_ADDR           (SPBA0_BASE_ADDR + 0x00038000)
+#define SPBA_CTRL_BASE_ADDR     (SPBA0_BASE_ADDR + 0x0003C000)
+
+/*
+ * AIPS 2
+ */
+#define AIPS2_BASE_ADDR       0x53F00000
+#define AIPS2_BASE_ADDR_VIRT  0xFC200000
+#define AIPS2_SIZE            SZ_1M
+#define CCM_BASE_ADDR       (AIPS2_BASE_ADDR + 0x00080000)
+#define GPT4_BASE_ADDR      (AIPS2_BASE_ADDR + 0x00084000)
+#define GPT3_BASE_ADDR      (AIPS2_BASE_ADDR + 0x00088000)
+#define GPT2_BASE_ADDR      (AIPS2_BASE_ADDR + 0x0008C000)
+#define GPT1_BASE_ADDR      (AIPS2_BASE_ADDR + 0x00090000)
+#define EPIT1_BASE_ADDR     (AIPS2_BASE_ADDR + 0x00094000)
+#define EPIT2_BASE_ADDR     (AIPS2_BASE_ADDR + 0x00098000)
+#define GPIO4_BASE_ADDR     (AIPS2_BASE_ADDR + 0x0009C000)
+#define PWM2_BASE_ADDR      (AIPS2_BASE_ADDR + 0x000A0000)
+#define GPIO3_BASE_ADDR     (AIPS2_BASE_ADDR + 0x000AD000)
+#define PWM3_BASE_ADDR      (AIPS2_BASE_ADDR + 0x000A8000)
+#define SCC_BASE_ADDR       (AIPS2_BASE_ADDR + 0x000AC000)
+#define RNGD_BASE_ADDR      (AIPS2_BASE_ADDR + 0x000B0000)
+#define MMC_SDHC1_BASE_ADDR (AIPS2_BASE_ADDR + 0x000B4000)
+#define MMC_SDHC2_BASE_ADDR (AIPS2_BASE_ADDR + 0x000B8000)
+#define LCDC_BASE_ADDR      (AIPS2_BASE_ADDR + 0x000BC000)
+#define SLCDC_BASE_ADDR     (AIPS2_BASE_ADDR + 0x000C0000)
+#define PWM4_BASE_ADDR      (AIPS2_BASE_ADDR + 0x000C8000)
+#define GPIO1_BASE_ADDR     (AIPS2_BASE_ADDR + 0x000CC000)
+#define GPIO2_BASE_ADDR     (AIPS2_BASE_ADDR + 0x000D0000)
+#define SDMA_BASE_ADDR      (AIPS2_BASE_ADDR + 0x000D4000)
+#define WDOG1_BASE_ADDR     (AIPS2_BASE_ADDR + 0x000DC000)
+#define PWM1_BASE_ADDR      (AIPS2_BASE_ADDR + 0x000E0000)
+#define RTIC_BASE_ADDR      (AIPS2_BASE_ADDR + 0x000EC000)
+#define IIM_BASE_ADDR       (AIPS2_BASE_ADDR + 0x000F0000)
+#define USBOTG_BASE_ADDR    (AIPS2_BASE_ADDR + 0x000F4000)
+#define OTG_BASE_ADDR       USBOTG_BASE_ADDR
+#define CSI_BASE_ADDR       (AIPS2_BASE_ADDR + 0x000F8000)
+#define DRYICE_BASE_ADDR    (AIPS2_BASE_ADDR + 0x000FC000)
+
+/*
+ * ROMP and ASIC
+ */
+#define ROMP_BASE_ADDR       0x60000000
+#define ROMP_BASE_ADDR_VIRT  0xFC300000
+#define ROMP_SIZE            SZ_1M
+
+#define ASIC_BASE_ADDR       0x68000000
+#define ASIC_BASE_ADDR_VIRT  0xFC400000
+#define ASIC_SIZE            SZ_1M
+#define AVIC_BASE_ADDR       ASIC_BASE_ADDR
+#define AVIC_BASE_ADDR_VIRT  ASIC_BASE_ADDR_VIRT
+#define AVIC_SIZE            ASIC_SIZE
+
+/*
+ * SDRAM, WEIM, M3IF, EMI controllers
+ */
+#define X_MEMC_BASE_ADDR       0xB8000000
+#define X_MEMC_BASE_ADDR_VIRT  0xFC520000
+#define X_MEMC_SIZE            SZ_64K
+
+#define SDRAMC_BASE_ADDR        (X_MEMC_BASE_ADDR + 0x1000)
+#define WEIM_BASE_ADDR          (X_MEMC_BASE_ADDR + 0x2000)
+#define M3IF_BASE_ADDR          (X_MEMC_BASE_ADDR + 0x3000)
+#define EMI_CTL_BASE_ADDR       (X_MEMC_BASE_ADDR + 0x4000)
+
+/*
+ * NFC controller
+ */
+#define NFC_BASE_ADDR       0xBB000000
+#define NFC_BASE_ADDR_VIRT  0xFC530000
+#define NFC_SIZE            SZ_8K
+
+/*
+ * Memory regions and CS
+ */
+#define CSD0_BASE_ADDR          0x80000000
+#define CSD1_BASE_ADDR          0x90000000
+
+#define SDRAM_BASE_ADDR         CSD0_BASE_ADDR
+
+#define CS0_BASE_ADDR           0xA0000000
+#define CS1_BASE_ADDR           0xA8000000
+#define CS2_BASE_ADDR           0xB0000000
+#define CS3_BASE_ADDR           0xB2000000
+#define CS4_BASE_ADDR           0xB4000000
+#define CS4_SIZE                SZ_32M
+#define CS5_BASE_ADDR           0xB6000000
+#define CS5_SIZE                SZ_32M
+
+/*!
+ * This macro defines the physical to virtual address mapping for all the
+ * peripheral modules. It is used by passing in the physical address as x
+ * and returning the virtual address. If the physical address is not mapped,
+ * it returns 0xDEADBEEF
+ */
+#define IO_ADDRESS(x)   \
+	(((x >= AIPS1_BASE_ADDR) && (x < (AIPS1_BASE_ADDR + AIPS1_SIZE))) ? AIPS1_IO_ADDRESS(x):\
+	((x >= SPBA0_BASE_ADDR) && (x < (SPBA0_BASE_ADDR + SPBA0_SIZE))) ? SPBA0_IO_ADDRESS(x):\
+	((x >= AIPS2_BASE_ADDR) && (x < (AIPS2_BASE_ADDR + AIPS2_SIZE))) ? AIPS2_IO_ADDRESS(x):\
+	((x >= ROMP_BASE_ADDR) && (x < (ROMP_BASE_ADDR + ROMP_SIZE))) ? ROMP_IO_ADDRESS(x):\
+	((x >= ASIC_BASE_ADDR) && (x < (ASIC_BASE_ADDR + AVIC_SIZE))) ? ASIC_IO_ADDRESS(x):\
+	((x >= IRAM_BASE_ADDR) && (x < (IRAM_BASE_ADDR + IRAM_SIZE))) ? IRAM_IO_ADDRESS(x):\
+	((x >= X_MEMC_BASE_ADDR) && (x < (X_MEMC_BASE_ADDR + X_MEMC_SIZE))) ? X_MEMC_IO_ADDRESS(x):\
+	((x >= NFC_BASE_ADDR) && (x < (NFC_BASE_ADDR + NFC_SIZE))) ? NFC_IO_ADDRESS(x):\
+	0xDEADBEEF)
+
+/*
+ * define the address mapping macros: in physical address order
+ */
+
+#define AIPS1_IO_ADDRESS(x)  \
+	(((x) - AIPS1_BASE_ADDR) + AIPS1_BASE_ADDR_VIRT)
+
+#define SPBA0_IO_ADDRESS(x)  \
+	(((x) - SPBA0_BASE_ADDR) + SPBA0_BASE_ADDR_VIRT)
+
+#define AIPS2_IO_ADDRESS(x)  \
+	(((x) - AIPS2_BASE_ADDR) + AIPS2_BASE_ADDR_VIRT)
+
+#define ROMP_IO_ADDRESS(x)  \
+	(((x) - ROMP_BASE_ADDR) + ROMP_BASE_ADDR_VIRT)
+
+#define ASIC_IO_ADDRESS(x)  \
+	(((x) - ASIC_BASE_ADDR) + ASIC_BASE_ADDR_VIRT)
+
+/* for entry-macro.S */
+#define AVIC_IO_ADDRESS(x)	ASIC_IO_ADDRESS(x)
+
+#define IRAM_IO_ADDRESS(x)  \
+	(((x) - IRAM_BASE_ADDR) + IRAM_BASE_ADDR_VIRT)
+
+#define X_MEMC_IO_ADDRESS(x)  \
+	(((x) - X_MEMC_BASE_ADDR) + X_MEMC_BASE_ADDR_VIRT)
+
+#define NFC_IO_ADDRESS(x)  \
+	(((x) - NFC_BASE_ADDR) + NFC_BASE_ADDR_VIRT)
+
+#define IS_MEM_DEVICE_NONSHARED(x)	0
+
+/*
+ * DMA request assignments
+ */
+#define DMA_REQ_EXTREQ0    0
+#define DMA_REQ_CCM        1
+#define DMA_REQ_ATA_TX_END 2
+#define DMA_REQ_ATA_TX     3
+#define DMA_REQ_ATA_RX     4
+#define DMA_REQ_CSPI2_RX   6
+#define DMA_REQ_CSPI2_TX   7
+#define DMA_REQ_CSPI1_RX   8
+#define DMA_REQ_CSPI1_TX   9
+#define DMA_REQ_UART3_RX   10
+#define DMA_REQ_UART3_TX   11
+#define DMA_REQ_UART4_RX   12
+#define DMA_REQ_UART4_TX   13
+#define DMA_REQ_EXTREQ1    14
+#define DMA_REQ_EXTREQ2    15
+#define DMA_REQ_UART2_RX   16
+#define DMA_REQ_UART2_TX   17
+#define DMA_REQ_UART1_RX   18
+#define DMA_REQ_UART1_TX   19
+#define DMA_REQ_SSI2_RX1   22
+#define DMA_REQ_SSI2_TX1   23
+#define DMA_REQ_SSI2_RX0   24
+#define DMA_REQ_SSI2_TX0   25
+#define DMA_REQ_SSI1_RX1   26
+#define DMA_REQ_SSI1_TX1   27
+#define DMA_REQ_SSI1_RX0   28
+#define DMA_REQ_SSI1_TX0   29
+#define DMA_REQ_NFC        30
+#define DMA_REQ_ECT        31
+#define DMA_REQ_ESAI_RX    32
+#define DMA_REQ_ESAI_TX    33
+#define DMA_REQ_CSPI3_RX   34
+#define DMA_REQ_CSPI3_TX   35
+#define DMA_REQ_SIM2_RX    36
+#define DMA_REQ_SIM2_TX    37
+#define DMA_REQ_SIM1_RX    38
+#define DMA_REQ_SIM1_TX    39
+#define DMA_REQ_TSC_GCQ    44
+#define DMA_REQ_TSC_TCQ    45
+#define DMA_REQ_UART5_RX   46
+#define DMA_REQ_UART5_TX   47
+
+/*
+ *  Interrupt numbers
+ */
+#define MXC_INT_CSPI3               0
+#define MXC_INT_GPT4                1
+#define MXC_INT_OWIRE               2
+#define MXC_INT_I2C                 3
+#define MXC_INT_I2C2                4
+#define MXC_INT_UART4               5
+#define MXC_INT_RTIC                6
+#define MXC_INT_ESAI                7
+#define MXC_INT_SDHC2               8
+#define MXC_INT_SDHC1               9
+#define MXC_INT_I2C3                10
+#define MXC_INT_SSI2                11
+#define MXC_INT_SSI1                12
+#define MXC_INT_CSPI2               13
+#define MXC_INT_CSPI1               14
+#define MXC_INT_ATA                 15
+#define MXC_INT_GPIO3               16
+#define MXC_INT_CSI                 17
+#define MXC_INT_UART3               18
+#define MXC_INT_IIM                 19
+#define MXC_INT_SIM1                20
+#define MXC_INT_SIM2                21
+#define MXC_INT_RNGD                22
+#define MXC_INT_GPIO4               23
+#define MXC_INT_KPP                 24
+#define MXC_INT_DRYICE_RTC          25
+#define MXC_INT_PWM                 26
+#define MXC_INT_EPIT2               27
+#define MXC_INT_EPIT1               28
+#define MXC_INT_GPT3                29
+#define MXC_INT_POWER_FAIL          30
+#define MXC_INT_CRM                 31
+#define MXC_INT_UART2               32
+#define MXC_INT_NANDFC              33
+#define MXC_INT_SDMA                34
+#define MXC_INT_USB_HTG             35
+#define MXC_INT_PWM2                36
+#define MXC_INT_USB_OTG             37
+#define MXC_INT_SLCDC               38
+#define MXC_INT_LCDC                39
+#define MXC_INT_UART5               40
+#define MXC_INT_PWM3                41
+#define MXC_INT_PWM4                42
+#define MXC_INT_CAN1                43
+#define MXC_INT_CAN2                44
+#define MXC_INT_UART1               45
+#define MXC_INT_TSC                 46
+#define MXC_INT_ECT                 48
+#define MXC_INT_SCC_SCM             49
+#define MXC_INT_SCC_SMN             50
+#define MXC_INT_GPIO2               51
+#define MXC_INT_GPIO1               52
+#define MXC_INT_GPT2                53
+#define MXC_INT_GPT1                54
+#define MXC_INT_WDOG                55
+#define MXC_INT_DRYICE              56
+#define MXC_INT_FEC                 57
+#define MXC_INT_EXT_INT5            58
+#define MXC_INT_EXT_INT4            59
+#define MXC_INT_EXT_INT3            60
+#define MXC_INT_EXT_INT2            61
+#define MXC_INT_EXT_INT1            62
+#define MXC_INT_EXT_INT0            63
+
+#define MXC_INT_GPT                 MXC_INT_GPT1
+
+#define MXC_MAX_INT_LINES       64
+#define MXC_MAX_EXT_LINES       6
+
+#define MXC_GPIO_INT_BASE	(MXC_MAX_INT_LINES)
+
+/*!
+ * Number of GPIO port as defined in the IC Spec
+ */
+#define GPIO_PORT_NUM           4
+/*!
+ * Number of GPIO pins per port
+ */
+#define GPIO_NUM_PIN            32
+
+#define MXC_TIMER_GPT1          1
+#define MXC_TIMER_GPT2          2
+#define MXC_TIMER_GPT3          3
+#define MXC_TIMER_GPT4          4
+
+/*!
+ * NFMS bit in FMCR register for pagesize of nandflash
+ */
+#define NFMS (*((volatile u32 *)IO_ADDRESS(SYSCTRL_BASE_ADDR+0x28)))
+
+#define NFMS_BIT 8
+
+#endif				/* __ASM_ARCH_MXC_MX25_H__ */
-- 
1.5.4.4

