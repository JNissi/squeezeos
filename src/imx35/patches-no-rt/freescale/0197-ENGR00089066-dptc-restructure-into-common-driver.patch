From 81191072ecd26d545582bf8d7e4f804a67594d7c Mon Sep 17 00:00:00 2001
From: Nancy Chen <Nancy.Chen@freescale.com>
Date: Sun, 2 Nov 2008 21:47:47 -0600
Subject: [PATCH] ENGR00089066 dptc: restructure into common driver

Restructure DPTC driver into common driver

Signed-off-by: Nancy Chen <Nancy.Chen@freescale.com>
---
 arch/arm/mach-mx3/clock.c           |    3 +-
 arch/arm/mach-mx3/devices.c         |   65 ++++-
 arch/arm/mach-mx3/dptc.c            |  110 +++++-----
 arch/arm/mach-mx37/Makefile         |    2 +-
 arch/arm/mach-mx37/crm_regs.h       |   37 +++
 arch/arm/mach-mx37/devices.c        |  158 ++++++++++---
 arch/arm/mach-mx37/dptc.c           |   69 ++++++
 arch/arm/mach-mx37/dptc_gp.c        |   43 ----
 arch/arm/mach-mx37/dptc_lp.c        |   46 ----
 arch/arm/plat-mxc/Makefile          |    2 +-
 arch/arm/plat-mxc/dptc.c            |  426 ++++++++++++++++++++-------------
 arch/arm/plat-mxc/dptc_gp.c         |  456 -----------------------------------
 arch/arm/plat-mxc/dptc_lp.c         |  456 -----------------------------------
 include/asm-arm/arch-mxc/mxc.h      |   28 ---
 include/asm-arm/arch-mxc/mxc_dptc.h |  110 +++++++++
 15 files changed, 713 insertions(+), 1298 deletions(-)

diff --git a/arch/arm/mach-mx3/clock.c b/arch/arm/mach-mx3/clock.c
index 4df7ea3..1a26745 100644
--- a/arch/arm/mach-mx3/clock.c
+++ b/arch/arm/mach-mx3/clock.c
@@ -18,6 +18,7 @@
 #include <linux/clk.h>
 #include <asm/io.h>
 #include <asm/arch/clock.h>
+#include <asm/arch/mxc_dptc.h>
 #include <asm/div64.h>
 
 #include "crm_regs.h"
@@ -25,8 +26,6 @@
 #define PRE_DIV_MIN_FREQ    10000000	/* Minimum Frequency after Predivider */
 #define PROPAGATE_RATE_DIS  2
 
-extern void dptc_suspend(void);
-
 static int cpu_clk_set_wp(int wp);
 struct timer_list dptcen_timer;
 
diff --git a/arch/arm/mach-mx3/devices.c b/arch/arm/mach-mx3/devices.c
index abf483e..25c2848 100644
--- a/arch/arm/mach-mx3/devices.c
+++ b/arch/arm/mach-mx3/devices.c
@@ -25,12 +25,13 @@
 #include <asm/arch/pmic_power.h>
 
 #include <asm/arch/spba.h>
+#include <asm/arch/mxc_dptc.h>
 #include "iomux.h"
+#include "crm_regs.h"
 #include <asm/arch/sdma.h>
 #include "sdma_script_code.h"
 #include "sdma_script_code_pass2.h"
 
-#ifndef CONFIG_MXC_DPTC
 extern struct dptc_wp dptc_wp_allfreq_26ckih[DPTC_WP_SUPPORTED];
 extern struct dptc_wp dptc_wp_allfreq_26ckih_TO_2_0[DPTC_WP_SUPPORTED];
 extern struct dptc_wp dptc_wp_allfreq_27ckih_TO_2_0[DPTC_WP_SUPPORTED];
@@ -38,7 +39,6 @@ extern struct dptc_wp dptc_wp_allfreq_27ckih_TO_2_0[DPTC_WP_SUPPORTED];
  * Clock structures
  */
 static struct clk *ckih_clk;
-#endif
 
 void mxc_sdma_get_script_info(sdma_script_start_addrs * sdma_script_addr)
 {
@@ -702,14 +702,57 @@ static inline void mxc_init_dma(void)
 	(void)platform_device_register(&mxc_dma_device);
 }
 
-#ifndef CONFIG_MXC_DPTC
-/*! Device Definition for DPTC */
+/*!
+ * Resource definition for the DPTC LP
+ */
+static struct resource dptc_resources[] = {
+	[0] = {
+	       .start = MXC_CCM_BASE,
+	       .end = MXC_CCM_BASE + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_CCM,
+	       .end = MXC_INT_CCM,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for DPTC */
+static struct mxc_dptc_data dptc_data = {
+	.reg_id = "SW1A_NORMAL",
+	.clk_id = "cpu_clk",
+	.dptccr_reg_addr = MXC_CCM_PMCR0,
+	.dcvr0_reg_addr = MXC_CCM_DCVR0,
+	.gpc_cntr_reg_addr = MXC_CCM_PMCR0,
+	.dptccr = 0xFFFFFFFF,
+	.dptc_wp_supported = DPTC_WP_SUPPORTED,
+	.dptc_wp_allfreq = dptc_wp_allfreq_26ckih,
+	.clk_max_val = 532000000,
+	.gpc_adu = 0x0,
+	.vai_mask = MXC_CCM_PMCR0_PTVAI_MASK,
+	.vai_offset = MXC_CCM_PMCR0_PTVAI_OFFSET,
+	.dptc_enable_bit = MXC_CCM_PMCR0_DPTEN,
+	.irq_mask = MXC_CCM_PMCR0_PTVAIM,
+	.dptc_nvcr_bit = 0x0,
+	.gpc_irq_bit = 0x00000000,
+	.init_config =
+	    MXC_CCM_PMCR0_PTVIS | MXC_CCM_PMCR0_DRCE3 | MXC_CCM_PMCR0_DRCE1,
+	.enable_config =
+	    MXC_CCM_PMCR0_DPTEN | MXC_CCM_PMCR0_DPVCR | MXC_CCM_PMCR0_DPVV,
+	.dcr_mask = MXC_CCM_PMCR0_DCR,
+};
+
+/*! Device Definition for MXC DPTC */
 static struct platform_device mxc_dptc_device = {
 	.name = "mxc_dptc",
+	.id = 0,
 	.dev = {
 		.release = mxc_nop_release,
-		.platform_data = &dptc_wp_allfreq_26ckih,
+		.platform_data = &dptc_data,
 		},
+	.num_resources = ARRAY_SIZE(dptc_resources),
+	.resource = dptc_resources,
 };
 
 static inline void mxc_init_dptc(void)
@@ -717,20 +760,18 @@ static inline void mxc_init_dptc(void)
 	if (clk_get_rate(ckih_clk) == 27000000) {
 
 		if (mxc_cpu_is_rev(CHIP_REV_2_0) < 0)
-			mxc_dptc_device.dev.platform_data = NULL;
+			dptc_data.dptc_wp_allfreq = NULL;
 		else
-			mxc_dptc_device.dev.platform_data =
-			    &dptc_wp_allfreq_27ckih_TO_2_0;
+			dptc_data.dptc_wp_allfreq =
+			    dptc_wp_allfreq_27ckih_TO_2_0;
 
 	} else if (clk_get_rate(ckih_clk) == 26000000
 		   && mxc_cpu_is_rev(CHIP_REV_2_0) == 1) {
-		mxc_dptc_device.dev.platform_data =
-		    &dptc_wp_allfreq_26ckih_TO_2_0;
+		dptc_data.dptc_wp_allfreq = dptc_wp_allfreq_26ckih_TO_2_0;
 	}
 
 	(void)platform_device_register(&mxc_dptc_device);
 }
-#endif
 
 #ifdef	CONFIG_MXC_VPU
 static struct resource vpu_resources[] = {
@@ -779,10 +820,8 @@ static int __init mxc_init_devices(void)
 	mxc_init_hmp4e();
 	mxc_init_dma();
 	mxc_init_audio();
-#ifndef CONFIG_MXC_DPTC
 	ckih_clk = clk_get(NULL, "ckih");
 	mxc_init_dptc();
-#endif
 	mxc_init_vpu();
 
 	/* SPBA configuration for SSI2 - SDMA and MCU are set */
diff --git a/arch/arm/mach-mx3/dptc.c b/arch/arm/mach-mx3/dptc.c
index 47a36a1..8cb1d3c 100644
--- a/arch/arm/mach-mx3/dptc.c
+++ b/arch/arm/mach-mx3/dptc.c
@@ -19,85 +19,85 @@
  * @ingroup PM
  */
 
-#include <asm/arch/pmic_power.h>
 #include <asm/arch/hardware.h>
+#include <asm/arch/mxc_dptc.h>
 
 struct dptc_wp dptc_wp_allfreq_26ckih[DPTC_WP_SUPPORTED] = {
 	/* 532MHz */
-	/* dcvr0      dcvr1       dcvr2       dcvr3       regulator voltage */
+	/* dcvr0      dcvr1       dcvr2       dcvr3     voltage */
 	/* wp0 */
-	{0xffc00000, 0x95c00000, 0xffc00000, 0xe5800000, SW_SW1A, SW1A_1_625V},
-	{0xffc00000, 0x95e3e8e4, 0xffc00000, 0xe5b6fda0, SW_SW1A, SW1A_1_6V},
-	{0xffc00000, 0x95e3e8e4, 0xffc00000, 0xe5b6fda0, SW_SW1A, SW1A_1_575V},
-	{0xffc00000, 0x95e3e8e8, 0xffc00000, 0xe5f70da4, SW_SW1A, SW1A_1_55V},
-	{0xffc00000, 0x9623f8e8, 0xffc00000, 0xe6371da8, SW_SW1A, SW1A_1_525V},
+	{0xffc00000, 0x95c00000, 0xffc00000, 0xe5800000, 1625},
+	{0xffc00000, 0x95e3e8e4, 0xffc00000, 0xe5b6fda0, 1600},
+	{0xffc00000, 0x95e3e8e4, 0xffc00000, 0xe5b6fda0, 1575},
+	{0xffc00000, 0x95e3e8e8, 0xffc00000, 0xe5f70da4, 1550},
+	{0xffc00000, 0x9623f8e8, 0xffc00000, 0xe6371da8, 1525},
 	/* wp5 */
-	{0xffc00000, 0x966408f0, 0xffc00000, 0xe6b73db0, SW_SW1A, SW1A_1_5V},
-	{0xffc00000, 0x96e428f4, 0xffc00000, 0xe7776dbc, SW_SW1A, SW1A_1_475V},
-	{0xffc00000, 0x976448fc, 0xffc00000, 0xe8379dc8, SW_SW1A, SW1A_1_45V},
-	{0xffc00000, 0x97e46904, 0xffc00000, 0xe977ddd8, SW_SW1A, SW1A_1_425V},
-	{0xffc00000, 0x98a48910, 0xffc00000, 0xeab81de8, SW_SW1A, SW1A_1_4V},
+	{0xffc00000, 0x966408f0, 0xffc00000, 0xe6b73db0, 1500},
+	{0xffc00000, 0x96e428f4, 0xffc00000, 0xe7776dbc, 1475},
+	{0xffc00000, 0x976448fc, 0xffc00000, 0xe8379dc8, 1450},
+	{0xffc00000, 0x97e46904, 0xffc00000, 0xe977ddd8, 1425},
+	{0xffc00000, 0x98a48910, 0xffc00000, 0xeab81de8, 1400},
 	/* wp10 */
-	{0xffc00000, 0x9964b918, 0xffc00000, 0xebf86df8, SW_SW1A, SW1A_1_375V},
-	{0xffc00000, 0xffe4e924, 0xffc00000, 0xfff8ae08, SW_SW1A, SW1A_1_35V},
-	{0xffc00000, 0xffe5192c, 0xffc00000, 0xfff8fe1c, SW_SW1A, SW1A_1_35V},
-	{0xffc00000, 0xffe54938, 0xffc00000, 0xfff95e2c, SW_SW1A, SW1A_1_35V},
-	{0xffc00000, 0xffe57944, 0xffc00000, 0xfff9ae44, SW_SW1A, SW1A_1_35V},
+	{0xffc00000, 0x9964b918, 0xffc00000, 0xebf86df8, 1375},
+	{0xffc00000, 0xffe4e924, 0xffc00000, 0xfff8ae08, 1350},
+	{0xffc00000, 0xffe5192c, 0xffc00000, 0xfff8fe1c, 1350},
+	{0xffc00000, 0xffe54938, 0xffc00000, 0xfff95e2c, 1350},
+	{0xffc00000, 0xffe57944, 0xffc00000, 0xfff9ae44, 1350},
 	/* wp15 */
-	{0xffc00000, 0xffe5b954, 0xffc00000, 0xfffa0e58, SW_SW1A, SW1A_1_35V},
-	{0xffc00000, 0xffe5e960, 0xffc00000, 0xfffa6e70, SW_SW1A, SW1A_1_35V},
+	{0xffc00000, 0xffe5b954, 0xffc00000, 0xfffa0e58, 1350},
+	{0xffc00000, 0xffe5e960, 0xffc00000, 0xfffa6e70, 1350},
 };
 
 struct dptc_wp dptc_wp_allfreq_26ckih_TO_2_0[DPTC_WP_SUPPORTED] = {
 	/* Mx31 TO 2.0  Offset table */
 	/* 532MHz  */
-	/* dcvr0      dcvr1       dcvr2       dcvr3       regulator voltage */
+	/* dcvr0      dcvr1       dcvr2       dcvr3     voltage */
 	/* wp0 */
-	{0xffc00000, 0x9E265978, 0xffc00000, 0xE4371D9C, SW_SW1A, SW1A_1_625V},
-	{0xffc00000, 0x9E665978, 0xffc00000, 0xE4772D9C, SW_SW1A, SW1A_1_6V},
-	{0xffc00000, 0x9EA65978, 0xffc00000, 0xE4772DA0, SW_SW1A, SW1A_1_575V},
-	{0xffc00000, 0x9EE66978, 0xffc00000, 0xE4B73DA0, SW_SW1A, SW1A_1_55V},
-	{0xffc00000, 0x9F26697C, 0xffc00000, 0xE4F73DA0, SW_SW1A, SW1A_1_525V},
+	{0xffc00000, 0x9E265978, 0xffc00000, 0xE4371D9C, 1625},
+	{0xffc00000, 0x9E665978, 0xffc00000, 0xE4772D9C, 1600},
+	{0xffc00000, 0x9EA65978, 0xffc00000, 0xE4772DA0, 1575},
+	{0xffc00000, 0x9EE66978, 0xffc00000, 0xE4B73DA0, 1550},
+	{0xffc00000, 0x9F26697C, 0xffc00000, 0xE4F73DA0, 1525},
 	/* wp5 */
-	{0xffc00000, 0x9F66797C, 0xffc00000, 0xE5774DA4, SW_SW1A, SW1A_1_5V},
-	{0xffc00000, 0x9FE6797C, 0xffc00000, 0xE5F75DA4, SW_SW1A, SW1A_1_475V},
-	{0xffc00000, 0xA026897C, 0xffc00000, 0xE6776DA4, SW_SW1A, SW1A_1_45V},
-	{0xffc00000, 0xA0A6897C, 0xffc00000, 0xE6F77DA8, SW_SW1A, SW1A_1_425V},
-	{0xffc00000, 0xA0E69980, 0xffc00000, 0xE7B78DAC, SW_SW1A, SW1A_1_4V},
+	{0xffc00000, 0x9F66797C, 0xffc00000, 0xE5774DA4, 1500},
+	{0xffc00000, 0x9FE6797C, 0xffc00000, 0xE5F75DA4, 1475},
+	{0xffc00000, 0xA026897C, 0xffc00000, 0xE6776DA4, 1450},
+	{0xffc00000, 0xA0A6897C, 0xffc00000, 0xE6F77DA8, 1425},
+	{0xffc00000, 0xA0E69980, 0xffc00000, 0xE7B78DAC, 1400},
 	/* wp10 */
-	{0xffc00000, 0xA1669980, 0xffc00000, 0xE8379DAC, SW_SW1A, SW1A_1_375V},
-	{0xffc00000, 0xA1A6A980, 0xffc00000, 0xE8F7ADB0, SW_SW1A, SW1A_1_35V},
-	{0xffc00000, 0xA226B984, 0xffc00000, 0xE9F7CDB0, SW_SW1A, SW1A_1_325V},
-	{0xffc00000, 0xA2A6C984, 0xffc00000, 0xEAB7DDB4, SW_SW1A, SW1A_1_3V},
-	{0xffc00000, 0xA326C988, 0xffc00000, 0xEBB7FDB8, SW_SW1A, SW1A_1_275V},
+	{0xffc00000, 0xA1669980, 0xffc00000, 0xE8379DAC, 1375},
+	{0xffc00000, 0xA1A6A980, 0xffc00000, 0xE8F7ADB0, 1350},
+	{0xffc00000, 0xA226B984, 0xffc00000, 0xE9F7CDB0, 1325},
+	{0xffc00000, 0xA2A6C984, 0xffc00000, 0xEAB7DDB4, 1300},
+	{0xffc00000, 0xA326C988, 0xffc00000, 0xEBB7FDB8, 1275},
 	/* wp15 */
-	{0xffc00000, 0xA3A6D988, 0xffc00000, 0xECB80DBC, SW_SW1A, SW1A_1_25V},
-	{0xffc00000, 0xA426E988, 0xffc00000, 0xEDB82DC0, SW_SW1A, SW1A_1_225V},
+	{0xffc00000, 0xA3A6D988, 0xffc00000, 0xECB80DBC, 1250},
+	{0xffc00000, 0xA426E988, 0xffc00000, 0xEDB82DC0, 1225},
 };
 
 struct dptc_wp dptc_wp_allfreq_27ckih_TO_2_0[DPTC_WP_SUPPORTED] = {
 	/* Mx31 TO 2.0  Offset table */
 	/* 532MHz  */
-	/* dcvr0      dcvr1       dcvr2       dcvr3       regulator voltage */
+	/* dcvr0      dcvr1       dcvr2       dcvr3     voltage */
 	/* wp0 */
-	{0xffc00000, 0x9864E920, 0xffc00000, 0xDBB50D1C, SW_SW1A, SW1A_1_625V},
-	{0xffc00000, 0x98A4E920, 0xffc00000, 0xDBF51D1C, SW_SW1A, SW1A_1_6V},
-	{0xffc00000, 0x98E4E920, 0xffc00000, 0xDBF51D20, SW_SW1A, SW1A_1_575V},
-	{0xffc00000, 0x9924F920, 0xffc00000, 0xDC352D20, SW_SW1A, SW1A_1_55V},
-	{0xffc00000, 0x9924F924, 0xffc00000, 0xDC752D20, SW_SW1A, SW1A_1_525V},
+	{0xffc00000, 0x9864E920, 0xffc00000, 0xDBB50D1C, 1625},
+	{0xffc00000, 0x98A4E920, 0xffc00000, 0xDBF51D1C, 1600},
+	{0xffc00000, 0x98E4E920, 0xffc00000, 0xDBF51D20, 1575},
+	{0xffc00000, 0x9924F920, 0xffc00000, 0xDC352D20, 1550},
+	{0xffc00000, 0x9924F924, 0xffc00000, 0xDC752D20, 1525},
 	/* wp5 */
-	{0xffc00000, 0x99650924, 0xffc00000, 0xDCF53D24, SW_SW1A, SW1A_1_5V},
-	{0xffc00000, 0x99E50924, 0xffc00000, 0xDD754D24, SW_SW1A, SW1A_1_475V},
-	{0xffc00000, 0x9A251924, 0xffc00000, 0xDDF55D24, SW_SW1A, SW1A_1_45V},
-	{0xffc00000, 0x9AA51924, 0xffc00000, 0xDE756D28, SW_SW1A, SW1A_1_425V},
-	{0xffc00000, 0x9AE52928, 0xffc00000, 0xDF357D2C, SW_SW1A, SW1A_1_4V},
+	{0xffc00000, 0x99650924, 0xffc00000, 0xDCF53D24, 1500},
+	{0xffc00000, 0x99E50924, 0xffc00000, 0xDD754D24, 1475},
+	{0xffc00000, 0x9A251924, 0xffc00000, 0xDDF55D24, 1450},
+	{0xffc00000, 0x9AA51924, 0xffc00000, 0xDE756D28, 1425},
+	{0xffc00000, 0x9AE52928, 0xffc00000, 0xDF357D2C, 1400},
 	/* wp10 */
-	{0xffc00000, 0x9B652928, 0xffc00000, 0xDFB58D2C, SW_SW1A, SW1A_1_375V},
-	{0xffc00000, 0x9BA53928, 0xffc00000, 0xE0759D30, SW_SW1A, SW1A_1_35V},
-	{0xffc00000, 0x9C254928, 0xffc00000, 0xE135BD30, SW_SW1A, SW1A_1_325V},
-	{0xffc00000, 0x9CA55928, 0xffc00000, 0xE1F5CD34, SW_SW1A, SW1A_1_3V},
-	{0xffc00000, 0x9D25592C, 0xffc00000, 0xE2F5ED38, SW_SW1A, SW1A_1_275V},
+	{0xffc00000, 0x9B652928, 0xffc00000, 0xDFB58D2C, 1375},
+	{0xffc00000, 0x9BA53928, 0xffc00000, 0xE0759D30, 1350},
+	{0xffc00000, 0x9C254928, 0xffc00000, 0xE135BD30, 1325},
+	{0xffc00000, 0x9CA55928, 0xffc00000, 0xE1F5CD34, 1300},
+	{0xffc00000, 0x9D25592C, 0xffc00000, 0xE2F5ED38, 1275},
 	/* wp15 */
-	{0xffc00000, 0x9DA5692C, 0xffc00000, 0xE3F5FD38, SW_SW1A, SW1A_1_25V},
-	{0xffc00000, 0x9E25792C, 0xffc00000, 0xE4F61D3C, SW_SW1A, SW1A_1_225V},
+	{0xffc00000, 0x9DA5692C, 0xffc00000, 0xE3F5FD38, 1250},
+	{0xffc00000, 0x9E25792C, 0xffc00000, 0xE4F61D3C, 1225},
 };
diff --git a/arch/arm/mach-mx37/Makefile b/arch/arm/mach-mx37/Makefile
index 2e79663..ea59215 100644
--- a/arch/arm/mach-mx37/Makefile
+++ b/arch/arm/mach-mx37/Makefile
@@ -4,7 +4,7 @@
 
 # Object file lists.
 
-obj-y   := system.o iomux.o cpu.o mm.o clock.o devices.o serial.o dma.o lpmodes.o dptc_gp.o dptc_lp.o
+obj-y   := system.o iomux.o cpu.o mm.o clock.o devices.o serial.o dma.o lpmodes.o dptc.o
 
 
 obj-$(CONFIG_MACH_MX37_3DS) += mx37_3stack.o mx37_3stack_gpio.o 
diff --git a/arch/arm/mach-mx37/crm_regs.h b/arch/arm/mach-mx37/crm_regs.h
index 0e38c8e..9406db9 100644
--- a/arch/arm/mach-mx37/crm_regs.h
+++ b/arch/arm/mach-mx37/crm_regs.h
@@ -548,6 +548,43 @@
 #define MXC_DVFSPT2 		(MXC_DVFS_CORE_BASE + 0x3C)
 #define MXC_DVFSPT3 		(MXC_DVFS_CORE_BASE + 0x40)
 
+/* DPTC GP */
+#define MXC_GP_DPTCCR		(MXC_DPTC_GP_BASE + 0x00)
+#define MXC_GP_DPTCDBG		(MXC_DPTC_GP_BASE + 0x04)
+#define MXC_GP_DCVR0		(MXC_DPTC_GP_BASE + 0x08)
+#define MXC_GP_DCVR1		(MXC_DPTC_GP_BASE + 0x0C)
+#define MXC_GP_DCVR2		(MXC_DPTC_GP_BASE + 0x10)
+#define MXC_GP_DCVR3		(MXC_DPTC_GP_BASE + 0x14)
+
+/* DPTC LP */
+#define MXC_LP_DPTCCR		(MXC_DPTC_LP_BASE + 0x00)
+#define MXC_LP_DPTCDBG		(MXC_DPTC_LP_BASE + 0x04)
+#define MXC_LP_DCVR0		(MXC_DPTC_LP_BASE + 0x08)
+#define MXC_LP_DCVR1		(MXC_DPTC_LP_BASE + 0x0C)
+#define MXC_LP_DCVR2		(MXC_DPTC_LP_BASE + 0x10)
+#define MXC_LP_DCVR3		(MXC_DPTC_LP_BASE + 0x14)
+
+#define MXC_DPTCCR_DRCE3                     0x00400000
+#define MXC_DPTCCR_DRCE2                     0x00200000
+#define MXC_DPTCCR_DRCE1                     0x00100000
+#define MXC_DPTCCR_DRCE0                     0x00080000
+#define MXC_DPTCCR_DCR_256                   0x00060000
+#define MXC_DPTCCR_DCR_128                   0x00040000
+#define MXC_DPTCCR_DCR_64                    0x00020000
+#define MXC_DPTCCR_DCR_32                    0x00000000
+#define MXC_DPTCCR_DSMM                      0x00000040
+#define MXC_DPTCCR_DPNVCR                    0x00000020
+#define MXC_DPTCCR_DPVV                      0x00000010
+#define MXC_DPTCCR_VAIM                      0x00000008
+#define MXC_DPTCCR_VAI_OFFSET                1
+#define MXC_DPTCCR_VAI_MASK                  0x00000006
+#define MXC_DPTCCR_DEN                       0x00000001
+
+#define MXC_GPCCNTR_GPCIRQ                   0x00100000
+#define MXC_GPCCNTR_DPTC0CR                  0x00040000
+#define MXC_GPCCNTR_DPTC1CR                  0x00080000
+#define MXC_GPCCNTR_ADU                      0x00008000
+
 /* SRPG */
 #define MXC_SRPGC_EMI_SRPGCR	(MXC_SRPGC_EMI_BASE + 0x0)
 #define MXC_SRPGC_ARM_SRPGCR	(MXC_SRPGC_ARM_BASE + 0x0)
diff --git a/arch/arm/mach-mx37/devices.c b/arch/arm/mach-mx37/devices.c
index cd82a09..037a186 100644
--- a/arch/arm/mach-mx37/devices.c
+++ b/arch/arm/mach-mx37/devices.c
@@ -22,10 +22,12 @@
 #include <asm/hardware.h>
 
 #include <asm/arch/spba.h>
+#include <asm/arch/mxc_dptc.h>
 #include "iomux.h"
 #include <asm/arch/sdma.h>
 #include "sdma_script_code.h"
 #include <asm/arch/mxc_scc2_driver.h>
+#include "crm_regs.h"
 
 extern struct dptc_wp dptc_gp_wp_allfreq[DPTC_GP_WP_SUPPORTED];
 extern struct dptc_wp dptc_lp_wp_allfreq[DPTC_LP_WP_SUPPORTED];
@@ -569,6 +571,129 @@ static struct resource tve_resources[] = {
 	 },
 };
 
+/*!
+ * Resource definition for the DPTC GP
+ */
+static struct resource dptc_gp_resources[] = {
+	[0] = {
+	       .start = MXC_DPTC_GP_BASE,
+	       .end = MXC_DPTC_GP_BASE + 8 * SZ_16 - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_GPC1,
+	       .end = MXC_INT_GPC1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for DPTC GP */
+static struct mxc_dptc_data dptc_gp_data = {
+	.reg_id = "SW1",
+	.clk_id = "cpu_clk",
+	.dptccr_reg_addr = MXC_GP_DPTCCR,
+	.dcvr0_reg_addr = MXC_GP_DCVR0,
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.dptccr = MXC_GPCCNTR_DPTC0CR,
+	.dptc_wp_supported = DPTC_GP_WP_SUPPORTED,
+	.dptc_wp_allfreq = dptc_gp_wp_allfreq,
+	.clk_max_val = 532000000,
+	.gpc_adu = MXC_GPCCNTR_ADU,
+	.vai_mask = MXC_DPTCCR_VAI_MASK,
+	.vai_offset = MXC_DPTCCR_VAI_OFFSET,
+	.dptc_enable_bit = MXC_DPTCCR_DEN,
+	.irq_mask = MXC_DPTCCR_VAIM,
+	.dptc_nvcr_bit = MXC_DPTCCR_DPNVCR,
+	.gpc_irq_bit = MXC_GPCCNTR_GPCIRQ,
+	.init_config =
+	    MXC_DPTCCR_DRCE0 | MXC_DPTCCR_DRCE1 | MXC_DPTCCR_DRCE2 |
+	    MXC_DPTCCR_DRCE3 | MXC_DPTCCR_DCR_128 | MXC_DPTCCR_DPNVCR |
+	    MXC_DPTCCR_DPVV,
+	.enable_config =
+	    MXC_DPTCCR_DEN | MXC_DPTCCR_DPNVCR | MXC_DPTCCR_DPVV |
+	    MXC_DPTCCR_DSMM,
+	.dcr_mask = MXC_DPTCCR_DCR_256,
+};
+
+/*!
+ * Resource definition for the DPTC LP
+ */
+static struct resource dptc_lp_resources[] = {
+	[0] = {
+	       .start = MXC_DPTC_LP_BASE,
+	       .end = MXC_DPTC_LP_BASE + 8 * SZ_16 - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_GPC1,
+	       .end = MXC_INT_GPC1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC DPTC LP */
+static struct mxc_dptc_data dptc_lp_data = {
+	.reg_id = "SW2",
+	.clk_id = "ahb_clk",
+	.dptccr_reg_addr = MXC_LP_DPTCCR,
+	.dcvr0_reg_addr = MXC_LP_DCVR0,
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.dptccr = MXC_GPCCNTR_DPTC1CR,
+	.dptc_wp_supported = DPTC_LP_WP_SUPPORTED,
+	.dptc_wp_allfreq = dptc_lp_wp_allfreq,
+	.clk_max_val = 133000000,
+	.gpc_adu = 0x0,
+	.vai_mask = MXC_DPTCCR_VAI_MASK,
+	.vai_offset = MXC_DPTCCR_VAI_OFFSET,
+	.dptc_enable_bit = MXC_DPTCCR_DEN,
+	.irq_mask = MXC_DPTCCR_VAIM,
+	.dptc_nvcr_bit = MXC_DPTCCR_DPNVCR,
+	.gpc_irq_bit = MXC_GPCCNTR_GPCIRQ,
+	.init_config =
+	    MXC_DPTCCR_DRCE0 | MXC_DPTCCR_DRCE1 | MXC_DPTCCR_DRCE2 |
+	    MXC_DPTCCR_DRCE3 | MXC_DPTCCR_DCR_128 | MXC_DPTCCR_DPNVCR |
+	    MXC_DPTCCR_DPVV,
+	.enable_config =
+	    MXC_DPTCCR_DEN | MXC_DPTCCR_DPNVCR | MXC_DPTCCR_DPVV |
+	    MXC_DPTCCR_DSMM,
+	.dcr_mask = MXC_DPTCCR_DCR_256,
+};
+
+/*! Device Definition for MXC DPTC */
+static struct platform_device mxc_dptc_devices[] = {
+	{
+	 .name = "mxc_dptc",
+	 .id = 0,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = &dptc_gp_data,
+		 },
+	 .num_resources = ARRAY_SIZE(dptc_gp_resources),
+	 .resource = dptc_gp_resources,
+	 },
+	{
+	 .name = "mxc_dptc",
+	 .id = 1,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .platform_data = &dptc_lp_data,
+		 },
+	 .num_resources = ARRAY_SIZE(dptc_lp_resources),
+	 .resource = dptc_lp_resources,
+	 },
+};
+
+static inline void mxc_init_dptc(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mxc_dptc_devices); i++) {
+		if (platform_device_register(&mxc_dptc_devices[i]) < 0)
+			dev_err(&mxc_dptc_devices[i].dev,
+				"Unable to register DPTC device\n");
+	}
+}
+
 static struct platform_device mxc_tve_device = {
 	.name = "tve",
 	.dev = {
@@ -608,36 +733,6 @@ struct mxc_gpio_port mxc_gpio_ports[GPIO_PORT_NUM] = {
 	 },
 };
 
-/*! Device Definition for DPTC GP */
-static struct platform_device mxc_dptc_gp_device = {
-	.name = "mxc_dptc_gp",
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &dptc_gp_wp_allfreq,
-		},
-};
-
-static inline void mxc_init_dptc_gp(void)
-{
-
-	(void)platform_device_register(&mxc_dptc_gp_device);
-}
-
-/*! Device Definition for DPTC LP */
-static struct platform_device mxc_dptc_lp_device = {
-	.name = "mxc_dptc_lp",
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &dptc_lp_wp_allfreq,
-		},
-};
-
-static inline void mxc_init_dptc_lp(void)
-{
-
-	(void)platform_device_register(&mxc_dptc_lp_device);
-}
-
 #if defined(CONFIG_MXC_VPU) || defined(CONFIG_MXC_VPU_MODULE)
 static struct resource vpu_resources[] = {
 	{
@@ -748,8 +843,7 @@ static int __init mxc_init_devices(void)
 	mxc_init_spdif();
 	mxc_init_tve();
 	mx37_init_lpmode();
-	mxc_init_dptc_gp();
-	mxc_init_dptc_lp();
+	mxc_init_dptc();
 	/* SPBA configuration for SSI2 - SDMA and MCU are set */
 	spba_take_ownership(SPBA_SSI2, SPBA_MASTER_C | SPBA_MASTER_A);
 	return 0;
diff --git a/arch/arm/mach-mx37/dptc.c b/arch/arm/mach-mx37/dptc.c
new file mode 100644
index 0000000..32eb260
--- /dev/null
+++ b/arch/arm/mach-mx37/dptc.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dptc_gp.c
+ *
+ * @brief DPTC table for the Freescale Semiconductor MXC DPTC module.
+ *
+ * @ingroup PM
+ */
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/mxc_dptc.h>
+
+struct dptc_wp dptc_gp_wp_allfreq[DPTC_GP_WP_SUPPORTED] = {
+	/* 532MHz */
+	/* dcvr0                  dcvr1                dcvr2
+	   dcvr3            voltage */
+	/* wp0 */
+	{DCVR(107, 108, 112), DCVR(122, 123, 127), DCVR(133, 134, 139),
+	 DCVR(115, 116, 121), 1000},
+	{DCVR(107, 108, 113), DCVR(122, 123, 127), DCVR(133, 134, 139),
+	 DCVR(115, 117, 122), 975},
+	{DCVR(107, 109, 113), DCVR(122, 123, 127), DCVR(133, 134, 139),
+	 DCVR(115, 117, 122), 950},
+	{DCVR(107, 109, 114), DCVR(122, 123, 127), DCVR(133, 135, 140),
+	 DCVR(115, 117, 122), 925},
+	{DCVR(108, 109, 115), DCVR(122, 123, 127), DCVR(133, 136, 142),
+	 DCVR(115, 117, 123), 900},
+	{DCVR(108, 110, 115), DCVR(122, 123, 127), DCVR(133, 136, 142),
+	 DCVR(115, 117, 123), 875},
+	{DCVR(108, 110, 115), DCVR(122, 124, 128), DCVR(133, 136, 143),
+	 DCVR(115, 118, 124), 850},
+};
+
+struct dptc_wp dptc_lp_wp_allfreq[DPTC_LP_WP_SUPPORTED] = {
+	/* 532MHz */
+	/* dcvr0                  dcvr1                dcvr2
+	   dcvr3            regulator  voltage */
+	/* wp0 */
+	{DCVR(141, 143, 149), DCVR(155, 157, 162), DCVR(106, 108, 112),
+	 DCVR(124, 126, 130), 1200},
+	{DCVR(141, 143, 149), DCVR(155, 157, 162), DCVR(106, 108, 113),
+	 DCVR(124, 126, 131), 1175},
+	{DCVR(141, 144, 150), DCVR(155, 157, 163), DCVR(106, 108, 113),
+	 DCVR(124, 126, 131), 1150},
+	{DCVR(141, 144, 151), DCVR(155, 157, 163), DCVR(106, 108, 114),
+	 DCVR(124, 126, 131), 1125},
+	{DCVR(142, 144, 152), DCVR(155, 157, 163), DCVR(107, 109, 114),
+	 DCVR(125, 127, 132), 1100},
+	{DCVR(142, 145, 153), DCVR(155, 157, 164), DCVR(107, 109, 115),
+	 DCVR(125, 127, 133), 1075},
+	{DCVR(142, 145, 153), DCVR(155, 158, 164), DCVR(107, 109, 116),
+	 DCVR(125, 127, 133), 1050},
+	{DCVR(142, 145, 154), DCVR(155, 158, 165), DCVR(107, 110, 117),
+	 DCVR(125, 127, 134), 1025},
+	{DCVR(142, 146, 156), DCVR(155, 158, 165), DCVR(107, 110, 117),
+	 DCVR(125, 128, 135), 1000},
+};
diff --git a/arch/arm/mach-mx37/dptc_gp.c b/arch/arm/mach-mx37/dptc_gp.c
deleted file mode 100644
index a943e51..0000000
--- a/arch/arm/mach-mx37/dptc_gp.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-/*!
- * @file dptc_gp.c
- *
- * @brief DPTC table for the Freescale Semiconductor MXC DPTC module.
- *
- * @ingroup PM
- */
-
-#include <asm/arch/hardware.h>
-#include <asm/arch/hardware.h>
-
-struct dptc_wp dptc_gp_wp_allfreq[DPTC_GP_WP_SUPPORTED] = {
-	/* 532MHz */
-	/* dcvr0          dcvr1             dcvr2           dcvr3      regulator  voltage */
-	/* wp0 */
-	{DCVR(107, 108, 112), DCVR(122, 123, 127), DCVR(133, 134, 139),
-	 DCVR(115, 116, 121), "DCDC1", 1000},
-	{DCVR(107, 108, 113), DCVR(122, 123, 127), DCVR(133, 134, 139),
-	 DCVR(115, 117, 122), "DCDC1", 975},
-	{DCVR(107, 109, 113), DCVR(122, 123, 127), DCVR(133, 134, 139),
-	 DCVR(115, 117, 122), "DCDC1", 950},
-	{DCVR(107, 109, 114), DCVR(122, 123, 127), DCVR(133, 135, 140),
-	 DCVR(115, 117, 122), "DCDC1", 925},
-	{DCVR(108, 109, 115), DCVR(122, 123, 127), DCVR(133, 136, 142),
-	 DCVR(115, 117, 123), "DCDC1", 900},
-	{DCVR(108, 110, 115), DCVR(122, 123, 127), DCVR(133, 136, 142),
-	 DCVR(115, 117, 123), "DCDC1", 875},
-	{DCVR(108, 110, 115), DCVR(122, 124, 128), DCVR(133, 136, 143),
-	 DCVR(115, 118, 124), "DCDC1", 850},
-};
diff --git a/arch/arm/mach-mx37/dptc_lp.c b/arch/arm/mach-mx37/dptc_lp.c
deleted file mode 100644
index ac7b3e5..0000000
--- a/arch/arm/mach-mx37/dptc_lp.c
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-/*!
- * @file dptc_lp.c
- *
- * @brief DPTC LP table for the Freescale Semiconductor MXC DPTC LP module.
- *
- * @ingroup PM
- */
-
-#include <asm/arch/hardware.h>
-
-struct dptc_wp dptc_lp_wp_allfreq[DPTC_LP_WP_SUPPORTED] = {
-	/* 532MHz */
-	/* dcvr0          dcvr1             dcvr2           dcvr3      regulator  voltage */
-	/* wp0 */
-	{DCVR(141, 143, 149), DCVR(155, 157, 162), DCVR(106, 108, 112),
-	 DCVR(124, 126, 130), "DCDC4", 1200},
-	{DCVR(141, 143, 149), DCVR(155, 157, 162), DCVR(106, 108, 113),
-	 DCVR(124, 126, 131), "DCDC4", 1175},
-	{DCVR(141, 144, 150), DCVR(155, 157, 163), DCVR(106, 108, 113),
-	 DCVR(124, 126, 131), "DCDC4", 1150},
-	{DCVR(141, 144, 151), DCVR(155, 157, 163), DCVR(106, 108, 114),
-	 DCVR(124, 126, 131), "DCDC4", 1125},
-	{DCVR(142, 144, 152), DCVR(155, 157, 163), DCVR(107, 109, 114),
-	 DCVR(125, 127, 132), "DCDC4", 1100},
-	{DCVR(142, 145, 153), DCVR(155, 157, 164), DCVR(107, 109, 115),
-	 DCVR(125, 127, 133), "DCDC4", 1075},
-	{DCVR(142, 145, 153), DCVR(155, 158, 164), DCVR(107, 109, 116),
-	 DCVR(125, 127, 133), "DCDC4", 1050},
-	{DCVR(142, 145, 154), DCVR(155, 158, 165), DCVR(107, 110, 117),
-	 DCVR(125, 127, 134), "DCDC4", 1025},
-	{DCVR(142, 146, 156), DCVR(155, 158, 165), DCVR(107, 110, 117),
-	 DCVR(125, 128, 135), "DCDC4", 1000},
-};
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
index b7acc4c..264ff01 100644
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -20,7 +20,7 @@ obj-$(CONFIG_ARCH_MX25) +=
 obj-$(CONFIG_ARCH_MX27) += dma_mx2.o usb_common.o
 obj-$(CONFIG_ARCH_MX3) += dptc.o usb_common.o
 obj-$(CONFIG_ARCH_MX35) += usb_common.o serialxc.o
-obj-$(CONFIG_ARCH_MX37)     += usb_common.o utmixc.o dptc_gp.o dptc_lp.o
+obj-$(CONFIG_ARCH_MX37)     += usb_common.o utmixc.o dptc.o
 obj-$(CONFIG_ARCH_MX51)	+= usb_common.o utmixc.o
 
 # LEDs support
diff --git a/arch/arm/plat-mxc/dptc.c b/arch/arm/plat-mxc/dptc.c
index 0c4a66a..9394e04 100644
--- a/arch/arm/plat-mxc/dptc.c
+++ b/arch/arm/plat-mxc/dptc.c
@@ -43,29 +43,10 @@
 
 #include <asm/arch/clock.h>
 #include <asm/arch/gpio.h>
-#include <asm/arch/pmic_external.h>
-#include <asm/arch/pmic_power.h>
+#include <linux/i2c.h>
+#include <linux/regulator/regulator.h>
 #include <asm/arch/hardware.h>
-
-#if defined(CONFIG_ARCH_MX3)
-#include "../mach-mx3/crm_regs.h"
-#elif defined(CONFIG_ARCH_MXC91321)
-#include "../mach-mxc91321/crm_regs.h"
-#else
-#include "../mach-mx27/crm_regs.h"
-#endif
-
-static int dptc_is_active;
-static int turbo_mode_active;
-
-static int curr_wp;
-static u32 ptvai;
-static struct delayed_work dptc_work;
-static struct dptc_wp *dptc_wp_allfreq;
-static struct device *dptc_dev;
-static struct clk *cpu_clk;
-
-DEFINE_SPINLOCK(mxc_dptc_lock);
+#include <asm/arch/mxc_dptc.h>
 
 enum {
 	DPTC_PTVAI_NOCHANGE = 0x0,
@@ -74,64 +55,114 @@ enum {
 	DPTC_PTVAI_EMERG,
 };
 
-static void update_dptc_wp(u32 wp)
-{
-	t_pmic_regulator regulator;
-	t_regulator_voltage voltage;
-
-	regulator = dptc_wp_allfreq[wp].regulator;
-	voltage = (t_regulator_voltage) dptc_wp_allfreq[wp].voltage;
+struct device *dev_data;
 
-	__raw_writel(dptc_wp_allfreq[wp].dcvr0, MXC_CCM_DCVR0);
-	__raw_writel(dptc_wp_allfreq[wp].dcvr1, MXC_CCM_DCVR1);
-	__raw_writel(dptc_wp_allfreq[wp].dcvr2, MXC_CCM_DCVR2);
-	__raw_writel(dptc_wp_allfreq[wp].dcvr3, MXC_CCM_DCVR3);
+/*!
+ * In case the MXC device has multiple DPTC modules, this structure is used to
+ * store information specific to each DPTC module.
+ */
+struct dptc_device {
+	/* DPTC delayed work */
+	struct delayed_work dptc_work;
+	/* DPTC spinlock */
+	spinlock_t lock;
+	/* DPTC regulator */
+	struct regulator *dptc_reg;
+	/* DPTC clock */
+	struct clk *dptc_clk;
+	/* DPTC is active flag */
+	int dptc_is_active;
+	/* turbo mode active flag */
+	int turbo_mode_active;
+	/* DPTC current working point */
+	int curr_wp;
+	/* DPTC vai bits */
+	u32 ptvai;
+	/* The interrupt number used by the DPTC device */
+	int irq;
+	/* DPTC platform data pointer */
+	struct mxc_dptc_data *dptc_platform_data;
+};
 
-	pmic_power_regulator_set_voltage(SW_SW1A, voltage);
+static void update_dptc_wp(struct dptc_device *drv_data, u32 wp)
+{
+	struct mxc_dptc_data *dptc_data = drv_data->dptc_platform_data;
+	int voltage_uV;
+	int ret = 0;
+
+	voltage_uV = mV_to_uV(dptc_data->dptc_wp_allfreq[wp].voltage);
+
+	__raw_writel(dptc_data->dptc_wp_allfreq[wp].dcvr0,
+		     dptc_data->dcvr0_reg_addr);
+	__raw_writel(dptc_data->dptc_wp_allfreq[wp].dcvr1,
+		     dptc_data->dcvr0_reg_addr + 0x4);
+	__raw_writel(dptc_data->dptc_wp_allfreq[wp].dcvr2,
+		     dptc_data->dcvr0_reg_addr + 0x8);
+	__raw_writel(dptc_data->dptc_wp_allfreq[wp].dcvr3,
+		     dptc_data->dcvr0_reg_addr + 0xC);
+
+	/* Set the voltage */
+	ret = regulator_set_voltage(drv_data->dptc_reg, voltage_uV);
+	if (ret < 0)
+		printk(KERN_DEBUG "COULD NOT SET VOLTAGE!!!!!\n");
 
 	pr_debug("dcvr0-3: 0x%x, 0x%x, 0x%x, 0x%x; vol: %d\n",
-		 dptc_wp_allfreq[wp].dcvr0,
-		 dptc_wp_allfreq[wp].dcvr1,
-		 dptc_wp_allfreq[wp].dcvr2,
-		 dptc_wp_allfreq[wp].dcvr3, dptc_wp_allfreq[wp].voltage);
+		 dptc_data->dptc_wp_allfreq[wp].dcvr0,
+		 dptc_data->dptc_wp_allfreq[wp].dcvr1,
+		 dptc_data->dptc_wp_allfreq[wp].dcvr2,
+		 dptc_data->dptc_wp_allfreq[wp].dcvr3,
+		 dptc_data->dptc_wp_allfreq[wp].voltage);
 }
 
 static irqreturn_t dptc_irq(int irq, void *dev_id)
 {
-	u32 pmcr0 = __raw_readl(MXC_CCM_PMCR0);
-
-	ptvai = (pmcr0 & MXC_CCM_PMCR0_PTVAI_MASK) >>
-	    MXC_CCM_PMCR0_PTVAI_OFFSET;
-
-	pr_debug("dptc_irq: ptvai = 0x%x (0x%x)!!!!!!!\n", ptvai, pmcr0);
-
-	/* disable DPTC and mask its interrupt */
-	pmcr0 = (pmcr0 & ~(MXC_CCM_PMCR0_DPTEN)) | MXC_CCM_PMCR0_PTVAIM;
-	__raw_writel(pmcr0, MXC_CCM_PMCR0);
-
-	schedule_delayed_work(&dptc_work, 0);
+	struct device *dev = dev_id;
+	struct dptc_device *drv_data = dev->driver_data;
+	struct mxc_dptc_data *dptc_data = dev->platform_data;
+	u32 dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+	u32 gpc_cntr = __raw_readl(dptc_data->gpc_cntr_reg_addr);
+
+	gpc_cntr = (gpc_cntr & dptc_data->dptccr);
+
+	if (gpc_cntr) {
+		drv_data->ptvai =
+		    (dptccr & dptc_data->vai_mask) >> dptc_data->vai_offset;
+		pr_debug("dptc_irq: vai = 0x%x (0x%x)!!!!!!!\n",
+			 drv_data->ptvai, dptccr);
+
+		/* disable DPTC and mask its interrupt */
+		dptccr = (dptccr & ~(dptc_data->dptc_enable_bit)) |
+		    (dptc_data->irq_mask);
+		dptccr = (dptccr & ~(dptc_data->dptc_nvcr_bit));
+		__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+
+		if (drv_data->turbo_mode_active == 1)
+			schedule_delayed_work(&drv_data->dptc_work, 0);
+	}
 
 	return IRQ_RETVAL(1);
 }
 
-static void dptc_workqueue_handler(struct work_struct *work)
+static void dptc_workqueue_handler(struct work_struct *work1)
 {
-	u32 pmcr0 = __raw_readl(MXC_CCM_PMCR0);
-
-	if (!turbo_mode_active)
-		return;
-	
-	switch (ptvai) {
+	struct delayed_work *dptc_work_tmp =
+	    container_of(work1, struct delayed_work, work);
+	struct dptc_device *drv_data =
+	    container_of(dptc_work_tmp, struct dptc_device, dptc_work);
+	struct mxc_dptc_data *dptc_data = drv_data->dptc_platform_data;
+	u32 dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+
+	switch (drv_data->ptvai) {
 	case DPTC_PTVAI_DECREASE:
-		curr_wp++;
+		drv_data->curr_wp++;
 		break;
 	case DPTC_PTVAI_INCREASE:
 	case DPTC_PTVAI_EMERG:
-		curr_wp--;
-		if (curr_wp < 0) {
+		drv_data->curr_wp--;
+		if (drv_data->curr_wp < 0) {
 			/* already max voltage */
-			curr_wp = 0;
-			printk(KERN_WARNING"dptc: already maximum voltage\n");
+			drv_data->curr_wp = 0;
+			printk(KERN_WARNING "dptc: already maximum voltage\n");
 		}
 		break;
 
@@ -140,69 +171,84 @@ static void dptc_workqueue_handler(struct work_struct *work)
 		BUG();
 	}
 
-	if (curr_wp > DPTC_WP_SUPPORTED || curr_wp < 0) {
-		panic("Can't support this working point: %d\n", curr_wp);
+	if (drv_data->curr_wp > dptc_data->dptc_wp_supported
+	    || drv_data->curr_wp < 0) {
+		panic("Can't support this working point: %d\n",
+		      drv_data->curr_wp);
 	}
-	update_dptc_wp(curr_wp);
+	update_dptc_wp(drv_data, drv_data->curr_wp);
 
-	/* enable DPTC and unmask its interrupt */
-	pmcr0 = (pmcr0 & ~(MXC_CCM_PMCR0_PTVAIM)) | MXC_CCM_PMCR0_DPTEN;
-	__raw_writel(pmcr0, MXC_CCM_PMCR0);
+	/* Enable DPTC and unmask its interrupt */
+	dptccr = (dptccr & ~(dptc_data->irq_mask)) |
+	    dptc_data->dptc_nvcr_bit | dptc_data->dptc_enable_bit;
+	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
 }
 
 /* Start DPTC unconditionally */
-static int start_dptc(void)
+static int start_dptc(struct device *dev)
 {
-	u32 pmcr0, flags;
-	unsigned long cpu_rate;
+	struct mxc_dptc_data *dptc_data = dev->platform_data;
+	struct dptc_device *drv_data = dev->driver_data;
+	u32 dptccr, flags;
+	unsigned long clk_rate;
 
-	spin_lock_irqsave(&mxc_dptc_lock, flags);
+	/* Set the voltage */
+	spin_lock_irqsave(&drv_data->lock, flags);
 
-	cpu_rate = clk_get_rate(cpu_clk);
+	clk_rate = clk_get_rate(drv_data->dptc_clk);
 
-	if (cpu_is_mx27() && cpu_rate < 399000000) {
-		goto err;
-	} else if (cpu_rate < 532000000) {
+	if (clk_rate < dptc_data->clk_max_val)
 		goto err;
+
+	if (dptc_data->gpc_irq_bit != 0x0) {
+		/* Enable ARM domain frequency and/or voltage update needed
+		   and enable ARM IRQ */
+		__raw_writel(dptc_data->gpc_irq_bit | dptc_data->gpc_adu,
+			     dptc_data->gpc_cntr_reg_addr);
 	}
 
-	pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+
+	/* Enable DPTC and unmask its interrupt */
+	dptccr = ((dptccr & ~(dptc_data->irq_mask)) | dptc_data->enable_config);
 
-	/* enable DPTC and unmask its interrupt */
-	pmcr0 = ((pmcr0 & ~(MXC_CCM_PMCR0_PTVAIM)) | MXC_CCM_PMCR0_DPTEN) |
-	    (MXC_CCM_PMCR0_DPVCR | MXC_CCM_PMCR0_DPVV);
+	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
 
-	__raw_writel(pmcr0, MXC_CCM_PMCR0);
+	spin_unlock_irqrestore(&drv_data->lock, flags);
 
-	spin_unlock_irqrestore(&mxc_dptc_lock, flags);
+	drv_data->dptc_is_active = 1;
+	drv_data->turbo_mode_active = 1;
 
 	pr_info("DPTC has been started \n");
 
 	return 0;
 
       err:
-	spin_unlock_irqrestore(&mxc_dptc_lock, flags);
-	pr_info("Core is not running in Turbo mode\n");
+	spin_unlock_irqrestore(&drv_data->lock, flags);
 	pr_info("DPTC is not enabled\n");
 	return -1;
 }
 
 /* Stop DPTC unconditionally */
-static void stop_dptc(void)
+static void stop_dptc(struct device *dev)
 {
-	u32 pmcr0;
+	struct mxc_dptc_data *dptc_data = dev->platform_data;
+	struct dptc_device *drv_data = dev->driver_data;
+	u32 dptccr;
 
-	pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
 
 	/* disable DPTC and mask its interrupt */
-	pmcr0 = ((pmcr0 & ~(MXC_CCM_PMCR0_DPTEN)) | MXC_CCM_PMCR0_PTVAIM) &
-	    (~MXC_CCM_PMCR0_DPVCR);
+	dptccr = ((dptccr & ~(dptc_data->dptc_enable_bit)) |
+		  dptc_data->irq_mask) & (~dptc_data->dptc_nvcr_bit);
 
-	__raw_writel(pmcr0, MXC_CCM_PMCR0);
+	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
 
 	/* Restore Turbo Mode voltage to highest wp */
-	update_dptc_wp(0);
-	curr_wp = 0;
+	update_dptc_wp(drv_data, 0);
+	drv_data->curr_wp = 0;
+
+	regulator_put(drv_data->dptc_reg, NULL);
 
 	pr_info("DPTC has been stopped\n");
 }
@@ -211,53 +257,61 @@ static void stop_dptc(void)
   this function does not change the working point. It can be
  called from an interrupt context.
 */
-void dptc_suspend(void)
+void dptc_suspend()
 {
-	u32 pmcr0;
+	struct mxc_dptc_data *dptc_data = dev_data->platform_data;
+	struct dptc_device *drv_data = dev_data->driver_data;
+	u32 dptccr;
 
-	if (!dptc_is_active)
+	if (!drv_data->dptc_is_active)
 		return;
 
-	pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
 
 	/* disable DPTC and mask its interrupt */
-	pmcr0 = ((pmcr0 & ~(MXC_CCM_PMCR0_DPTEN)) | MXC_CCM_PMCR0_PTVAIM) &
-	    (~MXC_CCM_PMCR0_DPVCR);
+	dptccr =
+	    ((dptccr & ~(dptc_data->dptc_enable_bit)) | dptc_data->
+	     irq_mask) & (~dptc_data->dptc_nvcr_bit);
 
-	__raw_writel(pmcr0, MXC_CCM_PMCR0);
+	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
 }
+EXPORT_SYMBOL(dptc_suspend);
 
 /*!
  * This function is called to put the DPTC in a low power state.
  *
  */
-void dptc_disable(void)
+void dptc_disable(struct device *dev)
 {
-	if (!dptc_is_active)
+	struct dptc_device *drv_data = dev->driver_data;
+
+	if (!(drv_data->dptc_is_active))
 		return;
 
-	stop_dptc();
-	dptc_is_active = 0;
-	turbo_mode_active = 0;
+	stop_dptc(dev);
+	drv_data->dptc_is_active = 0;
+	drv_data->turbo_mode_active = 0;
 }
 
 /*!
  * This function is called to resume the DPTC from a low power state.
  *
  */
-void dptc_enable(void)
+void dptc_enable(struct device *dev)
 {
-	if (dptc_is_active)
+	struct dptc_device *drv_data = dev->driver_data;
+
+	if (drv_data->dptc_is_active)
 		return;
-	start_dptc();
-	dptc_is_active = 1;
-	turbo_mode_active = 1;
+	start_dptc(dev);
 }
 
 static ssize_t dptc_show(struct device *dev, struct device_attribute *attr,
 			 char *buf)
 {
-	if (dptc_is_active)
+	struct dptc_device *drv_data = dev->driver_data;
+
+	if (drv_data->dptc_is_active)
 		return sprintf(buf, "DPTC is enabled\n");
 	else
 		return sprintf(buf, "DPTC is disabled\n");
@@ -267,9 +321,9 @@ static ssize_t dptc_store(struct device *dev, struct device_attribute *attr,
 			  const char *buf, size_t size)
 {
 	if (strstr(buf, "0") != NULL) {
-		dptc_disable();
+		dptc_disable(dev);
 	} else if (strstr(buf, "1") != NULL) {
-		dptc_enable();
+		dptc_enable(dev);
 	}
 
 	return size;
@@ -287,13 +341,58 @@ static DEVICE_ATTR(enable, 0644, dptc_show, dptc_store);
  */
 static int __devinit mxc_dptc_probe(struct platform_device *pdev)
 {
-	int res = 0;
-	u32 pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+	struct dptc_device *dptc_device_data;
+	int ret = 0;
+	struct resource *res;
+	u32 dptccr = 0;
 	struct clk *ckih_clk;
+	struct mxc_dptc_data *dptc_data = pdev->dev.platform_data;
 
-	dptc_dev = &pdev->dev;
-	dptc_wp_allfreq = pdev->dev.platform_data;
-	if (dptc_wp_allfreq == NULL) {
+	if (dptc_data == NULL) {
+		printk(KERN_ERR "DPTC: Pointer to DPTC data is NULL\
+				not started\n");
+		return -1;
+	}
+
+	dptc_device_data = kzalloc(sizeof(struct dptc_device), GFP_KERNEL);
+	if (!dptc_device_data)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	/*
+	 * Request the DPTC interrupt
+	 */
+	dptc_device_data->irq = platform_get_irq(pdev, 0);
+	if (dptc_device_data->irq < 0) {
+		ret = dptc_device_data->irq;
+		goto err1;
+	}
+
+	ret =
+	    request_irq(dptc_device_data->irq, dptc_irq, IRQF_SHARED,
+			pdev->name, &pdev->dev);
+	if (ret) {
+		printk(KERN_ERR "DPTC: Unable to attach to DPTC interrupt\n");
+		goto err1;
+	}
+
+	dptc_device_data->curr_wp = 0;
+	dptc_device_data->dptc_is_active = 0;
+	dptc_device_data->turbo_mode_active = 0;
+	dptc_device_data->ptvai = 0;
+
+	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+
+	printk(KERN_INFO "DPTC mxc_dptc_probe()\n");
+
+	spin_lock_init(&dptc_device_data->lock);
+
+	if (dptc_data->dptc_wp_allfreq == NULL) {
 		ckih_clk = clk_get(NULL, "ckih");
 		if (cpu_is_mx31() &
 		    (mxc_cpu_is_rev(CHIP_REV_2_0) < 0) &
@@ -303,51 +402,51 @@ static int __devinit mxc_dptc_probe(struct platform_device *pdev)
 		else
 			printk(KERN_ERR "DPTC: Pointer to DPTC table is NULL\
 					not started\n");
-		return -1;
+		goto err1;
 	}
 
-	INIT_DELAYED_WORK(&dptc_work, dptc_workqueue_handler);
-
-	/* request the DPTC interrupt */
-	res =
-	    request_irq(MXC_INT_CCM, dptc_irq, IRQF_DISABLED, "mxc-dptc", NULL);
-	if (res) {
-		printk(KERN_ERR "DPTC: Unable to attach to DPTC interrupt");
-		return res;
+	dptc_device_data->dptc_reg = regulator_get(NULL, dptc_data->reg_id);
+	if (IS_ERR(dptc_device_data->dptc_reg)) {
+		clk_put(dptc_device_data->dptc_clk);
+		printk(KERN_ERR "%s: failed to get regulator\n", __func__);
+		goto err1;
 	}
 
-	if (cpu_is_mx31()) {
-		/* 256 system clock count; ARM interrupt; enable all 2 rf circuits */
-		pmcr0 = (pmcr0 & ~(MXC_CCM_PMCR0_DCR)) | MXC_CCM_PMCR0_PTVIS |
-		    MXC_CCM_PMCR0_DRCE3 | MXC_CCM_PMCR0_DRCE1;
-	} else if (cpu_is_mx27()) {
-		pmcr0 =
-		    (pmcr0 & ~(MXC_CCM_PMCR0_DCR)) | MXC_CCM_PMCR0_DRCE3 |
-		    MXC_CCM_PMCR0_DRCE1;
-	}
+	INIT_DELAYED_WORK(&dptc_device_data->dptc_work, dptc_workqueue_handler);
 
-	__raw_writel(pmcr0, MXC_CCM_PMCR0);
+	/* Enable Reference Circuits */
+	dptccr = (dptccr & ~(dptc_data->dcr_mask)) | dptc_data->init_config;
+	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
 
-	res = sysfs_create_file(&dptc_dev->kobj, &dev_attr_enable.attr);
-	if (res) {
+	ret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_enable.attr);
+	if (ret) {
 		printk(KERN_ERR
 		       "DPTC: Unable to register sysdev entry for dptc");
-		return res;
+		goto err1;
 	}
 
-	if (res != 0) {
+	if (ret != 0) {
 		printk(KERN_ERR "DPTC: Unable to start");
-		return res;
+		goto err1;
 	}
 
-	curr_wp = 0;
-	update_dptc_wp(curr_wp);
+	dptc_device_data->dptc_clk = clk_get(NULL, dptc_data->clk_id);
 
-	cpu_clk = clk_get(NULL, "cpu_clk");
+	if (pdev->id == 0)
+		dev_data = &pdev->dev;
 
-	pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+	dptc_device_data->dptc_platform_data = pdev->dev.platform_data;
+
+	/* Set driver data */
+	platform_set_drvdata(pdev, dptc_device_data);
+	update_dptc_wp(dptc_device_data, dptc_device_data->curr_wp);
 
 	return 0;
+
+err1:
+	dev_err(&pdev->dev, "Failed to probe DPTC\n");
+	kfree(dptc_device_data);
+	return ret;
 }
 
 /*!
@@ -360,8 +459,10 @@ static int __devinit mxc_dptc_probe(struct platform_device *pdev)
  */
 static int mxc_dptc_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	if (dptc_is_active)
-		stop_dptc();
+	struct dptc_device *drv_data = pdev->dev.driver_data;
+
+	if (drv_data->dptc_is_active)
+		stop_dptc(&pdev->dev);
 
 	return 0;
 }
@@ -377,15 +478,18 @@ static int mxc_dptc_suspend(struct platform_device *pdev, pm_message_t state)
  */
 static int mxc_dptc_resume(struct platform_device *pdev)
 {
-	if (dptc_is_active)
-		start_dptc();
+	struct dptc_device *drv_data = pdev->dev.driver_data;
+
+	if (drv_data->dptc_is_active)
+		start_dptc(&pdev->dev);
 
 	return 0;
 }
 
-static struct platform_driver mxc_dptc_v2_driver = {
+static struct platform_driver mxc_dptc_driver = {
 	.driver = {
 		   .name = "mxc_dptc",
+		   .owner = THIS_MODULE,
 		   },
 	.probe = mxc_dptc_probe,
 	.suspend = mxc_dptc_suspend,
@@ -405,28 +509,20 @@ static struct platform_driver mxc_dptc_v2_driver = {
 
 static int __init dptc_init(void)
 {
-	if (cpu_is_mx31()) {
-		if (platform_driver_register(&mxc_dptc_v2_driver) != 0) {
-			printk(KERN_ERR "mxc_dptc_v2_driver register failed\n");
-			return -ENODEV;
-		}
-
-		printk(KERN_INFO "DPTC driver module loaded\n");
+	if (platform_driver_register(&mxc_dptc_driver) != 0) {
+		printk(KERN_ERR "mxc_dptc_driver register failed\n");
+		return -ENODEV;
 	}
+
+	printk(KERN_INFO "DPTC driver module loaded\n");
+
 	return 0;
 }
 
 static void __exit dptc_cleanup(void)
 {
-	stop_dptc();
-
-	/* release the DPTC interrupt */
-	free_irq(MXC_INT_CCM, NULL);
-
-	sysfs_remove_file(&dptc_dev->kobj, &dev_attr_enable.attr);
-
 	/* Unregister the device structure */
-	platform_driver_unregister(&mxc_dptc_v2_driver);
+	platform_driver_unregister(&mxc_dptc_driver);
 
 	printk("DPTC driver module unloaded\n");
 }
diff --git a/arch/arm/plat-mxc/dptc_gp.c b/arch/arm/plat-mxc/dptc_gp.c
deleted file mode 100644
index 7768535..0000000
--- a/arch/arm/plat-mxc/dptc_gp.c
+++ /dev/null
@@ -1,456 +0,0 @@
-/*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-/*!
- * @file dptc_gp.c
- *
- * @brief Driver for the Freescale Semiconductor MXC DPTC GP module.
- *
- * The DPTC GP driver is designed to control the MXC DPTC ARM hardware.
- * Upon initialization, the DPTC GP driver initializes the DPTC ARM hardware
- * sets up driver nodes attaches to the DPTC ARM interrupt and initializes internal
- * data structures. When the DPTC ARM interrupt occurs the driver checks the cause
- * of the interrupt (lower frequency, increase frequency or emergency) and changes
- * the CPU voltage according to translation table that is loaded into the driver.
- * The driver read method is used to read the log buffer.
- * Driver ioctls are used to change driver parameters and enable/disable the
- * DVFS operation.
- *
- * @ingroup PM
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/fs.h>
-#include <linux/interrupt.h>
-#include <linux/jiffies.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/clk.h>
-#include <linux/workqueue.h>
-#include <linux/platform_device.h>
-
-#include <asm/arch/clock.h>
-#include <asm/arch/gpio.h>
-#include <linux/i2c.h>
-#include <linux/regulator/regulator.h>
-#include <asm/arch/hardware.h>
-
-#include "../mach-mx37/crm_regs.h"
-
-#define MXC_DPTCCR		(MXC_DPTC_GP_BASE + 0x00)
-#define MXC_DPTCDBG		(MXC_DPTC_GP_BASE + 0x04)
-#define MXC_DCVR0		(MXC_DPTC_GP_BASE + 0x08)
-#define MXC_DCVR1		(MXC_DPTC_GP_BASE + 0x0C)
-#define MXC_DCVR2		(MXC_DPTC_GP_BASE + 0x10)
-#define MXC_DCVR3		(MXC_DPTC_GP_BASE + 0x14)
-
-#define MXC_DPTCCR_DRCE3                     0x00400000
-#define MXC_DPTCCR_DRCE2                     0x00200000
-#define MXC_DPTCCR_DRCE1                     0x00100000
-#define MXC_DPTCCR_DRCE0                     0x00080000
-#define MXC_DPTCCR_DCR_256                   0x00060000
-#define MXC_DPTCCR_DCR_128                   0x00040000
-#define MXC_DPTCCR_DCR_64                    0x00020000
-#define MXC_DPTCCR_DCR_32                    0x00000000
-#define MXC_DPTCCR_DSMM                      0x00000040
-#define MXC_DPTCCR_DPNVCR                    0x00000020
-#define MXC_DPTCCR_DPVV                      0x00000010
-#define MXC_DPTCCR_VAIM                      0x00000008
-#define MXC_DPTCCR_VAI_OFFSET                1
-#define MXC_DPTCCR_VAI_MASK                  0x00000006
-#define MXC_DPTCCR_DEN                       0x00000001
-
-#define MXC_GPCCNTR_GPCIRQ                   0x00100000
-#define MXC_GPCCNTR_DPTC0CR                  0x00040000
-#define MXC_GPCCNTR_ADU                      0x00008000
-
-static int dptc_is_active;
-
-static int curr_wp;
-static u32 ptvai;
-static struct delayed_work dptc_work;
-static struct dptc_wp *dptc_gp_wp_allfreq;
-static struct device *dptc_dev;
-static struct clk *cpu_clk;
-struct regulator *gp_core;
-
-DEFINE_SPINLOCK(mxc_dptc_lock);
-
-enum {
-	DPTC_PTVAI_NOCHANGE = 0x0,
-	DPTC_PTVAI_DECREASE,
-	DPTC_PTVAI_INCREASE,
-	DPTC_PTVAI_EMERG,
-};
-
-static void update_dptc_wp(u32 wp)
-{
-	int voltage_uV;
-	int ret = 0;
-
-	voltage_uV = (dptc_gp_wp_allfreq[wp].voltage) * 1000;
-
-	__raw_writel(dptc_gp_wp_allfreq[wp].dcvr0, MXC_DCVR0);
-	__raw_writel(dptc_gp_wp_allfreq[wp].dcvr1, MXC_DCVR1);
-	__raw_writel(dptc_gp_wp_allfreq[wp].dcvr2, MXC_DCVR2);
-	__raw_writel(dptc_gp_wp_allfreq[wp].dcvr3, MXC_DCVR3);
-
-	/* Set the voltage for the GP domain. */
-	if (gp_core != NULL) {
-		ret = regulator_set_voltage(gp_core, voltage_uV);
-		if (ret < 0)
-			printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!!!\n");
-	}
-
-	pr_debug("dcvr0-3: 0x%x, 0x%x, 0x%x, 0x%x; vol: %d\n",
-		 dptc_gp_wp_allfreq[wp].dcvr0,
-		 dptc_gp_wp_allfreq[wp].dcvr1,
-		 dptc_gp_wp_allfreq[wp].dcvr2,
-		 dptc_gp_wp_allfreq[wp].dcvr3, dptc_gp_wp_allfreq[wp].voltage);
-}
-
-static irqreturn_t dptc_irq(int irq, void *dev_id)
-{
-	u32 dptccr = __raw_readl(MXC_DPTCCR);
-	u32 gpc_cntr = __raw_readl(MXC_GPC_CNTR);
-
-	gpc_cntr = (gpc_cntr & MXC_GPCCNTR_DPTC0CR);
-
-	if (gpc_cntr) {
-		ptvai = (dptccr & MXC_DPTCCR_VAI_MASK) >> MXC_DPTCCR_VAI_OFFSET;
-
-		/* disable DPTC and mask its interrupt */
-		dptccr = (dptccr & ~(MXC_DPTCCR_DEN)) | MXC_DPTCCR_VAIM;
-		dptccr = (dptccr & ~(MXC_DPTCCR_DPNVCR));
-		__raw_writel(dptccr, MXC_DPTCCR);
-
-		schedule_delayed_work(&dptc_work, 0);
-	}
-
-	return IRQ_RETVAL(1);
-}
-
-static void dptc_workqueue_handler(struct work_struct *work)
-{
-	u32 dptccr = __raw_readl(MXC_DPTCCR);
-
-	switch (ptvai) {
-	case DPTC_PTVAI_DECREASE:
-		curr_wp++;
-		break;
-	case DPTC_PTVAI_INCREASE:
-	case DPTC_PTVAI_EMERG:
-		curr_wp--;
-		if (curr_wp < 0) {
-			/* already max voltage */
-			curr_wp = 0;
-			printk(KERN_WARNING "dptc: already maximum voltage\n");
-		}
-		break;
-
-		/* Unknown interrupt cause */
-	default:
-		BUG();
-	}
-
-	if (curr_wp > DPTC_GP_WP_SUPPORTED || curr_wp < 0) {
-		panic("Can't support this working point: %d\n", curr_wp);
-	}
-	update_dptc_wp(curr_wp);
-
-	/* enable DPTC and unmask its interrupt */
-	dptccr =
-	    (dptccr & ~(MXC_DPTCCR_VAIM)) | MXC_DPTCCR_DPNVCR | MXC_DPTCCR_DEN;
-	__raw_writel(dptccr, MXC_DPTCCR);
-}
-
-/* Start DPTC unconditionally */
-static int start_dptc(void)
-{
-	u32 dptccr, flags;
-	unsigned long cpu_rate;
-
-	/* Set the voltage for the GP domain. */
-	gp_core = regulator_get(NULL, "DCDC1");
-
-	spin_lock_irqsave(&mxc_dptc_lock, flags);
-
-	cpu_rate = clk_get_rate(cpu_clk);
-
-	if (cpu_rate < 532000000) {
-		goto err;
-	}
-
-	/* Enable ARM domain frequency and/or voltage update needed and enable ARM IRQ */
-	__raw_writel(MXC_GPCCNTR_GPCIRQ | MXC_GPCCNTR_ADU, MXC_GPC_CNTR);
-
-	dptccr = __raw_readl(MXC_DPTCCR);
-
-	/* Enable DPTC and unmask its interrupt */
-	dptccr = ((dptccr & ~(MXC_DPTCCR_VAIM)) | MXC_DPTCCR_DEN) |
-	    (MXC_DPTCCR_DPNVCR | MXC_DPTCCR_DPVV | MXC_DPTCCR_DSMM);
-
-	__raw_writel(dptccr, MXC_DPTCCR);
-
-	spin_unlock_irqrestore(&mxc_dptc_lock, flags);
-
-	pr_info("DPTC has been started \n");
-
-	return 0;
-
-      err:
-	spin_unlock_irqrestore(&mxc_dptc_lock, flags);
-	pr_info("DPTC GP is not enabled\n");
-	return -1;
-}
-
-/* Stop DPTC unconditionally */
-static void stop_dptc(void)
-{
-	u32 dptccr;
-
-	dptccr = __raw_readl(MXC_DPTCCR);
-
-	/* disable DPTC and mask its interrupt */
-	dptccr = ((dptccr & ~(MXC_DPTCCR_DEN)) | MXC_DPTCCR_VAIM) &
-	    (~MXC_DPTCCR_DPNVCR);
-
-	__raw_writel(dptccr, MXC_DPTCCR);
-
-	/* Restore Turbo Mode voltage to highest wp */
-	update_dptc_wp(0);
-	curr_wp = 0;
-
-	regulator_put(gp_core, NULL);
-
-	pr_info("DPTC GP has been stopped\n");
-}
-
-/*
-  this function does not change the working point. It can be
- called from an interrupt context.
-*/
-void dptc_suspend(void)
-{
-	u32 dptccr;
-
-	if (!dptc_is_active)
-		return;
-
-	dptccr = __raw_readl(MXC_DPTCCR);
-
-	/* disable DPTC and mask its interrupt */
-	dptccr = ((dptccr & ~(MXC_DPTCCR_DEN)) | MXC_DPTCCR_VAIM) &
-	    (~MXC_DPTCCR_DPNVCR);
-
-	__raw_writel(dptccr, MXC_DPTCCR);
-}
-
-/*!
- * This function is called to put the DPTC in a low power state.
- *
- */
-void dptc_disable(void)
-{
-	if (!dptc_is_active)
-		return;
-
-	stop_dptc();
-	dptc_is_active = 0;
-}
-
-/*!
- * This function is called to resume the DPTC from a low power state.
- *
- */
-void dptc_enable(void)
-{
-	if (dptc_is_active)
-		return;
-	start_dptc();
-	dptc_is_active = 1;
-}
-
-static ssize_t dptc_show(struct device *dev, struct device_attribute *attr,
-			 char *buf)
-{
-	if (dptc_is_active)
-		return sprintf(buf, "DPTC is enabled\n");
-	else
-		return sprintf(buf, "DPTC is disabled\n");
-}
-
-static ssize_t dptc_store(struct device *dev, struct device_attribute *attr,
-			  const char *buf, size_t size)
-{
-	if (strstr(buf, "0") != NULL) {
-		dptc_disable();
-	} else if (strstr(buf, "1") != NULL) {
-		dptc_enable();
-	}
-
-	return size;
-}
-
-static DEVICE_ATTR(enable, 0644, dptc_show, dptc_store);
-
-/*!
- * This is the probe routine for the DPTC driver.
- *
- * @param   pdev   The platform device structure
- *
- * @return         The function returns 0 on success
- *
- */
-static int __devinit mxc_dptc_gp_probe(struct platform_device *pdev)
-{
-	int res = 0;
-	u32 dptccr;
-
-	printk(KERN_INFO "DPTC mxc_dptc_gp_probe()\n");
-	dptc_dev = &pdev->dev;
-	dptc_gp_wp_allfreq = pdev->dev.platform_data;
-	if (dptc_gp_wp_allfreq == NULL) {
-		printk(KERN_ERR "DPTC: Pointer to DPTC table is NULL\
-				not started\n");
-		return -1;
-	}
-
-	INIT_DELAYED_WORK(&dptc_work, dptc_workqueue_handler);
-
-	/* request the DPTC interrupt */
-	res =
-	    request_irq(MXC_INT_GPC1, dptc_irq, IRQF_SHARED, "mxc-dptc-gp",
-			pdev);
-	if (res) {
-		printk(KERN_ERR "DPTC: Unable to attach to DPTC interrupt 1\n");
-		return res;
-	}
-	/* Enable Reference Circuits */
-	dptccr =
-	    (MXC_DPTCCR_DRCE0 | MXC_DPTCCR_DRCE1 | MXC_DPTCCR_DRCE2 |
-	     MXC_DPTCCR_DRCE3) | (MXC_DPTCCR_DCR_128 | MXC_DPTCCR_DPNVCR |
-				  MXC_DPTCCR_DPVV);
-	__raw_writel(dptccr, MXC_DPTCCR);
-
-	res = sysfs_create_file(&dptc_dev->kobj, &dev_attr_enable.attr);
-	if (res) {
-		printk(KERN_ERR
-		       "DPTC: Unable to register sysdev entry for dptc");
-		return res;
-	}
-
-	if (res != 0) {
-		printk(KERN_ERR "DPTC: Unable to start");
-		return res;
-	}
-
-	curr_wp = 0;
-	update_dptc_wp(curr_wp);
-
-	cpu_clk = clk_get(NULL, "cpu_clk");
-
-	return 0;
-}
-
-/*!
- * This function is called to put DPTC in a low power state.
- *
- * @param   pdev  the device structure
- * @param   state the power state the device is entering
- *
- * @return  The function always returns 0.
- */
-static int mxc_dptc_gp_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	if (dptc_is_active)
-		stop_dptc();
-
-	return 0;
-}
-
-/*!
- * This function is called to resume the MU from a low power state.
- *
- * @param   dev   the device structure
- * @param   level the stage in device suspension process that we want the
- *                device to be put in
- *
- * @return  The function always returns 0.
- */
-static int mxc_dptc_gp_resume(struct platform_device *pdev)
-{
-	if (dptc_is_active)
-		start_dptc();
-
-	return 0;
-}
-
-static struct platform_driver mxc_dptc_gp_driver = {
-	.driver = {
-		   .name = "mxc_dptc_gp",
-		   },
-	.probe = mxc_dptc_gp_probe,
-	.suspend = mxc_dptc_gp_suspend,
-	.resume = mxc_dptc_gp_resume,
-};
-
-/*!
- * This function is called to resume the MU from a low power state.
- *
- * @param   dev   the device structure used to give information on which MU
- *                device (0 through 3 channels) to suspend
- * @param   level the stage in device suspension process that we want the
- *                device to be put in
- *
- * @return  The function always returns 0.
- */
-
-static int __init dptc_init(void)
-{
-	printk(KERN_INFO "DPTC dptc_init()\n");
-	if (platform_driver_register(&mxc_dptc_gp_driver) != 0) {
-		printk(KERN_ERR "mxc_dptc_gp_driver register failed\n");
-		return -ENODEV;
-	}
-
-	printk(KERN_INFO "DPTC driver module loaded\n");
-	return 0;
-}
-
-static void __exit dptc_cleanup(void)
-{
-	stop_dptc();
-
-	/* release the DPTC interrupt 1 */
-	free_irq(MXC_INT_GPC1, NULL);
-
-	sysfs_remove_file(&dptc_dev->kobj, &dev_attr_enable.attr);
-
-	/* Unregister the device structure */
-	platform_driver_unregister(&mxc_dptc_gp_driver);
-
-	printk("DPTC driver module unloaded\n");
-}
-
-module_init(dptc_init);
-module_exit(dptc_cleanup);
-
-EXPORT_SYMBOL(dptc_disable);
-EXPORT_SYMBOL(dptc_enable);
-
-MODULE_AUTHOR("Freescale Semiconductor, Inc.");
-MODULE_DESCRIPTION("DPTC driver");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/dptc_lp.c b/arch/arm/plat-mxc/dptc_lp.c
deleted file mode 100644
index 589d1eb..0000000
--- a/arch/arm/plat-mxc/dptc_lp.c
+++ /dev/null
@@ -1,456 +0,0 @@
-/*
- * Copyright 2005-2008 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-/*!
- * @file dptc_lp.c
- *
- * @brief Driver for the Freescale Semiconductor MXC DPTC LP module.
- *
- * The DPTC LP driver is designed to control the MXC DPTC hardware.
- * Upon initialization, the DPTC LP driver initializes the DPTC Peripheral hardware
- * sets up driver nodes attaches to the DPTC interrupt and initializes internal
- * data structures. When the DPTC PER interrupt occurs the driver checks the cause
- * of the interrupt (lower frequency, increase frequency or emergency) and changes
- * the CPU voltage according to translation table that is loaded into the driver.
- * The driver read method is used to read the log buffer.
- * Driver ioctls are used to change driver parameters and enable/disable the
- * DVFS operation.
- *
- * @ingroup PM
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/fs.h>
-#include <linux/interrupt.h>
-#include <linux/jiffies.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/clk.h>
-#include <linux/workqueue.h>
-#include <linux/platform_device.h>
-
-#include <asm/arch/clock.h>
-#include <asm/arch/gpio.h>
-#include <linux/i2c.h>
-#include <linux/regulator/regulator.h>
-#include <asm/arch/hardware.h>
-
-#include "../mach-mx37/crm_regs.h"
-
-#define MXC_DPTCCR		(MXC_DPTC_LP_BASE + 0x00)
-#define MXC_DPTCDBG		(MXC_DPTC_LP_BASE + 0x04)
-#define MXC_DCVR0		(MXC_DPTC_LP_BASE + 0x08)
-#define MXC_DCVR1		(MXC_DPTC_LP_BASE + 0x0C)
-#define MXC_DCVR2		(MXC_DPTC_LP_BASE + 0x10)
-#define MXC_DCVR3		(MXC_DPTC_LP_BASE + 0x14)
-
-#define MXC_DPTCCR_DRCE3                     0x00400000
-#define MXC_DPTCCR_DRCE2                     0x00200000
-#define MXC_DPTCCR_DRCE1                     0x00100000
-#define MXC_DPTCCR_DRCE0                     0x00080000
-#define MXC_DPTCCR_DCR_256                   0x00060000
-#define MXC_DPTCCR_DCR_128                   0x00040000
-#define MXC_DPTCCR_DCR_64                    0x00020000
-#define MXC_DPTCCR_DCR_32                    0x00000000
-#define MXC_DPTCCR_DSMM                      0x00000040
-#define MXC_DPTCCR_DPNVCR                    0x00000020
-#define MXC_DPTCCR_DPVV                      0x00000010
-#define MXC_DPTCCR_VAIM                      0x00000008
-#define MXC_DPTCCR_VAI_OFFSET                1
-#define MXC_DPTCCR_VAI_MASK                  0x00000006
-#define MXC_DPTCCR_DEN                       0x00000001
-
-#define MXC_GPCCNTR_GPCIRQ                   0x00100000
-#define MXC_GPCCNTR_DPTC1CR                  0x00080000
-#define MXC_GPCCNTR_ADU                      0x00008000
-
-static int dptc_lp_is_active;
-
-static int curr_wp;
-static u32 ptvai;
-static struct delayed_work dptc_lp_work;
-static struct dptc_wp *dptc_lp_wp_allfreq;
-static struct device *dptc_lp_dev;
-static struct clk *ahb_clk;
-struct regulator *lp_per;
-
-DEFINE_SPINLOCK(mxc_dptc_lp_lock);
-
-enum {
-	DPTC_PTVAI_NOCHANGE = 0x0,
-	DPTC_PTVAI_DECREASE,
-	DPTC_PTVAI_INCREASE,
-	DPTC_PTVAI_EMERG,
-};
-
-static void update_dptc_wp(u32 wp)
-{
-	int voltage_uV;
-	int ret = 0;
-
-	voltage_uV = (dptc_lp_wp_allfreq[wp].voltage) * 1000;
-
-	__raw_writel(dptc_lp_wp_allfreq[wp].dcvr0, MXC_DCVR0);
-	__raw_writel(dptc_lp_wp_allfreq[wp].dcvr1, MXC_DCVR1);
-	__raw_writel(dptc_lp_wp_allfreq[wp].dcvr2, MXC_DCVR2);
-	__raw_writel(dptc_lp_wp_allfreq[wp].dcvr3, MXC_DCVR3);
-
-	/* Set the voltage for the LP domain. */
-	if (lp_per != NULL) {
-		ret = regulator_set_voltage(lp_per, voltage_uV);
-		if (ret < 0)
-			printk(KERN_DEBUG "COULD NOT SET LP VOLTAGE!!!!!\n");
-	}
-
-	pr_debug("dcvr0-3: 0x%x, 0x%x, 0x%x, 0x%x; vol: %d\n",
-		 dptc_lp_wp_allfreq[wp].dcvr0,
-		 dptc_lp_wp_allfreq[wp].dcvr1,
-		 dptc_lp_wp_allfreq[wp].dcvr2,
-		 dptc_lp_wp_allfreq[wp].dcvr3, dptc_lp_wp_allfreq[wp].voltage);
-}
-
-static irqreturn_t dptc_lp_irq(int irq, void *dev_id)
-{
-	u32 dptccr = __raw_readl(MXC_DPTCCR);
-	u32 gpc_cntr = __raw_readl(MXC_GPC_CNTR);
-
-	gpc_cntr = (gpc_cntr & MXC_GPCCNTR_DPTC1CR);
-
-	if (gpc_cntr) {
-		ptvai = (dptccr & MXC_DPTCCR_VAI_MASK) >> MXC_DPTCCR_VAI_OFFSET;
-
-		/* disable DPTC and mask its interrupt */
-		dptccr = (dptccr & ~(MXC_DPTCCR_DEN)) | MXC_DPTCCR_VAIM;
-		dptccr = (dptccr & ~(MXC_DPTCCR_DPNVCR));
-		__raw_writel(dptccr, MXC_DPTCCR);
-
-		schedule_delayed_work(&dptc_lp_work, 0);
-	}
-
-	return IRQ_RETVAL(1);
-}
-
-static void dptc_lp_workqueue_handler(struct work_struct *work)
-{
-	u32 dptccr = __raw_readl(MXC_DPTCCR);
-
-	switch (ptvai) {
-	case DPTC_PTVAI_DECREASE:
-		curr_wp++;
-		break;
-	case DPTC_PTVAI_INCREASE:
-	case DPTC_PTVAI_EMERG:
-		curr_wp--;
-		if (curr_wp < 0) {
-			/* already max voltage */
-			curr_wp = 0;
-			printk(KERN_WARNING "dptc: already maximum voltage\n");
-		}
-		break;
-
-		/* Unknown interrupt cause */
-	default:
-		BUG();
-	}
-
-	if (curr_wp > DPTC_LP_WP_SUPPORTED || curr_wp < 0) {
-		panic("Can't support this working point: %d\n", curr_wp);
-	}
-	update_dptc_wp(curr_wp);
-
-	/* enable DPTC and unmask its interrupt */
-	dptccr =
-	    (dptccr & ~(MXC_DPTCCR_VAIM)) | MXC_DPTCCR_DPNVCR | MXC_DPTCCR_DEN;
-	__raw_writel(dptccr, MXC_DPTCCR);
-}
-
-/* Start DPTC unconditionally */
-static int start_dptc(void)
-{
-	u32 dptccr, flags;
-	unsigned long ahb_rate;
-
-	/* Set the voltage for the LP domain. */
-	lp_per = regulator_get(NULL, "DCDC4");
-
-	spin_lock_irqsave(&mxc_dptc_lp_lock, flags);
-
-	ahb_rate = clk_get_rate(ahb_clk);
-
-	if (ahb_rate < 133000000) {
-		goto err;
-	}
-
-	/* Enable PER domain frequency and/or voltage update needed and enable ARM IRQ */
-	__raw_writel(MXC_GPCCNTR_GPCIRQ, MXC_GPC_CNTR);
-
-	dptccr = __raw_readl(MXC_DPTCCR);
-
-	/* Enable DPTC and unmask its interrupt */
-	dptccr = ((dptccr & ~(MXC_DPTCCR_VAIM)) | MXC_DPTCCR_DEN) |
-	    (MXC_DPTCCR_DPNVCR | MXC_DPTCCR_DPVV | MXC_DPTCCR_DSMM);
-
-	__raw_writel(dptccr, MXC_DPTCCR);
-
-	spin_unlock_irqrestore(&mxc_dptc_lp_lock, flags);
-
-	pr_info("DPTC LP has been started \n");
-
-	return 0;
-
-      err:
-	spin_unlock_irqrestore(&mxc_dptc_lp_lock, flags);
-	pr_info("DPTC LP is not enabled\n");
-	return -1;
-}
-
-/* Stop DPTC unconditionally */
-static void stop_dptc(void)
-{
-	u32 dptccr;
-
-	dptccr = __raw_readl(MXC_DPTCCR);
-
-	/* disable DPTC and mask its interrupt */
-	dptccr = ((dptccr & ~(MXC_DPTCCR_DEN)) | MXC_DPTCCR_VAIM) &
-	    (~MXC_DPTCCR_DPNVCR);
-
-	__raw_writel(dptccr, MXC_DPTCCR);
-
-	/* Restore Turbo Mode voltage to highest wp */
-	update_dptc_wp(0);
-	curr_wp = 0;
-
-	regulator_put(lp_per, NULL);
-
-	pr_info("DPTC LP has been stopped\n");
-}
-
-/*
-  this function does not change the working point. It can be
- called from an interrupt context.
-*/
-void dptc_lp_suspend(void)
-{
-	u32 dptccr;
-
-	if (!dptc_lp_is_active)
-		return;
-
-	dptccr = __raw_readl(MXC_DPTCCR);
-
-	/* disable DPTC and mask its interrupt */
-	dptccr = ((dptccr & ~(MXC_DPTCCR_DEN)) | MXC_DPTCCR_VAIM) &
-	    (~MXC_DPTCCR_DPNVCR);
-
-	__raw_writel(dptccr, MXC_DPTCCR);
-}
-
-/*!
- * This function is called to put the DPTC in a low power state.
- *
- */
-void dptc_lp_disable(void)
-{
-	if (!dptc_lp_is_active)
-		return;
-
-	stop_dptc();
-	dptc_lp_is_active = 0;
-}
-
-/*!
- * This function is called to resume the DPTC from a low power state.
- *
- */
-void dptc_lp_enable(void)
-{
-	if (dptc_lp_is_active)
-		return;
-	start_dptc();
-	dptc_lp_is_active = 1;
-}
-
-static ssize_t dptc_lp_show(struct device *dev, struct device_attribute *attr,
-			    char *buf)
-{
-	if (dptc_lp_is_active)
-		return sprintf(buf, "DPTC LP is enabled\n");
-	else
-		return sprintf(buf, "DPTC LP is disabled\n");
-}
-
-static ssize_t dptc_lp_store(struct device *dev, struct device_attribute *attr,
-			     const char *buf, size_t size)
-{
-	if (strstr(buf, "0") != NULL) {
-		dptc_lp_disable();
-	} else if (strstr(buf, "1") != NULL) {
-		dptc_lp_enable();
-	}
-
-	return size;
-}
-
-static DEVICE_ATTR(enable, 0644, dptc_lp_show, dptc_lp_store);
-
-/*!
- * This is the probe routine for the DPTC driver.
- *
- * @param   pdev   The platform device structure
- *
- * @return         The function returns 0 on success
- *
- */
-static int __devinit mxc_dptc_lp_probe(struct platform_device *pdev)
-{
-	int res = 0;
-	u32 dptccr;
-
-	printk(KERN_INFO "DPTC mxc_dptc_lp_probe()\n");
-	dptc_lp_dev = &pdev->dev;
-	dptc_lp_wp_allfreq = pdev->dev.platform_data;
-	if (dptc_lp_wp_allfreq == NULL) {
-		printk(KERN_ERR "DPTC: Pointer to DPTC table is NULL\
-				not started\n");
-		return -1;
-	}
-
-	INIT_DELAYED_WORK(&dptc_lp_work, dptc_lp_workqueue_handler);
-
-	/* request the DPTC interrupt */
-	res =
-	    request_irq(MXC_INT_GPC1, dptc_lp_irq, IRQF_SHARED, "mxc-dptc-lp",
-			pdev);
-	if (res) {
-		printk(KERN_ERR "DPTC: Unable to attach to DPTC interrupt");
-		return res;
-	}
-	/* Enable Reference Circuits */
-	dptccr =
-	    (MXC_DPTCCR_DRCE0 | MXC_DPTCCR_DRCE1 | MXC_DPTCCR_DRCE2 |
-	     MXC_DPTCCR_DRCE3) | (MXC_DPTCCR_DCR_128 | MXC_DPTCCR_DPNVCR |
-				  MXC_DPTCCR_DPVV);
-	__raw_writel(dptccr, MXC_DPTCCR);
-
-	res = sysfs_create_file(&dptc_lp_dev->kobj, &dev_attr_enable.attr);
-	if (res) {
-		printk(KERN_ERR
-		       "DPTC: Unable to register sysdev entry for dptc");
-		return res;
-	}
-
-	if (res != 0) {
-		printk(KERN_ERR "DPTC: Unable to start");
-		return res;
-	}
-
-	curr_wp = 0;
-	update_dptc_wp(curr_wp);
-
-	ahb_clk = clk_get(NULL, "ahb_clk");
-
-	return 0;
-}
-
-/*!
- * This function is called to put DPTC in a low power state.
- *
- * @param   pdev  the device structure
- * @param   state the power state the device is entering
- *
- * @return  The function always returns 0.
- */
-static int mxc_dptc_lp_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	if (dptc_lp_is_active)
-		stop_dptc();
-
-	return 0;
-}
-
-/*!
- * This function is called to resume the MU from a low power state.
- *
- * @param   dev   the device structure
- * @param   level the stage in device suspension process that we want the
- *                device to be put in
- *
- * @return  The function always returns 0.
- */
-static int mxc_dptc_lp_resume(struct platform_device *pdev)
-{
-	if (dptc_lp_is_active)
-		start_dptc();
-
-	return 0;
-}
-
-static struct platform_driver mxc_dptc_lp_driver = {
-	.driver = {
-		   .name = "mxc_dptc_lp",
-		   },
-	.probe = mxc_dptc_lp_probe,
-	.suspend = mxc_dptc_lp_suspend,
-	.resume = mxc_dptc_lp_resume,
-};
-
-/*!
- * This function is called to resume the MU from a low power state.
- *
- * @param   dev   the device structure used to give information on which MU
- *                device (0 through 3 channels) to suspend
- * @param   level the stage in device suspension process that we want the
- *                device to be put in
- *
- * @return  The function always returns 0.
- */
-
-static int __init dptc_lp_init(void)
-{
-	printk(KERN_INFO "DPTC dptc_lp_init()\n");
-	if (platform_driver_register(&mxc_dptc_lp_driver) != 0) {
-		printk(KERN_ERR "mxc_dptc_lp_driver register failed\n");
-		return -ENODEV;
-	}
-
-	printk(KERN_INFO "DPTC LP driver module loaded\n");
-	return 0;
-}
-
-static void __exit dptc_lp_cleanup(void)
-{
-	stop_dptc();
-
-	/* release the DPTC interrupt */
-	free_irq(MXC_INT_GPC1, NULL);
-
-	sysfs_remove_file(&dptc_lp_dev->kobj, &dev_attr_enable.attr);
-
-	/* Unregister the device structure */
-	platform_driver_unregister(&mxc_dptc_lp_driver);
-
-	printk("DPTC LP driver module unloaded\n");
-}
-
-module_init(dptc_lp_init);
-module_exit(dptc_lp_cleanup);
-
-EXPORT_SYMBOL(dptc_lp_disable);
-EXPORT_SYMBOL(dptc_lp_enable);
-
-MODULE_AUTHOR("Freescale Semiconductor, Inc.");
-MODULE_DESCRIPTION("DPTC LP driver");
-MODULE_LICENSE("GPL");
diff --git a/include/asm-arm/arch-mxc/mxc.h b/include/asm-arm/arch-mxc/mxc.h
index a69da24..cff2ea3 100644
--- a/include/asm-arm/arch-mxc/mxc.h
+++ b/include/asm-arm/arch-mxc/mxc.h
@@ -299,10 +299,6 @@ struct mxc_unifi_platform_data *get_unifi_plat_data(void);
 #define MXC_IDE_DMA_WATERMARK	32	/* DMA watermark level in bytes */
 #define MXC_IDE_DMA_BD_NR	(512/3/4)	/* Number of BDs per channel */
 
-#define DPTC_WP_SUPPORTED	17
-#define DPTC_GP_WP_SUPPORTED	7
-#define DPTC_LP_WP_SUPPORTED	9
-
 #ifndef IS_MEM_DEVICE_NONSHARED
 /* all peripherals on MXC so far are below 0x80000000 but leave L2CC alone */
 #define IS_MEM_DEVICE_NONSHARED(x)  ((x) < 0x80000000 && (x) != L2CC_BASE_ADDR)
@@ -311,18 +307,6 @@ struct mxc_unifi_platform_data *get_unifi_plat_data(void);
 #ifndef __ASSEMBLY__
 #include <linux/types.h>
 
-struct dptc_wp {
-	u32 dcvr0;
-	u32 dcvr1;
-	u32 dcvr2;
-	u32 dcvr3;
-#if defined(CONFIG_ARCH_MX37)
-	char *regulator;
-#else
-	u32 regulator;
-#endif
-	u32 voltage;
-};
 struct cpu_wp {
 	u32 pll_reg;
 	u32 pll_rate;
@@ -336,18 +320,6 @@ struct cpu_wp {
 
 struct cpu_wp *get_cpu_wp(int *wp);
 
-/*!
- * This function is called to put the DPTC in a low power state.
- *
- */
-void dptc_disable(void);
-
-/*!
- * This function is called to resume the DPTC from a low power state.
- *
- */
-void dptc_enable(void);
-
 enum mxc_cpu_pwr_mode {
 	WAIT_CLOCKED,		/* wfi only */
 	WAIT_UNCLOCKED,		/* WAIT */
diff --git a/include/asm-arm/arch-mxc/mxc_dptc.h b/include/asm-arm/arch-mxc/mxc_dptc.h
new file mode 100644
index 0000000..51b0d43
--- /dev/null
+++ b/include/asm-arm/arch-mxc/mxc_dptc.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup DPTC Dynamic Process and Temperatur Compensation (DPTC) Driver
+ */
+
+/*!
+ * @file arch-mxc/mxc_dptc.h
+ *
+ * @brief This file contains the DPTC configuration structure definition.
+ *
+ *
+ * @ingroup DPTC
+ */
+
+#ifndef __ASM_ARCH_MXC_DPTC_H__
+#define __ASM_ARCH_MXC_DPTC_H__
+
+#ifdef __KERNEL__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+#include <linux/device.h>
+
+#define DPTC_WP_SUPPORTED	17
+#define DPTC_GP_WP_SUPPORTED	7
+#define DPTC_LP_WP_SUPPORTED	9
+
+struct dptc_wp {
+	u32 dcvr0;
+	u32 dcvr1;
+	u32 dcvr2;
+	u32 dcvr3;
+	u32 voltage;
+};
+
+/*!
+ * This structure is used to define the dptc controller's platform
+ * data. It includes the regulator name string and DPTC clock name string.
+ */
+struct mxc_dptc_data {
+	/** Regulator name string */
+	char *reg_id;
+	/* DPTC clock name string */
+	char *clk_id;
+	/* Control reg address */
+	unsigned int dptccr_reg_addr;
+	/* Comparator value reg 0 address */
+	unsigned int dcvr0_reg_addr;
+	/* GPC control reg address */
+	unsigned int gpc_cntr_reg_addr;
+	/* DPTC interrupt status bit */
+	unsigned int dptccr;
+	/* The number of DPTC working points */
+	unsigned int dptc_wp_supported;
+	/* Maximum value of DPTC clock rate */
+	unsigned long clk_max_val;
+	/* DPTC working points */
+	struct dptc_wp *dptc_wp_allfreq;
+	/* DPTC enable bit */
+	u32 dptc_enable_bit;
+	/* DPTC ADU bit */
+	int gpc_adu;
+	/* VAI mask */
+	u32 vai_mask;
+	/* VAI offset */
+	int vai_offset;
+	/* Mask DPTC interrupt */
+	u32 irq_mask;
+	/* DPTC no voltage change request bit */
+	u32 dptc_nvcr_bit;
+	/* ARM interrrupt bit */
+	u32 gpc_irq_bit;
+	/* dptc init config */
+	u32 init_config;
+	/* dptc enable config */
+	u32 enable_config;
+	/* dptc counting range mask */
+	u32 dcr_mask;
+};
+
+/*!
+ * This function is called to put the DPTC in a low power state.
+ *
+ */
+void dptc_disable(struct device *dev);
+
+/*!
+ * This function is called to resume the DPTC from a low power state.
+ *
+ */
+void dptc_enable(struct device *dev);
+
+extern void dptc_suspend(void);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_DPTC_H__ */
-- 
1.5.4.4

