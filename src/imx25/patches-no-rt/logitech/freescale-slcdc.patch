Index: linux-2.6.26/arch/arm/mach-mx25/board-mx25_baby.h
===================================================================
--- linux-2.6.26.orig/arch/arm/mach-mx25/board-mx25_baby.h	2009-08-17 12:02:32.000000000 +0100
+++ linux-2.6.26/arch/arm/mach-mx25/board-mx25_baby.h	2009-08-17 12:06:18.000000000 +0100
@@ -93,6 +93,9 @@
 #define BABY_LCD_SPI_CLK_PB2	MX25_PIN_CSPI1_SS1
 #define BABY_LCD_RESET          MX25_PIN_POWER_FAIL
 #define BABY_SLCDC_CS           MX25_PIN_CSPI1_SS0
+#define BABY_SLCDC_RS           MX25_PIN_CSPI1_SS1
+#define BABY_LCD_RCM1       MX25_PIN_CSPI1_MISO
+#define BABY_LCD_IM1        MX25_PIN_CSPI1_MOSI
 
 /* WLAN PINS */
 #define BABY_WLAN_POWER_DOWN_BAR	MX25_PIN_CSI_D9
Index: linux-2.6.26/arch/arm/mach-mx25/clock.c
===================================================================
--- linux-2.6.26.orig/arch/arm/mach-mx25/clock.c	2009-08-17 12:02:32.000000000 +0100
+++ linux-2.6.26/arch/arm/mach-mx25/clock.c	2009-08-17 20:57:41.000000000 +0100
@@ -1136,7 +1136,7 @@
 	 .parent = &ipg_clk,
 	 .enable = _clk_enable,
 	 .enable_reg = MXC_CCM_CGCR2,
-	 .enable_shift = MXC_CCM_CGCR2_PWM3_OFFSET,
+	 .enable_shift = MXC_CCM_CGCR2_PWM4_OFFSET,
 	 .disable = _clk_disable,},
 };
 
Index: linux-2.6.26/arch/arm/mach-mx25/mx25_baby_gpio.c
===================================================================
--- linux-2.6.26.orig/arch/arm/mach-mx25/mx25_baby_gpio.c	2009-08-17 12:02:57.000000000 +0100
+++ linux-2.6.26/arch/arm/mach-mx25/mx25_baby_gpio.c	2009-08-17 12:06:18.000000000 +0100
@@ -770,6 +770,141 @@
 }
 EXPORT_SYMBOL(gpio_lcdc_inactive);
 
+
+/*!
+ * Activate SLCDC
+ */
+void gpio_slcdc_active(void)
+{
+    //pr_info("+++++ gpio_slcdc_active called, system_rev %d\n", system_rev);
+
+	/* SLCDC RGB interface */
+	mxc_request_iomux(MX25_PIN_LD0, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD1, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD2, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD3, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD4, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD5, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD6, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD7, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD8, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD9, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD10, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD11, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD12, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD13, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD14, MUX_CONFIG_ALT1);
+	mxc_request_iomux(MX25_PIN_LD15, MUX_CONFIG_ALT1);
+
+	/* LCD Brightness controls */
+	mxc_request_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_ALT4); /* Brightness, use this pin as PWM4 */
+	mxc_request_iomux(MX25_PIN_D11, MUX_CONFIG_GPIO);      /* extra low brightness mode.  0 = bright, 1 = dim */
+
+	/* LCD Control interface */
+	mxc_request_iomux(BABY_LCD_RESET,  MUX_CONFIG_GPIO);
+	mxc_request_iomux(BABY_SLCDC_CS,  MUX_CONFIG_ALT6);
+	mxc_request_iomux(BABY_SLCDC_RS,  MUX_CONFIG_ALT6);
+    mxc_request_iomux(BABY_LCD_RCM1, MUX_CONFIG_GPIO);
+    mxc_request_iomux(BABY_LCD_IM1, MUX_CONFIG_GPIO);
+
+#define LCD_PAD_CTL (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | PAD_CTL_100K_PU)
+	mxc_iomux_set_pad(MX25_PIN_LD0, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD1, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD2, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD3, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD4, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD5, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD6, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD7, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD8, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD9, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD10, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD11, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD12, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD13, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD14, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD15, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_D11,  PAD_CTL_DRV_3_3V | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER);
+	mxc_set_gpio_dataout(MX25_PIN_D11, 0);    // Set pin D11 to high brightness
+	mxc_set_gpio_direction(MX25_PIN_D11, 0);  // Set pin D11 to output
+
+
+	mxc_iomux_set_pad(BABY_LCD_RESET,    PAD_CTL_DRV_3_3V );
+	mxc_iomux_set_pad(BABY_LCD_RCM1,     PAD_CTL_DRV_3_3V | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER);
+	mxc_iomux_set_pad(BABY_LCD_IM1,     PAD_CTL_DRV_3_3V | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER);
+	mxc_iomux_set_pad(BABY_SLCDC_CS,     LCD_PAD_CTL);
+	mxc_iomux_set_pad(BABY_SLCDC_RS,     LCD_PAD_CTL);
+
+	mxc_set_gpio_direction(BABY_LCD_RESET,  0); // output
+	mxc_set_gpio_direction(BABY_LCD_RCM1,  0); // output
+	mxc_set_gpio_direction(BABY_LCD_IM1,  0); // output
+
+	mxc_set_gpio_dataout(BABY_LCD_RESET, 0);
+	mxc_set_gpio_dataout(BABY_LCD_RCM1, 0); //Enable The Wintek in MCU (aka SLCDC) mode.
+	mxc_set_gpio_dataout(BABY_LCD_IM1, 1); //Enable The Wintek in 16-bit interface mode.
+}
+EXPORT_SYMBOL(gpio_slcdc_active);
+
+/*!
+ * Inactivate SLCDC
+ */
+void gpio_slcdc_inactive(void)
+{
+    //pr_info("+++++ gpio_slcdc_inactive called\n");
+
+	mxc_request_gpio(MX25_PIN_LD0);
+	mxc_request_gpio(MX25_PIN_LD1);
+	mxc_request_gpio(MX25_PIN_LD2);
+	mxc_request_gpio(MX25_PIN_LD3);
+	mxc_request_gpio(MX25_PIN_LD4);
+	mxc_request_gpio(MX25_PIN_LD5);
+	mxc_request_gpio(MX25_PIN_LD6);
+	mxc_request_gpio(MX25_PIN_LD7);
+
+	mxc_free_iomux(MX25_PIN_LD0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD4, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD5, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD6, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD7, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD8, MUX_CONFIG_ALT1);
+	mxc_free_iomux(MX25_PIN_LD9, MUX_CONFIG_ALT1);
+	mxc_free_iomux(MX25_PIN_LD10, MUX_CONFIG_ALT1);
+	mxc_free_iomux(MX25_PIN_LD11, MUX_CONFIG_ALT1);
+	mxc_free_iomux(MX25_PIN_LD12, MUX_CONFIG_ALT1);
+	mxc_free_iomux(MX25_PIN_LD13, MUX_CONFIG_ALT1);
+	mxc_free_iomux(MX25_PIN_LD14, MUX_CONFIG_ALT1);
+    mxc_free_iomux(MX25_PIN_LD15, MUX_CONFIG_ALT1);
+
+	mxc_free_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_ALT4);
+	mxc_free_iomux(MX25_PIN_D11, MUX_CONFIG_GPIO);
+	mxc_free_iomux(BABY_SLCDC_CS, MUX_CONFIG_ALT6);
+	mxc_free_iomux(BABY_SLCDC_RS, MUX_CONFIG_ALT6);
+    mxc_free_iomux(BABY_LCD_RCM1, MUX_CONFIG_GPIO);
+    mxc_free_iomux(BABY_LCD_IM1, MUX_CONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_slcdc_inactive);
+
+/*
+ * Call this function before sending startup command sequence to the
+ * LCD display. This function should must be used when using the SLCDC
+ * driver.
+ */
+void gpio_slcdc_reset(void)
+{
+    //pr_info ("^^^^ gpio_slcdc_reset\n");
+ 	mxc_set_gpio_dataout(BABY_LCD_RESET, 1);
+	msleep(10);
+	mxc_set_gpio_dataout(BABY_LCD_RESET, 0);
+	msleep(50);
+	mxc_set_gpio_dataout(BABY_LCD_RESET, 1);
+	msleep(50);
+}
+EXPORT_SYMBOL(gpio_slcdc_reset);
+
+
 /*
  * Power on/off CPT VGA panel.
  */
@@ -970,3 +1105,4 @@
 }
 
 EXPORT_SYMBOL(gpio_sdhc_inactive);
+
Index: linux-2.6.26/drivers/video/backlight/Makefile
===================================================================
--- linux-2.6.26.orig/drivers/video/backlight/Makefile	2009-08-17 12:02:22.000000000 +0100
+++ linux-2.6.26/drivers/video/backlight/Makefile	2009-08-17 12:06:37.000000000 +0100
@@ -11,7 +11,8 @@
 obj-$(CONFIG_BACKLIGHT_PROGEAR) += progear_bl.o
 obj-$(CONFIG_BACKLIGHT_CARILLO_RANCH) += cr_bllcd.o
 
-obj-$(CONFIG_BACKLIGHT_MXC_LCDC) += mxc_lcdc_bl.o
+#obj-$(CONFIG_BACKLIGHT_MXC_LCDC) += mxc_lcdc_bl.o
+obj-$(CONFIG_BACKLIGHT_MXC_LCDC) += baby_slcdc_bl.o
 obj-$(CONFIG_BACKLIGHT_MXC_IPU)	+= mxc_ipu_bl.o
 obj-$(CONFIG_BACKLIGHT_MXC_PMIC) += mxc_pmic_bl.o
 obj-$(CONFIG_BACKLIGHT_WM8350) += wm8350_bl.o
Index: linux-2.6.26/drivers/video/backlight/baby_slcdc_bl.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.26/drivers/video/backlight/baby_slcdc_bl.c	2009-08-17 21:42:13.000000000 +0100
@@ -0,0 +1,288 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*!
+ * @defgroup SLCDC_BL SLCDC Backlight Driver For Wintek LCD Used on Logitech BabyBoom.
+ */
+/*!
+ * @file baby_slcdc_bl.c
+ *
+ * @brief Backlight Driver for PWM4 on Freescale MXC/i.MX platforms.
+ *
+ * This file contains API defined in include/linux/clk.h for setting up and
+ * retrieving clocks.
+ *
+ * Based on Sharp's Corgi Backlight Driver
+ *
+ * @ingroup SLCDC_BL
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+#include <linux/clk.h>
+
+
+//Registers for PWM4
+#define PWMCR	0x00
+#define PWMSR	0x04
+#define PWMIR	0x08
+#define PWMSAR	0x0C
+#define PWMPR	0x10
+#define PWMCNR	0x14
+
+#define PWM4_REG(reg)	(IO_ADDRESS(PWM4_BASE_ADDR) + reg)
+
+#define PWMCR_SRC_IPG_CLK (1 << 16)
+#define PWMCR_PREESCALER_MASK (0xFFFF000F)
+#define PWMCR_MAX_PRESCALER (0xFFF)
+
+#define FIXED_PWM_PERIOD_COUNTER (80)
+
+
+#define pr_func pr_emerg
+//#define pr_func
+
+
+/*
+ * REMARK: I chose this frequency 28.3KHz because
+ * That's what the LCD Contrast pin was set at.
+ * I played with different frequencies and always
+ * got the same contrast  from the Wintek LCD
+ */
+#define DEFAULT_PWM_CONTRAST_FREQUENCY (28300) //Hz
+
+#define MXC_DEFAULT_INTENSITY 	127
+#define MXC_MAX_INTENSITY 	255
+#define MXC_INTENSITY_OFF 	0
+
+
+struct mxcbl_dev_data {
+	struct clk *clk;
+	int intensity;
+};
+
+
+/*
+ * This function is hardcoded to initialize PWM4 only.
+ * PWM4 is used as the contrast control for SLCDC mode
+ * REMARK: Regarding power consumption:
+ *         There's the potential of reducing power consumption
+ *         by changing the current clock structure found at
+ *         arch/arm/mach-mx25/clock.c
+ *         Currently all PWMs: 1,2,3 & 4 are connected together
+ *         And all those clocks get activated even when using only one
+ *         of the PWM modules. We can improve this by isolating
+ *         those clocks.
+ */
+static int _init_pwm(void)
+{
+    struct clk * pwm_ipg_clk;
+    uint32_t pre_escaler;
+    uint32_t pwmcr;
+
+    pr_func("^^^^ _init_pwm\n");
+
+    pwm_ipg_clk = clk_get(NULL, "pwm_ipg_clk");
+
+    if (NULL == pwm_ipg_clk){
+        return -1;
+    }
+
+    clk_enable(pwm_ipg_clk);
+    __raw_writel(0xF << 3, PWM4_REG(PWMSR)); //Clear status
+    __raw_writel(0, PWM4_REG(PWMIR)); //Disable all interrupts
+
+    //Write one sample register to the FIFO.
+    //Divide by 2, will force the signal to be 50/50 duty cycle
+    __raw_writel(FIXED_PWM_PERIOD_COUNTER / 2, PWM4_REG(PWMSAR));
+
+    __raw_writel(FIXED_PWM_PERIOD_COUNTER, PWM4_REG(PWMPR));
+
+    pre_escaler = clk_get_rate(pwm_ipg_clk) / DEFAULT_PWM_CONTRAST_FREQUENCY / (FIXED_PWM_PERIOD_COUNTER + 2);
+    pr_info("pwm_ipg_clk rate(Hz)=%lu pre_escaler = %u\n", clk_get_rate(pwm_ipg_clk), pre_escaler);
+
+    pwmcr = PWMCR_SRC_IPG_CLK |
+            (pre_escaler << 4) |
+            1; //Enable
+    __raw_writel(pwmcr, PWM4_REG(PWMCR));
+
+    return 0;
+}
+
+static void _set_pwm_frequency(uint32_t out_frequency_hz)
+{
+    struct clk * pwm_ipg_clk;
+    uint32_t pwmcr;
+    uint32_t pre_escaler;
+
+    pr_func("^^^^ _set_pwm_frequency\n");
+
+    pwm_ipg_clk = clk_get(NULL, "pwm_ipg_clk");
+
+    //Before changing the pre escaler we must stop the pwm.
+    pwmcr = __raw_readl(PWM4_REG(PWMCR));
+    pwmcr &= 0xFFFFFFFE;
+    __raw_writel(pwmcr, PWM4_REG(PWMCR));
+
+    pre_escaler = clk_get_rate(pwm_ipg_clk) / out_frequency_hz / (FIXED_PWM_PERIOD_COUNTER + 2);
+    pr_info("pwm_ipg_clk rate(Hz)=%lu, out_frequency_hz=%u, pre_escaler = %u\n",
+            clk_get_rate(pwm_ipg_clk), out_frequency_hz, pre_escaler);
+    if (pre_escaler > PWMCR_MAX_PRESCALER){
+        pre_escaler = PWMCR_MAX_PRESCALER;
+        pr_info("Forcing pre_escaler to %u\n", pre_escaler);
+    }
+    pwmcr &= PWMCR_PREESCALER_MASK;
+    pwmcr |= (pre_escaler << 4);
+    pwmcr |= 1; //Enable the PWM again.
+
+    __raw_writel(pwmcr, PWM4_REG(PWMCR));
+}
+
+static int mxcbl_send_intensity(struct backlight_device *bd)
+{
+	int intensity = bd->props.brightness;
+	struct mxcbl_dev_data *devdata = dev_get_drvdata(&bd->dev);
+
+    pr_func("^^^^ mxcbl_send_intensity\n");
+
+	if (bd->props.power != FB_BLANK_UNBLANK)
+		intensity = 0;
+	if (bd->props.fb_blank != FB_BLANK_UNBLANK)
+		intensity = 0;
+
+	if ((devdata->intensity == 0) && (intensity != 0))
+		clk_enable(devdata->clk);
+
+	// Intensity is normally a frequency in hertz.
+	// The intensity controls the brightness.
+	if (intensity > 0){
+    	_set_pwm_frequency(intensity * DEFAULT_PWM_CONTRAST_FREQUENCY / MXC_DEFAULT_INTENSITY);
+    }
+
+	if ((devdata->intensity != 0) && (intensity == 0))
+		clk_disable(devdata->clk);
+
+	devdata->intensity = intensity;
+	return 0;
+}
+
+static int mxcbl_get_intensity(struct backlight_device *bd)
+{
+	struct mxcbl_dev_data *devdata = dev_get_drvdata(&bd->dev);
+
+    pr_func("^^^^ mxcbl_get_intensity\n");
+
+	return devdata->intensity;
+}
+
+static int mxcbl_check_fb(struct fb_info *info)
+{
+    pr_func("^^^^ mxcbl_check_fb\n");
+	if (strcmp(info->fix.id, "DISP0 BG") == 0) {
+		return 1;
+	}
+	return 0;
+}
+
+static struct backlight_ops mxcbl_ops = {
+	.get_brightness = mxcbl_get_intensity,
+	.update_status = mxcbl_send_intensity,
+	.check_fb = mxcbl_check_fb,
+};
+
+static int __init mxcbl_probe(struct platform_device *pdev)
+{
+	struct backlight_device *bd;
+	struct mxcbl_dev_data *devdata;
+	int ret = 0;
+
+    pr_func("^^^^ mxcbl_probe\n");
+
+	devdata = kzalloc(sizeof(struct mxcbl_dev_data), GFP_KERNEL);
+	if (!devdata)
+		return -ENOMEM;
+
+	devdata->clk = clk_get(NULL, "pwm_clk");
+    ret =  _init_pwm();
+    if (ret != 0){
+        pr_emerg("Failed to initialize pwm\n");
+        goto err0;
+    }
+
+	bd = backlight_device_register(pdev->dev.bus_id, &pdev->dev, devdata,
+				       &mxcbl_ops);
+	if (IS_ERR(bd)) {
+		ret = PTR_ERR(bd);
+		goto err0;
+	}
+	platform_set_drvdata(pdev, bd);
+
+	bd->props.brightness = MXC_DEFAULT_INTENSITY;
+	bd->props.max_brightness = MXC_MAX_INTENSITY;
+	bd->props.power = FB_BLANK_UNBLANK;
+	bd->props.fb_blank = FB_BLANK_UNBLANK;
+
+	printk("MXC Backlight Device %s Initialized.\n", pdev->dev.bus_id);
+	return 0;
+      err0:
+	kfree(devdata);
+	return ret;
+}
+
+static int mxcbl_remove(struct platform_device *pdev)
+{
+	struct backlight_device *bd = platform_get_drvdata(pdev);
+
+    pr_func("^^^^ mxcbl_remove\n");
+
+	bd->props.brightness = MXC_INTENSITY_OFF;
+	backlight_update_status(bd);
+
+	backlight_device_unregister(bd);
+
+	return 0;
+}
+
+static struct platform_driver mxcbl_driver = {
+	.probe = mxcbl_probe,
+	.remove = mxcbl_remove,
+	.driver = {
+		   .name = "mxc_lcdc_bl",
+		   },
+};
+
+static int __init mxcbl_init(void)
+{
+    pr_func("^^^^ mxcbl_init\n");
+
+	return platform_driver_register(&mxcbl_driver);
+}
+
+static void __exit mxcbl_exit(void)
+{
+    pr_func("^^^^ mxcbl_exit\n");
+	platform_driver_unregister(&mxcbl_driver);
+}
+
+module_init(mxcbl_init);
+module_exit(mxcbl_exit);
+
+MODULE_DESCRIPTION("Freescale MXC/i.MX SLCDC PWM4 Backlight Driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
+
+
Index: linux-2.6.26/drivers/video/mxc/Makefile
===================================================================
--- linux-2.6.26.orig/drivers/video/mxc/Makefile	2009-08-17 12:02:22.000000000 +0100
+++ linux-2.6.26/drivers/video/mxc/Makefile	2009-08-17 12:06:37.000000000 +0100
@@ -1,6 +1,7 @@
 ifeq ($(CONFIG_ARCH_MX21)$(CONFIG_ARCH_MX27)$(CONFIG_ARCH_MX25),y)
 	obj-$(CONFIG_FB_MXC_TVOUT)              += fs453.o
-	obj-$(CONFIG_FB_MXC_SYNC_PANEL)         += mx2fb.o mxcfb_modedb.o
+	#obj-$(CONFIG_FB_MXC_SYNC_PANEL)         += mx2fb.o mxcfb_modedb.o
+	obj-$(CONFIG_FB_MXC_SYNC_PANEL)         += mx2fb_baby.o mxcfb_modedb.o
 	obj-$(CONFIG_FB_MXC_EPSON_PANEL)        += mx2fb_epson.o
 else
 ifeq ($(CONFIG_MXC_IPU_V1),y)
Index: linux-2.6.26/drivers/video/mxc/mx2fb_baby.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.26/drivers/video/mxc/mx2fb_baby.c	2009-08-18 12:30:21.000000000 +0100
@@ -0,0 +1,1061 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer_MX25 SLCDC Framebuffer Driver for MX25.
+ */
+
+/*!
+ * @file mx2fb_baby.c
+ *
+ * @brief Frame buffer SLCDC driver for MX25 Logitech BabyBoom.
+ *
+ * @ingroup Framebuffer_MX25
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <linux/mxcfb.h>
+
+#define pr_func pr_emerg
+//#define pr_func 0
+
+#define MX2FB_TYPE_BG          0
+
+//This will be the clock rate of the SLCDC_CS signal.
+//Every rising edge of SLCDC_CS signal will send a 16-it pixel
+//to the LCD.
+//The final real frequency will be around 4.65MHz.
+//Frames Per second will be ~60.84
+#define TARGET_SLCDC_CLOCK_RATE (5000000) //5MHz
+
+/*
+ * SLCDC register definitions
+ */
+#define SLCDC_DATABASEADR		    0x00
+#define SLCDC_DATABUFSIZE		    0x04
+#define SLCDC_COMBASEADR		    0x08
+#define SLCDC_COMBUFSIZ	            0x0C
+#define SLCDC_COMSTRINGSIZ	        0x10
+#define SLCDC_FIFOCONFIG		    0x14
+#define SLCDC_LCDCONFIG		        0x18
+#define SLCDC_LCDTRANSCONFIG		0x1C
+#define SLCDC_SLCDCCONTROLSTATUS	0x20
+#define SLCDC_LCDCLOCKCONFIG		0x24
+#define SLCDC_LCDWRITEDATA	    	0x28
+
+#define SLCDC_REG(reg)		(IO_ADDRESS(SLCDC_BASE_ADDR) + reg)
+
+extern void gpio_slcdc_active(void);
+extern void gpio_slcdc_inactive(void);
+extern void board_power_lcd(int on);
+
+static char *fb_mode = 0;
+static int fb_enabled = 0;
+static unsigned long default_bpp = 16;
+static struct clk *slcdc_clk;
+
+/*!
+ * @brief Structure containing the MX2 specific framebuffer information.
+ */
+struct mx2fb_info {
+	int type;
+	char *id;
+	int registered;
+	int blank;
+	unsigned long pseudo_palette[16];
+};
+
+/* Framebuffer APIs */
+static int mx2fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info);
+static int mx2fb_set_par(struct fb_info *info);
+static int mx2fb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			   unsigned blue, unsigned transp,
+			   struct fb_info *info);
+static int mx2fb_pan_display(struct fb_var_screeninfo *var,
+			     struct fb_info *info);
+static int mx2fb_blank(int blank_mode, struct fb_info *info);
+static int mx2fb_ioctl(struct fb_info *info, unsigned int cmd,
+		       unsigned long arg);
+
+/* Driver entries */
+int __init mx2fb_init(void);
+void __exit mx2fb_exit(void);
+#ifndef MODULE
+static int __init mx2fb_setup(char *);
+#endif
+
+/* Internal functions */
+static int __init _init_fbinfo(struct fb_info *info,
+			       struct platform_device *pdev);
+static int __init _install_fb(struct fb_info *info,
+			      struct platform_device *pdev);
+static void __exit _uninstall_fb(struct fb_info *info);
+static int _map_video_memory(struct fb_info *info);
+static void _unmap_video_memory(struct fb_info *info);
+static void _set_fix(struct fb_info *info);
+static void _enable_slcdc(struct fb_info *info);
+static void _disable_slcdc(struct fb_info *info);
+static void _update_slcdc(struct fb_info *info);
+static void _request_irq(void);
+static void _free_irq(void);
+
+#ifdef CONFIG_PM
+static int mx2fb_suspend(struct platform_device *pdev, pm_message_t state);
+static int mx2fb_resume(struct platform_device *pdev);
+#else
+#define mx2fb_suspend	0
+#define mx2fb_resume	0
+#endif
+
+static int mx2fb_probe(struct platform_device *pdev);
+
+struct mx2fb_info mx2fbi_bg = {
+	.type = MX2FB_TYPE_BG,
+	.id = "DISP0 BG",
+	.registered = 0,
+};
+
+/*!
+ * @brief Framebuffer information structures.
+ * There's one framebuffer.
+ */
+static struct fb_info mx2fb_info[] = {
+	{.par = &mx2fbi_bg},
+};
+
+/*!
+ * @brief This structure contains pointers to the power management
+ * callback functions.
+ */
+static struct platform_driver mx2fb_driver = {
+	.driver = {
+		   .name = "mxc_sdc_fb",
+		   .owner = THIS_MODULE,
+		   .bus = &platform_bus_type,
+		   },
+	.probe = mx2fb_probe,
+	.suspend = mx2fb_suspend,
+	.resume = mx2fb_resume,
+};
+
+/*!
+ * @brief Framebuffer file operations
+ */
+static struct fb_ops mx2fb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = mx2fb_check_var,
+	.fb_set_par = mx2fb_set_par,
+	.fb_setcolreg = mx2fb_setcolreg,
+	.fb_blank = mx2fb_blank,
+	.fb_pan_display = mx2fb_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	//.fb_cursor = soft_cursor,
+	.fb_ioctl = mx2fb_ioctl,
+};
+
+/*!
+ * @brief Validates a var passed in.
+ *
+ * @param var	Frame buffer variable screen structure
+ * @param info	Frame buffer structure that represents a single frame buffer
+ *
+ * @return	Negative errno on error, or zero on success.
+ *
+ * Checks to see if the hardware supports the state requested by var passed
+ * in. This function does not alter the hardware state! If the var passed in
+ * is slightly off by what the hardware can support then we alter the var
+ * PASSED in to what we can do. If the hardware doesn't support mode change
+ * a -EINVAL will be returned by the upper layers.
+ *
+ */
+static int mx2fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	unsigned long htotal, vtotal;
+
+	pr_func("^^^^ mx2fb_check_var was called\n");
+
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	if (var->xoffset < 0)
+		var->xoffset = 0;
+
+	if (var->yoffset < 0)
+		var->yoffset = 0;
+
+	if (var->xoffset + info->var.xres > info->var.xres_virtual)
+		var->xoffset = info->var.xres_virtual - info->var.xres;
+
+	if (var->yoffset + info->var.yres > info->var.yres_virtual)
+		var->yoffset = info->var.yres_virtual - info->var.yres;
+
+	var->bits_per_pixel = default_bpp;
+
+	var->red.length = 5;
+	var->red.offset = 11;
+	var->red.msb_right = 0;
+
+	var->green.length = 6;
+	var->green.offset = 5;
+	var->green.msb_right = 0;
+
+	var->blue.length = 5;
+	var->blue.offset = 0;
+	var->blue.msb_right = 0;
+
+	var->transp.length = 0;
+	var->transp.offset = 0;
+	var->transp.msb_right = 0;
+
+	if (var->pixclock < 1000) {
+		htotal = var->xres + var->right_margin + var->hsync_len +
+		    var->left_margin;
+		vtotal = var->yres + var->lower_margin + var->vsync_len +
+		    var->upper_margin;
+		var->pixclock = (vtotal * htotal * 6UL) / 100UL;
+		var->pixclock = KHZ2PICOS(var->pixclock);
+		dev_dbg(info->device,
+			"pixclock set for 60Hz refresh = %u ps\n",
+			var->pixclock);
+	}
+	var->height = -1;
+	var->width = -1;
+	var->grayscale = 0;
+
+	/* Copy nonstd field to/from sync for fbset usage */
+	var->sync |= var->nonstd;
+	var->nonstd |= var->sync;
+
+	return 0;
+}
+
+/*!
+ * @brief Alters the hardware state.
+ *
+ * @param info	Frame buffer structure that represents a single frame buffer
+ *
+ * @return Zero on success others on failure
+ *
+ * Using the fb_var_screeninfo in fb_info we set the resolution of this
+ * particular framebuffer. This function alters the fb_fix_screeninfo stored
+ * in fb_info. It doesn't not alter var in fb_info since we are using that
+ * data. This means we depend on the data in var inside fb_info to be
+ * supported by the hardware. mx2fb_check_var is always called before
+ * mx2fb_set_par to ensure this.
+ */
+static int mx2fb_set_par(struct fb_info *info)
+{
+	unsigned long len;
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	pr_func("^^^^ mx2fb_set_par was called\n");
+
+	_set_fix(info);
+
+	len = info->var.yres_virtual * info->fix.line_length;
+	if (len > info->fix.smem_len) {
+		if (info->fix.smem_start)
+			_unmap_video_memory(info);
+
+		/* Memory allocation for framebuffer */
+		if (_map_video_memory(info)) {
+			dev_err(info->device, "Unable to allocate fb memory\n");
+			return -ENOMEM;
+		}
+	}
+
+	_update_slcdc(info);
+	if (info->fbops->fb_blank)
+		info->fbops->fb_blank(mx2fbi->blank, info);
+
+	return 0;
+}
+
+/*!
+ * @brief Sets a color register.
+ *
+ * @param regno		Which register in the CLUT we are programming
+ * @param red		The red value which can be up to 16 bits wide
+ * @param green		The green value which can be up to 16 bits wide
+ * @param blue		The blue value which can be up to 16 bits wide.
+ * @param transp	If supported the alpha value which can be up to
+ *                      16 bits wide.
+ * @param info		Frame buffer info structure
+ *
+ * @return		Negative errno on error, or zero on success.
+ *
+ * Set a single color register. The values supplied have a 16 bit magnitude
+ * which needs to be scaled in this function for the hardware. Things to take
+ * into consideration are how many color registers, if any, are supported with
+ * the current color visual. With truecolor mode no color palettes are
+ * supported. Here a psuedo palette is created which we store the value in
+ * pseudo_palette in struct fb_info. For pseudocolor mode we have a limited
+ * color palette.
+ */
+static int mx2fb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			   unsigned blue, unsigned transp, struct fb_info *info)
+{
+	int ret = 1;
+
+	pr_func("^^^^ mx2fb_setcolreg was called\n");
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (info->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+				      7471 * blue) >> 16;
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = info->pseudo_palette;
+			u32 v;
+
+#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
+			red = CNVT_TOHW(red, info->var.red.length);
+			green = CNVT_TOHW(green, info->var.green.length);
+			blue = CNVT_TOHW(blue, info->var.blue.length);
+			transp = CNVT_TOHW(transp, info->var.transp.length);
+#undef CNVT_TOHW
+
+			v = (red << info->var.red.offset) |
+			    (green << info->var.green.offset) |
+			    (blue << info->var.blue.offset) |
+			    (transp << info->var.transp.offset);
+
+			pal[regno] = v;
+			ret = 0;
+		}
+		break;
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		break;
+	}
+
+	return ret;
+}
+
+/*!
+ * @brief Pans the display.
+ *
+ * @param var	Frame buffer variable screen structure
+ * @param info	Frame buffer structure that represents a single frame buffer
+ *
+ * @return	Negative errno on error, or zero on success.
+ *
+ * Pan (or wrap, depending on the `vmode' field) the display using the
+ * 'xoffset' and 'yoffset' fields of the 'var' structure. If the values
+ * don't fit, return -EINVAL.
+ */
+static int mx2fb_pan_display(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+//      pr_func("^^^^ mx2fb_pan_display was called\n");
+
+	if ((info->var.xoffset == var->xoffset) &&
+	    (info->var.yoffset == var->yoffset)) {
+		return 0;	/* No change, do nothing */
+	}
+
+	if (var->xoffset < 0 || var->yoffset < 0
+	    || var->xoffset + info->var.xres > info->var.xres_virtual
+	    || var->yoffset + info->var.yres > info->var.yres_virtual)
+		return -EINVAL;
+
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+
+	_update_slcdc(info);
+
+	if (var->vmode & FB_VMODE_YWRAP) {
+		info->var.vmode |= FB_VMODE_YWRAP;
+	} else {
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Blanks the display.
+ *
+ * @param blank_mode	The blank mode we want.
+ * @param info		Frame buffer structure that represents a single frame buffer
+ *
+ * @return		Negative errno on error, or zero on success.
+ *
+ * Blank the screen if blank_mode != 0, else unblank. Return 0 if blanking
+ * succeeded, != 0 if un-/blanking failed.
+ * blank_mode == 2: suspend vsync
+ * blank_mode == 3: suspend hsync
+ * blank_mode == 4: powerdown
+ */
+static int mx2fb_blank(int blank_mode, struct fb_info *info)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	pr_func("^^^^ mx2fb_blank was called\n");
+
+	dev_dbg(info->device, "blank mode = %d\n", blank_mode);
+
+	mx2fbi->blank = blank_mode;
+
+	switch (blank_mode) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		_disable_slcdc(info);
+		break;
+	case FB_BLANK_UNBLANK:
+		_enable_slcdc(info);
+		break;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Ioctl function to support customized ioctl operations.
+ *
+ * @param info	Framebuffer structure that represents a single frame buffer
+ * @param cmd	The command number
+ * @param arg	Argument which depends on cmd
+ *
+ * @return	Negative errno on error, or zero on success.
+ */
+static int mx2fb_ioctl(struct fb_info *info, unsigned int cmd,
+		       unsigned long arg)
+{
+	return 0;
+}
+
+/*!
+ * @brief Set fixed framebuffer parameters based on variable settings.
+ *
+ * @param info	framebuffer information pointer
+ * @return	Negative errno on error, or zero on success.
+ */
+static void _set_fix(struct fb_info *info)
+{
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	pr_func("^^^^ _set_fix\n");
+
+	strncpy(fix->id, mx2fbi->id, strlen(mx2fbi->id));
+	fix->line_length = var->xres_virtual * var->bits_per_pixel / 8;
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->accel = FB_ACCEL_NONE;
+	fix->visual = FB_VISUAL_TRUECOLOR;
+	fix->xpanstep = 1;
+	fix->ypanstep = 1;
+}
+
+/*!
+ * @brief Initialize framebuffer information structure.
+ *
+ * @param info	framebuffer information pointer
+ * @param pdev	pointer to struct device
+ * @return	Negative errno on error, or zero on success.
+ */
+static int __init _init_fbinfo(struct fb_info *info,
+			       struct platform_device *pdev)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	pr_func("^^^^ _init_fbinfo was called\n");
+
+	info->device = &pdev->dev;
+	info->var.activate = FB_ACTIVATE_NOW;
+	info->fbops = &mx2fb_ops;
+	info->flags = FBINFO_FLAG_DEFAULT;
+	info->pseudo_palette = &mx2fbi->pseudo_palette;
+
+	/* Allocate colormap */
+	fb_alloc_cmap(&info->cmap, 16, 0);
+
+	return 0;
+}
+
+/*!
+ * @brief Install framebuffer into the system.
+ *
+ * @param info	framebuffer information pointer
+ * @param pdev  pointer to struct device
+ * @return	Negative errno on error, or zero on success.
+ */
+static int __init _install_fb(struct fb_info *info,
+			      struct platform_device *pdev)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	pr_func("^^^^ _install_fb was called\n");
+
+	if (_init_fbinfo(info, pdev))
+		return -EINVAL;
+
+	if (fb_mode == 0)
+		fb_mode = pdev->dev.platform_data;
+
+	if (!fb_find_mode(&info->var, info, fb_mode, mxcfb_modedb,
+			  mxcfb_modedb_sz, NULL, default_bpp)) {
+		fb_dealloc_cmap(&info->cmap);
+		return -EBUSY;
+	}
+
+	/* Default Y virtual size is 2x panel size */
+	info->var.yres_virtual = info->var.yres << 1;
+	pr_info("xres = %d, yres = %d\n", info->var.xres, info->var.yres);
+
+	mx2fbi->blank = FB_BLANK_UNBLANK;
+
+	if (mx2fb_set_par(info)) {
+		fb_dealloc_cmap(&info->cmap);
+		return -EINVAL;
+	}
+	if (register_framebuffer(info) < 0) {
+		_unmap_video_memory(info);
+		fb_dealloc_cmap(&info->cmap);
+		return -EINVAL;
+	}
+
+	mx2fbi->registered = 1;
+	dev_info(info->device, "fb%d: %s fb device registered successfully.\n",
+		 info->node, info->fix.id);
+
+	return 0;
+}
+
+/*!
+ * @brief Uninstall framebuffer from the system.
+ *
+ * @param info	framebuffer information pointer
+ */
+static void __exit _uninstall_fb(struct fb_info *info)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	pr_func("^^^^ _uninstall_fb was called\n");
+
+	if (!mx2fbi->registered)
+		return;
+
+	unregister_framebuffer(info);
+	_unmap_video_memory(info);
+	if (&info->cmap)
+		fb_dealloc_cmap(&info->cmap);
+
+	mx2fbi->registered = 0;
+}
+
+/*!
+ * @brief Allocate memory for framebuffer.
+ *
+ * @param info	framebuffer information pointer
+ * @return	Negative errno on error, or zero on success.
+ */
+static int _map_video_memory(struct fb_info *info)
+{
+	pr_func("^^^^ _map_video_memory was called\n");
+
+	//info->fix.smem_len = info->fix.line_length * info->var.yres_virtual;
+	info->fix.smem_len = (128 * 1024 * 2) + (info->fix.line_length * info->var.yres);
+
+	//REMARK: FIXME?
+	// The Frame Buffer application uses a double buffer scheme,
+	//  from a continuous 307200 (320 * 240 * 2 * 2) bytes long buffer.
+	//  The application will Ping Pong between relative offset 0 and
+	//  relative offset 153600. When the Frame Buffer is pointing to
+	//  relative offset 0, the images looks 100% perfect.
+	//  When the Frame Buffer is pointing to relative offset 153600
+	//  only 75% of the image shows correctly and the last 25% shows
+	//  some unaligned old data. As soon as the application flips back
+	//  to relative offset 0 the image shows again perfectly.
+	//  This artifact is occurring because, according to Mx25
+	//  reference manual page 1541:
+	//  "SLCDC DMA address generator width is 17-bits. Therefore, it is
+	//  possible that a data buffer can be incorrectly addressed by SLCDC,
+	//  if it extends beyond a 128 kbyte boundary.
+	//  Therefore, it is recommended that data buffer base address be set
+	//  at the beginning of a 128 kbyte boundary. The sum of
+	//  DATABASEADR[16:0] and DATABUFSIZ[16:0] must not exceed a multiple
+	//  of 128K."
+	//  To avoid this artifact, the driver can create a single
+	//  buffer long enough to have two (320 * 240 * 2) buffers with
+	//  starting address aligned at 128Kbyte boundaries, the first buffer
+	//  will start at relative 0, and the second buffer at relative offset
+	//  (128 * 1024 * 2). This will require the application to be aware
+	//  of doing ping pong between 0 and (128 * 1024 * 2),
+	//  instead of 0 and (320 * 240 * 2) which is the current situation.
+	info->screen_base = dma_alloc_coherent(0,
+					       info->fix.smem_len,
+					       (dma_addr_t *) & info->fix.
+					       smem_start,
+					       GFP_DMA | GFP_KERNEL);
+
+	if (info->screen_base == 0) {
+		dev_err(info->device, "Unable to allocate fb memory\n");
+		return -EBUSY;
+	}
+	pr_info("+++++ Allocated fb @ paddr=0x%08lX, size=%d.\n",
+		info->fix.smem_start, info->fix.smem_len);
+
+	info->screen_size = info->fix.smem_len;
+
+	/* Clear the screen */
+	memset((char *)info->screen_base, 0, info->fix.smem_len);
+
+	return 0;
+}
+
+/*!
+ * @brief Release memory for framebuffer.
+ * @param info	framebuffer information pointer
+ */
+static void _unmap_video_memory(struct fb_info *info)
+{
+	pr_func("^^^^ _unmap_video_memory was called\n");
+
+	dma_free_coherent(0, info->fix.smem_len, info->screen_base,
+			  (dma_addr_t) info->fix.smem_start);
+
+	info->screen_base = 0;
+	info->fix.smem_start = 0;
+	info->fix.smem_len = 0;
+}
+
+/*!
+ * @brief Enable LCD controller.
+ * @param info	framebuffer information pointer
+ */
+static void _enable_slcdc(struct fb_info *info)
+{
+	//struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+	pr_func("^^^^ _enable_slcdc was called\n");
+
+	if (!fb_enabled) {
+		clk_enable(slcdc_clk);
+		gpio_slcdc_active();
+		board_power_lcd(1);
+		fb_enabled++;
+	}
+}
+
+/*!
+ * @brief Disable LCD controller.
+ * @param info	framebuffer information pointer
+ */
+static void _disable_slcdc(struct fb_info *info)
+{
+	//struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+	pr_func("^^^^ _disable_slcdc was called\n");
+
+	if (fb_enabled) {
+		gpio_slcdc_inactive();
+		board_power_lcd(0);
+		clk_disable(slcdc_clk);
+		fb_enabled = 0;
+	}
+}
+
+/*!
+ * @brief Update LCDC registers
+ * @param info	framebuffer information pointer
+ */
+static void _update_slcdc(struct fb_info *info)
+{
+	unsigned long base;
+	uint32_t clk_divider;
+	uint32_t lcdtransconfig;
+	uint32_t controlstatus;
+	struct fb_var_screeninfo *var = &info->var;
+	//struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	//pr_func("^^^^ _update_slcdc was called\n");
+	//controlstatus = __raw_readl(SLCDC_REG(SLCDC_SLCDCCONTROLSTATUS));
+	//pr_info("=====  u1 slcldc status 0x%08X\n", controlstatus);
+
+	//base = (var->yoffset * var->xres_virtual + var->xoffset);
+	if (var->yoffset) {
+		base = (128 * 1024);
+	}
+	else {
+		base = 0;
+	}
+
+	base *= (var->bits_per_pixel) / 8;
+	base += info->fix.smem_start;
+
+	//Let's make sure the SLCDC is not busy before starting to
+	//send bytes.
+	while (1){
+		controlstatus = __raw_readl(SLCDC_REG(SLCDC_SLCDCCONTROLSTATUS));
+		if ((controlstatus & (1 << 2)) == 0){
+			break;
+		}
+		//pr_info("+++ SLCDC busy\n");
+	}
+
+	/* Screen start address register */
+	__raw_writel(base, SLCDC_REG(SLCDC_DATABASEADR));
+
+	/* Size register */
+	//pr_info("line_length = %d, yres = %d\n",
+	//	info->fix.line_length, info->var.yres);
+	__raw_writel( (info->fix.line_length * info->var.yres) >> 1,
+		     SLCDC_REG(SLCDC_DATABUFSIZE));
+
+	/* To setup SLCDC pixel data clock */
+	//pr_info(">>>>>  slcdc_clk rate is %lu\n", clk_get_rate(slcdc_clk));
+	clk_divider = (TARGET_SLCDC_CLOCK_RATE * 128) / clk_get_rate(slcdc_clk);
+	//pr_info(">>>>> clk_divider is %u\n", clk_divider);
+	__raw_writel(clk_divider, SLCDC_REG(SLCDC_LCDCLOCKCONFIG));
+
+	//Set the FIFO Configuration register to the lowest.
+	//0 is 1 word,..., 7 is 8 words.
+	__raw_writel(0, SLCDC_REG(SLCDC_FIFOCONFIG));
+
+	lcdtransconfig = (1 << 16) | //16-bit littleendian
+		(0 << 5) | //8-bit data words for LCD WRITE DATA (when sending commands).
+		(1 << 4) | //16-bit data words (when sending pixels).
+		(1 << 2) | //parallel transfer mode.
+		(0 << 1); //CSPOL
+	__raw_writel(lcdtransconfig, SLCDC_REG(SLCDC_LCDTRANSCONFIG));
+
+	controlstatus = (1 << 11) | //AUTOMODE at b01 (applies when sending pixels).
+		(1 << 8) | //Privileged data access.
+		(0  << 7) | //Disable interrupt.
+		1; //GO, start transfer
+	__raw_writel(controlstatus, SLCDC_REG(SLCDC_SLCDCCONTROLSTATUS));
+}
+
+/*
+ * @brief SLCDC interrupt handler
+ *
+ * REMARK: This driver doesn't use SLCDC interrupts.
+ */
+static irqreturn_t mx2fb_isr(int irq, void *dev_id)
+{
+	pr_func("^^^^^ EMPTY mx2fb_isr\n");
+#if 0
+	uint32_t status = __raw_readl(SLCDC_REG(SLCDC_SLCDCCONTROLSTATUS));
+#endif
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * @brief Config and request SLCDC interrupt
+ */
+static void _request_irq(void)
+{
+	pr_func("^^^^ EMPTY _request_irq was called\n");
+
+#if 0
+
+	if (request_irq(MXC_INT_SLCDC, mx2fb_isr, 0, "SLCDC", 0))
+		pr_info("Request SLCDC IRQ failed.\n");
+	else {
+		//Here enable interrupts  by writing
+		//to desired bits on SLCDC_REG(SLCDC_SLCDCCONTROLSTATUS) register.
+	}
+#endif
+}
+
+/*!
+ * @brief Free SLCDC interrupt handler
+ */
+static void _free_irq(void)
+{
+	pr_func("^^^^ _free_irq was called\n");
+
+#if 0
+	/* Disable all SLCDC interrupt */
+	//Put code here. usually modify
+	// SLCDC_REG(SLCDC_SLCDCCONTROLSTATUS) register.
+
+	//unregister the ISR.
+	free_irq(MXC_INT_SLCDC, 0);
+
+#endif
+}
+
+#ifdef CONFIG_PM
+/*
+ * Power management hooks. Note that we won't be called from IRQ context,
+ * unlike the blank functions above, so we may sleep.
+ */
+
+/*!
+ * @brief Suspends the framebuffer and blanks the screen.
+ * Power management support
+ */
+static int mx2fb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	pr_func("^^^^ mx2fb_suspend was called\n");
+
+	_disable_slcdc(&mx2fb_info[0]);
+
+	return 0;
+}
+
+/*!
+ * @brief Resumes the framebuffer and unblanks the screen.
+ * Power management support
+ */
+static int mx2fb_resume(struct platform_device *pdev)
+{
+	pr_func("^^^^ mx2fb_resume was called\n");
+
+	_enable_slcdc(&mx2fb_info[0]);
+
+	return 0;
+}
+
+#endif				/* CONFIG_PM */
+
+/*!
+ * @brief Probe routine for the framebuffer driver. It is called during the
+ *        driver binding process.
+ *
+ * @return Appropriate error code to the kernel common code
+ */
+static int mx2fb_probe(struct platform_device *pdev)
+{
+	int ret, i;
+
+	pr_func("^^^^ mx2fb_probe was called\n");
+
+	slcdc_clk = clk_get(&pdev->dev, "slcdc_clk");
+
+	for (i = 0; i < sizeof(mx2fb_info) / sizeof(struct fb_info); i++) {
+		if ((ret = _install_fb(&mx2fb_info[i], pdev))) {
+			dev_err(&pdev->dev,
+				"Failed to register framebuffer %d\n", i);
+			return ret;
+		}
+	}
+	_request_irq();
+
+	return 0;
+}
+
+#define SLCD_CMD (0x100) //RS bit '1' means it's data byte. '0' means it's command byte
+#define SLCD_DELAY_MS (0x8000) //When bit 31 is '1', it's not a command nor data byte, but a delay in milliseconds.
+const uint16_t wintek_slcdc_init_sequence[] =
+{
+/* SLPOUT              */   SLCD_CMD | 0x11,
+/* Delay 120 ms        */   SLCD_DELAY_MS | 120,
+/* Power Control 1 	   */   SLCD_CMD | 0xc0, 0x0a,
+/* Power Control 2 	   */   SLCD_CMD | 0xc1, 0x06, 0x06, 0x06,
+/* Power Control 3 	   */   SLCD_CMD | 0xc2, 0x55, 0x00,
+/* Power Control 4 	   */   SLCD_CMD | 0xc3, 0x55, 0x00,
+/* Power Control 5 	   */   SLCD_CMD | 0xc4, 0x55, 0x00,
+/* VCOM Control    	   */   SLCD_CMD | 0xc5, 0x27, 0x34,
+/* VCOM offset control */   SLCD_CMD | 0xc7, 0x40,
+/* Set Positive gamma  */   SLCD_CMD | 0xe0, 0x0d, 0x0f, 0x13, 0x0c, 0x15, 0x17,
+/* correction          */                    0x3b, 0x8c, 0x4d, 0x0b, 0x1e, 0x25, 0x1c, 0x23, 0x37,
+/* Set Negative gamma  */   SLCD_CMD | 0xe1, 0x0d, 0x1f, 0x26, 0x0a, 0x11, 0x13, 0x3a, 0x37, 0x4c,
+/* correction          */                    0x09, 0x1a, 0x23, 0x33, 0x37, 0x37,
+/* GAMSET              */   SLCD_CMD | 0x26, 0x10,
+/* Set Dis             */   SLCD_CMD | 0xb0, 0x0c, /* from novatech eratta */
+
+#if 0
+// XXXX display rotation causes tearing
+/* Rotate display      */   SLCD_CMD | 0x36, 0xA0,
+/* CASET */                 SLCD_CMD | 0x2A, 0x00, 0x00, 0x01, 0x3F,
+/* RASET */                 SLCD_CMD | 0x2B, 0x00, 0x00, 0x00, 0xEF,
+#endif
+
+/* Set division ratio
+   for internal clocks
+   of normal mode      */   SLCD_CMD | 0xb1, 0x6a, 0x15,
+/* Set Division ratio
+   for internal clocks
+   of idle mode        */   SLCD_CMD | 0xb2, 0x6a, 0x15,
+/* Set Division ratio
+   for internal clocks
+   of partial mode
+   (idle mode off)     */   SLCD_CMD | 0xb3, 0x6a, 0x15,
+/* display function set*/   SLCD_CMD | 0xb6, 0x01, 0x04,
+/* DISPON              */   SLCD_CMD | 0x29,
+/* 16-bit 565 format */     SLCD_CMD | 0x3A, 0x05,
+/* Send RAMWR */            SLCD_CMD | 0x2C,
+};
+
+
+/*!
+ * @brief Sends, manually, a series of 8-bit words to the LCD Display
+ *
+ * @param seq	Pointer to buffer with words. These words can be commands or data.
+ * @param len	Number of words
+ *
+ * @return	nothing
+ *
+ * This function assumes we are sending 8-bit words. The reason seq is a
+ * pointer to uint16_t is because on bit 8 we encode if the word is actually
+ * a command(1) or data(0).
+ * on bit 15 we encode if it's actually a word or a waiting time in
+ * Milliseconds.
+ *
+ */
+static void send_slcdc_cmd_and_data(const uint16_t * seq, int len)
+{
+	uint32_t status;
+	uint32_t wr_data;
+	uint16_t value;
+	int i;
+
+	pr_func("^^^^ send_slcdc_cmd_and_data\n");
+
+	//Let's make sure the SLCDC is not busy before starting to
+	//send bytes.
+	while (1){
+		status = __raw_readl(SLCDC_REG(SLCDC_SLCDCCONTROLSTATUS));
+		if ((status & (1 << 2)) == 0){
+			break;
+		}
+	}
+	for (i = 0; i < len; i++) {
+		value = seq[i];
+		if (value & SLCD_DELAY_MS){
+			msleep(value & ~SLCD_DELAY_MS);
+			continue;
+		}
+		if (value & SLCD_CMD){
+			wr_data = value & ~SLCD_CMD;
+		}
+		else {
+			wr_data = value | (1 << 16); //Bit 16, RS must be '1' to send data.
+		}
+		__raw_writel(wr_data, SLCDC_REG(SLCDC_LCDWRITEDATA));
+		//Wait until it's not busy.
+		while (1){
+			status = __raw_readl(SLCDC_REG(SLCDC_SLCDCCONTROLSTATUS));
+			if ((status & (1 << 2)) == 0){
+				break;
+			}
+		}
+	}
+}
+
+
+/*!
+ * @brief Initialization
+ */
+int __init mx2fb_init(void)
+{
+	pr_func("^^^^ mx2fb_init was called\n");
+
+	/*
+	 * For kernel boot options (in 'video=xxxfb:<options>' format)
+	 */
+#ifndef MODULE
+	{
+		char *option;
+
+		if (fb_get_options("mxcfb", &option))
+			return -ENODEV;
+		mx2fb_setup(option);
+	}
+#endif
+	int err = platform_driver_register(&mx2fb_driver);
+
+	//Once we are here, the driver is fully initialized.
+	//Now, it's a matter of resetting the LCD display and
+	//send the initialization sequence.
+	extern void gpio_slcdc_reset(void);
+	gpio_slcdc_reset();
+	send_slcdc_cmd_and_data( wintek_slcdc_init_sequence, sizeof(wintek_slcdc_init_sequence) / sizeof(wintek_slcdc_init_sequence[0]) );
+
+	return err;
+}
+
+
+
+/*!
+ * @brief Cleanup
+ */
+void __exit mx2fb_exit(void)
+{
+	int i;
+
+	_free_irq();
+	for (i = sizeof(mx2fb_info) / sizeof(struct fb_info); i > 0; i--)
+		_uninstall_fb(&mx2fb_info[i - 1]);
+
+	platform_driver_unregister(&mx2fb_driver);
+}
+
+#ifndef MODULE
+/*!
+ * @brief Setup
+ * Parse user specified options
+ * Example: video=mxcfb:240x320,bpp=16,Sharp-QVGA
+ */
+static int __init mx2fb_setup(char *options)
+{
+	char *opt;
+
+	pr_func("^^^^ mx2fb_setup\n");
+
+	if (!options || !*options)
+		return 0;
+
+	pr_info("^^^^ options = %s\n", options);
+
+	while ((opt = strsep(&options, ",")) != NULL) {
+		if (!*opt)
+			continue;
+
+		if (!strncmp(opt, "bpp=", 4))
+			default_bpp = simple_strtoul(opt + 4, NULL, 0);
+		else
+			fb_mode = opt;
+	}
+
+	return 0;
+}
+#endif
+
+/* Modularization */
+module_init(mx2fb_init);
+module_exit(mx2fb_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MX2 SLCDC framebuffer driver");
+MODULE_LICENSE("GPL");
+
