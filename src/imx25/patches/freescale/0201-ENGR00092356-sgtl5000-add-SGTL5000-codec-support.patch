From 65fd44de7244bc712e19e8016fc4391053ccc0e6 Mon Sep 17 00:00:00 2001
From: Richard Zhao <b20223@freescale.com>
Date: Fri, 24 Oct 2008 15:34:34 +0800
Subject: [PATCH] ENGR00092356 sgtl5000: add SGTL5000 codec support

Add SGTL5000 codec driver and machine driver for mx37.

Signed-off-by: Richard Zhao <b20223@freescale.com>
---
 arch/arm/configs/imx37_3stack_defconfig |    4 +-
 arch/arm/mach-mx37/board-mx37_3stack.h  |    1 +
 arch/arm/mach-mx37/clock.c              |  101 +++
 arch/arm/mach-mx37/mx37_3stack.c        |   82 +++-
 arch/arm/mach-mx37/mx37_3stack_gpio.c   |    7 +
 include/asm-arm/arch-mxc/mxc.h          |   16 +
 sound/soc/codecs/Kconfig                |    4 +
 sound/soc/codecs/Makefile               |    2 +
 sound/soc/codecs/sgtl5000.c             | 1007 +++++++++++++++++++++++++++++++
 sound/soc/codecs/sgtl5000.h             |  396 ++++++++++++
 sound/soc/imx/Kconfig                   |    8 +
 sound/soc/imx/Makefile                  |    4 +-
 sound/soc/imx/imx-3stack-sgtl5000.c     |  679 +++++++++++++++++++++
 13 files changed, 2307 insertions(+), 4 deletions(-)

diff --git a/arch/arm/configs/imx37_3stack_defconfig b/arch/arm/configs/imx37_3stack_defconfig
index 82d1f37..fcced7b 100644
--- a/arch/arm/configs/imx37_3stack_defconfig
+++ b/arch/arm/configs/imx37_3stack_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.26
-# Mon Oct 20 10:28:59 2008
+# Fri Oct 24 15:23:40 2008
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -1158,6 +1158,7 @@ CONFIG_SND_SOC_IMX_3STACK_WM8350=y
 # CONFIG_SND_SOC_IMX_3STACK_AK4647 is not set
 # CONFIG_SND_SOC_IMX_3STACK_WM8580 is not set
 # CONFIG_SND_SOC_IMX_3STACK_WM8903 is not set
+CONFIG_SND_SOC_IMX_3STACK_SGTL5000=y
 
 #
 # ALSA SoC audio for Freescale SOCs
@@ -1167,6 +1168,7 @@ CONFIG_SND_SOC_IMX_3STACK_WM8350=y
 # SoC Audio for the Texas Instruments OMAP
 #
 CONFIG_SND_SOC_WM8350=y
+CONFIG_SND_SOC_SGTL5000=y
 
 #
 # Open Sound System
diff --git a/arch/arm/mach-mx37/board-mx37_3stack.h b/arch/arm/mach-mx37/board-mx37_3stack.h
index 744db9e..74d0049 100644
--- a/arch/arm/mach-mx37/board-mx37_3stack.h
+++ b/arch/arm/mach-mx37/board-mx37_3stack.h
@@ -107,4 +107,5 @@ extern int sdhc_write_protect(struct device *dev);
 extern int sdhc_init_card_det(int id);
 extern struct tve_platform_data tve_data;
 
+extern int headphone_det_status(void);
 #endif				/* __ASM_ARCH_MXC_BOARD_MX37_3STACK_H__ */
diff --git a/arch/arm/mach-mx37/clock.c b/arch/arm/mach-mx37/clock.c
index 33c46ad..8222cce 100644
--- a/arch/arm/mach-mx37/clock.c
+++ b/arch/arm/mach-mx37/clock.c
@@ -2485,6 +2485,104 @@ static struct clk scc_clk = {
 	.secondary = &ahb_clk,
 };
 
+static void cko1_recalc(struct clk *clk)
+{
+	unsigned long rate;
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= MXC_CCM_CCOSR_CKOL_DIV_MASK;
+	reg = reg >> MXC_CCM_CCOSR_CKOL_DIV_OFFSET;
+	rate = clk->parent->rate;
+	clk->rate = rate / (reg + 1);
+}
+
+static int cko1_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg |= MXC_CCM_CCOSR_CKOL_EN;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+
+static void cko1_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MXC_CCM_CCOSR_CKOL_EN;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+}
+
+static int cko1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+
+	div = (clk->parent->rate/rate - 1) & 0x7;
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MXC_CCM_CCOSR_CKOL_DIV_MASK;
+	reg |= div << MXC_CCM_CCOSR_CKOL_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+
+static unsigned long cko1_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	div = div < 1 ? 1 : div;
+	div = div > 8 ? 8 : div;
+	return clk->parent->rate / div;
+}
+
+static int cko1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 sel, reg;
+
+	if (parent == &cpu_clk)
+		sel = 0;
+	else if (parent == &pll1_sw_clk)
+		sel = 1;
+	else if (parent == &pll2_sw_clk)
+		sel = 2;
+	else if (parent == &pll3_sw_clk)
+		sel = 3;
+	else if (parent == &emi_core_clk)
+		sel = 4;
+	else if (parent == &nfc_clk)
+		sel = 6;
+	else if (parent == &vpu_clk[1])
+		sel = 7;
+	else if (parent == &ipu_di_clk)
+		sel = 8;
+	else if (parent == &ahb_clk)
+		sel = 11;
+	else if (parent == &ipg_clk)
+		sel = 12;
+	else if (parent == &ipg_perclk)
+		sel = 13;
+	else
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MXC_CCM_CCOSR_CKOL_SEL_MASK;
+	reg |= sel << MXC_CCM_CCOSR_CKOL_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+static struct clk cko1_clk = {
+	.name = "cko1_clk",
+	.recalc = cko1_recalc,
+	.enable = cko1_enable,
+	.disable = cko1_disable,
+	.set_rate = cko1_set_rate,
+	.round_rate = cko1_round_rate,
+	.set_parent = cko1_set_parent,
+};
+
 static struct clk *mxc_clks[] = {
 	&osc_clk,
 	&ckih_clk,
@@ -2580,6 +2678,7 @@ static struct clk *mxc_clks[] = {
 	&ata_clk,
 	&rng_clk,
 	&scc_clk,
+	&cko1_clk,
 };
 
 static void clk_tree_init(void)
@@ -2755,6 +2854,8 @@ int __init mxc_clocks_init(void)
 	clk_set_parent(&vpu_clk[0], &emi_core_clk);
 	clk_set_parent(&vpu_clk[1], &emi_core_clk);
 
+	clk_set_parent(&cko1_clk, &ipg_perclk);
+
 	/* Set the current working point. */
 	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
 	for (i = 0; i < cpu_wp_nr; i++) {
diff --git a/arch/arm/mach-mx37/mx37_3stack.c b/arch/arm/mach-mx37/mx37_3stack.c
index 73c7c59..d203e63 100644
--- a/arch/arm/mach-mx37/mx37_3stack.c
+++ b/arch/arm/mach-mx37/mx37_3stack.c
@@ -300,15 +300,19 @@ static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
 	 .platform_data = &ls_data,
 	 },
 };
+
 static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
 	{
 	 .type = "mc13892",
 	 .addr = 0x08,
 	 .platform_data = (void *)MX37_PIN_OWIRE_LINE,
 	 },
+	{
+	 .type = "sgtl5000-i2c",
+	 .addr = 0x0a,
+	 },
 };
 
-
 static struct spi_board_info mxc_spi_board_info[] __initdata = {
 	{
 	 .modalias = "cpld_spi",
@@ -715,6 +719,80 @@ static void mxc_init_bluetooth(void)
 	(void)platform_device_register(&mxc_bt_device);
 }
 
+#if defined(CONFIG_SND_SOC_IMX_3STACK_SGTL5000) \
+    || defined(CONFIG_SND_SOC_IMX_3STACK_SGTL5000_MODULE)
+static struct mxc_sgtl5000_platform_data sgtl5000_data = {
+	.ssi_num = 1,
+	.src_port = 2,
+	.ext_port = 5,
+	.hp_irq = IOMUX_TO_IRQ(MX37_PIN_AUD5_RXFS),
+	.hp_status = headphone_det_status,
+	.vddio_reg = "SW3",
+	.vdda_reg = "VAUDIO",
+	.amp_gpo = "GPO2",
+	.vddio = 1850000,
+	.vdda = 2775000,
+	.vddd = 0,
+	.sysclk = 8300000,
+};
+
+static struct platform_device sgtl5000_device = {
+	.name = "sgtl5000-imx",
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &sgtl5000_data,
+		},
+};
+
+static void mxc_sgtl5000_init(void)
+{
+	int err, pin;
+	struct clk *cko1, *parent;
+	unsigned long rate;
+
+	/* for board v1.1 do nothing*/
+	if (!board_is_mx37(BOARD_REV_2))
+		return;
+
+	pin = MX37_PIN_AUD5_RXFS;
+	err = mxc_request_iomux(pin, IOMUX_CONFIG_GPIO);
+	if (err) {
+		sgtl5000_data.hp_irq = -1;
+		printk(KERN_ERR "Error: sgtl5000_init request gpio failed!\n");
+		return;
+	}
+	mxc_iomux_set_pad(pin, PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PU);
+	mxc_set_gpio_direction(pin, 1);
+
+	/* cko1 clock */
+	mxc_request_iomux(MX37_PIN_GPIO1_6, IOMUX_CONFIG_ALT2);
+
+	cko1 = clk_get(NULL, "cko1_clk");
+	if (IS_ERR(cko1))
+		return;
+	parent = clk_get(NULL, "ipg_perclk");
+	if (IS_ERR(parent))
+		return;
+	clk_set_parent(cko1, parent);
+	rate = clk_round_rate(cko1, 13000000);
+	if (rate < 8000000 || rate > 27000000) {
+		printk(KERN_ERR "Error: SGTL5000 mclk freq %d out of range!\n",
+			rate);
+		clk_put(parent);
+		clk_put(cko1);
+		return;
+	}
+	clk_set_rate(cko1, rate);
+	clk_enable(cko1);
+	sgtl5000_data.sysclk = rate;
+	platform_device_register(&sgtl5000_device);
+}
+#else
+static inline void mxc_sgtl5000_init(void)
+{
+}
+#endif
+
 /*!
  * fixup for mx37 3stack board v1.1(wm8350)
  */
@@ -774,7 +852,6 @@ static void __init mxc_board_init(void)
 		mx37_3stack_fixup_for_board_v1();
 	i2c_register_board_info(0, mxc_i2c0_board_info,
 				ARRAY_SIZE(mxc_i2c0_board_info));
-
 	i2c_register_board_info(1, mxc_i2c1_board_info,
 				ARRAY_SIZE(mxc_i2c1_board_info));
 
@@ -787,6 +864,7 @@ static void __init mxc_board_init(void)
 	mxc_init_bl();
 	mxc_init_bluetooth();
 	mxc_init_gps();
+	mxc_sgtl5000_init();
 }
 
 /*
diff --git a/arch/arm/mach-mx37/mx37_3stack_gpio.c b/arch/arm/mach-mx37/mx37_3stack_gpio.c
index 6a84e9d..02cf3e8 100644
--- a/arch/arm/mach-mx37/mx37_3stack_gpio.c
+++ b/arch/arm/mach-mx37/mx37_3stack_gpio.c
@@ -987,3 +987,10 @@ void gpio_gps_inactive(void)
 }
 
 EXPORT_SYMBOL(gpio_gps_inactive);
+
+int headphone_det_status(void)
+{
+	return mxc_get_gpio_datain(MX37_PIN_AUD5_RXFS);
+}
+
+EXPORT_SYMBOL(headphone_det_status);
diff --git a/include/asm-arm/arch-mxc/mxc.h b/include/asm-arm/arch-mxc/mxc.h
index cff2ea3..69fdda2 100644
--- a/include/asm-arm/arch-mxc/mxc.h
+++ b/include/asm-arm/arch-mxc/mxc.h
@@ -229,6 +229,22 @@ struct tve_platform_data {
 	char *dig_reg;
 };
 
+struct mxc_sgtl5000_platform_data {
+	int ssi_num;
+	int src_port;
+	int ext_port;
+	int hp_irq;
+	int (*hp_status)(void);
+
+	char *vddio_reg;
+	char *vdda_reg;
+	char *amp_gpo;
+	int vddio;	/* voltage of VDDIO (uv) */
+	int vdda;	/* voltage of vdda (uv) */
+	int vddd;	/* voldtage of vddd (uv), zero if not connected */
+	int sysclk;
+};
+
 extern void mxc_wd_reset(void);
 unsigned long board_get_ckih_rate(void);
 
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 54f9559..1e85e38 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -60,3 +60,7 @@ config SND_SOC_AK4647
 config SND_SOC_WM8580
         tristate
         depends on SND_SOC
+
+config SND_SOC_SGTL5000
+	tristate
+	depends on SND_SOC
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 31f8e31..79c3d50 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -10,6 +10,7 @@ snd-soc-cs4270-objs := cs4270.o
 snd-soc-ak4647-objs := ak4647.o
 snd-soc-tlv320aic3x-objs := tlv320aic3x.o
 snd-soc-wm8580-objs := wm8580.o
+snd-soc-sgtl5000-objs := sgtl5000.o
 
 obj-$(CONFIG_SND_SOC_AC97_CODEC)	+= snd-soc-ac97.o
 obj-$(CONFIG_SND_SOC_WM8350)	+= snd-soc-wm8350.o
@@ -23,3 +24,4 @@ obj-$(CONFIG_SND_SOC_CS4270)	+= snd-soc-cs4270.o
 obj-$(CONFIG_SND_SOC_AK4647)	+= snd-soc-ak4647.o
 obj-$(CONFIG_SND_SOC_TLV320AIC3X)	+= snd-soc-tlv320aic3x.o
 obj-$(CONFIG_SND_SOC_WM8580)    += snd-soc-wm8580.o
+obj-$(CONFIG_SND_SOC_SGTL5000)	+= snd-soc-sgtl5000.o
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
new file mode 100644
index 0000000..525649e
--- /dev/null
+++ b/sound/soc/codecs/sgtl5000.c
@@ -0,0 +1,1007 @@
+/*
+ * sgtl5000.c  --  SGTL5000 ALSA SoC Audio driver
+ *
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/tlv.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "sgtl5000.h"
+
+struct sgtl5000_priv {
+	int sysclk;
+	int master;
+	int fmt;
+	int playback_active;
+	int capture_active;
+};
+
+static int sgtl5000_dapm_event(struct snd_soc_codec *codec, int event);
+
+struct i2c_client *sgtl5000_i2c_client;
+
+static unsigned int sgtl5000_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	int i2c_ret;
+	u16 value;
+	u16 addr = sgtl5000_i2c_client->addr;
+	u16 flags = sgtl5000_i2c_client->flags;
+	u8 buf0[2];
+	u8 buf1[2];
+	struct i2c_msg msg[2] = {
+					{addr, flags, 2, buf0},
+					{addr, flags | I2C_M_RD, 2, buf1},
+				};
+
+	buf0[0] = (reg & 0xff00) >> 8;
+	buf0[1] = reg & 0xff;
+	i2c_ret = i2c_transfer(sgtl5000_i2c_client->adapter, msg, 2);
+	if (i2c_ret < 0) {
+		pr_err("%s: read reg error : reg=%x\n", __func__, reg);
+		return 0;
+	}
+
+	value = buf1[0] << 8 | buf1[1];
+
+	pr_debug("r r:%02x,v:%04x\n", reg, value);
+	return value;
+}
+
+static int sgtl5000_write(struct snd_soc_codec *codec, unsigned int reg,
+			  unsigned int value)
+{
+	int i2c_ret;
+	u16 addr = sgtl5000_i2c_client->addr;
+	u16 flags = sgtl5000_i2c_client->flags;
+	u8 buf[4];
+	struct i2c_msg msg = {addr, flags, 4, buf};
+
+	pr_debug("w r:%02x,v:%04x\n", reg, value);
+	buf[0] = (reg & 0xff00) >> 8;
+	buf[1] = reg & 0xff;
+	buf[2] = (value & 0xff00) >> 8;
+	buf[3] = value & 0xff;
+
+	i2c_ret = i2c_transfer(sgtl5000_i2c_client->adapter, &msg, 1);
+	if (i2c_ret < 0) {
+		pr_err("%s: write reg error : R%02d = 0x%04x\n",
+		       __func__, reg, value);
+		return -EIO;
+	}
+
+	return i2c_ret;
+}
+
+#ifdef DEBUG
+static int all_reg[] = {
+SGTL5000_CHIP_ID,
+SGTL5000_CHIP_DIG_POWER,
+SGTL5000_CHIP_CLK_CTRL,
+SGTL5000_CHIP_I2S_CTRL,
+SGTL5000_CHIP_SSS_CTRL,
+SGTL5000_CHIP_ADCDAC_CTRL,
+SGTL5000_CHIP_DAC_VOL,
+SGTL5000_CHIP_PAD_STRENGTH,
+SGTL5000_CHIP_ANA_ADC_CTRL,
+SGTL5000_CHIP_ANA_HP_CTRL,
+SGTL5000_CHIP_ANA_CTRL,
+SGTL5000_CHIP_LINREG_CTRL,
+SGTL5000_CHIP_REF_CTRL,
+SGTL5000_CHIP_MIC_CTRL,
+SGTL5000_CHIP_LINE_OUT_CTRL,
+SGTL5000_CHIP_LINE_OUT_VOL,
+SGTL5000_CHIP_ANA_POWER,
+SGTL5000_CHIP_PLL_CTRL,
+SGTL5000_CHIP_CLK_TOP_CTRL,
+SGTL5000_CHIP_ANA_STATUS,
+SGTL5000_CHIP_SHORT_CTRL,
+};
+
+static void dump_reg(struct snd_soc_codec *codec)
+{
+	int i, reg;
+	printk(KERN_DEBUG "dump begin\n");
+	for (i = 0; i < 21; i++) {
+		reg = sgtl5000_read(codec, all_reg[i]);
+		printk(KERN_DEBUG "d r %04x, v %04x\n", all_reg[i], reg);
+	}
+	printk(KERN_DEBUG "dump end\n");
+}
+#else
+static void dump_reg(struct snd_soc_codec *codec)
+{
+}
+#endif
+
+static int dac_mux_put(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_codec *codec = widget->codec;
+	unsigned int reg;
+
+	if (ucontrol->value.enumerated.item[0]) {
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_CLK_TOP_CTRL);
+		reg |= SGTL5000_INT_OSC_EN;
+		sgtl5000_write(codec, SGTL5000_CHIP_CLK_TOP_CTRL, reg);
+
+		if (codec->dapm_state != SNDRV_CTL_POWER_D0) {
+			sgtl5000_dapm_event(codec, SNDRV_CTL_POWER_D1);
+			snd_soc_dapm_put_enum_double(kcontrol, ucontrol);
+			sgtl5000_dapm_event(codec, SNDRV_CTL_POWER_D0);
+		} else
+			snd_soc_dapm_put_enum_double(kcontrol, ucontrol);
+	} else {
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_CLK_TOP_CTRL);
+		reg &= ~SGTL5000_INT_OSC_EN;
+		sgtl5000_write(codec, SGTL5000_CHIP_CLK_TOP_CTRL, reg);
+
+		snd_soc_dapm_put_enum_double(kcontrol, ucontrol);
+		sgtl5000_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	}
+	return 0;
+}
+
+
+static const char *adc_mux_text[] = {
+	"MIC_IN", "LINE_IN"
+};
+
+static const char *dac_mux_text[] = {
+	"DAC", "LINE_IN"
+};
+
+static const struct soc_enum adc_enum =
+	SOC_ENUM_SINGLE(SGTL5000_CHIP_ANA_CTRL, 2, 2, adc_mux_text);
+
+static const struct soc_enum dac_enum =
+	SOC_ENUM_SINGLE(SGTL5000_CHIP_ANA_CTRL, 6, 2, dac_mux_text);
+
+static const struct snd_kcontrol_new adc_mux =
+	SOC_DAPM_ENUM("ADC Mux", adc_enum);
+
+static const struct snd_kcontrol_new dac_mux = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = "DAC Mux",
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE
+		  | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.info = snd_soc_info_enum_double,
+	.get = snd_soc_dapm_get_enum_double,
+	.put = dac_mux_put,
+	.private_value = (unsigned long)&dac_enum,
+};
+
+static const struct snd_soc_dapm_widget sgtl5000_dapm_widgets[] = {
+SND_SOC_DAPM_INPUT("LINE_IN"),
+SND_SOC_DAPM_INPUT("MIC_IN"),
+
+SND_SOC_DAPM_OUTPUT("HP_OUT"),
+SND_SOC_DAPM_OUTPUT("LINE_OUT"),
+
+SND_SOC_DAPM_MUX("ADC Mux", SND_SOC_NOPM, 0, 0, &adc_mux),
+SND_SOC_DAPM_MUX("DAC Mux", SND_SOC_NOPM, 0, 0, &dac_mux),
+
+SND_SOC_DAPM_ADC("ADC", "Capture", SGTL5000_CHIP_DIG_POWER, 6, 0),
+SND_SOC_DAPM_DAC("DAC", "Playback", SGTL5000_CHIP_DIG_POWER, 5, 0),
+};
+
+static const char *audio_map[][3] = {
+	{ "ADC Mux", "LINE_IN", "LINE_IN" },
+	{ "ADC Mux", "MIC_IN", "MIC_IN" },
+	{ "ADC", NULL, "ADC Mux"},
+	{ "DAC Mux", "DAC", "DAC" },
+	{ "DAC Mux", "LINE_IN", "LINE_IN" },
+	{ "LINE_OUT", NULL, "DAC" },
+	{ "HP_OUT", NULL, "DAC Mux" },
+	{}
+};
+
+static int sgtl5000_add_widgets(struct snd_soc_codec *codec,
+			      struct snd_soc_machine *machine)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sgtl5000_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(machine, codec,
+					 &sgtl5000_dapm_widgets[i]);
+	}
+
+	/* set up audio path audio_mapnects */
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(machine, audio_map[i][0],
+					   audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(machine);
+	return 0;
+}
+
+static int dac_info_volsw(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 0xfc - 0x3c;
+	return 0;
+}
+
+static int dac_get_volsw(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg, l, r;
+
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_DAC_VOL);
+	l = (reg & SGTL5000_DAC_VOL_LEFT_MASK) << SGTL5000_DAC_VOL_LEFT_SHIFT;
+	r = (reg & SGTL5000_DAC_VOL_RIGHT_MASK) << SGTL5000_DAC_VOL_RIGHT_SHIFT;
+	l = l < 0x3c ? 0x3c : l;
+	l = l > 0xfc ? 0xfc : l;
+	r = r < 0x3c ? 0x3c : r;
+	r = r > 0xfc ? 0xfc : r;
+	l = 0xfc - l;
+	r = 0xfc - r;
+
+	ucontrol->value.integer.value[0] = l;
+	ucontrol->value.integer.value[1] = l;
+
+	return 0;
+}
+
+static int dac_put_volsw(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg, l, r;
+
+	l = ucontrol->value.integer.value[0];
+	r = ucontrol->value.integer.value[1];
+
+	l = l < 0x3c ? 0x3c : l;
+	l = l > 0xfc ? 0xfc : l;
+	r = r < 0x3c ? 0x3c : r;
+	r = r > 0xfc ? 0xfc : r;
+	l = 0xfc - l;
+	r = 0xfc - r;
+
+	reg = l << SGTL5000_DAC_VOL_LEFT_SHIFT |
+	      r << SGTL5000_DAC_VOL_RIGHT_SHIFT;
+
+	sgtl5000_write(codec, SGTL5000_CHIP_DAC_VOL, reg);
+
+	return 0;
+}
+
+static const char *mic_gain_text[] = {
+	"0dB", "20dB", "30dB", "40dB"
+};
+
+static const char *adc_m6db_text[] = {
+	"No Change", "Reduced by 6dB"
+};
+
+static const struct soc_enum mic_gain =
+	SOC_ENUM_SINGLE(SGTL5000_CHIP_MIC_CTRL, 0, 4, mic_gain_text);
+
+static const struct soc_enum adc_m6db =
+	SOC_ENUM_SINGLE(SGTL5000_CHIP_ANA_ADC_CTRL, 8, 2, adc_m6db_text);
+
+static const struct snd_kcontrol_new sgtl5000_snd_controls[] = {
+SOC_ENUM("MIC GAIN", mic_gain),
+SOC_DOUBLE("Capture Volume", SGTL5000_CHIP_ANA_ADC_CTRL, 0, 4, 0xf, 0),
+SOC_ENUM("Capture Vol Reduction", adc_m6db),
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = "Playback Volume",
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+		  SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.info = dac_info_volsw, .get = dac_get_volsw,
+	.put = dac_put_volsw,
+},
+SOC_DOUBLE("Headphone Volume", SGTL5000_CHIP_ANA_HP_CTRL, 0, 8, 0x7f, 1),
+};
+
+static int sgtl5000_add_controls(struct snd_soc_codec *codec,
+			       struct snd_card *card)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(sgtl5000_snd_controls); i++) {
+		err = snd_ctl_add(card,
+				  snd_soc_cnew(&sgtl5000_snd_controls[i],
+					       codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static int sgtl5000_digital_mute(struct snd_soc_dai *codec_dai, int mute)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u16 reg1, reg2;
+
+	reg1 = sgtl5000_read(codec, SGTL5000_CHIP_ANA_CTRL);
+	reg2 = sgtl5000_read(codec, SGTL5000_CHIP_ADCDAC_CTRL);
+
+	if (mute) {
+		reg1 |= SGTL5000_LINE_OUT_MUTE;
+		reg1 |= SGTL5000_HP_MUTE;
+		reg1 |= SGTL5000_ADC_MUTE;
+		reg2 |= SGTL5000_DAC_MUTE_LEFT;
+		reg2 |= SGTL5000_DAC_MUTE_RIGHT;
+	} else {
+		reg1 &= ~SGTL5000_LINE_OUT_MUTE;
+		reg1 &= ~SGTL5000_HP_MUTE;
+		reg1 &= ~SGTL5000_ADC_MUTE;
+		reg2 &= ~SGTL5000_DAC_MUTE_LEFT;
+		reg2 &= ~SGTL5000_DAC_MUTE_RIGHT;
+	}
+
+	sgtl5000_write(codec, SGTL5000_CHIP_ANA_CTRL, reg1);
+	sgtl5000_write(codec, SGTL5000_CHIP_ADCDAC_CTRL, reg2);
+	if (!mute)
+		dump_reg(codec);
+	return 0;
+}
+
+static int sgtl5000_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			      unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+	u16 i2sctl = 0;
+	pr_debug("%s:fmt=%08x\n", __func__, fmt);
+	sgtl5000->master = 0;
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		i2sctl |= SGTL5000_I2S_MASTER;
+		sgtl5000->master = 1;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+	case SND_SOC_DAIFMT_CBS_CFM:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_DSP_A:
+		i2sctl |= SGTL5000_I2S_MODE_PCM;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		i2sctl |= SGTL5000_I2S_MODE_PCM;
+		i2sctl |= SGTL5000_I2S_LRALIGN;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		i2sctl |= SGTL5000_I2S_MODE_I2S_LJ;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		i2sctl |= SGTL5000_I2S_MODE_RJ;
+		i2sctl |= SGTL5000_I2S_LRPOL;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		i2sctl |= SGTL5000_I2S_MODE_I2S_LJ;
+		i2sctl |= SGTL5000_I2S_LRALIGN;
+		break;
+	default:
+		return -EINVAL;
+	}
+	sgtl5000->fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;
+
+	/* Clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+	case SND_SOC_DAIFMT_NB_IF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+	case SND_SOC_DAIFMT_IB_NF:
+		i2sctl |= SGTL5000_I2S_SCLK_INV;
+		break;
+	default:
+		return -EINVAL;
+	}
+	sgtl5000_write(codec, SGTL5000_CHIP_I2S_CTRL, i2sctl);
+
+	return 0;
+}
+
+static int sgtl5000_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				 int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+
+	sgtl5000->sysclk = freq;
+
+	return 0;
+}
+
+/* dai ops, called by machine drivers */
+static const struct snd_soc_dai_ops sgtl5000_dai_ops = {
+	.digital_mute = sgtl5000_digital_mute,
+	.set_fmt = sgtl5000_set_dai_fmt,
+	.set_sysclk = sgtl5000_set_dai_sysclk,
+};
+
+static int sgtl5000_pcm_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_link *pcm_link = substream->private_data;
+	struct snd_soc_codec *codec = pcm_link->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		sgtl5000->playback_active++;
+	else
+		sgtl5000->capture_active++;
+
+	return 0;
+}
+
+static void sgtl5000_pcm_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_link *pcm_link = substream->private_data;
+	struct snd_soc_codec *codec = pcm_link->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+	int reg;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		sgtl5000->playback_active--;
+	else
+		sgtl5000->capture_active--;
+
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_DIG_POWER);
+	reg &= ~(SGTL5000_I2S_IN_POWERUP | SGTL5000_I2S_OUT_POWERUP);
+	sgtl5000_write(codec, SGTL5000_CHIP_DIG_POWER, reg);
+}
+
+/*
+ * Set PCM DAI bit size and sample rate.
+ * input: params_rate, params_fmt
+ */
+static int sgtl5000_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_link *pcm_link = substream->private_data;
+	struct snd_soc_codec *codec = pcm_link->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+	int fs = params_rate(params);
+	int clk_ctl = 0;
+	int pll_ctl = 0;
+	int i2s_ctl;
+	int div2 = 0;
+	int reg;
+
+	if (!sgtl5000->sysclk) {
+		pr_err("%s: set sysclk first!\n", __func__);
+		return -EFAULT;
+	}
+
+	switch (fs) {
+	case 32000:
+		clk_ctl |= SGTL5000_SYS_FS_32k << SGTL5000_SYS_FS_SHIFT;
+		break;
+	case 44100:
+		clk_ctl |= SGTL5000_SYS_FS_44_1k << SGTL5000_SYS_FS_SHIFT;
+		break;
+	case 48000:
+		clk_ctl |= SGTL5000_SYS_FS_48k << SGTL5000_SYS_FS_SHIFT;
+		break;
+	case 96000:
+		clk_ctl |= SGTL5000_SYS_FS_96k << SGTL5000_SYS_FS_SHIFT;
+		break;
+	default:
+		pr_err("%s: sample rate %d not supported\n", __func__, fs);
+		return -EFAULT;
+	}
+
+	if (fs*256 == sgtl5000->sysclk)
+		clk_ctl |= SGTL5000_MCLK_FREQ_256FS << SGTL5000_MCLK_FREQ_SHIFT;
+	else if (fs*384 == sgtl5000->sysclk && fs != 96000)
+		clk_ctl |= SGTL5000_MCLK_FREQ_384FS << SGTL5000_MCLK_FREQ_SHIFT;
+	else if (fs*512 == sgtl5000->sysclk && fs != 96000)
+		clk_ctl |= SGTL5000_MCLK_FREQ_512FS << SGTL5000_MCLK_FREQ_SHIFT;
+	else {
+		if (!sgtl5000->master) {
+			pr_err("%s: PLL not supported in slave mode\n",
+			       __func__);
+			return -EINVAL;
+		}
+		clk_ctl |= SGTL5000_MCLK_FREQ_PLL << SGTL5000_MCLK_FREQ_SHIFT;
+	}
+
+	if ((clk_ctl & SGTL5000_MCLK_FREQ_MASK) == SGTL5000_MCLK_FREQ_PLL) {
+		u64 out, t;
+		unsigned int in, int_div, frac_div;
+		if (sgtl5000->sysclk > 17000000) {
+			div2 = 1;
+			in = sgtl5000->sysclk / 2;
+		} else {
+			div2 = 0;
+			in = sgtl5000->sysclk;
+		}
+		if (fs == 44100)
+			out = 180633600;
+		else
+			out = 196608000;
+		t = do_div(out, in);
+		int_div = out;
+		t *= 2048;
+		do_div(t, in);
+		frac_div = t;
+		pll_ctl = int_div << SGTL5000_PLL_INT_DIV_SHIFT |
+			  frac_div << SGTL5000_PLL_FRAC_DIV_SHIFT;
+	}
+
+	i2s_ctl = sgtl5000_read(codec, SGTL5000_CHIP_I2S_CTRL);
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		if (sgtl5000->fmt == SND_SOC_DAIFMT_RIGHT_J)
+			return -EINVAL;
+		i2s_ctl |= SGTL5000_I2S_DLEN_16 << SGTL5000_I2S_DLEN_SHIFT;
+		i2s_ctl |= SGTL5000_I2S_SCLKFREQ_32FS <<
+			    SGTL5000_I2S_SCLKFREQ_SHIFT;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		i2s_ctl |= SGTL5000_I2S_DLEN_20 << SGTL5000_I2S_DLEN_SHIFT;
+		i2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<
+			   SGTL5000_I2S_SCLKFREQ_SHIFT;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		if ((clk_ctl & SGTL5000_MCLK_FREQ_MASK) !=
+		    SGTL5000_MCLK_FREQ_256FS)
+			return -EINVAL;
+		i2s_ctl |= SGTL5000_I2S_DLEN_24 << SGTL5000_I2S_DLEN_SHIFT;
+		i2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<
+			   SGTL5000_I2S_SCLKFREQ_SHIFT;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		if ((clk_ctl & SGTL5000_MCLK_FREQ_MASK) !=
+		    SGTL5000_MCLK_FREQ_256FS
+		    ||
+		    sgtl5000->fmt == SND_SOC_DAIFMT_RIGHT_J)
+			return -EINVAL;
+		i2s_ctl |= SGTL5000_I2S_DLEN_32 << SGTL5000_I2S_DLEN_SHIFT;
+		i2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<
+			   SGTL5000_I2S_SCLKFREQ_SHIFT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pr_debug("fs=%d,clk_ctl=%d,pll_ctl=%d,i2s_ctl=%d,div2=%d\n",
+		 fs, clk_ctl, pll_ctl, i2s_ctl, div2);
+
+	if ((clk_ctl & SGTL5000_MCLK_FREQ_MASK) == SGTL5000_MCLK_FREQ_PLL) {
+		sgtl5000_write(codec, SGTL5000_CHIP_PLL_CTRL, pll_ctl);
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_CLK_TOP_CTRL);
+		if (div2)
+			reg |= SGTL5000_INPUT_FREQ_DIV2;
+		else
+			reg &= ~SGTL5000_INPUT_FREQ_DIV2;
+		sgtl5000_write(codec, SGTL5000_CHIP_CLK_TOP_CTRL, reg);
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		reg |= SGTL5000_PLL_POWERUP | SGTL5000_VCOAMP_POWERUP; /*vco?*/
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+	}
+	sgtl5000_write(codec, SGTL5000_CHIP_CLK_CTRL, clk_ctl);
+	sgtl5000_write(codec, SGTL5000_CHIP_I2S_CTRL, i2s_ctl);
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_DIG_POWER);
+	reg |= SGTL5000_I2S_IN_POWERUP | SGTL5000_I2S_OUT_POWERUP;
+	sgtl5000_write(codec, SGTL5000_CHIP_DIG_POWER, reg);
+	return 0;
+}
+
+#define SGTL5000_RATES (SNDRV_PCM_RATE_32000 |\
+		      SNDRV_PCM_RATE_44100 |\
+		      SNDRV_PCM_RATE_48000 |\
+		      SNDRV_PCM_RATE_96000)
+
+#define SGTL5000_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\
+			SNDRV_PCM_FMTBIT_S20_3LE |\
+			SNDRV_PCM_FMTBIT_S24_LE)
+
+static const struct snd_soc_pcm_stream sgtl5000_dai_playback = {
+	.stream_name = "Playback",
+	.channels_min = 1,
+	.channels_max = 2,
+	.rates = SGTL5000_RATES,
+	.formats = SGTL5000_FORMATS,
+};
+
+static const struct snd_soc_pcm_stream sgtl5000_dai_capture = {
+	.stream_name = "Capture",
+	.channels_min = 1,
+	.channels_max = 1,
+	.rates = SGTL5000_RATES,
+	.formats = SGTL5000_FORMATS,
+};
+
+/* audio ops, called by alsa */
+static const struct snd_soc_ops sgtl5000_dai_audio_ops = {
+	.startup = sgtl5000_pcm_startup,
+	.shutdown = sgtl5000_pcm_shutdown,
+	.hw_params = sgtl5000_pcm_hw_params,
+};
+
+static int sgtl5000_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	u16 reg;
+	pr_debug("dapm event %d\n", event);
+	switch (event) {
+	case SNDRV_CTL_POWER_D0:	/* full On */
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		reg |= SGTL5000_HP_POWERUP;
+		reg |= SGTL5000_LINE_OUT_POWERUP;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+
+
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_MIC_CTRL);
+		reg &= ~SGTL5000_BIAS_R_MASK;
+		reg |= SGTL5000_BIAS_R_4k << SGTL5000_BIAS_R_SHIFT;
+		sgtl5000_write(codec, SGTL5000_CHIP_MIC_CTRL, reg);
+
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_CTRL);
+		reg |= SGTL5000_HP_ZCD_EN;
+		reg |= SGTL5000_ADC_ZCD_EN;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_CTRL, reg);
+		break;
+
+	case SNDRV_CTL_POWER_D1:	/* partial On */
+	case SNDRV_CTL_POWER_D2:	/* partial On */
+		break;
+
+	case SNDRV_CTL_POWER_D3hot:	/* Off, with power */
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_MIC_CTRL);
+		reg &= ~SGTL5000_BIAS_R_MASK;
+		reg |= SGTL5000_BIAS_R_off;
+		sgtl5000_write(codec, SGTL5000_CHIP_MIC_CTRL, reg);
+
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_CTRL);
+		reg &= ~SGTL5000_HP_ZCD_EN;
+		reg &= ~SGTL5000_ADC_ZCD_EN;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_CTRL, reg);
+
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		if (codec->dapm_state == SNDRV_CTL_POWER_D3cold) {
+			reg |= SGTL5000_VAG_POWERUP;
+			reg |= SGTL5000_REFTOP_POWERUP;
+			reg |= SGTL5000_DAC_POWERUP;
+			reg |= SGTL5000_ADC_POWERUP;
+		}
+		/*reg &= ~SGTL5000_PLL_POWERUP;
+		reg &= ~SGTL5000_VCOAMP_POWERUP;*/
+		reg &= ~SGTL5000_HP_POWERUP;
+		reg &= ~SGTL5000_CAPLESS_HP_POWERUP;
+		reg &= ~SGTL5000_LINE_OUT_POWERUP;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+
+		msleep(400);
+
+		break;
+
+	case SNDRV_CTL_POWER_D3cold:	/* Off, without power */
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		reg &= ~SGTL5000_VAG_POWERUP;
+		reg &= ~SGTL5000_REFTOP_POWERUP;
+		reg &= ~SGTL5000_DAC_POWERUP;
+		reg &= ~SGTL5000_ADC_POWERUP;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+		break;
+	}
+
+	codec->dapm_state = event;
+
+	return 0;
+}
+
+static int sgtl5000_suspend(struct device *dev, pm_message_t state)
+{
+	struct snd_soc_codec *codec = to_snd_soc_codec(dev);
+
+	sgtl5000_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+
+	return 0;
+}
+
+static int sgtl5000_resume(struct device *dev)
+{
+	struct snd_soc_codec *codec = to_snd_soc_codec(dev);
+
+	/* Bring the codec back up to standby first to minimise pop/clicks */
+	sgtl5000_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	sgtl5000_dapm_event(codec, codec->suspend_dapm_state);
+
+	return 0;
+}
+
+static int sgtl5000_codec_io_probe(struct snd_soc_codec *codec,
+				 struct snd_soc_machine *machine)
+{
+	u16 reg, ana_pwr, lreg_ctrl, ref_ctrl, lo_ctrl, short_ctrl, sss;
+	int vag;
+	struct sgtl5000_platform_data *plat = codec->platform_data;
+
+	/* reset value */
+	ana_pwr = SGTL5000_DAC_STERO |
+		  SGTL5000_LINREG_SIMPLE_POWERUP |
+		  SGTL5000_STARTUP_POWERUP |
+		  SGTL5000_ADC_STERO |
+		  SGTL5000_REFTOP_POWERUP;
+	lreg_ctrl = 0;
+	ref_ctrl = 0;
+	lo_ctrl = 0;
+	short_ctrl = 0;
+	sss = SGTL5000_DAC_SEL_I2S_IN << SGTL5000_DAC_SEL_SHIFT;
+
+	if (!plat->vddd) {
+		/* set VDDD to 1.2v */
+		lreg_ctrl |= 0x8 << SGTL5000_LINREG_VDDD_SHIFT;
+		/* power internal linear regulator */
+		ana_pwr |= SGTL5000_LINEREG_D_POWERUP;
+	} else {
+		/* turn of startup power */
+		ana_pwr &= ~SGTL5000_STARTUP_POWERUP;
+		ana_pwr &= ~SGTL5000_LINREG_SIMPLE_POWERUP;
+	}
+	if (plat->vddio < 3100 && plat->vdda < 3100) {
+		/* Enable VDDC charge pump */
+		ana_pwr |= SGTL5000_VDDC_CHRGPMP_POWERUP;
+	}
+	if (plat->vddio >= 3100 && plat->vdda >= 3100) {
+		/* VDDC use VDDIO rail */
+		lreg_ctrl |= SGTL5000_VDDC_ASSN_OVRD;
+		if (plat->vddio >= 3100)
+			lreg_ctrl |= SGTL5000_VDDC_MAN_ASSN_VDDIO <<
+				     SGTL5000_VDDC_MAN_ASSN_SHIFT;
+	}
+
+	/* set ADC/DAC ref voltage to vdda/2 */
+	vag = plat->vdda/2;
+	if (vag <= SGTL5000_ANA_GND_BASE)
+		vag = 0;
+	else if (vag >= SGTL5000_ANA_GND_BASE + SGTL5000_ANA_GND_STP *
+		 (SGTL5000_ANA_GND_MASK >> SGTL5000_ANA_GND_SHIFT))
+		vag = SGTL5000_ANA_GND_MASK >> SGTL5000_ANA_GND_SHIFT;
+	else
+		vag = (vag - SGTL5000_ANA_GND_BASE) / SGTL5000_ANA_GND_STP;
+	ref_ctrl |= vag << SGTL5000_ANA_GND_SHIFT;
+
+	/* set line out ref voltage to vddio/2 */
+	vag = plat->vddio/2;
+	if (vag <= SGTL5000_LINE_OUT_GND_BASE)
+		vag = 0;
+	else if (vag >= SGTL5000_LINE_OUT_GND_BASE + SGTL5000_LINE_OUT_GND_STP *
+		 SGTL5000_LINE_OUT_GND_MAX)
+		vag = SGTL5000_LINE_OUT_GND_MAX;
+	else
+		vag = (vag - SGTL5000_LINE_OUT_GND_BASE) /
+		      SGTL5000_LINE_OUT_GND_STP;
+	lo_ctrl |= vag << SGTL5000_LINE_OUT_GND_SHIFT;
+
+	/* enable small pop */
+	ref_ctrl |= SGTL5000_SMALL_POP;
+
+	/* set short detect */
+	/* keep default */
+
+	/* set routing */
+	/* keep default, bypass DAP */
+
+	sgtl5000_write(codec, SGTL5000_CHIP_LINREG_CTRL, lreg_ctrl);
+	sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, ana_pwr);
+	msleep(10);
+	sgtl5000_write(codec, SGTL5000_CHIP_REF_CTRL, ref_ctrl);
+	sgtl5000_write(codec, SGTL5000_CHIP_LINE_OUT_CTRL, lo_ctrl);
+	sgtl5000_write(codec, SGTL5000_CHIP_SHORT_CTRL, short_ctrl);
+	sgtl5000_write(codec, SGTL5000_CHIP_SSS_CTRL, sss);
+	sgtl5000_write(codec, SGTL5000_CHIP_DIG_POWER, 0);
+
+	reg = SGTL5000_DAC_VOL_RAMP_EN |
+	      SGTL5000_DAC_MUTE_RIGHT |
+	      SGTL5000_DAC_MUTE_LEFT;
+	sgtl5000_write(codec, SGTL5000_CHIP_ADCDAC_CTRL, reg);
+
+	sgtl5000_write(codec, SGTL5000_CHIP_PAD_STRENGTH, 0x015f);
+
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_ADC_CTRL);
+	reg &= ~SGTL5000_ADC_VOL_M6DB;
+	sgtl5000_write(codec, SGTL5000_CHIP_ANA_ADC_CTRL, reg);
+
+	reg = SGTL5000_LINE_OUT_MUTE |
+	      SGTL5000_HP_MUTE |
+	      SGTL5000_ADC_MUTE;
+	sgtl5000_write(codec, SGTL5000_CHIP_ANA_CTRL, reg);
+
+	sgtl5000_write(codec, SGTL5000_CHIP_MIC_CTRL, 0);
+	sgtl5000_write(codec, SGTL5000_CHIP_CLK_TOP_CTRL, 0);
+	/* disable DAP */
+	sgtl5000_write(codec, SGTL5000_DAP_CTRL, 0);
+	/* TODO: initialize DAP */
+
+	sgtl5000_add_controls(codec, machine->card);
+	sgtl5000_add_widgets(codec, machine);
+
+	codec->dapm_state = SNDRV_CTL_POWER_D3cold;
+	sgtl5000_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	return 0;
+}
+
+static int sgtl5000_codec_io_remove(struct snd_soc_codec *codec,
+				  struct snd_soc_machine *machine)
+{
+	if (codec->dapm_state != SNDRV_CTL_POWER_D3hot)
+		sgtl5000_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	sgtl5000_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static const struct snd_soc_codec_ops sgtl5000_codec_ops = {
+	.dapm_event = sgtl5000_dapm_event,
+	.read = sgtl5000_read,
+	.write = sgtl5000_write,
+	.io_probe = sgtl5000_codec_io_probe,
+	.io_remove = sgtl5000_codec_io_remove,
+};
+
+static int sgtl5000_codec_probe(struct device *dev)
+{
+	struct snd_soc_codec *codec = to_snd_soc_codec(dev);
+	struct sgtl5000_priv *sgtl5000;
+	u16 val;
+
+	codec->owner = THIS_MODULE;
+	codec->ops = &sgtl5000_codec_ops;
+
+	sgtl5000 = kzalloc(sizeof(struct sgtl5000_priv), GFP_KERNEL);
+	if (sgtl5000 == NULL)
+		return -ENOMEM;
+	codec->private_data = sgtl5000;
+
+	snd_soc_register_codec(codec);
+
+	val = sgtl5000_read(codec, SGTL5000_CHIP_ID);
+	dev_info(&sgtl5000_i2c_client->dev, "SGTL5000 revision %d\n",
+		 (val & SGTL5000_REVID_MASK) >> SGTL5000_REVID_SHIFT);
+
+	return 0;
+}
+
+static int sgtl5000_codec_remove(struct device *dev)
+{
+	struct snd_soc_codec *codec = to_snd_soc_codec(dev);
+	kfree(codec->private_data);
+	return 0;
+}
+
+static int sgtl5000_dai_probe(struct device *dev)
+{
+	struct snd_soc_dai *dai = to_snd_soc_dai(dev);
+
+	dai->ops = &sgtl5000_dai_ops;
+	dai->audio_ops = &sgtl5000_dai_audio_ops;
+	dai->capture = &sgtl5000_dai_capture;
+	dai->playback = &sgtl5000_dai_playback;
+	snd_soc_register_codec_dai(dai);
+
+	return 0;
+}
+
+const char sgtl5000_codec[SND_SOC_CODEC_NAME_SIZE] = "sgtl5000-codec";
+EXPORT_SYMBOL_GPL(sgtl5000_codec);
+
+static struct snd_soc_device_driver sgtl5000_codec_driver = {
+	.type = SND_SOC_BUS_TYPE_CODEC,
+	.driver = {
+		   .name = sgtl5000_codec,
+		   .owner = THIS_MODULE,
+		   .bus = &asoc_bus_type,
+		   .probe = sgtl5000_codec_probe,
+		   .remove = __devexit_p(sgtl5000_codec_remove),
+		   .suspend = sgtl5000_suspend,
+		   .resume = sgtl5000_resume,
+		   },
+};
+
+const char sgtl5000_dai[SND_SOC_CODEC_NAME_SIZE] = "sgtl5000-dai";
+EXPORT_SYMBOL_GPL(sgtl5000_dai);
+
+static struct snd_soc_device_driver sgtl5000_dai_driver = {
+	.type = SND_SOC_BUS_TYPE_DAI,
+	.driver = {
+		   .name = sgtl5000_dai,
+		   .owner = THIS_MODULE,
+		   .bus = &asoc_bus_type,
+		   .probe = sgtl5000_dai_probe,
+		   },
+};
+
+static int sgtl5000_i2c_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	int ret;
+
+	sgtl5000_i2c_client = client;
+
+	ret = driver_register(&sgtl5000_codec_driver.driver);
+	if (ret < 0)
+		return ret;
+
+	ret = driver_register(&sgtl5000_dai_driver.driver);
+	if (ret < 0) {
+		driver_unregister(&sgtl5000_codec_driver.driver);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int sgtl5000_i2c_remove(struct i2c_client *client)
+{
+	driver_unregister(&sgtl5000_dai_driver.driver);
+	driver_unregister(&sgtl5000_codec_driver.driver);
+
+	return 0;
+}
+
+static const struct i2c_device_id sgtl5000_id[] = {
+	{ "sgtl5000-i2c", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, sgtl5000_id);
+
+static struct i2c_driver sgtl5000_i2c_driver = {
+	.driver = {
+		   .name = "sgtl5000-i2c",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = sgtl5000_i2c_probe,
+	.remove = sgtl5000_i2c_remove,
+	.id_table = sgtl5000_id,
+};
+
+static __init int sgtl5000_init(void)
+{
+	int ret = 0;
+
+	ret = i2c_add_driver(&sgtl5000_i2c_driver);
+	if (ret) {
+		pr_err("sgtl5000 i2c driver register failed");
+		return ret;
+	}
+
+	return ret;
+}
+
+static __exit void sgtl5000_exit(void)
+{
+	i2c_del_driver(&sgtl5000_i2c_driver);
+}
+
+
+subsys_initcall(sgtl5000_init);
+module_exit(sgtl5000_exit);
+
+MODULE_DESCRIPTION("ASoC SGTL5000 driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/sgtl5000.h b/sound/soc/codecs/sgtl5000.h
new file mode 100644
index 0000000..b8b8d08
--- /dev/null
+++ b/sound/soc/codecs/sgtl5000.h
@@ -0,0 +1,396 @@
+/*
+ * sgtl5000.h - SGTL5000 audio codec interface
+ *
+ * Copyright 2008 Freescale Semiconductor, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#ifndef _SGTL5000_H
+#define _SGTL5000_H
+
+/*
+ * Register values.
+ */
+#define SGTL5000_CHIP_ID			0x0000
+#define SGTL5000_CHIP_DIG_POWER			0x0002
+#define SGTL5000_CHIP_CLK_CTRL			0x0004
+#define SGTL5000_CHIP_I2S_CTRL			0x0006
+#define SGTL5000_CHIP_SSS_CTRL			0x000a
+#define SGTL5000_CHIP_ADCDAC_CTRL		0x000e
+#define SGTL5000_CHIP_DAC_VOL			0x0010
+#define SGTL5000_CHIP_PAD_STRENGTH		0x0014
+#define SGTL5000_CHIP_ANA_ADC_CTRL		0x0020
+#define SGTL5000_CHIP_ANA_HP_CTRL		0x0022
+#define SGTL5000_CHIP_ANA_CTRL			0x0024
+#define SGTL5000_CHIP_LINREG_CTRL		0x0026
+#define SGTL5000_CHIP_REF_CTRL			0x0028
+#define SGTL5000_CHIP_MIC_CTRL			0x002a
+#define SGTL5000_CHIP_LINE_OUT_CTRL		0x002c
+#define SGTL5000_CHIP_LINE_OUT_VOL		0x002e
+#define SGTL5000_CHIP_ANA_POWER			0x0030
+#define SGTL5000_CHIP_PLL_CTRL			0x0032
+#define SGTL5000_CHIP_CLK_TOP_CTRL		0x0034
+#define SGTL5000_CHIP_ANA_STATUS		0x0036
+#define SGTL5000_CHIP_SHORT_CTRL		0x003c
+#define SGTL5000_DAP_CTRL			0x0100
+#define SGTL5000_DAP_PEQ			0x0102
+#define SGTL5000_DAP_BASS_ENHANCE		0x0104
+#define SGTL5000_DAP_BASS_ENHANCE_CTRL		0x0106
+#define SGTL5000_DAP_AUDIO_EQ			0x0108
+#define SGTL5000_DAP_SURROUND			0x010a
+#define SGTL5000_DAP_FLT_COEF_ACCESS		0x010c
+#define SGTL5000_DAP_COEF_WR_B0_MSB		0x010e
+#define SGTL5000_DAP_COEF_WR_B0_LSB		0x0110
+#define SGTL5000_DAP_EQ_BASS_BAND0		0x0116
+#define SGTL5000_DAP_EQ_BASS_BAND1		0x0118
+#define SGTL5000_DAP_EQ_BASS_BAND2		0x011a
+#define SGTL5000_DAP_EQ_BASS_BAND3		0x011c
+#define SGTL5000_DAP_EQ_BASS_BAND4		0x011e
+#define SGTL5000_DAP_MAIN_CHAN			0x0120
+#define SGTL5000_DAP_MIX_CHAN			0x0122
+#define SGTL5000_DAP_AVC_CTRL			0x0124
+#define SGTL5000_DAP_AVC_THRESHOLD		0x0126
+#define SGTL5000_DAP_AVC_ATTACK			0x0128
+#define SGTL5000_DAP_AVC_DECAY			0x012a
+#define SGTL5000_DAP_COEF_WR_B1_MSB		0x012c
+#define SGTL5000_DAP_COEF_WR_B1_LSB		0x012e
+#define SGTL5000_DAP_COEF_WR_B2_MSB		0x0130
+#define SGTL5000_DAP_COEF_WR_B2_LSB		0x0132
+#define SGTL5000_DAP_COEF_WR_A1_MSB		0x0134
+#define SGTL5000_DAP_COEF_WR_A1_LSB		0x0136
+#define SGTL5000_DAP_COEF_WR_A2_MSB		0x0138
+#define SGTL5000_DAP_COEF_WR_A2_LSB		0x013a
+
+#define WM8903_REGISTER_COUNT			49
+#define WM8903_MAX_REGISTER			0x013a
+
+/*
+ * Field Definitions.
+ */
+
+/*
+ * SGTL5000_CHIP_ID
+ */
+#define SGTL5000_PARTID_MASK			0xff00
+#define SGTL5000_PARTID_SHIFT			8
+#define SGTL5000_PARTID_WIDTH			8
+#define SGTL5000_REVID_MASK			0x00ff
+#define SGTL5000_REVID_SHIFT			0
+#define SGTL5000_REVID_WIDTH			8
+
+/*
+ * SGTL5000_CHIP_DIG_POWER
+ */
+#define SGTL5000_ADC_EN				0x0040
+#define SGTL5000_DAC_EN				0x0020
+#define SGTL5000_DAP_POWERUP			0x0010
+#define SGTL5000_I2S_OUT_POWERUP		0x0002
+#define SGTL5000_I2S_IN_POWERUP			0x0001
+
+/*
+ * SGTL5000_CHIP_CLK_CTRL
+ */
+#define SGTL5000_SYS_FS_MASK			0x00c0
+#define SGTL5000_SYS_FS_SHIFT			2
+#define SGTL5000_SYS_FS_WIDTH			2
+#define SGTL5000_SYS_FS_32k			0x0
+#define SGTL5000_SYS_FS_44_1k			0x1
+#define SGTL5000_SYS_FS_48k			0x2
+#define SGTL5000_SYS_FS_96k			0x3
+#define SGTL5000_MCLK_FREQ_MASK			0x0003
+#define SGTL5000_MCLK_FREQ_SHIFT		0
+#define SGTL5000_MCLK_FREQ_WIDTH		2
+#define SGTL5000_MCLK_FREQ_256FS		0x0
+#define SGTL5000_MCLK_FREQ_384FS		0x1
+#define SGTL5000_MCLK_FREQ_512FS		0x2
+#define SGTL5000_MCLK_FREQ_PLL			0x3
+
+/*
+ * SGTL5000_CHIP_I2S_CTRL
+ */
+#define SGTL5000_I2S_SCLKFREQ_MASK		0x0100
+#define SGTL5000_I2S_SCLKFREQ_SHIFT		8
+#define SGTL5000_I2S_SCLKFREQ_WIDTH		1
+#define SGTL5000_I2S_SCLKFREQ_64FS		0x0
+#define SGTL5000_I2S_SCLKFREQ_32FS		0x1 /* Not for RJ mode */
+#define SGTL5000_I2S_MASTER			0x0080
+#define SGTL5000_I2S_SCLK_INV			0x0040
+#define SGTL5000_I2S_DLEN_MASK			0x0030
+#define SGTL5000_I2S_DLEN_SHIFT			4
+#define SGTL5000_I2S_DLEN_WIDTH			2
+#define SGTL5000_I2S_DLEN_32			0x0
+#define SGTL5000_I2S_DLEN_24			0x1
+#define SGTL5000_I2S_DLEN_20			0x2
+#define SGTL5000_I2S_DLEN_16			0x3
+#define SGTL5000_I2S_MODE_MASK			0x000c
+#define SGTL5000_I2S_MODE_SHIFT			2
+#define SGTL5000_I2S_MODE_WIDTH			2
+#define SGTL5000_I2S_MODE_I2S_LJ		0x0
+#define SGTL5000_I2S_MODE_RJ			0x1
+#define SGTL5000_I2S_MODE_PCM			0x2
+#define SGTL5000_I2S_LRALIGN			0x0002
+#define SGTL5000_I2S_LRPOL			0x0001 /* set for which mode */
+
+/*
+ * SGTL5000_CHIP_SSS_CTRL
+ */
+#define SGTL5000_DAP_MIX_LRSWAP			0x4000
+#define SGTL5000_DAP_LRSWAP			0x2000
+#define SGTL5000_DAC_LRSWAP			0x1000
+#define SGTL5000_I2S_OUT_LRSWAP			0x0400
+#define SGTL5000_DAP_MIX_SEL_MASK		0x0300
+#define SGTL5000_DAP_MIX_SEL_SHIFT		8
+#define SGTL5000_DAP_MIX_SEL_WIDTH		2
+#define SGTL5000_DAP_MIX_SEL_ADC		0x0
+#define SGTL5000_DAP_MIX_SEL_I2S_IN		0x1
+#define SGTL5000_DAP_SEL_MASK			0x00c0
+#define SGTL5000_DAP_SEL_SHIFT			6
+#define SGTL5000_DAP_SEL_WIDTH			2
+#define SGTL5000_DAP_SEL_ADC			0x0
+#define SGTL5000_DAP_SEL_I2S_IN			0x1
+#define SGTL5000_DAC_SEL_MASK			0x0030
+#define SGTL5000_DAC_SEL_SHIFT			4
+#define SGTL5000_DAC_SEL_WIDTH			2
+#define SGTL5000_DAC_SEL_ADC			0x0
+#define SGTL5000_DAC_SEL_I2S_IN			0x1
+#define SGTL5000_DAC_SEL_DAP			0x3
+#define SGTL5000_I2S_OUT_SEL_MASK		0x0003
+#define SGTL5000_I2S_OUT_SEL_SHIFT		0
+#define SGTL5000_I2S_OUT_SEL_WIDTH		2
+#define SGTL5000_I2S_OUT_SEL_ADC		0x0
+#define SGTL5000_I2S_OUT_SEL_I2S_IN		0x1
+#define SGTL5000_I2S_OUT_SEL_DAP		0x3
+
+/*
+ * SGTL5000_CHIP_ADCDAC_CTRL
+ */
+#define SGTL5000_VOL_BUSY_DAC_RIGHT		0x2000
+#define SGTL5000_VOL_BUSY_DAC_LEFT		0x1000
+#define SGTL5000_DAC_VOL_RAMP_EN		0x0200
+#define SGTL5000_DAC_VOL_RAMP_EXPO		0x0100
+#define SGTL5000_DAC_MUTE_RIGHT			0x0008
+#define SGTL5000_DAC_MUTE_LEFT			0x0004
+#define SGTL5000_ADC_HPF_FREEZE			0x0002
+#define SGTL5000_ADC_HPF_BYPASS			0x0001
+
+/*
+ * SGTL5000_CHIP_DAC_VOL
+ */
+#define SGTL5000_DAC_VOL_RIGHT_MASK		0xff00
+#define SGTL5000_DAC_VOL_RIGHT_SHIFT		8
+#define SGTL5000_DAC_VOL_RIGHT_WIDTH		8
+#define SGTL5000_DAC_VOL_LEFT_MASK		0x00ff
+#define SGTL5000_DAC_VOL_LEFT_SHIFT		0
+#define SGTL5000_DAC_VOL_LEFT_WIDTH		8
+
+/*
+ * SGTL5000_CHIP_PAD_STRENGTH
+ */
+#define SGTL5000_PAD_I2S_LRCLK_MASK		0x0300
+#define SGTL5000_PAD_I2S_LRCLK_SHIFT		8
+#define SGTL5000_PAD_I2S_LRCLK_WIDTH		2
+#define SGTL5000_PAD_I2S_SCLK_MASK		0x00c0
+#define SGTL5000_PAD_I2S_SCLK_SHIFT		6
+#define SGTL5000_PAD_I2S_SCLK_WIDTH		2
+#define SGTL5000_PAD_I2S_DOUT_MASK		0x0030
+#define SGTL5000_PAD_I2S_DOUT_SHIFT		4
+#define SGTL5000_PAD_I2S_DOUT_WIDTH		2
+#define SGTL5000_PAD_I2C_SDA_MASK		0x000c
+#define SGTL5000_PAD_I2C_SDA_SHIFT		2
+#define SGTL5000_PAD_I2C_SDA_WIDTH		2
+#define SGTL5000_PAD_I2C_SCL_MASK		0x0003
+#define SGTL5000_PAD_I2C_SCL_SHIFT		0
+#define SGTL5000_PAD_I2C_SCL_WIDTH		2
+
+/*
+ * SGTL5000_CHIP_ANA_ADC_CTRL
+ */
+#define SGTL5000_ADC_VOL_M6DB			0x0100
+#define SGTL5000_ADC_VOL_RIGHT_MASK		0x00f0
+#define SGTL5000_ADC_VOL_RIGHT_SHIFT		4
+#define SGTL5000_ADC_VOL_RIGHT_WIDTH		4
+#define SGTL5000_ADC_VOL_LEFT_MASK		0x000f
+#define SGTL5000_ADC_VOL_LEFT_SHIFT		0
+#define SGTL5000_ADC_VOL_LEFT_WIDTH		4
+
+/*
+ * SGTL5000_CHIP_ANA_HP_CTRL
+ */
+#define SGTL5000_HP_VOL_RIGHT_MASK		0x7f00
+#define SGTL5000_HP_VOL_RIGHT_SHIFT		8
+#define SGTL5000_HP_VOL_RIGHT_WIDTH		7
+#define SGTL5000_HP_VOL_LEFT_MASK		0x007f
+#define SGTL5000_HP_VOL_LEFT_SHIFT		0
+#define SGTL5000_HP_VOL_LEFT_WIDTH		7
+
+/*
+ * SGTL5000_CHIP_ANA_CTRL
+ */
+#define SGTL5000_LINE_OUT_MUTE		0x0100
+#define SGTL5000_HP_SEL_MASK			0x0040
+#define SGTL5000_HP_SEL_SHIFT			6
+#define SGTL5000_HP_SEL_WIDTH			1
+#define SGTL5000_HP_SEL_DAC			0x0
+#define SGTL5000_HP_SEL_LINE_IN			0x1
+#define SGTL5000_HP_ZCD_EN			0x0020
+#define SGTL5000_HP_MUTE			0x0010
+#define SGTL5000_ADC_SEL_MASK			0x0004
+#define SGTL5000_ADC_SEL_SHIFT			2
+#define SGTL5000_ADC_SEL_WIDTH			1
+#define SGTL5000_ADC_SEL_MIC			0x0
+#define SGTL5000_ADC_SEL_LINE_IN		0x1
+#define SGTL5000_ADC_ZCD_EN			0x0002
+#define SGTL5000_ADC_MUTE			0x0001
+
+/*
+ * SGTL5000_CHIP_LINREG_CTRL
+ */
+#define SGTL5000_VDDC_MAN_ASSN_MASK		0x0040
+#define SGTL5000_VDDC_MAN_ASSN_SHIFT		6
+#define SGTL5000_VDDC_MAN_ASSN_WIDTH		1
+#define SGTL5000_VDDC_MAN_ASSN_VDDA		0x0
+#define SGTL5000_VDDC_MAN_ASSN_VDDIO		0x1
+#define SGTL5000_VDDC_ASSN_OVRD			0x0020
+#define SGTL5000_LINREG_VDDD_MASK		0x000f
+#define SGTL5000_LINREG_VDDD_SHIFT		0
+#define SGTL5000_LINREG_VDDD_WIDTH		4
+
+/*
+ * SGTL5000_CHIP_REF_CTRL
+ */
+#define SGTL5000_ANA_GND_MASK			0x01f0
+#define SGTL5000_ANA_GND_SHIFT			4
+#define SGTL5000_ANA_GND_WIDTH			5
+#define SGTL5000_ANA_GND_BASE			800 /* mv */
+#define SGTL5000_ANA_GND_STP			25 /*mv */
+#define SGTL5000_BIAS_CTRL_MASK			0x000e
+#define SGTL5000_BIAS_CTRL_SHIFT		1
+#define SGTL5000_BIAS_CTRL_WIDTH		3
+#define SGTL5000_SMALL_POP			0x0001
+
+/*
+ * SGTL5000_CHIP_MIC_CTRL
+ */
+#define SGTL5000_BIAS_R_MASK			0x0200
+#define SGTL5000_BIAS_R_SHIFT			8
+#define SGTL5000_BIAS_R_WIDTH			2
+#define SGTL5000_BIAS_R_off			0x0
+#define SGTL5000_BIAS_R_2K			0x1
+#define SGTL5000_BIAS_R_4k			0x2
+#define SGTL5000_BIAS_R_8k			0x3
+#define SGTL5000_BIAS_VOLT_MASK			0x0070
+#define SGTL5000_BIAS_VOLT_SHIFT		4
+#define SGTL5000_BIAS_VOLT_WIDTH		3
+#define SGTL5000_MIC_GAIN_MASK			0x0003
+#define SGTL5000_MIC_GAIN_SHIFT			0
+#define SGTL5000_MIC_GAIN_WIDTH			2
+
+/*
+ * SGTL5000_CHIP_LINE_OUT_CTRL
+ */
+#define SGTL5000_LINE_OUT_CURRENT_MASK		0x0f00
+#define SGTL5000_LINE_OUT_CURRENT_SHIFT		8
+#define SGTL5000_LINE_OUT_CURRENT_WIDTH		4
+#define SGTL5000_LINE_OUT_CURRENT_180u		0x0
+#define SGTL5000_LINE_OUT_CURRENT_270u		0x1
+#define SGTL5000_LINE_OUT_CURRENT_360u		0x3
+#define SGTL5000_LINE_OUT_CURRENT_450u		0x7
+#define SGTL5000_LINE_OUT_CURRENT_540u		0xf
+#define SGTL5000_LINE_OUT_GND_MASK		0x003f
+#define SGTL5000_LINE_OUT_GND_SHIFT		0
+#define SGTL5000_LINE_OUT_GND_WIDTH		6
+#define SGTL5000_LINE_OUT_GND_BASE		800 /* mv */
+#define SGTL5000_LINE_OUT_GND_STP		25
+#define SGTL5000_LINE_OUT_GND_MAX		0x23
+
+/*
+ * SGTL5000_CHIP_LINE_OUT_VOL
+ */
+#define SGTL5000_LINE_OUT_VOL_RIGHT_MASK	0x1f00
+#define SGTL5000_LINE_OUT_VOL_RIGHT_SHIFT	8
+#define SGTL5000_LINE_OUT_VOL_RIGHT_WIDTH	5
+#define SGTL5000_LINE_OUT_VOL_LEFT_MASK		0x001f
+#define SGTL5000_LINE_OUT_VOL_LEFT_SHIFT	0
+#define SGTL5000_LINE_OUT_VOL_LEFT_WIDTH	5
+
+/*
+ * SGTL5000_CHIP_ANA_POWER
+ */
+#define SGTL5000_DAC_STERO			0x4000
+#define SGTL5000_LINREG_SIMPLE_POWERUP		0x2000
+#define SGTL5000_STARTUP_POWERUP		0x1000
+#define SGTL5000_VDDC_CHRGPMP_POWERUP		0x0800
+#define SGTL5000_PLL_POWERUP			0x0400
+#define SGTL5000_LINEREG_D_POWERUP		0x0200
+#define SGTL5000_VCOAMP_POWERUP			0x0100
+#define SGTL5000_VAG_POWERUP			0x0080
+#define SGTL5000_ADC_STERO			0x0040
+#define SGTL5000_REFTOP_POWERUP			0x0020
+#define SGTL5000_HP_POWERUP			0x0010
+#define SGTL5000_DAC_POWERUP			0x0008
+#define SGTL5000_CAPLESS_HP_POWERUP		0x0004
+#define SGTL5000_ADC_POWERUP			0x0002
+#define SGTL5000_LINE_OUT_POWERUP		0x0001
+
+/*
+ * SGTL5000_CHIP_PLL_CTRL
+ */
+#define SGTL5000_PLL_INT_DIV_MASK		0xf800
+#define SGTL5000_PLL_INT_DIV_SHIFT		11
+#define SGTL5000_PLL_INT_DIV_WIDTH		5
+#define SGTL5000_PLL_FRAC_DIV_MASK		0x0700
+#define SGTL5000_PLL_FRAC_DIV_SHIFT		0
+#define SGTL5000_PLL_FRAC_DIV_WIDTH		11
+
+/*
+ * SGTL5000_CHIP_CLK_TOP_CTRL
+ */
+#define SGTL5000_INT_OSC_EN			0x0800
+#define SGTL5000_INPUT_FREQ_DIV2		0x0008
+
+/*
+ * SGTL5000_CHIP_ANA_STATUS
+ */
+#define SGTL5000_HP_LRSHORT			0x0200
+#define SGTL5000_CAPLESS_SHORT			0x0100
+#define SGTL5000_PLL_LOCKED			0x0010
+
+/*
+ * SGTL5000_CHIP_SHORT_CTRL
+ */
+#define SGTL5000_LVLADJR_MASK			0x7000
+#define SGTL5000_LVLADJR_SHIFT			12
+#define SGTL5000_LVLADJR_WIDTH			3
+#define SGTL5000_LVLADJL_MASK			0x0700
+#define SGTL5000_LVLADJL_SHIFT			8
+#define SGTL5000_LVLADJL_WIDTH			3
+#define SGTL5000_LVLADJC_MASK			0x0070
+#define SGTL5000_LVLADJC_SHIFT			4
+#define SGTL5000_LVLADJC_WIDTH			3
+#define SGTL5000_LR_SHORT_MOD_MASK		0x000c
+#define SGTL5000_LR_SHORT_MOD_SHIFT		2
+#define SGTL5000_LR_SHORT_MOD_WIDTH		2
+#define SGTL5000_CM_SHORT_MOD_MASK		0x0003
+#define SGTL5000_CM_SHORT_MOD_SHIFT		0
+#define SGTL5000_CM_SHORT_MOD_WIDTH		2
+
+/*
+ * SGTL5000_DAP_CTRL
+ */
+#define SGTL5000_DAP_MIX_EN			0x0010
+#define SGTL5000_DAP_EN				0x0001
+
+
+struct sgtl5000_platform_data {
+	int vddio;	/* voltage of VDDIO (mv) */
+	int vdda;	/* voltage of vdda (mv) */
+	int vddd;	/* voldtage of vddd (mv), zero if not connected */
+};
+
+extern const char sgtl5000_codec[SND_SOC_CODEC_NAME_SIZE];
+extern const char sgtl5000_dai[SND_SOC_CODEC_NAME_SIZE];
+#endif
diff --git a/sound/soc/imx/Kconfig b/sound/soc/imx/Kconfig
index c198c18..bb43200 100644
--- a/sound/soc/imx/Kconfig
+++ b/sound/soc/imx/Kconfig
@@ -50,3 +50,11 @@ config SND_SOC_IMX_3STACK_WM8903
  help
    Say Y if you want to add support for Soc audio on IMX 3STACK
    with the WM8903
+
+config SND_SOC_IMX_3STACK_SGTL5000
+ tristate "SoC Audio support for IMX - SGTL5000"
+ select SND_MXC_SOC_SSI
+ select SND_SOC_SGTL5000
+ help
+   Say Y if you want to add support for SoC audio on IMX 3STACK
+   with the SGTL5000.
diff --git a/sound/soc/imx/Makefile b/sound/soc/imx/Makefile
index 3d0653c..09abba3 100644
--- a/sound/soc/imx/Makefile
+++ b/sound/soc/imx/Makefile
@@ -15,4 +15,6 @@ obj-$(CONFIG_SND_SOC_IMX_3STACK_AK4647) += snd-soc-imx-3stack-ak4647.o
 snd-soc-imx-3stack-wm8580-objs := imx-3stack-wm8580.o
 obj-$(CONFIG_SND_SOC_IMX_3STACK_WM8580) += snd-soc-imx-3stack-wm8580.o
 snd-soc-imx-3stack-wm8903-objs := imx-3stack-wm8903.o
-obj-$(CONFIG_SND_SOC_IMX_3STACK_WM8903) += snd-soc-imx-3stack-wm8903.o
\ No newline at end of file
+obj-$(CONFIG_SND_SOC_IMX_3STACK_WM8903) += snd-soc-imx-3stack-wm8903.o
+snd-soc-imx-3stack-sgtl5000-objs := imx-3stack-sgtl5000.o
+obj-$(CONFIG_SND_SOC_IMX_3STACK_SGTL5000) += snd-soc-imx-3stack-sgtl5000.o
diff --git a/sound/soc/imx/imx-3stack-sgtl5000.c b/sound/soc/imx/imx-3stack-sgtl5000.c
new file mode 100644
index 0000000..f2e06d2
--- /dev/null
+++ b/sound/soc/imx/imx-3stack-sgtl5000.c
@@ -0,0 +1,679 @@
+/*
+ * imx-3stack-sgtl5000.c  --  i.MX 3Stack Driver for Freescale SGTL5000 Codec
+ *
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    21th Oct 2008   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/regulator.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/irq.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include <asm/gpio.h>
+#include <asm/arch/dma.h>
+#include <asm/arch/spba.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mxc.h>
+
+#include "../codecs/sgtl5000.h"
+#include "imx-ssi.h"
+#include "imx-pcm.h"
+
+void gpio_activate_audio_ports(void);
+
+/* SSI BCLK and LRC master */
+#define SGTL5000_SSI_MASTER	1
+
+struct imx_3stack_pcm_state {
+	int hw;
+	int playback_active;
+	int capture_active;
+};
+
+struct imx_3stack_priv {
+	struct regulator *reg_vddio;
+	struct regulator *reg_vdda;
+	struct regulator *reg_amp_gpo;
+};
+
+#if SGTL5000_SSI_MASTER
+static int imx_3stack_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_link *pcm_link = substream->private_data;
+	struct imx_3stack_pcm_state *state = pcm_link->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		state->capture_active = 1;
+	else
+		state->playback_active = 1;
+	return 0;
+}
+#else
+#define imx_3stack_startup NULL
+#endif
+
+static int imx_3stack_audio_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_link *pcm_link = substream->private_data;
+	struct snd_soc_dai *cpu_dai = pcm_link->cpu_dai;
+	struct snd_soc_dai *codec_dai = pcm_link->codec_dai;
+	struct imx_3stack_pcm_state *state = pcm_link->private_data;
+	unsigned int channels = params_channels(params);
+	u32 dai_format;
+
+	/* only need to do this once as capture and playback are sync */
+	if (state->hw)
+		return 0;
+	state->hw = 1;
+
+#if SGTL5000_SSI_MASTER
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	    SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_SYNC;
+	if (channels == 2)
+		dai_format |= SND_SOC_DAIFMT_TDM;
+
+	/* set codec DAI configuration */
+	codec_dai->ops->set_fmt(codec_dai, dai_format);
+
+	/* set cpu DAI configuration */
+	cpu_dai->ops->set_fmt(cpu_dai, dai_format);
+#else
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	    SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_SYNC;
+	if (channels == 2)
+		dai_format |= SND_SOC_DAIFMT_TDM;
+
+	/* set codec DAI configuration */
+	codec_dai->ops->set_fmt(codec_dai, dai_format);
+
+	/* set cpu DAI configuration */
+	cpu_dai->ops->set_fmt(cpu_dai, dai_format);
+#endif
+
+	/* set i.MX active slot mask */
+	cpu_dai->ops->set_tdm_slot(cpu_dai,
+				   channels == 1 ? 0xfffffffe : 0xfffffffc,
+				   channels);
+
+	/* set the SSI system clock as input (unused) */
+	cpu_dai->ops->set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0, SND_SOC_CLOCK_IN);
+
+	return 0;
+}
+
+static void imx_3stack_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_link *pcm_link = substream->private_data;
+	struct imx_3stack_pcm_state *state = pcm_link->private_data;
+
+	state->hw = 0;
+	/*
+	 * We need to keep track of active streams in master mode and
+	 * switch LRC source if necessary.
+	 */
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		state->capture_active = 0;
+	else
+		state->playback_active = 0;
+}
+
+/*
+ * imx_3stack SGTL5000 audio DAI opserations.
+ */
+static struct snd_soc_ops imx_3stack_audio_ops = {
+	.startup = imx_3stack_startup,
+	.shutdown = imx_3stack_shutdown,
+	.hw_params = imx_3stack_audio_hw_params,
+};
+
+static void imx_3stack_init_dam(int ssi_port, int dai_port)
+{
+	/* SGTL5000 uses SSI1 or SSI2 via AUDMUX port dai_port for audio */
+
+	/* reset port ssi_port & dai_port */
+	DAM_PTCR(ssi_port) = 0;
+	DAM_PDCR(ssi_port) = 0;
+	DAM_PTCR(dai_port) = 0;
+	DAM_PDCR(dai_port) = 0;
+
+	/* set to synchronous */
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_SYN;
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_SYN;
+
+#if SGTL5000_SSI_MASTER
+	/* set Rx sources ssi_port <--> dai_port */
+	DAM_PDCR(ssi_port) |= AUDMUX_PDCR_RXDSEL(dai_port);
+	DAM_PDCR(dai_port) |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+	/* set Tx frame direction and source  dai_port--> ssi_port output */
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TFSDIR;
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, dai_port);
+
+	/* set Tx Clock direction and source dai_port--> ssi_port output */
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TCLKDIR;
+	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, dai_port);
+#else
+	/* set Rx sources ssi_port <--> dai_port */
+	DAM_PDCR(ssi_port) |= AUDMUX_PDCR_RXDSEL(dai_port);
+	DAM_PDCR(dai_port) |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+	/* set Tx frame direction and source  ssi_port --> dai_port output */
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TFSDIR;
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, ssi_port);
+
+	/* set Tx Clock direction and source ssi_port--> dai_port output */
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TCLKDIR;
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, ssi_port);
+#endif
+
+}
+static int imx_3stack_pcm_new(struct snd_soc_pcm_link *pcm_link)
+{
+	struct imx_3stack_pcm_state *state;
+	int ret;
+
+	state = kzalloc(sizeof(struct imx_3stack_pcm_state), GFP_KERNEL);
+	if (state == NULL)
+		return -ENOMEM;
+
+	pcm_link->audio_ops = &imx_3stack_audio_ops;
+	pcm_link->private_data = state;
+
+	ret = snd_soc_pcm_new(pcm_link, 1, 1);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: failed to create audio pcm\n", __func__);
+		kfree(state);
+		return ret;
+	}
+
+	printk(KERN_INFO "i.MX 3STACK SGTL5000 Audio Driver");
+
+	return 0;
+}
+
+static int imx_3stack_pcm_free(struct snd_soc_pcm_link *pcm_link)
+{
+	kfree(pcm_link->private_data);
+	return 0;
+}
+
+static const struct snd_soc_pcm_link_ops imx_3stack_pcm_ops = {
+	.new = imx_3stack_pcm_new,
+	.free = imx_3stack_pcm_free,
+};
+
+/* imx_3stack machine dapm widgets */
+static const struct snd_soc_dapm_widget imx_3stack_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+	SND_SOC_DAPM_LINE("Line Out Jack", NULL),
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+};
+
+/* imx_3stack machine audio map */
+static const char *audio_map[][3] = {
+
+	/* Mic Jack --> MIC_IN (with automatic bias) */
+	{"MIC_IN", NULL, "Mic Jack"},
+
+	/* Line in Jack --> LINE_IN */
+	{"LINE_IN", NULL, "Line In Jack"},
+
+	/* HP_OUT --> Headphone Jack */
+	{"Headphone Jack", NULL, "HP_OUT"},
+
+	/* LINE_OUT --> Line Out Jack */
+	{"Line Out Jack", NULL, "LINE_OUT"},
+
+	{NULL, NULL, NULL},
+};
+
+
+
+#ifdef CONFIG_PM
+static int imx_3stack_sgtl5000_audio_suspend(struct platform_device *dev,
+					   pm_message_t state)
+{
+
+	int ret = 0;
+
+	return ret;
+}
+
+static int imx_3stack_sgtl5000_audio_resume(struct platform_device *dev)
+{
+
+	int ret = 0;
+
+	return ret;
+}
+
+#else
+#define imx_3stack_sgtl5000_audio_suspend	NULL
+#define imx_3stack_sgtl5000_audio_resume	NULL
+#endif
+
+static struct snd_soc_pcm_link *sgtl5000_3stack_pcm_link;
+static int sgtl5000_jack_func;
+static int sgtl5000_spk_func;
+
+static void headphone_detect_handler(struct work_struct *work)
+{
+	struct mxc_sgtl5000_platform_data *plat;
+	int hp_status;
+
+	sysfs_notify(&sgtl5000_3stack_pcm_link->machine->pdev->dev.kobj, NULL,
+		     "headphone");
+
+	plat = sgtl5000_3stack_pcm_link->machine->pdev->dev.platform_data;
+	hp_status = plat->hp_status();
+	if (hp_status)
+		set_irq_type(plat->hp_irq, IRQT_FALLING);
+	else
+		set_irq_type(plat->hp_irq, IRQT_RISING);
+	enable_irq(plat->hp_irq);
+}
+
+static DECLARE_DELAYED_WORK(hp_event, headphone_detect_handler);
+
+static irqreturn_t imx_headphone_detect_handler(int irq, void *data)
+{
+	disable_irq(irq);
+	schedule_delayed_work(&hp_event, msecs_to_jiffies(200));
+	return IRQ_HANDLED;
+}
+
+static ssize_t show_headphone(struct device_driver *dev, char *buf)
+{
+	u16 hp_status;
+	struct snd_soc_pcm_link *pcm_link;
+	struct snd_soc_codec *codec;
+	struct mxc_sgtl5000_platform_data *plat;
+
+	pcm_link = sgtl5000_3stack_pcm_link;
+	codec = pcm_link->codec;
+	plat = pcm_link->machine->pdev->dev.platform_data;
+
+	/* determine whether hp is plugged in */
+	hp_status = plat->hp_status();
+
+	if (hp_status == 0)
+		strcpy(buf, "speaker\n");
+	else
+		strcpy(buf, "headphone\n");
+
+	return strlen(buf);
+}
+
+static DRIVER_ATTR(headphone, S_IRUGO | S_IWUSR, show_headphone, NULL);
+
+static const char *jack_function[] = { "off", "on"
+};
+
+static const char *spk_function[] = { "off", "on" };
+
+static const struct soc_enum sgtl5000_enum[] = {
+	SOC_ENUM_SINGLE_EXT(2, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+};
+
+static int sgtl5000_get_jack(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = sgtl5000_jack_func;
+	return 0;
+}
+
+static int sgtl5000_set_jack(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_machine *machine = sgtl5000_3stack_pcm_link->machine;
+
+	if (sgtl5000_jack_func == ucontrol->value.enumerated.item[0])
+		return 0;
+
+	sgtl5000_jack_func = ucontrol->value.enumerated.item[0];
+	snd_soc_dapm_set_endpoint(machine, "Headphone Jack",
+				  sgtl5000_jack_func);
+	return 1;
+}
+
+static int sgtl5000_get_spk(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = sgtl5000_spk_func;
+	return 0;
+}
+
+static int sgtl5000_set_spk(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_machine *machine = sgtl5000_3stack_pcm_link->machine;
+
+	if (sgtl5000_spk_func == ucontrol->value.enumerated.item[0])
+		return 0;
+
+	sgtl5000_spk_func = ucontrol->value.enumerated.item[0];
+	snd_soc_dapm_set_endpoint(machine, "Line Out Jack", sgtl5000_spk_func);
+	return 1;
+}
+
+static const struct snd_kcontrol_new sgtl5000_machine_controls[] = {
+	SOC_ENUM_EXT("Jack Function", sgtl5000_enum[0], sgtl5000_get_jack,
+		     sgtl5000_set_jack),
+	SOC_ENUM_EXT("Speaker Function", sgtl5000_enum[1], sgtl5000_get_spk,
+		     sgtl5000_set_spk),
+};
+
+static int mach_probe(struct snd_soc_machine *machine)
+{
+	struct snd_soc_codec *codec;
+	struct snd_soc_dai *codec_dai;
+	struct snd_soc_pcm_link *pcm_link;
+	struct platform_device *pdev = machine->pdev;
+	struct mxc_sgtl5000_platform_data *plat = pdev->dev.platform_data;
+	struct sgtl5000_platform_data *codec_data;
+	struct imx_3stack_priv *priv;
+	struct regulator *reg;
+
+	int i, ret;
+
+	pcm_link = list_first_entry(&machine->active_list,
+				    struct snd_soc_pcm_link, active_list);
+	sgtl5000_3stack_pcm_link = pcm_link;
+
+	codec = pcm_link->codec;
+
+	codec_dai = pcm_link->codec_dai;
+	codec_dai->ops->set_sysclk(codec_dai, 0, plat->sysclk, 0);
+
+	priv = kzalloc(sizeof(struct imx_3stack_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	codec_data = kzalloc(sizeof(struct sgtl5000_platform_data), GFP_KERNEL);
+	if (!codec_data) {
+		ret = -ENOMEM;
+		goto err_codec_data;
+	}
+
+	ret = -EINVAL;
+	if (plat->vddio_reg) {
+		reg = regulator_get(&pdev->dev, plat->vddio_reg);
+		if (IS_ERR(reg))
+			goto err_reg_vddio;
+		priv->reg_vddio = reg;
+	}
+	reg = regulator_get(&pdev->dev, plat->vdda_reg);
+	if (IS_ERR(reg))
+		goto err_reg_vdda;
+	priv->reg_vdda = reg;
+	reg = regulator_get(&pdev->dev, plat->amp_gpo);
+	if (IS_ERR(reg))
+		goto err_reg_gpo;
+	priv->reg_amp_gpo = reg;
+	machine->platform_data = priv;
+
+	ret = regulator_set_voltage(priv->reg_vdda, plat->vdda);
+	regulator_enable(priv->reg_vdda);
+	if (priv->reg_vddio) {
+		regulator_set_voltage(priv->reg_vddio, plat->vddio);
+		regulator_enable(priv->reg_vddio);
+	}
+	regulator_enable(priv->reg_amp_gpo);
+
+	codec_data->vddio = plat->vddio / 1000; /* uV to mV */
+	codec_data->vdda = plat->vdda / 1000;
+	codec_data->vddd = plat->vddd / 1000;
+	codec->platform_data = codec_data;
+
+	codec->ops->io_probe(codec, machine);
+
+	/* Add imx_3stack specific widgets */
+	for (i = 0; i < ARRAY_SIZE(imx_3stack_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(machine, codec,
+					 &imx_3stack_dapm_widgets[i]);
+	}
+
+	/* set up imx_3stack specific audio path audio map */
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(machine, audio_map[i][0],
+					   audio_map[i][1], audio_map[i][2]);
+	}
+
+	/* connect and enable all imx_3stack SGTL5000 jacks (for now) */
+	snd_soc_dapm_set_endpoint(machine, "Line In Jack", 1);
+	snd_soc_dapm_set_endpoint(machine, "Mic Jack", 1);
+	snd_soc_dapm_set_endpoint(machine, "Line Out Jack", 1);
+	snd_soc_dapm_set_endpoint(machine, "Headphone Jack", 1);
+	sgtl5000_jack_func = 1;
+	sgtl5000_spk_func = 1;
+
+	snd_soc_dapm_set_policy(machine, SND_SOC_DAPM_POLICY_STREAM);
+	snd_soc_dapm_sync_endpoints(machine);
+
+	for (i = 0; i < ARRAY_SIZE(sgtl5000_machine_controls); i++) {
+		ret = snd_ctl_add(machine->card,
+				  snd_soc_cnew(&sgtl5000_machine_controls[i],
+					       codec, NULL));
+		if (ret < 0)
+			goto err_card_reg;
+	}
+
+	/* register card with ALSA upper layers */
+	ret = snd_soc_register_card(machine);
+	if (ret < 0) {
+		pr_err("%s: failed to register sound card\n",
+		       __func__);
+		goto err_card_reg;
+	}
+
+	if (plat->hp_status())
+		ret = request_irq(plat->hp_irq,
+				  imx_headphone_detect_handler,
+				  IRQT_FALLING, pdev->name, machine);
+	else
+		ret = request_irq(plat->hp_irq,
+				  imx_headphone_detect_handler,
+				  IRQT_RISING, pdev->name, machine);
+	if (ret < 0) {
+		pr_err("%s: request irq failed\n", __func__);
+		goto err_card_reg;
+	}
+
+	return 0;
+
+err_card_reg:
+	regulator_put(priv->reg_amp_gpo, &pdev->dev);
+err_reg_gpo:
+	regulator_put(priv->reg_vdda, &pdev->dev);
+err_reg_vdda:
+	if (priv->reg_vddio)
+		regulator_put(priv->reg_vddio, &pdev->dev);
+err_reg_vddio:
+	kfree(codec_data);
+err_codec_data:
+	kfree(priv);
+	return ret;
+}
+
+static int mach_remove(struct snd_soc_machine *machine)
+{
+	struct snd_soc_codec *codec;
+	struct snd_soc_pcm_link *pcm_link;
+	struct imx_3stack_priv *priv;
+	struct platform_device *pdev = machine->pdev;
+	struct mxc_sgtl5000_platform_data *plat = pdev->dev.platform_data;
+
+	free_irq(plat->hp_irq, machine);
+
+	pcm_link = list_first_entry(&machine->active_list,
+				    struct snd_soc_pcm_link, active_list);
+
+	codec = pcm_link->codec;
+	kfree(codec->platform_data);
+	codec->platform_data = NULL;
+
+	priv = machine->platform_data;
+	if (priv->reg_vddio)
+		regulator_disable(priv->reg_vddio);
+	regulator_disable(priv->reg_vdda);
+	regulator_disable(priv->reg_amp_gpo);
+	regulator_put(priv->reg_amp_gpo, &pdev->dev);
+	regulator_put(priv->reg_vdda, &pdev->dev);
+	if (priv->reg_vddio)
+		regulator_put(priv->reg_vddio, &pdev->dev);
+	kfree(machine->platform_data);
+	machine->platform_data = NULL;
+
+	return 0;
+}
+
+static struct snd_soc_machine_ops machine_ops = {
+	.mach_probe = mach_probe,
+	.mach_remove = mach_remove,
+};
+
+static int __devinit imx_3stack_sgtl5000_audio_probe(struct platform_device *pdev)
+{
+	struct snd_soc_machine *machine;
+	struct mxc_sgtl5000_platform_data *plat = pdev->dev.platform_data;
+	struct snd_soc_pcm_link *audio;
+	int ret;
+
+	machine = kzalloc(sizeof(struct snd_soc_machine), GFP_KERNEL);
+	if (machine == NULL)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, machine);
+	machine->owner = THIS_MODULE;
+	machine->pdev = pdev;
+	machine->name = "i.MX_3STACK";
+	machine->longname = "SGTL5000";
+	machine->ops = &machine_ops;
+
+	/* register card */
+	ret =
+	    snd_soc_new_card(machine, 1, SNDRV_DEFAULT_IDX1,
+			     SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		pr_err("%s: failed to create pcms\n", __func__);
+		goto err;
+	}
+
+	/* SGTL5000 interface */
+	ret = -ENODEV;
+
+	if (plat->src_port == 2)
+		audio = snd_soc_pcm_link_new(machine, "imx_3stack-audio",
+					    &imx_3stack_pcm_ops, imx_pcm,
+					    sgtl5000_codec, sgtl5000_dai,
+					    imx_ssi_3);
+	else
+		audio = snd_soc_pcm_link_new(machine, "imx_3stack-audio",
+					    &imx_3stack_pcm_ops, imx_pcm,
+					    sgtl5000_codec, sgtl5000_dai,
+					    imx_ssi_1);
+	if (audio == NULL) {
+		pr_err("failed to create PCM link\n");
+		goto link_err;
+	}
+	ret = snd_soc_pcm_link_attach(audio);
+	if (ret < 0) {
+		pr_err("%s: failed to attach audio pcm\n", __func__);
+		goto link_err;
+	}
+
+	gpio_activate_audio_ports();
+	imx_3stack_init_dam(plat->src_port, plat->ext_port);
+
+	ret = driver_create_file(pdev->dev.driver, &driver_attr_headphone);
+	if (ret < 0) {
+		pr_err("%s:failed to create driver_attr_headphone\n", __func__);
+		goto sysfs_err;
+	}
+
+	return ret;
+
+sysfs_err:
+	driver_remove_file(pdev->dev.driver, &driver_attr_headphone);
+link_err:
+	snd_soc_machine_free(machine);
+err:
+	kfree(machine);
+	return ret;
+
+}
+
+static int __devexit
+imx_3stack_sgtl5000_audio_remove(struct platform_device *pdev)
+{
+	struct snd_soc_machine *machine = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec;
+	struct snd_soc_pcm_link *pcm_link;
+
+	pcm_link = list_first_entry(&machine->active_list,
+				    struct snd_soc_pcm_link, active_list);
+
+	codec = pcm_link->codec;
+	codec->ops->io_remove(codec, machine);
+
+	snd_soc_machine_free(machine);
+	kfree(machine);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static const char imx_3stack_audio[32] = {
+	"sgtl5000-imx"
+};
+
+static struct platform_driver imx_3stack_sgtl5000_audio_driver = {
+	.probe = imx_3stack_sgtl5000_audio_probe,
+	.remove = __devexit_p(imx_3stack_sgtl5000_audio_remove),
+	.suspend = imx_3stack_sgtl5000_audio_suspend,
+	.resume = imx_3stack_sgtl5000_audio_resume,
+	.driver = {
+		   .name = imx_3stack_audio,
+		   },
+};
+
+static int __init imx_3stack_sgtl5000_audio_init(void)
+{
+	return platform_driver_register(&imx_3stack_sgtl5000_audio_driver);
+}
+
+static void __exit imx_3stack_sgtl5000_audio_exit(void)
+{
+	platform_driver_unregister(&imx_3stack_sgtl5000_audio_driver);
+}
+
+module_init(imx_3stack_sgtl5000_audio_init);
+module_exit(imx_3stack_sgtl5000_audio_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("SGTL5000 Driver for i.MX 3STACK");
+MODULE_LICENSE("GPL");
-- 
1.5.4.4

