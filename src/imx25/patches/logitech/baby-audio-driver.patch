---
 sound/soc/codecs/Kconfig           |    4 
 sound/soc/codecs/Makefile          |    2 
 sound/soc/codecs/tlv320aic3104.c   | 1767 +++++++++++++++++++++++++++++++++++++
 sound/soc/imx/Kconfig              |    8 
 sound/soc/imx/Makefile             |    2 
 sound/soc/imx/baby-tlv320aic3104.c |  643 +++++++++++++
 sound/soc/imx/imx-ssi.c            |    5 
 sound/soc/soc-core.c               |   14 
 8 files changed, 2439 insertions(+), 6 deletions(-)

Index: linux-2.6.26/sound/soc/codecs/Makefile
===================================================================
--- linux-2.6.26.orig/sound/soc/codecs/Makefile	2009-09-14 14:15:52.000000000 +0100
+++ linux-2.6.26/sound/soc/codecs/Makefile	2009-09-14 14:16:25.000000000 +0100
@@ -12,6 +12,7 @@
 snd-soc-wm8580-objs := wm8580.o
 snd-soc-sgtl5000-objs := sgtl5000.o
 snd-soc-bluetooth-objs := bluetooth.o
+snd-soc-tlv320aic3104-objs := tlv320aic3104.o
 
 obj-$(CONFIG_SND_SOC_AC97_CODEC)	+= snd-soc-ac97.o
 obj-$(CONFIG_SND_SOC_WM8350)	+= snd-soc-wm8350.o
@@ -27,3 +28,4 @@
 obj-$(CONFIG_SND_SOC_WM8580)    += snd-soc-wm8580.o
 obj-$(CONFIG_SND_SOC_SGTL5000)	+= snd-soc-sgtl5000.o
 obj-$(CONFIG_SND_SOC_BLUETOOTH)	+= snd-soc-bluetooth.o
+obj-$(CONFIG_SND_SOC_TLV320AIC3104)	+= snd-soc-tlv320aic3104.o
Index: linux-2.6.26/sound/soc/imx/Kconfig
===================================================================
--- linux-2.6.26.orig/sound/soc/imx/Kconfig	2009-09-14 14:15:52.000000000 +0100
+++ linux-2.6.26/sound/soc/imx/Kconfig	2009-09-14 14:16:25.000000000 +0100
@@ -66,3 +66,11 @@
  help
    Say Y if you want to add support for SoC audio on IMX 3STACK
    with the BLUETOOTH.
+
+config SND_SOC_BABY_TLV320AIC3104
+ tristate "SoC Audio support for Baby Boom - TLV320AIC3104"
+ depends on I2C
+ select SND_MXC_SOC_SSI
+ select SND_SOC_TLV320AIC3104
+ help
+   Say Y if you would like your baby to speak
Index: linux-2.6.26/sound/soc/imx/Makefile
===================================================================
--- linux-2.6.26.orig/sound/soc/imx/Makefile	2009-09-14 14:15:52.000000000 +0100
+++ linux-2.6.26/sound/soc/imx/Makefile	2009-09-14 14:16:25.000000000 +0100
@@ -20,4 +20,6 @@
 obj-$(CONFIG_SND_SOC_IMX_3STACK_SGTL5000) += snd-soc-imx-3stack-sgtl5000.o
 snd-soc-imx-3stack-bt-objs := imx-3stack-bt.o
 obj-$(CONFIG_SND_SOC_IMX_3STACK_BLUETOOTH) += snd-soc-imx-3stack-bt.o
+snd-soc-baby-tlv320aic3104-objs := baby-tlv320aic3104.o
+obj-$(CONFIG_SND_SOC_BABY_TLV320AIC3104) += snd-soc-baby-tlv320aic3104.o
 
Index: linux-2.6.26/sound/soc/imx/imx-ssi.c
===================================================================
--- linux-2.6.26.orig/sound/soc/imx/imx-ssi.c	2009-09-14 14:15:58.000000000 +0100
+++ linux-2.6.26/sound/soc/imx/imx-ssi.c	2009-09-14 14:16:25.000000000 +0100
@@ -276,7 +276,8 @@
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBS_CFS:
 		stcr |= SSI_STCR_TFDIR | SSI_STCR_TXDIR;
-		srcr |= SSI_SRCR_RFDIR | SSI_SRCR_RXDIR;
+		/* RXDIR = 0 for SSI Internal Continuous Clock mode */
+		srcr |= SSI_SRCR_RFDIR /*| SSI_SRCR_RXDIR*/;
 		if (((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_I2S)
 		    && (fmt & SND_SOC_DAIFMT_TDM)) {
 			scr &= ~SSI_SCR_I2S_MODE_MASK;
@@ -722,7 +723,7 @@
 
 static irqreturn_t ssi1_irq(int irq, void *dev_id)
 {
-	if (fifo_err_counter++ % 1000 == 0)
+	if (fifo_err_counter++ % 1 == 0)
 		printk(KERN_ERR "ssi1_irq SISR %x SIER %x fifo_errs=%d\n",
 		       SSI1_SISR, SSI1_SIER, fifo_err_counter);
 	SSI1_SISR = SSI_SIER_TUE0_EN | SSI_SIER_ROE0_EN;
Index: linux-2.6.26/sound/soc/codecs/tlv320aic3104.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.26/sound/soc/codecs/tlv320aic3104.c	2009-09-14 20:06:34.000000000 +0100
@@ -0,0 +1,1758 @@
+/*
+ * tlv320aic3104.c
+ *
+ * Copyright 2009 Logitech
+ *	Richard Titmuss <richard_titmuss@logitech.com>
+ *
+ * Based on
+ * - sound/soc/codecs/wm8350.c by Liam Girdwood
+ * - sound/soc/codecs/tlv320aic3x.c by Vladimir Barinov
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/tlv.h>
+#include <sound/initval.h>
+#include <asm/div64.h>
+
+#include "tlv320aic3x.h"
+
+/* extend register set */
+#undef AIC3X_CACHEREGNUM
+#define AIC3X_CACHEREGNUM		203
+
+#define WRITE_WORD 0x8000
+
+
+/* loud by default! */
+#undef DEFAULT_VOL
+#define DEFAULT_VOL INVERT_VOL(0x7f)
+
+#define AUDIO_NAME "AIC3104"
+#define AIC3104_VERSION "0.1"
+
+/* check every quarter second */
+#define HEADPHONE_POLL_INTERVAL (HZ / 4)
+
+
+/* Headphone sense debounce time */
+/* debounce time = 16 * 2^(HP_SENSE) ms, up to a value of 5.  */
+#define HP_SENSE 0
+
+/* Headphone press debounce time */
+/* debounce time:  0 -> 0ms.  1 -> 8ms.  2->16ms, 3->32ms */
+#define HP_PRESS 0
+
+/* ADC_GAIN in 0.5 dB steps.
+ * 7-bit value
+ * valid range from 0 to 127
+ * gain (dB) = ADC_GAIN * 0.5
+ */
+#define ADC_GAIN 0
+
+static int aic3104_dapm_event(struct snd_soc_codec *codec, int event);
+static int aic3104_i2c_read(void *control_data, long data, int);
+static void aic3104_timer_callback(unsigned long ptr);
+
+static struct i2c_client *aic3104_i2c_client;
+
+/* codec private data */
+struct aic3104_priv {
+	unsigned int sysclk;
+	int master;
+
+	/* i2c bus */
+        struct mutex lock;
+	int reg_page;
+
+	/* headphone switch */
+	struct timer_list timer;
+	struct snd_kcontrol *headphone_switch_ctl;
+	struct snd_kcontrol *headphone_button_ctl;
+	struct snd_card *card;
+	int headphone_type;
+	int headphone_detected;
+	int headphone_button;
+	int linein_test;
+	int headphone_detect_phase;
+};
+
+
+
+static const u8 aic3104_reg[AIC3X_CACHEREGNUM] = {
+	/* page a */
+	0x00, 0x00, 0x00, 0x10, /* 0 */
+	0x04, 0x00, 0x00, 0x00, /* 4 */
+	0x00, 0x00, 0x00, 0x01, /* 8 */
+	0x00, 0x00, 0x00, 0x80, /* 12 */
+	0x80, 0xff, 0xff, 0x78, /* 16 */
+	0x78, 0x78, 0x78, 0x78, /* 20 */
+	0x78, 0x06, 0x00, 0xfe, /* 24 */
+	0x00, 0x00, 0xfe, 0x00, /* 28 */
+	0x00, 0x00, 0x00, 0x00, /* 32 */
+	0x00, 0x00, 0x00, 0x00, /* 36 */
+	0x00, 0x00, 0x00, 0x80, /* 40 */
+	0x80, 0x00, 0x00, 0x00, /* 44 */
+	0x00, 0x00, 0x00, 0x04, /* 48 */
+	0x00, 0x00, 0x00, 0x00, /* 52 */
+	0x00, 0x00, 0x04, 0x00, /* 56 */
+	0x00, 0x00, 0x00, 0x00, /* 60 */
+	0x00, 0x04, 0x00, 0x00, /* 64 */
+	0x00, 0x00, 0x00, 0x00, /* 68 */
+	0x04, 0x00, 0x00, 0x00, /* 72 */
+	0x00, 0x00, 0x00, 0x00, /* 76 */
+	0x00, 0x00, 0x00, 0x00, /* 80 */
+	0x00, 0x00, 0x00, 0x00, /* 84 */
+	0x00, 0x00, 0x00, 0x00, /* 88 */
+	0x00, 0x00, 0x00, 0x00, /* 92 */
+	0x00, 0x00, 0x00, 0x00, /* 96 */
+	0x00, 0x00, 0x02, 0x00, /* 100 */
+	0x00, 0x00, 0x00, 0x00, /* 104 */
+	0x00, 0x00, 0x00, 0x00, /* 108 */
+	0x00, 0x00, 0x00, 0x00, /* 112 */
+	0x00, 0x00, 0x00, 0x00, /* 116 */
+	0x00, 0x00, 0x00, 0x00, /* 120 */
+	0x00, 0x00, 0x00, 0x00, /* 124 */
+	/* page b */
+	0x01, 0x6b, 0xe3, 0x96, /* 128 */
+	0x66, 0x67, 0x5d, 0x6b, /* 132 */
+	0xe3, 0x96, 0x66, 0x67, /* 136 */
+	0x5d, 0x7d, 0x83, 0x84, /* 140 */
+	0xee, 0x7d, 0x83, 0x84, /* 144 */
+	0xee, 0x39, 0x55, 0xf3, /* 148 */
+	0x2d, 0x53, 0x7e, 0x6b, /* 152 */
+	0xe3, 0x96, 0x66, 0x67, /* 156 */
+	0x5d, 0x6b, 0xe3, 0x96, /* 160 */
+	0x66, 0x67, 0x5d, 0x7d, /* 164 */
+	0x83, 0x84, 0xee, 0x7d, /* 168 */
+	0x83, 0x84, 0xee, 0x39, /* 172 */
+	0x55, 0xf3, 0x2d, 0x53, /* 176 */
+	0x7e, 0x7f, 0xff, 0x00, /* 180 */
+	0x00, 0x00, 0x00, 0x00, /* 184 */
+	0x00, 0x00, 0x00, 0x00, /* 188 */
+	0x00, 0x7f, 0xea, 0x80, /* 192 */
+	0x16, 0x7f, 0xd5, 0x7f, /* 196 */
+	0xea, 0x80, 0x16,       /* 200 */
+};
+
+
+/*
+ * write aic3104 register cache
+ */
+static inline void aic3104_write_reg_cache(struct snd_soc_codec *codec,
+					 u8 reg, u8 value)
+{
+	u8 *cache = codec->reg_cache;
+	if (reg >= AIC3X_CACHEREGNUM)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the aic3104 register space
+ */
+static int aic3104_write_reg(struct snd_soc_codec *codec, unsigned int reg,
+			     unsigned int value)
+{
+	struct aic3104_priv *aic3104 = codec->private_data;
+        u8 data[3];
+	int page, len;
+
+        mutex_lock(&aic3104->lock);
+
+	page = (reg & 0x80) >> 7;
+	if (page != aic3104->reg_page) {
+		data[0] = 0;
+		data[1] = page;
+
+		//printk("AIC3104 WPAGE %d: %08x\n", data[0], data[1]);
+
+		len = codec->mach_write(codec->control_data, (long)data, 2);
+		if (len != 2)
+			goto write_err;
+
+		aic3104->reg_page = page;
+	}
+
+	/* data is
+	 *   D15..D8 aic3x register offset
+	 *   D7...D0 register data
+	 */
+	/* effects registers must be written MSB followed by LSB */
+	if (reg & WRITE_WORD) {
+		data[0] = (reg & 0x7f);
+		data[1] = (value >> 8) & 0xff;
+		data[2] =  value & 0xff;
+
+		// printk("AIC3104 WRITE (REG,REG+1)=(MSB,LSB): (%d:%d)=(%02x:%02x)\n", data[0], data[0]+1, data[1], data[2]);
+
+		aic3104_write_reg_cache(codec, reg,     data[1]);
+		aic3104_write_reg_cache(codec, reg + 1, data[2]);
+		len = codec->mach_write(codec->control_data, (long)data, 3);
+		if (len != 3)
+			goto write_err;
+	}
+	else {
+		data[0] = reg & 0x7f;
+		data[1] = value & 0xff;
+
+		if (reg != 13) {
+			//printk("AIC3104 WRITE %d: %08x\n", data[0], data[1]);
+		}
+
+		aic3104_write_reg_cache(codec, reg, value);
+		len = codec->mach_write(codec->control_data, (long)data, 2);
+		if (len != 2)
+			goto write_err;
+	}
+
+        mutex_unlock(&aic3104->lock);
+	return 0;
+
+ write_err:
+	mutex_unlock(&aic3104->lock);
+	return -EIO;
+}
+
+/*
+ * read aic3104 register cache
+ */
+static inline unsigned int aic3104_read_reg_cache(struct snd_soc_codec * codec,
+						  unsigned int reg)
+{
+	u8 *cache = codec->reg_cache;
+	if (reg >= AIC3X_CACHEREGNUM)
+		return -1;
+
+	return cache[reg];
+}
+
+/*
+ * read aic3104 register cache
+ */
+static inline unsigned int aic3104_read_reg(struct snd_soc_codec * codec,
+					    unsigned int reg)
+{
+	struct aic3104_priv *aic3104 = codec->private_data;
+        u8 data[2];
+	int page, len;
+
+        mutex_lock(&aic3104->lock);
+
+	page = reg >> 7;
+	if (page != aic3104->reg_page) {
+		data[0] = 0;
+		data[1] = page;
+
+		//printk("AIC3104 RPAGE %d: %08x\n", data[0], data[1]);
+
+		len = codec->mach_write(codec->control_data, (long)data, 2);
+		if (len != 2) {
+			mutex_unlock(&aic3104->lock);
+			return -EIO;
+		}
+		aic3104->reg_page = page;
+	}
+
+	data[0] = reg & 0x7f;
+
+	len = codec->mach_read(codec->control_data, (long)data, 2);
+
+        mutex_unlock(&aic3104->lock);
+
+	if (len == 2) {
+		return data[1];
+	}
+	else {
+		return -EIO;
+	}
+}
+
+
+#define EFFECT_DOUBLE_R(xname, reg_left, reg_right) \
+{       .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+        .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\
+        .info = aic3104_info_effect, \
+        .get = aic3104_get_effect, .put = aic3104_put_effect, \
+        .private_value = (reg_left) | ((reg_right) << 24) }
+
+#define PG_B 128
+
+static int aic3104_info_effect(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+        uinfo->count = 2;
+        uinfo->value.integer.min = 0;
+        uinfo->value.integer.max = 0xFFFF;
+        return 0;
+}
+
+int aic3104_get_effect(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+        struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+        int reg = kcontrol->private_value & 0xff;
+        int reg2 = (kcontrol->private_value >> 24) & 0xff;
+
+        ucontrol->value.integer.value[0] =
+                (snd_soc_read(codec, reg) |
+		 snd_soc_read(codec, reg + 1) << 8);
+
+        ucontrol->value.integer.value[1] =
+                (snd_soc_read(codec, reg2) |
+		 snd_soc_read(codec, reg2 + 1) << 8);
+
+        return 0;
+}
+
+int aic3104_put_effect(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+        struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+        int reg = kcontrol->private_value & 0xff;
+        int reg2 = (kcontrol->private_value >> 24) & 0xff;
+        int err;
+        int val, val2;
+
+        val = ucontrol->value.integer.value[0];
+        val2 = ucontrol->value.integer.value[1];
+
+	/* write MSB first, then LSB, always */
+
+	if ((err = aic3104_write_reg(codec, reg | WRITE_WORD, val))) {
+		return err;
+	}
+
+	err = aic3104_write_reg(codec, reg2 | WRITE_WORD, val2);
+        return err;
+}
+
+static int aic3104_linein_test_get(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+        struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct aic3104_priv *aic3104 = codec->private_data;
+
+        ucontrol->value.integer.value[0] = aic3104->linein_test;
+	return 0;
+}
+
+static int aic3104_linein_test_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+        struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct aic3104_priv *aic3104 = codec->private_data;
+	int val;
+
+	/* route line in to speaker/headphone for testing */
+
+        val = ucontrol->value.integer.value[0];
+	if (val) {
+		/* PGA_L routed to HPLOUT, with a gain of 0 dB */
+		aic3104_write_reg(codec, 46, 0x80);
+		/* PGA_R routed to HPROUT, with a gain of 0 dB */
+		aic3104_write_reg(codec, 63, 0x80);
+		/* PGA_L routed to LEFT_LOP, with a gain of 0dB */
+		aic3104_write_reg(codec, 81, 0x80);
+		/* PGA_R routed to RIGHT_LOP, with a gain of 0dB */
+		aic3104_write_reg(codec, 91, 0x80);
+	}
+	else {
+		/* turn off PGA_L/R routing */
+		aic3104_write_reg(codec, 46, 0x00);
+		aic3104_write_reg(codec, 63, 0x00);
+		aic3104_write_reg(codec, 81, 0x00);
+		aic3104_write_reg(codec, 91, 0x00);
+	}
+
+        aic3104->linein_test = val;
+	return 0;
+}
+
+static int aic3104_headphone_switch_get(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+        struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct aic3104_priv *aic3104 = codec->private_data;
+
+        ucontrol->value.integer.value[0] = (aic3104->headphone_detected) ? aic3104->headphone_type : 0;
+	return 0;
+}
+
+
+static int aic3104_headphone_button_get(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+        struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct aic3104_priv *aic3104 = codec->private_data;
+
+        ucontrol->value.integer.value[0] = aic3104->headphone_button;
+	return 0;
+}
+
+
+#define SOC_DAPM_SINGLE_AIC3104(xname, reg, shift, mask, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_volsw, \
+	.get = snd_soc_dapm_get_volsw, .put = snd_soc_dapm_put_volsw_aic3104, \
+	.private_value =  SOC_SINGLE_VALUE(reg, shift, mask, invert) }
+
+/*
+ * All input lines are connected when !0xf and disconnected with 0xf bit field,
+ * so we have to use specific dapm_put call for input mixer
+ */
+static int snd_soc_dapm_put_volsw_aic3104(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+	unsigned short val, val_mask;
+	int ret;
+	struct snd_soc_dapm_path *path;
+	int found = 0;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+
+	mask = 0xf;
+	if (val)
+		val = mask;
+
+	if (invert)
+		val = mask - val;
+	val_mask = mask << shift;
+	val = val << shift;
+
+	mutex_lock(&widget->codec->mutex);
+
+	if (snd_soc_test_bits(widget->codec, reg, val_mask, val)) {
+		/* find dapm widget path assoc with kcontrol */
+		list_for_each_entry(path, &widget->machine->dapm_paths, list) {
+			if (path->kcontrol != kcontrol)
+				continue;
+
+			/* found, now check type */
+			found = 1;
+			if (val)
+				/* new connection */
+				path->connect = invert ? 0 : 1;
+			else
+				/* old connection must be powered down */
+				path->connect = invert ? 1 : 0;
+			break;
+		}
+
+		if (found)
+			snd_soc_dapm_sync_endpoints(widget->machine);
+	}
+
+	ret = snd_soc_update_bits(widget->codec, reg, val_mask, val);
+
+	mutex_unlock(&widget->codec->mutex);
+	return ret;
+}
+
+static const char *aic3104_left_dac_mux[] = { "DAC_L1", "DAC_L3", "DAC_L2" };
+static const char *aic3104_right_dac_mux[] = { "DAC_R1", "DAC_R3", "DAC_R2" };
+static const char *aic3104_left_hpcom_mux[] =
+    { "differential of HPLOUT", "constant VCM", "single-ended" };
+static const char *aic3104_right_hpcom_mux[] =
+    { "differential of HPROUT", "constant VCM", "single-ended",
+      "differential of HPLCOM", "external feedback" };
+static const char *aic3104_linein_mode_mux[] = { "single-ended", "differential" };
+
+#define LDAC_ENUM	0
+#define RDAC_ENUM	1
+#define LHPCOM_ENUM	2
+#define RHPCOM_ENUM	3
+#define LINE1L_ENUM	4
+#define LINE1R_ENUM	5
+#define LINE2L_ENUM	6
+#define LINE2R_ENUM	7
+
+static const struct soc_enum aic3104_enum[] = {
+	SOC_ENUM_SINGLE(DAC_LINE_MUX, 6, 3, aic3104_left_dac_mux),
+	SOC_ENUM_SINGLE(DAC_LINE_MUX, 4, 3, aic3104_right_dac_mux),
+	SOC_ENUM_SINGLE(HPLCOM_CFG, 4, 3, aic3104_left_hpcom_mux),
+	SOC_ENUM_SINGLE(HPRCOM_CFG, 3, 5, aic3104_right_hpcom_mux),
+	SOC_ENUM_SINGLE(LINE1L_2_LADC_CTRL, 7, 2, aic3104_linein_mode_mux),
+	SOC_ENUM_SINGLE(LINE1R_2_RADC_CTRL, 7, 2, aic3104_linein_mode_mux),
+	SOC_ENUM_SINGLE(LINE2L_2_LADC_CTRL, 7, 2, aic3104_linein_mode_mux),
+	SOC_ENUM_SINGLE(LINE2R_2_RADC_CTRL, 7, 2, aic3104_linein_mode_mux),
+};
+
+static const struct snd_kcontrol_new aic3104_snd_controls[] = {
+	/* Output */
+	SOC_DOUBLE_R("PCM Playback Volume", LDAC_VOL, RDAC_VOL, 0, 0x7f, 1),
+
+	SOC_DOUBLE_R("Line DAC Playback Volume", DACL1_2_LLOPM_VOL,
+		     DACR1_2_RLOPM_VOL, 0, 0x7f, 1),
+	SOC_DOUBLE_R("Line DAC Playback Switch", LLOPM_CTRL, RLOPM_CTRL, 3,
+		     0x01, 0),
+	SOC_DOUBLE_R("Line PGA Bypass Playback Volume", PGAL_2_LLOPM_VOL,
+		     PGAR_2_RLOPM_VOL, 0, 0x7f, 1),
+	SOC_DOUBLE_R("Line Line2 Bypass Playback Volume", LINE2L_2_LLOPM_VOL,
+		     LINE2R_2_RLOPM_VOL, 0, 0x7f, 1),
+
+	SOC_DOUBLE_R("Mono DAC Playback Volume", DACL1_2_MONOLOPM_VOL,
+		     DACR1_2_MONOLOPM_VOL, 0, 0x7f, 1),
+	SOC_SINGLE("Mono DAC Playback Switch", MONOLOPM_CTRL, 3, 0x01, 0),
+	SOC_DOUBLE_R("Mono PGA Bypass Playback Volume", PGAL_2_MONOLOPM_VOL,
+		     PGAR_2_MONOLOPM_VOL, 0, 0x7f, 1),
+	SOC_DOUBLE_R("Mono Line2 Bypass Playback Volume", LINE2L_2_MONOLOPM_VOL,
+		     LINE2R_2_MONOLOPM_VOL, 0, 0x7f, 1),
+
+	SOC_DOUBLE_R("HP DAC Playback Volume", DACL1_2_HPLOUT_VOL,
+		     DACR1_2_HPROUT_VOL, 0, 0x7f, 1),
+	SOC_DOUBLE_R("HP DAC Playback Switch", HPLOUT_CTRL, HPROUT_CTRL, 3,
+		     0x01, 0),
+	SOC_DOUBLE_R("HP PGA Bypass Playback Volume", PGAL_2_HPLOUT_VOL,
+		     PGAR_2_HPROUT_VOL, 0, 0x7f, 1),
+	SOC_DOUBLE_R("HP Line2 Bypass Playback Volume", LINE2L_2_HPLOUT_VOL,
+		     LINE2R_2_HPROUT_VOL, 0, 0x7f, 1),
+
+	SOC_DOUBLE_R("HPCOM DAC Playback Volume", DACL1_2_HPLCOM_VOL,
+		     DACR1_2_HPRCOM_VOL, 0, 0x7f, 1),
+	SOC_DOUBLE_R("HPCOM DAC Playback Switch", HPLCOM_CTRL, HPRCOM_CTRL, 3,
+		     0x01, 0),
+	SOC_DOUBLE_R("HPCOM PGA Bypass Playback Volume", PGAL_2_HPLCOM_VOL,
+		     PGAR_2_HPRCOM_VOL, 0, 0x7f, 1),
+	SOC_DOUBLE_R("HPCOM Line2 Bypass Playback Volume", LINE2L_2_HPLCOM_VOL,
+		     LINE2R_2_HPRCOM_VOL, 0, 0x7f, 1),
+
+	/*
+	 * Note: enable Automatic input Gain Controller with care. It can
+	 * adjust PGA to max value when ADC is on and will never go back.
+	*/
+	SOC_DOUBLE_R("AGC Switch", LAGC_CTRL_A, RAGC_CTRL_A, 7, 0x01, 0),
+
+	/* Input */
+	SOC_DOUBLE_R("PGA Capture Volume", LADC_VOL, RADC_VOL, 0, 0x7f, 0),
+	SOC_DOUBLE_R("PGA Capture Switch", LADC_VOL, RADC_VOL, 7, 0x01, 1),
+
+	/* Effects registers */
+	SOC_SINGLE("Audio Codec Digital Filter Control", 12, 0, 0xFF, 0),
+
+	EFFECT_DOUBLE_R("Audio Effects Filter N0 Coefficient", PG_B+1,  PG_B+27),
+	EFFECT_DOUBLE_R("Audio Effects Filter N1 Coefficient", PG_B+3,  PG_B+29),
+	EFFECT_DOUBLE_R("Audio Effects Filter N2 Coefficient", PG_B+5,  PG_B+31),
+	EFFECT_DOUBLE_R("Audio Effects Filter N3 Coefficient", PG_B+7,  PG_B+33),
+	EFFECT_DOUBLE_R("Audio Effects Filter N4 Coefficient", PG_B+9,  PG_B+35),
+	EFFECT_DOUBLE_R("Audio Effects Filter N5 Coefficient", PG_B+11, PG_B+37),
+
+	EFFECT_DOUBLE_R("Audio Effects Filter D1 Coefficient", PG_B+13, PG_B+39),
+	EFFECT_DOUBLE_R("Audio Effects Filter D2 Coefficient", PG_B+15, PG_B+41),
+	EFFECT_DOUBLE_R("Audio Effects Filter D4 Coefficient", PG_B+17, PG_B+43),
+	EFFECT_DOUBLE_R("Audio Effects Filter D5 Coefficient", PG_B+19, PG_B+45),
+
+	EFFECT_DOUBLE_R("De-Emphasis Filter N0 Coefficient", PG_B+21, PG_B+47),
+	EFFECT_DOUBLE_R("De-Emphasis Filter N1 Coefficient", PG_B+23, PG_B+49),
+	EFFECT_DOUBLE_R("De-Emphasis Filter D1 Coefficient", PG_B+25, PG_B+51),
+
+	//EFFECT_SINGLE_R("3-D Attenuation Coefficient", PG_B+, PG_B+),
+
+	EFFECT_DOUBLE_R("ADC High-Pass Filter N0 Coefficient", PG_B+65, PG_B+71),
+	EFFECT_DOUBLE_R("ADC High-Pass Filter N1 Coefficient", PG_B+67, PG_B+73),
+	EFFECT_DOUBLE_R("ADC High-Pass Filter D1 Coefficient", PG_B+69, PG_B+75),
+
+	/* Line-in bypass for testing */
+	SOC_SINGLE_BOOL_EXT("Line In Test", 0, aic3104_linein_test_get, aic3104_linein_test_put),
+
+	/* Headphone switch */
+	SOC_SINGLE_EXT("Headphone Switch", 0, 0, 0, 0,
+		       aic3104_headphone_switch_get, NULL),
+
+	SOC_SINGLE_EXT("Headphone Button", 0, 0, 0, 0,
+		       aic3104_headphone_button_get, NULL),
+};
+
+/* add non dapm controls */
+static int aic3104_add_controls(struct snd_soc_codec *codec, struct snd_card *card)
+{
+	struct aic3104_priv *aic3104 = codec->private_data;
+	struct snd_kcontrol *kctl;
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(aic3104_snd_controls); i++) {
+		err = snd_ctl_add(card,
+				  kctl = snd_soc_cnew(&aic3104_snd_controls[i],
+						      codec, NULL));
+
+		if (strcmp(aic3104_snd_controls[i].name, "Headphone Switch") == 0) {
+			aic3104->headphone_switch_ctl = kctl;
+		}
+
+		if (strcmp(aic3104_snd_controls[i].name, "Headphone Button") == 0) {
+			aic3104->headphone_button_ctl = kctl;
+		}
+
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/* Left DAC Mux */
+static const struct snd_kcontrol_new aic3104_left_dac_mux_controls =
+SOC_DAPM_ENUM("Route", aic3104_enum[LDAC_ENUM]);
+
+/* Right DAC Mux */
+static const struct snd_kcontrol_new aic3104_right_dac_mux_controls =
+SOC_DAPM_ENUM("Route", aic3104_enum[RDAC_ENUM]);
+
+/* Left HPCOM Mux */
+static const struct snd_kcontrol_new aic3104_left_hpcom_mux_controls =
+SOC_DAPM_ENUM("Route", aic3104_enum[LHPCOM_ENUM]);
+
+/* Right HPCOM Mux */
+static const struct snd_kcontrol_new aic3104_right_hpcom_mux_controls =
+SOC_DAPM_ENUM("Route", aic3104_enum[RHPCOM_ENUM]);
+
+/* Left DAC_L1 Mixer */
+static const struct snd_kcontrol_new aic3104_left_dac_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Line Switch", DACL1_2_LLOPM_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("Mono Switch", DACL1_2_MONOLOPM_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("HP Switch", DACL1_2_HPLOUT_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("HPCOM Switch", DACL1_2_HPLCOM_VOL, 7, 1, 0),
+};
+
+/* Right DAC_R1 Mixer */
+static const struct snd_kcontrol_new aic3104_right_dac_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Line Switch", DACR1_2_RLOPM_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("Mono Switch", DACR1_2_MONOLOPM_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("HP Switch", DACR1_2_HPROUT_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("HPCOM Switch", DACR1_2_HPRCOM_VOL, 7, 1, 0),
+};
+
+/* Left PGA Mixer */
+static const struct snd_kcontrol_new aic3104_left_pga_mixer_controls[] = {
+	SOC_DAPM_SINGLE_AIC3104("Line1L Switch", LINE1L_2_LADC_CTRL, 3, 1, 1),
+	SOC_DAPM_SINGLE_AIC3104("Line2L Switch", LINE2L_2_LADC_CTRL, 3, 1, 1),
+	SOC_DAPM_SINGLE_AIC3104("Mic3L Switch", MIC3LR_2_LADC_CTRL, 4, 1, 1),
+};
+
+/* Right PGA Mixer */
+static const struct snd_kcontrol_new aic3104_right_pga_mixer_controls[] = {
+	SOC_DAPM_SINGLE_AIC3104("Line1R Switch", LINE1R_2_RADC_CTRL, 3, 1, 1),
+	SOC_DAPM_SINGLE_AIC3104("Line2R Switch", LINE2R_2_RADC_CTRL, 3, 1, 1),
+	SOC_DAPM_SINGLE_AIC3104("Mic3R Switch", MIC3LR_2_RADC_CTRL, 0, 1, 1),
+};
+
+/* Left Line1 Mux */
+static const struct snd_kcontrol_new aic3104_left_line1_mux_controls =
+SOC_DAPM_ENUM("Route", aic3104_enum[LINE1L_ENUM]);
+
+/* Right Line1 Mux */
+static const struct snd_kcontrol_new aic3104_right_line1_mux_controls =
+SOC_DAPM_ENUM("Route", aic3104_enum[LINE1R_ENUM]);
+
+/* Left Line2 Mux */
+static const struct snd_kcontrol_new aic3104_left_line2_mux_controls =
+SOC_DAPM_ENUM("Route", aic3104_enum[LINE2L_ENUM]);
+
+/* Right Line2 Mux */
+static const struct snd_kcontrol_new aic3104_right_line2_mux_controls =
+SOC_DAPM_ENUM("Route", aic3104_enum[LINE2R_ENUM]);
+
+/* Left PGA Bypass Mixer */
+static const struct snd_kcontrol_new aic3104_left_pga_bp_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Line Switch", PGAL_2_LLOPM_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("Mono Switch", PGAL_2_MONOLOPM_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("HP Switch", PGAL_2_HPLOUT_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("HPCOM Switch", PGAL_2_HPLCOM_VOL, 7, 1, 0),
+};
+
+/* Right PGA Bypass Mixer */
+static const struct snd_kcontrol_new aic3104_right_pga_bp_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Line Switch", PGAR_2_RLOPM_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("Mono Switch", PGAR_2_MONOLOPM_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("HP Switch", PGAR_2_HPROUT_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("HPCOM Switch", PGAR_2_HPRCOM_VOL, 7, 1, 0),
+};
+
+/* Left Line2 Bypass Mixer */
+static const struct snd_kcontrol_new aic3104_left_line2_bp_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Line Switch", LINE2L_2_LLOPM_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("Mono Switch", LINE2L_2_MONOLOPM_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("HP Switch", LINE2L_2_HPLOUT_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("HPCOM Switch", LINE2L_2_HPLCOM_VOL, 7, 1, 0),
+};
+
+/* Right Line2 Bypass Mixer */
+static const struct snd_kcontrol_new aic3104_right_line2_bp_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Line Switch", LINE2R_2_RLOPM_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("Mono Switch", LINE2R_2_MONOLOPM_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("HP Switch", LINE2R_2_HPROUT_VOL, 7, 1, 0),
+	SOC_DAPM_SINGLE("HPCOM Switch", LINE2R_2_HPRCOM_VOL, 7, 1, 0),
+};
+
+static const struct snd_soc_dapm_widget aic3104_dapm_widgets[] = {
+	/* Left DAC to Left Outputs */
+	SND_SOC_DAPM_DAC("Left DAC", "Left Playback", DAC_PWR, 7, 0),
+	SND_SOC_DAPM_MUX("Left DAC Mux", SND_SOC_NOPM, 0, 0,
+			 &aic3104_left_dac_mux_controls),
+	SND_SOC_DAPM_MIXER("Left DAC_L1 Mixer", SND_SOC_NOPM, 0, 0,
+			   &aic3104_left_dac_mixer_controls[0],
+			   ARRAY_SIZE(aic3104_left_dac_mixer_controls)),
+	SND_SOC_DAPM_MUX("Left HPCOM Mux", SND_SOC_NOPM, 0, 0,
+			 &aic3104_left_hpcom_mux_controls),
+	SND_SOC_DAPM_PGA("Left Line Out", LLOPM_CTRL, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Left HP Out", HPLOUT_CTRL, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Left HP Com", HPLCOM_CTRL, 0, 0, NULL, 0),
+
+	/* Right DAC to Right Outputs */
+	SND_SOC_DAPM_DAC("Right DAC", "Right Playback", DAC_PWR, 6, 0),
+	SND_SOC_DAPM_MUX("Right DAC Mux", SND_SOC_NOPM, 0, 0,
+			 &aic3104_right_dac_mux_controls),
+	SND_SOC_DAPM_MIXER("Right DAC_R1 Mixer", SND_SOC_NOPM, 0, 0,
+			   &aic3104_right_dac_mixer_controls[0],
+			   ARRAY_SIZE(aic3104_right_dac_mixer_controls)),
+	SND_SOC_DAPM_MUX("Right HPCOM Mux", SND_SOC_NOPM, 0, 0,
+			 &aic3104_right_hpcom_mux_controls),
+	SND_SOC_DAPM_PGA("Right Line Out", RLOPM_CTRL, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right HP Out", HPROUT_CTRL, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right HP Com", HPRCOM_CTRL, 0, 0, NULL, 0),
+
+	/* Mono Output */
+	SND_SOC_DAPM_PGA("Mono Out", MONOLOPM_CTRL, 0, 0, NULL, 0),
+
+	/* Left Inputs to Left ADC */
+	SND_SOC_DAPM_ADC("Left ADC", "Left Capture", LINE1L_2_LADC_CTRL, 2, 0),
+	SND_SOC_DAPM_MIXER("Left PGA Mixer", SND_SOC_NOPM, 0, 0,
+			   &aic3104_left_pga_mixer_controls[0],
+			   ARRAY_SIZE(aic3104_left_pga_mixer_controls)),
+	SND_SOC_DAPM_MUX("Left Line1L Mux", SND_SOC_NOPM, 0, 0,
+			 &aic3104_left_line1_mux_controls),
+	SND_SOC_DAPM_MUX("Left Line2L Mux", SND_SOC_NOPM, 0, 0,
+			 &aic3104_left_line2_mux_controls),
+
+	/* Right Inputs to Right ADC */
+	SND_SOC_DAPM_ADC("Right ADC", "Right Capture",
+			 LINE1R_2_RADC_CTRL, 2, 0),
+	SND_SOC_DAPM_MIXER("Right PGA Mixer", SND_SOC_NOPM, 0, 0,
+			   &aic3104_right_pga_mixer_controls[0],
+			   ARRAY_SIZE(aic3104_right_pga_mixer_controls)),
+	SND_SOC_DAPM_MUX("Right Line1R Mux", SND_SOC_NOPM, 0, 0,
+			 &aic3104_right_line1_mux_controls),
+	SND_SOC_DAPM_MUX("Right Line2R Mux", SND_SOC_NOPM, 0, 0,
+			 &aic3104_right_line2_mux_controls),
+
+	/* Mic Bias */
+	SND_SOC_DAPM_MICBIAS("Mic Bias 2V", MICBIAS_CTRL, 6, 0),
+	SND_SOC_DAPM_MICBIAS("Mic Bias 2.5V", MICBIAS_CTRL, 7, 0),
+	SND_SOC_DAPM_MICBIAS("Mic Bias AVDD", MICBIAS_CTRL, 6, 0),
+	SND_SOC_DAPM_MICBIAS("Mic Bias AVDD", MICBIAS_CTRL, 7, 0),
+
+	/* Left PGA to Left Output bypass */
+	SND_SOC_DAPM_MIXER("Left PGA Bypass Mixer", SND_SOC_NOPM, 0, 0,
+			   &aic3104_left_pga_bp_mixer_controls[0],
+			   ARRAY_SIZE(aic3104_left_pga_bp_mixer_controls)),
+
+	/* Right PGA to Right Output bypass */
+	SND_SOC_DAPM_MIXER("Right PGA Bypass Mixer", SND_SOC_NOPM, 0, 0,
+			   &aic3104_right_pga_bp_mixer_controls[0],
+			   ARRAY_SIZE(aic3104_right_pga_bp_mixer_controls)),
+
+	/* Left Line2 to Left Output bypass */
+	SND_SOC_DAPM_MIXER("Left Line2 Bypass Mixer", SND_SOC_NOPM, 0, 0,
+			   &aic3104_left_line2_bp_mixer_controls[0],
+			   ARRAY_SIZE(aic3104_left_line2_bp_mixer_controls)),
+
+	/* Right Line2 to Right Output bypass */
+	SND_SOC_DAPM_MIXER("Right Line2 Bypass Mixer", SND_SOC_NOPM, 0, 0,
+			   &aic3104_right_line2_bp_mixer_controls[0],
+			   ARRAY_SIZE(aic3104_right_line2_bp_mixer_controls)),
+
+	SND_SOC_DAPM_OUTPUT("LLOUT"),
+	SND_SOC_DAPM_OUTPUT("RLOUT"),
+	SND_SOC_DAPM_OUTPUT("MONO_LOUT"),
+	SND_SOC_DAPM_OUTPUT("HPLOUT"),
+	SND_SOC_DAPM_OUTPUT("HPROUT"),
+	SND_SOC_DAPM_OUTPUT("HPLCOM"),
+	SND_SOC_DAPM_OUTPUT("HPRCOM"),
+
+	SND_SOC_DAPM_INPUT("MIC3L"),
+	SND_SOC_DAPM_INPUT("MIC3R"),
+	SND_SOC_DAPM_INPUT("LINE1L"),
+	SND_SOC_DAPM_INPUT("LINE1R"),
+	SND_SOC_DAPM_INPUT("LINE2L"),
+	SND_SOC_DAPM_INPUT("LINE2R"),
+};
+
+static const char *intercon[][3] = {
+	/* Left Output */
+	{"Left DAC Mux", "DAC_L1", "Left DAC"},
+	{"Left DAC Mux", "DAC_L2", "Left DAC"},
+	{"Left DAC Mux", "DAC_L3", "Left DAC"},
+
+	{"Left DAC_L1 Mixer", "Line Switch", "Left DAC Mux"},
+	{"Left DAC_L1 Mixer", "Mono Switch", "Left DAC Mux"},
+	{"Left DAC_L1 Mixer", "HP Switch", "Left DAC Mux"},
+	{"Left DAC_L1 Mixer", "HPCOM Switch", "Left DAC Mux"},
+	{"Left Line Out", NULL, "Left DAC Mux"},
+	{"Left HP Out", NULL, "Left DAC Mux"},
+
+	{"Left HPCOM Mux", "differential of HPLOUT", "Left DAC_L1 Mixer"},
+	{"Left HPCOM Mux", "constant VCM", "Left DAC_L1 Mixer"},
+	{"Left HPCOM Mux", "single-ended", "Left DAC_L1 Mixer"},
+
+	{"Left Line Out", NULL, "Left DAC_L1 Mixer"},
+	{"Mono Out", NULL, "Left DAC_L1 Mixer"},
+	{"Left HP Out", NULL, "Left DAC_L1 Mixer"},
+	{"Left HP Com", NULL, "Left HPCOM Mux"},
+
+	{"LLOUT", NULL, "Left Line Out"},
+	{"LLOUT", NULL, "Left Line Out"},
+	{"HPLOUT", NULL, "Left HP Out"},
+	{"HPLCOM", NULL, "Left HP Com"},
+
+	/* Right Output */
+	{"Right DAC Mux", "DAC_R1", "Right DAC"},
+	{"Right DAC Mux", "DAC_R2", "Right DAC"},
+	{"Right DAC Mux", "DAC_R3", "Right DAC"},
+
+	{"Right DAC_R1 Mixer", "Line Switch", "Right DAC Mux"},
+	{"Right DAC_R1 Mixer", "Mono Switch", "Right DAC Mux"},
+	{"Right DAC_R1 Mixer", "HP Switch", "Right DAC Mux"},
+	{"Right DAC_R1 Mixer", "HPCOM Switch", "Right DAC Mux"},
+	{"Right Line Out", NULL, "Right DAC Mux"},
+	{"Right HP Out", NULL, "Right DAC Mux"},
+
+	{"Right HPCOM Mux", "differential of HPROUT", "Right DAC_R1 Mixer"},
+	{"Right HPCOM Mux", "constant VCM", "Right DAC_R1 Mixer"},
+	{"Right HPCOM Mux", "single-ended", "Right DAC_R1 Mixer"},
+	{"Right HPCOM Mux", "differential of HPLCOM", "Right DAC_R1 Mixer"},
+	{"Right HPCOM Mux", "external feedback", "Right DAC_R1 Mixer"},
+
+	{"Right Line Out", NULL, "Right DAC_R1 Mixer"},
+	{"Mono Out", NULL, "Right DAC_R1 Mixer"},
+	{"Right HP Out", NULL, "Right DAC_R1 Mixer"},
+	{"Right HP Com", NULL, "Right HPCOM Mux"},
+
+	{"RLOUT", NULL, "Right Line Out"},
+	{"RLOUT", NULL, "Right Line Out"},
+	{"HPROUT", NULL, "Right HP Out"},
+	{"HPRCOM", NULL, "Right HP Com"},
+
+	/* Mono Output */
+	{"MONO_LOUT", NULL, "Mono Out"},
+	{"MONO_LOUT", NULL, "Mono Out"},
+
+	/* Left Input */
+	{"Left Line1L Mux", "single-ended", "LINE1L"},
+	{"Left Line1L Mux", "differential", "LINE1L"},
+
+	{"Left Line2L Mux", "single-ended", "LINE2L"},
+	{"Left Line2L Mux", "differential", "LINE2L"},
+
+	// XXXX hardcoded to Line1L
+	//{"Left PGA Mixer", "Line1L Switch", "Left Line1L Mux"},
+	//{"Left PGA Mixer", "Line2L Switch", "Left Line2L Mux"},
+	//{"Left PGA Mixer", "Mic3L Switch", "MIC3L"},
+	{"Left PGA Mixer", NULL, "Left Line1L Mux"},
+
+	{"Left ADC", NULL, "Left PGA Mixer"},
+
+	/* Right Input */
+	{"Right Line1R Mux", "single-ended", "LINE1R"},
+	{"Right Line1R Mux", "differential", "LINE1R"},
+
+	{"Right Line2R Mux", "single-ended", "LINE2R"},
+	{"Right Line2R Mux", "differential", "LINE2R"},
+
+	// XXXX hardcoded to Line1R
+	//{"Right PGA Mixer", "Line1R Switch", "Right Line1R Mux"},
+	//{"Right PGA Mixer", "Line2R Switch", "Right Line2R Mux"},
+	//{"Right PGA Mixer", "Mic3R Switch", "MIC3R"},
+	{"Right PGA Mixer", NULL, "Right Line1R Mux"},
+
+	{"Right ADC", NULL, "Right PGA Mixer"},
+
+	/* Left PGA Bypass */
+	{"Left PGA Bypass Mixer", "Line Switch", "Left PGA Mixer"},
+	{"Left PGA Bypass Mixer", "Mono Switch", "Left PGA Mixer"},
+	{"Left PGA Bypass Mixer", "HP Switch", "Left PGA Mixer"},
+	{"Left PGA Bypass Mixer", "HPCOM Switch", "Left PGA Mixer"},
+
+	{"Left HPCOM Mux", "differential of HPLOUT", "Left PGA Bypass Mixer"},
+	{"Left HPCOM Mux", "constant VCM", "Left PGA Bypass Mixer"},
+	{"Left HPCOM Mux", "single-ended", "Left PGA Bypass Mixer"},
+
+	{"Left Line Out", NULL, "Left PGA Bypass Mixer"},
+	{"Mono Out", NULL, "Left PGA Bypass Mixer"},
+	{"Left HP Out", NULL, "Left PGA Bypass Mixer"},
+
+	/* Right PGA Bypass */
+	{"Right PGA Bypass Mixer", "Line Switch", "Right PGA Mixer"},
+	{"Right PGA Bypass Mixer", "Mono Switch", "Right PGA Mixer"},
+	{"Right PGA Bypass Mixer", "HP Switch", "Right PGA Mixer"},
+	{"Right PGA Bypass Mixer", "HPCOM Switch", "Right PGA Mixer"},
+
+	{"Right HPCOM Mux", "differential of HPROUT", "Right PGA Bypass Mixer"},
+	{"Right HPCOM Mux", "constant VCM", "Right PGA Bypass Mixer"},
+	{"Right HPCOM Mux", "single-ended", "Right PGA Bypass Mixer"},
+	{"Right HPCOM Mux", "differential of HPLCOM", "Right PGA Bypass Mixer"},
+	{"Right HPCOM Mux", "external feedback", "Right PGA Bypass Mixer"},
+
+	{"Right Line Out", NULL, "Right PGA Bypass Mixer"},
+	{"Mono Out", NULL, "Right PGA Bypass Mixer"},
+	{"Right HP Out", NULL, "Right PGA Bypass Mixer"},
+
+	/* Left Line2 Bypass */
+	{"Left Line2 Bypass Mixer", "Line Switch", "Left Line2L Mux"},
+	{"Left Line2 Bypass Mixer", "Mono Switch", "Left Line2L Mux"},
+	{"Left Line2 Bypass Mixer", "HP Switch", "Left Line2L Mux"},
+	{"Left Line2 Bypass Mixer", "HPCOM Switch", "Left Line2L Mux"},
+
+	{"Left HPCOM Mux", "differential of HPLOUT", "Left Line2 Bypass Mixer"},
+	{"Left HPCOM Mux", "constant VCM", "Left Line2 Bypass Mixer"},
+	{"Left HPCOM Mux", "single-ended", "Left Line2 Bypass Mixer"},
+
+	{"Left Line Out", NULL, "Left Line2 Bypass Mixer"},
+	{"Mono Out", NULL, "Left Line2 Bypass Mixer"},
+	{"Left HP Out", NULL, "Left Line2 Bypass Mixer"},
+
+	/* Right Line2 Bypass */
+	{"Right Line2 Bypass Mixer", "Line Switch", "Right Line2R Mux"},
+	{"Right Line2 Bypass Mixer", "Mono Switch", "Right Line2R Mux"},
+	{"Right Line2 Bypass Mixer", "HP Switch", "Right Line2R Mux"},
+	{"Right Line2 Bypass Mixer", "HPCOM Switch", "Right Line2R Mux"},
+
+	{"Right HPCOM Mux", "differential of HPROUT", "Right Line2 Bypass Mixer"},
+	{"Right HPCOM Mux", "constant VCM", "Right Line2 Bypass Mixer"},
+	{"Right HPCOM Mux", "single-ended", "Right Line2 Bypass Mixer"},
+	{"Right HPCOM Mux", "differential of HPLCOM", "Right Line2 Bypass Mixer"},
+	{"Right HPCOM Mux", "external feedback", "Right Line2 Bypass Mixer"},
+
+	{"Right Line Out", NULL, "Right Line2 Bypass Mixer"},
+	{"Mono Out", NULL, "Right Line2 Bypass Mixer"},
+	{"Right HP Out", NULL, "Right Line2 Bypass Mixer"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int aic3104_add_widgets(struct snd_soc_codec *codec, struct snd_soc_machine *machine)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(aic3104_dapm_widgets); i++)
+		snd_soc_dapm_new_control(machine, codec, &aic3104_dapm_widgets[i]);
+
+	/* set up audio path interconnects */
+	for (i = 0; intercon[i][0] != NULL; i++)
+		snd_soc_dapm_connect_input(machine, intercon[i][0],
+					   intercon[i][1], intercon[i][2]);
+
+	snd_soc_dapm_new_widgets(machine);
+	return 0;
+}
+
+
+static int aic3104_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct aic3104_priv *aic3104 = codec->private_data;
+	u8 iface_areg = 0;
+	u8 iface_breg = 0;
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		aic3104->master = 1;
+		iface_areg |= BIT_CLK_MASTER | WORD_CLK_MASTER;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		aic3104->master = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface_breg |= (0x01 << 6);
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		iface_breg |= (0x02 << 6);
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface_breg |= (0x03 << 6);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* set iface */
+	aic3104_write_reg(codec, AIC3X_ASD_INTF_CTRLA, iface_areg);
+	aic3104_write_reg(codec, AIC3X_ASD_INTF_CTRLB, iface_breg);
+
+	return 0;
+}
+
+static int aic3104_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+                int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct aic3104_priv *aic3104 = codec->private_data;
+
+	switch (freq) {
+	case 12000000:
+	case 19200000:
+	case 22579200:
+	case 33868800:
+		aic3104->sysclk = freq;
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+
+struct aic3104_rate_divs {
+	u32 mclk;
+	u32 rate;
+	u32 fsref_reg;
+	u8 sr_reg:4;
+	u8 pllj_reg;
+	u16 plld_reg;
+};
+
+/* AIC3104 codec mclk clock divider coefficients */
+static const struct aic3104_rate_divs aic3104_divs[] = {
+	/* FIXME:
+	 * For now, Only support 44.1 and 48k with 12MHz clock.
+	 * This is because the DSP filters need to run at
+	 * that rate.
+	 */
+
+	/* 8k */
+	//{12000000, 8000, 48000, 0xa, 16, 3840},
+	/* 11.025k */
+	//{12000000, 11025, 44100, 0x6, 15, 528},
+	/* 16k */
+	//{12000000, 16000, 48000, 0x4, 16, 3840},
+	/* 22.05k */
+	//{12000000, 22050, 44100, 0x2, 15, 528},
+	/* 32k */
+	//{12000000, 32000, 48000, 0x1, 16, 3840},
+	/* 44.1k */
+	{12000000, 44100, 44100, 0x0, 7, 5264},
+	/* 48k */
+	{12000000, 48000, 48000, 0x0, 8, 1920},
+	/* 64k */
+	//{12000000, 64000, 96000, 0x1, 16, 3840},
+	/* 88.2k */
+	//{12000000, 88200, 88200, 0x0, 15, 528},
+	/* 96k */
+	//{12000000, 96000, 96000, 0x0, 16, 3840},
+};
+
+static inline int aic3104_get_divs(int mclk, int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(aic3104_divs); i++) {
+		if (aic3104_divs[i].rate == rate && aic3104_divs[i].mclk == mclk)
+			return i;
+	}
+
+	return 0;
+}
+
+static int aic3104_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+        struct snd_soc_pcm_link *pcm_link = substream->private_data;
+	//struct snd_soc_device *socdev = pcm_link->socdev;
+        struct snd_soc_codec *codec = pcm_link->codec;
+	struct aic3104_priv *aic3104 = codec->private_data;
+	int i;
+	u8 data, pll_p, pll_r, pll_j;
+	u16 pll_d;
+
+	//printk("###### %s:%d %s\n", __FILE__, __LINE__, __FUNCTION__);
+
+	i = aic3104_get_divs(aic3104->sysclk, params_rate(params));
+
+	/* Route Left DAC to left channel input and
+	 * right DAC to right channel input */
+	data = (LDAC2LCH | RDAC2RCH);
+	switch (aic3104_divs[i].fsref_reg) {
+	case 44100:
+		data |= FSREF_44100;
+		break;
+	case 48000:
+		data |= FSREF_48000;
+		break;
+	case 88200:
+		data |= FSREF_44100 | DUAL_RATE_MODE;
+		break;
+	case 96000:
+		data |= FSREF_48000 | DUAL_RATE_MODE;
+		break;
+	}
+	aic3104_write_reg(codec, AIC3X_CODEC_DATAPATH_REG, data); /*  reg 7 */
+
+	/* codec sample rate select */
+	data = aic3104_divs[i].sr_reg;
+	data |= (data << 4);
+	aic3104_write_reg(codec, AIC3X_SAMPLE_RATE_SEL_REG, data); /* reg 2 */
+
+	/* Use PLL for generation Fsref by equation:
+	 * Fsref = (MCLK * K * R)/(2048 * P);
+	 * Fix P = 1 and R = 1 and calculate K, if
+	 * K = J.D, i.e. J - an interger portion of K and D is the fractional
+	 * one with 4 digits of precision;
+	 * Example:
+	 * Our MCLK is 12MHz, therefore P must be 1 (page 29 of aic3104 datasheet)
+	 *
+	 **************
+	 * Restrictions:
+	 * 10 MHz <= PLLCLK_IN/P <= 20 MHz
+	 * 80 MHz <= PLLCLK_IN x K x R/P <= 110 MHz
+	 * 4 <= J <= 11
+	 * R = 1
+	 *
+	 **************
+	 * Example:
+	 * MCLK = 12 MHz and fS(ref) = 44.1 kHz
+	 * Select P = 1, R = 1, K = 7.5264, which results in J = 7, D = 5264
+	 * Example:
+	 * MCLK = 12 MHz and fS(ref) = 48 kHz
+	 * Select P = 1, R = 1, K = 8.192, which results in J = 8, D = 1920
+	 */
+
+	pll_p = 1;
+	pll_r = 1;
+	pll_j = aic3104_divs[i].pllj_reg;
+	pll_d = aic3104_divs[i].plld_reg;
+
+	data = aic3104_read_reg_cache(codec, AIC3X_PLL_PROGA_REG);
+	aic3104_write_reg(codec, AIC3X_PLL_PROGA_REG, data | (pll_p << PLLP_SHIFT));
+	aic3104_write_reg(codec, AIC3X_OVRF_STATUS_AND_PLLR_REG, pll_r << PLLR_SHIFT);
+	aic3104_write_reg(codec, AIC3X_PLL_PROGB_REG, pll_j << PLLJ_SHIFT);
+	aic3104_write_reg(codec, AIC3X_PLL_PROGC_REG, (pll_d >> 6) << PLLD_MSB_SHIFT);
+	aic3104_write_reg(codec, AIC3X_PLL_PROGD_REG, (pll_d & 0x3F) << PLLD_LSB_SHIFT);
+
+	if (aic3104->master) {
+		/* enable pll */
+		data = aic3104_read_reg_cache(codec, AIC3X_PLL_PROGA_REG);
+		aic3104_write_reg(codec, AIC3X_PLL_PROGA_REG, data | PLL_ENABLE);
+	}
+
+	/* select data word length */
+	data = aic3104_read_reg_cache(codec, AIC3X_ASD_INTF_CTRLB) & (~(0x3 << 4));
+#if 0
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		data |= (0x01 << 4);
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		data |= (0x02 << 4);
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		data |= (0x03 << 4);
+		break;
+	}
+#else
+	data |= (0x03 << 4);
+#endif
+	aic3104_write_reg(codec, AIC3X_ASD_INTF_CTRLB, data);
+
+	return 0;
+}
+
+static int aic3104_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u8 ldac_reg = aic3104_read_reg_cache(codec, LDAC_VOL) & ~MUTE_ON;
+	u8 rdac_reg = aic3104_read_reg_cache(codec, RDAC_VOL) & ~MUTE_ON;
+
+	//printk("###### %s:%d %s\n", __FILE__, __LINE__, __FUNCTION__);
+
+	if (mute) {
+		aic3104_write_reg(codec, LDAC_VOL, ldac_reg | MUTE_ON);
+		aic3104_write_reg(codec, RDAC_VOL, rdac_reg | MUTE_ON);
+	} else {
+		aic3104_write_reg(codec, LDAC_VOL, ldac_reg);
+		aic3104_write_reg(codec, RDAC_VOL, rdac_reg);
+	}
+
+	return 0;
+}
+
+static int aic3104_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	struct aic3104_priv *aic3104 = codec->private_data;
+	u8 reg;
+
+	//printk("###### %s:%d %s\n", __FILE__, __LINE__, __FUNCTION__);
+
+	if (codec->dapm_state == event) {
+		return 0;
+	}
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0:
+		/* all power is driven by DAPM system */
+
+		/*
+		 * pll is enabled in hw_params above, it must be on
+		 * before the dac and adc are powered up.
+		 */
+		break;
+	case SNDRV_CTL_POWER_D1:
+	case SNDRV_CTL_POWER_D2:
+		break;
+	case SNDRV_CTL_POWER_D3hot:
+		/*
+		 * all power is driven by DAPM system,
+		 * so output power is safe if bypass was set
+		 */
+		if (aic3104->master) {
+			/* disable pll */
+			reg = aic3104_read_reg_cache(codec, AIC3X_PLL_PROGA_REG);
+			aic3104_write_reg(codec, AIC3X_PLL_PROGA_REG,
+					  reg & ~PLL_ENABLE);
+		}
+		break;
+	case SNDRV_CTL_POWER_D3cold:
+		/* force all power off */
+		reg = aic3104_read_reg_cache(codec, LINE1L_2_LADC_CTRL);
+		aic3104_write_reg(codec, LINE1L_2_LADC_CTRL, reg & ~LADC_PWR_ON);
+		reg = aic3104_read_reg_cache(codec, LINE1R_2_RADC_CTRL);
+		aic3104_write_reg(codec, LINE1R_2_RADC_CTRL, reg & ~RADC_PWR_ON);
+
+		reg = aic3104_read_reg_cache(codec, DAC_PWR);
+		aic3104_write_reg(codec, DAC_PWR, reg & ~(LDAC_PWR_ON | RDAC_PWR_ON));
+
+		reg = aic3104_read_reg_cache(codec, HPLOUT_CTRL);
+		aic3104_write_reg(codec, HPLOUT_CTRL, reg & ~HPLOUT_PWR_ON);
+		reg = aic3104_read_reg_cache(codec, HPROUT_CTRL);
+		aic3104_write_reg(codec, HPROUT_CTRL, reg & ~HPROUT_PWR_ON);
+
+		reg = aic3104_read_reg_cache(codec, HPLCOM_CTRL);
+		aic3104_write_reg(codec, HPLCOM_CTRL, reg & ~HPLCOM_PWR_ON);
+		reg = aic3104_read_reg_cache(codec, HPRCOM_CTRL);
+		aic3104_write_reg(codec, HPRCOM_CTRL, reg & ~HPRCOM_PWR_ON);
+
+		reg = aic3104_read_reg_cache(codec, MONOLOPM_CTRL);
+		aic3104_write_reg(codec, MONOLOPM_CTRL, reg & ~MONOLOPM_PWR_ON);
+
+		reg = aic3104_read_reg_cache(codec, LLOPM_CTRL);
+		aic3104_write_reg(codec, LLOPM_CTRL, reg & ~LLOPM_PWR_ON);
+		reg = aic3104_read_reg_cache(codec, RLOPM_CTRL);
+		aic3104_write_reg(codec, RLOPM_CTRL, reg & ~RLOPM_PWR_ON);
+
+		if (aic3104->master) {
+			/* disable pll */
+			reg = aic3104_read_reg_cache(codec, AIC3X_PLL_PROGA_REG);
+			aic3104_write_reg(codec, AIC3X_PLL_PROGA_REG,
+					  reg & ~PLL_ENABLE);
+		}
+		break;
+	}
+	codec->dapm_state = event;
+
+	return 0;
+}
+
+
+static int aic3104_codec_init(struct snd_soc_codec *codec) {
+	int reg;
+
+	/* software reset */
+	aic3104_write_reg(codec, AIC3X_PAGE_SELECT, PAGE0_SELECT);
+	aic3104_write_reg(codec, AIC3X_RESET, SOFT_RESET);
+
+	/* DAC default volume and mute */
+	aic3104_write_reg(codec, LDAC_VOL, DEFAULT_VOL | MUTE_ON);
+	aic3104_write_reg(codec, RDAC_VOL, DEFAULT_VOL | MUTE_ON);
+
+	/* DAC to HP default volume and route to Output mixer */
+	aic3104_write_reg(codec, DACL1_2_HPLOUT_VOL, DEFAULT_VOL | ROUTE_ON);
+	aic3104_write_reg(codec, DACR1_2_HPROUT_VOL, DEFAULT_VOL | ROUTE_ON);
+	aic3104_write_reg(codec, DACL1_2_HPLCOM_VOL, DEFAULT_VOL | ROUTE_ON);
+	aic3104_write_reg(codec, DACR1_2_HPRCOM_VOL, DEFAULT_VOL | ROUTE_ON);
+	/* DAC to Line Out default volume and route to Output mixer */
+	aic3104_write_reg(codec, DACL1_2_LLOPM_VOL, DEFAULT_VOL | ROUTE_ON);
+	aic3104_write_reg(codec, DACR1_2_RLOPM_VOL, DEFAULT_VOL | ROUTE_ON);
+
+	/* unmute all outputs */
+	reg = aic3104_read_reg_cache(codec, LLOPM_CTRL);
+	aic3104_write_reg(codec, LLOPM_CTRL, reg | UNMUTE);
+	reg = aic3104_read_reg_cache(codec, RLOPM_CTRL);
+	aic3104_write_reg(codec, RLOPM_CTRL, reg | UNMUTE);
+
+	/* headphone */
+	aic3104_write_reg(codec, MICBIAS_CTRL,
+			  (2 << 6));  /* turn on MICBIAS to 2.5V */
+
+	aic3104_write_reg(codec, /* HIGH_POWER_OUTPUT_STAGE */ 40,
+			  (2 << 6));  /* 1.65 V bias for HP output */
+
+	aic3104_write_reg(codec, HPOUT_POP_REDUCTION,
+			  (5 << 4) |  /* Pop reduction of 50mS */
+			  (3 << 2) |  /* Ramp-up step time of 4ms */
+			  (0 << 1));  /* Generated from bandgap reference */
+
+	aic3104_write_reg(codec, HPLOUT_CTRL,
+			  (0 << 4) |  /* 0dB level */
+			  (1 << 3) |  /* HPLOUT is not muted */
+			  (0 << 2) |  /* Drive to common mode voltage */
+			  (0 << 0)    /* HPLOUT is powered down */
+			  );
+	aic3104_write_reg(codec, HPROUT_CTRL,
+			  (0 << 4) |  /* 0dB level */
+			  (1 << 3) |  /* HPROUT is not muted */
+			  (0 << 2) |  /* Drive to common mode voltage */
+			  (0 << 0)    /* HPROUT is powered down */
+			  );
+
+	/* headphone detect */
+	aic3104_write_reg(codec, /* HEADSET_DETECTION_REG_B */ 14, (1 << 7));
+
+	/* XXXX ADC config */
+	aic3104_write_reg(codec, 15, (0<<7) | (ADC_GAIN<<0));
+	aic3104_write_reg(codec, 16, (0<<7) | (ADC_GAIN<<0));
+
+	aic3104_write_reg(codec, 17, 0xFF);
+	aic3104_write_reg(codec, 18, 0xFF);
+
+	aic3104_write_reg(codec, 19, (0<<7) | (0<<3) | (1<<2) | (0<<0));
+	aic3104_write_reg(codec, 22, (0<<7) | (0<<3) | (1<<2) | (0<<0));
+
+	return 0;
+}
+
+static int aic3104_codec_io_probe(struct snd_soc_codec *codec,
+	struct snd_soc_machine *machine)
+{
+	struct aic3104_priv *aic3104 = codec->private_data;
+
+	aic3104->card = machine->card;
+	aic3104_codec_init(codec);
+
+	/* off, with power on */
+	aic3104_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	aic3104_add_controls(codec, machine->card);
+	aic3104_add_widgets(codec, machine);
+
+	/* headphone detect */
+	init_timer(&aic3104->timer);
+	aic3104->timer.function = aic3104_timer_callback;
+	aic3104->timer.data = (unsigned long) codec;
+
+	aic3104->timer.expires = jiffies + HEADPHONE_POLL_INTERVAL;
+	add_timer(&aic3104->timer);
+
+	return 0;
+}
+
+static int aic3104_codec_io_remove(struct snd_soc_codec *codec,
+	struct snd_soc_machine *machine)
+{
+	//printk("###### %s:%d %s\n", __FILE__, __LINE__, __FUNCTION__);
+
+	aic3104_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+
+/* The Baby DSP only supports 44.1k and 48k sample rates, it is easiest (but a
+ * hack) to make that restriction here.
+ */
+//#define AIC3104_RATES SNDRV_PCM_RATE_8000_96000
+#define AIC3104_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
+#define AIC3104_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FORMAT_S20_3LE | \
+			 SNDRV_PCM_FMTBIT_S24_LE)
+
+static const struct snd_soc_pcm_stream aic3104_dai_capture = {
+	.stream_name = "Capture",
+	.channels_min = 2,
+	.channels_max = 2,
+	.rates = AIC3104_RATES,
+	.formats = AIC3104_FORMATS,
+};
+
+static const struct snd_soc_pcm_stream aic3104_dai_playback = {
+	.stream_name = "Playback",
+	.channels_min = 2,
+	.channels_max = 2,
+	.rates = AIC3104_RATES,
+	.formats = AIC3104_FORMATS,
+};
+
+/* dai ops, called by machine drivers */
+static const struct snd_soc_dai_ops aic3104_dai_ops = {
+	.digital_mute = aic3104_mute,
+	.set_fmt = aic3104_set_dai_fmt,
+        .set_sysclk = aic3104_set_dai_sysclk,
+};
+
+/* audio ops, called by alsa */
+static const struct snd_soc_ops aic3104_dai_audio_ops = {
+	.hw_params = aic3104_pcm_hw_params,
+};
+
+static const struct snd_soc_codec_ops aic3104_codec_ops = {
+	.dapm_event	= aic3104_dapm_event,
+	.read		= aic3104_read_reg_cache,
+	.write		= aic3104_write_reg,
+	.io_probe	= aic3104_codec_io_probe,
+	.io_remove	= aic3104_codec_io_remove,
+};
+
+
+static void aic3104_timer_callback(unsigned long ptr)
+{
+	/*
+	 * AIC3106 has the documentation for registers 13 and 14.
+	 * reading register 14 clears the stickyness of register 13.
+	 */
+	struct snd_soc_codec *codec = (struct snd_soc_codec *) ptr;
+	struct aic3104_priv *aic3104 = codec->private_data;
+	int val, headset_detected, button_detected;
+
+	switch (aic3104->headphone_detect_phase) {
+	case 0:
+		/*  turn off headphone detect to clear the registers */
+		aic3104_write_reg(codec, 13, 0);
+
+		/*  turn it back on */
+		aic3104_write_reg(codec, 13,
+				  (1<<7) |
+				  (HP_SENSE<<2) |
+				  (HP_PRESS<<0));
+
+		aic3104->headphone_detect_phase = 1;
+		break;
+
+	case 1:
+		/* headphone detect, using reg 14 */
+
+		val = aic3104_read_reg(codec, 14);
+		headset_detected = (val & (1<<4)) ? 1 : 0;
+		button_detected  = (val & (1<<5)) ? 1 : 0;
+
+		/* headset button */
+		if (aic3104->headphone_button != button_detected) {
+			aic3104->headphone_button  = button_detected;
+
+			snd_ctl_notify(aic3104->card, SNDRV_CTL_EVENT_MASK_VALUE, &aic3104->headphone_button_ctl->id);
+		}
+
+		/* headset detect? */
+		if (aic3104->headphone_detected == headset_detected) {
+			break;
+		}
+
+		aic3104->headphone_detected  = headset_detected;
+
+#if 0
+		/* register 13 detection is not working like this, at
+		 * the moment we don't actually need to detect the
+		 * headphone type, so this code is disabled.
+		 *
+		 * See bug 12905
+		 */
+
+		/* headset type:
+		 * 00: no headset
+		 * 01: headset without microphone
+		 * 10: ignore
+		 * 11: headset with microphone
+		 */
+
+		val  = aic3104_read_reg(codec, 13);
+		aic3104->headphone_type = (val >> 5) & 0x03;
+#else
+		aic3104->headphone_type = 1;
+#endif
+
+		snd_ctl_notify(aic3104->card, SNDRV_CTL_EVENT_MASK_VALUE, &aic3104->headphone_switch_ctl->id);
+
+		aic3104->headphone_detect_phase = 0;
+		break;
+	}
+
+	aic3104->timer.expires = jiffies + HEADPHONE_POLL_INTERVAL;
+	add_timer(&aic3104->timer);
+}
+
+
+// XXXX for debugging i2c
+static struct snd_soc_codec *debugreg_codec;
+
+static ssize_t show_debugreg(struct device_driver *dev, char *buf)
+{
+        struct snd_soc_codec *codec = debugreg_codec;
+	struct aic3104_priv *aic3104 = codec->private_data;
+	u8 data[2];
+	int i;
+
+        mutex_lock(&aic3104->lock);
+
+	printk("PAGE 0\n");
+
+	data[0] = 0;
+	data[1] = 0;
+	codec->mach_write(codec->control_data, (long)data, 2);
+
+	for (i=0; i<127; i++) {
+		int val = aic3104_read_reg_cache(codec, i);
+
+		data[0] = i;
+		codec->mach_read(codec->control_data, (long)data, 2);
+
+		if (data[1] == val) {
+			printk("REG [%03d]: %02x\n", i & 0x7F, data[1]);
+		}
+		else {
+			printk("REG [%03d]: %02x cache=%02x\n", i & 0x7F, data[1], val);
+		}
+	}
+
+	printk("PAGE 1\n");
+
+	data[0] = 0;
+	data[1] = 1;
+	codec->mach_write(codec->control_data, (long)data, 2);
+
+	for (i=128; i<AIC3X_CACHEREGNUM; i++) {
+		int val = aic3104_read_reg_cache(codec, i);
+
+		data[0] = i & 0x7F;
+		codec->mach_read(codec->control_data, (long)data, 2);
+
+		if (data[1] == val) {
+			printk("REG [%03d]: %02x\n", i & 0x7F, data[1]);
+		}
+		else {
+			printk("REG [%03d]: %02x cache=%02x\n", i & 0x7F, data[1], val);
+		}
+	}
+
+	data[0] = 0;
+	data[1] = aic3104->reg_page;
+	codec->mach_write(codec->control_data, (long)data, 2);
+
+        mutex_unlock(&aic3104->lock);
+
+	return 0;
+}
+
+DRIVER_ATTR(debugreg, S_IRUGO | S_IWUSR, show_debugreg, NULL);
+
+
+static int aic3104_codec_probe(struct device *dev)
+{
+	struct snd_soc_codec *codec = to_snd_soc_codec(dev);
+	struct aic3104_priv *aic3104;
+
+	printk(KERN_INFO "AIC3104 Audio Codec %s", AIC3104_VERSION);
+
+	codec->owner = THIS_MODULE;
+	codec->ops = &aic3104_codec_ops;
+
+	aic3104  = kzalloc(sizeof(struct aic3104_priv), GFP_KERNEL);
+	if (!aic3104)
+		return -ENOMEM;
+
+        mutex_init(&aic3104->lock);
+	codec->private_data = aic3104;
+
+	codec->reg_cache_size = sizeof(aic3104_reg);
+	codec->reg_cache = kmemdup(aic3104_reg, sizeof(aic3104_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+
+        codec->control_data = aic3104_i2c_client;
+	codec->mach_read = aic3104_i2c_read;
+        codec->mach_write = (int (*)(void *control_data, long data, int))i2c_master_send;
+
+	snd_soc_register_codec(codec);
+
+	// XXXX for debugging register cache
+	debugreg_codec = codec;
+	driver_create_file(dev->driver, &driver_attr_debugreg);
+
+	return 0;
+
+}
+
+static int aic3104_codec_remove(struct device *dev)
+{
+	struct snd_soc_codec *codec = to_snd_soc_codec(dev);
+
+	kfree(codec->reg_cache);
+	kfree(codec->private_data);
+	return 0;
+}
+
+static int aic3104_dai_probe(struct device *dev)
+{
+	struct snd_soc_dai *dai = to_snd_soc_dai(dev);
+
+	dai->ops = &aic3104_dai_ops;
+	dai->audio_ops = &aic3104_dai_audio_ops;
+	dai->capture = &aic3104_dai_capture;
+	dai->playback = &aic3104_dai_playback;
+	snd_soc_register_codec_dai(dai);
+	return 0;
+}
+
+const char aic3104_codec[SND_SOC_CODEC_NAME_SIZE] = "aic3104-codec";
+EXPORT_SYMBOL_GPL(aic3104_codec);
+
+static struct snd_soc_device_driver aic3104_codec_driver = {
+	.type = SND_SOC_BUS_TYPE_CODEC,
+	.driver = {
+		   .name = aic3104_codec,
+		   .owner = THIS_MODULE,
+		   .bus = &asoc_bus_type,
+		   .probe = aic3104_codec_probe,
+		   .remove = __devexit_p(aic3104_codec_remove),
+		   },
+};
+
+const char aic3104_dai[SND_SOC_CODEC_NAME_SIZE] = "aic3104-dai";
+EXPORT_SYMBOL_GPL(aic3104_dai);
+
+static struct snd_soc_device_driver aic3104_dai_driver = {
+	.type = SND_SOC_BUS_TYPE_DAI,
+	.driver = {
+		   .name = aic3104_dai,
+		   .owner = THIS_MODULE,
+		   .bus = &asoc_bus_type,
+		   .probe = aic3104_dai_probe,
+		   },
+};
+
+
+/* I2C */
+static int aic3104_i2c_read(void *control_data, long data, int num)
+{
+	struct i2c_client *client = (struct i2c_client *) control_data;
+	u8 *val = (u8 *)data;
+
+	val[1] = i2c_smbus_read_byte_data(client, val[0]);
+	return num;
+}
+
+static int aic3104_i2c_probe(struct i2c_client *client, const struct i2c_device_id *devid)
+{
+        if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+                dev_err(&client->dev, "No SMBUS byte data capability\n");
+                return -EEXIST;
+        }
+
+        aic3104_i2c_client = client;
+
+        return 0;
+}
+
+static int aic3104_i2c_remove(struct i2c_client *client)
+{
+        struct snd_soc_codec *codec = i2c_get_clientdata(client);
+        kfree(codec->reg_cache);
+        return 0;
+}
+
+static struct i2c_device_id aic3104_i2c_ids[] = {
+        { "aic3104-i2c", 0 },
+        { }
+};
+
+MODULE_DEVICE_TABLE(i2c, aic3104_i2c_ids);
+
+static struct i2c_driver aic3104_i2c_driver = {
+        .driver = {
+                .name = "aic3104-i2c",
+                .owner = THIS_MODULE,
+        },
+        .probe  = aic3104_i2c_probe,
+        .remove = aic3104_i2c_remove,
+        .id_table = aic3104_i2c_ids,
+};
+/* END I2C */
+
+
+static __init int aic3104_init(void)
+{
+	int ret = 0;
+
+        ret = i2c_add_driver(&aic3104_i2c_driver);
+	if (ret != 0)
+		goto err0;
+
+	ret = driver_register(&aic3104_codec_driver.driver);
+	if (ret < 0)
+		goto err1;
+
+	ret = driver_register(&aic3104_dai_driver.driver);
+	if (ret < 0)
+		goto err2;
+
+	return ret;
+
+ err2:
+	driver_unregister(&aic3104_codec_driver.driver);
+ err1:
+	i2c_del_driver(&aic3104_i2c_driver);
+ err0:
+	return ret;
+}
+
+static __exit void aic3104_exit(void)
+{
+	driver_unregister(&aic3104_dai_driver.driver);
+	driver_unregister(&aic3104_codec_driver.driver);
+}
+
+module_init(aic3104_init);
+module_exit(aic3104_exit);
+
+MODULE_DESCRIPTION("ASoC AIC3104 driver");
+MODULE_AUTHOR("Richard Titmuss");
+MODULE_LICENSE("GPL");
Index: linux-2.6.26/sound/soc/imx/baby-tlv320aic3104.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.26/sound/soc/imx/baby-tlv320aic3104.c	2009-09-14 14:16:25.000000000 +0100
@@ -0,0 +1,643 @@
+/*
+ * baby-tlv320aic3104.c
+ *
+ * Copyright 2008 Logitech
+ *	Richard Titmuss <richard_titmuss@logitech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mxc.h>
+#include <asm/arch/gpio.h>
+
+#include "imx-pcm.h"
+#include "imx-ssi.h"
+
+
+/* define this to make the codec the i2s master */
+#define CODEC_MASTER
+
+/* useful to turn off when my kids are asleep while debugging! */
+#define USE_SPEAKER 1
+
+/* debounce time for line in switch */
+#define LINEIN_DEBOUNCE_TIME (HZ/2)
+
+
+extern void gpio_activate_audio_ports(int ssi_port);
+extern const char aic3104_codec[SND_SOC_CODEC_NAME_SIZE];
+extern const char aic3104_dai[SND_SOC_CODEC_NAME_SIZE];
+
+static struct snd_soc_machine *baby_aic3104_machine;
+
+// XXXX in private data
+static struct snd_kcontrol *linein_switch;
+static struct timer_list linein_timer;
+static int linein_val;
+
+
+static void baby_init_dam(int ssi_port, int dai_port)
+{
+	/* AIC3104 uses SSI1 or SSI2 via AUDMUX port dai_port for audio */
+
+        /* reset port ssi_port & dai_port */
+        DAM_PTCR(ssi_port) = 0;
+        DAM_PDCR(ssi_port) = 0;
+        DAM_PTCR(dai_port) = 0;
+        DAM_PDCR(dai_port) = 0;
+
+#ifdef CODEC_MASTER
+        /* set to synchronous */
+        DAM_PTCR(ssi_port) |= AUDMUX_PTCR_SYN;
+        DAM_PTCR(dai_port) |= AUDMUX_PTCR_SYN;
+
+        /* set Rx sources ssi_port <--> dai_port */
+        DAM_PDCR(ssi_port) |= AUDMUX_PDCR_RXDSEL(dai_port);
+        DAM_PDCR(dai_port) |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+        /* set Tx frame direction and source dai_port--> ssi_port output */
+        DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TFSDIR;
+        DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, dai_port);
+
+        /* set Tx Clock direction and source dai_port--> ssi_port output */
+        DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TCLKDIR;
+        DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, dai_port);
+#else
+	/* set to asynchronous */
+
+	/* set Rx sources ssi_port <--> dai_port */
+	DAM_PDCR(ssi_port) |= AUDMUX_PDCR_RXDSEL(dai_port);
+	DAM_PDCR(dai_port) |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+	/* set Tx frame direction and source  ssi_port --> dai_port output */
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TFSDIR;
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, ssi_port);
+
+	/* set Tx Clock direction and source ssi_port--> dai_port output */
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TCLKDIR;
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, ssi_port);
+
+	/* set Rx Clock (master clock) ssi_port --> dai_port output */
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_RCLKDIR;
+	DAM_PTCR(dai_port) |= AUDMUX_PTCR_RCSEL(AUDMUX_FROM_RXFS, ssi_port);
+#endif
+}
+
+
+/* define the scenarios */
+#define SCENARIO_AUDIO_OFF                  0
+#define SCENARIO_SPEAKER                    1
+#define SCENARIO_HEADPHONE                  2
+#define SCENARIO_FACTORY_TEST               3
+
+static const char *jive_scenarios[] = {
+	"Off",
+	"Speaker",
+	"Headphone",
+	"FactoryTest",
+};
+
+static const struct soc_enum baby_aic3104_scenarios_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(jive_scenarios),jive_scenarios),
+};
+
+// XXXX move this into private data
+static int baby_aic3104_scenario = SCENARIO_SPEAKER; /* default speaker on */
+
+static int baby_aic3104_get_scenario(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+        ucontrol->value.integer.value[0] = baby_aic3104_scenario;
+        return 0;
+}
+
+static void set_scenario_endpoints(struct snd_soc_machine *machine)
+{
+        switch(baby_aic3104_scenario) {
+        case SCENARIO_SPEAKER:
+		snd_soc_dapm_set_endpoint(machine, "Headphone Jack", 0);
+		snd_soc_dapm_set_endpoint(machine, "Speaker", USE_SPEAKER);
+		break;
+        case SCENARIO_HEADPHONE:
+		snd_soc_dapm_set_endpoint(machine, "Headphone Jack", 1);
+		snd_soc_dapm_set_endpoint(machine, "Speaker", 0);
+		break;
+        case SCENARIO_FACTORY_TEST:
+		snd_soc_dapm_set_endpoint(machine, "Headphone Jack", 1);
+		snd_soc_dapm_set_endpoint(machine, "Speaker", USE_SPEAKER);
+		break;
+        case SCENARIO_AUDIO_OFF:
+	default:
+		snd_soc_dapm_set_endpoint(machine, "Headphone Jack", 0);
+		snd_soc_dapm_set_endpoint(machine, "Speaker", 0);
+		break;
+	}
+
+	snd_soc_dapm_sync_endpoints(machine);
+}
+
+static int baby_aic3104_set_scenario(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+        if (baby_aic3104_scenario == ucontrol->value.integer.value[0])
+                return 0;
+
+        baby_aic3104_scenario = ucontrol->value.integer.value[0];
+        set_scenario_endpoints(baby_aic3104_machine);
+        return 1;
+}
+
+static int baby_aic3104_pashutdown_get(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	struct platform_device *pdev = baby_aic3104_machine->pdev;
+	unsigned int pa_shutdown;
+
+	pa_shutdown = platform_get_resource(pdev, IORESOURCE_MEM, 1)->start;
+	ucontrol->value.integer.value[0] = mxc_get_gpio_datain(pa_shutdown);
+	return 0;
+}
+
+static int baby_aic3104_pashutdown_put(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	struct platform_device *pdev = baby_aic3104_machine->pdev;
+	unsigned int pa_shutdown;
+	long flag = ucontrol->value.integer.value[0];
+
+	pa_shutdown = platform_get_resource(pdev, IORESOURCE_MEM, 1)->start;
+	mxc_set_gpio_dataout(pa_shutdown, flag);
+	return 1;
+}
+
+static int baby_aic3104_pamute_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct platform_device *pdev = baby_aic3104_machine->pdev;
+	unsigned int pa_mute;
+
+	pa_mute = platform_get_resource(pdev, IORESOURCE_MEM, 2)->start;
+	ucontrol->value.integer.value[0] = mxc_get_gpio_datain(pa_mute);
+	return 0;
+}
+
+static int baby_aic3104_pamute_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct platform_device *pdev = baby_aic3104_machine->pdev;
+	unsigned int pa_mute;
+	long flag = ucontrol->value.integer.value[0];
+
+	pa_mute = platform_get_resource(pdev, IORESOURCE_MEM, 2)->start;
+	mxc_set_gpio_dataout(pa_mute, flag);
+	return 1;
+}
+
+static int baby_aic3104_linein_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+        ucontrol->value.integer.value[0] = !linein_val;
+	return 0;
+}
+
+
+static const struct snd_kcontrol_new baby_aic3104_snd_controls[] = {
+	SOC_ENUM_EXT("Endpoint", baby_aic3104_scenarios_enum[0], baby_aic3104_get_scenario, baby_aic3104_set_scenario),
+	SOC_SINGLE_BOOL_EXT("Test PA Shutdown", 0, baby_aic3104_pashutdown_get, baby_aic3104_pashutdown_put),
+	SOC_SINGLE_BOOL_EXT("Test PA Mute", 0, baby_aic3104_pamute_get, baby_aic3104_pamute_put),
+	SOC_SINGLE_BOOL_EXT("Line In Switch", 0, baby_aic3104_linein_get, NULL)
+};
+
+static int baby_aic3104_spk_event(struct snd_soc_dapm_widget *w,
+				  struct snd_kcontrol *k, int event)
+{
+	struct platform_device *pdev = baby_aic3104_machine->pdev;
+	unsigned int pa_mute;
+	unsigned int pa_shutdown;
+
+	pa_shutdown = platform_get_resource(pdev, IORESOURCE_MEM, 1)->start;
+	pa_mute = platform_get_resource(pdev, IORESOURCE_MEM, 2)->start;
+
+        if (SND_SOC_DAPM_EVENT_ON(event)) {
+		mxc_set_gpio_dataout(pa_shutdown, 1);
+		mdelay(2);
+		mxc_set_gpio_dataout(pa_mute, 0);
+	}
+	else {
+		mxc_set_gpio_dataout(pa_mute, 1);
+		mdelay(2);
+		mxc_set_gpio_dataout(pa_shutdown, 0);
+	}
+
+        return 0;
+}
+
+/* baby machine dapm widgets */
+static const struct snd_soc_dapm_widget baby_aic3104_dapm_widgets[] = {
+	SND_SOC_DAPM_SPK("Speaker", baby_aic3104_spk_event),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+};
+
+/* baby machine audio map */
+static const char *audio_map[][3] = {
+	/* Speaker connected to LLOUT, RLOUT */
+	{"Speaker", NULL, "RLOUT"},
+	{"Speaker", NULL, "LLOUT"},
+
+	/* Headphone Jack connected to HPLOUT, HPROUT */
+	{"Headphone Jack", NULL, "HPLOUT"},
+	{"Headphone Jack", NULL, "HPROUT"},
+
+	/* Line in Jack */
+	// XXXX check this:
+	{"LINE1L", NULL, "Line In Jack"},
+	{"LINE1R", NULL, "Line In Jack"},
+
+	{NULL, NULL, NULL},
+};
+
+
+
+static int baby_hifi_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_link *pcm_link = substream->private_data;
+	struct mxc_audio_platform_data *dev_data = pcm_link->private_data;
+	struct snd_soc_dai *cpu_dai = pcm_link->cpu_dai;
+	struct snd_soc_dai *codec_dai = pcm_link->codec_dai;
+	unsigned int channels = params_channels(params);
+	u32 dai_format;
+	struct clk *clk, *parent;
+	unsigned long rate;
+
+	baby_init_dam(dev_data->src_port, dev_data->ext_port);
+
+#ifdef CODEC_MASTER
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	    SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_SYNC;
+#else
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	    SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_SYNC;
+#endif
+
+	if (channels == 2)
+		dai_format |= SND_SOC_DAIFMT_TDM;
+
+        /* set codec DAI configuration */
+        codec_dai->ops->set_fmt(codec_dai, dai_format);
+
+	/* set cpu DAI configuration */
+	cpu_dai->ops->set_fmt(cpu_dai, dai_format);
+
+	/* set i.MX active slot mask */
+	cpu_dai->ops->set_tdm_slot(cpu_dai,
+				   channels == 1 ? 0xfffffffe : 0xfffffffc,
+				   channels);
+
+
+#ifdef CODEC_MASTER
+	/* set the SSI system clock as output */
+	cpu_dai->ops->set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0, SND_SOC_CLOCK_OUT);
+
+	/* cko1 clock */
+	clk = clk_get(NULL, "clko_clk");
+	if (IS_ERR(clk))
+		return EINVAL;
+	parent = clk_get(NULL, "usb_clk");
+	if (IS_ERR(parent))
+		return EINVAL;;
+	clk_set_parent(clk, parent);
+	rate = clk_round_rate(clk, 12000000);
+
+	if (rate < 11000000 || rate > 13000000) {
+		pr_err("Error: audio mclk freq %ld out of range!\n", rate);
+		clk_put(parent);
+		clk_put(clk);
+		return EINVAL;;
+	}
+	clk_set_rate(clk, rate);
+	clk_enable(clk);
+
+	codec_dai->ops->set_sysclk(codec_dai, 1, 12000000,  SND_SOC_CLOCK_IN);
+#else
+	// FIXME wrong clock speed
+
+	/* set the SSI system clock as input */
+	cpu_dai->ops->set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0, SND_SOC_CLOCK_IN);
+
+	/* set the SSI1 clock divider */
+	clk = clk_get(NULL, "per_ssi1_clk");
+	clk_set_rate(clk, 24000000);
+	clk_put(clk);
+
+	/* set BCLK division for sample rate */
+	switch (rate) {
+	case 96000:
+	case 88200:
+		cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 0);
+		break;
+	default:
+		cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 1);
+		break;
+	}
+#endif
+
+	return 0;
+}
+
+/*
+ * baby aic3104 HiFi DAI opserations.
+ */
+static struct snd_soc_ops baby_hifi_ops = {
+	.hw_params = baby_hifi_hw_params,
+};
+
+static int hifi_pcm_new(struct snd_soc_pcm_link *pcm_link)
+{
+	int ret;
+	pcm_link->audio_ops = &baby_hifi_ops;
+	ret = snd_soc_pcm_new(pcm_link, 1, 1);
+	if (ret < 0) {
+		pr_err("%s: Failed to create hifi pcm\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+struct snd_soc_pcm_link_ops hifi_pcm = {
+	.new = hifi_pcm_new,
+};
+
+static void linein_timer_callback(unsigned long data)
+{
+	struct snd_soc_machine *machine = (struct snd_soc_machine *) data;
+	struct platform_device *pdev = machine->pdev;
+	unsigned int linein;
+	int val;
+
+	linein = platform_get_resource(pdev, IORESOURCE_MEM, 0)->start;
+	val = mxc_get_gpio_datain(linein);
+
+	if (val) {
+		set_irq_type(IOMUX_TO_IRQ(linein), IRQ_TYPE_EDGE_FALLING);
+	}
+	else {
+		set_irq_type(IOMUX_TO_IRQ(linein), IRQ_TYPE_EDGE_RISING);
+	}
+	enable_irq(IOMUX_TO_IRQ(linein));
+
+	if (linein_switch && linein_val != val) {
+		linein_val = val;
+		snd_ctl_notify(machine->card, SNDRV_CTL_EVENT_MASK_VALUE, &linein_switch->id);
+	}
+}
+
+
+static irqreturn_t linein_handler(int irq, void *data)
+{
+	struct snd_soc_machine *machine = (struct snd_soc_machine *) data;
+	struct platform_device *pdev = machine->pdev;
+	unsigned int linein;
+
+	linein = platform_get_resource(pdev, IORESOURCE_MEM, 0)->start;
+	disable_irq(IOMUX_TO_IRQ(linein));
+
+	mod_timer(&linein_timer, jiffies + LINEIN_DEBOUNCE_TIME);
+
+	return IRQ_HANDLED;
+}
+
+static int baby_aic3104_machine_probe(struct snd_soc_machine *machine)
+{
+	struct snd_soc_codec *codec;
+	struct snd_soc_pcm_link *pcm_link;
+	struct snd_kcontrol *kctl;
+	int i, ret;
+
+	pcm_link = list_first_entry(&machine->active_list,
+				    struct snd_soc_pcm_link, active_list);
+	codec = pcm_link->codec;
+
+	codec->ops->io_probe(codec, machine);
+
+	/* Add baby specific controls */
+	for (i = 0; i < ARRAY_SIZE(baby_aic3104_snd_controls); i++) {
+		snd_ctl_add(machine->card,
+			    kctl = snd_soc_cnew(&baby_aic3104_snd_controls[i],
+						codec, NULL));
+
+		if (strcmp(baby_aic3104_snd_controls[i].name, "Line In Switch") == 0) {
+			linein_switch = kctl;
+		}
+
+	}
+
+	/* Add baby specific widgets */
+	for (i = 0; i < ARRAY_SIZE(baby_aic3104_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(machine, codec,
+					 &baby_aic3104_dapm_widgets[i]);
+	}
+
+	/* set up baby specific audio path audio map */
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(machine, audio_map[i][0],
+					   audio_map[i][1], audio_map[i][2]);
+	}
+
+        /* not connected codec outputs */
+        snd_soc_dapm_set_endpoint(machine, "MONO_LOUT", 0);
+        snd_soc_dapm_set_endpoint(machine, "HPLOUT", 0);
+        snd_soc_dapm_set_endpoint(machine, "HPROUT", 0);
+
+        /* not connected codec inputs */
+        snd_soc_dapm_set_endpoint(machine, "LINE2L", 0);
+        snd_soc_dapm_set_endpoint(machine, "LINE2R", 0);
+
+	set_scenario_endpoints(machine);
+	snd_soc_dapm_set_endpoint(machine, "Line In Jack", 1);
+
+	snd_soc_dapm_set_policy(machine, SND_SOC_DAPM_POLICY_STREAM);
+	snd_soc_dapm_sync_endpoints(machine);
+
+	/* register card with ALSA upper layers */
+	ret = snd_soc_register_card(machine);
+	if (ret < 0) {
+		pr_err("%s: failed to register sound card\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+struct snd_soc_machine_ops baby_aic3104_machine_ops = {
+	.mach_probe = baby_aic3104_machine_probe,
+};
+
+
+/*
+ * This function will register the snd_soc_pcm_link drivers.
+ * It also registers devices for platform DMA, I2S, SSP and registers an
+ * I2C driver to probe the codec.
+ */
+static int __init baby_aic3104_probe(struct platform_device *pdev)
+{
+	struct snd_soc_machine *machine;
+	struct mxc_audio_platform_data *dev_data = pdev->dev.platform_data;
+	struct snd_soc_pcm_link *hifi;
+	unsigned int linein;
+	const char *ssi_port;
+	int ret;
+
+	machine = kzalloc(sizeof(struct snd_soc_machine), GFP_KERNEL);
+	if (machine == NULL)
+		return -ENOMEM;
+
+	machine->owner = THIS_MODULE;
+	machine->pdev = pdev;
+	machine->name = "baby";
+	machine->longname = "aic3104";
+	machine->ops = &baby_aic3104_machine_ops;
+	pdev->dev.driver_data = machine;
+
+	/* register card */
+	baby_aic3104_machine = machine;
+	ret = snd_soc_new_card(machine, 1, SNDRV_DEFAULT_IDX1,
+			       SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		pr_err("%s: failed to create stereo sound card\n", __func__);
+		goto err;
+	}
+
+	/* baby aic3104 hifi interface */
+	if (dev_data->src_port == 1)
+		ssi_port = imx_ssi_1;
+	else
+		ssi_port = imx_ssi_3;
+	hifi = snd_soc_pcm_link_new(machine,
+				    "baby-aic3104", &hifi_pcm,
+				    imx_pcm, aic3104_codec,
+				    aic3104_dai, ssi_port);
+	if (hifi == NULL) {
+		pr_err("Failed to create HiFi PCM link\n");
+		goto err;
+	}
+
+	ret = snd_soc_pcm_link_attach(hifi);
+	hifi->private_data = dev_data;
+	if (ret < 0)
+		goto link_err;
+
+	/* Configure audio port 3 */
+	gpio_activate_audio_ports(dev_data->src_port);
+
+	/* line in switch irq/timer */
+	init_timer(&linein_timer);
+	linein_timer.data = (unsigned long) machine;
+	linein_timer.function = linein_timer_callback;
+
+	linein = platform_get_resource(pdev, IORESOURCE_MEM, 0)->start;
+	linein_val = mxc_get_gpio_datain(linein);
+	if (linein_val) {
+		set_irq_type(IOMUX_TO_IRQ(linein), IRQ_TYPE_EDGE_FALLING);
+	}
+	else {
+		set_irq_type(IOMUX_TO_IRQ(linein), IRQ_TYPE_EDGE_RISING);
+	}
+	if (request_irq(IOMUX_TO_IRQ(linein), linein_handler, IRQF_DISABLED | IRQF_SAMPLE_RANDOM, "linein", machine))
+		goto link_err;
+
+	return ret;
+
+      link_err:
+	snd_soc_machine_free(machine);
+      err:
+	kfree(machine);
+	return ret;
+}
+
+static int __devexit baby_aic3104_remove(struct platform_device *pdev)
+{
+	struct snd_soc_machine *machine = pdev->dev.driver_data;
+
+	baby_aic3104_machine = NULL;
+	kfree(machine);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int baby_aic3104_suspend(struct platform_device
+				     *pdev, pm_message_t state)
+{
+	struct snd_soc_machine *machine = pdev->dev.driver_data;
+	return snd_soc_suspend(machine, state);
+}
+
+static int baby_aic3104_resume(struct platform_device
+				    *pdev)
+{
+	struct snd_soc_machine *machine = pdev->dev.driver_data;
+	return snd_soc_resume(machine);
+}
+
+#else
+#define baby_aic3104_suspend NULL
+#define baby_aic3104_resume  NULL
+#endif
+
+static struct platform_driver baby_aic3104_driver = {
+	.probe = baby_aic3104_probe,
+	.remove = __devexit_p(baby_aic3104_remove),
+	.suspend = baby_aic3104_suspend,
+	.resume = baby_aic3104_resume,
+	.driver = {
+		   .name = "baby-aic3104",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init baby_asoc_init(void)
+{
+	return platform_driver_register(&baby_aic3104_driver);
+}
+
+static void __exit baby_asoc_exit(void)
+{
+	platform_driver_unregister(&baby_aic3104_driver);
+}
+
+module_init(baby_asoc_init);
+module_exit(baby_asoc_exit);
+
+/* Module information */
+MODULE_DESCRIPTION("ALSA SoC aic3104 baby");
+MODULE_AUTHOR("Richard Titmuss");
+MODULE_LICENSE("GPL");
Index: linux-2.6.26/sound/soc/codecs/Kconfig
===================================================================
--- linux-2.6.26.orig/sound/soc/codecs/Kconfig	2009-09-14 14:15:52.000000000 +0100
+++ linux-2.6.26/sound/soc/codecs/Kconfig	2009-09-14 14:16:25.000000000 +0100
@@ -69,3 +69,7 @@
 	tristate
 	depends on SND_SOC
 
+config SND_SOC_TLV320AIC3104
+	tristate
+	depends on SND_SOC && I2C
+
Index: linux-2.6.26/sound/soc/soc-core.c
===================================================================
--- linux-2.6.26.orig/sound/soc/soc-core.c	2009-09-14 14:16:24.000000000 +0100
+++ linux-2.6.26/sound/soc/soc-core.c	2009-09-14 20:06:37.000000000 +0100
@@ -351,10 +351,16 @@
 	cpu_dai->runtime = NULL;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		/* start delayed pop wq here for playback streams */
-		codec_dai->pop_wait = 1;
-		schedule_delayed_work(&pcm_link->delayed_work,
-			msecs_to_jiffies(pmdown_time));
+		if (codec->dapm_state == SNDRV_CTL_POWER_D0) {
+			/* start delayed pop wq here for playback streams */
+			codec_dai->pop_wait = 1;
+			schedule_delayed_work(&pcm_link->delayed_work,
+					      msecs_to_jiffies(pmdown_time));
+		}
+		else {
+			snd_soc_dapm_device_event(pcm_link,
+						  SNDRV_CTL_POWER_D3hot);
+		}
 	} else {
 		/* capture streams can be powered down now */
 		snd_soc_dapm_stream_event(machine,
