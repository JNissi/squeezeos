Index: linux-2.6.26/arch/arm/mach-mx25/mx25_baby_gpio.c
===================================================================
--- linux-2.6.26.orig/arch/arm/mach-mx25/mx25_baby_gpio.c	2009-09-09 08:43:57.000000000 -0700
+++ linux-2.6.26/arch/arm/mach-mx25/mx25_baby_gpio.c	2009-09-09 08:44:45.000000000 -0700
@@ -38,6 +38,7 @@
 {
 	/* MCLK uses CLKO */
 	mxc_request_iomux(MX25_PIN_CLKO,  	    MUX_CONFIG_FUNC);
+	mxc_iomux_set_pad(MX25_PIN_CLKO, PAD_CTL_DRV_NORMAL);
 
 	mxc_request_iomux(BABY_DAC_SDIN,  	    MUX_CONFIG_ALT1);
 	mxc_request_iomux(BABY_DAC_SDOUT, 	    MUX_CONFIG_ALT1);
Index: linux-2.6.26/sound/soc/codecs/tlv320aic3104.c
===================================================================
--- linux-2.6.26.orig/sound/soc/codecs/tlv320aic3104.c	2009-09-09 08:44:27.000000000 -0700
+++ linux-2.6.26/sound/soc/codecs/tlv320aic3104.c	2009-09-09 08:52:46.000000000 -0700
@@ -183,8 +183,10 @@
 			     unsigned int value)
 {
 	struct aic3104_priv *aic3104 = codec->private_data;
-        u8 data[2];
+        u8 data[3];
 	int page, len;
+	u8 data_read[2];
+	int value_read;
 
         mutex_lock(&aic3104->lock);
 
@@ -207,24 +209,34 @@
 	 *   D7...D0 register data
 	 */
 	/* effects registers must be written MSB followed by LSB */
+	//printk("******:  set %d = 0x%16x\n", reg, value);
 	if (reg & WRITE_WORD) {
 		data[0] = (reg & 0x7f);
 		data[1] = (value >> 8) & 0xff;
+		data[2] =  value & 0xff;
 
-		//printk("AIC3104 MSB WRITE %d: %08x\n", data[0], data[1]);
+		// printk("AIC3104 WRITE (REG,REG+1)=(MSB,LSB): (%d:%d)=(%02x:%02x)\n", data[0], data[0]+1, data[1], data[2]);
 
-		aic3104_write_reg_cache(codec, reg, data[1]);
-		len = codec->mach_write(codec->control_data, (long)data, 2);
-		if (len != 2)
+		aic3104_write_reg_cache(codec, reg,     data[1]);
+		aic3104_write_reg_cache(codec, reg + 1, data[2]);
+		len = codec->mach_write(codec->control_data, (long)data, 3);
+		if (len != 3)
 			goto write_err;
-
-		data[0] = (reg & 0x7f) + 1;
-		data[1] = value & 0xff;
-
-		//printk("AIC3104 LSB WRITE %d: %08x\n", data[0], data[1]);
-
-		aic3104_write_reg_cache(codec, reg + 1, data[1]);
-		len = codec->mach_write(codec->control_data, (long)data, 2);
+		data_read[0] = reg;
+		data_read[1] = 0;
+		aic3104_i2c_read(codec->control_data, (long)data_read, 1);
+		value_read = data_read[1] << 8;
+		data_read[0] = reg+1;
+		data_read[1] = 0;
+		aic3104_i2c_read(codec->control_data, (long)data_read, 1);
+		value_read |= data_read[1];
+		if ((value_read != value) &&
+		    (reg != 11)&&
+		    (reg != 1) &&
+		    (reg != 25)
+			) {
+			printk("***********\n******** Error writing to reg %d: writing 0x%x, but read 0x%x\n******\n", reg, value, value_read);
+		}
 	}
 	else {
 		data[0] = reg & 0x7f;
@@ -236,8 +248,19 @@
 
 		aic3104_write_reg_cache(codec, reg, value);
 		len = codec->mach_write(codec->control_data, (long)data, 2);
-	}
 
+		data_read[0] = reg;
+		data_read[1] = 0;
+		aic3104_i2c_read(codec->control_data, (long)data_read, 1);
+		value_read = data_read[1];
+		if ((value_read != value) &&
+		    (reg != 11) &&
+		    (reg != 1)  &&
+		    (reg != 25)
+			) {
+			printk("***********\n******** Error writing to reg %d: writing 0x%x, but read 0x%x\n*******\n", reg, value, value_read);
+		}
+	}
 	if (len != 2)
 		goto write_err;
 
@@ -275,6 +298,9 @@
         mutex_lock(&aic3104->lock);
 
 	page = reg >> 7;
+	if (page != 0) {
+		printk("*****\n***** HEY!  PAge is not 0\n****\n");
+	}
 	if (page != aic3104->reg_page) {
 		data[0] = 0;
 		data[1] = page;
@@ -1064,56 +1090,32 @@
 
 /* AIC3104 codec mclk clock divider coefficients */
 static const struct aic3104_rate_divs aic3104_divs[] = {
+	/* FIXME:
+	 * For now, Only support 44.1 and 48k with 12MHz clock.
+	 * This is because the DSP filters need to run at
+	 * that rate.
+	 */
+
 	/* 8k */
-	{12000000, 8000, 48000, 0xa, 16, 3840},
-	{19200000, 8000, 48000, 0xa, 10, 2400},
-	{22579200, 8000, 48000, 0xa, 8, 7075},
-	{33868800, 8000, 48000, 0xa, 5, 8049},
+	//{12000000, 8000, 48000, 0xa, 16, 3840},
 	/* 11.025k */
-	{12000000, 11025, 44100, 0x6, 15, 528},
-	{19200000, 11025, 44100, 0x6, 9, 4080},
-	{22579200, 11025, 44100, 0x6, 8, 0},
-	{33868800, 11025, 44100, 0x6, 5, 3333},
+	//{12000000, 11025, 44100, 0x6, 15, 528},
 	/* 16k */
-	{12000000, 16000, 48000, 0x4, 16, 3840},
-	{19200000, 16000, 48000, 0x4, 10, 2400},
-	{22579200, 16000, 48000, 0x4, 8, 7075},
-	{33868800, 16000, 48000, 0x4, 5, 8049},
+	//{12000000, 16000, 48000, 0x4, 16, 3840},
 	/* 22.05k */
-	{12000000, 22050, 44100, 0x2, 15, 528},
-	{19200000, 22050, 44100, 0x2, 9, 4080},
-	{22579200, 22050, 44100, 0x2, 8, 0},
-	{33868800, 22050, 44100, 0x2, 5, 3333},
+	//{12000000, 22050, 44100, 0x2, 15, 528},
 	/* 32k */
-	{12000000, 32000, 48000, 0x1, 16, 3840},
-	{19200000, 32000, 48000, 0x1, 10, 2400},
-	{22579200, 32000, 48000, 0x1, 8, 7075},
-	{33868800, 32000, 48000, 0x1, 5, 8049},
+	//{12000000, 32000, 48000, 0x1, 16, 3840},
 	/* 44.1k */
-	{12000000, 44100, 44100, 0x0, 15, 528},
-	{19200000, 44100, 44100, 0x0, 9, 4080},
-	{22579200, 44100, 44100, 0x0, 8, 0},
-	{33868800, 44100, 44100, 0x0, 5, 3333},
+	{12000000, 44100, 44100, 0x0, 7, 5264},
 	/* 48k */
-	{12000000, 48000, 48000, 0x0, 16, 3840},
-	{19200000, 48000, 48000, 0x0, 10, 2400},
-	{22579200, 48000, 48000, 0x0, 8, 7075},
-	{33868800, 48000, 48000, 0x0, 5, 8049},
+	{12000000, 48000, 48000, 0x0, 8, 1920},
 	/* 64k */
-	{12000000, 64000, 96000, 0x1, 16, 3840},
-	{19200000, 64000, 96000, 0x1, 10, 2400},
-	{22579200, 64000, 96000, 0x1, 8, 7075},
-	{33868800, 64000, 96000, 0x1, 5, 8049},
+	//{12000000, 64000, 96000, 0x1, 16, 3840},
 	/* 88.2k */
-	{12000000, 88200, 88200, 0x0, 15, 528},
-	{19200000, 88200, 88200, 0x0, 9, 4080},
-	{22579200, 88200, 88200, 0x0, 8, 0},
-	{33868800, 88200, 88200, 0x0, 5, 3333},
+	//{12000000, 88200, 88200, 0x0, 15, 528},
 	/* 96k */
-	{12000000, 96000, 96000, 0x0, 16, 3840},
-	{19200000, 96000, 96000, 0x0, 10, 2400},
-	{22579200, 96000, 96000, 0x0, 8, 7075},
-	{33868800, 96000, 96000, 0x0, 5, 8049},
+	//{12000000, 96000, 96000, 0x0, 16, 3840},
 };
 
 static inline int aic3104_get_divs(int mclk, int rate)
@@ -1160,39 +1162,92 @@
 		data |= FSREF_48000 | DUAL_RATE_MODE;
 		break;
 	}
-	aic3104_write_reg(codec, AIC3X_CODEC_DATAPATH_REG, data);
+	aic3104_write_reg(codec, AIC3X_CODEC_DATAPATH_REG, data); /*  reg 7 */
 
 	/* codec sample rate select */
 	data = aic3104_divs[i].sr_reg;
 	data |= (data << 4);
-	aic3104_write_reg(codec, AIC3X_SAMPLE_RATE_SEL_REG, data);
+	aic3104_write_reg(codec, AIC3X_SAMPLE_RATE_SEL_REG, data); /* reg 2 */
 
 	/* Use PLL for generation Fsref by equation:
 	 * Fsref = (MCLK * K * R)/(2048 * P);
-	 * Fix P = 2 and R = 1 and calculate K, if
+	 * Fix P = 1 and R = 1 and calculate K, if
 	 * K = J.D, i.e. J - an interger portion of K and D is the fractional
 	 * one with 4 digits of precision;
 	 * Example:
-	 * For MCLK = 22.5792 MHz and Fsref = 48kHz:
-	 * Select P = 2, R= 1, K = 8.7074, which results in J = 8, D = 7074
+	 * Our MCLK is 12MHz, therefore P must be 1 (page 29 of aic3104 datasheet)
+	 *
+	 **************
+	 * Restrictions:
+	 * 10 MHz <= PLLCLK_IN/P <= 20 MHz
+	 * 80 MHz <= PLLCLK_IN x K x R/P <= 110 MHz
+	 * 4 <= J <= 11
+	 * R = 1
+	 **************
+	 * Example:
+	 * MCLK = 12 MHz and fS(ref) = 44.1 kHz
+	 * Select P = 1, R = 1, K = 7.5264, which results in J = 7, D = 5264
+	 * Example:
+	 * MCLK = 12 MHz and fS(ref) = 48 kHz
+	 * Select P = 1, R = 1, K = 8.192, which results in J = 8, D = 1920
+	 **************
 	 */
-	pll_p = 2;
+	pll_p = 1;
 	pll_r = 1;
 	pll_j = aic3104_divs[i].pllj_reg;
 	pll_d = aic3104_divs[i].plld_reg;
 
-	data = aic3104_read_reg_cache(codec, AIC3X_PLL_PROGA_REG);
-	aic3104_write_reg(codec, AIC3X_PLL_PROGA_REG, data | (pll_p << PLLP_SHIFT));
-	aic3104_write_reg(codec, AIC3X_OVRF_STATUS_AND_PLLR_REG, pll_r << PLLR_SHIFT);
-	aic3104_write_reg(codec, AIC3X_PLL_PROGB_REG, pll_j << PLLJ_SHIFT);
-	aic3104_write_reg(codec, AIC3X_PLL_PROGC_REG, (pll_d >> 6) << PLLD_MSB_SHIFT);
-	aic3104_write_reg(codec, AIC3X_PLL_PROGD_REG, (pll_d & 0x3F) << PLLD_LSB_SHIFT);
-
-	if (aic3104->master) {
-		/* enable pll */
-		data = aic3104_read_reg_cache(codec, AIC3X_PLL_PROGA_REG);
-		aic3104_write_reg(codec, AIC3X_PLL_PROGA_REG, data | PLL_ENABLE);
+#if 0
+	/* This is a stress-testing debug block that
+	 * exercises the I2C buss.
+	 * We didn't find even a single bit error with thousands of writes.
+	 * We also tested a slower I2C clock speed, and a delay between
+	 * writes.  No change in the intermittent DAC clock stop.
+	 */
+	{
+		int i;
+		int val = 0;
+		int error = 0;
+		printk("#### Stress testing\n\n");
+		for (i = 0; i < 100; i++) {
+			aic3104_write_reg(codec, 47, 0xaa);
+			val = aic3104_read_reg(codec,  47);
+			if (val != 0xaa) {
+				printk("**** \n**** ERROR WRITING REGISTER:  wrote 0xAA but read 0x%02x\n**** \n", val);
+				error++;
+			}
+			aic3104_write_reg(codec, 47, 0x55);
+			val = aic3104_read_reg(codec,  47);
+			if (val != 0x55) {
+				printk("**** \n**** ERROR WRITING REGISTER:  wrote 0x55 but read 0x%02x\n**** \n", val);
+				error++;
+			}
+		}
+		if (error) {
+			printk("**** Found a total of %d errors\n", error);
+		}
+		printk("#### Stress testing complete\n\n\n");
 	}
+#endif
+	aic3104_write_reg(codec, 15, (1 << 7)); /* PGA mute */
+	aic3104_write_reg(codec, 16, (1 << 7)); /* PGA mute */
+	aic3104_write_reg(codec, 19, 0); /* left ADC power down */
+	aic3104_write_reg(codec, 22, 0); /* right adc power down */
+	aic3104_write_reg(codec, 37, 0); /* left&right DAC power down */
+	aic3104_write_reg(codec, 101,                             1);                                  /* reg 101: switch to clkin */
+	aic3104_write_reg(codec, AIC3X_PLL_PROGA_REG, 		  (2 << 3));                           /* reg 3  : disable PLL (set to reset value) */
+	aic3104_write_reg(codec, AIC3X_PLL_PROGA_REG, 		  (2 << 3) | (pll_p << PLLP_SHIFT));   /* reg 3  : write P and default Q */
+	aic3104_write_reg(codec, AIC3X_OVRF_STATUS_AND_PLLR_REG,  pll_r << PLLR_SHIFT);    	       /* reg 11 */
+	aic3104_write_reg(codec, AIC3X_PLL_PROGB_REG,             pll_j << PLLJ_SHIFT);       	       /* reg 4  */
+	aic3104_write_reg(codec, WRITE_WORD | AIC3X_PLL_PROGC_REG,(pll_d << 2));                       /* reg 6  */
+
+	aic3104_write_reg(codec, 19, (1<<2)); /* left ADC power up */
+	aic3104_write_reg(codec, 22, (1<<2)); /* right adc power up */
+	aic3104_write_reg(codec, 15, 0); /* PGA unmute */
+	aic3104_write_reg(codec, 16, 0); /* PGA unmute */
+	aic3104_write_reg(codec, 37, (3 << 6)); /* left&right DAC power up */
+	// aic3104_write_reg(codec, 101, 0); /* reg 101: switch to pll */
+
 
 	/* select data word length */
 	data = aic3104_read_reg_cache(codec, AIC3X_ASD_INTF_CTRLB) & (~(0x3 << 4));
@@ -1215,6 +1270,12 @@
 #endif
 	aic3104_write_reg(codec, AIC3X_ASD_INTF_CTRLB, data);
 
+	if (aic3104->master) {
+		/* enable pll */
+		data = aic3104_read_reg_cache(codec, AIC3X_PLL_PROGA_REG);
+		aic3104_write_reg(codec, AIC3X_PLL_PROGA_REG, data | PLL_ENABLE);
+	}
+
 	return 0;
 }
 
