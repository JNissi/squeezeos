From e35c95b4d73dff961780732894e68da30d4f6e17 Mon Sep 17 00:00:00 2001
From: Erez_Zadok <ezk@cs.sunysb.edu>
Date: Sun, 10 Jun 2007 19:04:30 -0400
Subject: [PATCH] cleanup: convert all instances of "hidden" to "lower".

The unionfs code contained many references to symbols whose name had the
string "hidden" in it, referring to, for example, a "hidden inode" below the
unionfs inode.  The term "hidden" was there for historical reasons and was a
misnomer, implying that the objects at unionfs's lower branches were somehow
hidden or unavailable.  This was not just incorrect, but confusing.  The
lower objects are just that: lower.  They are not hidden from users.  In
fact, users can 'cd' to lower branches and manipulate files directly there.
This long patch renames all such mis-named symbols, and re-indents the code
as needed to comply with coding standards.

Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
---
 fs/unionfs/commonfops.c |  182 +++++++++++++-------------
 fs/unionfs/copyup.c     |  212 +++++++++++++++---------------
 fs/unionfs/debug.c      |   14 +-
 fs/unionfs/dentry.c     |   28 ++--
 fs/unionfs/dirfops.c    |   14 +-
 fs/unionfs/dirhelper.c  |   84 ++++++------
 fs/unionfs/fanout.h     |   14 +-
 fs/unionfs/inode.c      |  334 +++++++++++++++++++++++-----------------------
 fs/unionfs/lookup.c     |  142 ++++++++++----------
 fs/unionfs/main.c       |  174 ++++++++++++------------
 fs/unionfs/rdstate.c    |    8 +-
 fs/unionfs/rename.c     |  104 ++++++++--------
 fs/unionfs/subr.c       |  102 +++++++-------
 fs/unionfs/super.c      |   38 +++---
 fs/unionfs/union.h      |   16 +-
 fs/unionfs/unlink.c     |   46 ++++----
 fs/unionfs/xattr.c      |   24 ++--
 17 files changed, 768 insertions(+), 768 deletions(-)

diff --git a/fs/unionfs/commonfops.c b/fs/unionfs/commonfops.c
index 900887e..8e47e92 100644
--- a/fs/unionfs/commonfops.c
+++ b/fs/unionfs/commonfops.c
@@ -33,13 +33,13 @@ static int copyup_deleted_file(struct file *file, struct dentry *dentry,
 	char name[nlen + 1];
 	int err;
 	struct dentry *tmp_dentry = NULL;
-	struct dentry *hidden_dentry;
-	struct dentry *hidden_dir_dentry = NULL;
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry = NULL;
 
-	hidden_dentry = unionfs_lower_dentry_idx(dentry, bstart);
+	lower_dentry = unionfs_lower_dentry_idx(dentry, bstart);
 
 	sprintf(name, ".unionfs%*.*lx",
-		i_inosize, i_inosize, hidden_dentry->d_inode->i_ino);
+		i_inosize, i_inosize, lower_dentry->d_inode->i_ino);
 
 	/*
 	 * Loop, looking for an unused temp name to copyup to.
@@ -62,7 +62,7 @@ retry:
 		printk(KERN_DEBUG "unionfs: trying to rename %s to %s\n",
 		       dentry->d_name.name, name);
 
-		tmp_dentry = lookup_one_len(name, hidden_dentry->d_parent,
+		tmp_dentry = lookup_one_len(name, lower_dentry->d_parent,
 					    nlen);
 		if (IS_ERR(tmp_dentry)) {
 			err = PTR_ERR(tmp_dentry);
@@ -81,15 +81,15 @@ retry:
 	}
 
 	/* bring it to the same state as an unlinked file */
-	hidden_dentry = unionfs_lower_dentry_idx(dentry, dbstart(dentry));
+	lower_dentry = unionfs_lower_dentry_idx(dentry, dbstart(dentry));
 	if (!unionfs_lower_inode_idx(dentry->d_inode, bindex)) {
-		atomic_inc(&hidden_dentry->d_inode->i_count);
+		atomic_inc(&lower_dentry->d_inode->i_count);
 		unionfs_set_lower_inode_idx(dentry->d_inode, bindex,
-					    hidden_dentry->d_inode);
+					    lower_dentry->d_inode);
 	}
-	hidden_dir_dentry = lock_parent(hidden_dentry);
-	err = vfs_unlink(hidden_dir_dentry->d_inode, hidden_dentry);
-	unlock_dir(hidden_dir_dentry);
+	lower_dir_dentry = lock_parent(lower_dentry);
+	err = vfs_unlink(lower_dir_dentry->d_inode, lower_dentry);
+	unlock_dir(lower_dir_dentry);
 
 out:
 	if (!err)
@@ -157,8 +157,8 @@ static void cleanup_file(struct file *file)
 static int open_all_files(struct file *file)
 {
 	int bindex, bstart, bend, err = 0;
-	struct file *hidden_file;
-	struct dentry *hidden_dentry;
+	struct file *lower_file;
+	struct dentry *lower_dentry;
 	struct dentry *dentry = file->f_dentry;
 	struct super_block *sb = dentry->d_sb;
 
@@ -166,25 +166,25 @@ static int open_all_files(struct file *file)
 	bend = dbend(dentry);
 
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-		if (!hidden_dentry)
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
 			continue;
 
-		dget(hidden_dentry);
+		dget(lower_dentry);
 		unionfs_mntget(dentry, bindex);
 		unionfs_read_lock(sb);
 		branchget(sb, bindex);
 		unionfs_read_unlock(sb);
 
-		hidden_file =
-			dentry_open(hidden_dentry,
+		lower_file =
+			dentry_open(lower_dentry,
 				    unionfs_lower_mnt_idx(dentry, bindex),
 				    file->f_flags);
-		if (IS_ERR(hidden_file)) {
-			err = PTR_ERR(hidden_file);
+		if (IS_ERR(lower_file)) {
+			err = PTR_ERR(lower_file);
 			goto out;
 		} else
-			unionfs_set_lower_file_idx(file, bindex, hidden_file);
+			unionfs_set_lower_file_idx(file, bindex, lower_file);
 	}
 out:
 	return err;
@@ -194,8 +194,8 @@ out:
 static int open_highest_file(struct file *file, int willwrite)
 {
 	int bindex, bstart, bend, err = 0;
-	struct file *hidden_file;
-	struct dentry *hidden_dentry;
+	struct file *lower_file;
+	struct dentry *lower_dentry;
 	struct dentry *dentry = file->f_dentry;
 	struct inode *parent_inode = dentry->d_parent->d_inode;
 	struct super_block *sb = dentry->d_sb;
@@ -204,7 +204,7 @@ static int open_highest_file(struct file *file, int willwrite)
 	bstart = dbstart(dentry);
 	bend = dbend(dentry);
 
-	hidden_dentry = unionfs_lower_dentry(dentry);
+	lower_dentry = unionfs_lower_dentry(dentry);
 	if (willwrite && IS_WRITE_FLAG(file->f_flags) && is_robranch(dentry)) {
 		for (bindex = bstart - 1; bindex >= 0; bindex--) {
 			err = copyup_file(parent_inode, file, bstart, bindex,
@@ -218,23 +218,23 @@ static int open_highest_file(struct file *file, int willwrite)
 		goto out;
 	}
 
-	dget(hidden_dentry);
+	dget(lower_dentry);
 	unionfs_mntget(dentry, bstart);
 	unionfs_read_lock(sb);
 	branchget(sb, bstart);
 	unionfs_read_unlock(sb);
-	hidden_file = dentry_open(hidden_dentry,
-				  unionfs_lower_mnt_idx(dentry, bstart),
-				  file->f_flags);
-	if (IS_ERR(hidden_file)) {
-		err = PTR_ERR(hidden_file);
+	lower_file = dentry_open(lower_dentry,
+				 unionfs_lower_mnt_idx(dentry, bstart),
+				 file->f_flags);
+	if (IS_ERR(lower_file)) {
+		err = PTR_ERR(lower_file);
 		goto out;
 	}
-	unionfs_set_lower_file(file, hidden_file);
+	unionfs_set_lower_file(file, lower_file);
 	/* Fix up the position. */
-	hidden_file->f_pos = file->f_pos;
+	lower_file->f_pos = file->f_pos;
 
-	memcpy(&hidden_file->f_ra, &file->f_ra, sizeof(struct file_ra_state));
+	memcpy(&lower_file->f_ra, &file->f_ra, sizeof(struct file_ra_state));
 out:
 	return err;
 }
@@ -402,29 +402,29 @@ out_nofree:
 /* unionfs_open helper function: open a directory */
 static int __open_dir(struct inode *inode, struct file *file)
 {
-	struct dentry *hidden_dentry;
-	struct file *hidden_file;
+	struct dentry *lower_dentry;
+	struct file *lower_file;
 	int bindex, bstart, bend;
 
 	bstart = fbstart(file) = dbstart(file->f_dentry);
 	bend = fbend(file) = dbend(file->f_dentry);
 
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_dentry =
+		lower_dentry =
 			unionfs_lower_dentry_idx(file->f_dentry, bindex);
-		if (!hidden_dentry)
+		if (!lower_dentry)
 			continue;
 
-		dget(hidden_dentry);
+		dget(lower_dentry);
 		unionfs_mntget(file->f_dentry, bindex);
-		hidden_file = dentry_open(hidden_dentry,
-					  unionfs_lower_mnt_idx(file->f_dentry,
-								bindex),
-					  file->f_flags);
-		if (IS_ERR(hidden_file))
-			return PTR_ERR(hidden_file);
+		lower_file = dentry_open(lower_dentry,
+					 unionfs_lower_mnt_idx(file->f_dentry,
+							       bindex),
+					 file->f_flags);
+		if (IS_ERR(lower_file))
+			return PTR_ERR(lower_file);
 
-		unionfs_set_lower_file_idx(file, bindex, hidden_file);
+		unionfs_set_lower_file_idx(file, bindex, lower_file);
 
 		/*
 		 * The branchget goes after the open, because otherwise
@@ -441,27 +441,27 @@ static int __open_dir(struct inode *inode, struct file *file)
 /* unionfs_open helper function: open a file */
 static int __open_file(struct inode *inode, struct file *file)
 {
-	struct dentry *hidden_dentry;
-	struct file *hidden_file;
-	int hidden_flags;
+	struct dentry *lower_dentry;
+	struct file *lower_file;
+	int lower_flags;
 	int bindex, bstart, bend;
 
-	hidden_dentry = unionfs_lower_dentry(file->f_dentry);
-	hidden_flags = file->f_flags;
+	lower_dentry = unionfs_lower_dentry(file->f_dentry);
+	lower_flags = file->f_flags;
 
 	bstart = fbstart(file) = dbstart(file->f_dentry);
 	bend = fbend(file) = dbend(file->f_dentry);
 
 	/*
-	 * check for the permission for hidden file.  If the error is
+	 * check for the permission for lower file.  If the error is
 	 * COPYUP_ERR, copyup the file.
 	 */
-	if (hidden_dentry->d_inode && is_robranch(file->f_dentry)) {
+	if (lower_dentry->d_inode && is_robranch(file->f_dentry)) {
 		/*
 		 * if the open will change the file, copy it up otherwise
 		 * defer it.
 		 */
-		if (hidden_flags & O_TRUNC) {
+		if (lower_flags & O_TRUNC) {
 			int size = 0;
 			int err = -EROFS;
 
@@ -475,24 +475,24 @@ static int __open_file(struct inode *inode, struct file *file)
 			}
 			return err;
 		} else
-			hidden_flags &= ~(OPEN_WRITE_FLAGS);
+			lower_flags &= ~(OPEN_WRITE_FLAGS);
 	}
 
-	dget(hidden_dentry);
+	dget(lower_dentry);
 
 	/*
 	 * dentry_open will decrement mnt refcnt if err.
 	 * otherwise fput() will do an mntput() for us upon file close.
 	 */
 	unionfs_mntget(file->f_dentry, bstart);
-	hidden_file =
-		dentry_open(hidden_dentry,
+	lower_file =
+		dentry_open(lower_dentry,
 			    unionfs_lower_mnt_idx(file->f_dentry, bstart),
-			    hidden_flags);
-	if (IS_ERR(hidden_file))
-		return PTR_ERR(hidden_file);
+			    lower_flags);
+	if (IS_ERR(lower_file))
+		return PTR_ERR(lower_file);
 
-	unionfs_set_lower_file(file, hidden_file);
+	unionfs_set_lower_file(file, lower_file);
 	unionfs_read_lock(inode->i_sb);
 	branchget(inode->i_sb, bstart);
 	unionfs_read_unlock(inode->i_sb);
@@ -503,7 +503,7 @@ static int __open_file(struct inode *inode, struct file *file)
 int unionfs_open(struct inode *inode, struct file *file)
 {
 	int err = 0;
-	struct file *hidden_file = NULL;
+	struct file *lower_file = NULL;
 	struct dentry *dentry = NULL;
 	int bindex = 0, bstart = 0, bend = 0;
 	int size;
@@ -544,7 +544,7 @@ int unionfs_open(struct inode *inode, struct file *file)
 
 	/*
 	 * open all directories and make the unionfs file struct point to
-	 * these hidden file structs
+	 * these lower file structs
 	 */
 	if (S_ISDIR(inode->i_mode))
 		err = __open_dir(inode, file);	/* open a dir */
@@ -555,15 +555,15 @@ int unionfs_open(struct inode *inode, struct file *file)
 	if (err) {
 		atomic_dec(&UNIONFS_I(dentry->d_inode)->totalopens);
 		for (bindex = bstart; bindex <= bend; bindex++) {
-			hidden_file = unionfs_lower_file_idx(file, bindex);
-			if (!hidden_file)
+			lower_file = unionfs_lower_file_idx(file, bindex);
+			if (!lower_file)
 				continue;
 
 			unionfs_read_lock(file->f_dentry->d_sb);
 			branchput(file->f_dentry->d_sb, bindex);
 			unionfs_read_unlock(file->f_dentry->d_sb);
-			/* fput calls dput for hidden_dentry */
-			fput(hidden_file);
+			/* fput calls dput for lower_dentry */
+			fput(lower_file);
 		}
 	}
 
@@ -585,7 +585,7 @@ out_nofree:
 /* release all lower object references & free the file info structure */
 int unionfs_file_release(struct inode *inode, struct file *file)
 {
-	struct file *hidden_file = NULL;
+	struct file *lower_file = NULL;
 	struct unionfs_file_info *fileinfo;
 	struct unionfs_inode_info *inodeinfo;
 	struct super_block *sb = inode->i_sb;
@@ -605,16 +605,16 @@ int unionfs_file_release(struct inode *inode, struct file *file)
 	BUG_ON(file->f_dentry->d_inode != inode);
 	inodeinfo = UNIONFS_I(inode);
 
-	/* fput all the hidden files */
+	/* fput all the lower files */
 	fgen = atomic_read(&fileinfo->generation);
 	bstart = fbstart(file);
 	bend = fbend(file);
 
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_file = unionfs_lower_file_idx(file, bindex);
+		lower_file = unionfs_lower_file_idx(file, bindex);
 
-		if (hidden_file) {
-			fput(hidden_file);
+		if (lower_file) {
+			fput(lower_file);
 			unionfs_read_lock(sb);
 			branchput(sb, bindex);
 			unionfs_read_unlock(sb);
@@ -648,24 +648,24 @@ out:
 /* pass the ioctl to the lower fs */
 static long do_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct file *hidden_file;
+	struct file *lower_file;
 	int err;
 
-	hidden_file = unionfs_lower_file(file);
+	lower_file = unionfs_lower_file(file);
 
-	err = security_file_ioctl(hidden_file, cmd, arg);
+	err = security_file_ioctl(lower_file, cmd, arg);
 	if (err)
 		goto out;
 
 	err = -ENOTTY;
-	if (!hidden_file || !hidden_file->f_op)
+	if (!lower_file || !lower_file->f_op)
 		goto out;
-	if (hidden_file->f_op->unlocked_ioctl) {
-		err = hidden_file->f_op->unlocked_ioctl(hidden_file, cmd, arg);
-	} else if (hidden_file->f_op->ioctl) {
+	if (lower_file->f_op->unlocked_ioctl) {
+		err = lower_file->f_op->unlocked_ioctl(lower_file, cmd, arg);
+	} else if (lower_file->f_op->ioctl) {
 		lock_kernel();
-		err = hidden_file->f_op->ioctl(hidden_file->f_dentry->d_inode,
-					       hidden_file, cmd, arg);
+		err = lower_file->f_op->ioctl(lower_file->f_dentry->d_inode,
+					      lower_file, cmd, arg);
 		unlock_kernel();
 	}
 
@@ -686,7 +686,7 @@ static int unionfs_ioctl_queryfile(struct file *file, unsigned int cmd,
 	fd_set branchlist;
 	int bstart = 0, bend = 0, bindex = 0;
 	int orig_bstart, orig_bend;
-	struct dentry *dentry, *hidden_dentry;
+	struct dentry *dentry, *lower_dentry;
 	struct vfsmount *mnt;
 
 	dentry = file->f_dentry;
@@ -701,14 +701,14 @@ static int unionfs_ioctl_queryfile(struct file *file, unsigned int cmd,
 	FD_ZERO(&branchlist);
 
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-		if (!hidden_dentry)
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
 			continue;
-		if (hidden_dentry->d_inode)
+		if (lower_dentry->d_inode)
 			FD_SET(bindex, &branchlist);
 		/* purge any lower objects after partial_lookup */
 		if (bindex < orig_bstart || bindex > orig_bend) {
-			dput(hidden_dentry);
+			dput(lower_dentry);
 			unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
 			iput(unionfs_lower_inode_idx(dentry->d_inode, bindex));
 			unionfs_set_lower_inode_idx(dentry->d_inode, bindex,
@@ -772,7 +772,7 @@ out:
 int unionfs_flush(struct file *file, fl_owner_t id)
 {
 	int err = 0;
-	struct file *hidden_file = NULL;
+	struct file *lower_file = NULL;
 	struct dentry *dentry = file->f_dentry;
 	int bindex, bstart, bend;
 
@@ -790,11 +790,11 @@ int unionfs_flush(struct file *file, fl_owner_t id)
 	bstart = fbstart(file);
 	bend = fbend(file);
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_file = unionfs_lower_file_idx(file, bindex);
+		lower_file = unionfs_lower_file_idx(file, bindex);
 
-		if (hidden_file && hidden_file->f_op &&
-		    hidden_file->f_op->flush) {
-			err = hidden_file->f_op->flush(hidden_file, id);
+		if (lower_file && lower_file->f_op &&
+		    lower_file->f_op->flush) {
+			err = lower_file->f_op->flush(lower_file, id);
 			if (err)
 				goto out_lock;
 
diff --git a/fs/unionfs/copyup.c b/fs/unionfs/copyup.c
index bccd6dd..3a54699 100644
--- a/fs/unionfs/copyup.c
+++ b/fs/unionfs/copyup.c
@@ -25,8 +25,8 @@
 
 #ifdef CONFIG_UNION_FS_XATTR
 /* copyup all extended attrs for a given dentry */
-static int copyup_xattrs(struct dentry *old_hidden_dentry,
-			 struct dentry *new_hidden_dentry)
+static int copyup_xattrs(struct dentry *old_lower_dentry,
+			 struct dentry *new_lower_dentry)
 {
 	int err = 0;
 	ssize_t list_size = -1;
@@ -34,7 +34,7 @@ static int copyup_xattrs(struct dentry *old_hidden_dentry,
 	char *attr_value = NULL;
 	char *name_list_orig = NULL;
 
-	list_size = vfs_listxattr(old_hidden_dentry, NULL, 0);
+	list_size = vfs_listxattr(old_lower_dentry, NULL, 0);
 
 	if (list_size <= 0) {
 		err = list_size;
@@ -46,7 +46,7 @@ static int copyup_xattrs(struct dentry *old_hidden_dentry,
 		err = PTR_ERR(name_list);
 		goto out;
 	}
-	list_size = vfs_listxattr(old_hidden_dentry, name_list, list_size);
+	list_size = vfs_listxattr(old_lower_dentry, name_list, list_size);
 	attr_value = unionfs_xattr_alloc(XATTR_SIZE_MAX, XATTR_SIZE_MAX);
 	if (!attr_value || IS_ERR(attr_value)) {
 		err = PTR_ERR(name_list);
@@ -57,10 +57,10 @@ static int copyup_xattrs(struct dentry *old_hidden_dentry,
 		ssize_t size;
 
 		/* Lock here since vfs_getxattr doesn't lock for us */
-		mutex_lock(&old_hidden_dentry->d_inode->i_mutex);
-		size = vfs_getxattr(old_hidden_dentry, name_list,
+		mutex_lock(&old_lower_dentry->d_inode->i_mutex);
+		size = vfs_getxattr(old_lower_dentry, name_list,
 				    attr_value, XATTR_SIZE_MAX);
-		mutex_unlock(&old_hidden_dentry->d_inode->i_mutex);
+		mutex_unlock(&old_lower_dentry->d_inode->i_mutex);
 		if (size < 0) {
 			err = size;
 			goto out;
@@ -71,7 +71,7 @@ static int copyup_xattrs(struct dentry *old_hidden_dentry,
 			goto out;
 		}
 		/* Don't lock here since vfs_setxattr does it for us. */
-		err = vfs_setxattr(new_hidden_dentry, name_list, attr_value,
+		err = vfs_setxattr(new_lower_dentry, name_list, attr_value,
 				   size, 0);
 
 		if (err < 0)
@@ -94,10 +94,10 @@ out:
 
 /* Determine the mode based on the copyup flags, and the existing dentry. */
 static int copyup_permissions(struct super_block *sb,
-			      struct dentry *old_hidden_dentry,
-			      struct dentry *new_hidden_dentry)
+			      struct dentry *old_lower_dentry,
+			      struct dentry *new_lower_dentry)
 {
-	struct inode *i = old_hidden_dentry->d_inode;
+	struct inode *i = old_lower_dentry->d_inode;
 	struct iattr newattrs;
 	int err;
 
@@ -114,7 +114,7 @@ static int copyup_permissions(struct super_block *sb,
 		ATTR_ATIME_SET | ATTR_MTIME_SET | ATTR_FORCE |
 		ATTR_GID | ATTR_UID | ATTR_MODE;
 
-	err = notify_change(new_hidden_dentry, &newattrs);
+	err = notify_change(new_lower_dentry, &newattrs);
 
 	return err;
 }
@@ -126,25 +126,25 @@ static int copyup_permissions(struct super_block *sb,
  * if the object being copied up is a regular file, the file is only created,
  * the contents have to be copied up separately
  */
-static int __copyup_ndentry(struct dentry *old_hidden_dentry,
-			    struct dentry *new_hidden_dentry,
-			    struct dentry *new_hidden_parent_dentry,
+static int __copyup_ndentry(struct dentry *old_lower_dentry,
+			    struct dentry *new_lower_dentry,
+			    struct dentry *new_lower_parent_dentry,
 			    char *symbuf)
 {
 	int err = 0;
-	umode_t old_mode = old_hidden_dentry->d_inode->i_mode;
+	umode_t old_mode = old_lower_dentry->d_inode->i_mode;
 	struct sioq_args args;
 
 	if (S_ISDIR(old_mode)) {
-		args.mkdir.parent = new_hidden_parent_dentry->d_inode;
-		args.mkdir.dentry = new_hidden_dentry;
+		args.mkdir.parent = new_lower_parent_dentry->d_inode;
+		args.mkdir.dentry = new_lower_dentry;
 		args.mkdir.mode = old_mode;
 
 		run_sioq(__unionfs_mkdir, &args);
 		err = args.err;
 	} else if (S_ISLNK(old_mode)) {
-		args.symlink.parent = new_hidden_parent_dentry->d_inode;
-		args.symlink.dentry = new_hidden_dentry;
+		args.symlink.parent = new_lower_parent_dentry->d_inode;
+		args.symlink.dentry = new_lower_dentry;
 		args.symlink.symbuf = symbuf;
 		args.symlink.mode = old_mode;
 
@@ -152,16 +152,16 @@ static int __copyup_ndentry(struct dentry *old_hidden_dentry,
 		err = args.err;
 	} else if (S_ISBLK(old_mode) || S_ISCHR(old_mode) ||
 		   S_ISFIFO(old_mode) || S_ISSOCK(old_mode)) {
-		args.mknod.parent = new_hidden_parent_dentry->d_inode;
-		args.mknod.dentry = new_hidden_dentry;
+		args.mknod.parent = new_lower_parent_dentry->d_inode;
+		args.mknod.dentry = new_lower_dentry;
 		args.mknod.mode = old_mode;
-		args.mknod.dev = old_hidden_dentry->d_inode->i_rdev;
+		args.mknod.dev = old_lower_dentry->d_inode->i_rdev;
 
 		run_sioq(__unionfs_mknod, &args);
 		err = args.err;
 	} else if (S_ISREG(old_mode)) {
-		args.create.parent = new_hidden_parent_dentry->d_inode;
-		args.create.dentry = new_hidden_dentry;
+		args.create.parent = new_lower_parent_dentry->d_inode;
+		args.create.dentry = new_lower_dentry;
 		args.create.mode = old_mode;
 		args.create.nd = NULL;
 
@@ -177,8 +177,8 @@ static int __copyup_ndentry(struct dentry *old_hidden_dentry,
 }
 
 static int __copyup_reg_data(struct dentry *dentry,
-			     struct dentry *new_hidden_dentry, int new_bindex,
-			     struct dentry *old_hidden_dentry, int old_bindex,
+			     struct dentry *new_lower_dentry, int new_bindex,
+			     struct dentry *old_lower_dentry, int old_bindex,
 			     struct file **copyup_file, loff_t len)
 {
 	struct super_block *sb = dentry->d_sb;
@@ -197,11 +197,11 @@ static int __copyup_reg_data(struct dentry *dentry,
 	branchget(sb, old_bindex);
 	unionfs_read_unlock(sb);
 	/* dentry_open calls dput and mntput if it returns an error */
-	input_file = dentry_open(old_hidden_dentry,
+	input_file = dentry_open(old_lower_dentry,
 				 unionfs_lower_mnt_idx(dentry, old_bindex),
 				 O_RDONLY | O_LARGEFILE);
 	if (IS_ERR(input_file)) {
-		dput(old_hidden_dentry);
+		dput(old_lower_dentry);
 		err = PTR_ERR(input_file);
 		goto out;
 	}
@@ -211,12 +211,12 @@ static int __copyup_reg_data(struct dentry *dentry,
 	}
 
 	/* open new file */
-	dget(new_hidden_dentry);
+	dget(new_lower_dentry);
 	output_mnt = unionfs_mntget(sb->s_root, new_bindex);
 	unionfs_read_lock(sb);
 	branchget(sb, new_bindex);
 	unionfs_read_unlock(sb);
-	output_file = dentry_open(new_hidden_dentry, output_mnt,
+	output_file = dentry_open(new_lower_dentry, output_mnt,
 				  O_WRONLY | O_LARGEFILE);
 	if (IS_ERR(output_file)) {
 		err = PTR_ERR(output_file);
@@ -276,7 +276,7 @@ static int __copyup_reg_data(struct dentry *dentry,
 
 	if (!err)
 		err = output_file->f_op->fsync(output_file,
-					       new_hidden_dentry, 0);
+					       new_lower_dentry, 0);
 
 	if (err)
 		goto out_close_out;
@@ -309,17 +309,17 @@ out:
  * dput the lower references for old and new dentry & clear a lower dentry
  * pointer
  */
-static void __clear(struct dentry *dentry, struct dentry *old_hidden_dentry,
+static void __clear(struct dentry *dentry, struct dentry *old_lower_dentry,
 		    int old_bstart, int old_bend,
-		    struct dentry *new_hidden_dentry, int new_bindex)
+		    struct dentry *new_lower_dentry, int new_bindex)
 {
-	/* get rid of the hidden dentry and all its traces */
+	/* get rid of the lower dentry and all its traces */
 	unionfs_set_lower_dentry_idx(dentry, new_bindex, NULL);
 	set_dbstart(dentry, old_bstart);
 	set_dbend(dentry, old_bend);
 
-	dput(new_hidden_dentry);
-	dput(old_hidden_dentry);
+	dput(new_lower_dentry);
+	dput(old_lower_dentry);
 }
 
 /*
@@ -338,14 +338,14 @@ int copyup_dentry(struct inode *dir, struct dentry *dentry, int bstart,
 		  int new_bindex, const char *name, int namelen,
 		  struct file **copyup_file, loff_t len)
 {
-	struct dentry *new_hidden_dentry;
-	struct dentry *old_hidden_dentry = NULL;
+	struct dentry *new_lower_dentry;
+	struct dentry *old_lower_dentry = NULL;
 	struct super_block *sb;
 	int err = 0;
 	int old_bindex;
 	int old_bstart;
 	int old_bend;
-	struct dentry *new_hidden_parent_dentry = NULL;
+	struct dentry *new_lower_parent_dentry = NULL;
 	mm_segment_t oldfs;
 	char *symbuf = NULL;
 
@@ -364,74 +364,74 @@ int copyup_dentry(struct inode *dir, struct dentry *dentry, int bstart,
 		goto out;
 
 	/* Create the directory structure above this dentry. */
-	new_hidden_dentry = create_parents(dir, dentry, name, new_bindex);
-	if (IS_ERR(new_hidden_dentry)) {
-		err = PTR_ERR(new_hidden_dentry);
+	new_lower_dentry = create_parents(dir, dentry, name, new_bindex);
+	if (IS_ERR(new_lower_dentry)) {
+		err = PTR_ERR(new_lower_dentry);
 		goto out;
 	}
 
-	old_hidden_dentry = unionfs_lower_dentry_idx(dentry, old_bindex);
-	/* we conditionally dput this old_hidden_dentry at end of function */
-	dget(old_hidden_dentry);
+	old_lower_dentry = unionfs_lower_dentry_idx(dentry, old_bindex);
+	/* we conditionally dput this old_lower_dentry at end of function */
+	dget(old_lower_dentry);
 
 	/* For symlinks, we must read the link before we lock the directory. */
-	if (S_ISLNK(old_hidden_dentry->d_inode->i_mode)) {
+	if (S_ISLNK(old_lower_dentry->d_inode->i_mode)) {
 
 		symbuf = kmalloc(PATH_MAX, GFP_KERNEL);
 		if (!symbuf) {
-			__clear(dentry, old_hidden_dentry,
+			__clear(dentry, old_lower_dentry,
 				old_bstart, old_bend,
-				new_hidden_dentry, new_bindex);
+				new_lower_dentry, new_bindex);
 			err = -ENOMEM;
 			goto out_free;
 		}
 
 		oldfs = get_fs();
 		set_fs(KERNEL_DS);
-		err = old_hidden_dentry->d_inode->i_op->readlink(
-			old_hidden_dentry,
+		err = old_lower_dentry->d_inode->i_op->readlink(
+			old_lower_dentry,
 			(char __user *)symbuf,
 			PATH_MAX);
 		set_fs(oldfs);
 		if (err) {
-			__clear(dentry, old_hidden_dentry,
+			__clear(dentry, old_lower_dentry,
 				old_bstart, old_bend,
-				new_hidden_dentry, new_bindex);
+				new_lower_dentry, new_bindex);
 			goto out_free;
 		}
 		symbuf[err] = '\0';
 	}
 
 	/* Now we lock the parent, and create the object in the new branch. */
-	new_hidden_parent_dentry = lock_parent(new_hidden_dentry);
+	new_lower_parent_dentry = lock_parent(new_lower_dentry);
 
 	/* create the new inode */
-	err = __copyup_ndentry(old_hidden_dentry, new_hidden_dentry,
-			       new_hidden_parent_dentry, symbuf);
+	err = __copyup_ndentry(old_lower_dentry, new_lower_dentry,
+			       new_lower_parent_dentry, symbuf);
 
 	if (err) {
-		__clear(dentry, old_hidden_dentry,
+		__clear(dentry, old_lower_dentry,
 			old_bstart, old_bend,
-			new_hidden_dentry, new_bindex);
+			new_lower_dentry, new_bindex);
 		goto out_unlock;
 	}
 
 	/* We actually copyup the file here. */
-	if (S_ISREG(old_hidden_dentry->d_inode->i_mode))
-		err = __copyup_reg_data(dentry, new_hidden_dentry, new_bindex,
-					old_hidden_dentry, old_bindex,
+	if (S_ISREG(old_lower_dentry->d_inode->i_mode))
+		err = __copyup_reg_data(dentry, new_lower_dentry, new_bindex,
+					old_lower_dentry, old_bindex,
 					copyup_file, len);
 	if (err)
 		goto out_unlink;
 
 	/* Set permissions. */
-	if ((err = copyup_permissions(sb, old_hidden_dentry,
-				      new_hidden_dentry)))
+	if ((err = copyup_permissions(sb, old_lower_dentry,
+				      new_lower_dentry)))
 		goto out_unlink;
 
 #ifdef CONFIG_UNION_FS_XATTR
 	/* Selinux uses extended attributes for permissions. */
-	if ((err = copyup_xattrs(old_hidden_dentry, new_hidden_dentry)))
+	if ((err = copyup_xattrs(old_lower_dentry, new_lower_dentry)))
 		goto out_unlink;
 #endif /* CONFIG_UNION_FS_XATTR */
 
@@ -447,7 +447,7 @@ out_unlink:
 	 * quota, or something else happened so let's unlink; we don't
 	 * really care about the return value of vfs_unlink
 	 */
-	vfs_unlink(new_hidden_parent_dentry->d_inode, new_hidden_dentry);
+	vfs_unlink(new_lower_parent_dentry->d_inode, new_lower_dentry);
 
 	if (copyup_file) {
 		/* need to close the file */
@@ -467,17 +467,17 @@ out_unlink:
 	 */
 
 out_unlock:
-	unlock_dir(new_hidden_parent_dentry);
+	unlock_dir(new_lower_parent_dentry);
 
 out_free:
 	/*
-	 * If old_hidden_dentry was a directory, we need to dput it.  If it
+	 * If old_lower_dentry was a directory, we need to dput it.  If it
 	 * was a file, then it was already dput indirectly by other
 	 * functions we call above which operate on regular files.
 	 */
-	if (old_hidden_dentry && old_hidden_dentry->d_inode &&
-	    S_ISDIR(old_hidden_dentry->d_inode->i_mode))
-		dput(old_hidden_dentry);
+	if (old_lower_dentry && old_lower_dentry->d_inode &&
+	    S_ISDIR(old_lower_dentry->d_inode->i_mode))
+		dput(old_lower_dentry);
 	kfree(symbuf);
 
 	if (err)
@@ -489,7 +489,7 @@ out_free:
 			 * If we got here, then we copied up to an
 			 * unlinked-open file, whose name is .unionfsXXXXX.
 			 */
-			struct inode *inode = new_hidden_dentry->d_inode;
+			struct inode *inode = new_lower_dentry->d_inode;
 			atomic_inc(&inode->i_count);
 			unionfs_set_lower_inode_idx(dentry->d_inode,
 						    ibstart(dentry->d_inode),
@@ -631,8 +631,8 @@ struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
 	int err;
 	struct dentry *child_dentry;
 	struct dentry *parent_dentry;
-	struct dentry *hidden_parent_dentry = NULL;
-	struct dentry *hidden_dentry = NULL;
+	struct dentry *lower_parent_dentry = NULL;
+	struct dentry *lower_dentry = NULL;
 	const char *childname;
 	unsigned int childnamelen;
 	int nr_dentry;
@@ -645,14 +645,14 @@ struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
 	verify_locked(dentry);
 
 	if ((err = is_robranch_super(dir->i_sb, bindex))) {
-		hidden_dentry = ERR_PTR(err);
+		lower_dentry = ERR_PTR(err);
 		goto out;
 	}
 
 	old_bstart = dbstart(dentry);
 	old_bend = dbend(dentry);
 
-	hidden_dentry = ERR_PTR(-ENOMEM);
+	lower_dentry = ERR_PTR(-ENOMEM);
 
 	/* There is no sense allocating any less than the minimum. */
 	nr_dentry = 1;
@@ -679,8 +679,8 @@ struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
 		parent_dentry = child_dentry->d_parent;
 		unionfs_lock_dentry(parent_dentry);
 
-		/* find out the hidden_parent_dentry in the given branch */
-		hidden_parent_dentry =
+		/* find out the lower_parent_dentry in the given branch */
+		lower_parent_dentry =
 			unionfs_lower_dentry_idx(parent_dentry, bindex);
 
 		/* grow path table */
@@ -691,7 +691,7 @@ struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
 			p = krealloc(path, nr_dentry * sizeof(struct dentry *),
 				     GFP_KERNEL);
 			if (!p) {
-				hidden_dentry = ERR_PTR(-ENOMEM);
+				lower_dentry = ERR_PTR(-ENOMEM);
 				goto out;
 			}
 			path = p;
@@ -699,7 +699,7 @@ struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
 
 		/* store the child dentry */
 		path[count++] = child_dentry;
-	} while (!hidden_parent_dentry);
+	} while (!lower_parent_dentry);
 	count--;
 
 	sb = dentry->d_sb;
@@ -710,8 +710,8 @@ struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
 	 * shorter than what would be a much longer while loop.
 	 */
 begin:
-	/* get hidden parent dir in the current branch */
-	hidden_parent_dentry = unionfs_lower_dentry_idx(parent_dentry, bindex);
+	/* get lower parent dir in the current branch */
+	lower_parent_dentry = unionfs_lower_dentry_idx(parent_dentry, bindex);
 	unionfs_unlock_dentry(parent_dentry);
 
 	/* init the values to lookup */
@@ -720,43 +720,43 @@ begin:
 
 	if (child_dentry != dentry) {
 		/* lookup child in the underlying file system */
-		hidden_dentry = lookup_one_len(childname, hidden_parent_dentry,
-					       childnamelen);
-		if (IS_ERR(hidden_dentry))
+		lower_dentry = lookup_one_len(childname, lower_parent_dentry,
+					      childnamelen);
+		if (IS_ERR(lower_dentry))
 			goto out;
 	} else {
 		/*
 		 * Is the name a whiteout of the child name ?  lookup the
 		 * whiteout child in the underlying file system
 		 */
-		hidden_dentry = lookup_one_len(name, hidden_parent_dentry,
-					       strlen(name));
-		if (IS_ERR(hidden_dentry))
+		lower_dentry = lookup_one_len(name, lower_parent_dentry,
+					      strlen(name));
+		if (IS_ERR(lower_dentry))
 			goto out;
 
 		/* Replace the current dentry (if any) with the new one */
 		dput(unionfs_lower_dentry_idx(dentry, bindex));
 		unionfs_set_lower_dentry_idx(dentry, bindex,
-					     hidden_dentry);
+					     lower_dentry);
 
 		__cleanup_dentry(dentry, bindex, old_bstart, old_bend);
 		goto out;
 	}
 
-	if (hidden_dentry->d_inode) {
+	if (lower_dentry->d_inode) {
 		/*
 		 * since this already exists we dput to avoid
 		 * multiple references on the same dentry
 		 */
-		dput(hidden_dentry);
+		dput(lower_dentry);
 	} else {
 		struct sioq_args args;
 
 		/* it's a negative dentry, create a new dir */
-		hidden_parent_dentry = lock_parent(hidden_dentry);
+		lower_parent_dentry = lock_parent(lower_dentry);
 
-		args.mkdir.parent = hidden_parent_dentry->d_inode;
-		args.mkdir.dentry = hidden_dentry;
+		args.mkdir.parent = lower_parent_dentry->d_inode;
+		args.mkdir.dentry = lower_dentry;
 		args.mkdir.mode = child_dentry->d_inode->i_mode;
 
 		run_sioq(__unionfs_mkdir, &args);
@@ -764,42 +764,42 @@ begin:
 
 		if (!err)
 			err = copyup_permissions(dir->i_sb, child_dentry,
-						 hidden_dentry);
-		unlock_dir(hidden_parent_dentry);
+						 lower_dentry);
+		unlock_dir(lower_parent_dentry);
 		if (err) {
-			struct inode *inode = hidden_dentry->d_inode;
+			struct inode *inode = lower_dentry->d_inode;
 			/*
 			 * If we get here, it means that we created a new
 			 * dentry+inode, but copying permissions failed.
 			 * Therefore, we should delete this inode and dput
 			 * the dentry so as not to leave cruft behind.
 			 */
-			if (hidden_dentry->d_op && hidden_dentry->d_op->d_iput)
-				hidden_dentry->d_op->d_iput(hidden_dentry,
-							    inode);
+			if (lower_dentry->d_op && lower_dentry->d_op->d_iput)
+				lower_dentry->d_op->d_iput(lower_dentry,
+							   inode);
 			else
 				iput(inode);
-			hidden_dentry->d_inode = NULL;
-			dput(hidden_dentry);
-			hidden_dentry = ERR_PTR(err);
+			lower_dentry->d_inode = NULL;
+			dput(lower_dentry);
+			lower_dentry = ERR_PTR(err);
 			goto out;
 		}
 
 	}
 
-	__set_inode(child_dentry, hidden_dentry, bindex);
-	__set_dentry(child_dentry, hidden_dentry, bindex);
+	__set_inode(child_dentry, lower_dentry, bindex);
+	__set_dentry(child_dentry, lower_dentry, bindex);
 
 	parent_dentry = child_dentry;
 	child_dentry = path[--count];
 	goto begin;
 out:
 	/* cleanup any leftover locks from the do/while loop above */
-	if (IS_ERR(hidden_dentry))
+	if (IS_ERR(lower_dentry))
 		while (count)
 			unionfs_unlock_dentry(path[count--]);
 	kfree(path);
-	return hidden_dentry;
+	return lower_dentry;
 }
 
 /* set lower mnt of dentry+parents to the first parent node that has an mnt */
diff --git a/fs/unionfs/debug.c b/fs/unionfs/debug.c
index 2bfbd80..9255ebb 100644
--- a/fs/unionfs/debug.c
+++ b/fs/unionfs/debug.c
@@ -17,13 +17,13 @@
  */
 
 /* it's always useful to know what part of the code called us */
-#define PRINT_CALLER()				\
-do {						\
-  if (!printed_caller) {			\
-    printk("PC:%s:%s:%d\n",fname,fxn,line);	\
-    printed_caller = 1;				\
-  }						\
- } while (0)
+#define PRINT_CALLER()						\
+	do {							\
+		if (!printed_caller) {				\
+			printk("PC:%s:%s:%d\n",fname,fxn,line);	\
+			printed_caller = 1;			\
+		}						\
+	} while (0)
 
 /*
  * __unionfs_check_{inode,dentry,file} perform exhaustive sanity checking on
diff --git a/fs/unionfs/dentry.c b/fs/unionfs/dentry.c
index c9ff886..85f68f1 100644
--- a/fs/unionfs/dentry.c
+++ b/fs/unionfs/dentry.c
@@ -29,7 +29,7 @@ static int __unionfs_d_revalidate_one(struct dentry *dentry,
 				      struct nameidata *nd)
 {
 	int valid = 1;		/* default is valid (1); invalid is 0. */
-	struct dentry *hidden_dentry;
+	struct dentry *lower_dentry;
 	int bindex, bstart, bend;
 	int sbgen, dgen;
 	int positive = 0;
@@ -77,12 +77,12 @@ static int __unionfs_d_revalidate_one(struct dentry *dentry,
 		bstart = dbstart(dentry);
 		bend = dbend(dentry);
 		if (bstart >= 0) {
-			struct dentry *hidden_dentry;
+			struct dentry *lower_dentry;
 			for (bindex = bstart; bindex <= bend; bindex++) {
-				hidden_dentry =
+				lower_dentry =
 					unionfs_lower_dentry_idx(dentry,
 								 bindex);
-				dput(hidden_dentry);
+				dput(lower_dentry);
 			}
 		}
 		set_dbstart(dentry, -1);
@@ -105,14 +105,14 @@ static int __unionfs_d_revalidate_one(struct dentry *dentry,
 			bstart = ibstart(dentry->d_inode);
 			bend = ibend(dentry->d_inode);
 			if (bstart >= 0) {
-				struct inode *hidden_inode;
+				struct inode *lower_inode;
 				for (bindex = bstart; bindex <= bend;
 				     bindex++) {
-					hidden_inode =
+					lower_inode =
 						unionfs_lower_inode_idx(
 							dentry->d_inode,
 							bindex);
-					iput(hidden_inode);
+					iput(lower_inode);
 				}
 			}
 			kfree(UNIONFS_I(dentry->d_inode)->lower_inodes);
@@ -152,12 +152,12 @@ static int __unionfs_d_revalidate_one(struct dentry *dentry,
 	bend = dbend(dentry);
 	BUG_ON(bstart == -1);
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-		if (!hidden_dentry || !hidden_dentry->d_op
-		    || !hidden_dentry->d_op->d_revalidate)
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry || !lower_dentry->d_op
+		    || !lower_dentry->d_op->d_revalidate)
 			continue;
-		if (!hidden_dentry->d_op->d_revalidate(hidden_dentry,
-						       &lowernd))
+		if (!lower_dentry->d_op->d_revalidate(lower_dentry,
+						      &lowernd))
 			valid = 0;
 	}
 
@@ -314,13 +314,13 @@ static void unionfs_d_release(struct dentry *dentry)
 		goto out;
 	} else if (dbstart(dentry) < 0) {
 		/* this is due to a failed lookup */
-		printk(KERN_DEBUG "unionfs: dentry without hidden "
+		printk(KERN_DEBUG "unionfs: dentry without lower "
 		       "dentries: %.*s",
 		       dentry->d_name.len, dentry->d_name.name);
 		goto out_free;
 	}
 
-	/* Release all the hidden dentries */
+	/* Release all the lower dentries */
 	bstart = dbstart(dentry);
 	bend = dbend(dentry);
 	for (bindex = bstart; bindex <= bend; bindex++) {
diff --git a/fs/unionfs/dirfops.c b/fs/unionfs/dirfops.c
index 7306b3f..a7ba947 100644
--- a/fs/unionfs/dirfops.c
+++ b/fs/unionfs/dirfops.c
@@ -90,7 +90,7 @@ out:
 static int unionfs_readdir(struct file *file, void *dirent, filldir_t filldir)
 {
 	int err = 0;
-	struct file *hidden_file = NULL;
+	struct file *lower_file = NULL;
 	struct inode *inode = NULL;
 	struct unionfs_getdents_callback buf;
 	struct unionfs_dir_state *uds;
@@ -122,8 +122,8 @@ static int unionfs_readdir(struct file *file, void *dirent, filldir_t filldir)
 	bend = fbend(file);
 
 	while (uds->bindex <= bend) {
-		hidden_file = unionfs_lower_file_idx(file, uds->bindex);
-		if (!hidden_file) {
+		lower_file = unionfs_lower_file_idx(file, uds->bindex);
+		if (!lower_file) {
 			uds->bindex++;
 			uds->dirpos = 0;
 			continue;
@@ -139,15 +139,15 @@ static int unionfs_readdir(struct file *file, void *dirent, filldir_t filldir)
 		buf.sb = inode->i_sb;
 
 		/* Read starting from where we last left off. */
-		offset = vfs_llseek(hidden_file, uds->dirpos, SEEK_SET);
+		offset = vfs_llseek(lower_file, uds->dirpos, SEEK_SET);
 		if (offset < 0) {
 			err = offset;
 			goto out;
 		}
-		err = vfs_readdir(hidden_file, unionfs_filldir, &buf);
+		err = vfs_readdir(lower_file, unionfs_filldir, &buf);
 
 		/* Save the position for when we continue. */
-		offset = vfs_llseek(hidden_file, 0, SEEK_CUR);
+		offset = vfs_llseek(lower_file, 0, SEEK_CUR);
 		if (offset < 0) {
 			err = offset;
 			goto out;
@@ -155,7 +155,7 @@ static int unionfs_readdir(struct file *file, void *dirent, filldir_t filldir)
 		uds->dirpos = offset;
 
 		/* Copy the atime. */
-		fsstack_copy_attr_atime(inode, hidden_file->f_dentry->d_inode);
+		fsstack_copy_attr_atime(inode, lower_file->f_dentry->d_inode);
 
 		if (err < 0)
 			goto out;
diff --git a/fs/unionfs/dirhelper.c b/fs/unionfs/dirhelper.c
index e2cd544..80d1427 100644
--- a/fs/unionfs/dirhelper.c
+++ b/fs/unionfs/dirhelper.c
@@ -21,25 +21,25 @@
 /*
  * Delete all of the whiteouts in a given directory for rmdir.
  *
- * hidden directory inode should be locked
+ * lower directory inode should be locked
  */
 int do_delete_whiteouts(struct dentry *dentry, int bindex,
 			struct unionfs_dir_state *namelist)
 {
 	int err = 0;
-	struct dentry *hidden_dir_dentry = NULL;
-	struct dentry *hidden_dentry;
+	struct dentry *lower_dir_dentry = NULL;
+	struct dentry *lower_dentry;
 	char *name = NULL, *p;
-	struct inode *hidden_dir;
+	struct inode *lower_dir;
 	int i;
 	struct list_head *pos;
 	struct filldir_node *cursor;
 
-	/* Find out hidden parent dentry */
-	hidden_dir_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-	BUG_ON(!S_ISDIR(hidden_dir_dentry->d_inode->i_mode));
-	hidden_dir = hidden_dir_dentry->d_inode;
-	BUG_ON(!S_ISDIR(hidden_dir->i_mode));
+	/* Find out lower parent dentry */
+	lower_dir_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+	BUG_ON(!S_ISDIR(lower_dir_dentry->d_inode->i_mode));
+	lower_dir = lower_dir_dentry->d_inode;
+	BUG_ON(!S_ISDIR(lower_dir->i_mode));
 
 	err = -ENOMEM;
 	name = __getname();
@@ -61,17 +61,17 @@ int do_delete_whiteouts(struct dentry *dentry, int bindex,
 				continue;
 
 			strcpy(p, cursor->name);
-			hidden_dentry =
-				lookup_one_len(name, hidden_dir_dentry,
+			lower_dentry =
+				lookup_one_len(name, lower_dir_dentry,
 					       cursor->namelen +
 					       UNIONFS_WHLEN);
-			if (IS_ERR(hidden_dentry)) {
-				err = PTR_ERR(hidden_dentry);
+			if (IS_ERR(lower_dentry)) {
+				err = PTR_ERR(lower_dentry);
 				break;
 			}
-			if (hidden_dentry->d_inode)
-				err = vfs_unlink(hidden_dir, hidden_dentry);
-			dput(hidden_dentry);
+			if (lower_dentry->d_inode)
+				err = vfs_unlink(lower_dir, lower_dentry);
+			dput(lower_dentry);
 			if (err)
 				break;
 		}
@@ -80,7 +80,7 @@ int do_delete_whiteouts(struct dentry *dentry, int bindex,
 	__putname(name);
 
 	/* After all of the removals, we should copy the attributes once. */
-	fsstack_copy_attr_times(dentry->d_inode, hidden_dir_dentry->d_inode);
+	fsstack_copy_attr_times(dentry->d_inode, lower_dir_dentry->d_inode);
 
 out:
 	return err;
@@ -92,8 +92,8 @@ int delete_whiteouts(struct dentry *dentry, int bindex,
 {
 	int err;
 	struct super_block *sb;
-	struct dentry *hidden_dir_dentry;
-	struct inode *hidden_dir;
+	struct dentry *lower_dir_dentry;
+	struct inode *lower_dir;
 	struct sioq_args args;
 
 	sb = dentry->d_sb;
@@ -106,13 +106,13 @@ int delete_whiteouts(struct dentry *dentry, int bindex,
 	if (err)
 		goto out;
 
-	hidden_dir_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-	BUG_ON(!S_ISDIR(hidden_dir_dentry->d_inode->i_mode));
-	hidden_dir = hidden_dir_dentry->d_inode;
-	BUG_ON(!S_ISDIR(hidden_dir->i_mode));
+	lower_dir_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+	BUG_ON(!S_ISDIR(lower_dir_dentry->d_inode->i_mode));
+	lower_dir = lower_dir_dentry->d_inode;
+	BUG_ON(!S_ISDIR(lower_dir->i_mode));
 
-	mutex_lock(&hidden_dir->i_mutex);
-	if (!permission(hidden_dir, MAY_WRITE | MAY_EXEC, NULL))
+	mutex_lock(&lower_dir->i_mutex);
+	if (!permission(lower_dir, MAY_WRITE | MAY_EXEC, NULL))
 		err = do_delete_whiteouts(dentry, bindex, namelist);
 	else {
 		args.deletewh.namelist = namelist;
@@ -121,7 +121,7 @@ int delete_whiteouts(struct dentry *dentry, int bindex,
 		run_sioq(__delete_whiteouts, &args);
 		err = args.err;
 	}
-	mutex_unlock(&hidden_dir->i_mutex);
+	mutex_unlock(&lower_dir->i_mutex);
 
 out:
 	unionfs_read_unlock(sb);
@@ -185,9 +185,9 @@ out:
 int check_empty(struct dentry *dentry, struct unionfs_dir_state **namelist)
 {
 	int err = 0;
-	struct dentry *hidden_dentry = NULL;
+	struct dentry *lower_dentry = NULL;
 	struct super_block *sb;
-	struct file *hidden_file;
+	struct file *lower_file;
 	struct unionfs_rdutil_callback *buf = NULL;
 	int bindex, bstart, bend, bopaque;
 
@@ -219,28 +219,28 @@ int check_empty(struct dentry *dentry, struct unionfs_dir_state **namelist)
 		goto out;
 	}
 
-	/* Process the hidden directories with rdutil_callback as a filldir. */
+	/* Process the lower directories with rdutil_callback as a filldir. */
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-		if (!hidden_dentry)
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
 			continue;
-		if (!hidden_dentry->d_inode)
+		if (!lower_dentry->d_inode)
 			continue;
-		if (!S_ISDIR(hidden_dentry->d_inode->i_mode))
+		if (!S_ISDIR(lower_dentry->d_inode->i_mode))
 			continue;
 
-		dget(hidden_dentry);
+		dget(lower_dentry);
 		unionfs_mntget(dentry, bindex);
 		unionfs_read_lock(sb);
 		branchget(sb, bindex);
 		unionfs_read_unlock(sb);
-		hidden_file =
-			dentry_open(hidden_dentry,
+		lower_file =
+			dentry_open(lower_dentry,
 				    unionfs_lower_mnt_idx(dentry, bindex),
 				    O_RDONLY);
-		if (IS_ERR(hidden_file)) {
-			err = PTR_ERR(hidden_file);
-			dput(hidden_dentry);
+		if (IS_ERR(lower_file)) {
+			err = PTR_ERR(lower_file);
+			dput(lower_dentry);
 			unionfs_read_lock(sb);
 			branchput(sb, bindex);
 			unionfs_read_unlock(sb);
@@ -250,14 +250,14 @@ int check_empty(struct dentry *dentry, struct unionfs_dir_state **namelist)
 		do {
 			buf->filldir_called = 0;
 			buf->rdstate->bindex = bindex;
-			err = vfs_readdir(hidden_file,
+			err = vfs_readdir(lower_file,
 					  readdir_util_callback, buf);
 			if (buf->err)
 				err = buf->err;
 		} while ((err >= 0) && buf->filldir_called);
 
-		/* fput calls dput for hidden_dentry */
-		fput(hidden_file);
+		/* fput calls dput for lower_dentry */
+		fput(lower_file);
 		unionfs_read_lock(sb);
 		branchput(sb, bindex);
 		unionfs_read_unlock(sb);
diff --git a/fs/unionfs/fanout.h b/fs/unionfs/fanout.h
index f21f23a..366c408 100644
--- a/fs/unionfs/fanout.h
+++ b/fs/unionfs/fanout.h
@@ -127,14 +127,14 @@ static inline void unionfs_set_lower_inode(struct inode *i, struct inode *val)
 
 /* Superblock to lower superblock. */
 static inline struct super_block *unionfs_lower_super(
-					const struct super_block *sb)
+	const struct super_block *sb)
 {
 	return UNIONFS_SB(sb)->data[sbstart(sb)].sb;
 }
 
 static inline struct super_block *unionfs_lower_super_idx(
-					const struct super_block *sb,
-					int index)
+	const struct super_block *sb,
+	int index)
 {
 	return UNIONFS_SB(sb)->data[index].sb;
 }
@@ -216,8 +216,8 @@ static inline void unionfs_set_lower_dentry_idx(struct dentry *dent, int index,
 }
 
 static inline struct dentry *unionfs_lower_dentry_idx(
-				const struct dentry *dent,
-				int index)
+	const struct dentry *dent,
+	int index)
 {
 	return UNIONFS_D(dent)->lower_paths[index].dentry;
 }
@@ -234,8 +234,8 @@ static inline void unionfs_set_lower_mnt_idx(struct dentry *dent, int index,
 }
 
 static inline struct vfsmount *unionfs_lower_mnt_idx(
-					const struct dentry *dent,
-					int index)
+	const struct dentry *dent,
+	int index)
 {
 	return UNIONFS_D(dent)->lower_paths[index].mnt;
 }
diff --git a/fs/unionfs/inode.c b/fs/unionfs/inode.c
index de50e76..8532c6a 100644
--- a/fs/unionfs/inode.c
+++ b/fs/unionfs/inode.c
@@ -22,10 +22,10 @@ static int unionfs_create(struct inode *parent, struct dentry *dentry,
 			  int mode, struct nameidata *nd)
 {
 	int err = 0;
-	struct dentry *hidden_dentry = NULL;
+	struct dentry *lower_dentry = NULL;
 	struct dentry *wh_dentry = NULL;
-	struct dentry *new_hidden_dentry;
-	struct dentry *hidden_parent_dentry = NULL;
+	struct dentry *new_lower_dentry;
+	struct dentry *lower_parent_dentry = NULL;
 	int bindex = 0, bstart;
 	char *name = NULL;
 	int valid = 0;
@@ -59,7 +59,7 @@ static int unionfs_create(struct inode *parent, struct dentry *dentry,
 
 	/* We start out in the leftmost branch. */
 	bstart = dbstart(dentry);
-	hidden_dentry = unionfs_lower_dentry(dentry);
+	lower_dentry = unionfs_lower_dentry(dentry);
 
 	/*
 	 * check if whiteout exists in this branch, i.e. lookup .wh.foo
@@ -71,7 +71,7 @@ static int unionfs_create(struct inode *parent, struct dentry *dentry,
 		goto out;
 	}
 
-	wh_dentry = lookup_one_len(name, hidden_dentry->d_parent,
+	wh_dentry = lookup_one_len(name, lower_dentry->d_parent,
 				   dentry->d_name.len + UNIONFS_WHLEN);
 	if (IS_ERR(wh_dentry)) {
 		err = PTR_ERR(wh_dentry);
@@ -85,7 +85,7 @@ static int unionfs_create(struct inode *parent, struct dentry *dentry,
 		 * First truncate it and then rename it to foo (hence having
 		 * the same overall effect as a normal create.
 		 */
-		struct dentry *hidden_dir_dentry;
+		struct dentry *lower_dir_dentry;
 		struct iattr newattrs;
 
 		mutex_lock(&wh_dentry->d_inode->i_mutex);
@@ -111,32 +111,32 @@ static int unionfs_create(struct inode *parent, struct dentry *dentry,
 			       "failed: %d, ignoring..\n",
 			       __FILE__, __LINE__, err);
 
-		new_hidden_dentry = unionfs_lower_dentry(dentry);
-		dget(new_hidden_dentry);
+		new_lower_dentry = unionfs_lower_dentry(dentry);
+		dget(new_lower_dentry);
 
-		hidden_dir_dentry = dget_parent(wh_dentry);
-		lock_rename(hidden_dir_dentry, hidden_dir_dentry);
+		lower_dir_dentry = dget_parent(wh_dentry);
+		lock_rename(lower_dir_dentry, lower_dir_dentry);
 
 		if (!(err = is_robranch_super(dentry->d_sb, bstart))) {
-			err = vfs_rename(hidden_dir_dentry->d_inode,
+			err = vfs_rename(lower_dir_dentry->d_inode,
 					 wh_dentry,
-					 hidden_dir_dentry->d_inode,
-					 new_hidden_dentry);
+					 lower_dir_dentry->d_inode,
+					 new_lower_dentry);
 		}
 		if (!err) {
 			fsstack_copy_attr_times(parent,
-						new_hidden_dentry->d_parent->
+						new_lower_dentry->d_parent->
 						d_inode);
 			fsstack_copy_inode_size(parent,
-						new_hidden_dentry->d_parent->
+						new_lower_dentry->d_parent->
 						d_inode);
 			parent->i_nlink = unionfs_get_nlinks(parent);
 		}
 
-		unlock_rename(hidden_dir_dentry, hidden_dir_dentry);
-		dput(hidden_dir_dentry);
+		unlock_rename(lower_dir_dentry, lower_dir_dentry);
+		dput(lower_dir_dentry);
 
-		dput(new_hidden_dentry);
+		dput(new_lower_dentry);
 
 		if (err) {
 			/* exit if the error returned was NOT -EROFS */
@@ -173,37 +173,37 @@ static int unionfs_create(struct inode *parent, struct dentry *dentry,
 	}
 
 	for (bindex = bstart; bindex >= 0; bindex--) {
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-		if (!hidden_dentry) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry) {
 			/*
-			 * if hidden_dentry is NULL, create the entire
+			 * if lower_dentry is NULL, create the entire
 			 * dentry directory structure in branch 'bindex'.
-			 * hidden_dentry will NOT be null when bindex == bstart
+			 * lower_dentry will NOT be null when bindex == bstart
 			 * because lookup passed as a negative unionfs dentry
 			 * pointing to a lone negative underlying dentry.
 			 */
-			hidden_dentry = create_parents(parent, dentry,
-						       dentry->d_name.name,
-						       bindex);
-			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
-				if (IS_ERR(hidden_dentry))
-					err = PTR_ERR(hidden_dentry);
+			lower_dentry = create_parents(parent, dentry,
+						      dentry->d_name.name,
+						      bindex);
+			if (!lower_dentry || IS_ERR(lower_dentry)) {
+				if (IS_ERR(lower_dentry))
+					err = PTR_ERR(lower_dentry);
 				continue;
 			}
 		}
 
-		hidden_parent_dentry = lock_parent(hidden_dentry);
-		if (IS_ERR(hidden_parent_dentry)) {
-			err = PTR_ERR(hidden_parent_dentry);
+		lower_parent_dentry = lock_parent(lower_dentry);
+		if (IS_ERR(lower_parent_dentry)) {
+			err = PTR_ERR(lower_parent_dentry);
 			goto out;
 		}
 		/* We shouldn't create things in a read-only branch. */
 		if (!(err = is_robranch_super(dentry->d_sb, bindex)))
-			err = vfs_create(hidden_parent_dentry->d_inode,
-					 hidden_dentry, mode, nd);
+			err = vfs_create(lower_parent_dentry->d_inode,
+					 lower_dentry, mode, nd);
 
-		if (err || !hidden_dentry->d_inode) {
-			unlock_dir(hidden_parent_dentry);
+		if (err || !lower_dentry->d_inode) {
+			unlock_dir(lower_parent_dentry);
 
 			/* break out of for loop if the error wasn't  -EROFS */
 			if (!IS_COPYUP_ERR(err))
@@ -217,15 +217,15 @@ static int unionfs_create(struct inode *parent, struct dentry *dentry,
 							parent->i_sb, 0));
 			if (!err) {
 				fsstack_copy_attr_times(parent,
-							hidden_parent_dentry->
+							lower_parent_dentry->
 							d_inode);
 				fsstack_copy_inode_size(parent,
-							hidden_parent_dentry->
+							lower_parent_dentry->
 							d_inode);
 				/* update no. of links on parent directory */
 				parent->i_nlink = unionfs_get_nlinks(parent);
 			}
-			unlock_dir(hidden_parent_dentry);
+			unlock_dir(lower_parent_dentry);
 			break;
 		}
 	}
@@ -286,9 +286,9 @@ static int unionfs_link(struct dentry *old_dentry, struct inode *dir,
 			struct dentry *new_dentry)
 {
 	int err = 0;
-	struct dentry *hidden_old_dentry = NULL;
-	struct dentry *hidden_new_dentry = NULL;
-	struct dentry *hidden_dir_dentry = NULL;
+	struct dentry *lower_old_dentry = NULL;
+	struct dentry *lower_new_dentry = NULL;
+	struct dentry *lower_dir_dentry = NULL;
 	struct dentry *whiteout_dentry;
 	char *name = NULL;
 
@@ -304,7 +304,7 @@ static int unionfs_link(struct dentry *old_dentry, struct inode *dir,
 		goto out;
 	}
 
-	hidden_new_dentry = unionfs_lower_dentry(new_dentry);
+	lower_new_dentry = unionfs_lower_dentry(new_dentry);
 
 	/*
 	 * check if whiteout exists in the branch of new dentry, i.e. lookup
@@ -316,7 +316,7 @@ static int unionfs_link(struct dentry *old_dentry, struct inode *dir,
 		goto out;
 	}
 
-	whiteout_dentry = lookup_one_len(name, hidden_new_dentry->d_parent,
+	whiteout_dentry = lookup_one_len(name, lower_new_dentry->d_parent,
 					 new_dentry->d_name.len +
 					 UNIONFS_WHLEN);
 	if (IS_ERR(whiteout_dentry)) {
@@ -329,40 +329,40 @@ static int unionfs_link(struct dentry *old_dentry, struct inode *dir,
 		whiteout_dentry = NULL;
 	} else {
 		/* found a .wh.foo entry, unlink it and then call vfs_link() */
-		hidden_dir_dentry = lock_parent(whiteout_dentry);
+		lower_dir_dentry = lock_parent(whiteout_dentry);
 		err = is_robranch_super(new_dentry->d_sb, dbstart(new_dentry));
 		if (!err)
-			err = vfs_unlink(hidden_dir_dentry->d_inode,
+			err = vfs_unlink(lower_dir_dentry->d_inode,
 					 whiteout_dentry);
 
-		fsstack_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+		fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
 		dir->i_nlink = unionfs_get_nlinks(dir);
-		unlock_dir(hidden_dir_dentry);
-		hidden_dir_dentry = NULL;
+		unlock_dir(lower_dir_dentry);
+		lower_dir_dentry = NULL;
 		dput(whiteout_dentry);
 		if (err)
 			goto out;
 	}
 
 	if (dbstart(old_dentry) != dbstart(new_dentry)) {
-		hidden_new_dentry = create_parents(dir, new_dentry,
-						   new_dentry->d_name.name,
-						   dbstart(old_dentry));
-		err = PTR_ERR(hidden_new_dentry);
+		lower_new_dentry = create_parents(dir, new_dentry,
+						  new_dentry->d_name.name,
+						  dbstart(old_dentry));
+		err = PTR_ERR(lower_new_dentry);
 		if (IS_COPYUP_ERR(err))
 			goto docopyup;
-		if (!hidden_new_dentry || IS_ERR(hidden_new_dentry))
+		if (!lower_new_dentry || IS_ERR(lower_new_dentry))
 			goto out;
 	}
-	hidden_new_dentry = unionfs_lower_dentry(new_dentry);
-	hidden_old_dentry = unionfs_lower_dentry(old_dentry);
+	lower_new_dentry = unionfs_lower_dentry(new_dentry);
+	lower_old_dentry = unionfs_lower_dentry(old_dentry);
 
 	BUG_ON(dbstart(old_dentry) != dbstart(new_dentry));
-	hidden_dir_dentry = lock_parent(hidden_new_dentry);
+	lower_dir_dentry = lock_parent(lower_new_dentry);
 	if (!(err = is_robranch(old_dentry)))
-		err = vfs_link(hidden_old_dentry, hidden_dir_dentry->d_inode,
-			       hidden_new_dentry);
-	unlock_dir(hidden_dir_dentry);
+		err = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode,
+			       lower_new_dentry);
+	unlock_dir(lower_dir_dentry);
 
 docopyup:
 	if (IS_COPYUP_ERR(err)) {
@@ -376,19 +376,19 @@ docopyup:
 					    old_dentry->d_name.len, NULL,
 					    old_dentry->d_inode->i_size);
 			if (!err) {
-				hidden_new_dentry =
+				lower_new_dentry =
 					create_parents(dir, new_dentry,
 						       new_dentry->d_name.name,
 						       bindex);
-				hidden_old_dentry =
+				lower_old_dentry =
 					unionfs_lower_dentry(old_dentry);
-				hidden_dir_dentry =
-					lock_parent(hidden_new_dentry);
+				lower_dir_dentry =
+					lock_parent(lower_new_dentry);
 				/* do vfs_link */
-				err = vfs_link(hidden_old_dentry,
-					       hidden_dir_dentry->d_inode,
-					       hidden_new_dentry);
-				unlock_dir(hidden_dir_dentry);
+				err = vfs_link(lower_old_dentry,
+					       lower_dir_dentry->d_inode,
+					       lower_new_dentry);
+				unlock_dir(lower_dir_dentry);
 				goto check_link;
 			}
 		}
@@ -396,15 +396,15 @@ docopyup:
 	}
 
 check_link:
-	if (err || !hidden_new_dentry->d_inode)
+	if (err || !lower_new_dentry->d_inode)
 		goto out;
 
 	/* Its a hard link, so use the same inode */
 	new_dentry->d_inode = igrab(old_dentry->d_inode);
 	d_instantiate(new_dentry, new_dentry->d_inode);
-	fsstack_copy_attr_all(dir, hidden_new_dentry->d_parent->d_inode,
+	fsstack_copy_attr_all(dir, lower_new_dentry->d_parent->d_inode,
 			      unionfs_get_nlinks);
-	fsstack_copy_inode_size(dir, hidden_new_dentry->d_parent->d_inode);
+	fsstack_copy_inode_size(dir, lower_new_dentry->d_parent->d_inode);
 
 	/* propagate number of hard-links */
 	old_dentry->d_inode->i_nlink = unionfs_get_nlinks(old_dentry->d_inode);
@@ -430,9 +430,9 @@ static int unionfs_symlink(struct inode *dir, struct dentry *dentry,
 			   const char *symname)
 {
 	int err = 0;
-	struct dentry *hidden_dentry = NULL;
+	struct dentry *lower_dentry = NULL;
 	struct dentry *whiteout_dentry = NULL;
-	struct dentry *hidden_dir_dentry = NULL;
+	struct dentry *lower_dir_dentry = NULL;
 	umode_t mode;
 	int bindex = 0, bstart;
 	char *name = NULL;
@@ -448,7 +448,7 @@ static int unionfs_symlink(struct inode *dir, struct dentry *dentry,
 	/* We start out in the leftmost branch. */
 	bstart = dbstart(dentry);
 
-	hidden_dentry = unionfs_lower_dentry(dentry);
+	lower_dentry = unionfs_lower_dentry(dentry);
 
 	/*
 	 * check if whiteout exists in this branch, i.e. lookup .wh.foo
@@ -461,7 +461,7 @@ static int unionfs_symlink(struct inode *dir, struct dentry *dentry,
 	}
 
 	whiteout_dentry =
-		lookup_one_len(name, hidden_dentry->d_parent,
+		lookup_one_len(name, lower_dentry->d_parent,
 			       dentry->d_name.len + UNIONFS_WHLEN);
 	if (IS_ERR(whiteout_dentry)) {
 		err = PTR_ERR(whiteout_dentry);
@@ -476,18 +476,18 @@ static int unionfs_symlink(struct inode *dir, struct dentry *dentry,
 		 * found a .wh.foo entry, unlink it and then call
 		 * vfs_symlink().
 		 */
-		hidden_dir_dentry = lock_parent(whiteout_dentry);
+		lower_dir_dentry = lock_parent(whiteout_dentry);
 
 		if (!(err = is_robranch_super(dentry->d_sb, bstart)))
-			err = vfs_unlink(hidden_dir_dentry->d_inode,
+			err = vfs_unlink(lower_dir_dentry->d_inode,
 					 whiteout_dentry);
 		dput(whiteout_dentry);
 
-		fsstack_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+		fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
 		/* propagate number of hard-links */
 		dir->i_nlink = unionfs_get_nlinks(dir);
 
-		unlock_dir(hidden_dir_dentry);
+		unlock_dir(lower_dir_dentry);
 
 		if (err) {
 			/* exit if the error returned was NOT -EROFS */
@@ -506,41 +506,41 @@ static int unionfs_symlink(struct inode *dir, struct dentry *dentry,
 	 * with possible recursive directory creation
 	 */
 	for (bindex = bstart; bindex >= 0; bindex--) {
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-		if (!hidden_dentry) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry) {
 			/*
-			 * if hidden_dentry is NULL, create the entire
+			 * if lower_dentry is NULL, create the entire
 			 * dentry directory structure in branch 'bindex'.
-			 * hidden_dentry will NOT be null when bindex ==
+			 * lower_dentry will NOT be null when bindex ==
 			 * bstart because lookup passed as a negative
 			 * unionfs dentry pointing to a lone negative
 			 * underlying dentry
 			 */
-			hidden_dentry = create_parents(dir, dentry,
-						       dentry->d_name.name,
-						       bindex);
-			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
-				if (IS_ERR(hidden_dentry))
-					err = PTR_ERR(hidden_dentry);
-
-				printk(KERN_DEBUG "unionfs: hidden dentry "
+			lower_dentry = create_parents(dir, dentry,
+						      dentry->d_name.name,
+						      bindex);
+			if (!lower_dentry || IS_ERR(lower_dentry)) {
+				if (IS_ERR(lower_dentry))
+					err = PTR_ERR(lower_dentry);
+
+				printk(KERN_DEBUG "unionfs: lower dentry "
 				       "NULL (or error) for bindex = %d\n",
 				       bindex);
 				continue;
 			}
 		}
 
-		hidden_dir_dentry = lock_parent(hidden_dentry);
+		lower_dir_dentry = lock_parent(lower_dentry);
 
 		if (!(err = is_robranch_super(dentry->d_sb, bindex))) {
 			mode = S_IALLUGO;
 			err =
-				vfs_symlink(hidden_dir_dentry->d_inode,
-					    hidden_dentry, symname, mode);
+				vfs_symlink(lower_dir_dentry->d_inode,
+					    lower_dentry, symname, mode);
 		}
-		unlock_dir(hidden_dir_dentry);
+		unlock_dir(lower_dir_dentry);
 
-		if (err || !hidden_dentry->d_inode) {
+		if (err || !lower_dentry->d_inode) {
 			/*
 			 * break out of for loop if error returned was NOT
 			 * -EROFS.
@@ -556,10 +556,10 @@ static int unionfs_symlink(struct inode *dir, struct dentry *dentry,
 							dir->i_sb, 0));
 			if (!err) {
 				fsstack_copy_attr_times(dir,
-							hidden_dir_dentry->
+							lower_dir_dentry->
 							d_inode);
 				fsstack_copy_inode_size(dir,
-							hidden_dir_dentry->
+							lower_dir_dentry->
 							d_inode);
 				/*
 				 * update number of links on parent
@@ -588,8 +588,8 @@ out:
 static int unionfs_mkdir(struct inode *parent, struct dentry *dentry, int mode)
 {
 	int err = 0;
-	struct dentry *hidden_dentry = NULL, *whiteout_dentry = NULL;
-	struct dentry *hidden_parent_dentry = NULL;
+	struct dentry *lower_dentry = NULL, *whiteout_dentry = NULL;
+	struct dentry *lower_parent_dentry = NULL;
 	int bindex = 0, bstart;
 	char *name = NULL;
 	int whiteout_unlinked = 0;
@@ -605,7 +605,7 @@ static int unionfs_mkdir(struct inode *parent, struct dentry *dentry, int mode)
 
 	bstart = dbstart(dentry);
 
-	hidden_dentry = unionfs_lower_dentry(dentry);
+	lower_dentry = unionfs_lower_dentry(dentry);
 
 	/*
 	 * check if whiteout exists in this branch, i.e. lookup .wh.foo
@@ -617,7 +617,7 @@ static int unionfs_mkdir(struct inode *parent, struct dentry *dentry, int mode)
 		goto out;
 	}
 
-	whiteout_dentry = lookup_one_len(name, hidden_dentry->d_parent,
+	whiteout_dentry = lookup_one_len(name, lower_dentry->d_parent,
 					 dentry->d_name.len + UNIONFS_WHLEN);
 	if (IS_ERR(whiteout_dentry)) {
 		err = PTR_ERR(whiteout_dentry);
@@ -628,18 +628,18 @@ static int unionfs_mkdir(struct inode *parent, struct dentry *dentry, int mode)
 		dput(whiteout_dentry);
 		whiteout_dentry = NULL;
 	} else {
-		hidden_parent_dentry = lock_parent(whiteout_dentry);
+		lower_parent_dentry = lock_parent(whiteout_dentry);
 
 		/* found a.wh.foo entry, remove it then do vfs_mkdir */
 		if (!(err = is_robranch_super(dentry->d_sb, bstart))) {
-			args.unlink.parent = hidden_parent_dentry->d_inode;
+			args.unlink.parent = lower_parent_dentry->d_inode;
 			args.unlink.dentry = whiteout_dentry;
 			run_sioq(__unionfs_unlink, &args);
 			err = args.err;
 		}
 		dput(whiteout_dentry);
 
-		unlock_dir(hidden_parent_dentry);
+		unlock_dir(lower_parent_dentry);
 
 		if (err) {
 			/* exit if the error returned was NOT -EROFS */
@@ -657,29 +657,29 @@ static int unionfs_mkdir(struct inode *parent, struct dentry *dentry, int mode)
 		if (is_robranch_super(dentry->d_sb, bindex))
 			continue;
 
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-		if (!hidden_dentry) {
-			hidden_dentry = create_parents(parent, dentry,
-						       dentry->d_name.name,
-						       bindex);
-			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
-				printk(KERN_DEBUG "unionfs: hidden dentry "
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry) {
+			lower_dentry = create_parents(parent, dentry,
+						      dentry->d_name.name,
+						      bindex);
+			if (!lower_dentry || IS_ERR(lower_dentry)) {
+				printk(KERN_DEBUG "unionfs: lower dentry "
 				       " NULL for bindex = %d\n", bindex);
 				continue;
 			}
 		}
 
-		hidden_parent_dentry = lock_parent(hidden_dentry);
+		lower_parent_dentry = lock_parent(lower_dentry);
 
-		if (IS_ERR(hidden_parent_dentry)) {
-			err = PTR_ERR(hidden_parent_dentry);
+		if (IS_ERR(lower_parent_dentry)) {
+			err = PTR_ERR(lower_parent_dentry);
 			goto out;
 		}
 
-		err = vfs_mkdir(hidden_parent_dentry->d_inode, hidden_dentry,
+		err = vfs_mkdir(lower_parent_dentry->d_inode, lower_dentry,
 				mode);
 
-		unlock_dir(hidden_parent_dentry);
+		unlock_dir(lower_parent_dentry);
 
 		/* did the mkdir succeed? */
 		if (err)
@@ -700,9 +700,9 @@ static int unionfs_mkdir(struct inode *parent, struct dentry *dentry, int mode)
 		err = PTR_ERR(unionfs_interpose(dentry, parent->i_sb, 0));
 		if (!err) {
 			fsstack_copy_attr_times(parent,
-						hidden_parent_dentry->d_inode);
+						lower_parent_dentry->d_inode);
 			fsstack_copy_inode_size(parent,
-						hidden_parent_dentry->d_inode);
+						lower_parent_dentry->d_inode);
 
 			/* update number of links on parent directory */
 			parent->i_nlink = unionfs_get_nlinks(parent);
@@ -735,8 +735,8 @@ static int unionfs_mknod(struct inode *dir, struct dentry *dentry, int mode,
 			 dev_t dev)
 {
 	int err = 0;
-	struct dentry *hidden_dentry = NULL, *whiteout_dentry = NULL;
-	struct dentry *hidden_parent_dentry = NULL;
+	struct dentry *lower_dentry = NULL, *whiteout_dentry = NULL;
+	struct dentry *lower_parent_dentry = NULL;
 	int bindex = 0, bstart;
 	char *name = NULL;
 	int whiteout_unlinked = 0;
@@ -751,7 +751,7 @@ static int unionfs_mknod(struct inode *dir, struct dentry *dentry, int mode,
 
 	bstart = dbstart(dentry);
 
-	hidden_dentry = unionfs_lower_dentry(dentry);
+	lower_dentry = unionfs_lower_dentry(dentry);
 
 	/*
 	 * check if whiteout exists in this branch, i.e. lookup .wh.foo
@@ -763,7 +763,7 @@ static int unionfs_mknod(struct inode *dir, struct dentry *dentry, int mode,
 		goto out;
 	}
 
-	whiteout_dentry = lookup_one_len(name, hidden_dentry->d_parent,
+	whiteout_dentry = lookup_one_len(name, lower_dentry->d_parent,
 					 dentry->d_name.len + UNIONFS_WHLEN);
 	if (IS_ERR(whiteout_dentry)) {
 		err = PTR_ERR(whiteout_dentry);
@@ -775,15 +775,15 @@ static int unionfs_mknod(struct inode *dir, struct dentry *dentry, int mode,
 		whiteout_dentry = NULL;
 	} else {
 		/* found .wh.foo, unlink it */
-		hidden_parent_dentry = lock_parent(whiteout_dentry);
+		lower_parent_dentry = lock_parent(whiteout_dentry);
 
 		/* found a.wh.foo entry, remove it then do vfs_mkdir */
 		if (!(err = is_robranch_super(dentry->d_sb, bstart)))
-			err = vfs_unlink(hidden_parent_dentry->d_inode,
+			err = vfs_unlink(lower_parent_dentry->d_inode,
 					 whiteout_dentry);
 		dput(whiteout_dentry);
 
-		unlock_dir(hidden_parent_dentry);
+		unlock_dir(lower_parent_dentry);
 
 		if (err) {
 			if (!IS_COPYUP_ERR(err))
@@ -797,30 +797,30 @@ static int unionfs_mknod(struct inode *dir, struct dentry *dentry, int mode,
 		if (is_robranch_super(dentry->d_sb, bindex))
 			continue;
 
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-		if (!hidden_dentry) {
-			hidden_dentry = create_parents(dir, dentry,
-						       dentry->d_name.name,
-						       bindex);
-			if (IS_ERR(hidden_dentry)) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry) {
+			lower_dentry = create_parents(dir, dentry,
+						      dentry->d_name.name,
+						      bindex);
+			if (IS_ERR(lower_dentry)) {
 				printk(KERN_DEBUG "unionfs: failed to create "
 				       "parents on %d, err = %ld\n",
-				       bindex, PTR_ERR(hidden_dentry));
+				       bindex, PTR_ERR(lower_dentry));
 				continue;
 			}
 		}
 
-		hidden_parent_dentry = lock_parent(hidden_dentry);
-		if (IS_ERR(hidden_parent_dentry)) {
-			err = PTR_ERR(hidden_parent_dentry);
+		lower_parent_dentry = lock_parent(lower_dentry);
+		if (IS_ERR(lower_parent_dentry)) {
+			err = PTR_ERR(lower_parent_dentry);
 			goto out;
 		}
 
-		err = vfs_mknod(hidden_parent_dentry->d_inode,
-				hidden_dentry, mode, dev);
+		err = vfs_mknod(lower_parent_dentry->d_inode,
+				lower_dentry, mode, dev);
 
 		if (err) {
-			unlock_dir(hidden_parent_dentry);
+			unlock_dir(lower_parent_dentry);
 			break;
 		}
 
@@ -831,13 +831,13 @@ static int unionfs_mknod(struct inode *dir, struct dentry *dentry, int mode,
 		err = PTR_ERR(unionfs_interpose(dentry, dir->i_sb, 0));
 		if (!err) {
 			fsstack_copy_attr_times(dir,
-						hidden_parent_dentry->d_inode);
+						lower_parent_dentry->d_inode);
 			fsstack_copy_inode_size(dir,
-						hidden_parent_dentry->d_inode);
+						lower_parent_dentry->d_inode);
 			/* update number of links on parent directory */
 			dir->i_nlink = unionfs_get_nlinks(dir);
 		}
-		unlock_dir(hidden_parent_dentry);
+		unlock_dir(lower_parent_dentry);
 
 		break;
 	}
@@ -861,7 +861,7 @@ static int unionfs_readlink(struct dentry *dentry, char __user *buf,
 			    int bufsiz)
 {
 	int err;
-	struct dentry *hidden_dentry;
+	struct dentry *lower_dentry;
 
 	unionfs_lock_dentry(dentry);
 
@@ -870,19 +870,19 @@ static int unionfs_readlink(struct dentry *dentry, char __user *buf,
 		goto out;
 	}
 
-	hidden_dentry = unionfs_lower_dentry(dentry);
+	lower_dentry = unionfs_lower_dentry(dentry);
 
-	if (!hidden_dentry->d_inode->i_op ||
-	    !hidden_dentry->d_inode->i_op->readlink) {
+	if (!lower_dentry->d_inode->i_op ||
+	    !lower_dentry->d_inode->i_op->readlink) {
 		err = -EINVAL;
 		goto out;
 	}
 
-	err = hidden_dentry->d_inode->i_op->readlink(hidden_dentry,
-						     buf, bufsiz);
+	err = lower_dentry->d_inode->i_op->readlink(lower_dentry,
+						    buf, bufsiz);
 	if (err > 0)
 		fsstack_copy_attr_atime(dentry->d_inode,
-					hidden_dentry->d_inode);
+					lower_dentry->d_inode);
 
 out:
 	unionfs_unlock_dentry(dentry);
@@ -1003,7 +1003,7 @@ static int inode_permission(struct inode *inode, int mask,
 static int unionfs_permission(struct inode *inode, int mask,
 			      struct nameidata *nd)
 {
-	struct inode *hidden_inode = NULL;
+	struct inode *lower_inode = NULL;
 	int err = 0;
 	int bindex, bstart, bend;
 	const int is_file = !S_ISDIR(inode->i_mode);
@@ -1042,8 +1042,8 @@ static int unionfs_permission(struct inode *inode, int mask,
 	}
 
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_inode = unionfs_lower_inode_idx(inode, bindex);
-		if (!hidden_inode)
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (!lower_inode)
 			continue;
 
 		/*
@@ -1051,14 +1051,14 @@ static int unionfs_permission(struct inode *inode, int mask,
 		 * we don't have to check for files, if we are checking for
 		 * directories.
 		 */
-		if (!is_file && !S_ISDIR(hidden_inode->i_mode))
+		if (!is_file && !S_ISDIR(lower_inode->i_mode))
 			continue;
 
 		/*
 		 * We use our own special version of permission, such that
 		 * only the first branch returns -EROFS.
 		 */
-		err = inode_permission(hidden_inode, mask, nd, bindex);
+		err = inode_permission(lower_inode, mask, nd, bindex);
 
 		/*
 		 * The permissions are an intersection of the overall directory
@@ -1070,9 +1070,9 @@ static int unionfs_permission(struct inode *inode, int mask,
 		/* only the leftmost file matters. */
 		if (is_file || write_mask) {
 			if (is_file && write_mask) {
-				err = get_write_access(hidden_inode);
+				err = get_write_access(lower_inode);
 				if (!err)
-					put_write_access(hidden_inode);
+					put_write_access(lower_inode);
 			}
 			break;
 		}
@@ -1088,9 +1088,9 @@ out:
 static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
 {
 	int err = 0;
-	struct dentry *hidden_dentry;
+	struct dentry *lower_dentry;
 	struct inode *inode = NULL;
-	struct inode *hidden_inode = NULL;
+	struct inode *lower_inode = NULL;
 	int bstart, bend, bindex;
 	int i;
 	int copyup = 0;
@@ -1108,14 +1108,14 @@ static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
 
 	for (bindex = bstart; (bindex <= bend) || (bindex == bstart);
 	     bindex++) {
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-		if (!hidden_dentry)
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
 			continue;
-		BUG_ON(hidden_dentry->d_inode == NULL);
+		BUG_ON(lower_dentry->d_inode == NULL);
 
 		/* If the file is on a read only branch */
 		if (is_robranch_super(dentry->d_sb, bindex)
-		    || IS_RDONLY(hidden_dentry->d_inode)) {
+		    || IS_RDONLY(lower_dentry->d_inode)) {
 			if (copyup || (bindex != bstart))
 				continue;
 			/* Only if its the leftmost file, copyup the file */
@@ -1131,7 +1131,7 @@ static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
 
 				if (!err) {
 					copyup = 1;
-					hidden_dentry =
+					lower_dentry =
 						unionfs_lower_dentry(dentry);
 					break;
 				}
@@ -1144,7 +1144,7 @@ static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
 			}
 
 		}
-		err = notify_change(hidden_dentry, ia);
+		err = notify_change(lower_dentry, ia);
 		if (err)
 			goto out;
 		break;
@@ -1159,10 +1159,10 @@ static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
 		}
 	}
 
-	/* get the size from the first hidden inode */
-	hidden_inode = unionfs_lower_inode(dentry->d_inode);
-	fsstack_copy_attr_all(inode, hidden_inode, unionfs_get_nlinks);
-	fsstack_copy_inode_size(inode, hidden_inode);
+	/* get the size from the first lower inode */
+	lower_inode = unionfs_lower_inode(dentry->d_inode);
+	fsstack_copy_attr_all(inode, lower_inode, unionfs_get_nlinks);
+	fsstack_copy_inode_size(inode, lower_inode);
 out:
 	unionfs_unlock_dentry(dentry);
 	unionfs_check_dentry(dentry);
diff --git a/fs/unionfs/lookup.c b/fs/unionfs/lookup.c
index c65875d..dadfd14 100644
--- a/fs/unionfs/lookup.c
+++ b/fs/unionfs/lookup.c
@@ -33,39 +33,39 @@ static int is_validname(const char *name)
 static noinline int is_opaque_dir(struct dentry *dentry, int bindex)
 {
 	int err = 0;
-	struct dentry *hidden_dentry;
-	struct dentry *wh_hidden_dentry;
-	struct inode *hidden_inode;
+	struct dentry *lower_dentry;
+	struct dentry *wh_lower_dentry;
+	struct inode *lower_inode;
 	struct sioq_args args;
 
-	hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-	hidden_inode = hidden_dentry->d_inode;
+	lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+	lower_inode = lower_dentry->d_inode;
 
-	BUG_ON(!S_ISDIR(hidden_inode->i_mode));
+	BUG_ON(!S_ISDIR(lower_inode->i_mode));
 
-	mutex_lock(&hidden_inode->i_mutex);
+	mutex_lock(&lower_inode->i_mutex);
 
-	if (!permission(hidden_inode, MAY_EXEC, NULL))
-		wh_hidden_dentry =
-			lookup_one_len(UNIONFS_DIR_OPAQUE, hidden_dentry,
+	if (!permission(lower_inode, MAY_EXEC, NULL))
+		wh_lower_dentry =
+			lookup_one_len(UNIONFS_DIR_OPAQUE, lower_dentry,
 				       sizeof(UNIONFS_DIR_OPAQUE) - 1);
 	else {
-		args.is_opaque.dentry = hidden_dentry;
+		args.is_opaque.dentry = lower_dentry;
 		run_sioq(__is_opaque_dir, &args);
-		wh_hidden_dentry = args.ret;
+		wh_lower_dentry = args.ret;
 	}
 
-	mutex_unlock(&hidden_inode->i_mutex);
+	mutex_unlock(&lower_inode->i_mutex);
 
-	if (IS_ERR(wh_hidden_dentry)) {
-		err = PTR_ERR(wh_hidden_dentry);
+	if (IS_ERR(wh_lower_dentry)) {
+		err = PTR_ERR(wh_lower_dentry);
 		goto out;
 	}
 
-	/* This is an opaque dir iff wh_hidden_dentry is positive */
-	err = !!wh_hidden_dentry->d_inode;
+	/* This is an opaque dir iff wh_lower_dentry is positive */
+	err = !!wh_lower_dentry->d_inode;
 
-	dput(wh_hidden_dentry);
+	dput(wh_lower_dentry);
 out:
 	return err;
 }
@@ -80,17 +80,17 @@ struct dentry *unionfs_lookup_backend(struct dentry *dentry,
 				      struct nameidata *nd, int lookupmode)
 {
 	int err = 0;
-	struct dentry *hidden_dentry = NULL;
-	struct dentry *wh_hidden_dentry = NULL;
-	struct dentry *hidden_dir_dentry = NULL;
+	struct dentry *lower_dentry = NULL;
+	struct dentry *wh_lower_dentry = NULL;
+	struct dentry *lower_dir_dentry = NULL;
 	struct dentry *parent_dentry = NULL;
 	struct dentry *d_interposed = NULL;
 	int bindex, bstart, bend, bopaque;
 	int dentry_count = 0;	/* Number of positive dentries. */
 	int first_dentry_offset = -1; /* -1 is uninitialized */
 	struct dentry *first_dentry = NULL;
-	struct dentry *first_hidden_dentry = NULL;
-	struct vfsmount *first_hidden_mnt = NULL;
+	struct dentry *first_lower_dentry = NULL;
+	struct vfsmount *first_lower_mnt = NULL;
 	int locked_parent = 0;
 	int locked_child = 0;
 	int allocated_new_info = 0;
@@ -157,20 +157,20 @@ struct dentry *unionfs_lookup_backend(struct dentry *dentry,
 	}
 
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-		if (lookupmode == INTERPOSE_PARTIAL && hidden_dentry)
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (lookupmode == INTERPOSE_PARTIAL && lower_dentry)
 			continue;
-		BUG_ON(hidden_dentry != NULL);
+		BUG_ON(lower_dentry != NULL);
 
-		hidden_dir_dentry =
+		lower_dir_dentry =
 			unionfs_lower_dentry_idx(parent_dentry, bindex);
 
-		/* if the parent hidden dentry does not exist skip this */
-		if (!(hidden_dir_dentry && hidden_dir_dentry->d_inode))
+		/* if the parent lower dentry does not exist skip this */
+		if (!(lower_dir_dentry && lower_dir_dentry->d_inode))
 			continue;
 
 		/* also skip it if the parent isn't a directory. */
-		if (!S_ISDIR(hidden_dir_dentry->d_inode->i_mode))
+		if (!S_ISDIR(lower_dir_dentry->d_inode->i_mode))
 			continue;
 
 		/* Reuse the whiteout name because its value doesn't change. */
@@ -183,47 +183,47 @@ struct dentry *unionfs_lookup_backend(struct dentry *dentry,
 		}
 
 		/* check if whiteout exists in this branch: lookup .wh.foo */
-		wh_hidden_dentry = lookup_one_len(whname, hidden_dir_dentry,
-						  namelen + UNIONFS_WHLEN);
-		if (IS_ERR(wh_hidden_dentry)) {
-			dput(first_hidden_dentry);
+		wh_lower_dentry = lookup_one_len(whname, lower_dir_dentry,
+						 namelen + UNIONFS_WHLEN);
+		if (IS_ERR(wh_lower_dentry)) {
+			dput(first_lower_dentry);
 			unionfs_mntput(first_dentry, first_dentry_offset);
-			err = PTR_ERR(wh_hidden_dentry);
+			err = PTR_ERR(wh_lower_dentry);
 			goto out_free;
 		}
 
-		if (wh_hidden_dentry->d_inode) {
+		if (wh_lower_dentry->d_inode) {
 			/* We found a whiteout so lets give up. */
-			if (S_ISREG(wh_hidden_dentry->d_inode->i_mode)) {
+			if (S_ISREG(wh_lower_dentry->d_inode->i_mode)) {
 				set_dbend(dentry, bindex);
 				set_dbopaque(dentry, bindex);
-				dput(wh_hidden_dentry);
+				dput(wh_lower_dentry);
 				break;
 			}
 			err = -EIO;
 			printk(KERN_NOTICE "unionfs: EIO: invalid whiteout "
 			       "entry type %d.\n",
-			       wh_hidden_dentry->d_inode->i_mode);
-			dput(wh_hidden_dentry);
-			dput(first_hidden_dentry);
+			       wh_lower_dentry->d_inode->i_mode);
+			dput(wh_lower_dentry);
+			dput(first_lower_dentry);
 			unionfs_mntput(first_dentry, first_dentry_offset);
 			goto out_free;
 		}
 
-		dput(wh_hidden_dentry);
-		wh_hidden_dentry = NULL;
+		dput(wh_lower_dentry);
+		wh_lower_dentry = NULL;
 
 		/* Now do regular lookup; lookup foo */
 		nd->dentry = unionfs_lower_dentry_idx(dentry, bindex);
 		/* FIXME: fix following line for mount point crossing */
 		nd->mnt = unionfs_lower_mnt_idx(parent_dentry, bindex);
 
-		hidden_dentry = lookup_one_len_nd(name, hidden_dir_dentry,
-						  namelen, nd);
-		if (IS_ERR(hidden_dentry)) {
-			dput(first_hidden_dentry);
+		lower_dentry = lookup_one_len_nd(name, lower_dir_dentry,
+						 namelen, nd);
+		if (IS_ERR(lower_dentry)) {
+			dput(first_lower_dentry);
 			unionfs_mntput(first_dentry, first_dentry_offset);
-			err = PTR_ERR(hidden_dentry);
+			err = PTR_ERR(lower_dentry);
 			goto out_free;
 		}
 
@@ -231,19 +231,19 @@ struct dentry *unionfs_lookup_backend(struct dentry *dentry,
 		 * Store the first negative dentry specially, because if they
 		 * are all negative we need this for future creates.
 		 */
-		if (!hidden_dentry->d_inode) {
-			if (!first_hidden_dentry && (dbstart(dentry) == -1)) {
-				first_hidden_dentry = hidden_dentry;
+		if (!lower_dentry->d_inode) {
+			if (!first_lower_dentry && (dbstart(dentry) == -1)) {
+				first_lower_dentry = lower_dentry;
 				/*
 				 * FIXME: following line needs to be changed
 				 * to allow mount-point crossing
 				 */
 				first_dentry = parent_dentry;
-				first_hidden_mnt =
+				first_lower_mnt =
 					unionfs_mntget(parent_dentry, bindex);
 				first_dentry_offset = bindex;
 			} else
-				dput(hidden_dentry);
+				dput(lower_dentry);
 
 			continue;
 		}
@@ -254,7 +254,7 @@ struct dentry *unionfs_lookup_backend(struct dentry *dentry,
 		/* store underlying dentry */
 		if (dbstart(dentry) == -1)
 			set_dbstart(dentry, bindex);
-		unionfs_set_lower_dentry_idx(dentry, bindex, hidden_dentry);
+		unionfs_set_lower_dentry_idx(dentry, bindex, lower_dentry);
 		/*
 		 * FIXME: the following line needs to get fixed to allow
 		 * mount-point crossing
@@ -266,10 +266,10 @@ struct dentry *unionfs_lookup_backend(struct dentry *dentry,
 
 		/* update parent directory's atime with the bindex */
 		fsstack_copy_attr_atime(parent_dentry->d_inode,
-					hidden_dir_dentry->d_inode);
+					lower_dir_dentry->d_inode);
 
 		/* We terminate file lookups here. */
-		if (!S_ISDIR(hidden_dentry->d_inode->i_mode)) {
+		if (!S_ISDIR(lower_dentry->d_inode->i_mode)) {
 			if (lookupmode == INTERPOSE_PARTIAL)
 				continue;
 			if (dentry_count == 1)
@@ -282,7 +282,7 @@ struct dentry *unionfs_lookup_backend(struct dentry *dentry,
 
 		opaque = is_opaque_dir(dentry, bindex);
 		if (opaque < 0) {
-			dput(first_hidden_dentry);
+			dput(first_lower_dentry);
 			unionfs_mntput(first_dentry, first_dentry_offset);
 			err = opaque;
 			goto out_free;
@@ -314,12 +314,12 @@ out_negative:
 		/* FIXME: fix following line for mount point crossing */
 		nd->mnt = unionfs_lower_mnt_idx(parent_dentry, bindex);
 
-		first_hidden_dentry =
-			lookup_one_len_nd(name, hidden_dir_dentry,
+		first_lower_dentry =
+			lookup_one_len_nd(name, lower_dir_dentry,
 					  namelen, nd);
 		first_dentry_offset = bindex;
-		if (IS_ERR(first_hidden_dentry)) {
-			err = PTR_ERR(first_hidden_dentry);
+		if (IS_ERR(first_lower_dentry)) {
+			err = PTR_ERR(first_lower_dentry);
 			goto out;
 		}
 
@@ -328,13 +328,13 @@ out_negative:
 		 * mount-point crossing
 		 */
 		first_dentry = dentry;
-		first_hidden_mnt = unionfs_mntget(dentry->d_sb->s_root,
-						  bindex);
+		first_lower_mnt = unionfs_mntget(dentry->d_sb->s_root,
+						 bindex);
 	}
 	unionfs_set_lower_dentry_idx(dentry, first_dentry_offset,
-				     first_hidden_dentry);
+				     first_lower_dentry);
 	unionfs_set_lower_mnt_idx(dentry, first_dentry_offset,
-				  first_hidden_mnt);
+				  first_lower_mnt);
 	set_dbstart(dentry, first_dentry_offset);
 	set_dbend(dentry, first_dentry_offset);
 
@@ -352,7 +352,7 @@ out_positive:
 	 * If we're holding onto the first negative dentry & corresponding
 	 * vfsmount - throw it out.
 	 */
-	dput(first_hidden_dentry);
+	dput(first_lower_dentry);
 	unionfs_mntput(first_dentry, first_dentry_offset);
 
 	/* Partial lookups need to re-interpose, or throw away older negs. */
@@ -529,17 +529,17 @@ void update_bstart(struct dentry *dentry)
 	int bindex;
 	int bstart = dbstart(dentry);
 	int bend = dbend(dentry);
-	struct dentry *hidden_dentry;
+	struct dentry *lower_dentry;
 
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-		if (!hidden_dentry)
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
 			continue;
-		if (hidden_dentry->d_inode) {
+		if (lower_dentry->d_inode) {
 			set_dbstart(dentry, bindex);
 			break;
 		}
-		dput(hidden_dentry);
+		dput(lower_dentry);
 		unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
 	}
 }
diff --git a/fs/unionfs/main.c b/fs/unionfs/main.c
index a690182..d1e034f 100644
--- a/fs/unionfs/main.c
+++ b/fs/unionfs/main.c
@@ -29,8 +29,8 @@
 struct dentry *unionfs_interpose(struct dentry *dentry, struct super_block *sb,
 				 int flag)
 {
-	struct inode *hidden_inode;
-	struct dentry *hidden_dentry;
+	struct inode *lower_inode;
+	struct dentry *lower_dentry;
 	int err = 0;
 	struct inode *inode;
 	int is_negative_dentry = 1;
@@ -90,45 +90,45 @@ struct dentry *unionfs_interpose(struct dentry *dentry, struct super_block *sb,
 fill_i_info:
 	skipped = 0;
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-		if (!hidden_dentry) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry) {
 			unionfs_set_lower_inode_idx(inode, bindex, NULL);
 			continue;
 		}
 
-		/* Initialize the hidden inode to the new hidden inode. */
-		if (!hidden_dentry->d_inode)
+		/* Initialize the lower inode to the new lower inode. */
+		if (!lower_dentry->d_inode)
 			continue;
 
 		unionfs_set_lower_inode_idx(inode, bindex,
-					    igrab(hidden_dentry->d_inode));
+					    igrab(lower_dentry->d_inode));
 	}
 
 	ibstart(inode) = dbstart(dentry);
 	ibend(inode) = dbend(dentry);
 
 	/* Use attributes from the first branch. */
-	hidden_inode = unionfs_lower_inode(inode);
+	lower_inode = unionfs_lower_inode(inode);
 
 	/* Use different set of inode ops for symlinks & directories */
-	if (S_ISLNK(hidden_inode->i_mode))
+	if (S_ISLNK(lower_inode->i_mode))
 		inode->i_op = &unionfs_symlink_iops;
-	else if (S_ISDIR(hidden_inode->i_mode))
+	else if (S_ISDIR(lower_inode->i_mode))
 		inode->i_op = &unionfs_dir_iops;
 
 	/* Use different set of file ops for directories */
-	if (S_ISDIR(hidden_inode->i_mode))
+	if (S_ISDIR(lower_inode->i_mode))
 		inode->i_fop = &unionfs_dir_fops;
 
 	/* properly initialize special inodes */
-	if (S_ISBLK(hidden_inode->i_mode) || S_ISCHR(hidden_inode->i_mode) ||
-	    S_ISFIFO(hidden_inode->i_mode) || S_ISSOCK(hidden_inode->i_mode))
-		init_special_inode(inode, hidden_inode->i_mode,
-				   hidden_inode->i_rdev);
+	if (S_ISBLK(lower_inode->i_mode) || S_ISCHR(lower_inode->i_mode) ||
+	    S_ISFIFO(lower_inode->i_mode) || S_ISSOCK(lower_inode->i_mode))
+		init_special_inode(inode, lower_inode->i_mode,
+				   lower_inode->i_rdev);
 
 	/* all well, copy inode attributes */
-	fsstack_copy_attr_all(inode, hidden_inode, unionfs_get_nlinks);
-	fsstack_copy_inode_size(inode, hidden_inode);
+	fsstack_copy_attr_all(inode, lower_inode, unionfs_get_nlinks);
+	fsstack_copy_inode_size(inode, lower_inode);
 
 	if (spliced)
 		goto out_spliced;
@@ -179,7 +179,7 @@ out:
 /* like interpose above, but for an already existing dentry */
 void unionfs_reinterpose(struct dentry *dentry)
 {
-	struct dentry *hidden_dentry;
+	struct dentry *lower_dentry;
 	struct inode *inode;
 	int bindex, bstart, bend;
 
@@ -191,16 +191,16 @@ void unionfs_reinterpose(struct dentry *dentry)
 	bstart = dbstart(dentry);
 	bend = dbend(dentry);
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-		if (!hidden_dentry)
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
 			continue;
 
-		if (!hidden_dentry->d_inode)
+		if (!lower_dentry->d_inode)
 			continue;
 		if (unionfs_lower_inode_idx(inode, bindex))
 			continue;
 		unionfs_set_lower_inode_idx(inode, bindex,
-					    igrab(hidden_dentry->d_inode));
+					    igrab(lower_dentry->d_inode));
 	}
 	ibstart(inode) = dbstart(dentry);
 	ibend(inode) = dbend(dentry);
@@ -225,7 +225,7 @@ int check_branch(struct nameidata *nd)
 	return 0;
 }
 
-/* checks if two hidden_dentries have overlapping branches */
+/* checks if two lower_dentries have overlapping branches */
 static int is_branch_overlap(struct dentry *dent1, struct dentry *dent2)
 {
 	struct dentry *dent = NULL;
@@ -273,7 +273,7 @@ int parse_branch_mode(const char *name)
 
 /* parse the dirs= mount argument */
 static int parse_dirs_option(struct super_block *sb, struct unionfs_dentry_info
-			     *hidden_root_info, char *options)
+			     *lower_root_info, char *options)
 {
 	struct nameidata nd;
 	char *name;
@@ -299,7 +299,7 @@ static int parse_dirs_option(struct super_block *sb, struct unionfs_dentry_info
 		if (options[i] == ':')
 			branches++;
 
-	/* allocate space for underlying pointers to hidden dentry */
+	/* allocate space for underlying pointers to lower dentry */
 	UNIONFS_SB(sb)->data =
 		kcalloc(branches, sizeof(struct unionfs_data), GFP_KERNEL);
 	if (!UNIONFS_SB(sb)->data) {
@@ -307,9 +307,9 @@ static int parse_dirs_option(struct super_block *sb, struct unionfs_dentry_info
 		goto out;
 	}
 
-	hidden_root_info->lower_paths =
+	lower_root_info->lower_paths =
 		kcalloc(branches, sizeof(struct path), GFP_KERNEL);
-	if (!hidden_root_info->lower_paths) {
+	if (!lower_root_info->lower_paths) {
 		err = -ENOMEM;
 		goto out;
 	}
@@ -342,20 +342,20 @@ static int parse_dirs_option(struct super_block *sb, struct unionfs_dentry_info
 		err = path_lookup(name, LOOKUP_FOLLOW, &nd);
 		if (err) {
 			printk(KERN_WARNING "unionfs: error accessing "
-			       "hidden directory '%s' (error %d)\n",
+			       "lower directory '%s' (error %d)\n",
 			       name, err);
 			goto out;
 		}
 
 		if ((err = check_branch(&nd))) {
-			printk(KERN_WARNING "unionfs: hidden directory "
+			printk(KERN_WARNING "unionfs: lower directory "
 			       "'%s' is not a valid branch\n", name);
 			path_release(&nd);
 			goto out;
 		}
 
-		hidden_root_info->lower_paths[bindex].dentry = nd.dentry;
-		hidden_root_info->lower_paths[bindex].mnt = nd.mnt;
+		lower_root_info->lower_paths[bindex].dentry = nd.dentry;
+		lower_root_info->lower_paths[bindex].mnt = nd.mnt;
 
 		unionfs_write_lock(sb);
 		set_branchperms(sb, bindex, perms);
@@ -363,9 +363,9 @@ static int parse_dirs_option(struct super_block *sb, struct unionfs_dentry_info
 		new_branch_id(sb, bindex);
 		unionfs_write_unlock(sb);
 
-		if (hidden_root_info->bstart < 0)
-			hidden_root_info->bstart = bindex;
-		hidden_root_info->bend = bindex;
+		if (lower_root_info->bstart < 0)
+			lower_root_info->bstart = bindex;
+		lower_root_info->bend = bindex;
 		bindex++;
 	}
 
@@ -375,7 +375,7 @@ static int parse_dirs_option(struct super_block *sb, struct unionfs_dentry_info
 		goto out;
 	}
 
-	BUG_ON(branches != (hidden_root_info->bend + 1));
+	BUG_ON(branches != (lower_root_info->bend + 1));
 
 	/*
 	 * Ensure that no overlaps exist in the branches.
@@ -393,9 +393,9 @@ static int parse_dirs_option(struct super_block *sb, struct unionfs_dentry_info
 	 * branch-overlapping test.
 	 */
 	for (i = 0; i < branches; i++) {
-		dent1 = hidden_root_info->lower_paths[i].dentry;
+		dent1 = lower_root_info->lower_paths[i].dentry;
 		for (j = i + 1; j < branches; j++) {
-			dent2 = hidden_root_info->lower_paths[j].dentry;
+			dent2 = lower_root_info->lower_paths[j].dentry;
 			if (is_branch_overlap(dent1, dent2)) {
 				printk(KERN_WARNING "unionfs: branches %d and "
 				       "%d overlap\n", i, j);
@@ -408,20 +408,20 @@ static int parse_dirs_option(struct super_block *sb, struct unionfs_dentry_info
 out:
 	if (err) {
 		for (i = 0; i < branches; i++)
-			if (hidden_root_info->lower_paths[i].dentry) {
-				dput(hidden_root_info->lower_paths[i].dentry);
+			if (lower_root_info->lower_paths[i].dentry) {
+				dput(lower_root_info->lower_paths[i].dentry);
 				/* initialize: can't use unionfs_mntput here */
-				mntput(hidden_root_info->lower_paths[i].mnt);
+				mntput(lower_root_info->lower_paths[i].mnt);
 			}
 
-		kfree(hidden_root_info->lower_paths);
+		kfree(lower_root_info->lower_paths);
 		kfree(UNIONFS_SB(sb)->data);
 
 		/*
 		 * MUST clear the pointers to prevent potential double free if
 		 * the caller dies later on
 		 */
-		hidden_root_info->lower_paths = NULL;
+		lower_root_info->lower_paths = NULL;
 		UNIONFS_SB(sb)->data = NULL;
 	}
 	return err;
@@ -430,14 +430,14 @@ out:
 /*
  * Parse mount options.  See the manual page for usage instructions.
  *
- * Returns the dentry object of the lower-level (hidden) directory;
- * We want to mount our stackable file system on top of that hidden directory.
+ * Returns the dentry object of the lower-level (lower) directory;
+ * We want to mount our stackable file system on top of that lower directory.
  */
 static struct unionfs_dentry_info *unionfs_parse_options(
-					struct super_block *sb,
-					char *options)
+	struct super_block *sb,
+	char *options)
 {
-	struct unionfs_dentry_info *hidden_root_info;
+	struct unionfs_dentry_info *lower_root_info;
 	char *optname;
 	int err = 0;
 	int bindex;
@@ -445,13 +445,13 @@ static struct unionfs_dentry_info *unionfs_parse_options(
 
 	/* allocate private data area */
 	err = -ENOMEM;
-	hidden_root_info =
+	lower_root_info =
 		kzalloc(sizeof(struct unionfs_dentry_info), GFP_KERNEL);
-	if (!hidden_root_info)
+	if (!lower_root_info)
 		goto out_error;
-	hidden_root_info->bstart = -1;
-	hidden_root_info->bend = -1;
-	hidden_root_info->bopaque = -1;
+	lower_root_info->bstart = -1;
+	lower_root_info->bend = -1;
+	lower_root_info->bopaque = -1;
 
 	while ((optname = strsep(&options, ",")) != NULL) {
 		char *optarg;
@@ -482,7 +482,7 @@ static struct unionfs_dentry_info *unionfs_parse_options(
 				err = -EINVAL;
 				goto out_error;
 			}
-			err = parse_dirs_option(sb, hidden_root_info, optarg);
+			err = parse_dirs_option(sb, lower_root_info, optarg);
 			if (err)
 				goto out_error;
 			continue;
@@ -511,15 +511,15 @@ static struct unionfs_dentry_info *unionfs_parse_options(
 	goto out;
 
 out_error:
-	if (hidden_root_info && hidden_root_info->lower_paths) {
-		for (bindex = hidden_root_info->bstart;
-		     bindex >= 0 && bindex <= hidden_root_info->bend;
+	if (lower_root_info && lower_root_info->lower_paths) {
+		for (bindex = lower_root_info->bstart;
+		     bindex >= 0 && bindex <= lower_root_info->bend;
 		     bindex++) {
 			struct dentry *d;
 			struct vfsmount *m;
 
-			d = hidden_root_info->lower_paths[bindex].dentry;
-			m = hidden_root_info->lower_paths[bindex].mnt;
+			d = lower_root_info->lower_paths[bindex].dentry;
+			m = lower_root_info->lower_paths[bindex].mnt;
 
 			dput(d);
 			/* initializing: can't use unionfs_mntput here */
@@ -527,15 +527,15 @@ out_error:
 		}
 	}
 
-	kfree(hidden_root_info->lower_paths);
-	kfree(hidden_root_info);
+	kfree(lower_root_info->lower_paths);
+	kfree(lower_root_info);
 
 	kfree(UNIONFS_SB(sb)->data);
 	UNIONFS_SB(sb)->data = NULL;
 
-	hidden_root_info = ERR_PTR(err);
+	lower_root_info = ERR_PTR(err);
 out:
-	return hidden_root_info;
+	return lower_root_info;
 }
 
 /*
@@ -565,7 +565,7 @@ static int unionfs_read_super(struct super_block *sb, void *raw_data,
 			      int silent)
 {
 	int err = 0;
-	struct unionfs_dentry_info *hidden_root_info = NULL;
+	struct unionfs_dentry_info *lower_root_info = NULL;
 	int bindex, bstart, bend;
 
 	if (!raw_data) {
@@ -588,28 +588,28 @@ static int unionfs_read_super(struct super_block *sb, void *raw_data,
 	init_rwsem(&UNIONFS_SB(sb)->rwsem);
 	UNIONFS_SB(sb)->high_branch_id = -1; /* -1 == invalid branch ID */
 
-	hidden_root_info = unionfs_parse_options(sb, raw_data);
-	if (IS_ERR(hidden_root_info)) {
+	lower_root_info = unionfs_parse_options(sb, raw_data);
+	if (IS_ERR(lower_root_info)) {
 		printk(KERN_WARNING
 		       "unionfs: read_super: error while parsing options "
-		       "(err = %ld)\n", PTR_ERR(hidden_root_info));
-		err = PTR_ERR(hidden_root_info);
-		hidden_root_info = NULL;
+		       "(err = %ld)\n", PTR_ERR(lower_root_info));
+		err = PTR_ERR(lower_root_info);
+		lower_root_info = NULL;
 		goto out_free;
 	}
-	if (hidden_root_info->bstart == -1) {
+	if (lower_root_info->bstart == -1) {
 		err = -ENOENT;
 		goto out_free;
 	}
 
-	/* set the hidden superblock field of upper superblock */
-	bstart = hidden_root_info->bstart;
+	/* set the lower superblock field of upper superblock */
+	bstart = lower_root_info->bstart;
 	BUG_ON(bstart != 0);
-	sbend(sb) = bend = hidden_root_info->bend;
+	sbend(sb) = bend = lower_root_info->bend;
 	for (bindex = bstart; bindex <= bend; bindex++) {
 		struct dentry *d;
 
-		d = hidden_root_info->lower_paths[bindex].dentry;
+		d = lower_root_info->lower_paths[bindex].dentry;
 
 		unionfs_write_lock(sb);
 		unionfs_set_lower_super_idx(sb, bindex, d->d_sb);
@@ -635,13 +635,13 @@ static int unionfs_read_super(struct super_block *sb, void *raw_data,
 	if ((err = new_dentry_private_data(sb->s_root)))
 		goto out_freedpd;
 
-	/* Set the hidden dentries for s_root */
+	/* Set the lower dentries for s_root */
 	for (bindex = bstart; bindex <= bend; bindex++) {
 		struct dentry *d;
 		struct vfsmount *m;
 
-		d = hidden_root_info->lower_paths[bindex].dentry;
-		m = hidden_root_info->lower_paths[bindex].mnt;
+		d = lower_root_info->lower_paths[bindex].dentry;
+		m = lower_root_info->lower_paths[bindex].mnt;
 
 		unionfs_set_lower_dentry_idx(sb->s_root, bindex, d);
 		unionfs_set_lower_mnt_idx(sb->s_root, bindex, m);
@@ -670,22 +670,22 @@ out_freedpd:
 	dput(sb->s_root);
 
 out_dput:
-	if (hidden_root_info && !IS_ERR(hidden_root_info)) {
-		for (bindex = hidden_root_info->bstart;
-		     bindex <= hidden_root_info->bend; bindex++) {
+	if (lower_root_info && !IS_ERR(lower_root_info)) {
+		for (bindex = lower_root_info->bstart;
+		     bindex <= lower_root_info->bend; bindex++) {
 			struct dentry *d;
 			struct vfsmount *m;
 
-			d = hidden_root_info->lower_paths[bindex].dentry;
-			m = hidden_root_info->lower_paths[bindex].mnt;
+			d = lower_root_info->lower_paths[bindex].dentry;
+			m = lower_root_info->lower_paths[bindex].mnt;
 
 			dput(d);
 			/* initializing: can't use unionfs_mntput here */
 			mntput(m);
 		}
-		kfree(hidden_root_info->lower_paths);
-		kfree(hidden_root_info);
-		hidden_root_info = NULL;
+		kfree(lower_root_info->lower_paths);
+		kfree(lower_root_info);
+		lower_root_info = NULL;
 	}
 
 out_free:
@@ -694,9 +694,9 @@ out_free:
 	sb->s_fs_info = NULL;
 
 out:
-	if (hidden_root_info && !IS_ERR(hidden_root_info)) {
-		kfree(hidden_root_info->lower_paths);
-		kfree(hidden_root_info);
+	if (lower_root_info && !IS_ERR(lower_root_info)) {
+		kfree(lower_root_info->lower_paths);
+		kfree(lower_root_info);
 	}
 	return err;
 }
diff --git a/fs/unionfs/rdstate.c b/fs/unionfs/rdstate.c
index f0525ff..06ad5a8 100644
--- a/fs/unionfs/rdstate.c
+++ b/fs/unionfs/rdstate.c
@@ -64,7 +64,7 @@ void unionfs_destroy_filldir_cache(void)
 #define MINHASHSIZE 1
 static int guesstimate_hash_size(struct inode *inode)
 {
-	struct inode *hidden_inode;
+	struct inode *lower_inode;
 	int bindex;
 	int hashsize = MINHASHSIZE;
 
@@ -72,13 +72,13 @@ static int guesstimate_hash_size(struct inode *inode)
 		return UNIONFS_I(inode)->hashsize;
 
 	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
-		if (!(hidden_inode = unionfs_lower_inode_idx(inode, bindex)))
+		if (!(lower_inode = unionfs_lower_inode_idx(inode, bindex)))
 			continue;
 
-		if (hidden_inode->i_size == DENTPAGE)
+		if (lower_inode->i_size == DENTPAGE)
 			hashsize += DENTPERONEPAGE;
 		else
-			hashsize += (hidden_inode->i_size / DENTPAGE) *
+			hashsize += (lower_inode->i_size / DENTPAGE) *
 				DENTPERPAGE;
 	}
 
diff --git a/fs/unionfs/rename.c b/fs/unionfs/rename.c
index 3e58425..095aa5a 100644
--- a/fs/unionfs/rename.c
+++ b/fs/unionfs/rename.c
@@ -23,27 +23,27 @@ static int __unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 			    int bindex, struct dentry **wh_old)
 {
 	int err = 0;
-	struct dentry *hidden_old_dentry;
-	struct dentry *hidden_new_dentry;
-	struct dentry *hidden_old_dir_dentry;
-	struct dentry *hidden_new_dir_dentry;
-	struct dentry *hidden_wh_dentry;
-	struct dentry *hidden_wh_dir_dentry;
+	struct dentry *lower_old_dentry;
+	struct dentry *lower_new_dentry;
+	struct dentry *lower_old_dir_dentry;
+	struct dentry *lower_new_dir_dentry;
+	struct dentry *lower_wh_dentry;
+	struct dentry *lower_wh_dir_dentry;
 	char *wh_name = NULL;
 
-	hidden_new_dentry = unionfs_lower_dentry_idx(new_dentry, bindex);
-	hidden_old_dentry = unionfs_lower_dentry_idx(old_dentry, bindex);
+	lower_new_dentry = unionfs_lower_dentry_idx(new_dentry, bindex);
+	lower_old_dentry = unionfs_lower_dentry_idx(old_dentry, bindex);
 
-	if (!hidden_new_dentry) {
-		hidden_new_dentry =
+	if (!lower_new_dentry) {
+		lower_new_dentry =
 			create_parents(new_dentry->d_parent->d_inode,
 				       new_dentry, new_dentry->d_name.name,
 				       bindex);
-		if (IS_ERR(hidden_new_dentry)) {
+		if (IS_ERR(lower_new_dentry)) {
 			printk(KERN_DEBUG "unionfs: error creating directory "
 			       "tree for rename, bindex = %d, err = %ld\n",
-			       bindex, PTR_ERR(hidden_new_dentry));
-			err = PTR_ERR(hidden_new_dentry);
+			       bindex, PTR_ERR(lower_new_dentry));
+			err = PTR_ERR(lower_new_dentry);
 			goto out;
 		}
 	}
@@ -55,42 +55,42 @@ static int __unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		goto out;
 	}
 
-	hidden_wh_dentry = lookup_one_len(wh_name, hidden_new_dentry->d_parent,
-					  new_dentry->d_name.len +
-					  UNIONFS_WHLEN);
-	if (IS_ERR(hidden_wh_dentry)) {
-		err = PTR_ERR(hidden_wh_dentry);
+	lower_wh_dentry = lookup_one_len(wh_name, lower_new_dentry->d_parent,
+					 new_dentry->d_name.len +
+					 UNIONFS_WHLEN);
+	if (IS_ERR(lower_wh_dentry)) {
+		err = PTR_ERR(lower_wh_dentry);
 		goto out;
 	}
 
-	if (hidden_wh_dentry->d_inode) {
+	if (lower_wh_dentry->d_inode) {
 		/* get rid of the whiteout that is existing */
-		if (hidden_new_dentry->d_inode) {
+		if (lower_new_dentry->d_inode) {
 			printk(KERN_WARNING "unionfs: both a whiteout and a "
 			       "dentry exist when doing a rename!\n");
 			err = -EIO;
 
-			dput(hidden_wh_dentry);
+			dput(lower_wh_dentry);
 			goto out;
 		}
 
-		hidden_wh_dir_dentry = lock_parent(hidden_wh_dentry);
+		lower_wh_dir_dentry = lock_parent(lower_wh_dentry);
 		if (!(err = is_robranch_super(old_dentry->d_sb, bindex)))
-			err = vfs_unlink(hidden_wh_dir_dentry->d_inode,
-					 hidden_wh_dentry);
+			err = vfs_unlink(lower_wh_dir_dentry->d_inode,
+					 lower_wh_dentry);
 
-		dput(hidden_wh_dentry);
-		unlock_dir(hidden_wh_dir_dentry);
+		dput(lower_wh_dentry);
+		unlock_dir(lower_wh_dir_dentry);
 		if (err)
 			goto out;
 	} else
-		dput(hidden_wh_dentry);
+		dput(lower_wh_dentry);
 
-	dget(hidden_old_dentry);
-	hidden_old_dir_dentry = dget_parent(hidden_old_dentry);
-	hidden_new_dir_dentry = dget_parent(hidden_new_dentry);
+	dget(lower_old_dentry);
+	lower_old_dir_dentry = dget_parent(lower_old_dentry);
+	lower_new_dir_dentry = dget_parent(lower_new_dentry);
 
-	lock_rename(hidden_old_dir_dentry, hidden_new_dir_dentry);
+	lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
 
 	err = is_robranch_super(old_dentry->d_sb, bindex);
 	if (err)
@@ -107,7 +107,7 @@ static int __unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		err = PTR_ERR(whname);
 		if (IS_ERR(whname))
 			goto out_unlock;
-		*wh_old = lookup_one_len(whname, hidden_old_dir_dentry,
+		*wh_old = lookup_one_len(whname, lower_old_dir_dentry,
 					 old_dentry->d_name.len +
 					 UNIONFS_WHLEN);
 		kfree(whname);
@@ -118,15 +118,15 @@ static int __unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		}
 	}
 
-	err = vfs_rename(hidden_old_dir_dentry->d_inode, hidden_old_dentry,
-			 hidden_new_dir_dentry->d_inode, hidden_new_dentry);
+	err = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,
+			 lower_new_dir_dentry->d_inode, lower_new_dentry);
 
 out_unlock:
-	unlock_rename(hidden_old_dir_dentry, hidden_new_dir_dentry);
+	unlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
 
-	dput(hidden_old_dir_dentry);
-	dput(hidden_new_dir_dentry);
-	dput(hidden_old_dentry);
+	dput(lower_old_dir_dentry);
+	dput(lower_new_dir_dentry);
+	dput(lower_old_dentry);
 
 out:
 	if (!err) {
@@ -254,12 +254,12 @@ static int do_unionfs_rename(struct inode *old_dir,
 	 * (2) We did a copy_up
 	 */
 	if ((old_bstart != old_bend) || (do_copyup != -1)) {
-		struct dentry *hidden_parent;
+		struct dentry *lower_parent;
 		BUG_ON(!wh_old || wh_old->d_inode || bwh_old < 0);
-		hidden_parent = lock_parent(wh_old);
-		local_err = vfs_create(hidden_parent->d_inode, wh_old, S_IRUGO,
+		lower_parent = lock_parent(wh_old);
+		local_err = vfs_create(lower_parent->d_inode, wh_old, S_IRUGO,
 				       NULL);
-		unlock_dir(hidden_parent);
+		unlock_dir(lower_parent);
 		if (!local_err)
 			set_dbopaque(old_dentry, bwh_old);
 		else {
@@ -279,14 +279,14 @@ out:
 
 revert:
 	/* Do revert here. */
-	local_err = unionfs_refresh_hidden_dentry(new_dentry, old_bstart);
+	local_err = unionfs_refresh_lower_dentry(new_dentry, old_bstart);
 	if (local_err) {
 		printk(KERN_WARNING "unionfs: revert failed in rename: "
 		       "the new refresh failed.\n");
 		eio = -EIO;
 	}
 
-	local_err = unionfs_refresh_hidden_dentry(old_dentry, old_bstart);
+	local_err = unionfs_refresh_lower_dentry(old_dentry, old_bstart);
 	if (local_err) {
 		printk(KERN_WARNING "unionfs: revert failed in rename: "
 		       "the old refresh failed.\n");
@@ -319,10 +319,10 @@ revert:
 		eio = -EIO;
 	}
 
-	local_err = unionfs_refresh_hidden_dentry(new_dentry, bindex);
+	local_err = unionfs_refresh_lower_dentry(new_dentry, bindex);
 	if (local_err)
 		eio = -EIO;
-	local_err = unionfs_refresh_hidden_dentry(old_dentry, bindex);
+	local_err = unionfs_refresh_lower_dentry(old_dentry, bindex);
 	if (local_err)
 		eio = -EIO;
 
@@ -336,7 +336,7 @@ static struct dentry *lookup_whiteout(struct dentry *dentry)
 {
 	char *whname;
 	int bindex = -1, bstart = -1, bend = -1;
-	struct dentry *parent, *hidden_parent, *wh_dentry;
+	struct dentry *parent, *lower_parent, *wh_dentry;
 
 	whname = alloc_whname(dentry->d_name.name, dentry->d_name.len);
 	if (IS_ERR(whname))
@@ -348,10 +348,10 @@ static struct dentry *lookup_whiteout(struct dentry *dentry)
 	bend = dbend(parent);
 	wh_dentry = ERR_PTR(-ENOENT);
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_parent = unionfs_lower_dentry_idx(parent, bindex);
-		if (!hidden_parent)
+		lower_parent = unionfs_lower_dentry_idx(parent, bindex);
+		if (!lower_parent)
 			continue;
-		wh_dentry = lookup_one_len(whname, hidden_parent,
+		wh_dentry = lookup_one_len(whname, lower_parent,
 					   dentry->d_name.len + UNIONFS_WHLEN);
 		if (IS_ERR(wh_dentry))
 			continue;
@@ -426,7 +426,7 @@ int unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		goto out;
 
 	/*
-	 * if new_dentry is already hidden because of whiteout,
+	 * if new_dentry is already lower because of whiteout,
 	 * simply override it even if the whited-out dir is not empty.
 	 */
 	wh_dentry = lookup_whiteout(new_dentry);
@@ -466,7 +466,7 @@ out:
 	else {
 		/*
 		 * force re-lookup since the dir on ro branch is not renamed,
-		 * and hidden dentries still indicate the un-renamed ones.
+		 * and lower dentries still indicate the un-renamed ones.
 		 */
 		if (S_ISDIR(old_dentry->d_inode->i_mode))
 			atomic_dec(&UNIONFS_D(old_dentry)->generation);
diff --git a/fs/unionfs/subr.c b/fs/unionfs/subr.c
index 3a23ec0..4c18b3a 100644
--- a/fs/unionfs/subr.c
+++ b/fs/unionfs/subr.c
@@ -26,9 +26,9 @@
 int create_whiteout(struct dentry *dentry, int start)
 {
 	int bstart, bend, bindex;
-	struct dentry *hidden_dir_dentry;
-	struct dentry *hidden_dentry;
-	struct dentry *hidden_wh_dentry;
+	struct dentry *lower_dir_dentry;
+	struct dentry *lower_dentry;
+	struct dentry *lower_wh_dentry;
 	char *name = NULL;
 	int err = -EINVAL;
 
@@ -45,51 +45,51 @@ int create_whiteout(struct dentry *dentry, int start)
 	}
 
 	for (bindex = start; bindex >= 0; bindex--) {
-		hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
 
-		if (!hidden_dentry) {
+		if (!lower_dentry) {
 			/*
-			 * if hidden dentry is not present, create the
-			 * entire hidden dentry directory structure and go
+			 * if lower dentry is not present, create the
+			 * entire lower dentry directory structure and go
 			 * ahead.  Since we want to just create whiteout, we
 			 * only want the parent dentry, and hence get rid of
 			 * this dentry.
 			 */
-			hidden_dentry = create_parents(dentry->d_inode,
-						       dentry,
-						       dentry->d_name.name,
-						       bindex);
-			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
+			lower_dentry = create_parents(dentry->d_inode,
+						      dentry,
+						      dentry->d_name.name,
+						      bindex);
+			if (!lower_dentry || IS_ERR(lower_dentry)) {
 				printk(KERN_DEBUG "unionfs: create_parents "
 				       "failed for bindex = %d\n", bindex);
 				continue;
 			}
 		}
 
-		hidden_wh_dentry =
-			lookup_one_len(name, hidden_dentry->d_parent,
+		lower_wh_dentry =
+			lookup_one_len(name, lower_dentry->d_parent,
 				       dentry->d_name.len + UNIONFS_WHLEN);
-		if (IS_ERR(hidden_wh_dentry))
+		if (IS_ERR(lower_wh_dentry))
 			continue;
 
 		/*
 		 * The whiteout already exists. This used to be impossible,
 		 * but now is possible because of opaqueness.
 		 */
-		if (hidden_wh_dentry->d_inode) {
-			dput(hidden_wh_dentry);
+		if (lower_wh_dentry->d_inode) {
+			dput(lower_wh_dentry);
 			err = 0;
 			goto out;
 		}
 
-		hidden_dir_dentry = lock_parent(hidden_wh_dentry);
+		lower_dir_dentry = lock_parent(lower_wh_dentry);
 		if (!(err = is_robranch_super(dentry->d_sb, bindex)))
-			err = vfs_create(hidden_dir_dentry->d_inode,
-					 hidden_wh_dentry,
+			err = vfs_create(lower_dir_dentry->d_inode,
+					 lower_wh_dentry,
 					 ~current->fs->umask & S_IRWXUGO,
 					 NULL);
-		unlock_dir(hidden_dir_dentry);
-		dput(hidden_wh_dentry);
+		unlock_dir(lower_dir_dentry);
+		dput(lower_wh_dentry);
 
 		if (!err || !IS_COPYUP_ERR(err))
 			break;
@@ -108,24 +108,24 @@ out:
  * This is a helper function for rename, which ends up with hosed over
  * dentries when it needs to revert.
  */
-int unionfs_refresh_hidden_dentry(struct dentry *dentry, int bindex)
+int unionfs_refresh_lower_dentry(struct dentry *dentry, int bindex)
 {
-	struct dentry *hidden_dentry;
-	struct dentry *hidden_parent;
+	struct dentry *lower_dentry;
+	struct dentry *lower_parent;
 	int err = 0;
 
 	verify_locked(dentry);
 
 	unionfs_lock_dentry(dentry->d_parent);
-	hidden_parent = unionfs_lower_dentry_idx(dentry->d_parent, bindex);
+	lower_parent = unionfs_lower_dentry_idx(dentry->d_parent, bindex);
 	unionfs_unlock_dentry(dentry->d_parent);
 
-	BUG_ON(!S_ISDIR(hidden_parent->d_inode->i_mode));
+	BUG_ON(!S_ISDIR(lower_parent->d_inode->i_mode));
 
-	hidden_dentry = lookup_one_len(dentry->d_name.name, hidden_parent,
-				       dentry->d_name.len);
-	if (IS_ERR(hidden_dentry)) {
-		err = PTR_ERR(hidden_dentry);
+	lower_dentry = lookup_one_len(dentry->d_name.name, lower_parent,
+				      dentry->d_name.len);
+	if (IS_ERR(lower_dentry)) {
+		err = PTR_ERR(lower_dentry);
 		goto out;
 	}
 
@@ -133,13 +133,13 @@ int unionfs_refresh_hidden_dentry(struct dentry *dentry, int bindex)
 	iput(unionfs_lower_inode_idx(dentry->d_inode, bindex));
 	unionfs_set_lower_inode_idx(dentry->d_inode, bindex, NULL);
 
-	if (!hidden_dentry->d_inode) {
-		dput(hidden_dentry);
+	if (!lower_dentry->d_inode) {
+		dput(lower_dentry);
 		unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
 	} else {
-		unionfs_set_lower_dentry_idx(dentry, bindex, hidden_dentry);
+		unionfs_set_lower_dentry_idx(dentry, bindex, lower_dentry);
 		unionfs_set_lower_inode_idx(dentry->d_inode, bindex,
-					    igrab(hidden_dentry->d_inode));
+					    igrab(lower_dentry->d_inode));
 	}
 
 out:
@@ -149,16 +149,16 @@ out:
 int make_dir_opaque(struct dentry *dentry, int bindex)
 {
 	int err = 0;
-	struct dentry *hidden_dentry, *diropq;
-	struct inode *hidden_dir;
+	struct dentry *lower_dentry, *diropq;
+	struct inode *lower_dir;
 
-	hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-	hidden_dir = hidden_dentry->d_inode;
+	lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+	lower_dir = lower_dentry->d_inode;
 	BUG_ON(!S_ISDIR(dentry->d_inode->i_mode) ||
-	       !S_ISDIR(hidden_dir->i_mode));
+	       !S_ISDIR(lower_dir->i_mode));
 
-	mutex_lock(&hidden_dir->i_mutex);
-	diropq = lookup_one_len(UNIONFS_DIR_OPAQUE, hidden_dentry,
+	mutex_lock(&lower_dir->i_mutex);
+	diropq = lookup_one_len(UNIONFS_DIR_OPAQUE, lower_dentry,
 				sizeof(UNIONFS_DIR_OPAQUE) - 1);
 	if (IS_ERR(diropq)) {
 		err = PTR_ERR(diropq);
@@ -166,14 +166,14 @@ int make_dir_opaque(struct dentry *dentry, int bindex)
 	}
 
 	if (!diropq->d_inode)
-		err = vfs_create(hidden_dir, diropq, S_IRUGO, NULL);
+		err = vfs_create(lower_dir, diropq, S_IRUGO, NULL);
 	if (!err)
 		set_dbopaque(dentry, bindex);
 
 	dput(diropq);
 
 out:
-	mutex_unlock(&hidden_dir->i_mutex);
+	mutex_unlock(&lower_dir->i_mutex);
 	return err;
 }
 
@@ -186,7 +186,7 @@ int unionfs_get_nlinks(struct inode *inode)
 	int sum_nlinks = 0;
 	int dirs = 0;
 	int bindex;
-	struct inode *hidden_inode;
+	struct inode *lower_inode;
 
 	/* don't bother to do all the work since we're unlinked */
 	if (inode->i_nlink == 0)
@@ -196,16 +196,16 @@ int unionfs_get_nlinks(struct inode *inode)
 		return unionfs_lower_inode(inode)->i_nlink;
 
 	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
-		hidden_inode = unionfs_lower_inode_idx(inode, bindex);
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
 
 		/* ignore files */
-		if (!hidden_inode || !S_ISDIR(hidden_inode->i_mode))
+		if (!lower_inode || !S_ISDIR(lower_inode->i_mode))
 			continue;
 
-		BUG_ON(hidden_inode->i_nlink < 0);
+		BUG_ON(lower_inode->i_nlink < 0);
 
 		/* A deleted directory. */
-		if (hidden_inode->i_nlink == 0)
+		if (lower_inode->i_nlink == 0)
 			continue;
 		dirs++;
 
@@ -215,10 +215,10 @@ int unionfs_get_nlinks(struct inode *inode)
 		 * Some filesystems don't properly set the number of links
 		 * on empty directories
 		 */
-		if (hidden_inode->i_nlink == 1)
+		if (lower_inode->i_nlink == 1)
 			sum_nlinks += 2;
 		else
-			sum_nlinks += (hidden_inode->i_nlink - 2);
+			sum_nlinks += (lower_inode->i_nlink - 2);
 	}
 
 	return (!dirs ? 0 : sum_nlinks + 2);
diff --git a/fs/unionfs/super.c b/fs/unionfs/super.c
index c5c0933..7056f7b 100644
--- a/fs/unionfs/super.c
+++ b/fs/unionfs/super.c
@@ -191,7 +191,7 @@ static noinline int do_remount_mode_option(char *optarg, int cur_branches,
 	err = path_lookup(optarg, LOOKUP_FOLLOW, &nd);
 	if (err) {
 		printk(KERN_WARNING "unionfs: error accessing "
-		       "hidden directory \"%s\" (error %d)\n",
+		       "lower directory \"%s\" (error %d)\n",
 		       optarg, err);
 		goto out;
 	}
@@ -234,7 +234,7 @@ static noinline int do_remount_del_option(char *optarg, int cur_branches,
 	err = path_lookup(optarg, LOOKUP_FOLLOW, &nd);
 	if (err) {
 		printk(KERN_WARNING "unionfs: error accessing "
-		       "hidden directory \"%s\" (error %d)\n",
+		       "lower directory \"%s\" (error %d)\n",
 		       optarg, err);
 		goto out;
 	}
@@ -318,7 +318,7 @@ static noinline int do_remount_add_option(char *optarg, int cur_branches,
 	err = path_lookup(optarg, LOOKUP_FOLLOW, &nd);
 	if (err) {
 		printk(KERN_WARNING "unionfs: error accessing "
-		       "hidden directory \"%s\" (error %d)\n",
+		       "lower directory \"%s\" (error %d)\n",
 		       optarg, err);
 		goto out;
 	}
@@ -354,7 +354,7 @@ found_insertion_point:
 	err = path_lookup(new_branch, LOOKUP_FOLLOW, &nd);
 	if (err) {
 		printk(KERN_WARNING "unionfs: error accessing "
-		       "hidden directory \"%s\" (error %d)\n",
+		       "lower directory \"%s\" (error %d)\n",
 		       new_branch, err);
 		goto out;
 	}
@@ -366,7 +366,7 @@ found_insertion_point:
 	 * code base supports that correctly.
 	 */
 	if ((err = check_branch(&nd))) {
-		printk(KERN_WARNING "unionfs: hidden directory "
+		printk(KERN_WARNING "unionfs: lower directory "
 		       "\"%s\" is not a valid branch\n", optarg);
 		path_release(&nd);
 		goto out;
@@ -513,7 +513,7 @@ static int unionfs_remount_fs(struct super_block *sb, int *flags,
 	 * and then free the temps (done near the end of this function).
 	 */
 	max_branches = cur_branches + add_branches;
-	/* allocate space for new pointers to hidden dentry */
+	/* allocate space for new pointers to lower dentry */
 	tmp_data = kcalloc(max_branches,
 			   sizeof(struct unionfs_data), GFP_KERNEL);
 	if (!tmp_data) {
@@ -654,7 +654,7 @@ out_no_change:
 		goto out_release;
 	}
 
-	/* (re)allocate space for new pointers to hidden dentry */
+	/* (re)allocate space for new pointers to lower dentry */
 	size = new_branches * sizeof(struct unionfs_data);
 	new_data = krealloc(tmp_data, size, GFP_KERNEL);
 	if (!new_data) {
@@ -796,7 +796,7 @@ out_error:
 static void unionfs_clear_inode(struct inode *inode)
 {
 	int bindex, bstart, bend;
-	struct inode *hidden_inode;
+	struct inode *lower_inode;
 	struct list_head *pos, *n;
 	struct unionfs_dir_state *rdstate;
 
@@ -807,17 +807,17 @@ static void unionfs_clear_inode(struct inode *inode)
 	}
 
 	/*
-	 * Decrement a reference to a hidden_inode, which was incremented
+	 * Decrement a reference to a lower_inode, which was incremented
 	 * by our read_inode when it was created initially.
 	 */
 	bstart = ibstart(inode);
 	bend = ibend(inode);
 	if (bstart >= 0) {
 		for (bindex = bstart; bindex <= bend; bindex++) {
-			hidden_inode = unionfs_lower_inode_idx(inode, bindex);
-			if (!hidden_inode)
+			lower_inode = unionfs_lower_inode_idx(inode, bindex);
+			if (!lower_inode)
 				continue;
-			iput(hidden_inode);
+			iput(lower_inode);
 		}
 	}
 
@@ -903,8 +903,8 @@ static int unionfs_write_inode(struct inode *inode, int sync)
  */
 static void unionfs_umount_begin(struct vfsmount *mnt, int flags)
 {
-	struct super_block *sb, *hidden_sb;
-	struct vfsmount *hidden_mnt;
+	struct super_block *sb, *lower_sb;
+	struct vfsmount *lower_mnt;
 	int bindex, bstart, bend;
 
 	if (!(flags & MNT_FORCE))
@@ -919,14 +919,14 @@ static void unionfs_umount_begin(struct vfsmount *mnt, int flags)
 	bstart = sbstart(sb);
 	bend = sbend(sb);
 	for (bindex = bstart; bindex <= bend; bindex++) {
-		hidden_mnt = unionfs_lower_mnt_idx(sb->s_root, bindex);
+		lower_mnt = unionfs_lower_mnt_idx(sb->s_root, bindex);
 		unionfs_read_lock(sb);
-		hidden_sb = unionfs_lower_super_idx(sb, bindex);
+		lower_sb = unionfs_lower_super_idx(sb, bindex);
 		unionfs_read_unlock(sb);
 
-		if (hidden_mnt && hidden_sb && hidden_sb->s_op &&
-		    hidden_sb->s_op->umount_begin)
-			hidden_sb->s_op->umount_begin(hidden_mnt, flags);
+		if (lower_mnt && lower_sb && lower_sb->s_op &&
+		    lower_sb->s_op->umount_begin)
+			lower_sb->s_op->umount_begin(lower_mnt, flags);
 	}
 }
 
diff --git a/fs/unionfs/union.h b/fs/unionfs/union.h
index 37a53fd..6cd3207 100644
--- a/fs/unionfs/union.h
+++ b/fs/unionfs/union.h
@@ -97,7 +97,7 @@ struct unionfs_inode_info {
 	int hashsize;
 	int cookie;
 
-	/* The hidden inodes */
+	/* The lower inodes */
 	struct inode **lower_inodes;
 	/* to keep track of reads/writes for unlinks before closes */
 	atomic_t totalopens;
@@ -274,7 +274,7 @@ extern void unionfs_inherit_mnt(struct dentry *dentry);
 extern void unionfs_purge_extras(struct dentry *dentry);
 
 extern int remove_whiteouts(struct dentry *dentry,
-			    struct dentry *hidden_dentry, int bindex);
+			    struct dentry *lower_dentry, int bindex);
 
 extern int do_delete_whiteouts(struct dentry *dentry, int bindex,
 			       struct unionfs_dir_state *namelist);
@@ -288,8 +288,8 @@ extern int check_empty(struct dentry *dentry,
 extern int delete_whiteouts(struct dentry *dentry, int bindex,
 			    struct unionfs_dir_state *namelist);
 
-/* Re-lookup a hidden dentry. */
-extern int unionfs_refresh_hidden_dentry(struct dentry *dentry, int bindex);
+/* Re-lookup a lower dentry. */
+extern int unionfs_refresh_lower_dentry(struct dentry *dentry, int bindex);
 
 extern void unionfs_reinterpose(struct dentry *this_dentry);
 extern struct super_block *unionfs_duplicate_super(struct super_block *sb);
@@ -525,13 +525,13 @@ static inline void unionfs_mntput(struct dentry *dentry, int bindex)
 /* useful for tracking code reachability */
 #define UDBG printk("DBG:%s:%s:%d\n",__FILE__,__FUNCTION__,__LINE__)
 
-#define unionfs_check_inode(i)	__unionfs_check_inode((i),\
+#define unionfs_check_inode(i)	__unionfs_check_inode((i),	\
 	__FILE__,__FUNCTION__,__LINE__)
-#define unionfs_check_dentry(d)	__unionfs_check_dentry((d),\
+#define unionfs_check_dentry(d)	__unionfs_check_dentry((d),	\
 	__FILE__,__FUNCTION__,__LINE__)
-#define unionfs_check_file(f)	__unionfs_check_file((f),\
+#define unionfs_check_file(f)	__unionfs_check_file((f),	\
 	__FILE__,__FUNCTION__,__LINE__)
-#define show_branch_counts(sb)	__show_branch_counts((sb),\
+#define show_branch_counts(sb)	__show_branch_counts((sb),	\
 	__FILE__,__FUNCTION__,__LINE__)
 extern void __unionfs_check_inode(const struct inode *inode, const char *fname,
 				  const char *fxn, int line);
diff --git a/fs/unionfs/unlink.c b/fs/unionfs/unlink.c
index 69233cc..5d35994 100644
--- a/fs/unionfs/unlink.c
+++ b/fs/unionfs/unlink.c
@@ -21,8 +21,8 @@
 /* unlink a file by creating a whiteout */
 static int unionfs_unlink_whiteout(struct inode *dir, struct dentry *dentry)
 {
-	struct dentry *hidden_dentry;
-	struct dentry *hidden_dir_dentry;
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry;
 	int bindex;
 	int err = 0;
 
@@ -31,19 +31,19 @@ static int unionfs_unlink_whiteout(struct inode *dir, struct dentry *dentry)
 
 	bindex = dbstart(dentry);
 
-	hidden_dentry = unionfs_lower_dentry_idx(dentry, bindex);
-	if (!hidden_dentry)
+	lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+	if (!lower_dentry)
 		goto out;
 
-	hidden_dir_dentry = lock_parent(hidden_dentry);
+	lower_dir_dentry = lock_parent(lower_dentry);
 
-	/* avoid destroying the hidden inode if the file is in use */
-	dget(hidden_dentry);
+	/* avoid destroying the lower inode if the file is in use */
+	dget(lower_dentry);
 	if (!(err = is_robranch_super(dentry->d_sb, bindex)))
-		err = vfs_unlink(hidden_dir_dentry->d_inode, hidden_dentry);
-	dput(hidden_dentry);
-	fsstack_copy_attr_times(dir, hidden_dir_dentry->d_inode);
-	unlock_dir(hidden_dir_dentry);
+		err = vfs_unlink(lower_dir_dentry->d_inode, lower_dentry);
+	dput(lower_dentry);
+	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
+	unlock_dir(lower_dir_dentry);
 
 	if (err && !IS_COPYUP_ERR(err))
 		goto out;
@@ -53,7 +53,7 @@ static int unionfs_unlink_whiteout(struct inode *dir, struct dentry *dentry)
 			goto out;
 		err = create_whiteout(dentry, dbstart(dentry) - 1);
 	} else if (dbopaque(dentry) != -1)
-		/* There is a hidden lower-priority file with the same name. */
+		/* There is a lower lower-priority file with the same name. */
 		err = create_whiteout(dentry, dbopaque(dentry));
 	else
 		err = create_whiteout(dentry, dbstart(dentry));
@@ -99,31 +99,31 @@ static int unionfs_rmdir_first(struct inode *dir, struct dentry *dentry,
 			       struct unionfs_dir_state *namelist)
 {
 	int err;
-	struct dentry *hidden_dentry;
-	struct dentry *hidden_dir_dentry = NULL;
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry = NULL;
 
 	/* Here we need to remove whiteout entries. */
 	err = delete_whiteouts(dentry, dbstart(dentry), namelist);
 	if (err)
 		goto out;
 
-	hidden_dentry = unionfs_lower_dentry(dentry);
+	lower_dentry = unionfs_lower_dentry(dentry);
 
-	hidden_dir_dentry = lock_parent(hidden_dentry);
+	lower_dir_dentry = lock_parent(lower_dentry);
 
-	/* avoid destroying the hidden inode if the file is in use */
-	dget(hidden_dentry);
+	/* avoid destroying the lower inode if the file is in use */
+	dget(lower_dentry);
 	if (!(err = is_robranch(dentry)))
-		err = vfs_rmdir(hidden_dir_dentry->d_inode, hidden_dentry);
-	dput(hidden_dentry);
+		err = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);
+	dput(lower_dentry);
 
-	fsstack_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
 	/* propagate number of hard-links */
 	dentry->d_inode->i_nlink = unionfs_get_nlinks(dentry->d_inode);
 
 out:
-	if (hidden_dir_dentry)
-		unlock_dir(hidden_dir_dentry);
+	if (lower_dir_dentry)
+		unlock_dir(lower_dir_dentry);
 	return err;
 }
 
diff --git a/fs/unionfs/xattr.c b/fs/unionfs/xattr.c
index bf8f1cf..02a87c5 100644
--- a/fs/unionfs/xattr.c
+++ b/fs/unionfs/xattr.c
@@ -54,7 +54,7 @@ void unionfs_xattr_free(void *ptr, size_t size)
 ssize_t unionfs_getxattr(struct dentry *dentry, const char *name, void *value,
 			 size_t size)
 {
-	struct dentry *hidden_dentry = NULL;
+	struct dentry *lower_dentry = NULL;
 	int err = -EOPNOTSUPP;
 
 	unionfs_lock_dentry(dentry);
@@ -64,9 +64,9 @@ ssize_t unionfs_getxattr(struct dentry *dentry, const char *name, void *value,
 		goto out;
 	}
 
-	hidden_dentry = unionfs_lower_dentry(dentry);
+	lower_dentry = unionfs_lower_dentry(dentry);
 
-	err = vfs_getxattr(hidden_dentry, (char*) name, value, size);
+	err = vfs_getxattr(lower_dentry, (char*) name, value, size);
 
 out:
 	unionfs_unlock_dentry(dentry);
@@ -81,7 +81,7 @@ out:
 int unionfs_setxattr(struct dentry *dentry, const char *name,
 		     const void *value, size_t size, int flags)
 {
-	struct dentry *hidden_dentry = NULL;
+	struct dentry *lower_dentry = NULL;
 	int err = -EOPNOTSUPP;
 
 	unionfs_lock_dentry(dentry);
@@ -91,9 +91,9 @@ int unionfs_setxattr(struct dentry *dentry, const char *name,
 		goto out;
 	}
 
-	hidden_dentry = unionfs_lower_dentry(dentry);
+	lower_dentry = unionfs_lower_dentry(dentry);
 
-	err = vfs_setxattr(hidden_dentry, (char*) name, (void*) value,
+	err = vfs_setxattr(lower_dentry, (char*) name, (void*) value,
 			   size, flags);
 
 out:
@@ -108,7 +108,7 @@ out:
  */
 int unionfs_removexattr(struct dentry *dentry, const char *name)
 {
-	struct dentry *hidden_dentry = NULL;
+	struct dentry *lower_dentry = NULL;
 	int err = -EOPNOTSUPP;
 
 	unionfs_lock_dentry(dentry);
@@ -118,9 +118,9 @@ int unionfs_removexattr(struct dentry *dentry, const char *name)
 		goto out;
 	}
 
-	hidden_dentry = unionfs_lower_dentry(dentry);
+	lower_dentry = unionfs_lower_dentry(dentry);
 
-	err = vfs_removexattr(hidden_dentry, (char*) name);
+	err = vfs_removexattr(lower_dentry, (char*) name);
 
 out:
 	unionfs_unlock_dentry(dentry);
@@ -134,7 +134,7 @@ out:
  */
 ssize_t unionfs_listxattr(struct dentry *dentry, char *list, size_t size)
 {
-	struct dentry *hidden_dentry = NULL;
+	struct dentry *lower_dentry = NULL;
 	int err = -EOPNOTSUPP;
 	char *encoded_list = NULL;
 
@@ -145,10 +145,10 @@ ssize_t unionfs_listxattr(struct dentry *dentry, char *list, size_t size)
 		goto out;
 	}
 
-	hidden_dentry = unionfs_lower_dentry(dentry);
+	lower_dentry = unionfs_lower_dentry(dentry);
 
 	encoded_list = list;
-	err = vfs_listxattr(hidden_dentry, encoded_list, size);
+	err = vfs_listxattr(lower_dentry, encoded_list, size);
 
 out:
 	unionfs_unlock_dentry(dentry);
-- 
1.5.4.3

